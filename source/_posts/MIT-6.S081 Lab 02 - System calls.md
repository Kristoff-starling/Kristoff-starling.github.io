---
layout: post
date: 2022-01-27
title: "MIT-6.S081 Lab 02: System calls"
categories: ["MIT-6.S081 Introduction to Operating Systems", "Lab Reports"]
tags: 
mathjax: true
---

## Progress

- [x] System call tracing (moderate)
- [x] Sysinfo (moderate)

<!-- more -->

## System call tracing (moderate)

该实验可以对 xv6 中系统调用的过程有一个大致的了解。

在 `/user/trace.c` 中，程序解析了 `trace()` 后的所有，将 trace 之后的那一个数字作为 trace 的参数，剩下的作为另外的一条命令调用 `exec()`。

`trace()` 函数是用 assembly 写的，由 `/user/usys.pl` 生成。`/user/usys.pl` 是一个脚本，内容如下：

```perl
#!/usr/bin/perl -w

# Generate usys.S, the stubs for syscalls.

print "# generated by usys.pl - do not edit\n";

print "#include \"kernel/syscall.h\"\n";

sub entry {
    my $name = shift;
    print ".global $name\n";
    print "${name}:\n";
    print " li a7, SYS_${name}\n";
    print " ecall\n";
    print " ret\n";
}
	
entry("fork");
entry("exit");
...
```

对于每一个系统调用，它会生成一个函数，将系统调用号 SYS_name 放到 `a7` 寄存器中，然后使用 `ecall` 陷入内核。根据 calling convention，剩下的系统调用参数放在 `a0` `a1` …… 寄存器中，因为和 `trace.c` 中准备参数的过程相同，所以不需要额外再做一次参数准备。

硬件提升完特权级后，根据 `stvec` 寄存器的值进行地址跳转，`stvec` 内保存的地址是 `/kernel/trampoline.S` 中的 `uservec`。`uservec` 是用 assembly 写的，保存了上下文，并跳转到 `/kernel/trap.c` 中的函数 `usertrap`。`usertrap` 根据 `scause` 寄存器的值，认定这是一个系统调用，于是转到 `/kernel/syscall.c` 中的函数 `syscall`。

`syscall` 根据 `a7` 寄存器的值获取系统调用号，并执行相应的系统调用服务程序（所有的服务程序都存在 syscalls[] 数组中）。

对于 `trace()` 系统调用来说，我们需要注册一个函数 `sys_trace()` 。xv6 提供了一系列函数来获取系统调用的参数（本质上是根据 calling convention 提取寄存器的值），`argint()` 用于获取值，`argaddr()` 用于获取地址，`argstr()` 用于获取字符串（本质上是对寄存器的值进行了不同的类型解释）。我们需要在 proc 结构体中新定义一个变量来存储 trace mask，将参数取出放进这个变量即可。

此外，在 `syscall` 中，每执行完一个系统调用准备返回时，我们要根据 trace mask 决定是否将其相关的信息打印。我们需要额外准备一个数组存储所有系统调用的名字，进程号可以通过 p->pid 获得。

根据讲义的定义，父进程 fork 出的子进程要继承 trace mask，因此需要修改一下 fork 函数的代码，将 p->tMask 复制给 np->tMask 即可。

## Sysinfo (moderate)

该实验与上一个实验的主要不同在于：

* `sysinfo(struct sysinfo *)` 系统调用需要将信息写回到 user space 的结构体中，因此需要从 kernel space 向 user space 复制信息，可以参考 `fstat()` 系统调用的实现来运用 `copyout()` 函数，由于目前还未实现虚拟存储相关细节，故不深究 `copyout()` 的具体原理。

* 当前进程的个数很好统计，进程信息保存在 `/kernel/proc.c` 的 proc[] 数组里，proc[] 数组的每个元素是一个 proc 结构体，只要结构体的 state 变量不是 UNUSED 就是一个当前的进程。

* 当前剩余的内存统计稍为复杂。xv6 实现了分页机制，`/kernel/kalloc.c` 负责物理内存的分配和释放。具体的组织形式和各个函数的意义见 Xv6 源码解读手册。

    要实现剩余内存的统计，我们只要数一数 freelist 链表中有多少个页面即可。可以每次现场数一遍，也可以维护一个变量，在 `kalloc()` 和 `kfree()` 的时候动态统计空闲页面的个数。
