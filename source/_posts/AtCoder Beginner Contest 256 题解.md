---
layout: post
date: 2022-06-22
title: "AtCoder Beginner Contest 256 题解"
categories:
tags: [AtCoder, 贪心, 动态规划, 矩阵乘法, 树状数组, 线段树]
mathjax: true
---

## A. 2^N

### 题面描述

* [传送门](https://atcoder.jp/contests/abc256/tasks/abc256_a)
* 给定 $N$，求 $2^N$。<!-- more -->

### 题解

直接求解即可。

## B. Batters

### 题面描述

* [传送门](https://atcoder.jp/contests/abc256/tasks/abc256_b)
* 有 4 个盒子，现进行 $N$ 次操作，每次给定整数 $x$，首先在 1 号盒子里放一张卡片，然后把每张卡片向后移动 $x$ 个盒子，若超出了 4 则将卡片扔掉。问最后扔掉了多少卡片。
* $N\leq 100$。

### 题解

直接模拟即可。

## C. Filling 3x3 Array

### 题面描述

* [传送门](https://atcoder.jp/contests/abc256/tasks/abc256_c)
* 现有一个 $3\times 3$ 的方格纸，给定 $h_1,h_2,h_3,w_1,w_2,w_3$，问有多少种在方格中填正整数的方法，使得第 $i$ 行的数的和为 $h_i$，第 $j$ 列的数的和为 $w_j$。
* $h_i,w_i\leq 30$。

### 题解

容易发现我们只需要枚举方格纸左上角 $2\times 2$ 区域的 4 个数字，就可以算出前两行、前两列剩下的 4 个数字，并检查右下角的格子能否按要求填上。因此总时间复杂度为 $O(30^4)$。

## D. Union of Interval

### 题面描述

* [传送门](https://atcoder.jp/contests/abc256/tasks/abc256_d)
* 给定 $n$ 个区间，第 $i$ 个区间是 $[l_i,r_i)$。现要求给出最少数量的左闭右开区间，使得这些区间的并和给出的 $n$ 个区间的并相同。
* $n\leq 2\times 10^5$。

### 题解

首先将所有区间按照左端点从小到大排序，然后按顺序考虑如何用最少的区间把给定的 $n$ 个区间包起来。假设当前考虑到第 $i$ 个区间，我们生成的区间的右端点为 $R$，下一个区间是 $[l_{i+1},r_{i+1})$，那么如果 $l_{i+1}\leq R$，我们可以通过将当前区间右端点取 $R'=\max(r_{i+1},R)$ 的方式包裹住下一个区间；如果 $l_{i+1}>R$，我们就不得不开辟一个新区间来包裹住它，此时 $R'=r_{i+1}$，并输出上一个区间。

总时间复杂度 $O(n\log n)$。

## E. Takahashi's Anguish

### 题面描述

* [传送门](https://atcoder.jp/contests/abc256/tasks/abc256_e)
* 现有 $n$ 个人， 第 $i$ 个人身上有一个数值 $C_i$，他有且仅有一个讨厌的人 $P_i(P_i\neq i)$。现在要将这 $n$ 个人排成一排，如果第 $i$ 个人发现他排在自己讨厌的人后面，那么我们就要支付给他 $C_i$ 元钱，问最小花费。
* $n\leq 2\times 10^5$。

### 题解

因为每个人有且仅有一条出边，因此如果我们对整个讨厌关系建图，会发现这张图是由若干个有向的基环树组成的 (中间一个环，周围有一系列分支指向这个环)。

我们容易发现对于一个环，不论怎么排列环上的人都至少需要给一个人支付代价，且只要按照环的顺序依次排人就一定只需要给一个人支付代价。对于环周围的那些树枝，我们只需要将其按照拓扑序排在环上人的前面就都不需要支付代价。因此对于图中的一个连通块，我们的最优方案就是给环上代价最小的人付钱，对图进行搜索即可。

总时间复杂度 $O(n)$。

## F. Cumulative Cumulative Cumulative Sum

### 题面描述

* [传送门](https://atcoder.jp/contests/abc256/tasks/abc256_f)
* 对于个数列 $a_1,a_2,\cdots, a_n$，令 $b_x=\sum_{i=1}^xa_i$，$c_x=\sum_{i=1}^xb_i$，$d_x=\sum_{i=1}^xc_i$。现有 $q$ 次操作，每次操作属于以下两种：
    * `1 x v`，将 $a_x$ 修改成 $v$。
    * `2 x`，求 $d_x$。
* $n,q\leq 2\times 10^5$。

### 题解

推式子
$$
\begin{align}
b_i &= \sum_{j=1}^ia_i\\\\
c_i &= \sum_{j=1}^ib_i=\sum_{j=1}^i\sum_{k=1}^ja_k=\sum_{j=1}^i(i-j+1)\cdot a_j\\\\
d_i &= \sum_{j=1}^ic_i=\sum_{j=1}^i\sum_{k=1}^j(j-k+1)\cdot a_k\\\\
&=\sum_{j=1}^i(1+2+\cdots+(i-j+1))a_j\\\\
&=\frac{1}{2}\sum_{j=1}^i(i-j+2)(i-j+1)a_j\\\\
&=\frac{1}{2}\sum_{j=1}^i(i^2+3i+2)a_j-(2i+3)ja_j+j^2a_j\\\\
&=\frac{1}{2}\left((i^2+3i+2)\sum_{j=1}^ia_j-(2i+3)\sum_{j=1}^ija_j+\sum_{j=1}^ij^2a_j\right)
\end{align}
$$因此我们只需要用三个树状数组分别维护 $\sum a_j,\sum ja_j$ 和 $\sum j^2a_j$ 即可高效维护 $d_x$。

## G. Black and White Stones

### 题面描述

* [传送门](https://atcoder.jp/contests/abc256/tasks/abc256_g)
* 给定一个 $n$ 边形，现要在每条边上等距离放 $d+1$ 个棋子 (即有两个放在多边形的角上，$d-1$ 个放在边上，角上的棋子是两条边共用的)，共放 $nd$ 个棋子。每个棋子要么是黑的要么是白的，问有多少种方案使得每条边上白子的个数相同。
* $3\leq n\leq 10^{12},d\leq 10^4$。

### 题解

首先枚举一条边上的白棋子个数 $D$，然后考虑动态规划：令 $dp(i,0/1)$ 表示当前考虑到第 $i$ 条边，这一条边最后一个棋子不是/是白色的情况下的方案数，我们可以从 $dp(i-1,0/1)$ 转移来，并且可以将转移写成矩阵形式：
$$
\begin{pmatrix}
dp(i,0)\\
dp(i,1)
\end{pmatrix}
=
\begin{bmatrix}
\binom{d-1}{D} & \binom{d-1}{D-1}\\\\
\binom{d-1}{D-1} & \binom{d-1}{D-2}
\end{bmatrix}
\begin{pmatrix}
dp(i-1,0)\\\\
dp(i-1,1)
\end{pmatrix}
$$这样使用矩阵快速幂就可以快速得到 $dp(n-1,0/1)$ 的值。注意到多边形是环形的，所以最后一条边我们要特殊处理：刚开始我们需要先枚举第一条边的第一个棋子是黑色/白色，算到 $dp(n-1,0/1)$ 时再根据最后一条边两个角上的棋子颜色乘最后一个组合数。

总时间复杂度 $O(d\log n)$。

## Ex. I Like Query Problem

### 题面描述

* [传送门](https://atcoder.jp/contests/abc256/tasks/abc256_h)
* 有长度为 $n$ 的数列 $a_1,\cdots, a_n$ 和 $q$ 次操作，每次操作是以下三种之一：
    * `1 L R x`：将 $[L,R]$ 中所有的 $a_i$ 变成 $\lfloor\frac{a_i}{x}\rfloor$。
    * `2 L R x`：将 $[L,R]$ 中所有的 $a_i$ 变成 $x$。
    * `3 L R`：求 $\sum_{i=L}^Ra_i$。
* $n\leq 5\times 10^5,q\leq 10^5,x\leq 10^9$。

### 题解

第二和第三种操作都是经典的线段树操作，通过懒标记就可以维护。第一种操作比较难办，我们考虑在懒标记上维护一个 flag，表示当前区间是否所有数都是一个值，然后在线段树修改操作的时候，如果一个区间的值全部相同，就可以直接修改这个相同的值并更新区间和，否则就向左向右分别递归。

我们尝试分析这种有点像“暴力”的做法的效率：首先每个数只需要 $\log$ 次第一类操作就会变成 0，之后它再变得非 0 需要依赖第二类操作，而第二类修改操作趋向于让整个序列变得“越来越一样”，所以直观上整个算法效率很高。使用势能分析的手法可以得出该做法的时间复杂度为 $O(q\log n\log x)$。