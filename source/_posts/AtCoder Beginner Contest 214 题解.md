---
layout: post
date: 2021-08-17
title: "AtCoder Beginner Contest 214 题解"
categories:
tags: [AtCoder, 动态规划, 并查集, 容斥原理, 强连通分量, 网络流, 贪心]
mathjax: true
---

## A. New Generation ABC

### 题面描述

* [传送门](https://atcoder.jp/contests/abc214/tasks/abc214_a)

<!-- more -->

### 题解

按照题目要求判断即可。

## B. How Many?

### 题面描述

* [传送门](https://atcoder.jp/contests/abc214/tasks/abc214_b)
* 给定 $S$ 和 $T$ ，求有多少个由非负整数构成的三元组 $(a,b,c)$ 满足 $a+b+c\leq S$ 且 $a\times b\times c\leq T$。
* $S\leq 100, T\leq 10000$。

### 题解

由于 $S$ 不大，所以直接三重循环枚举所有可能的三元组即可。复杂度 $O(S^3)$。

## C. Distribution

### 题面描述

* [传送门](https://atcoder.jp/contests/abc214/tasks/abc214_c)
* 有 $n$ 个人围成一圈，每个人会在 $t_i$ 时刻获得一枚钻石（无来源）。如果第 $i$ 个人在 $t$ 时刻拿到了一个钻石（无来源或来自前一个人），他会在 $t+S_i$​ 时刻把钻石给下一个人。设每个人拿到第一个钻石的时间为 $T_i$ ，求 $\max_{i=1}^nT_i$​。
* $n\leq 2\times 10^5$。

### 题解

首先考虑这 $n$ 个人中 $t_i$ 最小的那个，他第一个拿到的钻石一定是无来源钻石而不是从前一个人手里传过来的钻石。我们以这个人为起点剖环为链。于是显然有 $T_i=min\{T_{i-1}+S_{i-1},t_i\}$，递推一遍即可。

总时间复杂度 $O(n)$​。

## D. Sum of Maximum Weights

### 题面描述

* [传送门](https://atcoder.jp/contests/abc214/tasks/abc214_c)

* 给定一棵 $n$ 个点的树和每条边的边权。令 $f(i,j)$ 表示从节点 $i$ 到节点 $j$​ 的最短路径上的最长边的权值，求
    $$
    \sum_{i=1}^{n-1}\sum_{j=i+1}^nf(i,j)
    $$

* $n\leq 10^5$。

### 题解

考虑每条边对答案的贡献，容易发现如果我们将所有边按边权大小从小到大排序后按顺序插入，则一条边的贡献相当于它连接的两个连通块的大小之积。因此用并查集维护连通块大小即可。

总时间复杂度 $O(n\alpha(n))$。

## E. Packing Under Range Regulations

### 题面描述

* [传送门](https://atcoder.jp/contests/abc214/tasks/abc214_e)
* 有 $10^9$ 个箱子和 $n$ 个球，球编号 $1,2,...,n$。现给出 $n$ 个区间，第 $i$ 个区间为 $[L_i,R_i]$，问是否存在一种将球放进箱子的方案，使得每个箱子至多放一个球，且第 $i$ 个球在第 $L_i$ 到第 $R_i$ 的箱子中的某一个里。
* $n\leq 2\times 10^5$。

### 题解

考虑一种贪心策略：如果我们一个箱子一个箱子地决策里面该放哪个球，假设现在考虑到第 $i$ 个箱子，有若干个区间可以用这个箱子来满足条件且还没有满足条件，那么我一定会选择 $R$ 最小的那个率先满足。

基于这种贪心策略，我们将所有的 $L$ 和 $R$ 离散化之后按顺序枚举每个端点并用一个堆动态维护当前有哪些区间还没满足条件，如果遇到一个区间的左端点就入堆，每个时刻挑堆中最小的元素出堆，如果在某一时刻出堆区间的右端点小于当前时刻则无解。

总时间复杂度 $O(nlogn)$。

## F. Substrings

### 题面描述

* [传送门](https://atcoder.jp/contests/abc214/tasks/abc214_f)
* 给定一个仅有小写字母构成的字符串 $S$，现要从 $S$ 中生成出子串 $T$，生成规则是挑选 $S$ 中不相邻的若干位按顺序连接组成 $T$，问可以组成多少种不同的 $T$。

* $\mid S\mid \leq 2\times 10^5$。

### 题解

令 $dp[i]$ 表示以 $i$ 结尾有多少种不同的子串，考虑如何用 $dp[i]$​ 去更新后面的答案。比如下一个接字母 `a`，那么只向最近的一个 `a` 转移。这样转移相当于所有可能的子串都只计算了字典序（字典序指所有字母出现的位置连起来构成的序列的字典序）最小的那一个，从而避免了重复计数。

由于字符集只有小写字母，所以每个状态最多转移 $26$ 次，总时间复杂度 $O(\mid S\mid)$。

## G. Three Permutations

### 题面描述

* [传送门](https://atcoder.jp/contests/abc214/tasks/abc214_g)
* 给定两个长度为 $n$ 的排列 $p_1,p_2,...,p_n$ 和 $q_1,q_2,...,q_n$，对于一个排列 $r_1,r_2,...,r_n$，如果对于任意 $1\leq i\leq n$​ 都有  $r_i\neq p_i$ 且 $r_i\neq q_i$ ，则称这个排列是好的。问有多少个好的排列。
* $n\leq 3000$。

### 题解

考虑容斥，转而对于所有的 $1\leq k\leq n$​ 计算有指定的 $k$ 个位置不满足条件的方案数。

我们容易发现两个排列构成了若干个置换，置换之间两两不影响。如果我们已经能够设法维护 $cnt[i][j]$​ 表示第 $i$​ 个置换中有 $j$​​ 个位置不合法的方案数，那么我们就可以用一个简单的背包dp来计算整个局面下有 $1,2,...,n$​ 个位置不合法的方案数。这里的背包dp只需要使用暴力转移就好，这样看上去虽然是 $O(n^3)$ 的，但由于所有置换的大小的和是 $n$ ，所以实际上是 $O(n^2)$。现在重点考虑如何计算 $cnt[i][j]$。

一个 $n$ 个元素的置换可以看作一个 $n$ 个点构成的圈。在置换中选出若干个位置等价于在圈中选出若干条边。我们容易发现，如果 $n$ 条边全部被选中，则有 $2$ 种放置的方案；否则选中的部分一定是若干条链，对于有 $i$ 条边的链有 $i+1$ 种放置的方案。我们容易想到动态规划，用 $f[i][j]$ 表示当前已经考虑到第 $i$ 条边，已经选了 $j$ 条边的方案数，但由于需要枚举当前这条链的长度来转移，因此复杂度为 $O(n^3)$，需要优化。

一个常用的技巧是：**如果对于每个连通块要计算某种和其大小有关的函数，可以考虑其组合意义。**在本题中对于长度为 $i$​ 的链贡献是 $i+1$​ ，我们可以考虑如下问题：在圈中选出若干条链，对于每条链，第一条边上有两个小球，其他边上有一个小球，这样长度为 $i$​ 的边上有 $i+1$​ 个小球，在其中挑选一个染色，问选边+染色的方案数。这个问题和原问题的答案是一致的。于是我们修改状态，令 $f[i][j][0/1/2]$​ 表示当前考虑到第 $i$​ 条边，已经选了 $j$​​ 条边，最后一维的三个状态分别表示 “当前边没有选” “当前边选了且当前边所在的链中还没有小球被染色” “当前边选了且当前边所在的链中已经有小球被染色”，转移是容易的。本题中由于做的是环上的问题，因此还要考虑末尾和开头的拼接问题，在实际 dp 的过程中还要多一维状态记录开头的情况，做完 dp 后将首尾状态合并再计算答案。

综上，我们需要做两个 $O(n^2)$ 的动态规划，再用容斥原理计算答案，总时间复杂度 $O(n^2)$。

## H. Collecting

### 题面描述

* [传送门](https://atcoder.jp/contests/abc214/tasks/abc214_h)
* 给定一张 $n$ 个点 $m$ 条边的有向图，第 $i$ 个点上有 $X_i$ 个宝石。现有 $k$ 个人，他们依次从 $1$ 号点出发，沿着有向图的边走任意步，沿途如果某个节点有宝石就将其取走。问他们最多能拿走多少宝石。
* $n,m\leq 2\times 10^5$，$k\leq 10$。

### 题解

显然同一个强连通分量里的宝石是可以一次性拿完的。如果我们将强连通分量缩点后重新建图，得到的就是一个DAG（有向无环图）。

**本题的 $k$​ 较小，这是在 $n$​​ 较大的情况下仍可以尝试考虑网络流的依据。**我们先考虑如下费用流模型：对于每个点建立入点和出点 $in_u$​ 和 $out_u$​。此外建立超级源点和超级汇点，建边方法如下：

* 在 $in_u$​​ 和 $out_u$ 之间建一条流量为 $1$ ，费用为 $-X_u$ 的边和一条流量为 $\infty$，费用为 $0$ 的边，来模拟每个点的宝石只会被取走一次。
* 对于DAG中的每条边 $(u,v)$，在 $out_u$ 和 $in_v$ 之间连一条流量为 $\infty$，费用为 $0$ 的边。
* 超级源点向 $in_1$ 连一条流量为 $k$ ，费用为 $0$ 的边。
* 所有的 $out_u$ 向超级汇点连一条流量为 $\infty$，费用为 $0$ 的边。

在这张图上跑费用流，取最小费用的相反数即可得到答案。但带有负权的费用流不好做，我们可以用先强制满流再退流的方法使费用变为正数，事实上，换一个角度建图也可以规避负费用的问题。我们令每单位 “水流” 的代价为它没有吃到的宝石的代价之和，那么最小化这个代价就是最大化吃到的宝石。建边如下：

* 在 $in_u$ 和 $out_u$ 之间建一条流量为 $1$ ，费用为 $0$ 的边和一条流量为 $\infty$ ，费用为 $X_u$ 的边。
* 对于 DAG 中的每条边 $(u,v)$，由于是 DAG 所以可以保证 $u<v$，在 $out_u$ 和 $in_v$ 之间连一条流量为 $\infty$​ ，费用为 $X_{u+1}+X_{u+2}+...+X_{v-1}$ 的边，表示如果沿着这条边走就放弃了中间这些点的宝石。
* 超级源点向 $in_1$ 连一条流量为 $k$，费用为 $0$ 的边。
* 所有的 $out_u$ 向超级汇点连一条流量为 $\infty$，费用为 $X_{u+1}+X_{u+2}+...+X_n$ 的边。

设该图中得到的最小费用为 $mincost$ ，则最终答案为 $k(\sum_{i=1}^nX_i)-mincost$。注意在 DAG 中 $1$ 号点之前的点理应先从 DAG 中剔除。

虽然本题中 $n$ 较大，但我们可以这样估算 Edmonds-Karp-Dijkstra 算法的时间复杂度：每做一次 Dijkstra 的时间复杂度为 $O(mlogm)$，每做一次最短路至少可以流一单位流量，因此复杂度的上界为 $O(kmlogm)$，可以通过。

