---
layout: post
date: 2021-10-07
title: "几种求解最大流算法的通俗解释"
categories:
tags: [算法笔记, 网络流]
mathjax: true
---

## 基本概念

流：一个函数 $f: V\times V\rightarrow \mathbb{R}$，满足

* $0\leq f(u,v)\leq c(u,v)$
* 对于任意 $u\in V-\{s,t\}$，有流量守恒：$\sum_{v\in V} f(u,v)=\sum_{v\in V}f(v,u)$

一个流 $f$ 的流量： $\mid f\mid=\sum_{v\in V} f(s,v)-\sum_{v\in V} f(v,s)$

预流：一个函数 $f:V\times V \rightarrow \mathbb{R}$，满足

* $0\leq f(u,v)\leq c(u,v)$
* 对于任意 $u\in V-\{s,t\}$，有 $\sum_{v\in V}f(v,u)\geq \sum_{v\in V}f(u,v)$（即进来的比出去的多）

残余网络：残余网络中引入了反向边的概念，从而使退流成为可能，具体的，$c_f:V\times V\rightarrow \mathbb{R}$ 满足

$$
c_f(u,v)=
\begin{cases}
c(u,v)-f(u,v), &(u,v)\in E\\\\
f(v,u), &(v,u)\in E\\\\
0，& otherwise
\end{cases}
$$割：割是图中点集的一个划分：$V=S\cup T$ ，满足 $S\cap T=\emptyset$ 且 $s\in S,t\in T$。

那么割的容量 $c(S,T)=\sum_{u\in S,v\in T}c(u,v)$。

一个流 $f$ 在割 $(S,T)$ 上的流量为 $f(S,T)=\sum_{u\in S,v\in T}f(u,v)-\sum_{v\in T,u,in S}f(v,u)$。可以理解对于任意割，$\mid f\mid=f(S,T)$。

<!-- more -->

## Ford-Fulkerson 方法

### 基本流程

```pseudocode
FORD-FULKERSON-METHOD(G, s, t)
{
	initialize flow f to 0
	while there exits an augmenting path p in the residual network Gf
    	c = min{c(u, v): (u,v) in in p}
    	foreach (u, v) in p
    		if (u, v) in E
    			(u, v).f += c
    		else
    			(v, u).f -= c
    return f
}
```

该算法不断在残余网络中寻找增广路并增广，直到残余网络“断了”（没有增广路）为止。

### 对于反向边的直观理解

对于反向边的直观理解是理解最大流算法的重要步骤之一。在这种基于不断寻找增广路的算法中，如果某条增广路 $p':s\rightsquigarrow y\rightarrow x\rightsquigarrow t$ 经过了一条反向边 $y\rightarrow x$（即原边为 $x\rightarrow y$），那么之前一定也流过一条增广路 $p:s\rightsquigarrow x\rightarrow y\rightsquigarrow t$。那么走反向边相当于退流，不再走 $x\rightarrow y$ 并将这两条增广路拆开重新组合成另外两条增广路 $q:s\rightsquigarrow x\rightsquigarrow t$，$q':s\rightsquigarrow y\rightsquigarrow t$。

### 通俗的正确性理解

首先，设残余网络 $G_f$ 上的一个流为 $f'$，那么将两个流 $f$ 与 $f'$ 合成一个流，我们可以写出
$$
(f\uparrow f')(u,v)=
\begin{cases}
f(u,v)+f'(u,v)-f'(v,u), &(u,v)\in E\\\\
0, &otherwise
\end{cases}
$$
可以证明，$(f\uparrow f')$ 确实是一个流，且 $\mid f\uparrow f'\mid=\mid f\mid+\mid f'\mid$。这为 Ford-Fulkerson 将每次增广的流量加起来作为总流量提供了正确性保证。

Ford-Fulkerson 之所以得到了最大流取决于最大流最小割定理：

> (Max-flow min-cut Theorem) 以下三条等价：
>
> 1. $f$ 是 $G$ 的最大流
> 2. 残余网络 $G_f$ 中没有增广路
> 3. 存在一个割 $(S,T)$ ，$\mid f\mid=c(S,T)$ 

$1\rightarrow 2$ ：如果还有增广路，那么顺着增广路流一下，总流量就变大了，矛盾。

$2\rightarrow 3$：设 $s$ 能到达的点集为 $S$，剩余的为 $T$，显然有 $s\in S,t\in T$。那么对于任意一条边 $(u,v)\in E,u\in S,v\in T$，必然有 $f(u,v)=c(u,v)$，否则$(u,v)\in G_f$， $v$ 也会在 $S$ 中。

对于任意一条边 $(v,u)\in E,v\in T,u\in S$，必然有 $f(v,u)=0$，否则在残余网络中 $c_f(u,v)=f(v,u)\neq 0$，$v$ 也会在 $S$ 中。所以容易验证 $f(S,T)=c(S,T)$。

$3\rightarrow 1$：最大流显然是不超过最小割的。通俗理解，最大流中的每一份流量都要经过从 $S$ 到 $T$ 的过程，所以每一份容量都要占用割的容量。从数学角度，对于任意的割 $(S,T)$，
$$
\begin{align}
\mid f\mid &= f(S,T)\\\\
&= \sum_{u\in S,v\in T} f(u,v)-\sum_{v\in T,u\in S}f(v,u)\\\\
&\leq \sum_{u\in S,v\in T} f(u,v)\\\\
&\leq \sum_{u\in S,v\in T} c(u,v)\\\\
&=c(S,T)
\end{align}
$$
又因为现在找到了一个流等于某个最小割，所以该流一定是最大流。

### 通俗的复杂度分析

假设将 Ford-Fulkerson 运用于整数容量的网络。则每次增广至少增加 $1$ 的流量。每次寻找增广路需要对图做一次搜索，所以 Ford-Fulkerson 的最坏时间复杂度为 $O(\mid f\mid E)$。

### Edmonds-Karp 算法

Ford-Fulkerson 之所以被称为 "方法" 是因为它没有明确给出找一条增广路的方式。Edmonds-Karp 是一种基于 Ford-Fulkerson 方法的算法，它给出了一种具体的找增广路的方式，从而使理论最坏复杂度降低到 $O(VE^2)$。

Edmonds-Karp 找增广路的方法是：将残余网络每条边的边权看作1做一次 bfs，然后沿着从 $s$ 到 $t$ 经过边数最少的路来增广。

可以证明：在增广的过程中，源点 $s$ 到每个点的最短距离是单调不降的：

> 考虑反证法：假设在做完流$f$ 时还满足条件，但在做完 $f'$ 之后有节点的最短距离变短了，设 $v$ 是满足 $\delta_{f'}(s,v)<\delta_f(s,v)$ 且 $\delta_{f'}(s,v)$ 最小的点 $v$。显然 $v\neq s$，那么设在残余网络 $E_{f'}$ 中 $s$ 到 $v$ 的一条最短路径为 $s\rightsquigarrow u\rightarrow v$，则 $\delta_{f'}(s,u)=\delta_{f'}(s,v)-1$。根据之前 $v$ 的找法，必然有 $\delta_{f'}(s,u)\geq \delta_f(s,u)$。因此 $\delta_f(s,u)\leq \delta_{f'}(s,u)<\delta_{f'}(s,v)<\delta_f(s,v)$。连续的两个小于号意味着 $\delta_f(s,u)<\delta_f(s,v)-1$，所以在 $E_f$ 中必然没有 $(u,v)$ 这条边。
>
> $E_f$ 中没有 $(u,v)$ 而 $E_{f'}$ 中有 $(u,v)$ ，这说明流 $f'$ 必然沿着 $(v,u)$ 增广了，所以有 $\delta_f(s,u)=\delta_f(s,v)+1$。这与之前的 $\delta_f(s,u)<\delta_f(s,v)$ 矛盾。$\blacksquare$

对于每一条增广路，至少存在一条边的残余容量与增广路流量 $f$ 相同。我们称这条边 $(u,v)$ 为关键边。关键边在增广后会残余网络中消失，如果它要再次出现，需要在某一条流 $f'$ 中沿着反向边再增广一次。我们考虑每一条边有多少次机会成为关键边：$\delta_{f'}(s,u)=\delta_{f'}(s,v)+1\geq \delta_f(s,v)+1=\delta_f(s,u)+2$。即一条边 $(u,v)$ 成为关键边后如果再出现在图中，$\delta(s,u)$ 至少增加了2。又每个点的 $\delta$ 值不超过 V，所以一条边成为关键边的次数是 $O(V)$ 的。所以总关键边边次是 $O(VE)$。每条增广路至少包含一条关键边，所以增广次数最多是 $O(VE)$ 的。每次增广需要做一遍 bfs，所以最坏时间复杂度为 $O(VE^2)$。

## 预流推进 (Push-relabel) 方法

### 基本流程

```pseudocode
PUSH(u, v)
{
	# Applies when u is overflowing, cf(u, v)>0 and u.h = v.h + 1
	t(u, v) = min(u.e, cf(u, v))
	if (u, v) in E
		(u, v).f += t(u, v)
	else
		(v, u).f -= t(u, v)
	u.e -= t(u, v)
	v.e += t(u, v)
}

RELABEL(u)
{
	# Applies when u is overflowing and for all v in u.adj, u.h <= v.h
	u.h = 1 + min{v.h: (u, v) in Ef}
}

INITIALIZE-PREFLOW(G, s)
{
	foreach v in G.V: v.h = v.e = 0 # v.h -> v's height; v.e -> v's overflow volume
	foreach (u, v) in G.E: (u, v).f = 0
	s.h = G.V.size
	foreach v in s.adj
		(s, v).f = c(s, v)
		v.e = c(s, v)
		s.e -= c(s, v)
}

GENERIC-PUSH-RELABEL(G)
{
	INITIALIZE-PREFLOW(G, s)
	while there exists an applicable push or relabel operation
		select an applicable push or relabel operation and perform it
}
```

预流推进方法和增广路方法的思路很不一样：增广路方法在过程中始终保证流量平衡，而预流推进则不然：它在每个节点后面都设置了一个储水罐，先把尽可能多的水流到该节点存在储水罐中，此时该节点的进水量大于出水量，称该状态为 overflow 状态。该节点想办法尽可能把储水罐里的水流出去，实在流不出去的再顺着原路退回去。

预流推进的另一套重要机制是每个节点的高度函数。高度函数 $h: V\rightarrow \mathbb{R}$ 满足 $h(t)=0$ 且任意 $(u,v)\in G_f$，$u.h\leq v.h+1$。高度函数类似于模拟了“水往低处流”的原理。节点 $u$ 的水可以流向节点 $v$ (PUSH) 当且仅当 $u.h=v.h+1$。

有的时候水可能存在一个低洼的节点中流不出去，这时候就要抬高这个节点的高度——把它抬得比相邻的节点中最最低的那个高 1 水就能流过去了。这就是 RELABEL 的过程。

流进 $t$ 的水不算 overflow，因为 $t$ 本身就是汇点。那些预先从 $s$ 流出去但发现灌不下去的水，会随着中间节点高度的抬高流回到 $s$。

### 对于反向边的直观理解

节点 $u$ 从它的上家收集了大量的水，暂存在 $u$ 背后的储水罐里。但 $u$ 发现这些水并不能全部灌到 $u$ 的下家去，所以 $u$ 把多余的水退还给了自己的上家。即上家不应该把这么多水丢给 $u$ 这个出口量很小的下家，而应该把更多的水分配给那些出口量很大但还没“吃饱”的其他下家，或者上家可以将这些多余的水继续退还给上家的上家。

### 通俗的正确性理解

一件比较显然的事情是如果网络中存在 overflow 的节点，那么算法一定不会结束。因为对于该 overflow 节点，如果有边 PUSH 则会 PUSH，如果没边 PUSH 一定可以 RELABEL。

我们简单地说明在预流推进的过程中，$h$ 始终满足高度函数的性质：

* 对于 PUSH 操作，它可能使边 $(u,v)$ 消失，可能使边 $(v,u)$ 出现。边消失意味着约束条件变少，显然没问题。因为 PUSH 的时候 $u.h>v.h$，所以 $(v,u)$ 边的存在也不会导致问题。
* 对于 RELABEL(u) 操作，因为它的高度只是比相邻的最低的节点恰好多 1，所以从 $u$ 出发的边不会出现问题。那些指向 $u$ 的节点，因为 $u.h$ 是在变大，所以也不会出现问题。

另外一件比较显然的事情是残余网络中始终不存在从 $s$ 到 $t$ 的通路。从直观角度理解，刚开始我们已经尽可能把水从 $s$ 全灌出去了，所以接下来的事情是把水尽可能多地灌到 $t$，不会再有水需要补充进来。从数学角度来看，在基于上面的高度函数的性质的基础上也不难理解：因为 $s.h=V,t.h=0$ 不会变化，所以如果存在通路，那么这条通路要包含 $V+1$ 个点 (高度函数的约束)，显然不可能。

因此，我们可以用如下循环不变式来证明其正确性：

> GENERIC-PUSH-RELABEL() 的每次循环开始时，$f$ 都是一个预流。

该不变式的 Initialization 和 Maintenance 都比较容易说明。着重说明 Termination: 当循环结束，即无法做 PUSH 也无法做 RELABEL 时，必然没有节点 overflow，所以预流 $f$ 就是一个流。此时 $h$ 仍是一个高度函数，这在数学上帮我们保证了从 $s$ 到 $t$ 没有通路，因此此时 $f$ 等于某一个割的容量，根据最大流最小割定理，此时的 $f$ 就是最大流。

### 通俗的复杂度分析

比较容易看出来每个顶点的高度值不会超过 $2\mid V\mid$。每次RELABEL一定会有一个节点的高度值增加，所以RELABEL 的次数不超过 $O(V^2)$。每次 RELABEL 之后，可以感性地理解最多 $O(E)$ 次 PUSH 之后就没的可 PUSH 了，所以最坏时间复杂度为 $O(V^2E)$。

### Relabel-to-front 算法

和 Ford-Fulkerson 方法类似，Push-Relabel 也是一个方法，因为它没有指明按照什么样的顺序进行 PUSH 和 RELABEL。Relabel-to-front 算法规定了一种 PUSH, RELABEL 的顺序，使最坏时间复杂度降到 $O(V^3)$。

Relabel-to-front 方法定义了一个 DISCHARGE 函数：

```pseudocode
DISCHARGE(u)
while u.e > 0
	v = u.current
	if v == NIL
		RELABEL(u)
		u.current = u.N.head
	elseif cf(u,v) > 0 and u.h == v.h + 1
		PUSH(u, v)
	else u.current = v.next-neighbor
```

其中 $u$ 的所有相关的邻居（进边和出边）以链表的形式存在 $u.N$ 中。DISCHARGE 函数的内涵就是不停地 PUSH，没得 PUSH 就 RELABEL 之后再 PUSH，直到把 $u$ 里面的存水全部灌出去。

Relabel-to-front 算法的主函数如下：

```pseudocode
RELABEL-TO-FRONT(G, s, t)
INITIALIZE-PREFLOW(G, s)
L = G.V - {s, t}, in any order
foreach u in G.V - {s, t}
	u.current = u.N.head
u = L.head
while u != NIL
	old-height = u.h
	DISCHARGE(u)
	if u.h > old-height
		move u to the front of list L
	u = u.next
```

我们定义所有满足 $u.h=v.h+1$ 的边 $(u,v)$ 为可流边，则可流边组成了一个DAG。我们设立循环不变式：

> 每次循环开始时， $L$ 中的序列都满足可流边DAG的偏序关系，且 $u$ 之间的节点没有 overflow。

简单描述 Maintenance 部分：先考虑前半部分：如果当前节点 $u$ 没有被 RELABEL，那么仅仅 PUSH 显然不会产生新的可流边。如果 $u$ 被 RELABEL 了，那么可以证明 $u$ 此时没有可流入边。因为如果存在 $(v,u)$ 是可流入边，那么 RELABEL 之后 $v.h=u.h+1$，那么 RELABEL 之前 $v.h>u.h+1$ ，与高度函数的定义不符。所以把 $u$ 提到最前面是安全的。

再考虑后半部分：如果 $u$ 被 RELABEL 了，那么 $u$ 被提到了最前面，显然没问题。如果 $u$ 没被 RELABEL，那么 $u$ PUSH 的时候只能把水灌到 $L$ 中在 $u$ 之后的节点中（偏序关系），所以 $u$ 之前的节点不会出问题。

因此 Relabel-to-front 算法的正确性有保证。可以证明，它的最坏时间复杂度为 $O(V^3)$。