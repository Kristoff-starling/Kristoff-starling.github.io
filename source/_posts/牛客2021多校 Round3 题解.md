---
layout: post
date: 2021-08-18
title: "牛客2021多校 Round3 题解"
categories:
tags: [动态规划, 最小生成树, 二分图匹配, 容斥原理]
mathjax: true
---

## A. Guess and Lies

### 题面描述

* [传送门](https://ac.nowcoder.com/acm/contest/18900/A)
* Alice 和 Bob 玩游戏，Alice 想好一个 $1$ 到 $n$ 之间的整数，Bob 每次可以给出一个 $x$ ，并问 Alice 她想的数是否大于等于 $x$ ，Alice 可以回答 `Yes`或 `No`。Alice 在游戏全程有一次撒谎的机会，她可以选择在任意时刻使用这次机会。现问：在 Bob 第一次问的 $x$ 是 $1,2,3,...,n$​ 且 Alice 回答了 `Yes`（可能撒谎）的情况下，Bob 各最少需要多少次才能确定 Alice 想的数。
* $n\leq 2000$​。

<!-- more-->

### 题解

转换思路考虑这个问题：如果某一次对于 Bob 提出的 $x$ Alice 回答了 Yes，那么如果 Alice 想的数小于 $x$ ，则她的撒谎次数+1。进而我们发现：对于一系列的 Bob 提问 Alice 回答的操作之后的局面，我们可以对每一个数 $i$ 记一个 $a_i$ 表示如果 Alice 想的数是 $i$ ，她目前撒谎了多少次，根据之前的提问回答每一个 $a_i$ 都是确定的。当且仅当只有一个 $a_i\leq 1$ 时，Bob 就可以确定 Alice 想的数。因此游戏转化为：每次 Bob 选一个分界点，Alice可以选择将分界点的前一半+1或后一半+1，Bob 希望尽快让数列中只有一个数 $\leq 1$，Alice则相反，问 Bob 需要问多少次。

直接维护 $a$ 数组的状态是困难的，但我们发现一个性质：在若干次操作后，$a$ 序列中那些 $\leq 1$ 的数一定是一段1，然后一段0，然后一段1（段与段不一定相邻，用数学归纳法此结论易证）。因此我们用 $dp[i][j][k]$ 表示第一段 $i$ 个 $1$，第二段 $j$ 个 $0$，第三段 $k$ 个 $1$ 的情况下需要多少次结束游戏，转移暴力枚举 Bob 选择的分界点，这样总时间复杂度为 $O(n^4)$，不足以通过。

我们进而可以发现该dp具有决策单调性：即在固定 $i$ 和 $j$ 的情况下，随着 $k$ 的增长，对 Bob 最优的分界点一定也是递增的（因为后面的 $1$ 变多了）。利用决策单调性优化可以优化到 $O(n^3)$，仍然不足以通过。

考虑继续对dp进行优化。我们考虑一种Bob的策略：Bob每轮连续两次问同一个数，如果 Alice 两次回答结果相同则没有撒谎，如果回答结果不同则撒谎了，这样每问两次 Bob 就可以将区间长度缩小一般，因此 Bob 一定能在 $2logn$​ 次以内确定答案，也就是说，dp数组内存储的值都是log级别的，非常小。进而我们发现dp值与dp下标之间也存在单调性，即固定 $i$, $j$ 不动时，随着 $k$ 的增大，dp值不会减少（因为后面的 $1$ 变多了）。因此我们考虑交换dp的第三维与答案，重新设计状态。

令 $dp[t][i][j]$ 表示中间的 $0$ 有 $i$ 个，左边或右边（具有对称性）的某一段 $1$ 有 $j$ 个，Bob使用不超过 $k$ 次猜测能结束游戏的前提下，另一段 $1$ 至多能有多少个。转移相对复杂，仍然是考虑分界点的位置，但充分利用单调性，每次将答案标记在最大的位置上并在每轮最后取一个后缀max，核心代码如下：

```c++
rep(t,0,20)
{
    rep(i,0,n) rep(j,0,i)
    {
        int k=dp[t][j][i-j],w=dp[t][i-j][j];
        if (k>=0) check_max(dp[t+1][i][min(k,n-i)],w);
    }
    rep(i,0,n) if (dp[t][0][i]!=-1)
        rep(j,0,n-i) if (dp[t][i][j]!=-1)
    {
        int k=dp[t][i][j];
        check_max(dp[t+1][i][min(k,n-i)],dp[t][0][i]+j);
        check_max(dp[t+1][i][min(dp[t][0][i]+j,n-i)],k);
    }
    rep(i,0,n) REP(j,n-i-1,0) check_max(dp[t+1][i][j],dp[t+1][i][j+1]);
}
```

 总时间复杂度为 $O(n^2logn)$，可以通过。

## B. Black and White

### 题面描述

* [传送门](https://ac.nowcoder.com/acm/contest/18900/B)
* 给定一个 $n$ 行 $m$ 列的矩阵，每个格子上都有一个权值 $w$，给这个格子涂色需要付出对应权值的代价。对于任意一个子矩阵，如果有三个角已经被涂上了颜色，则第四个角可以免费被涂上颜色。问最少用多少代价可以将整个矩阵涂上颜色。
* $n,m\leq 5000,w\leq 10^5$​​。

### 题解

考虑对每一个行建一个点 $A_i$，每一列建一个点 $B_j$ ，花代价选中第 $i$ 行第 $j$​ 列格子，就将 $A_i$ 与 $B_j$ 连起来。可以发现，免费涂色的过程是不改变连通性的。又可以发现整张图需要连通才能实现将颜色涂满，因此对建出的点求最小生成树即可。

由于权值范围有限，所以可以省去排序的 log。总时间复杂度 $O(n^2)$。

## C. Minimum Grid

### 题面描述

* [传送门](https://ac.nowcoder.com/acm/contest/18900/C)
* 给定一个 $n\times n$ 的方阵，其中有 $m$ 个格子可以填非负整数。先给定每行每列的数字的最大值，求填写的数的和的最小值。
* $n\leq 2000, m\leq 8\times 10^5$，行列最大值序列中相同的数不会出现超过 $500%$​ 次。

### 题解

我们先将每行的最大值，每列的最大值求和作为一个初始答案，然后考虑如何“节省”。

对于一个可以填数的格子，如果其所在行列的最大值不同，那么这个数必然只能给较小的行/列做贡献。换言之，只有某一个格子所在的行和列的最大值一样，才能通过在这个格子填数的方式实现“一石二鸟”。

因此我们每轮将最大值相同的那些行与列拿出来考虑，看他们的交叉点上的那些可以填数的格子。如果第 $i$ 行第 $j$ 列可以填数，那么在这个格子填数可以同时解决一行一列的问题，从而省下一个数。所以我们对所有的行建点，所有的列建点，可以填数的格子等价于连边，这样求一个最大匹配即可算出最多可以省下的代价。

因为题目保证了相同的数不会超过 $500$ 次，所以使用dinic最大流的方法求解最大匹配，可以预估时间复杂度大致为 $O(m\sqrt m)$。

## D. Count

### 题面描述

* [传送门](https://ac.nowcoder.com/acm/contest/18900/D)

* 给定一个 $n\times n$ 的矩阵，现要将其中的 $C$ 个格子染成黑色，染法要求满足以下条件：

    * 每行，每列，两条对角线都至少有一个格子被染黑；

    * 额外给出 $K$ 个位置，这 $K$​ 个位置不能被染黑。

        

    求方案数，答案对 $10007$ 取模。

* $n\leq 32,K\leq 7$。

### 题解

首先对 $K$ 个不能放的位置进行容斥，我们用 $2^K$ 的代价消除了染法的第二条限制，现在专注于第一条。

继续容斥，枚举有多少个行，列可以染色以及枚举对角线是否可以染色，我们发现假设有 $A$ 行， $B$ 列可以染色，则总共可以染色的格子数为 $AB-M$，其中 $M$ 为行列均允许染色但由于对角线被ban而无法染色的格子数。考虑用动态规划来计数，令 $dp_{p,i,j,k}$ 表示当前考虑到第 $p$ 行，当前可以染色的行数为 $i$ ，可以染色的列数为 $j$ ，行列均可以染色但由于对角线限制被ban的格子数为 $k$ 的方案数。转移的时候，我们发现若要充分考虑对角线上的点，则必须同时考虑第 $p$ 行，第 $p$ 列，第 $n+1-p$ 行，第 $n+1-p$​ 列。

总时间复杂度为 $O(2^Kn^4)$​。

## E. Math

### 题面描述

* [传送门](https://ac.nowcoder.com/acm/contest/18900/E)
* 对于给定的 $n$，求有多少个有序数对 $1\leq x\leq y\leq n$ 满足 $xy+1\mid x^2+y^2$。
* 多组数据， $T\leq 10^5,n\leq 10^{18}$。

### 题解

打表观察可以发现解的分布满足以下规律：

将解分成若干组，每一组的解由一个序列生成：第 $i$ 组的序列前两个数是 $i$ 和 $i^3$ ，以后 $f_i(n)=i^2f_i(n-1)-f_i(n-2)$​​，每相邻的两个数构成一对合法的解。注意第一组只有 $(1,1)$ 一对。

由此可以看出答案不是很多，因此可以预处理出所有的答案，再根据 $n$​ 二分。

## F. 24dian

### 题面描述

* [传送门](https://ac.nowcoder.com/acm/contest/18900/F)
* 输入 $n$ 和 $m$ ，问有多少种 $n$ 张扑克牌的组合（不考虑花色，仅有1~13）满足可以运用24点规则内的计算方法得到 $m$ ，且每一种得到 $m$ 的方法中途都出现了分数。
* $n\leq 4,m\leq 10^9$

### 题解

模拟题。枚举初始状态搜索即可。

## G. Yu Ling(Ling YueZheng) and Colorful Tree

留坑

## H. Ling Qiu, Luna and Triple Backpack

留坑

## I. Kuriyama Mirai and Exclusive Or

### 题面描述

* [传送门](https://ac.nowcoder.com/acm/contest/18900/I)

* 给定一个长度为 $n$ 的序列，现有 $q$ 次操作，每次操作属于以下两种类型之一：

    * `0 l r x` 给区间 $[l,r]$ 中的所有数异或 $x$；
    * `1 l r x` 给区间 $[l,r]$ 中下标为 $i$ 的数异或 $x+(i-l)$。

    求操作结束后的序列。

* $n\leq 6\times 10^5,q\leq 4\times 10^5$，所有异或的数均在 $[0,2^{30})$ 中。

### 题解

第一种操作相对简单，只需要记录一个差分数组，对于每次操作在位置 $l$ 和位置 $r+1$ 异或 $x$ ，最后求前缀异或和即可得每个数需要异或的值。

对于第二种操作，按位考虑。对于第 $i$​​ 位，可以发现需要异或1的位置都是以 $2^i$ 为周期循环出现的。如果我们将序列排成一个宽为 $2^i$ 的矩阵，则每次需要异或1的位置构成了一个或两个子矩阵区域，同样可以通过打差分标记的方式来维护，最后求二维前缀异或和即可。

假设 $n$​ 与 $q$​ 同阶，总时间复杂度 $O(nlog2^{30})$​。

## J. Counting Triangles

### 题面描述

* [传送门](https://ac.nowcoder.com/acm/contest/18900/J)
* 给定一张 $n$ 个顶点的无向完全图，每条边是黑色或白色，求三边同色的三角形的个数。
* $n\leq 8000$​。

### 题解

换一个角度考虑，用总三角形个数减去那些不是同色的三角形的个数。

我们可以发现一个性质：不同色的三角形三条边要么是两黑一白要么是两白一黑，这两种都满足三角形有恰好两个顶点旁边的两条边颜色不同。换言之，对于图中的每个顶点，考虑其所有邻边，任选一条黑色的边与一条白色的边组合，第三条边无论是什么颜色都是一个异色三角形。因此只要对每个顶点计算 $cnt_{black}*cnt_{white}$​ 最后除以二就是异色三角形的个数。 

总时间复杂度 $O(n^2)$。

