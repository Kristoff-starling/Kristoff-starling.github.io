---
layout: post
date: 2021-08-10
title: "AtCoder Beginner Contest 213 题解"
categories:
tags: [AtCoder, 动态规划, 后缀数组, 单调栈/单调队列, 分治, FFT/NTT]
mathjax: true
---

## A. Bitwise Exclusive Or

### 题面描述

* [传送门](https://atcoder.jp/contests/abc213/tasks/abc213_a)
* 给定整数 $A$ 和 $B$，求满足 $A\space xor\space C=B$ 的整数 $C$。
* $1\leq A,B\leq 255$​。

<!--more-->

### 题解

直接输出 $C=A\space xor\space B$ 即可。

## B. Booby Prize

### 题面描述

* [传送门](https://atcoder.jp/contests/abc213/tasks/abc213_b)
* 给定 $n$ 个整数，若一个数比另一个数小，则其排名比另一个数靠前。求排名倒数第二的数的位置。
* $n\leq 10^5$，$n$ 个数两两不同。

### 题解

求序列中第二大的数即可。时间复杂度 $O(n)$。

## C. Reorder Cards

### 题面描述

* [传送门](https://atcoder.jp/contests/abc213/tasks/abc213_c)
* 给定一个 $H\times W$ 的矩阵，每个格子里有一张卡片，其中有 $n$​ 张卡片上有数字，其他的卡片是空白的。每次操作可以选择一行或一列全白的卡片删除，然后将删除的行/列的下/右侧的卡片向上/左移动。重复操作直至无法操作。问每张有数字的卡片最后的位置。可以证明答案与操作的顺序无关。
* $1\leq H,W\leq 10^9,1\leq n\leq min(10^5,HW)$。

### 题解

对横坐标和纵坐标分别离散化之后得到的即为答案。总时间复杂度 $O(nlogn)$。

## D. Takahashi Tour

### 题面描述

* [传送门](https://atcoder.jp/contests/abc213/tasks/abc213_d)
* 给定一棵 $n$ 个节点的树，从 $1$ 号点出发，如果孩子中有未访问的则访问编号最小的，否则返回父亲。求访问路径。
* $n\leq 10^5$。

### 题解

将每个点的孩子按照编号排序后做一遍深度优先搜索即可。时间复杂度 $O(nlogn)$，可以做到 $O(n)$ 。

## E. Stronger Takahashi

### 题面描述

* [传送门](https://atcoder.jp/contests/abc213/tasks/abc213_e)
* 给定一张 $H\times W$ 的地图，每个点给定 `.` 或 `#`，表示这个点无/有障碍物。要求从 $(1,1)$ 出发前往 $(H,W)$。主人公有特殊技能，他可以选择任意一个 $2\times 2$ 的区域，将这个区域内的所有障碍物清除，这需要花费他 $1$ 的体力，行走不需要耗费体力。求到达目的地所需的最小体力。
* $H,W\leq 500$。

### 题解

将原地图转化成一张图。对于相邻的格子，如果目标格子是空地，则建一条权值为0的边，否则不建。接下来考虑特殊技能，我们容易发现主人公一定可以只在和自己相邻的区域使用这个技能，另外使用过一次技能之后，这个 $2\times 2$​ 的区域只会经过一次，所以我们也不需要记录哪些障碍物被打通了，我们只需要对于每个格子，给其相邻的所有 $2\times 2$ 区域内的障碍物建权值为1的边即可。最后在这张图上跑一个 $01$ bfs 即可。总时间复杂度 $O(n^2)$。

（ $01$ bfs 的写法是：准备一个双端队列，每次从队头出队一个点，然后考虑其邻边，将权值为 $0$ 的边连接的点加入队头，将权值为 $1$ 的边连接的点加到队尾。）

## F. Common Prefixes

### 题面描述

* [传送门](https://atcoder.jp/contests/abc213/tasks/abc213_f)
* 给定一个长度为 $n$ 的字符串 $S$ ，令 $f(x,y)$ 表示从第 $x$ 个字符开始的后缀与从第 $y$​ 个字符开始的后缀的最长公共前缀的长度。对于每个 $k=1,2,...,n$，求 $F(k)=\sum_{i=1}^nf(k,i)$。
* $n\leq 10^6$。

### 题解

对原串建立后缀数组和高度数组，这样对于每个位置 $k$​​ ，设其在后缀数组中的位置为 $sa_k$​​ ，则 $F(k)=\sum_{i=1}^n\min_{j=i}^{sa_k}height[j]$​​。

考虑后缀数组中某一个位置与其前面所有位置的 $lcp$ ，容易发现越远的地方 $lcp$​​ 越短，可以用一个单调栈来维护。所以我们对着高度数组正着反着分别用单调栈维护一次即可。

总时间复杂度 $O(nlogn)$。

## G. Connectivity 2

### 题面描述

* [传送门](https://atcoder.jp/contests/abc213/tasks/abc213_g)
* 给定一张 $n$ 个点 $m$ 条边的无向图，对于每个 $k=2,3,...,n$，求满足 $1$ 号点与 $k$ 号点连通的生成子图的个数对 $998244353$ 取模的值。
* $n\leq 17$。

### 题解

我们枚举和 $1$ 号点所在的连通块 $Mask$，并计算包含 $Mask$ 的连通块的个数。令 $cnt[Mask]$ 表示两个顶点均在 $Mask$ 中的边的数量。那么对于剩下的 $m-Mask$ 条边，如果其两个顶点均不在 $Mask$ 中，则可选可不选，如果一个顶点在 $Mask$ 中另一个不在 $Mask$ 中，则不能选，否则连通块就不是 $Mask$ 了。对于 $Mask$ 的导出子图，我们设法计算其连通生成子图的个数。

令 $dp[Mask]$​ 表示 $Mask$​ 的导出子图的连通生成子图的个数，考虑问题的反面，用所有生成子图的个数减去不连通的生成子图的个数。欲计算不连通的生成子图的个数，我们枚举 $1$​ 号点所在的连通块 $Mask’$​ ，$Mask’\subset Mask$​。考虑 $Mask’$​ 的导出子图以外的边，和 $Mask’$​ 有关的边不能选，和 $Mask’$​ 无关的边可选可不选，因此可以得出状态转移方程：
$$
dp[Mask]=\sum_{Mask'\subset Mask}dp[Mask']*2^{cnt[Mask-Mask']}
$$ 总时间复杂度 $O(3^n+2^nm)$。

## H. Stroll

### 题面描述

* [传送门](https://atcoder.jp/contests/abc213/tasks/abc213_h)
* 给定一个 $n$ 个点的图，有 $m$ 种边，第 $i$ 种边连接 $a_i$ 和 $b_i$ ，且长度为 $j$ 的边有 $p_{i,j}$ 条。求从 $1$ 号点回到 $1$ 号点且总长度为 $T$ 的路径个数。（路径中途可以任意重复经过点和边）
* $n\leq 10,m\leq min(10,\frac{n(n-1)}{2})，T\leq 4\times 10^4$。

### 题解

令 $dp[u][i]$​​​​ 表示从 $1$​​​​ 号点出发，当前在 $u$​​​​ 号点，总长度为 $i$​​​​ 的路径的条数。显然有转移方程：
$$
dp[u][i]=\sum_{(a_j,b_j)\in E,a_j/b_j=u}\sum_{t=1}^idp[v][t]*p_{j,i-t}
$$注意到该dp是卷积形式，可以用分治 NTT 优化，总时间复杂度 $O(mTlog^2T)$。

