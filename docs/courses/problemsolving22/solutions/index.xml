<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OJ习题讲解 | Yuyao Wang&#39;s Homepage</title>
    <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/</link>
      <atom:link href="https://kristoff-starling.github.io/courses/problemsolving22/solutions/index.xml" rel="self" type="application/rss+xml" />
    <description>OJ习题讲解</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sun, 05 Mar 2023 00:00:00 +0000</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>OJ习题讲解</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/</link>
    </image>
    
    <item>
      <title>问题求解 I-Final 题解</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/1-final/</link>
      <pubDate>Sun, 05 Mar 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/1-final/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Problem A: BrainF**k Syntax Checker&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题意概括：给定一个 BF 程序，判断它是否符合语法要求。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;BF 程序中的 &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; 显然不会对程序的合法性造成影响，因此本题的主要任务是判断 BF 程序中的 &lt;code&gt;[&lt;/code&gt; &lt;code&gt;]&lt;/code&gt; 是否形成了合法的括号序列，即两两匹配。&lt;/p&gt;
&lt;p&gt;值得注意的是，BF 程序中 &lt;code&gt;[&lt;/code&gt; 和 &lt;code&gt;]&lt;/code&gt; 的个数相同并不是括号序列合法的充要条件，比如 &lt;code&gt;][&lt;/code&gt; 这个序列就是不合法的。在此基础上，我们还要保证 BF 程序的任意前缀中，&lt;code&gt;[&lt;/code&gt; 的个数要大于等于 &lt;code&gt;]&lt;/code&gt; 的个数。&lt;/p&gt;
&lt;details&gt;&lt;summary&gt;&lt;b&gt;Code&lt;/b&gt; &lt;i&gt;[Click to expand]&lt;/i&gt;&lt;/summary&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
 
char program[1000];
string ValidChar = &amp;quot;+-,.&amp;lt;&amp;gt;[]&amp;quot;;
 
int main()
{
    scanf(&amp;quot;%s&amp;quot;, program);
    int len = strlen(program), LeftRightDelta = 0;
    bool flag = true;
    for (int i = 0; i &amp;lt; len; i++)
    {
        if (ValidChar.find(program[i]) == string::npos) flag = false;
        if (program[i] == &#39;[&#39;) LeftRightDelta++;
        if (program[i] == &#39;]&#39;) LeftRightDelta--;
        if (LeftRightDelta &amp;lt; 0) flag = false;
    }
    puts((flag &amp;amp;&amp;amp; LeftRightDelta == 0) ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Problem B: BrainF**k Interpreter&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题意概括： 给定一个 BF 程序，模拟其运行过程并输出最后的内存状态。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这是一道相当有意思的题目，解法也很多。该问题的核心难点是如何处理嵌套的中括号。考场上有很多同学利用递归处理中括号的嵌套，这是一个很好且可行的思路。我们在这里介绍另外一种不需要递归的思路，它书写起来更加简洁，且在一定程度上揭示了计算机运行的本质——大家在本学期的 &lt;em&gt;数字逻辑与计算机组成&lt;/em&gt; 和下学期的 &lt;em&gt;计算机系统基础&lt;/em&gt; 中会不断与这种逻辑打交道。&lt;/p&gt;
&lt;p&gt;在题面的提示中我们已经给出了计算机执行指令的四步骤，我们在这里再重复一遍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取指：取出下一条执行的指令。&lt;/li&gt;
&lt;li&gt;译码：根据指令的格式确定该指令的类型。&lt;/li&gt;
&lt;li&gt;执行：根据指令类型，执行该指令定义的动作。&lt;/li&gt;
&lt;li&gt;跳转：根据指令类型和执行过程，确定下一条应当执行的指令的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;真正的计算机处理的是“汇编语言”，我们的 BF 解释器处理的是 BF 语言，这两者在本质上没有区别。计算机内部通常有一个程序计数器 (program counter, 简称 pc)，它的功能和计数没什么关系，反而像一个指针，用来指向下一条要执行的指令。我们来具体地看看四个步骤对应到 BF 语言应当如何操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;取指：这是最简单的一步，对应到 C++ 代码大概就是 &lt;code&gt;char instruction = program[pc]&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;译码&amp;amp;执行：这两步在 BF 种可以放在一起做 (因为 BF 的所有指令都没有“操作数”)，你大抵会用一个 if/switch 语句来判断 instruction 是 8 个符号中的哪一种并执行相应的操作。前 6 种指令的操作都非常简单，这里不再赘述。&lt;code&gt;[&lt;/code&gt; 和 &lt;code&gt;]&lt;/code&gt; 本质上是分支控制指令，所以在“执行”这个步骤中它们什么也不用做。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跳转：前 6 种指令的跳转都非常简单：做完了就做紧接着的下一条指令，即 &lt;code&gt;pc++&lt;/code&gt;。我们着重讲解 &lt;code&gt;[&lt;/code&gt; 和 &lt;code&gt;]&lt;/code&gt; 的跳转如何处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[&lt;/code&gt;：左中括号指令的逻辑是
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;if (memory[pointer] != 0)
    pc++ // go into the loop
else
    pc = (the position of the corresponding &amp;quot;]&amp;quot;) + 1 // skip the loop
&lt;/code&gt;&lt;/pre&gt;
&lt;code&gt;pc&lt;/code&gt; 直接加一意味着进入循环，&lt;code&gt;pc&lt;/code&gt; 跳转到对应的 &lt;code&gt;]&lt;/code&gt; 的下一条指令意味着跳过循环。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;]&lt;/code&gt;：右中括号指令的逻辑是
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;pc = (the position of the corresponding &amp;quot;[&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
遇到右中括号，无条件跳转到对应的左中括号，开始新一轮循环条件判断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意到 &lt;code&gt;[&lt;/code&gt; 和 &lt;code&gt;]&lt;/code&gt; 的处理都依赖与之匹配的“另一半”，因此在正式开始执行程序之前，我们要预处理一遍程序以知道与每个 &lt;code&gt;[&lt;/code&gt;/&lt;code&gt;]&lt;/code&gt; 配对的 &lt;code&gt;]&lt;/code&gt;/&lt;code&gt;[&lt;/code&gt; 在什么位置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按照这四个步骤书写本题的代码，可以完成得轻松且高效，从中你也可以领悟到计算机系统设计的伟大智慧。&lt;/p&gt;
&lt;details&gt;&lt;summary&gt;&lt;b&gt;Code&lt;/b&gt; &lt;i&gt;[Click to expand]&lt;/i&gt;&lt;/summary&gt;
&lt;p&gt;注：下面参考程序仅仅实现了一个 BF 解释器，输入格式和输出格式与原题并不相同。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int memory[1000], pointer;
char program[1000]; int n;

int input_count, input[1000];

int jumpto[1000], stk[1000], stot;

int main ()
{
    scanf(&amp;quot;%s&amp;quot;, program); n = strlen(program);
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;input_count);
    for (int i = 1; i &amp;lt;= input_count; i++) scanf(&amp;quot;%d&amp;quot;, input + i);

    // 预处理每个 [ 和 ] 对应的 ]/[
    stot = 0;
    for (int i = 0; i &amp;lt; n; i++)
    {
        if (program[i] == &#39;[&#39;) stk[++stot] = i;
        if (program[i] == &#39;]&#39;)
        {
            jumpto[i] = stk[stot];
            jumpto[stk[stot]] = i + 1;
            stot--;
        }
    }

    pointer = 0;
    int pc = 0, input_pt = 0;
    bool printed = false;
    while (pc &amp;lt; n)
    {
        int next_pc = pc + 1;
        switch (program[pc])
        {
            case &#39;+&#39;: memory[pointer]++; break;
            case &#39;-&#39;: memory[pointer]--; break;
            case &#39;&amp;lt;&#39;: pointer--; break;
            case &#39;&amp;gt;&#39;: pointer++; break;
            case &#39;,&#39;: memory[pointer] = input[++input_pt]; break;
            case &#39;.&#39;: printf(&amp;quot;%d &amp;quot;, memory[pointer]); printed = true; break;
            case &#39;[&#39;:
                if (memory[pointer] == 0)
                    next_pc = jumpto[pc];
                break;
            case &#39;]&#39;: next_pc = jumpto[pc]; break;
        }
        pc = next_pc;
    }
    if (printed) puts(&amp;quot;&amp;quot;);
    for (int i = 0; i &amp;lt; 10; i++)
        printf(&amp;quot;%d &amp;quot;, memory[i]);
    puts(&amp;quot;&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Problem C: DXY&amp;rsquo;s Graph Problem&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题意概括：给定一张图 $G=(V, E)$，其中 $V$, $E$ 分别是点和边的集合。对于图中任意顶点 $v\in V$，令 $\text{cover}(v)\triangleq \{(x, y)\in E: x=v\vee y=v\}$ (即与该点相邻的所有边的集合)。问是否存在原图顶点的划分 $S_1, S_2$，满足 $S_1\uplus S_2=V$ (即 $S_1\cup S_2=V$ 且 $S_1\cap S_2=\emptyset$)，且&lt;/p&gt;
&lt;p&gt;$$
\bigcup_{v\in S_1}\text{cover}(v)=\bigcup_{v\in S_2}\text{cover}(v)=E
$$&lt;/p&gt;
&lt;p&gt;(注：本题完整题意里中文描述中有关“DXY可以通过自己的点集将原图恢复”的部分给大家带来了较大困扰，对此我们深表歉意。)&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;每条边都有两个端点，要想这条边被双方都覆盖到，那么这两个端点必须分属于不同的集合。因此可以成功划分的充要条件是：存在将整张图上的顶点黑白染色，且每条边的两个端点一黑一白的方案。&lt;/p&gt;
&lt;p&gt;我们容易发现这样的方案如果存在一定是唯一的，因为我们已经规定了 1 号点属于 DXY，我们不妨将白色分配给 DXY，那么整个过程相当于从一个白色的 1 号点开始向外搜索，每搜索到一个新的节点就给它涂上和邻居节点不同的颜色。由于整个图是连通的 (即任意两个节点都存在路径互相可达)，所以这样的搜索一定能给每个节点一个唯一的颜色 (如果你想要严谨地证明，可以考虑数学归纳法)。在搜索的过程中，如果发现无法解决的矛盾 (例如某个节点同时和一个黑点和白点相邻)，则问题无解。&lt;/p&gt;
&lt;p&gt;如果你愿意继续深究这个问题 (这部分知识对于解决这道题并无必要)，你会发现可以成功黑白染色充要条件是&lt;strong&gt;图中不存在奇数长度的环&lt;/strong&gt;，这也是判断二分图 (Bipartite Graph) 的方法，大家在后续的问题求解课程中会学习到这个概念和相关的证明。&lt;/p&gt;
&lt;details&gt;&lt;summary&gt;&lt;b&gt;Code&lt;/b&gt; &lt;i&gt;[Click to expand]&lt;/i&gt;&lt;/summary&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
 
const int MAXN = 1e5 + 10;
 
int n, m;
vector&amp;lt;int&amp;gt; v[MAXN];
 
int color[MAXN];
bool flag;
 
void dfs(int cur)
{
    for (auto neighbor : v[cur])
        if (color[neighbor] == 0)
        {
            color[neighbor] = 3 - color[cur]; 
            // 两种颜色用 1, 2 表示
            // 3 - color[cur] 则表示“另一种颜色”
            dfs(neighbor);
        }
        else if (color[neighbor] != 3 - color[cur])
            flag = false;
         
}
 
int main ()
{
    scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m); int x, y;
    for (int i = 1; i &amp;lt;= m; i++)
    {
        scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;x, &amp;amp;y);
        v[x].push_back(y); v[y].push_back(x);
    }
     
    color[1] = 1; flag = true;
    dfs(1);
     
    if (flag)
    {
        puts(&amp;quot;Yes&amp;quot;);
        int cnt1 = 0, cnt2 = 0;
        for (int i = 1; i &amp;lt;= n; i++) if (color[i] == 1) cnt1++; else cnt2++;
        printf(&amp;quot;%d %d\n&amp;quot;, cnt1, cnt2);
        for (int i = 1; i &amp;lt;= n; i++) if (color[i] == 1) printf(&amp;quot;%d &amp;quot;, i);
        puts(&amp;quot;&amp;quot;);
        for (int i = 1; i &amp;lt;= n; i++) if (color[i] == 2) printf(&amp;quot;%d &amp;quot;, i);
        puts(&amp;quot;&amp;quot;);
    }
    else
        puts(&amp;quot;No&amp;quot;);
     
    return 0;
     
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;</description>
    </item>
    
    <item>
      <title>【问题求解I-HW6.C】万圣节的新娘</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/1-6-c/</link>
      <pubDate>Wed, 14 Dec 2022 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/1-6-c/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;题意概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定 $n$ 个数对，保证 $1\cdots n$ 中的每个数恰好出现两次。每次操作可以任意交换两个数的位置。问至少多少次交换可以使得每对数都相同。&lt;/p&gt;
&lt;p&gt;约束条件：$n\leq 10^6$。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这道题颇有思维难度，需要仔细观察并发现问题的性质。发现问题的性质不能靠双眼瞪着屏幕——动起手来，画几个样例手算出解法，很多时候解决问题的灵感就是从手算得出的。&lt;/p&gt;
&lt;p&gt;我们首先可以确定一件事：答案的上限是 $n-1$，因为每轮操作你总可以让某一个数对匹配起来。如果你手算尝试了一些样例，你一定会发现想要让交换次数最少，我们会格外喜欢这样的数对：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;1 2
2 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为我们只要让上面的 2 和下面的 1 交换，我们就可以一下子得到两个匹配的数对，这看起来非常赚。但不是什么时候都能有“动一次成两对”这么赚的事情，你很快会发现有的时候格局可能是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;1 2
2 3
3 5
5 8
8 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过观察你可以发现：这样的 5 个数对你只要将前 4 个搞定，最后一个也会随之搞定，且你无法给出比 4 次交换更好的方案。&lt;/p&gt;
&lt;p&gt;你是否觉得上面的 5 个数对像是 &lt;code&gt;1, 2, 3, 5, 8&lt;/code&gt; 五个数构成的环？事实上，稍加思索你便能发现 $n$ 个数对其实就是由这样的若干个互不影响的“环”组成的。每个环形如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;a1 a2
a2 a3
...
an-1 an
an a1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样一个长度为 $n$ 的环，我们需要 $n-1$ 次操作将其全部搞定，每有一个“环”，我们就可以“节省”一次操作。因此，设 $n$ 个数对共由 $m$ 个环构成，那么最小的操作次数就是 $n-m$。&lt;/p&gt;
&lt;p&gt;判断环的个数相对简单，你并不一定需要使用“并查集”这样高级的数据结构——事实上搜索已经足够完成任务了，这部分的细节留给大家自行思考。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【问题求解I-HW4.C】jyy为什么是神</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/1-4-c/</link>
      <pubDate>Thu, 27 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/1-4-c/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;题意概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定字符串 $s$，求 $|\{(i,j,k)|s_i=j,s_j=y,s_k=y\}|$。&lt;/p&gt;
&lt;p&gt;约束条件：$|s|\leq 10^6$。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;大家容易想到的一个非常简明的做法是使用三重循环计数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ans = 0;
for (int i = 0; i &amp;lt; int(s.size()); i++)
    for (int j = i + 1; j &amp;lt; int(s.size()); j++)
        for (int k = j + 1; k &amp;lt; int(s.size()); k++)
            if (s[i] == &#39;j&#39; &amp;amp;&amp;amp; s[j] == &#39;y&#39; &amp;amp;&amp;amp; s[k] == &#39;y&#39;)
                ans++;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但由于此题中 $|s|$ 达到了 $10^6$，使用三重循环意味着循环最内层的核心语句被执行了将近 $|s|^3$ 次。计算机一秒钟可以执行的 C/C++ 基本语句数目大约在 $10^8$ 量级，这样的程序显然会超时。&lt;/p&gt;
&lt;p&gt;本题的出题助教 (aka. dxy) 希望大家构造自动机解题。这里我们给出一个另外的比较简单的思路：&lt;/p&gt;
&lt;p&gt;我们将上面的程序改写为如下伪代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ans = 0;
for (int i = 0; i &amp;lt; int(s.size()); i++)
    if (s[i] == &#39;j&#39;)
        ans += &amp;quot;s[i]的后面(可以不连续)的yy的数目&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之前的代码中我们使用双重循环来数 &amp;ldquo;yy&amp;rdquo; 的个数，但事实上我们有更快速的方法：假设 &lt;code&gt;s[i]&lt;/code&gt; 的后面一共有 &lt;code&gt;n&lt;/code&gt; 个字母y，那么任意挑选两个都可以组成一个yy，所以yy的总数目是 $\binom{n}{2}=\frac{1}{2}n(n-1)$。基于这个想法，我们可以用一个二重循环解决该问题：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ans = 0;
for (int i = 0; i &amp;lt; int(s.size()); i++)
    if (s[i] == &#39;j&#39;)
    {
        int y_count = 0;
        for (int j = i + 1; j &amp;lt; int(s.size()); j++)
            if (s[j] == &#39;y&#39;) y_count++;
        ans += C(y_count, 2); // 组合数需要另外实现
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们的算法已经得到了改进，但 $|s|^2$ 次运行仍然无法在规定时间内获得结果，算法还需要进一步的优化。上述方法的瓶颈在于我们每遇到一个j都会把它后面的y数一遍，这样有很多的字母y被反复数了很多遍，这无疑拖慢了速度。&lt;/p&gt;
&lt;p&gt;事实上，一个巧妙的顺序的改变就可以“柳暗花明”：我们将外层循环的顺序倒过来，一边寻找j一边把j“身后”的y的个数数出来，这样就不需要内层循环了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ans = y_count = 0;
for (int i = int(s.size()) - 1; i &amp;gt;= 0; i--) {
    if (s[i] == &#39;y&#39;) y_count++;
    if (s[i] == &#39;j&#39;) ans += C(y_count, 2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;循环的使用方法博大精深，大家可以仔细体会这段代码。&lt;/p&gt;
&lt;p&gt;此外，本题由于结果过大，最终需要输出答案对 $998244353$ 取模的结果。大家在本题中可能会使用乘法，此时必须格外小心两个 &lt;code&gt;int&lt;/code&gt; 类型变量相乘 (还没来得及取模时) 结果溢出的情况，一个好的解决方案是使用更大的数据类型存储中间结果。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
