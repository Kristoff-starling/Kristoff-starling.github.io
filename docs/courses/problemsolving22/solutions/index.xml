<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OJ习题讲解 | Yuyao Wang&#39;s Homepage</title>
    <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/</link>
      <atom:link href="https://kristoff-starling.github.io/courses/problemsolving22/solutions/index.xml" rel="self" type="application/rss+xml" />
    <description>OJ习题讲解</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sat, 29 Apr 2023 00:00:00 +0000</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>OJ习题讲解</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/</link>
    </image>
    
    <item>
      <title>【问题求解II-HW3.A】签到题</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-3-a/</link>
      <pubDate>Sat, 29 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-3-a/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;题意概述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;给定数列 $a_1, \cdots, a_n$，求区间 $(l, r)$，使得&lt;/p&gt;
&lt;p&gt;$$
\left(\min_{i=l}^r a_i\right)\cdot \left(\max_{i=l}^r a_i\right)\cdot \left(\text{OR}_{i=l}^r a_i\right) \cdot (r - l + 1)
$$&lt;/p&gt;
&lt;p&gt;最大。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$n\leq 10^6$。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;遇到复杂的表达式不要慌，应当仔细观察它的性质。我们很容易发现该表达式的一个特点：除了 $\min$ 这个操作，其他的三项都是随着区间的扩大而增加的。换句话说，如果没有 $\min$ 这一项，这题的答案就是整个数列。&lt;/p&gt;
&lt;p&gt;接下来我们考虑如何对付这个棘手的 $\min$。$\min$ 的一大特点在于它是有限的——任何一个区间的 $\min$ 一定是原数列中的一个数，因此所有可能的 $\min$ 最多只有 $n$ 种。如果我们把所有的区间按照 $\min$ 的位置归类，那么根据之前的结论，享有同一个 $\min$ 的区间集合中，只有最长的那个才可能是答案的候选区间。&lt;/p&gt;
&lt;p&gt;到这里，我们的问题转化成了：枚举数列中的每个数 $a_i$ 作为最小值的情况，我们希望找到以此为最小值的最长区间，即从 $a_i$ 出发向左向右扩展，把所有 $\geq a_i$ 的数纳入到区间中，直到碰到边界/比 $a_i$ 小的数。但这件事仍然不容易，如果暴力地向左向右查看，复杂度仍然会达到 $O(n^2)$。&lt;/p&gt;
&lt;p&gt;考虑这样一种精巧的做法：我们不按照下标的顺序依次枚举 $a_i$，而是按照 $a_i$ 值从小到大的顺序枚举 $a_i$。这样在枚举到任意 $a_i$ 的时刻整个数列的格局如下：&lt;/p&gt;
&lt;img src=&#34;https://kristoff-starling.github.io/img/ps-sol-2031.png&#34; style=&#34;zoom: 50%;&#34; /&gt;
&lt;p&gt;其中蓝色的格子代表已经被枚举过的数，红色的是当前枚举的数。我们发现所有蓝色的数一定比当前数小(小于等于)，所有白色的数一定比当前的数大。因此要寻找“最长区间”，我们只要在“蓝色数”的下标数列中寻找比当前下标小的最大数和比当前下标大的最小数即可。你可以借助 C++ STL 的 set 容器以及 &lt;code&gt;lower_bound&lt;/code&gt; 方法来轻松完成这件事，时间复杂度降低到 $O(n\log n)$。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;遇到大小相同的数怎么办？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实不用担心这个问题。你可以按照任意顺序处理大小相同的数，因为先处理的数对应的区间可以包括后处理的数，所以后处理的数被先处理的数“卡住”区间边界也无关紧要了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;或者你也可以采取类似分治的做法，每次找完当前区间的最小值后将区间拆分成左右两个区间分别处理 (因为后续的区间不应该跨越这个最小值)。至于如何寻找一个区间最小值的位置，你可以在维护 ST 表时同时维护最小值位置，具体细节留给大家自己思考。&lt;/p&gt;
&lt;p&gt;剩下的最后一件事情是：对于每个最小值，我们找到了它对应的最长区间后，如何求该区间的最大值/同或和/长度。长度是容易的，剩下的两样恰好是 ST 表擅长的内容。你只需要预处理 ST 表即可 $O(1)$ 地查询。整个算法的时间复杂度为 $O(n\log n)$。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【问题求解II-HW3.B】砍树</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-3-b/</link>
      <pubDate>Sat, 29 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-3-b/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;题意描述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定一棵 $n$ 个节点的数和 $m$ 个点对，每个点对染不同的颜色。要求找出树中的一条边，使得砍掉这条边后得到的两棵树中没有颜色相同的节点 (即颜色相同的点对不能被划分到同一棵树中)。求满足条件的边的最大编号，若不存在输出 -1。&lt;/li&gt;
&lt;li&gt;$n\leq 10^5$。&lt;/li&gt;
&lt;/ul&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;树上任意两个点之间有且仅有一条简单路径。并且我们容易发现：如果要把两个点分到两棵树中，那么选择的这条边必须在连接这两个点的路径上。因此该问题被转化为了对树上的 $m$ 条路径求交。以下我们介绍三种做法供大家参考。&lt;/p&gt;
&lt;h4 id=&#34;做法1-基于lca的路径标记&#34;&gt;&lt;strong&gt;做法1: 基于LCA的路径标记&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;对于树上的任意两个点 $u$, $v$，从 $u$ 到 $v$ 的路径总可以被拆分为 $u\to lca(u, v)$ 和 $lca(u,v)\to v$ 两条直上直下的链。我们希望可以快速给链上所有的边打一个 +1 标记，这样最后只需要找有 $m$ 个标记的边即可。&lt;/p&gt;
&lt;p&gt;如果对每条路径上的所有边暴力打 +1 标记的话，总复杂度为 $O(\sum_{i=1}^m len(u_i\to v_i))$，最坏情况下可以达到 $O(mn)$，不可接受。&lt;/p&gt;
&lt;p&gt;以 $o(t)$ 的代价给 $t$ 条边打上标记似乎是一件“违反物理”的事情。但我们向大家展示如下的技巧做到这一点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们不把操作作用在边上，而是作用在点上，每个点与连向它父亲的边对应 (根节点没有对应的边)。&lt;/li&gt;
&lt;li&gt;对于路径 $(u, v)$：
&lt;ul&gt;
&lt;li&gt;$mark(u) + 1$。&lt;/li&gt;
&lt;li&gt;$mark(v) + 1$。&lt;/li&gt;
&lt;li&gt;$mark(lca(u, v)) - 2$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每个点最终的标记 $Mark(u) = \sum_{v\in subtree(u)} mark(v)$ (即以 $u$ 为根的子树中所有节点的 mark 之和)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个技巧有一个很炫酷的名字，叫“树上差分”。你可以对一条路径按照上述操作做一遍，然后验证一下处于各个位置的节点的 Mark，你会发现只有 $(u, v)$ 路径上的节点 (除了 LCA) Mark 为 1，其他的都是 0。这恰好符合我们在边上打标记的需求。此外，这个标记系统是可以累加的，即你不需要每次计算 Mark，而是可以把 $m$ 条边的 mark 做完之后再一起计算 Mark。这样我们在 $O(m+n)$ 的时间内完成了打标记的动作。加上预处理和计算 LCA 的复杂度，该算法的总时间复杂度为 $O((n+m)\log n)$。&lt;/p&gt;
&lt;h4 id=&#34;做法2-将树上路径求交转化为一维的区间求交&#34;&gt;&lt;strong&gt;做法2: 将树上路径求交转化为一维的区间求交&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;把第一个点对所在的路径 $(u_1, v_1)$ 抓出来，考虑剩下的 $m-1$ 条路径在 $(u_1, v_1)$ 上的相交部分。想象一下容易发现，如果把树中的一条链 $(u_1, v_1)$ 提出来，“用手拎着两端提在空中”，那么整个树的格局会像一个晾衣绳，晾衣绳上的每个点挂了一个树，如下图所示。&lt;/p&gt;
&lt;img src=&#34;https://kristoff-starling.github.io/img/ps-sol-2032-link.png&#34; style=&#34;zoom: 50%;&#34; /&gt;
&lt;p&gt;给 $(u_1, v_1)$ 这条链上的点重新标号 $x_1, x_2,\cdots, x_t$。对于其他任意一个点对 $(u_i, v_i)$，如果 $u_i, v_i$ 在同一个 $x_p$ 的树下 (如图中红色所示)，那么 $(u_i, v_i)$ 这条路径将完全在 $x_p$ 的子树内部，从而和 $(u_1, v_1)$ 没有边的交集；如果 $u_i, v_i$ 在不同的子树 $x_p, x_q (p&amp;lt;q)$ 下 (如图中蓝色所示)，那么 $(u_1, v_1)$ 和 $(u_i, v_i)$ 这两条链将会有 $(x_p, x_q)$ 这一段是公共的。&lt;/p&gt;
&lt;p&gt;对于 $(u_2, v_2), \cdots, (u_m, v_m)$ 中的每一对，我们都可以检查 $u_i, v_i$ 在哪棵子树中，从而算出它和 $(u_1, v_1)$ 的交集。这时问题已经被转化成了在一维序列 $x_1, \cdots, x_t$ 上的区间交集问题。剩下的一点点细节非常简单，留给大家思考。&lt;/p&gt;
&lt;p&gt;这个做法颇有“大道至简”的意味——没有“倍增求LCA”“树上差分“这样炫酷的技术，就是平平无奇的几遍搜索，就给出了更优秀的时间复杂度 $O(n)$。在这里我们也想给大家传递一个价值观：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;高级算法和高级数据结构就像武林中的重武器，而你分析问题、转化问题的能力则像内功。内功和武器是相辅相成的，内功不足却想耍大刀，适得其反。比起盲目地学习很多炫酷的技术，我们更希望大家能充分锻炼自己的思维能力，这才是成为一个优秀的算法设计师的正道。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;做法3-一个神奇的随机算法&#34;&gt;&lt;strong&gt;做法3: 一个神奇的随机算法&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;这个做法有些“过于”精巧，大家只需欣赏即可。&lt;/p&gt;
&lt;p&gt;为每个数对 $(u_i, v_i)$ 随机一个数 $c_i$，并将 $c_i$ 打在 $u_i, v_i$ 两个节点上。对于每条边，砍掉它合法的充分必要条件是这条边下面的子树恰好包含 $c_1, c_2, \cdots, c_m$ 各一个。这件事并不容易检查，但我们直接&lt;strong&gt;对子树上的数值求异或和&lt;/strong&gt;，并通过&lt;strong&gt;检查子树异或和是否等于所有 $c_i$ 的异或和&lt;/strong&gt;的方式来“判定”子树是否满足要求。时间复杂度 $O(n)$。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;看上去有点雷人。下面尝试用不太严谨的方式论证该做法错误的概率极小：&lt;/p&gt;
&lt;p&gt;异或的性质是：$x\otimes x = 0$ (其中 $\otimes$ 常用于表示异或算符)。因此如果一个子树同时包含了一对点 $(u_i, v_i)$ 中的两个或零个，那么它最终的异或和将缺少 $c_i$ 这一项。因此要使得上述随机算法错误，一定存在一个 $\{1, 2, \cdots,m\}$ 的子集 $\{k_1, k_2, \cdots k_t\}$ 满足 $\bigotimes_{i=1}^t c_{k_i} = 0$，且恰好存在一条边能把这个子集精准地“选出来”。&lt;/p&gt;
&lt;p&gt;对于一个集合，若该集合中的数在 $[0, 2^k)$ 之间随机，那么不论这个集合中元素的个数有多少，该集合的异或和为 0 的概率都是 $\frac{1}{2^k}$ (考虑每个二进制位，有若干个要么是 0 要么是 1 的数，但不论有多少，其中有偶数个 1 的概率都是 $\frac{1}{2}$)。&lt;/p&gt;
&lt;p&gt;我们可以不严谨地认为，树上的每条边相当于独立地在 $\{1, 2, \cdots, m\}$ 中选一次子集 (说它不严谨是因为 ①不同的边选出的集合之间存在互相包含关系，并不是独立的； ②该过程和 $2m$ 个数在树上的分布有关，并不是随机选取。但总体可以感受到在概率上两者是同阶的)。因此该算法正确的概率&lt;/p&gt;
&lt;p&gt;$$
P(correct)\sim \left(1-\frac{1}{2^k}\right)^{\min(2^m, n)}
$$&lt;/p&gt;
&lt;p&gt;本题中 $n\sim 10^5$。简单计算可知，当 $k=32$ 时正确率已经达到 $99.997\%$，当 $k=64$ 时该算法正确率将极其接近 $100\%$ (64位恰好是 long long 的范围，在 long long 范围内随机整数并不困难)。&lt;/p&gt;
&lt;p&gt;虽然从理论计算科学的角度，有错误率的随机算法和确保正确的算法之间存在本质区别，但在实际中，如果算法错误的概率已经远小于硬件出错的概率，那么该算法的可用性便已经很高。对于这道题来说，我们确实容易设计出简单高效的线性算法，但事实上，绝大多数问题是难的 (关于难的定义，以及 P, NP, NP-hard 相关的概念大家会在第四学期学习)，对于难问题，很多时候我们只能从近似角度尝试解决。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【问题求解II-HW3.C】单词接龙</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-3-c/</link>
      <pubDate>Sat, 29 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-3-c/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;题意概述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定 $n$ 个英文单词，两个单词可以接在一起当且仅当前一个单词的最后一个字母和后一个单词的第一个字母相同。问最少删除多少个单词可以让剩下的单词全部接龙。&lt;/li&gt;
&lt;li&gt;$n\leq 10^5$。&lt;/li&gt;
&lt;/ul&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;从本次作业开始我们会逐渐向大家介绍简单的动态规划 (dynamic programming) 设计。动态规划是一项“很难教”的技术，因为它没有什么特别的理论基础，好的状态设计和转移优化也没有固定的模式，需要大家多看、多想、多总结。我们通过“单词接龙”这道题来向大家展示好的状态设计是如何显著减少算法时间复杂度的。&lt;/p&gt;
&lt;p&gt;首先，删除尽量少的单词等价于选择尽量多的可接龙单词，因此我们将问题转化为寻找原单词序列的最长可接龙子序列。我们首先考虑如下最容易想到的状态：令 $dp(i)$ 表示&lt;strong&gt;以第 $i$ 个单词结尾&lt;/strong&gt;的最长可接龙子序列的长度。为了计算这个状态，我们需要在 i-th 前找到另外一个单词，满足可以和 i-th 接上。因此转移方程可以写为
$$
dp(i) = 1 + \max_{k\in [1, i-1], word_k \to word_i} dp(k)
$$
其中 $word_i\to word_j$ 表示第 $i$ 个词的最后一个字母和第 $j$ 个词的第一个字母相同。式子最前方的 1 表示第 $i$ 个单词贡献的序列长度。计算完所有的 dp 值之后，$\max_{k=1}^n dp(k)$ 即为答案。&lt;/p&gt;
&lt;p&gt;这自然是一个正确的算法，但计算 $dp(i)$ 时需要依次枚举前面的所有单词，从而时间复杂度达到了 $O(n^2)$，在本题的数据规模下不可接受。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;优化状态设计的动机是：我们最关心的其实是单词的开头/结尾字母，而小写字母一共只有 26 个。因此我们应该在这方面作文章，把每次遍历前面所有单词的过程节省掉。考虑如下状态：令 $dp(i, ch)$ 表示在前 $i$ 个单词中，以字符 $ch$ 结尾的最长可接龙子序列的长度 &lt;strong&gt;(注意！不再要求一定以 $word_i$ 结尾！)&lt;/strong&gt;。转移考虑对以下两种情况取 max：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最长子序列不包括第 $i$ 个单词: $dp(i-1, ch)$。&lt;/li&gt;
&lt;li&gt;最长子序列包括第 $i$ 个单词，且第 $i$ 个单词确实以 $ch$ 结尾: 设第 $i$ 个单词的开头字符为 $ch&amp;rsquo;$，则这种情况的最长序列长度为 $dp(i-1, ch&amp;rsquo;) + 1$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此状态转移方程可以写为&lt;/p&gt;
&lt;p&gt;$$
dp(i, ch) = \begin{cases}
\max\{dp(i-1, ch), dp(i-1, \text{start}(word_i)) + 1\} &amp;amp;, \text{end}(word_i) = ch\\
dp(i-1, ch)&amp;amp;, \text{otherwise}
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;可以看到，虽然状态的数量上升到了 $O(n|\Sigma|)$，但转移的代价变成了 $O(1)$，所以总时间复杂度降低到了 $O(|\Sigma|n)$，其中 $\Sigma$ 为字符集，在本题中 $|\Sigma|=26$，可以通过。&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;有没有什么小技巧可以略微优化一下复杂度？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上述状态转移方程中，我们每次只会对一个 $ch$ 更新 dp，其余的都是照抄。而且 $dp(i, ch)$ 的计算只会用到 $dp(i-1, ch)$ 的结果，因此我们可以把状态的第一维省掉，把代码写成如下形式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dp = [0] * MAX_CHARACTER # 长度为 |Sigma| 的数组
for i in range(1, n + 1):
    # 此时的 dp[ch] 存储的是方程式中 dp(i-1, ch) 的值
    startch, endch = strings[i].start, strings[i].end
    dp[endch] = max(dp[endch], dp[startch] + 1)
    # 根据转移方程，此时 dp[endch] 的值是 dp(i, ch) 的值
    # 又因为其他的 dp[ch] 不需要改变，所以自动“升级”成了 dp(i, ch)
    # 至此，dp[ch] 存储了方程式中 dp(i, ch) 的值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，省掉了第一维之后，动态规划的时间复杂度下降到了 $O(n)$，空间复杂度下降到了 $O(|\Sigma|)$ (不考虑存储字符串的额外代价)。如果字符集的大小达到了很大的级别 (比如 unicode 中的所有字符)，那么这一简单的优化可以节省大量的时间和存储。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;第一个 dp 思路真的是“死胡同”吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;再来重温一下状态转移方程&lt;/p&gt;
&lt;p&gt;$$
dp(i) = 1 + \max_{k\in [1, i), word_k \to word_i} dp(k)
$$&lt;/p&gt;
&lt;p&gt;在考虑 $dp(i)$ 的转移时，我们在意的是所有的那些结尾字母与 $word_i$ 开头字母相同的位置的 dp 的最大值。每次把 1 到 i-1 扫一遍效率太低，但注意我们在做到 $dp(i)$ 时，之前的所有 dp 值已经求好了，因此我们可以额外对每种结尾字母维护当前最大值，从而实现 $O(1)$ 转移。&lt;/p&gt;
&lt;p&gt;形式化地，令
$$
maxdp(i, ch)\triangleq \max_{k\in [1, i],\text{end}(word_k)=ch} dp(k)
$$
则我们可以同时写出 dp 和 maxdp 的状态转移方程&lt;/p&gt;
&lt;p&gt;$$
\begin{align}
dp(i) &amp;amp;= 1 + maxdp(i-1, \text{start}(word_i))\\
maxdp(i, ch) &amp;amp;=
\begin{cases}
\max\{maxdp(i-1, ch), dp(i)\} &amp;amp;, \text{end}(word_i) = ch\\
maxdp(i-1, ch) &amp;amp;, \text{otherwise}
\end{cases}
\end{align}
$$&lt;/p&gt;
&lt;p&gt;两个转移都是 $O(1)$ 的，而且由于 $dp(i)$ 只用到 $maxdp(i-1, ch)$，所以我们可以用和类似的技巧将 maxdp 的第一维度省去，将代码写成类似下面的模样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for i in range(1, n + 1):
    startch, endch = strings[i].start, strings[i].end
    dp[i] = 1 + maxdp[startch]
    maxdp[endch] = max(maxdp[endch], dp[i])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你又可以发现一件事情：$dp(i)$ 在当前循环算完立即使用，且后续再也不会使用，所以可以把 $dp(i)$ 省略：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for i in range(1, n + 1):
    startch, endch = strings[i].start, strings[i].end
    maxdp[s.endch] = max(maxdp[endch], 1 + maxdp[startch])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和之前的代码对比一下，你会发现除了数组名字不一样，其他完全一样。我们用两条看上去不太相同的思考路径得到了相同的结果，但实际上它们的本质是一致的：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态规划状态设计就像给当前时刻做一张“快照”。你需要想清楚快照中保存怎样的性质可以完整地刻画当前的状态并为后续所用。在此基础上，记录的性质应当越少越好。&lt;/strong&gt; 在这个问题中，每个接龙字符串序列的最后一个字符是最本质地刻画特征的性质，而最后一个字符串的下标并不是 ($i+1$ 往后的状态并不关心 $[1,i]$ 中结尾为 $ch$ 的最长接龙字符串序列的最后一个字符串是 $[1, i]$ 中的哪一个)。这就是第一个 dp 方向错误的根本原因。&lt;/p&gt;
&lt;p&gt;大家日后要做的，就是稳准狠地抓住一个状态最本质的性质。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>【问题求解II-HW2.A】取数游戏</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-2-a/</link>
      <pubDate>Fri, 07 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-2-a/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;题意概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个长度为 $2n$ 的数列，保证所有数的和是奇数。两个人轮流取数，每次只能取数列的第一个或最后一个数。问双方都采取最优策略的情况下谁能获得胜利。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;为了说明这道题目的合理性，我们介绍策梅洛定理 (以下是摘自 Wikipedia 的解释)：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In game theory, Zermelo&amp;rsquo;s theorem is a theorem about finite two-person games of perfect information in which the players move alternately and in which chance does not affect the decision making process. It says that if the game cannot end in a draw, then one of the two players must have a winning strategy (i.e. can force a win).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说，一个双方轮流行动的游戏如果满足&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在有限步内结束。&lt;/li&gt;
&lt;li&gt;场上所有信息对双方公开。&lt;/li&gt;
&lt;li&gt;没有随机因素。&lt;/li&gt;
&lt;li&gt;没有平局。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么必然存在先手必胜策略或后手必胜策略。常见的棋类竞技运动如象棋、围棋都是有必胜策略的 (只不过搜索空间太大人们找不到)；当然飞行棋没有必胜策略，因为扔骰子这件事情带来了随机因素。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;回到这道题，如果撇除那条充满诱导性的提示，大家很可能想到的是使用如下的一个递推过程计算谁必胜：令 $s(l, r)$ 表示用区间 $[l, r)$ 中的数玩这个游戏，先手拿到的数的和最多可以比后手多多少。那么有&lt;/p&gt;
&lt;p&gt;$$
s(l, r)=\begin{cases}
0, &amp;amp;l=r\\
\max(\\
\qquad s(l+2, r) + a_l - a_{l+1},\\
\qquad s(l+1, r-1) + a_l - a_{r-1},\\
\qquad s(l+1, r-1) + a_{r-1} - a_l,\\
\qquad s(l, r-2) + a_{r-1} - a_{r-2}\\
), &amp;amp;l &amp;lt; r
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;这个公式看上去复杂，但其实只是枚举了两个人从数列里各取一个数的四种情况： (头,头)，(头,尾)，(尾,头)，(尾,尾)。如果我们认为区间的长度代表这个问题的规模的话，那么我们的递推公式就成功将大规模的问题转化为了小规模的同质问题。如果按照区间长度从小到大的顺序递推，你可以在 $O(n^2)$ 的时间复杂度内计算出 $s(1,2n+1)$，并根据 $s(1,2n+1)$ 的正负性判断谁必胜。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;上面的过程本质上是一个&lt;strong&gt;动态规划 (dynamic programming)&lt;/strong&gt;，如果你没有完全看懂也不要紧 (毕竟还没学)。我们出这道题的根本目的是为了展示一个更妙的想法：&lt;/p&gt;
&lt;p&gt;称 kk 取一个数，ff 再取一个数的两次操作为一轮。考虑每个数在原数列中的下标的奇偶性，我们容易发现：因为任意时刻剩余的数列一定是原数列的一个连续的子区间，所以每一轮开始时，剩余的数列在原数列中的位置一定是 “奇偶奇偶……” 或者 “偶奇偶奇……”。此时 kk 有着挑选奇偶的权利：如果 kk 拿走奇数位置的数，那么 ff 只能从两个偶数位置的数里选一个，反之亦然。&lt;/p&gt;
&lt;p&gt;因为每一轮 kk 都有挑选奇偶的权利，所以 kk 有能力拿走原数列中所有奇数位置的数，或者原数列中所有偶数位置的数。而“所有奇数位置的数的和”与“所有偶数位置的数的和”必定有一个更大，所以 kk 一定能把大的那组拿走，把小的留给 ff。所以这个游戏 kk 必胜。&lt;/p&gt;
&lt;p&gt;这道题旨在展示：通过充分动脑筋，一个看似复杂的问题可以解得非常简单。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【问题求解II-HW1.C】新马走日</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-1-c/</link>
      <pubDate>Thu, 30 Mar 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-1-c/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;题意概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个 $n\times m$ 的棋盘和象棋棋子马的初始位置，问经过 $k$ 步到达棋盘上任意点的方案数。&lt;/p&gt;
&lt;p&gt;$n,m\leq 15, k\leq 10^5$。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;邻接矩阵是描述图的一种常见方法：$\text{ga}(i,j)=1$ 当且仅当图中点 $i,j$ 之间有边。它之所以被称为“矩阵”，是因为矩阵的乘法恰好可以用于描述图上的游走。&lt;/p&gt;
&lt;p&gt;令 $A_k$ 为一个 $n$ 阶矩阵，其中 $A_k(i,j)$ 表示从点 $i$ 走 $k$ 步到点 $j$ 的方案数，那么我们可以发现 $A_0=I,A_1=\text{ga}$。更一般地，我们可以发现&lt;/p&gt;
&lt;p&gt;$$
\forall p, q. A_{p+q}=A_p\cdot A_q
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Proof: 考虑任意点对 $i,j$，从 $i$ 走 $p+q$ 步到 $j$ 可以被分解成两个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从 $i$ 走 $p$ 步到某一个节点 $k$。&lt;/li&gt;
&lt;li&gt;从 $k$ 走 $q$ 步到 $j$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此我们可以枚举这个中间节点 $k$，再根据加法/乘法原理有如下递推式：
$$
A_{p+q}(i,j)=\sum_{k=1}^n A_p(i,k)\cdot A_q(k,j)
$$&lt;/p&gt;
&lt;p&gt;容易发现这恰好是矩阵乘法的计算公式，从而原命题得证。$\square$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，$A_k=\text{ga}^k$。至于如何将原问题转化为一个图上的游走问题，想必你能够自己解决。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>问题求解 I-Final 题解</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/1-final/</link>
      <pubDate>Sun, 05 Mar 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/1-final/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Problem A: BrainF**k Syntax Checker&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题意概括：给定一个 BF 程序，判断它是否符合语法要求。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;BF 程序中的 &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; 显然不会对程序的合法性造成影响，因此本题的主要任务是判断 BF 程序中的 &lt;code&gt;[&lt;/code&gt; &lt;code&gt;]&lt;/code&gt; 是否形成了合法的括号序列，即两两匹配。&lt;/p&gt;
&lt;p&gt;值得注意的是，BF 程序中 &lt;code&gt;[&lt;/code&gt; 和 &lt;code&gt;]&lt;/code&gt; 的个数相同并不是括号序列合法的充要条件，比如 &lt;code&gt;][&lt;/code&gt; 这个序列就是不合法的。在此基础上，我们还要保证 BF 程序的任意前缀中，&lt;code&gt;[&lt;/code&gt; 的个数要大于等于 &lt;code&gt;]&lt;/code&gt; 的个数。&lt;/p&gt;
&lt;details&gt;&lt;summary&gt;&lt;b&gt;Code&lt;/b&gt; &lt;i&gt;[Click to expand]&lt;/i&gt;&lt;/summary&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
 
char program[1000];
string ValidChar = &amp;quot;+-,.&amp;lt;&amp;gt;[]&amp;quot;;
 
int main()
{
    scanf(&amp;quot;%s&amp;quot;, program);
    int len = strlen(program), LeftRightDelta = 0;
    bool flag = true;
    for (int i = 0; i &amp;lt; len; i++)
    {
        if (ValidChar.find(program[i]) == string::npos) flag = false;
        if (program[i] == &#39;[&#39;) LeftRightDelta++;
        if (program[i] == &#39;]&#39;) LeftRightDelta--;
        if (LeftRightDelta &amp;lt; 0) flag = false;
    }
    puts((flag &amp;amp;&amp;amp; LeftRightDelta == 0) ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Problem B: BrainF**k Interpreter&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题意概括： 给定一个 BF 程序，模拟其运行过程并输出最后的内存状态。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这是一道相当有意思的题目，解法也很多。该问题的核心难点是如何处理嵌套的中括号。考场上有很多同学利用递归处理中括号的嵌套，这是一个很好且可行的思路。我们在这里介绍另外一种不需要递归的思路，它书写起来更加简洁，且在一定程度上揭示了计算机运行的本质——大家在本学期的 &lt;em&gt;数字逻辑与计算机组成&lt;/em&gt; 和下学期的 &lt;em&gt;计算机系统基础&lt;/em&gt; 中会不断与这种逻辑打交道。&lt;/p&gt;
&lt;p&gt;在题面的提示中我们已经给出了计算机执行指令的四步骤，我们在这里再重复一遍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取指：取出下一条执行的指令。&lt;/li&gt;
&lt;li&gt;译码：根据指令的格式确定该指令的类型。&lt;/li&gt;
&lt;li&gt;执行：根据指令类型，执行该指令定义的动作。&lt;/li&gt;
&lt;li&gt;跳转：根据指令类型和执行过程，确定下一条应当执行的指令的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;真正的计算机处理的是“汇编语言”，我们的 BF 解释器处理的是 BF 语言，这两者在本质上没有区别。计算机内部通常有一个程序计数器 (program counter, 简称 pc)，它的功能和计数没什么关系，反而像一个指针，用来指向下一条要执行的指令。我们来具体地看看四个步骤对应到 BF 语言应当如何操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;取指：这是最简单的一步，对应到 C++ 代码大概就是 &lt;code&gt;char instruction = program[pc]&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;译码&amp;amp;执行：这两步在 BF 中可以放在一起做 (因为 BF 的所有指令都没有“操作数”)，你大抵会用一个 if/switch 语句来判断 instruction 是 8 个符号中的哪一种并执行相应的操作。前 6 种指令的操作都非常简单，这里不再赘述。&lt;code&gt;[&lt;/code&gt; 和 &lt;code&gt;]&lt;/code&gt; 本质上是分支控制指令，所以在“执行”这个步骤中它们什么也不用做。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跳转：前 6 种指令的跳转都非常简单：做完了就做紧接着的下一条指令，即 &lt;code&gt;pc++&lt;/code&gt;。我们着重讲解 &lt;code&gt;[&lt;/code&gt; 和 &lt;code&gt;]&lt;/code&gt; 的跳转如何处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[&lt;/code&gt;：左中括号指令的逻辑是
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;if (memory[pointer] != 0)
    pc++ // go into the loop
else
    pc = (the position of the corresponding &amp;quot;]&amp;quot;) + 1 // skip the loop
&lt;/code&gt;&lt;/pre&gt;
&lt;code&gt;pc&lt;/code&gt; 直接加一意味着进入循环，&lt;code&gt;pc&lt;/code&gt; 跳转到对应的 &lt;code&gt;]&lt;/code&gt; 的下一条指令意味着跳过循环。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;]&lt;/code&gt;：右中括号指令的逻辑是
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;pc = (the position of the corresponding &amp;quot;[&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
遇到右中括号，无条件跳转到对应的左中括号，开始新一轮循环条件判断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意到 &lt;code&gt;[&lt;/code&gt; 和 &lt;code&gt;]&lt;/code&gt; 的处理都依赖与之匹配的“另一半”，因此在正式开始执行程序之前，我们要预处理一遍程序以知道与每个 &lt;code&gt;[&lt;/code&gt;/&lt;code&gt;]&lt;/code&gt; 配对的 &lt;code&gt;]&lt;/code&gt;/&lt;code&gt;[&lt;/code&gt; 在什么位置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按照这四个步骤书写本题的代码，可以完成得轻松且高效，从中你也可以领悟到计算机系统设计的伟大智慧。&lt;/p&gt;
&lt;details&gt;&lt;summary&gt;&lt;b&gt;Code&lt;/b&gt; &lt;i&gt;[Click to expand]&lt;/i&gt;&lt;/summary&gt;
&lt;p&gt;注：下面参考程序仅仅实现了一个 BF 解释器，输入格式和输出格式与原题并不相同。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int memory[1000], pointer;
char program[1000]; int n;

int input_count, input[1000];

int jumpto[1000], stk[1000], stot;

int main ()
{
    scanf(&amp;quot;%s&amp;quot;, program); n = strlen(program);
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;input_count);
    for (int i = 1; i &amp;lt;= input_count; i++) scanf(&amp;quot;%d&amp;quot;, input + i);

    // 预处理每个 [ 和 ] 对应的 ]/[
    stot = 0;
    for (int i = 0; i &amp;lt; n; i++)
    {
        if (program[i] == &#39;[&#39;) stk[++stot] = i;
        if (program[i] == &#39;]&#39;)
        {
            jumpto[i] = stk[stot];
            jumpto[stk[stot]] = i + 1;
            stot--;
        }
    }

    pointer = 0;
    int pc = 0, input_pt = 0;
    bool printed = false;
    while (pc &amp;lt; n)
    {
        int next_pc = pc + 1;
        switch (program[pc])
        {
            case &#39;+&#39;: memory[pointer]++; break;
            case &#39;-&#39;: memory[pointer]--; break;
            case &#39;&amp;lt;&#39;: pointer--; break;
            case &#39;&amp;gt;&#39;: pointer++; break;
            case &#39;,&#39;: memory[pointer] = input[++input_pt]; break;
            case &#39;.&#39;: printf(&amp;quot;%d &amp;quot;, memory[pointer]); printed = true; break;
            case &#39;[&#39;:
                if (memory[pointer] == 0)
                    next_pc = jumpto[pc];
                break;
            case &#39;]&#39;: next_pc = jumpto[pc]; break;
        }
        pc = next_pc;
    }
    if (printed) puts(&amp;quot;&amp;quot;);
    for (int i = 0; i &amp;lt; 10; i++)
        printf(&amp;quot;%d &amp;quot;, memory[i]);
    puts(&amp;quot;&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Problem C: DXY&amp;rsquo;s Graph Problem&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题意概括：给定一张图 $G=(V, E)$，其中 $V$, $E$ 分别是点和边的集合。对于图中任意顶点 $v\in V$，令 $\text{cover}(v)\triangleq \{(x, y)\in E: x=v\vee y=v\}$ (即与该点相邻的所有边的集合)。问是否存在原图顶点的划分 $S_1, S_2$，满足 $S_1\uplus S_2=V$ (即 $S_1\cup S_2=V$ 且 $S_1\cap S_2=\emptyset$)，且&lt;/p&gt;
&lt;p&gt;$$
\bigcup_{v\in S_1}\text{cover}(v)=\bigcup_{v\in S_2}\text{cover}(v)=E
$$&lt;/p&gt;
&lt;p&gt;(注：本题完整题意里中文描述中有关“DXY可以通过自己的点集将原图恢复”的部分给大家带来了较大困扰，对此我们深表歉意。)&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;每条边都有两个端点，要想这条边被双方都覆盖到，那么这两个端点必须分属于不同的集合。因此可以成功划分的充要条件是：存在将整张图上的顶点黑白染色，且每条边的两个端点一黑一白的方案。&lt;/p&gt;
&lt;p&gt;我们容易发现这样的方案如果存在一定是唯一的，因为我们已经规定了 1 号点属于 DXY，我们不妨将白色分配给 DXY，那么整个过程相当于从一个白色的 1 号点开始向外搜索，每搜索到一个新的节点就给它涂上和邻居节点不同的颜色。由于整个图是连通的 (即任意两个节点都存在路径互相可达)，所以这样的搜索一定能给每个节点一个唯一的颜色 (如果你想要严谨地证明，可以考虑数学归纳法)。在搜索的过程中，如果发现无法解决的矛盾 (例如某个节点同时和一个黑点和白点相邻)，则问题无解。&lt;/p&gt;
&lt;p&gt;如果你愿意继续深究这个问题 (这部分知识对于解决这道题并无必要)，你会发现可以成功黑白染色充要条件是&lt;strong&gt;图中不存在奇数长度的环&lt;/strong&gt;，这也是判断二分图 (Bipartite Graph) 的方法，大家在后续的问题求解课程中会学习到这个概念和相关的证明。&lt;/p&gt;
&lt;details&gt;&lt;summary&gt;&lt;b&gt;Code&lt;/b&gt; &lt;i&gt;[Click to expand]&lt;/i&gt;&lt;/summary&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
 
const int MAXN = 1e5 + 10;
 
int n, m;
vector&amp;lt;int&amp;gt; v[MAXN];
 
int color[MAXN];
bool flag;
 
void dfs(int cur)
{
    for (auto neighbor : v[cur])
        if (color[neighbor] == 0)
        {
            color[neighbor] = 3 - color[cur]; 
            // 两种颜色用 1, 2 表示
            // 3 - color[cur] 则表示“另一种颜色”
            dfs(neighbor);
        }
        else if (color[neighbor] != 3 - color[cur])
            flag = false;
         
}
 
int main ()
{
    scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m); int x, y;
    for (int i = 1; i &amp;lt;= m; i++)
    {
        scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;x, &amp;amp;y);
        v[x].push_back(y); v[y].push_back(x);
    }
     
    color[1] = 1; flag = true;
    dfs(1);
     
    if (flag)
    {
        puts(&amp;quot;Yes&amp;quot;);
        int cnt1 = 0, cnt2 = 0;
        for (int i = 1; i &amp;lt;= n; i++) if (color[i] == 1) cnt1++; else cnt2++;
        printf(&amp;quot;%d %d\n&amp;quot;, cnt1, cnt2);
        for (int i = 1; i &amp;lt;= n; i++) if (color[i] == 1) printf(&amp;quot;%d &amp;quot;, i);
        puts(&amp;quot;&amp;quot;);
        for (int i = 1; i &amp;lt;= n; i++) if (color[i] == 2) printf(&amp;quot;%d &amp;quot;, i);
        puts(&amp;quot;&amp;quot;);
    }
    else
        puts(&amp;quot;No&amp;quot;);
     
    return 0;
     
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;</description>
    </item>
    
    <item>
      <title>【问题求解I-HW6.C】万圣节的新娘</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/1-6-c/</link>
      <pubDate>Wed, 14 Dec 2022 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/1-6-c/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;题意概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定 $n$ 个数对，保证 $1\cdots n$ 中的每个数恰好出现两次。每次操作可以任意交换两个数的位置。问至少多少次交换可以使得每对数都相同。&lt;/p&gt;
&lt;p&gt;约束条件：$n\leq 10^6$。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这道题颇有思维难度，需要仔细观察并发现问题的性质。发现问题的性质不能靠双眼瞪着屏幕——动起手来，画几个样例手算出解法，很多时候解决问题的灵感就是从手算得出的。&lt;/p&gt;
&lt;p&gt;我们首先可以确定一件事：答案的上限是 $n-1$，因为每轮操作你总可以让某一个数对匹配起来。如果你手算尝试了一些样例，你一定会发现想要让交换次数最少，我们会格外喜欢这样的数对：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;1 2
2 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为我们只要让上面的 2 和下面的 1 交换，我们就可以一下子得到两个匹配的数对，这看起来非常赚。但不是什么时候都能有“动一次成两对”这么赚的事情，你很快会发现有的时候格局可能是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;1 2
2 3
3 5
5 8
8 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过观察你可以发现：这样的 5 个数对你只要将前 4 个搞定，最后一个也会随之搞定，且你无法给出比 4 次交换更好的方案。&lt;/p&gt;
&lt;p&gt;你是否觉得上面的 5 个数对像是 &lt;code&gt;1, 2, 3, 5, 8&lt;/code&gt; 五个数构成的环？事实上，稍加思索你便能发现 $n$ 个数对其实就是由这样的若干个互不影响的“环”组成的。每个环形如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;a1 a2
a2 a3
...
an-1 an
an a1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样一个长度为 $n$ 的环，我们需要 $n-1$ 次操作将其全部搞定，每有一个“环”，我们就可以“节省”一次操作。因此，设 $n$ 个数对共由 $m$ 个环构成，那么最小的操作次数就是 $n-m$。&lt;/p&gt;
&lt;p&gt;判断环的个数相对简单，你并不一定需要使用“并查集”这样高级的数据结构——事实上搜索已经足够完成任务了，这部分的细节留给大家自行思考。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【问题求解I-HW4.C】jyy为什么是神</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/1-4-c/</link>
      <pubDate>Thu, 27 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/1-4-c/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;题意概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定字符串 $s$，求 $|\{(i,j,k)|s_i=j,s_j=y,s_k=y\}|$。&lt;/p&gt;
&lt;p&gt;约束条件：$|s|\leq 10^6$。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;大家容易想到的一个非常简明的做法是使用三重循环计数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ans = 0;
for (int i = 0; i &amp;lt; int(s.size()); i++)
    for (int j = i + 1; j &amp;lt; int(s.size()); j++)
        for (int k = j + 1; k &amp;lt; int(s.size()); k++)
            if (s[i] == &#39;j&#39; &amp;amp;&amp;amp; s[j] == &#39;y&#39; &amp;amp;&amp;amp; s[k] == &#39;y&#39;)
                ans++;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但由于此题中 $|s|$ 达到了 $10^6$，使用三重循环意味着循环最内层的核心语句被执行了将近 $|s|^3$ 次。计算机一秒钟可以执行的 C/C++ 基本语句数目大约在 $10^8$ 量级，这样的程序显然会超时。&lt;/p&gt;
&lt;p&gt;本题的出题助教 (aka. dxy) 希望大家构造自动机解题。这里我们给出一个另外的比较简单的思路：&lt;/p&gt;
&lt;p&gt;我们将上面的程序改写为如下伪代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ans = 0;
for (int i = 0; i &amp;lt; int(s.size()); i++)
    if (s[i] == &#39;j&#39;)
        ans += &amp;quot;s[i]的后面(可以不连续)的yy的数目&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之前的代码中我们使用双重循环来数 &amp;ldquo;yy&amp;rdquo; 的个数，但事实上我们有更快速的方法：假设 &lt;code&gt;s[i]&lt;/code&gt; 的后面一共有 &lt;code&gt;n&lt;/code&gt; 个字母y，那么任意挑选两个都可以组成一个yy，所以yy的总数目是 $\binom{n}{2}=\frac{1}{2}n(n-1)$。基于这个想法，我们可以用一个二重循环解决该问题：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ans = 0;
for (int i = 0; i &amp;lt; int(s.size()); i++)
    if (s[i] == &#39;j&#39;)
    {
        int y_count = 0;
        for (int j = i + 1; j &amp;lt; int(s.size()); j++)
            if (s[j] == &#39;y&#39;) y_count++;
        ans += C(y_count, 2); // 组合数需要另外实现
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们的算法已经得到了改进，但 $|s|^2$ 次运行仍然无法在规定时间内获得结果，算法还需要进一步的优化。上述方法的瓶颈在于我们每遇到一个j都会把它后面的y数一遍，这样有很多的字母y被反复数了很多遍，这无疑拖慢了速度。&lt;/p&gt;
&lt;p&gt;事实上，一个巧妙的顺序的改变就可以“柳暗花明”：我们将外层循环的顺序倒过来，一边寻找j一边把j“身后”的y的个数数出来，这样就不需要内层循环了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ans = y_count = 0;
for (int i = int(s.size()) - 1; i &amp;gt;= 0; i--) {
    if (s[i] == &#39;y&#39;) y_count++;
    if (s[i] == &#39;j&#39;) ans += C(y_count, 2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;循环的使用方法博大精深，大家可以仔细体会这段代码。&lt;/p&gt;
&lt;p&gt;此外，本题由于结果过大，最终需要输出答案对 $998244353$ 取模的结果。大家在本题中可能会使用乘法，此时必须格外小心两个 &lt;code&gt;int&lt;/code&gt; 类型变量相乘 (还没来得及取模时) 结果溢出的情况，一个好的解决方案是使用更大的数据类型存储中间结果。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
