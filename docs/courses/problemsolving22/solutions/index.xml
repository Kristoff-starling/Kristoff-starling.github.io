<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OJ习题讲解 | Yuyao Wang&#39;s Homepage</title>
    <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/</link>
      <atom:link href="https://kristoff-starling.github.io/courses/problemsolving22/solutions/index.xml" rel="self" type="application/rss+xml" />
    <description>OJ习题讲解</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sat, 18 Nov 2023 00:00:00 +0000</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>OJ习题讲解</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/</link>
    </image>
    
    <item>
      <title>问题求解III-HW09 题解</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/3-9/</link>
      <pubDate>Sat, 18 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/3-9/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Problem A: 电路交换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个流网络，求最大流。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这是一道纯正的模板题，不过我们希望大家可以尽可能学会一个高效的最大流算法实现，你可以选择学习&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增广路流派: Dinic/SAP。&lt;/li&gt;
&lt;li&gt;预流推进流派: HLPP。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中 Dinic 算法较为简单。&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Problem B: 探索遗迹&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;给定一个 $n\times n$ 的网格，第 $i$ 行第 $j$ 列格子的权值为 $w(i, j)$。现希望选出一个集合 $S\subseteq \{1,\cdots, n\}\times \{1,\cdots, n\}$，满足&lt;/p&gt;
&lt;p&gt;$$
\forall (x_1, y_1), (x_2, y_2)\in S, \lnot \text{adjacent}((x_1, y_1), (x_2, y_2))
$$&lt;/p&gt;
&lt;p&gt;且
$$
\sum_{(x, y)\in S}w(x, y)
$$&lt;/p&gt;
&lt;p&gt;最大。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$2\leq n\leq 25$。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;本题的数据范围容易让人想到使用状态压缩动态规划求解：令 $dp(i, Mask)$ 表示当前考虑到第 $i$ 行，上一行宝箱选择状态为 $Mask$ 的情况下的最大收益，转移考虑枚举当前行的选择即可。该思路和第8周习题“炮兵阵地”的解法类似，但本题的数据范围稍大，恰好使得该做法无法通过 &lt;del&gt;(事实上我们是故意这样设计的)&lt;/del&gt;。&lt;/p&gt;
&lt;p&gt;本题的典型解法是使用网络流，且采用了一种“最小割建图”的思路。这种思路比较精巧，如果之前从未见过，只需欣赏即可。&lt;/p&gt;
&lt;p&gt;我们首先转化一下问题：从方格阵中抛弃最小代价的宝物，使得剩下的宝物满足不相邻的要求。然后构建这样一个流网络：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该网络包含一个超级源点，超级汇点，和为每个方格建立的顶点，共 $n\times n+2$ 个。&lt;/li&gt;
&lt;li&gt;将原方格图黑白染色，将两种颜色的格子分别连到源点和汇点，边的权值为该点的权值。更具体地，对于一个方格 $(x, y)$ 如果 $x+y$ 为奇数，则从源点向它连边，权值为 $w(x, y)$；如果 $x+y$ 为偶数，则从它向汇点连边，权值为 $w(x, y)$。在求割的时候，如果一个方格顶点与源点/汇点的边被割去了，则认为我们“抛弃”了这个宝物。&lt;/li&gt;
&lt;li&gt;对于方格图中每组相邻的格子，从“奇数坐标和”点向“偶数坐标和”点连一条权值为 $\inf$ 的边。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以证明，这个网络的最小割就是满足要求的最小代价。这是因为该网络中从超级源点走向超级汇点的通路均满足 $S\to v_1\to v_2\to T$ 的形式，其中 $S/T$ 表示超级源点/汇点，$v_1, v_2$ 为一对相邻的方格顶点。因为 $v_1\to v_2$ 的边权值是 $\inf$，所以要破坏这条通路，我们必然要割去 $S\to v_1$ 或 $v_2\to T$ 里的至少一条，即相邻的两个方格必然会抛弃至少一个。因此任意一个割给出的都是合法方案，而最小割给出的就是最优方案。&lt;/p&gt;
&lt;p&gt;根据最大流最小割定理，我们只需求解该网络从 $S$ 到 $T$ 的最大流即可。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>问题求解III-HW08 题解</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/3-8/</link>
      <pubDate>Mon, 13 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/3-8/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Problem A: 加油&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;给定 $n$ 个二元组 $(x_1, y_1)\cdots (x_n, y_n)$，另给定 $k$，求 $S\subseteq \{1,\cdots, n\}$，满足&lt;/p&gt;
&lt;p&gt;$$
\sum_{i\in S} x_i = k\cdot \sum_{i\in S}y_i
$$
且
$$
\sum_{i\in S} x_i + y_i
$$
最大。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$n\leq 100, 1\leq k\leq 10, 1\leq x_i, y_i\leq 100$。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;考虑如下动态规划：令 $dp(i, j)$ 表示当前考虑到第 $i$ 个物品，当前第一种混合物与第二种混合物达成 $k$ 的比例后还富余/亏欠 $j$ 的情况下，选取所有物品的最大重量。转移和背包问题类似，考虑当前物品选或不选：&lt;/p&gt;
&lt;p&gt;$$
dp(i, j) = \max\{dp(i-1, j), dp(i-1, j - (x_i - k\cdot y_i)) + x_i + y_i\}
$$&lt;/p&gt;
&lt;p&gt;$dp(n, 0)$ 即为最终的答案。&lt;/p&gt;
&lt;p&gt;在实现上有几个细节需要注意，以下分析中记 $x_i, y_i$ 的最大值为 $v(v\leq 100)$：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;该 dp 状态中 $j$ 的值可以是负数，但 C/C++ 代码中不方便直接用数组实现负数的下标索引。因此我们可以先预估 $j$ 的真实值域，记为 $[-l, r]$，然后用数组的 $[0, l + r]$ 来模拟这个区间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对 $l, r$ 的预估将直接影响算法的时间和空间复杂度。一个简单且有效的预估是：如果当前的“亏欠值”已经大于了 $v\cdot n$，那么无论怎么选也“补救”不回来了。另一方面，即使将所有物品全选，第一种混合物的总量也不会超过 $v\cdot n$，所以令 $l, r=v\cdot n$ 是合理的。&lt;/p&gt;
&lt;p&gt;值得注意的是，该 dp 第二维的真实值域其实大约是 $[-k\cdot vn, vn]$，但我们通过分析“最大的可补救范围”大大缩小了负数方向的范围，算得上是一种“剪枝”。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;时间复杂度上，动态规划的总状态数为 $O(n^2v)$，转移是 $O(1)$ 的，因此总时间复杂度为 $O(n^2v)$。如果没有考虑到上述的对第二维值域的剪枝，时间复杂度为 $O(n^2kv)$ 的算法也可以通过本题，但需要指出本题的较优实现可以做到复杂度与 $k$ 无关。&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Problem B: 炮兵阵地&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;给定 $n\times m$ 的方格，坐标为 $(i, j)$ 的格子是否可以放置炮兵的状态记为 $\text{accept}(i, j)$。求集合 $S\subseteq \{1,\cdots n\}\times \{1,\cdots m\}$，满足&lt;/p&gt;
&lt;p&gt;$$
\begin{align}
&amp;amp;\forall (x, y)\in S, \text{accept}(x, y)=\mathbf{True} \ \wedge \\
&amp;amp;\forall (x_1, y_1), (x_2, y_2)\in S, (x_1\neq x_2\vee y_1\neq y_2) \\
&amp;amp;\qquad \Rightarrow (x_1=x_2\to |y_1-y_2|&amp;gt;2 \wedge y_1=y_2\to |x_1-x_2|&amp;gt;2)
\end{align}
$$&lt;/p&gt;
&lt;p&gt;且 |S| 最大。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$n\leq 100, m\leq 10$。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;考虑状态压缩动态规划：令 $dp(i, Mask_1, Mask_2)$ 表示当前考虑到第 $i$ 行，第 $i-1$ 行炮兵的布置情况为 $Mask_1$，第 $i-2$ 行炮兵的布置情况为 $Mask_2$ 的情况下最多能布置多少个炮兵 (之所以记录两行是因为第 $i$ 行炮兵向上的覆盖范围最多与前两行有交集)。转移考虑当前行的炮兵布置情况，状态转移方程为&lt;/p&gt;
&lt;p&gt;$$
\begin{align}
&amp;amp;dp(i, Mask_1, Mask_2) \to dp(i + 1, Mask, Mask_1) + \text{count_one}(Mask)\\
&amp;amp;\qquad if\ \text{valid}(Mask, Mask_1, Mask_2)
\end{align}
$$&lt;/p&gt;
&lt;p&gt;其中 $\text{valid}$ 函数检查三行的炮兵部署是否合法。该动态规划的时间复杂度看似为 $O(2^{3m}\cdot n)$，但事实上由于同行的炮兵之间距离至少为 3，所以 $m\leq 10$ 时在本行内合法的状态数很少 (不超过 70，远小于 $2^{10}$)，因此可以通过。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>问题求解III-HW07 题解</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/3-7/</link>
      <pubDate>Mon, 06 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/3-7/</guid>
      <description>&lt;p&gt;(TBA)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>问题求解III-HW06 题解</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/3-6/</link>
      <pubDate>Mon, 30 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/3-6/</guid>
      <description>&lt;p&gt;(TBA)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>问题求解III-HW05 题解</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/3-5/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/3-5/</guid>
      <description>&lt;p&gt;(TBA)&lt;/p&gt;
&lt;!-- &lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Problem A: 最小环&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定一个 $n$ 个点 $m$ 条边的无向图，求权值最小的非平凡环。&lt;/li&gt;
&lt;li&gt;$n\leq 200, m\leq 6000$。&lt;/li&gt;
&lt;/ul&gt;

  &lt;/div&gt;
&lt;/div&gt;


求图的最小环 (也称为图的围长(girth)) 有多种常见的思路，以下介绍两种方法，分别适用于稀疏图和稠密图。

**基于删边+最短路的算法**

枚举图中的每条边，对于一条边 $(u, v)$，求出不经过这条边从 $u$ 到 $v$ 的最短路，这样拼上边 $(u, v)$ 就找到了经过边 $(u, v)$ 的最小环。

该算法需要枚举每条边，暂时性地删除该边之后跑一遍 Dijkstra 算法，故时间复杂度为 $O(m^2\log n)$，适用于稀疏图。

**基于Floyd的算法** --&gt;&lt;blockquote&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>问题求解III-HW04 题解</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/3-4/</link>
      <pubDate>Thu, 28 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/3-4/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Problem A: 飘雪圣域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一张 $n$ 个点 $m$ 条边的图，求图的割点。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;求图的割点有著名的时间复杂度为 $O(n+m)$ 的 Tarjan 算法，此处不做赘述。&lt;/p&gt;
&lt;hr&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Problem B: 同色三角形&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一张 $n$ 个点的完全图，每条边为黑色或白色，问图中有多少个同色三角形。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;del&gt;作为中秋+国庆放假的福利，本题设置的数据范围可以允许最简单的 $O(n^3)$ 枚举算法通过&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;这里主要讲解非平凡的 $O(n^2)$ 做法应当如何实现；将复杂度优化到平方级需要仔细分析该问题的性质以减少枚举的次数。&lt;/p&gt;
&lt;p&gt;枚举同色三角形似乎很难逃出三方枚举的困境——对于每个顶点 $u$，它的任意两条同色边关联的相邻点 $v_1, v_2$ 都需要再检查边 $(v_1, v_2)$ 的颜色。因此我们换一个角度考虑：该图中三角形的总数为 $\binom{n}{3}$，我们只要转而计算图中非同色三角形的数目，就可以算出同色三角形的数目。&lt;/p&gt;
&lt;p&gt;另一个重要的观察是：&lt;strong&gt;对于任意顶点 $u, v_1, v_2$，如果 $\text{color}(u, v_1)\neq \text{color}(u, v_2)$，那么无论边 $(v_1, v_2)$ 是什么颜色，$(u, v_1, v_2)$ 都一定能形成一个异色三角形。&lt;/strong&gt; 进一步地，记 $black_u$ 表示 $u$ 的黑色邻边的数目，那么顶点带有 $u$ 的异色三角形数目为 $black_u\cdot (n-1-black_u)$。因此，同色三角形的数目为&lt;/p&gt;
&lt;p&gt;$$
ans=\binom{n}{3} - \frac{1}{2}\sum_{u\in V}black_u\cdot (n - 1 - black_u)
$$&lt;/p&gt;
&lt;p&gt;公式中的 $1/2$ 来源于一个异色三角形会被它的两个“异色邻边顶点”计算两次。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>问题求解III-HW03 题解</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/3-3/</link>
      <pubDate>Thu, 21 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/3-3/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Problem A: 一笔画&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;求无向图 $G=(V, E)$ 的欧拉回路。&lt;/li&gt;
&lt;li&gt;$|V|\leq 10^5, |E|\leq 10^6$。&lt;/li&gt;
&lt;/ul&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;本题数据范围较大，使用 fleury 算法无法通过，需要实现线性的 Hierholzer 算法。Hierholzer 算法的思路如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果存在奇数度数点 $u, v$，则取任意一条 $uv$ 迹，否则取图中任意一条迹。记当前的路径为 $T$。&lt;/li&gt;
&lt;li&gt;取 $T$ 中仍有未访问邻边的非孤立节点 $w$，寻找一条 $ww$ 迹，将这条闭迹插入到 $T$ 中。&lt;/li&gt;
&lt;li&gt;重复步骤 2 直到所有的边均被访问。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;寻找合法的 $uv$ 迹和 $ww$ 迹看似困难，其实在如下几条性质的加持下非常简单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在一个有两个奇数度数节点的图中从一个奇点出发，以任意方法不走重复边地遍历，直到走到死路，最后一定停留在另一个奇点上。且去掉这条迹之后，图中所有点度数均为偶数。&lt;/li&gt;
&lt;li&gt;在一个所有节点度数均为偶数的图中从任意节点 $w$ 出发，以任意方法不走重复边地遍历，直到走到死路，最后一定回到 $w$。且去掉这条迹之后，图中所有点度数仍然均为偶数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两条性质的证明并不困难，形象化地，对于一个偶数度数点来说，有“进”则必有“出”，所以最后一定会停在奇点/出发点上。因此在上述算法中，所有找迹的部分只要“闷头向前搜”即可。&lt;/p&gt;
&lt;p&gt;现在的另外一个问题是：如何寻找步骤2中的合法出发点 $w$，以及找到 $ww$ 迹之后如何高效插入。Hierholzer 算法存在经典且精巧的回溯实现可以完成这两件事。我们直接给出伪代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def hierholzer(u):
    for (u, v) in G.edges:
        delete (u, v) from G.edges
        hierholzer(v)
    path.append(u)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大家可以仔细阅读这段代码并思考两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该函数是如何通过回溯找到当前路径上仍有出边的节点的？&lt;/li&gt;
&lt;li&gt;该函数在走完所有 $u$ 的出边后将 $u$ 加入路径，该顺序是如何做到将步骤 2 中的 $ww$ 迹“插入”原路径的？&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Problem B: 观光&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;求带权无向图 $G=(V,E)$ 中权值最小的哈密尔顿路径。&lt;/li&gt;
&lt;li&gt;$|V|\leq 15$。&lt;/li&gt;
&lt;/ul&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;做法1-折半搜索&#34;&gt;做法1: 折半搜索&lt;/h3&gt;
&lt;p&gt;折半搜索的主要思想是将一个大任务拆成两个规模各为一半的子任务，然后尝试在中间将两部分的结果拼接起来。假设我们可以高效地拼接，记原算法复杂度为 $f(n)$，则折半搜索可以将复杂度优化为 $2\cdot f(n/2)$。当 $f$ 是一个指数或更高阶的函数时，折半搜索通常能显著降低复杂度。&lt;/p&gt;
&lt;p&gt;直接阶乘枚举所有可能路径的时间复杂度为 $O(n!)$。如果使用折半搜索，我们可以计算图中所有节点数为 $n/2$ 的路径的长度。然后枚举每条“半路径”(此时另一半路径的顶点已知)和另一半路径与当前路径连接的端点，更新最短的哈密尔顿路径。时间复杂度为 $O(C(n, n/2)\cdot n)$。&lt;/p&gt;
&lt;h3 id=&#34;做法2状态压缩动态规划&#34;&gt;做法2：状态压缩动态规划&lt;/h3&gt;
&lt;p&gt;本题更正统的做法是采取状态压缩动态规划。所谓状态压缩，是指用一个 01 串表示当前已经经过的顶点的集合 (1表示已经走过)，这样一个 01 串又可以映射到一个十进制数的二进制表示，因此我们可以用 $[0, 2^n)$ 中的整数来刻画所有可能的经过状态。以下为了表示方便，我们以 $0$ 到 $n-1$ 标号节点。&lt;/p&gt;
&lt;p&gt;令 $dp(Mask, u)$ 表示当前已经经过的节点集合为 Mask，当前节点为 $u$ 的情况下，$Mask$ 中经过节点构成的哈密尔顿路径的最短长度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;边界条件是容易的：对于所有的 $0\leq x\leq n-1$，有 $dp(2^x, x)=0$ (只有一个点的路径，当前长度为 0)。&lt;/li&gt;
&lt;li&gt;转移只需枚举路径下一个节点 $v$(需要保证 $v$ 尚未经过)，状态转移方程式为
$$
dp(Mask|2^v, v) = \min\{dp(Mask|2^v, v), dp(Mask, u) + c(u, v)\}
$$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最终答案为
$$
ans = \min_{0\leq x&amp;lt;n}dp(2^n-1, x)
$$
状态的数量为 $O(2^n\cdot n)$，每个状态可以向 $O(n)$ 个状态转移，因此总时间复杂度为 $O(2^n\cdot n^2)$。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>问题求解III-HW02 题解</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/3-2/</link>
      <pubDate>Sun, 17 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/3-2/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Problem A: 补图最短路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一张不带权无向图，求其补图中1号点到其他各个点的最短路。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;本题由于数据规模较小 ($n,m\leq 500$)，所以大家可以直接求出补图并用 BFS 求出所有的最短路。因为补图的边数是 $O(n^2)$ 级的，所以该做法时间复杂度为 $O(n^2)$。&lt;/p&gt;
&lt;p&gt;事实上，本题存在 $O(n+m)$ 的做法：与BFS用图中的边去更新可达关系相反，我们可以直接用当前图中的边去更新补图中的不可达关系。下面直接给出算法流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;维护一个集合 $S$ 表示当前 1 号点不可达的顶点集合，初始 $S=V-\{1\}$。&lt;/li&gt;
&lt;li&gt;每次选择一个尚未访问且到1号点距离最短的顶点 $v$，令 $S&#39;=S\cap Neighbor(v)$，则 $S-S&#39;$ 中的顶点在原图中可以通过 $v$ 到达，更新距离；同时更新 $S=S&#39;$。将 $v$ 标记为已访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Problem B: 单词接龙&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定 $\text{beginWord}$, $\text{endWord}$ 和一个单词池，求从开始词到结束词最短的接龙序列，接龙序列中相邻的单词只能有一个字母不同。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如果将每个单词看作图上的顶点，两个单词之间连边当且仅当他们相差一个字母，那么原问题就转化为了从开始词顶点到结束词顶点的最短路径问题，可以通过 BFS 解决。&lt;/p&gt;
&lt;p&gt;最朴素的想法是枚举所有的单词对并判断是否可以连边。该做法的时间复杂度为 $O(n^2\cdot l)$，其中 $l$ 为单词的长度。&lt;del&gt;虽然有很多人这样水过了&lt;/del&gt;需要继续优化。&lt;/p&gt;
&lt;p&gt;朴素做法过慢的一个原因是：有太多不可能连边的单词对被枚举了——一个单词不可能有这么多的“相邻”单词。事实上，一个单词的相邻单词数最多为 $|\Sigma|\cdot l$，其中 $\Sigma$ 为字符集。因此，我们可以将单词池中的单词加入哈希表，对每个单词枚举它所有可能的相邻单词 (枚举位置+替换字母) 并在哈希表中查询是否存在，如果存在则连边。这样算法复杂度降到 $O(n\cdot |\Sigma|\cdot l)$，可以通过。&lt;/p&gt;
&lt;p&gt;本题的 $\Sigma$ 为小写字母集。如果 $\Sigma$ 很大上述做法仍然效率过低。事实上我们有更巧妙的建图方法：以单词 &lt;code&gt;cat&lt;/code&gt; 为例，我们建立虚拟节点 &lt;code&gt;*at&lt;/code&gt;, &lt;code&gt;c*t&lt;/code&gt; 和 &lt;code&gt;ca*&lt;/code&gt;，将 &lt;code&gt;cat&lt;/code&gt; 连向这三个虚拟节点。这里的 &lt;code&gt;*&lt;/code&gt; 可以理解为“百搭”。这样只有一个字母不一样的两个单词就可以通过共同的虚拟节点被连接起来。最后求出的最短距离只要除以2就是我们需要的答案。算法复杂度 $O(n\cdot l)$。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>问题求解III-HW01 题解</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/3-1/</link>
      <pubDate>Sat, 09 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/3-1/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Problem A: 控制流图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一段伪代码，求出其控制流图中每个节点的入度和出度。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;伪代码中我们只需关注 &lt;code&gt;GOTO&lt;/code&gt;, &lt;code&gt;IF-GOTO&lt;/code&gt;，和所有的 label 语句即可。对于 &lt;code&gt;GOTO&lt;/code&gt; 和 &lt;code&gt;IF-GOTO&lt;/code&gt; 语句，当前基本块会有一条连向 GOTO 目标的边；此外，除非当前基本块的最后一条语句是无条件跳转，每个基本块都会向它的下一个基本块连边。&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Problem B: 躺平&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在一群人中给定一些两两排名先后的比较关系，问能否求出全场 rank 1。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;将每个人抽象为图的一个顶点，A 的排名比 B 高则连一条从 A 到 B 的有向边。这样原问题转化为判断是否存在唯一的入度为 0 的节点，非常简单。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>问题求解II-Final 题解</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-final/</link>
      <pubDate>Sat, 24 Jun 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-final/</guid>
      <description>&lt;div align=&#34;center&#34;&gt;
&lt;p&gt;&lt;embed src=&#34;https://kristoff-starling.github.io/files/II-Final-AB.pdf&#34; width=&#34;820&#34; height=&#34;1000&#34; 
type=&#34;application/pdf&#34;&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Problem C: 实况足球&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有一个 $n$ 个点 $m$ 条边的带权无向图。$q$ 次询问，第 $i$ 次询问从点 $x_i$ 出发，每步交替移动到最远邻居和最近邻居，共移动 $k_i$ 步，求移动总距离。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于 $40\%$ 的分数：$k\leq 100$。&lt;/li&gt;
&lt;li&gt;对于另外 $40\%$ 的分数：$n\leq 100$。&lt;/li&gt;
&lt;li&gt;对于 $100\%$ 的分数：$n, k, q\leq 10^5$。&lt;/li&gt;
&lt;/ul&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;$40\%$ 分数的解法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于 $k\leq 100$，所以我们可以模拟完整的移动流程，只需为图上的每个点预处理最远的邻居和最近的邻居，然后模拟即可。假设 $n, m, q$ 同阶 (后续的复杂度分析类似)，总时间复杂度 $O(nk)$。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;$80\%$ 分数的解法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;令 &lt;code&gt;(球员编号,0/1)&lt;/code&gt; 这个状态表示当前球在谁的脚下且下一步是短传还是长传，以所有这样的状态为点建一个新图。如果编号为 $i$ 的球员在短传时目标球员是 $j$，则在 &lt;code&gt;(i, 0)&lt;/code&gt; 和 &lt;code&gt;(j, 1)&lt;/code&gt; 之间连一条有向边，长传的情况类似。容易发现这样一张图完整地刻画了传球的情况，且它只有 $2n$ 个点，每个点有且仅有一条出边。一个形如 $(x_i, k_i)$ 的询问只需要在这张新图上从点 &lt;code&gt;(xi, 1)&lt;/code&gt; 出发连走 $k_i$ 步计算距离之和。&lt;/p&gt;
&lt;p&gt;额外 $40\%$ 的分数满足 $n\leq 100$，这意味着新图节点也很少。所以虽然 $k$ 可能很大，但根据鸽巢原理，走超过 $2n$ 步之后我们一定会进入一个之前走过的状态，也就是说我们会在一个环中兜圈，如下图所示 (虚线箭头代表省略了中间的部分节点)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
S1(1) --&amp;gt; S2(2) -.-&amp;gt; Si(i) --&amp;gt; S4(i+1) -.-&amp;gt; Sm(m) --&amp;gt; Si
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因此我们只要尝试性地走若干步识别出这个环，然后用数学方法计算出在这个环上绕多少圈，最后再手动模拟剩余的不足一圈的步数即可。时间复杂度为 $O(n^2)$。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;$100\%$ 分数的解法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在“倍增”章节中我们曾说：倍增适用于“有固定的下一个状态”的场合，在树上求 LCA 时，这点体现为每个点有唯一的父亲。这里由于新图中每个点有且仅有一条出边，所以也适合用倍增处理移动问题。&lt;/p&gt;
&lt;p&gt;令 $to(i, j)$ 表示新图上从点 $i$ 出发，走 $2^j$ 步后到达的节点编号，$sum(i, j)$ 表示新图上从点 $i$ 出发，走 $2^j$ 步经过的路程之和，这两个都是可以高效计算的：&lt;/p&gt;
&lt;p&gt;$$
to(i, j) = \begin{cases}
next(i)&amp;amp;, j = 0\\
to(to(i, j-1), j-1)&amp;amp;, j &amp;gt; 0
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;$$
sum(i, j) = \begin{cases}
w(i, next(i))&amp;amp;, j = 0\\
sum(i, j - 1) + sum(to(i, j-1), j-1)&amp;amp;, j &amp;gt; 0
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;对于任意的 $k$，只要将其分解成若干个2的次幂相加的形式，然后累加对应的 sum 即可。时间复杂度为 $O(n\log k)$。&lt;/p&gt;
&lt;hr&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Problem D: 排序代价&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于一个数列 $s$，每次可以选定一个区间 $[l, r]$ 并花费 $r-l+1$ 的代价将区间中的数排序，将 $s$ 完全排序的最小代价记为 $cost(s)$。现给定数列 $S$，求
$$
\sum_{s是S的子串}cost(s)
$$&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;首先可以发现一个性质：对于任何一个子串 $s$，最优的排序方案应该满足选择的区间两两不相交。这是因为如果两个区间相交，我们总可以将其换成这两个区间的并集，这个区间的代价比两个区间的代价和更小且效果与两个区间相同。又因为给 $[l, r]$ 排序的代价正好等于其长度 $r-l+1$，所以在子串中，我们每能找到一个数不被覆盖，我们就能为最终的代价节省 $1$。&lt;/p&gt;
&lt;p&gt;综合以上分析，我们可以得出结论：要最小化子串的代价之和，我们只要&lt;strong&gt;对于每个元素 $s_i$，计算它在多少个子串的排序过程中可以不被区间覆盖，记为 $f(i)$&lt;/strong&gt;，最后用所有子串的总长减去计数的结果即可。&lt;/p&gt;
&lt;p&gt;接下来我们考虑一个元素在区间排序的过程中不被覆盖的充分必要条件是什么。考场上有大量的同学询问 &lt;code&gt;4 3 1&lt;/code&gt; 的排序代价为何是 3 而不是 2，这是因为虽然 3 在正确的位置，但 1 和 4 “站错边”了，想要将 1 和 4 排到正确的位置不可能通过选择不包括 3 的区间实现。结合这个样例，我们可以发现：数列 $s_1, \cdots, s_n$ 中 $s_k$ 可以在排序中不被覆盖的充要条件是
$$
\forall i\in [1, n], (i - k)(s_i - s_k) \geq 0
$$
用人话来说，就是在 $s_k$ 左边的数都小于等于它，在 $s_k$ 右边的数都大于等于它。这样我们就可以对 $[1, k-1]$ 和 $[k+1, n]$ 局部地排序。&lt;/p&gt;
&lt;p&gt;结合这个充要条件，我们可以得到计算 $f(i)$ 的方法：令 $l_i$ 为 $s_i$ 左侧第一个大于 $s_i$ 的数的位置 (若不存在这样的数则为 0)，$r_i$ 为 $s_i$ 右侧第一个小于 $s_i$ 的数的位置 (若不存在则为 $n+1$)，那么任意满足 $l_i&amp;lt; l\leq i, i\leq r&amp;lt; r_i$ 的区间 $[l, r]$ 都是可以使 $s_i$ 不被覆盖的区间，从而 $f(i)=(i - l_i)(r_i - i)$。&lt;/p&gt;
&lt;p&gt;最后的问题是如何计算 $l_i$ 和 $r_i$。以计算 $l_i$ 为例，计算的方法很多，一种可行的做法是将所有数按照从大到小的顺序加入 C++ set，每次使用 &lt;code&gt;lower_bound()&lt;/code&gt; 方法寻找左侧最靠右的元素位置，类似于 II-HW-3A 的做法。该算法总复杂度为 $O(n\log n)$，虽然分析了很多，但实现起来其实非常简短。&lt;/p&gt;
&lt;div class=&#34;alert alert-tip&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;本题其实相当有难度，这是因为人很难克服惯性思维：题目中要对各个子串的最小代价求和，所以我们很自然地想对每个子串单独求代价，最后相加。将视角转化为对每个元素计算可以不在多少个区间中被覆盖，打破了原题中对总代价的划分方式，这步转化需要相当的功力。&lt;/p&gt;
&lt;p&gt;这道题目的原型是 &lt;a href=&#34;https://codeforces.com/contest/1827/problem/B1&#34;&gt;Codeforces-1827B&lt;/a&gt;，区别在于原题中排序一个区间的代价不是 $r-l+1$，而是 $r-l$。这一点小小的差异对题目难度的影响其实是巨大的——因为排序一个区间的代价不等于区间的长度，所以“省下”一个元素不被覆盖的收益难以定义，从而原题更加复杂。感兴趣的同学可以去挑战一下。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>【问题求解II-HW6.C】关押罪犯</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-6-c/</link>
      <pubDate>Wed, 07 Jun 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-6-c/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;题意概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一张 $n$ 个点 $m$ 条边的图 $G=(V, E)$，要求将图上的顶点二染色，使得&lt;/p&gt;
&lt;p&gt;$$
\max_{(u, v)\in E, color(u)=color(v)} w(u, v)
$$&lt;/p&gt;
&lt;p&gt;最小。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;基于并查集的思路&#34;&gt;基于并查集的思路&lt;/h3&gt;
&lt;p&gt;这是一道经典的并查集练习题，我们出题的本意是希望大家使用并查集解决。考虑如下最自然的思路：按边权从大到小排序，然后按顺序将边一条一条插入到图中，直到图无法被二染色。你可能会思考为何不能在加边的时候顺便给节点染上色，每次判断新边连接的两个节点是否同色。该做法在连接不同的连通块时会出现问题，例如&lt;/p&gt;
&lt;img src=&#34;https://kristoff-starling.github.io/img/problemsolving/ps-sol-2063.png&#34; style=&#34;zoom: 50%;&#34; /&gt;
&lt;p&gt;新加入的红色边其实并没有导致问题，我们只要将下面连通块的染色方案换一下就行。但我们每次加边创建出新连通块时无法确定怎么给它染色，因此这条路行不通。我们应该转而去维护点之间的同类关系而不是强行染色，而维护同类关系正是并查集所擅长的。&lt;/p&gt;
&lt;p&gt;本题的难点在于：每条边描述的都是“两个点不能属于同一阵营”，如何将其转化为对同类关系的描述？这里有一个非常精妙的技巧。我们创建 $2n$ 个节点，1~n 是原本的节点，n+1~2n 这些节点，$n+i$ 是 $i$ 的“假想敌”。这样如果 $i$ 和 $j$ 之间有边，我们要做的就是在并查集中将 $i$ 和 $n+j$ 合并，$j$ 和 $n+i$ 合并。容易发现“假想敌”的设计非常好地实现了“敌人的敌人是朋友”：如果 $i$ 和 $j$，$k$ 和 $j$ 有边，那么 $i$ 和 $k$ 都会与 $n+j$ 在并查集中合并，从而 $i$ 和 $k$ 属于同一阵营。在每条边 $(i, j)$ 加入之前，我们只需在并查集中查询 $i$ 和 $j$ 的关系，然后按照上面的方法更新关系即可。假设 $n$ 和 $m$ 同阶，理论时间复杂度为 $O(n\alpha(n))$。&lt;/p&gt;
&lt;h3 id=&#34;基于二分答案的思路&#34;&gt;基于二分答案的思路&lt;/h3&gt;
&lt;p&gt;如果你仔细阅读了二分答案章节的讲义，你会发现该问题满足二分答案问题的所有“套路”，尤其是最关键的一点：这是一个最小化最大值的问题。因此我们只需二分答案 $mid$，然后关注由原图中边权大于 $mid$ 的边构成的子图。我们要保证这些边不会落到同一个颜色中，所以要判断该图是否可以二染色。你可以参考 I-Final-C，用一遍搜索完成可二染色判断。假设 $n$ 和 $m$ 同阶，则时间复杂度为 $O(n\log n)$。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【问题求解II-HW6.B】Cache调度</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-6-b/</link>
      <pubDate>Tue, 06 Jun 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-6-b/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;题意概述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有两块 Cache 和 $n$ 个程序，每个程序有一个类别 (共有 $k$ 种类别)，在同一块 Cache 上连续执行相同种类的程序第二次只需 $hot_i$ 的时间，否则需要 $cold_i$ 的时间。问串行执行所有程序所需的最小时间。&lt;/li&gt;
&lt;li&gt;$n, k\leq 5000$。&lt;/li&gt;
&lt;/ul&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;本题摘自 
&lt;a href=&#34;https://codeforces.com/problemset/problem/1799/D1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Codeforces 1799D1&lt;/a&gt;。你可以点击网站右侧的 Tutorial 查看官方题解 (官方题解从最朴素的时间复杂度为 $O(nk^2)$ 的动态规划讲起，逐步优化，清晰易懂，非常建议同学们仔细阅读)。这里我们给出一个另外的解法，比官方解法更加简洁高效。&lt;/p&gt;
&lt;p&gt;我们首先可以发现一个贪心性质。对于某一个类型为 $t$ 的程序来说，如果它只需要花 $hot_t$ 的时间执行，那么情况一定是：在这个程序之前&lt;strong&gt;最近&lt;/strong&gt;的一个类型为 $t$ 的程序在某块 Cache 上 (不妨记为 Cache 0) 执行之后，它们中间的程序都在 Cache 1 上执行，然后当前程序在 Cache 0 上执行。为什么当前程序不可能“继承&amp;quot;更早的 $t$ 类型程序使用的 Cache 呢？假设这种情况发生了，如下图：&lt;/p&gt;
&lt;img src=&#34;https://kristoff-starling.github.io/img/problemsolving/ps-sol-2062.png&#34; style=&#34;zoom: 50%;&#34; /&gt;
&lt;p&gt;在这个例子中，当前的1类型程序“继承”了更早的同类型程序，它们中间还夹着一个1类型程序。那么我们没有道理不把中间的这个1类型程序拉到下面的 Cache 上执行——一方面，这个1类型程序的左右都不是1类型，将它挪下来甚至可能让上面这块 Cache 多命中一次 (虽然图示例子不符合这个情况，1 的左右程序类型不一样)，另一方面，把这个程序拉下来可以让它享受 $hot_1$ 的执行时间。因此这是一笔稳赚不赔的买卖。&lt;/p&gt;
&lt;p&gt;我们在这个性质的基础上进行动态规划。为了方便叙述，我们首先约定一些记号：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;令 $last_i$ 表示在第 $i$ 个程序之前最近的一个和 $i$ 同类型的程序的位置。该数组不难获取，具体细节留给大家思考。&lt;/li&gt;
&lt;li&gt;令 $sum_{l, r}$ 表示将 $[l+1, r]$ 这个区间里的程序按顺序在同一块 Cache 上执行所需的总时间，注意我们不计算第 $l$ 个程序的执行时间，将第 $l$ 个程序纳入讨论是为了确定第 $l+1$ 个程序能否享受到 Cache hit 的加速。该记号可以通过前缀和实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;令 $dp(i, 0/1)$ 表示当前看到第 $i$ 个程序，第 $i$ 个程序使用的 Cache 和第 $i-1$ 个程序一样 (用第二维的 1 表示)/不一样 (0) 的情况下，最小的执行时间。令第 $i$ 个程序的类型为 $t$，分以下两种情况讨论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第 $i$ 个程序没有享受到 Cache hit，花了 $cold_t$ 的时间执行：这种情况下我们完全不用在意前面是哪两个程序留在了 Cache 里，因为我们没打算 Cache hit。因此
$$
dp(i, 0) = dp(i, 1) = \min\{dp(i-1, 0), dp(i-1, 1)\} + cold_t
$$&lt;/li&gt;
&lt;li&gt;第 $i$ 个程序享受到了 Cache hit，花了 $hot_t$ 的时间执行：根据我们之前发现的结论，它一定是继承了和它最近的相同类型程序的 Cache，然后中间的其他程序在另一块 Cache 上执行，这里又分两种情况：
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;上一个同类型的程序是第 $i-1$ 个，则此时满足“和前一个程序使用了同一块 Cache”，因此更新 $dp(i, 1)$：
$$
dp(i, 1) = \min\{dp(i - 1, 0), dp(i - 1, 1)\} + hot_t
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上一个同类型的程序不是第 $i-1$ 个，则此时更新 $dp(i, 0)$:
$$
dp(i, 0) = dp(last_i + 1, 0) + sum_{last_i+1, i - 1} + hot_t
$$&lt;/p&gt;
&lt;p&gt;注意一个细节：$dp(last_i+1, 0)$ 只能从 0 状态转移来，因为我们要强制 $[last_i + 1, i - 1]$ 的程序换到另一块 Cache 上。在这种情况中，你也可以体会到为什么状态设计中有这么一个看似奇怪的“和前一个程序是否使用同一块 Cache”。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对上述所有情况取 min 即可。你可能会有疑问：第一种情况计算的是不是不太精细，随便放也是有可能命中的？但命中情形下的最优解一定会被第二类情况覆盖到，所以第一种计算的粗糙一些问题不大。第一种情况存在的意义是保证 Cache miss 下达到最小时间的情况被覆盖到 (有点玄妙，请仔细体会)。&lt;/p&gt;
&lt;p&gt;最终答案为 $\min\{dp(n, 0), dp(n, 1)\}$，时间复杂度和空间复杂度均为 $O(n+k)$。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【问题求解II-HW5.A】高楼抛鸡蛋</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-5-a/</link>
      <pubDate>Sun, 28 May 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-5-a/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;题意概述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有一个 $n$ 层的高楼。存在一个未知的分界楼层 $X$，在 $1&amp;hellip;X$ 层扔鸡蛋落地不会碎；在 $X+1$ 层以及更高的楼层扔鸡蛋落地会碎。问用 $k$ 个鸡蛋最少扔几次可以确定 $X$。&lt;/li&gt;
&lt;li&gt;$n\leq 10^4, k\leq 100$。&lt;/li&gt;
&lt;/ul&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;引子&#34;&gt;引子&lt;/h3&gt;
&lt;p&gt;这是一个十分有趣的问题。我们首先思考扔鸡蛋到底意味着什么：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个鸡蛋如果在 $x$ 层扔下去没碎，说明 $X\geq x$，否则 $X&amp;lt;x$。&lt;/li&gt;
&lt;li&gt;鸡蛋碎与不碎是有区别的：如果所有鸡蛋都碎了但我们仍没有找出 $X$，那就寄了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于这些观察，我们先进行一些简单情况的思考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果我们手里只有一个鸡蛋，那么我们没有犯错空间，只能从一楼开始一层一层往上扔，次数为 $O(n)$。&lt;/li&gt;
&lt;li&gt;如果我们手里有两个鸡蛋，那我们的策略应该是这样的：用第一个鸡蛋把一个大致的范围框出来——例如选择在 $l_1=1, l_2, \cdots, l_m=n$ 这些点扔鸡蛋，把范围缩小到某个 $[l_i, l_{i+1})$ 后，再用第二个鸡蛋一层层试过去。这个策略很像之前提过的“分块”。如果我们选取那些 $\sqrt n$ 的倍数位置作为第一轮的节点，则抛鸡蛋次数为 $O(\sqrt n)$。&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;动态规划-i&#34;&gt;动态规划 (I)&lt;/h3&gt;
&lt;p&gt;我们可以看到“用前面的鸡蛋的牺牲为后面的鸡蛋缩小范围”是一个核心思路。对于更多数量的鸡蛋，硬想已经很难想得清楚。考虑使用动态规划。&lt;/p&gt;
&lt;p&gt;一个非常直接的动态规划状态设计是：令 $dp(k, n)$ 表示手里有 $k$ 个鸡蛋，要确定 $n$ 层大楼的答案，最少需要扔几次 (这个状态设计和原问题的描述是完全一致的)。转移考虑第一次应该在哪一层扔鸡蛋。如果第一次在第 $i$ 层扔鸡蛋，有两种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;鸡蛋碎了，则需要用 $k-1$ 个鸡蛋在 $1\cdots i-1$ 层确定答案。&lt;/li&gt;
&lt;li&gt;鸡蛋没碎，则需要用 $k$ 个鸡蛋在 $i\cdot n$ 层确定答案。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两种情况会落入哪一种是我们无法预知的，但为了保证找出答案，求次数时应该对其取 max。不过第一次在哪里扔是我们可以决定的，所以我们可以遍历所有可能的第一层，对所有情况取 min (请仔细体会取min/max的逻辑)。因此状态转移方程为&lt;/p&gt;
&lt;p&gt;$$
dp(k, n) = \min_{1\leq i\leq n}\left(\max\{dp(k-1,i-1)+1, dp(k, n-i+1)+1\}\right)
$$&lt;/p&gt;
&lt;p&gt;该算法的空间复杂度为 $O(kn)$，时间复杂度为 $O(kn^2)$。对于本题来说仍需要优化。&lt;/p&gt;
&lt;h4 id=&#34;基于状态转移方程单调性的优化&#34;&gt;&lt;strong&gt;基于状态转移方程单调性的优化&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;我们将 $dp(k, n)$ 看作关于 $k$ 和 $n$ 的二元函数，来观察它的单调性。容易发现它关于 $n$ 是单调增的 (大楼高度增加扔的次数肯定更多)。再次观察上述的状态转移方程，可以发现随着 $i$ 的增大，第一项 $dp(k-1, i-1)$ 一直在变大，第二项 $dp(k, n-i+1)$ 一直在变小。如果画成图的话大概是这样：&lt;/p&gt;
&lt;img src=&#34;https://kristoff-starling.github.io/img/problemsolving/ps-sol-2051.png&#34; style=&#34;zoom: 50%&#34;/&gt;
&lt;p&gt;可以看到，状态转移方程中的函数 (绿色) 是&lt;strong&gt;单峰&lt;/strong&gt;的 (即形如二次函数)。它在红色和蓝色线相等的地方取到最小值。因此对于每个 $dp(k, n)$，我们可以通过二分查找而不是一一枚举的方式寻找取到最小值的点 (红色减蓝色的结果是单调的)，时间复杂度优化至 $O(kn\log n)$。(注意：图上的红色和蓝色线是连续的，而实际问题中 dp 数组是离散的，因此你实际需要找的是“红色和蓝色差值最小的地方”。)&lt;/p&gt;
&lt;h4 id=&#34;基于决策单调性的优化&#34;&gt;&lt;strong&gt;基于决策单调性的优化&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;在这个思路的基础上还可以进一步优化。我们令 $M_{k, n}$ 表示使得 $dp(k, n)$ 取到最小值的状态转移方程中的那个 $i$。朴素方法通过枚举确定 $M_{k, n}$，第一版优化通过二分查找确定 $M_{k, n}$，这里我们利用&lt;strong&gt;决策单调性&lt;/strong&gt;均摊 $O(1)$ 地确定 $M_{k, n}$。&lt;/p&gt;
&lt;p&gt;如果把 $M_{k, n}$ 看作关于 $k$ 和 $n$ 的函数，我们容易发现它关于 $n$ 是单调递增的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直觉上，大楼的总层数增高了，那么第一次扔鸡蛋的位置肯定应该相对应地调高，否则如果鸡蛋没碎，上面待探索的层数就会太多。&lt;/li&gt;
&lt;li&gt;严谨地计算上，对于 $dp(k, n)$ 问题，$M_{k, n}$ 满足 $dp(k-1, M_{k, n}) = dp(k, n-M_{k, n}+1)$。那么对于 $dp(k, n+1)$ 问题，
$$
dp(k-1, M_{k,n}) = dp(k, n-M_{k, n}+1) \overset{dp关于n的单调性}{\leq} dp(k, (n+1) - M_{k, n} + 1)
$$
因此必然有 $M_{k, n+1}\geq M_{k, n}$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$M_{k, n}$ 是每轮的最优点，也称为决策点。所以 $M_{k, n}$ 满足的单调性质称为决策单调性。基于决策单调性，对于每个 $k$，我们在计算 $M_{k, n}$ 时，不用从 1 开始枚举，而可以从 $M_{k, n-1}$ 开始枚举。因为 $dp(k, *)$ 一层中所有的 $M_{k, *}$ 的枚举合起来复杂度为 $O(n)$，所以算法的总时间复杂度降至 $O(kn)$。&lt;/p&gt;
&lt;h3 id=&#34;动态规划-ii&#34;&gt;动态规划 (II)&lt;/h3&gt;
&lt;p&gt;动态规划 (I) 的优点在于它选择从一个非常自然的状态设计出发解决问题，整个思维过程没有大的跃迁点。但缺点在于对优化能力的要求较高，如果水平不足很可能卡在 $O(kn^2)$ 的位置无法前进。这里我们介绍另一种动态规划的状态设计，它的状态和转移都有点“神之一手”的意味，但一旦想到整个问题就变得非常简单。&lt;/p&gt;
&lt;p&gt;令 $dp(k, m)$ 表示用 $k$ 个鸡蛋扔 $m$ 次，最多可以在多高的楼层范围内确定答案 (例如 $dp(1, m)=m$，因为一个鸡蛋只能从1楼开始一层层往上)。考虑如何转移：在这种状态设计下，我们可以精确地确定第一次该在哪里扔鸡蛋。因为鸡蛋如果碎了，我们就要用 $k-1$ 个鸡蛋在 $m-1$ 次内找出答案，而这个条件下能确定的最大层数恰好是 $dp(k-1, m-1)$。所以我们第一轮应该在第 $dp(k-1, m-1) + 1$ 层扔鸡蛋。另外，如果鸡蛋没碎，我们还可以用 $k$ 个鸡蛋扔 $m-1$ 次，从而最多可以再向上探索 $dp(k, m-1)$ 层，因此状态转移方程为&lt;/p&gt;
&lt;p&gt;$$
dp(k, m) = dp(k-1, m-1) + 1 + dp(k, m-1)
$$&lt;/p&gt;
&lt;p&gt;剩下的问题是，对于每个 $k$，$m$ 要枚举到多大？由于 $dp(k, m)$ 关于 $m$ 单调递增，所以我们只要枚举到 $dp(k, m)\geq n$ 的 $m$ 即可。一件显然的事情是 $m\leq n$，因此复杂度的一个上界是 $O(kn)$，这已经足够优秀了&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;h3 id=&#34;基于信息论的思路&#34;&gt;基于“信息论”的思路&lt;/h3&gt;
&lt;p&gt;这个解法的思路比较清奇，仅供大家欣赏。令 $f(k, m)$ 表示用 $k$ 个鸡蛋，扔 $m$ 次可以确定答案的最多楼层数，我们其实可以不借助任何基础推导，直接给出数学结果&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;p&gt;$$
f(k, m) = \sum_{i=1}^k\binom{m}{i}
$$&lt;/p&gt;
&lt;p&gt;它的道理来自以下的分析：&lt;/p&gt;
&lt;p&gt;用 $k$ 个鸡蛋扔 $m$ 次这个实验的本质，是建立一个从仅包含0和1的状态字符串到最终答案的映射。这里 01 串至多 $m$ 位，表示每次扔鸡蛋的结果，0 是碎了，1 是没有碎。因为我们只有 $k$ 个鸡蛋，所以 01 串里至多只能有 $k$ 个 0。注意两个细节：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果从头到尾鸡蛋都没有碎过，那么我们不可能知道答案 (因为没有上界)，所以全 1 的串无效。&lt;/li&gt;
&lt;li&gt;如果串中有 $k$ 个 0，那么最后一个必须是 0 (因为鸡蛋碎完了就没有鸡蛋可扔了)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此合法的状态共有&lt;/p&gt;
&lt;p&gt;$$
\sum_{i=1}^{k-1}\binom{m}{i} + \sum_{i=k}^m\binom{i-1}{k-1}
$$&lt;/p&gt;
&lt;p&gt;其中前面一个求和表示包含小于 $k$ 个 0 的合法字符串的个数，后面一个求和表示恰好 $k$ 个 0 的合法字符串的个数。后面一类由于固定了一个 0 在字符串末尾，所以只有 $k-1$ 个可支配的 0 (注：我们认为组合数 $n$ 选 $m$ 如果 $n&amp;lt;m$ 则值为 0，这与广义组合数的定义相容)。通过简单的数学推导你可以发现 $\displaystyle \sum_{i=k}^m\binom{i-1}{k-1}=\binom{m}{k}$ (将第一项 $\displaystyle\binom{k-1}{k-1}$ 改写为 $\displaystyle \binom{k}{k}$，然后采用“滚雪球法”)，或者你也可以通过思维推导发现如果在这种字符串的末尾添加占位符将其长度补到 $m$，本质上就是 $\displaystyle \binom{m}{k}$。总之，合法的状态总数为&lt;/p&gt;
&lt;p&gt;$$
\sum_{i=1}^k\binom{m}{i}
$$&lt;/p&gt;
&lt;p&gt;鸡蛋落地的结果序列必须可以和楼层建立一一映射，否则一定存在无法分辨的两个楼层 (可以参考使用决策树证明基于比较的排序算法的复杂度下界的过程来理解这句话)，所以答案的上界是 $\sum_{i=1}^k\binom{m}{i}$。又因为每次鸡蛋碎与不碎会将我们引导到两个不相交的区域 ($[1, x-1]$ 和 $[x, n]$) 进行下一步操作，所以这个上界是可以做到的。因此 $f(k, m)=\sum_{i=1}^k\binom{m}{i}$。进一步地，你可以发现我们在此处定义 0 为碎的巧妙之处：将所有状态串按照字典序从小到大排序，排在第 $i$ 位的字符串恰好就是确定第 $i$ 层的扔法。&lt;/p&gt;
&lt;p&gt;有了这个结果，我们可以直接二分 $m$，然后计算 $f(k, m)$ 并与 $n$ 比较。时间复杂度 $O(k\log n)$。&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;LeetCode的 
&lt;a href=&#34;https://leetcode.cn/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode-solution-2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方题解&lt;/a&gt; 不加证明地给出了 $O(k\sqrt[k]{n})$ 的复杂度。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;事实上，第二种解法里的动态规划状态转移方程本身长的就很像二项式系数的递推式。如果你对这个转移方程进行差分等数学处理，也可以得到如下的结果。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>【问题求解II-HW5.B】最长公共子序列</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-5-b/</link>
      <pubDate>Fri, 26 May 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-5-b/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;题意概述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定两个字符串 $s, t$，求两者的最长公共子序列的长度。&lt;/li&gt;
&lt;li&gt;$1\leq |s|\leq 10^6, 1\leq |t|\leq 10^3$。&lt;/li&gt;
&lt;/ul&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;求字符串的最长公共子序列长度是一个经典的动态规划入门问题。该问题有如下非常经典的状态设计和转移“套路”：&lt;/p&gt;
&lt;p&gt;令 $dp(i, j)$ 表示 $s[1&amp;hellip;i]$ 和 $t[1..j]$ 这两个串的最长公共子序列长度，那么最终答案显然为 $dp(|s|, |t|)$。转移考虑 $s[i]$ 和 $t[j]$ 是否在最长公共子序列中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若 $s[i]$ 不在最长公共子序列中，则可以从 $dp(i-1, j)$ 转移来。&lt;/li&gt;
&lt;li&gt;若 $t[j]$ 不在最长公共子序列中，则可以从 $dp(i, j-1)$ 转移来。&lt;/li&gt;
&lt;li&gt;若 $s[i]$ 和 $t[j]$ 都在公共子序列中 (注意它们是最后一个字符，所以它们一定要能匹配上 (相同))，则可以从 $dp(i-1, j-1)+1$ 转移来。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对以上三种情况取最大值即可。该动态规划的时间复杂度和空间复杂度均为 $O(|s||t|)$。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本题的特别之处在于 $s$ 很长而 $t$ 很短，且 $|s||t|$ 超出了我们能够承受的范围 (无论是时间还是空间)，因此前面提到的传统做法不太奏效。本题希望让大家明白的是：&lt;strong&gt;对于求极值的动态规划问题，状态和值之间通常可以互相转化&lt;/strong&gt;。一个动态规划问题通常有若干个变量 (记为 $m$ 个)，动态规划状态会固定住其中的 $m-1$ 个变量，动态规划的值则是剩下的那个变量的极值。对于大部分人来说，最自然的选择是将题目要求的那个变量作为动态规划的值，但有时为了缩减状态数，我们会选择“看起来别扭”的设计，将&lt;strong&gt;取值空间小的那些变量作为动态规划的状态&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;以本题为例，本题的变量有三个：$s$ 的前缀长度，$t$ 的前缀长度，最长公共子序列的长度。因为本题求的是第三个，所以前面提到的传统状态设计最容易让人理解。但在本题的数据范围下，你会发现 $s$ 的前缀长度有 $10^6$ 种可能，而后两者的取值空间都是 $10^3$，因此我们来设计如下一种“看起来很奇怪的状态”：&lt;/p&gt;
&lt;p&gt;令 $dp(i, j)$ 表示考虑 $t[1&amp;hellip;i]$，如果想要获得长度为 $j$ 的最长公共子序列，$s$ 的前缀至少要取到哪里 (如果做不到则值为 $|s|+1$)。虽然听起来很拗口，但转移仍然可行。考虑以下情形：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最长公共子序列不包含 $t[i]$，则可以从 $dp(i-1, j)$ 直接转移来。&lt;/li&gt;
&lt;li&gt;最长公共子序列包含 $t[i]$，从 $dp(i-1, j-1)$ 转移来。记 $x=dp(i-1, j-1)$，现在的状况是：$s[1&amp;hellip;x]$ 和 $t[1&amp;hellip;i-1]$ 有一个长度为 $j-1$ 的公共子串。我们要从 $x+1$ 往后继续延伸，找到第一个和 $t[i]$ 相同的字符匹配上从而达到要求。因此我们可以预处理一个数组 $nxt(i, ch)$ 表示从 $s[i]$ 开始第一个字符 $ch$ 出现在哪里 (这并不困难，留给大家作为思考)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们把取值空间小的两个状态作为动态规划的状态，把最大的那个作为值。值是不需要在执行过程中枚举的，因此我们有效优化了复杂度。该做法的时间复杂度和空间复杂度均为 $O(|t|^2)$。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【问题求解II-HW5.C】背包问题</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-5-c/</link>
      <pubDate>Fri, 26 May 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-5-c/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;题意概述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有一个容积为 $v$ 的背包和 $n$ 个物品，第 $i$ 个物品的体积是 $v_i$，价值是 $w_i$。求用背包最多能装下多少价值的物品。&lt;/li&gt;
&lt;li&gt;$n\leq 500, v\leq 10^9, \sum w_i\leq 10^6$。&lt;/li&gt;
&lt;/ul&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;本题虽然是经典的 01 背包问题 (它被称为 01 背包是因为每个物品要么选要么不选，只有两种状态)，但仍然有一些值得注意的细节。和 2-5-B 类似地，本题也需要仔细斟酌状态的选取。01 背包的一种常见状态设计是：令 $dp(i, j)$ 表示考虑到第 $i$ 个物品，使用容积为 $j$ 的背包，最多可以获得多少价值。转移考虑第 $i$ 个物品是否放进背包。方程是容易写出的：&lt;/p&gt;
&lt;p&gt;$$
dp(i, j) = \max\{dp(i-1, j), dp(i-1, j-v_i) + w_i\}
$$&lt;/p&gt;
&lt;p&gt;时间总复杂度为 $O(nv)$。但本题中 $v$ 的取值范围很大，这样做无法通过。&lt;/p&gt;
&lt;p&gt;考虑将值域更小的价值作为状态，将值域大的容积作为动态规划的值，重新设计：令 $dp(i, j)$ 表示考虑到第 $i$ 个物品，想要选取出总价值为 $j$ 的物品，至少需要多少容积。最终所有容积不超过 $v$ 的状态的 $j$ 的最大值即为题目所求。转移仍然考虑第 $i$ 个物品是否选择：&lt;/p&gt;
&lt;p&gt;$$
dp(i, j) = \min\{dp(i-1, j), dp(i-1, j-w_i) + v_i\}
$$&lt;/p&gt;
&lt;p&gt;看上去和之前的方程式长得差不多，但现在时间复杂度变为了 $O(n\cdot \sum w_i)$。而且在做第 $i$ 轮时，第二维实际只需要枚举到 $\sum_{k=1}^iw_k$，因此实际实现时会有一个十分可观的小于 1 的常数因子，足够通过。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;另外一个需要考虑的问题是: $O(n\cdot \sum w_i)$ 的空间复杂度似乎过高，使用了太多的内存。这里我们为大家介绍“滚动数组”的技术：观察状态转移方程，我们容易发现 $dp(i, *)$ 只使用了 $dp(i-1, *)$ 来更新自己的结果，因此在做 $dp(i+, *)$ 时仍然存留这 $dp(i-2, *)$ 以及更之前的数据就是对空间的浪费。因此我们的 dp 数组可以只开两行：$dp(previous, *)$ 和 $dp(current, *)$。current 层依赖 previous 层获取结果，然后 previous 和 current 互换，依次类推。采用滚动数组的代码通常会写成如下形式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int dp[2][MAXN];

int previous = 0, current = 1;
for (int i = 1; i &amp;lt;= n; i++)
{
    // DP logic: dp[current][...] = compute(dp[previous][...])
    swap(previous, current);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;滚动数组是压缩空间的通用技术，不过就本题而言，我们还可以做得更激进一些，只需要开一维数组即可，这样代码书写起来也更加方便。你可以参考 2-3-C 关于空间优化的部分进行思考。&lt;/p&gt;
&lt;div class=&#34;alert alert-tip&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;背包问题是 NP-Complete 问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不少同学疑惑的问题是：背包问题存在如此简明的动态规划算法可以高效解决，为什么它通常被归入“难问题”的行列呢？这是因为我们给出的动态规划算法有效的前提是物品的总体积/总价值不太大。换句话说，我们目前暂时无法给出一个只和物品数量 $n$ 相关的时间复杂度。这样的不仅依赖输入的数量，还依赖输入值的大小的“多项式”算法称为&lt;strong&gt;伪多项式算法 (pseudo-polynomial algorithm)&lt;/strong&gt;。大家会在问题求解IV中学习这方面的内容。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>【问题求解II-HW4.C】烧烤</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-4-c/</link>
      <pubDate>Mon, 08 May 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-4-c/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;题面描述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有 $n$ 个包，第 $i$ 个包里有 $A_i$ 个黑球和 $B_i$ 个白球。问有多少种方法选取两个包，再将包中的球排成一排。同色的球之间不可区分，选择不同的包被视为不同方案。&lt;/li&gt;
&lt;li&gt;$n\leq 2\times 10^5, A_i, B_i\leq 2000$。&lt;/li&gt;
&lt;/ul&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;该题面描述与原题背景不太相同，但容易看出它们讨论的问题是一样的。本题解法比较精巧，供大家欣赏。&lt;/p&gt;
&lt;p&gt;如果我们枚举选择哪两个包，那么选取第 $i$ 个包和第 $j$ 个包的情况下，问题会被转化为将 $A_i+A_j$ 个黑球和 $B_i+B_j$ 个白球排成一排有多少种方案，这等价于在 $A_i+A_j+B_i+B_j$ 个位置中选择 $A_i + A_j$ 个位置放黑球。因此最终答案可以写为
$$
\sum_{i,j\in \{1,\cdots, n\}, i&amp;lt;j} \binom{A_i+A_j+B_i+B_j}{A_i+A_j}
$$
即使我们可以通过预处理 $O(1)$ 地求解组合数，直接计算该表达式的时间复杂度也会达到 $O(n^2)$。本题 $n\leq 2\times 10^5$，无法通过。&lt;/p&gt;
&lt;p&gt;本题的关键在于一步精妙的模型转化。通常我们认为能够写出 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Closed-form_expression&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;closed form&lt;/a&gt; 的数学表达式是优美的，但这里我们反其道而行之，将上面表达式中的组合数转化为一个具体的动态规划问题。考虑如下问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在一张 $n\times m$ 的方格纸上，从 $(0, 0)$ 走到 $(n, m)$ 有多少种方案？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很容易看出该问题的答案是 $\binom{n+m}{n}$，即从 $(0, 0)$ 到 $(n, m)$ 一共要走 $n$ 条横向边和 $m$ 条竖向边，从 $n+m$ 步中选 $n$ 步走横的。不过我们还有一个“笨方法”：令 $dp(i, j)$ 表示从 $(0, 0)$ 走到 $(i, j)$ 的方案数，显然 $(i, j)$ 可以从 $(i-1, j)$ 或 $(i, j-1)$ 转移来，因此
$$
dp(i, j)=
\begin{cases}
1&amp;amp;, (i, j) = (0, 0)\\
dp(i-1, j) + dp(i, j-1)&amp;amp;, otherwise
\end{cases}
$$
注意上述状态转移方程没有考虑边界问题。
回到原问题，对于 $\binom{A_i+A_j+B_i+B_j}{A_i+A_j}$，我们可以套用走方格纸问题，将其转化为从 $(-A_i, -B_i)$ 到 $(A_j, B_j)$ 的方案数，并通过动态规划递推解决。我们看似用一个 $O(|A_i|^2)$ 的算法替代了 $O(1)$ 的组合数求解，但&lt;strong&gt;动态规划的递推过程是可以叠加的&lt;/strong&gt;。我们不需要单独对每组点对跑动态规划，我们可以给地图上所有的负坐标 $(-A_i, -B_i)$ 打上 1，然后从地图的左下角开始一遍推到右上角，然后在所有的正坐标位置收取答案。这样我们花一趟完成了 $n^2$ 次动态规划，时间复杂度降低到 $O(|A_i|^2)$。&lt;/p&gt;
&lt;p&gt;这个过程有一点抽象，如果你没有完全理解，可以简单构造一个 3 个点的样例手动模拟一下算法，看看一个负坐标上的标记是如何同时贡献到所有的正坐标上，以及不同的标记是如何叠加的。&lt;/p&gt;
&lt;p&gt;此外还有一些细节需要注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C/C++ 中无法直接支持负数下标，你可以考虑给所有的坐标加上一个偏移量 offset 转化成正数。&lt;/li&gt;
&lt;li&gt;上述递推过程会出现 $(-A_i, B_i)$ 向 $(A_i, B_i)$ 贡献的情况，相当于选取了两个一样的包，需要 $O(n)$ 地单独计算并扣除。&lt;/li&gt;
&lt;li&gt;对于任意一对 $(i, j)$，上述递推过程会同时计算 “$(-A_i, -B_i)$ 向 $(A_j, B_j)$ 贡献” 和 “$(-A_j, B_J)$ 向 $(A_i, B_i)$ 贡献”，即重复计算了两次。因此扣除第二点中的数量后还需要除以 2。&lt;/li&gt;
&lt;li&gt;在模意义下如何除以 2 不是一个简单的问题，你可以上网搜索“逆元”或 &amp;ldquo;modular multiplicative inverse&amp;rdquo;。现阶段你不需要过深地理解背后的数论原理，因为后续的理论课程会涉及。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>【问题求解II-HW3.A】签到题</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-3-a/</link>
      <pubDate>Sat, 29 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-3-a/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;题意概述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;给定数列 $a_1, \cdots, a_n$，求区间 $(l, r)$，使得&lt;/p&gt;
&lt;p&gt;$$
\left(\min_{i=l}^r a_i\right)\cdot \left(\max_{i=l}^r a_i\right)\cdot \left(\text{OR}_{i=l}^r a_i\right) \cdot (r - l + 1)
$$&lt;/p&gt;
&lt;p&gt;最大。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$n\leq 10^6$。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;遇到复杂的表达式不要慌，应当仔细观察它的性质。我们很容易发现该表达式的一个特点：除了 $\min$ 这个操作，其他的三项都是随着区间的扩大而增加的。换句话说，如果没有 $\min$ 这一项，这题的答案就是整个数列。&lt;/p&gt;
&lt;p&gt;接下来我们考虑如何对付这个棘手的 $\min$。$\min$ 的一大特点在于它是有限的——任何一个区间的 $\min$ 一定是原数列中的一个数，因此所有可能的 $\min$ 最多只有 $n$ 种。如果我们把所有的区间按照 $\min$ 的位置归类，那么根据之前的结论，享有同一个 $\min$ 的区间集合中，只有最长的那个才可能是答案的候选区间。&lt;/p&gt;
&lt;p&gt;到这里，我们的问题转化成了：枚举数列中的每个数 $a_i$ 作为最小值的情况，我们希望找到以此为最小值的最长区间，即从 $a_i$ 出发向左向右扩展，把所有 $\geq a_i$ 的数纳入到区间中，直到碰到边界/比 $a_i$ 小的数。但这件事仍然不容易，如果暴力地向左向右查看，复杂度仍然会达到 $O(n^2)$。&lt;/p&gt;
&lt;p&gt;考虑这样一种精巧的做法：我们不按照下标的顺序依次枚举 $a_i$，而是按照 $a_i$ 值从小到大的顺序枚举 $a_i$。这样在枚举到任意 $a_i$ 的时刻整个数列的格局如下：&lt;/p&gt;
&lt;img src=&#34;https://kristoff-starling.github.io/img/ps-sol-2031.png&#34; style=&#34;zoom: 50%;&#34; /&gt;
&lt;p&gt;其中蓝色的格子代表已经被枚举过的数，红色的是当前枚举的数。我们发现所有蓝色的数一定比当前数小(小于等于)，所有白色的数一定比当前的数大。因此要寻找“最长区间”，我们只要在“蓝色数”的下标数列中寻找比当前下标小的最大数和比当前下标大的最小数即可。你可以借助 C++ STL 的 set 容器以及 &lt;code&gt;lower_bound&lt;/code&gt; 方法来轻松完成这件事，时间复杂度降低到 $O(n\log n)$。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;遇到大小相同的数怎么办？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实不用担心这个问题。你可以按照任意顺序处理大小相同的数，因为先处理的数对应的区间可以包括后处理的数，所以后处理的数被先处理的数“卡住”区间边界也无关紧要了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;或者你也可以采取类似分治的做法，每次找完当前区间的最小值后将区间拆分成左右两个区间分别处理 (因为后续的区间不应该跨越这个最小值)。至于如何寻找一个区间最小值的位置，你可以在维护 ST 表时同时维护最小值位置，具体细节留给大家自己思考。&lt;/p&gt;
&lt;p&gt;剩下的最后一件事情是：对于每个最小值，我们找到了它对应的最长区间后，如何求该区间的最大值/同或和/长度。长度是容易的，剩下的两样恰好是 ST 表擅长的内容。你只需要预处理 ST 表即可 $O(1)$ 地查询。整个算法的时间复杂度为 $O(n\log n)$。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【问题求解II-HW3.B】砍树</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-3-b/</link>
      <pubDate>Sat, 29 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-3-b/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;题意描述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定一棵 $n$ 个节点的数和 $m$ 个点对，每个点对染不同的颜色。要求找出树中的一条边，使得砍掉这条边后得到的两棵树中没有颜色相同的节点 (即颜色相同的点对不能被划分到同一棵树中)。求满足条件的边的最大编号，若不存在输出 -1。&lt;/li&gt;
&lt;li&gt;$n\leq 10^5$。&lt;/li&gt;
&lt;/ul&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;树上任意两个点之间有且仅有一条简单路径。并且我们容易发现：如果要把两个点分到两棵树中，那么选择的这条边必须在连接这两个点的路径上。因此该问题被转化为了对树上的 $m$ 条路径求交。以下我们介绍三种做法供大家参考。&lt;/p&gt;
&lt;h4 id=&#34;做法1-基于lca的路径标记&#34;&gt;&lt;strong&gt;做法1: 基于LCA的路径标记&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;对于树上的任意两个点 $u$, $v$，从 $u$ 到 $v$ 的路径总可以被拆分为 $u\to lca(u, v)$ 和 $lca(u,v)\to v$ 两条直上直下的链。我们希望可以快速给链上所有的边打一个 +1 标记，这样最后只需要找有 $m$ 个标记的边即可。&lt;/p&gt;
&lt;p&gt;如果对每条路径上的所有边暴力打 +1 标记的话，总复杂度为 $O(\sum_{i=1}^m len(u_i\to v_i))$，最坏情况下可以达到 $O(mn)$，不可接受。&lt;/p&gt;
&lt;p&gt;以 $o(t)$ 的代价给 $t$ 条边打上标记似乎是一件“违反物理”的事情。但我们向大家展示如下的技巧做到这一点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们不把操作作用在边上，而是作用在点上，每个点与连向它父亲的边对应 (根节点没有对应的边)。&lt;/li&gt;
&lt;li&gt;对于路径 $(u, v)$：
&lt;ul&gt;
&lt;li&gt;$mark(u) + 1$。&lt;/li&gt;
&lt;li&gt;$mark(v) + 1$。&lt;/li&gt;
&lt;li&gt;$mark(lca(u, v)) - 2$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每个点最终的标记 $Mark(u) = \sum_{v\in subtree(u)} mark(v)$ (即以 $u$ 为根的子树中所有节点的 mark 之和)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个技巧有一个很炫酷的名字，叫“树上差分”。你可以对一条路径按照上述操作做一遍，然后验证一下处于各个位置的节点的 Mark，你会发现只有 $(u, v)$ 路径上的节点 (除了 LCA) Mark 为 1，其他的都是 0。这恰好符合我们在边上打标记的需求。此外，这个标记系统是可以累加的，即你不需要每次计算 Mark，而是可以把 $m$ 条边的 mark 做完之后再一起计算 Mark。这样我们在 $O(m+n)$ 的时间内完成了打标记的动作。加上预处理和计算 LCA 的复杂度，该算法的总时间复杂度为 $O((n+m)\log n)$。&lt;/p&gt;
&lt;h4 id=&#34;做法2-将树上路径求交转化为一维的区间求交&#34;&gt;&lt;strong&gt;做法2: 将树上路径求交转化为一维的区间求交&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;把第一个点对所在的路径 $(u_1, v_1)$ 抓出来，考虑剩下的 $m-1$ 条路径在 $(u_1, v_1)$ 上的相交部分。想象一下容易发现，如果把树中的一条链 $(u_1, v_1)$ 提出来，“用手拎着两端提在空中”，那么整个树的格局会像一个晾衣绳，晾衣绳上的每个点挂了一个树，如下图所示。&lt;/p&gt;
&lt;img src=&#34;https://kristoff-starling.github.io/img/ps-sol-2032-link.png&#34; style=&#34;zoom: 50%;&#34; /&gt;
&lt;p&gt;给 $(u_1, v_1)$ 这条链上的点重新标号 $x_1, x_2,\cdots, x_t$。对于其他任意一个点对 $(u_i, v_i)$，如果 $u_i, v_i$ 在同一个 $x_p$ 的树下 (如图中红色所示)，那么 $(u_i, v_i)$ 这条路径将完全在 $x_p$ 的子树内部，从而和 $(u_1, v_1)$ 没有边的交集；如果 $u_i, v_i$ 在不同的子树 $x_p, x_q (p&amp;lt;q)$ 下 (如图中蓝色所示)，那么 $(u_1, v_1)$ 和 $(u_i, v_i)$ 这两条链将会有 $(x_p, x_q)$ 这一段是公共的。&lt;/p&gt;
&lt;p&gt;对于 $(u_2, v_2), \cdots, (u_m, v_m)$ 中的每一对，我们都可以检查 $u_i, v_i$ 在哪棵子树中，从而算出它和 $(u_1, v_1)$ 的交集。这时问题已经被转化成了在一维序列 $x_1, \cdots, x_t$ 上的区间交集问题。剩下的一点点细节非常简单，留给大家思考。&lt;/p&gt;
&lt;p&gt;这个做法颇有“大道至简”的意味——没有“倍增求LCA”“树上差分“这样炫酷的技术，就是平平无奇的几遍搜索，就给出了更优秀的时间复杂度 $O(n)$。在这里我们也想给大家传递一个价值观：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;高级算法和高级数据结构就像武林中的重武器，而你分析问题、转化问题的能力则像内功。内功和武器是相辅相成的，内功不足却想耍大刀，适得其反。比起盲目地学习很多炫酷的技术，我们更希望大家能充分锻炼自己的思维能力，这才是成为一个优秀的算法设计师的正道。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;做法3-一个神奇的随机算法&#34;&gt;&lt;strong&gt;做法3: 一个神奇的随机算法&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;这个做法有些“过于”精巧，大家只需欣赏即可。&lt;/p&gt;
&lt;p&gt;为每个数对 $(u_i, v_i)$ 随机一个数 $c_i$，并将 $c_i$ 打在 $u_i, v_i$ 两个节点上。对于每条边，砍掉它合法的充分必要条件是这条边下面的子树恰好包含 $c_1, c_2, \cdots, c_m$ 各一个。这件事并不容易检查，但我们直接&lt;strong&gt;对子树上的数值求异或和&lt;/strong&gt;，并通过&lt;strong&gt;检查子树异或和是否等于所有 $c_i$ 的异或和&lt;/strong&gt;的方式来“判定”子树是否满足要求。时间复杂度 $O(n)$。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;看上去有点雷人。下面尝试用不太严谨的方式论证该做法错误的概率极小：&lt;/p&gt;
&lt;p&gt;异或的性质是：$x\otimes x = 0$ (其中 $\otimes$ 常用于表示异或算符)。因此如果一个子树同时包含了一对点 $(u_i, v_i)$ 中的两个或零个，那么它最终的异或和将缺少 $c_i$ 这一项。因此要使得上述随机算法错误，一定存在一个 $\{1, 2, \cdots,m\}$ 的子集 $\{k_1, k_2, \cdots k_t\}$ 满足 $\bigotimes_{i=1}^t c_{k_i} = 0$，且恰好存在一条边能把这个子集精准地“选出来”。&lt;/p&gt;
&lt;p&gt;对于一个集合，若该集合中的数在 $[0, 2^k)$ 之间随机，那么不论这个集合中元素的个数有多少，该集合的异或和为 0 的概率都是 $\frac{1}{2^k}$ (考虑每个二进制位，有若干个要么是 0 要么是 1 的数，但不论有多少，其中有偶数个 1 的概率都是 $\frac{1}{2}$)。&lt;/p&gt;
&lt;p&gt;我们可以不严谨地认为，树上的每条边相当于独立地在 $\{1, 2, \cdots, m\}$ 中选一次子集 (说它不严谨是因为 ①不同的边选出的集合之间存在互相包含关系，并不是独立的； ②该过程和 $2m$ 个数在树上的分布有关，并不是随机选取。但总体可以感受到在概率上两者是同阶的)。因此该算法正确的概率&lt;/p&gt;
&lt;p&gt;$$
P(correct)\sim \left(1-\frac{1}{2^k}\right)^{\min(2^m, n)}
$$&lt;/p&gt;
&lt;p&gt;本题中 $n\sim 10^5$。简单计算可知，当 $k=32$ 时正确率已经达到 $99.997\%$，当 $k=64$ 时该算法正确率将极其接近 $100\%$ (64位恰好是 long long 的范围，在 long long 范围内随机整数并不困难)。&lt;/p&gt;
&lt;p&gt;虽然从理论计算科学的角度，有错误率的随机算法和确保正确的算法之间存在本质区别，但在实际中，如果算法错误的概率已经远小于硬件出错的概率，那么该算法的可用性便已经很高。对于这道题来说，我们确实容易设计出简单高效的线性算法，但事实上，绝大多数问题是难的 (关于难的定义，以及 P, NP, NP-hard 相关的概念大家会在第四学期学习)，对于难问题，很多时候我们只能从近似角度尝试解决。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【问题求解II-HW3.C】单词接龙</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-3-c/</link>
      <pubDate>Sat, 29 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-3-c/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;题意概述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定 $n$ 个英文单词，两个单词可以接在一起当且仅当前一个单词的最后一个字母和后一个单词的第一个字母相同。问最少删除多少个单词可以让剩下的单词全部接龙。&lt;/li&gt;
&lt;li&gt;$n\leq 10^5$。&lt;/li&gt;
&lt;/ul&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;从本次作业开始我们会逐渐向大家介绍简单的动态规划 (dynamic programming) 设计。动态规划是一项“很难教”的技术，因为它没有什么特别的理论基础，好的状态设计和转移优化也没有固定的模式，需要大家多看、多想、多总结。我们通过“单词接龙”这道题来向大家展示好的状态设计是如何显著减少算法时间复杂度的。&lt;/p&gt;
&lt;p&gt;首先，删除尽量少的单词等价于选择尽量多的可接龙单词，因此我们将问题转化为寻找原单词序列的最长可接龙子序列。我们首先考虑如下最容易想到的状态：令 $dp(i)$ 表示&lt;strong&gt;以第 $i$ 个单词结尾&lt;/strong&gt;的最长可接龙子序列的长度。为了计算这个状态，我们需要在 i-th 前找到另外一个单词，满足可以和 i-th 接上。因此转移方程可以写为
$$
dp(i) = 1 + \max_{k\in [1, i-1], word_k \to word_i} dp(k)
$$
其中 $word_i\to word_j$ 表示第 $i$ 个词的最后一个字母和第 $j$ 个词的第一个字母相同。式子最前方的 1 表示第 $i$ 个单词贡献的序列长度。计算完所有的 dp 值之后，$\max_{k=1}^n dp(k)$ 即为答案。&lt;/p&gt;
&lt;p&gt;这自然是一个正确的算法，但计算 $dp(i)$ 时需要依次枚举前面的所有单词，从而时间复杂度达到了 $O(n^2)$，在本题的数据规模下不可接受。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;优化状态设计的动机是：我们最关心的其实是单词的开头/结尾字母，而小写字母一共只有 26 个。因此我们应该在这方面作文章，把每次遍历前面所有单词的过程节省掉。考虑如下状态：令 $dp(i, ch)$ 表示在前 $i$ 个单词中，以字符 $ch$ 结尾的最长可接龙子序列的长度 &lt;strong&gt;(注意！不再要求一定以 $word_i$ 结尾！)&lt;/strong&gt;。转移考虑对以下两种情况取 max：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最长子序列不包括第 $i$ 个单词: $dp(i-1, ch)$。&lt;/li&gt;
&lt;li&gt;最长子序列包括第 $i$ 个单词，且第 $i$ 个单词确实以 $ch$ 结尾: 设第 $i$ 个单词的开头字符为 $ch&#39;$，则这种情况的最长序列长度为 $dp(i-1, ch&#39;) + 1$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此状态转移方程可以写为&lt;/p&gt;
&lt;p&gt;$$
dp(i, ch) = \begin{cases}
\max\{dp(i-1, ch), dp(i-1, \text{start}(word_i)) + 1\} &amp;amp;, \text{end}(word_i) = ch\\
dp(i-1, ch)&amp;amp;, \text{otherwise}
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;可以看到，虽然状态的数量上升到了 $O(n|\Sigma|)$，但转移的代价变成了 $O(1)$，所以总时间复杂度降低到了 $O(|\Sigma|n)$，其中 $\Sigma$ 为字符集，在本题中 $|\Sigma|=26$，可以通过。&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;有没有什么小技巧可以略微优化一下复杂度？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上述状态转移方程中，我们每次只会对一个 $ch$ 更新 dp，其余的都是照抄。而且 $dp(i, ch)$ 的计算只会用到 $dp(i-1, ch)$ 的结果，因此我们可以把状态的第一维省掉，把代码写成如下形式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dp = [0] * MAX_CHARACTER # 长度为 |Sigma| 的数组
for i in range(1, n + 1):
    # 此时的 dp[ch] 存储的是方程式中 dp(i-1, ch) 的值
    startch, endch = strings[i].start, strings[i].end
    dp[endch] = max(dp[endch], dp[startch] + 1)
    # 根据转移方程，此时 dp[endch] 的值是 dp(i, ch) 的值
    # 又因为其他的 dp[ch] 不需要改变，所以自动“升级”成了 dp(i, ch)
    # 至此，dp[ch] 存储了方程式中 dp(i, ch) 的值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，省掉了第一维之后，动态规划的时间复杂度下降到了 $O(n)$，空间复杂度下降到了 $O(|\Sigma|)$ (不考虑存储字符串的额外代价)。如果字符集的大小达到了很大的级别 (比如 unicode 中的所有字符)，那么这一简单的优化可以节省大量的时间和存储。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;第一个 dp 思路真的是“死胡同”吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;再来重温一下状态转移方程&lt;/p&gt;
&lt;p&gt;$$
dp(i) = 1 + \max_{k\in [1, i), word_k \to word_i} dp(k)
$$&lt;/p&gt;
&lt;p&gt;在考虑 $dp(i)$ 的转移时，我们在意的是所有的那些结尾字母与 $word_i$ 开头字母相同的位置的 dp 的最大值。每次把 1 到 i-1 扫一遍效率太低，但注意我们在做到 $dp(i)$ 时，之前的所有 dp 值已经求好了，因此我们可以额外对每种结尾字母维护当前最大值，从而实现 $O(1)$ 转移。&lt;/p&gt;
&lt;p&gt;形式化地，令
$$
maxdp(i, ch)\triangleq \max_{k\in [1, i],\text{end}(word_k)=ch} dp(k)
$$
则我们可以同时写出 dp 和 maxdp 的状态转移方程&lt;/p&gt;
&lt;p&gt;$$
\begin{align}
dp(i) &amp;amp;= 1 + maxdp(i-1, \text{start}(word_i))\\
maxdp(i, ch) &amp;amp;=
\begin{cases}
\max\{maxdp(i-1, ch), dp(i)\} &amp;amp;, \text{end}(word_i) = ch\\
maxdp(i-1, ch) &amp;amp;, \text{otherwise}
\end{cases}
\end{align}
$$&lt;/p&gt;
&lt;p&gt;两个转移都是 $O(1)$ 的，而且由于 $dp(i)$ 只用到 $maxdp(i-1, ch)$，所以我们可以用和类似的技巧将 maxdp 的第一维度省去，将代码写成类似下面的模样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for i in range(1, n + 1):
    startch, endch = strings[i].start, strings[i].end
    dp[i] = 1 + maxdp[startch]
    maxdp[endch] = max(maxdp[endch], dp[i])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你又可以发现一件事情：$dp(i)$ 在当前循环算完立即使用，且后续再也不会使用，所以可以把 $dp(i)$ 省略：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for i in range(1, n + 1):
    startch, endch = strings[i].start, strings[i].end
    maxdp[s.endch] = max(maxdp[endch], 1 + maxdp[startch])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和之前的代码对比一下，你会发现除了数组名字不一样，其他完全一样。我们用两条看上去不太相同的思考路径得到了相同的结果，但实际上它们的本质是一致的：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态规划状态设计就像给当前时刻做一张“快照”。你需要想清楚快照中保存怎样的性质可以完整地刻画当前的状态并为后续所用。在此基础上，记录的性质应当越少越好。&lt;/strong&gt; 在这个问题中，每个接龙字符串序列的最后一个字符是最本质地刻画特征的性质，而最后一个字符串的下标并不是 ($i+1$ 往后的状态并不关心 $[1,i]$ 中结尾为 $ch$ 的最长接龙字符串序列的最后一个字符串是 $[1, i]$ 中的哪一个)。这就是第一个 dp 方向错误的根本原因。&lt;/p&gt;
&lt;p&gt;大家日后要做的，就是稳准狠地抓住一个状态最本质的性质。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>【问题求解II-HW2.A】取数游戏</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-2-a/</link>
      <pubDate>Fri, 07 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-2-a/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;题意概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个长度为 $2n$ 的数列，保证所有数的和是奇数。两个人轮流取数，每次只能取数列的第一个或最后一个数。问双方都采取最优策略的情况下谁能获得胜利。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;为了说明这道题目的合理性，我们介绍策梅洛定理 (以下是摘自 Wikipedia 的解释)：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In game theory, Zermelo&amp;rsquo;s theorem is a theorem about finite two-person games of perfect information in which the players move alternately and in which chance does not affect the decision making process. It says that if the game cannot end in a draw, then one of the two players must have a winning strategy (i.e. can force a win).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说，一个双方轮流行动的游戏如果满足&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在有限步内结束。&lt;/li&gt;
&lt;li&gt;场上所有信息对双方公开。&lt;/li&gt;
&lt;li&gt;没有随机因素。&lt;/li&gt;
&lt;li&gt;没有平局。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么必然存在先手必胜策略或后手必胜策略。常见的棋类竞技运动如象棋、围棋都是有必胜策略的 (只不过搜索空间太大人们找不到)；当然飞行棋没有必胜策略，因为扔骰子这件事情带来了随机因素。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;回到这道题，如果撇除那条充满诱导性的提示，大家很可能想到的是使用如下的一个递推过程计算谁必胜：令 $s(l, r)$ 表示用区间 $[l, r)$ 中的数玩这个游戏，先手拿到的数的和最多可以比后手多多少。那么有&lt;/p&gt;
&lt;p&gt;$$
s(l, r)=\begin{cases}
0, &amp;amp;l=r\\
\max(\\
\qquad s(l+2, r) + a_l - a_{l+1},\\
\qquad s(l+1, r-1) + a_l - a_{r-1},\\
\qquad s(l+1, r-1) + a_{r-1} - a_l,\\
\qquad s(l, r-2) + a_{r-1} - a_{r-2}\\
), &amp;amp;l &amp;lt; r
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;这个公式看上去复杂，但其实只是枚举了两个人从数列里各取一个数的四种情况： (头,头)，(头,尾)，(尾,头)，(尾,尾)。如果我们认为区间的长度代表这个问题的规模的话，那么我们的递推公式就成功将大规模的问题转化为了小规模的同质问题。如果按照区间长度从小到大的顺序递推，你可以在 $O(n^2)$ 的时间复杂度内计算出 $s(1,2n+1)$，并根据 $s(1,2n+1)$ 的正负性判断谁必胜。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;上面的过程本质上是一个&lt;strong&gt;动态规划 (dynamic programming)&lt;/strong&gt;，如果你没有完全看懂也不要紧 (毕竟还没学)。我们出这道题的根本目的是为了展示一个更妙的想法：&lt;/p&gt;
&lt;p&gt;称 kk 取一个数，ff 再取一个数的两次操作为一轮。考虑每个数在原数列中的下标的奇偶性，我们容易发现：因为任意时刻剩余的数列一定是原数列的一个连续的子区间，所以每一轮开始时，剩余的数列在原数列中的位置一定是 “奇偶奇偶……” 或者 “偶奇偶奇……”。此时 kk 有着挑选奇偶的权利：如果 kk 拿走奇数位置的数，那么 ff 只能从两个偶数位置的数里选一个，反之亦然。&lt;/p&gt;
&lt;p&gt;因为每一轮 kk 都有挑选奇偶的权利，所以 kk 有能力拿走原数列中所有奇数位置的数，或者原数列中所有偶数位置的数。而“所有奇数位置的数的和”与“所有偶数位置的数的和”必定有一个更大，所以 kk 一定能把大的那组拿走，把小的留给 ff。所以这个游戏 kk 必胜。&lt;/p&gt;
&lt;p&gt;这道题旨在展示：通过充分动脑筋，一个看似复杂的问题可以解得非常简单。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【问题求解II-HW1.C】新马走日</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-1-c/</link>
      <pubDate>Thu, 30 Mar 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-1-c/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;题意概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个 $n\times m$ 的棋盘和象棋棋子马的初始位置，问经过 $k$ 步到达棋盘上任意点的方案数。&lt;/p&gt;
&lt;p&gt;$n,m\leq 15, k\leq 10^5$。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;邻接矩阵是描述图的一种常见方法：$\text{ga}(i,j)=1$ 当且仅当图中点 $i,j$ 之间有边。它之所以被称为“矩阵”，是因为矩阵的乘法恰好可以用于描述图上的游走。&lt;/p&gt;
&lt;p&gt;令 $A_k$ 为一个 $n$ 阶矩阵，其中 $A_k(i,j)$ 表示从点 $i$ 走 $k$ 步到点 $j$ 的方案数，那么我们可以发现 $A_0=I,A_1=\text{ga}$。更一般地，我们可以发现&lt;/p&gt;
&lt;p&gt;$$
\forall p, q. A_{p+q}=A_p\cdot A_q
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Proof: 考虑任意点对 $i,j$，从 $i$ 走 $p+q$ 步到 $j$ 可以被分解成两个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从 $i$ 走 $p$ 步到某一个节点 $k$。&lt;/li&gt;
&lt;li&gt;从 $k$ 走 $q$ 步到 $j$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此我们可以枚举这个中间节点 $k$，再根据加法/乘法原理有如下递推式：
$$
A_{p+q}(i,j)=\sum_{k=1}^n A_p(i,k)\cdot A_q(k,j)
$$&lt;/p&gt;
&lt;p&gt;容易发现这恰好是矩阵乘法的计算公式，从而原命题得证。$\square$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，$A_k=\text{ga}^k$。至于如何将原问题转化为一个图上的游走问题，想必你能够自己解决。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>问题求解 I-Final 题解</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/1-final/</link>
      <pubDate>Sun, 05 Mar 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/1-final/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Problem A: BrainF**k Syntax Checker&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题意概括：给定一个 BF 程序，判断它是否符合语法要求。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;BF 程序中的 &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; 显然不会对程序的合法性造成影响，因此本题的主要任务是判断 BF 程序中的 &lt;code&gt;[&lt;/code&gt; &lt;code&gt;]&lt;/code&gt; 是否形成了合法的括号序列，即两两匹配。&lt;/p&gt;
&lt;p&gt;值得注意的是，BF 程序中 &lt;code&gt;[&lt;/code&gt; 和 &lt;code&gt;]&lt;/code&gt; 的个数相同并不是括号序列合法的充要条件，比如 &lt;code&gt;][&lt;/code&gt; 这个序列就是不合法的。在此基础上，我们还要保证 BF 程序的任意前缀中，&lt;code&gt;[&lt;/code&gt; 的个数要大于等于 &lt;code&gt;]&lt;/code&gt; 的个数。&lt;/p&gt;
&lt;details&gt;&lt;summary&gt;&lt;b&gt;Code&lt;/b&gt; &lt;i&gt;[Click to expand]&lt;/i&gt;&lt;/summary&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
 
char program[1000];
string ValidChar = &amp;quot;+-,.&amp;lt;&amp;gt;[]&amp;quot;;
 
int main()
{
    scanf(&amp;quot;%s&amp;quot;, program);
    int len = strlen(program), LeftRightDelta = 0;
    bool flag = true;
    for (int i = 0; i &amp;lt; len; i++)
    {
        if (ValidChar.find(program[i]) == string::npos) flag = false;
        if (program[i] == &#39;[&#39;) LeftRightDelta++;
        if (program[i] == &#39;]&#39;) LeftRightDelta--;
        if (LeftRightDelta &amp;lt; 0) flag = false;
    }
    puts((flag &amp;amp;&amp;amp; LeftRightDelta == 0) ? &amp;quot;Yes&amp;quot; : &amp;quot;No&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Problem B: BrainF**k Interpreter&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题意概括： 给定一个 BF 程序，模拟其运行过程并输出最后的内存状态。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这是一道相当有意思的题目，解法也很多。该问题的核心难点是如何处理嵌套的中括号。考场上有很多同学利用递归处理中括号的嵌套，这是一个很好且可行的思路。我们在这里介绍另外一种不需要递归的思路，它书写起来更加简洁，且在一定程度上揭示了计算机运行的本质——大家在本学期的 &lt;em&gt;数字逻辑与计算机组成&lt;/em&gt; 和下学期的 &lt;em&gt;计算机系统基础&lt;/em&gt; 中会不断与这种逻辑打交道。&lt;/p&gt;
&lt;p&gt;在题面的提示中我们已经给出了计算机执行指令的四步骤，我们在这里再重复一遍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取指：取出下一条执行的指令。&lt;/li&gt;
&lt;li&gt;译码：根据指令的格式确定该指令的类型。&lt;/li&gt;
&lt;li&gt;执行：根据指令类型，执行该指令定义的动作。&lt;/li&gt;
&lt;li&gt;跳转：根据指令类型和执行过程，确定下一条应当执行的指令的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;真正的计算机处理的是“汇编语言”，我们的 BF 解释器处理的是 BF 语言，这两者在本质上没有区别。计算机内部通常有一个程序计数器 (program counter, 简称 pc)，它的功能和计数没什么关系，反而像一个指针，用来指向下一条要执行的指令。我们来具体地看看四个步骤对应到 BF 语言应当如何操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;取指：这是最简单的一步，对应到 C++ 代码大概就是 &lt;code&gt;char instruction = program[pc]&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;译码&amp;amp;执行：这两步在 BF 中可以放在一起做 (因为 BF 的所有指令都没有“操作数”)，你大抵会用一个 if/switch 语句来判断 instruction 是 8 个符号中的哪一种并执行相应的操作。前 6 种指令的操作都非常简单，这里不再赘述。&lt;code&gt;[&lt;/code&gt; 和 &lt;code&gt;]&lt;/code&gt; 本质上是分支控制指令，所以在“执行”这个步骤中它们什么也不用做。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跳转：前 6 种指令的跳转都非常简单：做完了就做紧接着的下一条指令，即 &lt;code&gt;pc++&lt;/code&gt;。我们着重讲解 &lt;code&gt;[&lt;/code&gt; 和 &lt;code&gt;]&lt;/code&gt; 的跳转如何处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[&lt;/code&gt;：左中括号指令的逻辑是
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;if (memory[pointer] != 0)
    pc++ // go into the loop
else
    pc = (the position of the corresponding &amp;quot;]&amp;quot;) + 1 // skip the loop
&lt;/code&gt;&lt;/pre&gt;
&lt;code&gt;pc&lt;/code&gt; 直接加一意味着进入循环，&lt;code&gt;pc&lt;/code&gt; 跳转到对应的 &lt;code&gt;]&lt;/code&gt; 的下一条指令意味着跳过循环。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;]&lt;/code&gt;：右中括号指令的逻辑是
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;pc = (the position of the corresponding &amp;quot;[&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
遇到右中括号，无条件跳转到对应的左中括号，开始新一轮循环条件判断。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意到 &lt;code&gt;[&lt;/code&gt; 和 &lt;code&gt;]&lt;/code&gt; 的处理都依赖与之匹配的“另一半”，因此在正式开始执行程序之前，我们要预处理一遍程序以知道与每个 &lt;code&gt;[&lt;/code&gt;/&lt;code&gt;]&lt;/code&gt; 配对的 &lt;code&gt;]&lt;/code&gt;/&lt;code&gt;[&lt;/code&gt; 在什么位置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按照这四个步骤书写本题的代码，可以完成得轻松且高效，从中你也可以领悟到计算机系统设计的伟大智慧。&lt;/p&gt;
&lt;details&gt;&lt;summary&gt;&lt;b&gt;Code&lt;/b&gt; &lt;i&gt;[Click to expand]&lt;/i&gt;&lt;/summary&gt;
&lt;p&gt;注：下面参考程序仅仅实现了一个 BF 解释器，输入格式和输出格式与原题并不相同。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int memory[1000], pointer;
char program[1000]; int n;

int input_count, input[1000];

int jumpto[1000], stk[1000], stot;

int main ()
{
    scanf(&amp;quot;%s&amp;quot;, program); n = strlen(program);
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;input_count);
    for (int i = 1; i &amp;lt;= input_count; i++) scanf(&amp;quot;%d&amp;quot;, input + i);

    // 预处理每个 [ 和 ] 对应的 ]/[
    stot = 0;
    for (int i = 0; i &amp;lt; n; i++)
    {
        if (program[i] == &#39;[&#39;) stk[++stot] = i;
        if (program[i] == &#39;]&#39;)
        {
            jumpto[i] = stk[stot];
            jumpto[stk[stot]] = i + 1;
            stot--;
        }
    }

    pointer = 0;
    int pc = 0, input_pt = 0;
    bool printed = false;
    while (pc &amp;lt; n)
    {
        int next_pc = pc + 1;
        switch (program[pc])
        {
            case &#39;+&#39;: memory[pointer]++; break;
            case &#39;-&#39;: memory[pointer]--; break;
            case &#39;&amp;lt;&#39;: pointer--; break;
            case &#39;&amp;gt;&#39;: pointer++; break;
            case &#39;,&#39;: memory[pointer] = input[++input_pt]; break;
            case &#39;.&#39;: printf(&amp;quot;%d &amp;quot;, memory[pointer]); printed = true; break;
            case &#39;[&#39;:
                if (memory[pointer] == 0)
                    next_pc = jumpto[pc];
                break;
            case &#39;]&#39;: next_pc = jumpto[pc]; break;
        }
        pc = next_pc;
    }
    if (printed) puts(&amp;quot;&amp;quot;);
    for (int i = 0; i &amp;lt; 10; i++)
        printf(&amp;quot;%d &amp;quot;, memory[i]);
    puts(&amp;quot;&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Problem C: DXY&amp;rsquo;s Graph Problem&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题意概括：给定一张图 $G=(V, E)$，其中 $V$, $E$ 分别是点和边的集合。对于图中任意顶点 $v\in V$，令 $\text{cover}(v)\triangleq \{(x, y)\in E: x=v\vee y=v\}$ (即与该点相邻的所有边的集合)。问是否存在原图顶点的划分 $S_1, S_2$，满足 $S_1\uplus S_2=V$ (即 $S_1\cup S_2=V$ 且 $S_1\cap S_2=\emptyset$)，且&lt;/p&gt;
&lt;p&gt;$$
\bigcup_{v\in S_1}\text{cover}(v)=\bigcup_{v\in S_2}\text{cover}(v)=E
$$&lt;/p&gt;
&lt;p&gt;(注：本题完整题意里中文描述中有关“DXY可以通过自己的点集将原图恢复”的部分给大家带来了较大困扰，对此我们深表歉意。)&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;每条边都有两个端点，要想这条边被双方都覆盖到，那么这两个端点必须分属于不同的集合。因此可以成功划分的充要条件是：存在将整张图上的顶点黑白染色，且每条边的两个端点一黑一白的方案。&lt;/p&gt;
&lt;p&gt;我们容易发现这样的方案如果存在一定是唯一的，因为我们已经规定了 1 号点属于 DXY，我们不妨将白色分配给 DXY，那么整个过程相当于从一个白色的 1 号点开始向外搜索，每搜索到一个新的节点就给它涂上和邻居节点不同的颜色。由于整个图是连通的 (即任意两个节点都存在路径互相可达)，所以这样的搜索一定能给每个节点一个唯一的颜色 (如果你想要严谨地证明，可以考虑数学归纳法)。在搜索的过程中，如果发现无法解决的矛盾 (例如某个节点同时和一个黑点和白点相邻)，则问题无解。&lt;/p&gt;
&lt;p&gt;如果你愿意继续深究这个问题 (这部分知识对于解决这道题并无必要)，你会发现可以成功黑白染色充要条件是&lt;strong&gt;图中不存在奇数长度的环&lt;/strong&gt;，这也是判断二分图 (Bipartite Graph) 的方法，大家在后续的问题求解课程中会学习到这个概念和相关的证明。&lt;/p&gt;
&lt;details&gt;&lt;summary&gt;&lt;b&gt;Code&lt;/b&gt; &lt;i&gt;[Click to expand]&lt;/i&gt;&lt;/summary&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
 
const int MAXN = 1e5 + 10;
 
int n, m;
vector&amp;lt;int&amp;gt; v[MAXN];
 
int color[MAXN];
bool flag;
 
void dfs(int cur)
{
    for (auto neighbor : v[cur])
        if (color[neighbor] == 0)
        {
            color[neighbor] = 3 - color[cur]; 
            // 两种颜色用 1, 2 表示
            // 3 - color[cur] 则表示“另一种颜色”
            dfs(neighbor);
        }
        else if (color[neighbor] != 3 - color[cur])
            flag = false;
         
}
 
int main ()
{
    scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m); int x, y;
    for (int i = 1; i &amp;lt;= m; i++)
    {
        scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;x, &amp;amp;y);
        v[x].push_back(y); v[y].push_back(x);
    }
     
    color[1] = 1; flag = true;
    dfs(1);
     
    if (flag)
    {
        puts(&amp;quot;Yes&amp;quot;);
        int cnt1 = 0, cnt2 = 0;
        for (int i = 1; i &amp;lt;= n; i++) if (color[i] == 1) cnt1++; else cnt2++;
        printf(&amp;quot;%d %d\n&amp;quot;, cnt1, cnt2);
        for (int i = 1; i &amp;lt;= n; i++) if (color[i] == 1) printf(&amp;quot;%d &amp;quot;, i);
        puts(&amp;quot;&amp;quot;);
        for (int i = 1; i &amp;lt;= n; i++) if (color[i] == 2) printf(&amp;quot;%d &amp;quot;, i);
        puts(&amp;quot;&amp;quot;);
    }
    else
        puts(&amp;quot;No&amp;quot;);
     
    return 0;
     
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;</description>
    </item>
    
    <item>
      <title>【问题求解I-HW6.C】万圣节的新娘</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/1-6-c/</link>
      <pubDate>Wed, 14 Dec 2022 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/1-6-c/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;题意概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定 $n$ 个数对，保证 $1\cdots n$ 中的每个数恰好出现两次。每次操作可以任意交换两个数的位置。问至少多少次交换可以使得每对数都相同。&lt;/p&gt;
&lt;p&gt;约束条件：$n\leq 10^6$。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这道题颇有思维难度，需要仔细观察并发现问题的性质。发现问题的性质不能靠双眼瞪着屏幕——动起手来，画几个样例手算出解法，很多时候解决问题的灵感就是从手算得出的。&lt;/p&gt;
&lt;p&gt;我们首先可以确定一件事：答案的上限是 $n-1$，因为每轮操作你总可以让某一个数对匹配起来。如果你手算尝试了一些样例，你一定会发现想要让交换次数最少，我们会格外喜欢这样的数对：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;1 2
2 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为我们只要让上面的 2 和下面的 1 交换，我们就可以一下子得到两个匹配的数对，这看起来非常赚。但不是什么时候都能有“动一次成两对”这么赚的事情，你很快会发现有的时候格局可能是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;1 2
2 3
3 5
5 8
8 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过观察你可以发现：这样的 5 个数对你只要将前 4 个搞定，最后一个也会随之搞定，且你无法给出比 4 次交换更好的方案。&lt;/p&gt;
&lt;p&gt;你是否觉得上面的 5 个数对像是 &lt;code&gt;1, 2, 3, 5, 8&lt;/code&gt; 五个数构成的环？事实上，稍加思索你便能发现 $n$ 个数对其实就是由这样的若干个互不影响的“环”组成的。每个环形如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;a1 a2
a2 a3
...
an-1 an
an a1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样一个长度为 $n$ 的环，我们需要 $n-1$ 次操作将其全部搞定，每有一个“环”，我们就可以“节省”一次操作。因此，设 $n$ 个数对共由 $m$ 个环构成，那么最小的操作次数就是 $n-m$。&lt;/p&gt;
&lt;p&gt;判断环的个数相对简单，你并不一定需要使用“并查集”这样高级的数据结构——事实上搜索已经足够完成任务了，这部分的细节留给大家自行思考。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【问题求解I-HW4.C】jyy为什么是神</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/solutions/1-4-c/</link>
      <pubDate>Thu, 27 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/solutions/1-4-c/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;题意概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定字符串 $s$，求 $|\{(i,j,k)|s_i=j,s_j=y,s_k=y\}|$。&lt;/p&gt;
&lt;p&gt;约束条件：$|s|\leq 10^6$。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;大家容易想到的一个非常简明的做法是使用三重循环计数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ans = 0;
for (int i = 0; i &amp;lt; int(s.size()); i++)
    for (int j = i + 1; j &amp;lt; int(s.size()); j++)
        for (int k = j + 1; k &amp;lt; int(s.size()); k++)
            if (s[i] == &#39;j&#39; &amp;amp;&amp;amp; s[j] == &#39;y&#39; &amp;amp;&amp;amp; s[k] == &#39;y&#39;)
                ans++;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但由于此题中 $|s|$ 达到了 $10^6$，使用三重循环意味着循环最内层的核心语句被执行了将近 $|s|^3$ 次。计算机一秒钟可以执行的 C/C++ 基本语句数目大约在 $10^8$ 量级，这样的程序显然会超时。&lt;/p&gt;
&lt;p&gt;本题的出题助教 (aka. dxy) 希望大家构造自动机解题。这里我们给出一个另外的比较简单的思路：&lt;/p&gt;
&lt;p&gt;我们将上面的程序改写为如下伪代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ans = 0;
for (int i = 0; i &amp;lt; int(s.size()); i++)
    if (s[i] == &#39;j&#39;)
        ans += &amp;quot;s[i]的后面(可以不连续)的yy的数目&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之前的代码中我们使用双重循环来数 &amp;ldquo;yy&amp;rdquo; 的个数，但事实上我们有更快速的方法：假设 &lt;code&gt;s[i]&lt;/code&gt; 的后面一共有 &lt;code&gt;n&lt;/code&gt; 个字母y，那么任意挑选两个都可以组成一个yy，所以yy的总数目是 $\binom{n}{2}=\frac{1}{2}n(n-1)$。基于这个想法，我们可以用一个二重循环解决该问题：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ans = 0;
for (int i = 0; i &amp;lt; int(s.size()); i++)
    if (s[i] == &#39;j&#39;)
    {
        int y_count = 0;
        for (int j = i + 1; j &amp;lt; int(s.size()); j++)
            if (s[j] == &#39;y&#39;) y_count++;
        ans += C(y_count, 2); // 组合数需要另外实现
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们的算法已经得到了改进，但 $|s|^2$ 次运行仍然无法在规定时间内获得结果，算法还需要进一步的优化。上述方法的瓶颈在于我们每遇到一个j都会把它后面的y数一遍，这样有很多的字母y被反复数了很多遍，这无疑拖慢了速度。&lt;/p&gt;
&lt;p&gt;事实上，一个巧妙的顺序的改变就可以“柳暗花明”：我们将外层循环的顺序倒过来，一边寻找j一边把j“身后”的y的个数数出来，这样就不需要内层循环了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ans = y_count = 0;
for (int i = int(s.size()) - 1; i &amp;gt;= 0; i--) {
    if (s[i] == &#39;y&#39;) y_count++;
    if (s[i] == &#39;j&#39;) ans += C(y_count, 2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;循环的使用方法博大精深，大家可以仔细体会这段代码。&lt;/p&gt;
&lt;p&gt;此外，本题由于结果过大，最终需要输出答案对 $998244353$ 取模的结果。大家在本题中可能会使用乘法，此时必须格外小心两个 &lt;code&gt;int&lt;/code&gt; 类型变量相乘 (还没来得及取模时) 结果溢出的情况，一个好的解决方案是使用更大的数据类型存储中间结果。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
