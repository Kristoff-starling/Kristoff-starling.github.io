<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Coding | Yuyao Wang&#39;s Homepage</title>
    <link>https://kristoff-starling.github.io/courses/problemsolving22/coding/</link>
      <atom:link href="https://kristoff-starling.github.io/courses/problemsolving22/coding/index.xml" rel="self" type="application/rss+xml" />
    <description>Coding</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Tue, 28 Mar 2023 00:00:00 +0000</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>Coding</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/coding/</link>
    </image>
    
    <item>
      <title>Differential Testing</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/coding/difftest/</link>
      <pubDate>Tue, 28 Mar 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/coding/difftest/</guid>
      <description>&lt;p&gt;如何论证你写的程序是正确的？这是一个历史悠久且难以回答的问题。通常来说有两种思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Verification: 形式化验证简单来说是通过数学手段证明你的程序的行为符合预期。这是对程序正确性的强而有力的证明，但通常非常困难、局限性很大、scalability 较差，因此更多用于对于安全/可靠性要求非常严苛的场景，如自动驾驶，火星车等。问题求解一中提到的“通过 loop invariant 证明循环正确性”可以认为是 verification 的一种非常简单的形式。由于 verificaton 需要大量的程序语言(PL)/形式化方法(FM)的背景知识，且对于简单算法问题来说颇有大材小用之嫌，故在这里不作赘述。&lt;/li&gt;
&lt;li&gt;Testing: 测试是更加常用的检查程序是否有漏洞的方法，其核心思想是构造大量的输入并检查目标程序在这些输入上的输出是否符合预期。测试有着天然的局限性：它只能证明你的程序有 bug，但无法证明你的程序没有 bug (OJ 的本质也是测试，因此在 OJ 上通过的程序并不一定是对的 &lt;del&gt;而且由于助教太懒数据太水很可能确实是错的&lt;/del&gt;)。不过我们总可以认为，如果我们构造的输入足够多且足够丰富，那么通过了所有测试的程序的可靠性相对会很高。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里我们介绍一种简单易行的测试技术：differential testing (如果你曾经参加过算法竞赛，“对拍”的本质就是 DiffTest)。DiffTest 的核心思想是针对同一个问题完成两份不同的实现，然后构造大量的输入喂给两份实现观察它们的输出是否相同 (就像你每天早晨和同桌对作业答案，虽然你们都不能保证自己做的是对的，但做错且错得一样的概率毕竟很小，如果你们的解题思路不一样就更小了)。为了避免过于空洞，我们以“计算Fibonacci第n项”这个问题为例说明如何在 OJ 算法题上进行 DiffTest。&lt;/p&gt;
&lt;p&gt;假设你已经写好了一个使用矩阵快速幂优化 Fibonacci 计算的程序 &lt;code&gt;fib.cpp&lt;/code&gt;，现在希望对其进行测试。我们很容易写一个朴素版的 &lt;code&gt;fib_bruteforce.cpp&lt;/code&gt; 来实现同样的功能 (虽然它能处理的 $n$ 规模较小)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

const int MOD = 998244353;

int main ()
{
    int n, f0 = 0, f1 = 1, f2;
    cin &amp;gt;&amp;gt; n;
    for (int i = 2; i &amp;lt;= n; i++)
    {
        f2 = (f0 + f1) % MOD;
        f0 = f1; f1 = f2;
    }
    printf(&amp;quot;%d\n&amp;quot;, f2);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据我们的预期，对于任意 $n$，如果 &lt;code&gt;fib.cpp&lt;/code&gt; 和 &lt;code&gt;fib_bruteforce.cpp&lt;/code&gt; 都给出了答案，那么答案应该是相同的。这个问题的好处在于测试数据形式非常简单：只有一个数。因此我们很容易写出一个数据生成程序 &lt;code&gt;gen_data.cpp&lt;/code&gt; (注意我们的朴素版本无法处理过大的 $n$)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int main ()
{
    int limit = 10000000;
    mt19937 mt(time(nullptr));

    cout &amp;lt;&amp;lt; mt() % limit + 1 &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;mt19937&lt;/code&gt; class 是一个非常高效的伪随机数生成器。你也可以使用 &lt;code&gt;rand()&lt;/code&gt; 等其他函数来生成随机数 (注意设置随机种子，否则可能每次生成的随机数都一样)。&lt;/p&gt;
&lt;p&gt;有了两份实现和一个数据生成器，接下来的任务就是写一个脚本来做如下循环：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;while True
{
    DataGenerator &amp;gt;&amp;gt; data
    data &amp;gt;&amp;gt; Program1 &amp;gt;&amp;gt; output1
    data &amp;gt;&amp;gt; Program2 &amp;gt;&amp;gt; output2
    compare output1 and output2
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你会在 Windows 下写 Batch/Powershell 脚本，你应该可以给出一个上述伪代码的轻巧实现；如果你使用类 Unix 系统，你大概率也可以给出一个 bash 脚本。如果你啥也不会，可以考虑使用下面给出的这份 Python 程序进行测试。&lt;/p&gt;
&lt;details&gt;&lt;summary&gt;一份 Difftest Python 实现 &lt;i&gt;[Click to expand]&lt;/i&gt;&lt;/summary&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
usage: difftest.py [-h] --impl IMPL IMPL --gen GEN [--num NUM] [--time TIME]

optional arguments:
  -h, --help        show this help message and exit
  --impl IMPL IMPL  two source code files
  --gen GEN         data generator, cpp or python
  --num NUM         number of tests
  --time TIME       time limit for each test, in seconds
&amp;quot;&amp;quot;&amp;quot;

import os, subprocess
import atexit

objs = []

def compile(*progs):
    for prog in progs:
        assert os.path.exists(prog), f&amp;quot;{prog} not exist&amp;quot;
        if prog.endswith(&amp;quot;.cpp&amp;quot;):
            obj = f&amp;quot;obj-{prog}&amp;quot;
            objs.append(obj)
            p = subprocess.run(f&amp;quot;g++ -o {obj} {prog} -O2&amp;quot;, shell=True)
            assert p.returncode == 0, f&amp;quot;{prog} failed to be compiled, make sure that g++ is in your enviroment path&amp;quot;
    
def destructor():
    for obj in objs:
        if os.path.exists(obj):
            os.remove(obj)

def run(prog: str, tl: float, data: str):
    cmd = f&amp;quot;./obj-{prog}&amp;quot; if prog.endswith(&amp;quot;.cpp&amp;quot;) else f&amp;quot;python3 {prog}&amp;quot;
    p = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
    try:
        stdout, _ = p.communicate(input=data.encode(), timeout=tl)
    except subprocess.TimeoutExpired:
        p.kill()
        raise Exception(f&amp;quot;{prog} exceed {tl}s time limit&amp;quot;)
    return stdout.decode()

def dump(data, o1, o2):
    with open(&amp;quot;input&amp;quot;, &amp;quot;w&amp;quot;) as f: f.write(data)
    with open(&amp;quot;output1&amp;quot;, &amp;quot;w&amp;quot;) as f: f.write(o1)
    with open(&amp;quot;output2&amp;quot;, &amp;quot;w&amp;quot;) as f: f.write(o2)

def cmp(data, o1, o2):
    t1, t2 = o1.strip().split(&amp;quot;\n&amp;quot;), o2.strip().split(&amp;quot;\n&amp;quot;)
    if len(t1) != len(t2):
        dump(data, o1, o2)
        return False
    for line1, line2 in zip(t1, t2):
        if line1.strip() != line2.strip():
            dump(data, o1, o2)
            return False
    return True

if __name__ == &amp;quot;__main__&amp;quot;:
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument(&amp;quot;--impl&amp;quot;, nargs=2, required=True, help=&amp;quot;two source code files&amp;quot;)
    parser.add_argument(&amp;quot;--gen&amp;quot;, type=str, required=True, help=&amp;quot;data generator, cpp or python&amp;quot;)
    parser.add_argument(&amp;quot;--num&amp;quot;, type=int, default=100, help=&amp;quot;number of tests&amp;quot;)
    parser.add_argument(&amp;quot;--time&amp;quot;, type=float, default=5.0, help=&amp;quot;time limit for each test, in seconds&amp;quot;)
    args = parser.parse_args()

    atexit.register(destructor)

    compile(args.impl[0], args.impl[1], args.gen)

    for i in range(args.num):
        data = run(args.gen, args.time, &amp;quot;&amp;quot;)
        res1 = run(args.impl[0], args.time, data)
        res2 = run(args.impl[1], args.time, data)
        assert cmp(data, res1, res2), &amp;quot;Wrong answer, input/output files dumped&amp;quot;
        print(f&amp;quot;Test {i+1} OK!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr&gt;
&lt;p&gt;DiffTest 显然比自己出数据，运行程序，再手动验证结果要高效得多。用正确的工具和方法做事能让你事半功倍。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>优雅地取模</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/coding/modulation/</link>
      <pubDate>Wed, 22 Mar 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/coding/modulation/</guid>
      <description>&lt;p&gt;不少同学被OJ的取模问题折磨得心力憔悴——不论多么仔细地检查每一处四则运算，总会有一处漏网之鱼让程序输出错误的结果。这里我们展示一种比较优雅的代码书写方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;const int MOD = 998244353;

int add(int x, int y) { x += y; if (x &amp;gt;= MOD) x -= MOD; return x;}
int sub(int x, int y) { x -= y; if (x &amp;lt; 0) x += MOD; return x; }
int mul(int x, int y) { return 1ll * x * y % MOD; }
void Add(int &amp;amp;x, int y) { x = add(x, y); }
void Sub(int &amp;amp;x, int y) { x = sub(x, y); }
void Mul(int &amp;amp;x, int y) { x = mul(x, y); }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我们定义了 &lt;code&gt;MOD&lt;/code&gt; 这个变量以及 6 个函数统一完成加法、减法和乘法的取模操作。这样后续程序中的任何运算都可以调用这几个函数来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;c = sub(a, b);  // instead of c = (a - b) % MOD;
Add(c, d);      // instead of c += d %= MOD;
Mul(a_very_very_long_variable_name, c); 
  // instead of a_very_very_long_variable_name = 1ll * a_very_very_long_variable_name * c % MOD;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用统一的取模函数和 &lt;code&gt;MOD&lt;/code&gt; 变量有包括但不限于以下好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正确性: 你只需要仔细地书写这几个取模函数，后面的程序中你只要保证不出现 &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt;，就不会发生“漏了取模”的悲剧。&lt;/li&gt;
&lt;li&gt;简洁性: 在上述的的第三个例子中可以看出使用取模函数可以避免重复书写长变量名，使代码更加简洁。&lt;/li&gt;
&lt;li&gt;可维护性: 假设某一天我们通知需要将模数紧急换成 &lt;code&gt;1000000007&lt;/code&gt;，相比较将程序中散落在各处的 &lt;code&gt;998244353&lt;/code&gt; 修改掉，如果你定义了 &lt;code&gt;MOD&lt;/code&gt; 变量，你只需要修改一处。&lt;/li&gt;
&lt;li&gt;性能: 你也许注意到了我们在加法和减法中使用了 “if 判断 + 加减”的方式代替了取模，你可以证明只要传入的参数在 &lt;code&gt;[0, MOD)&lt;/code&gt; 范围内，该写法的正确性的可以保证的。在计算机底层实现中，进行一次取模操作的代价显著高于简单判断和加减，这样的写法有助于提升效率 (有时候这种提升是惊人的！)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们承认取模这件事情在工程开发中可能并不常见，但这样的程序设计却体现了软件工程的通用思想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;将需要频繁使用的常量定义成宏/constexpr&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将容易出错的功能单独封装成函数，之后调用接口解决问题&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;alert alert-tip&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;程序设计优化是一件&lt;b&gt;“绝知此事要躬行”&lt;/b&gt;的事情。阅读一遍这篇文章大抵不会对你的思想产生重大的影响：你也许会认为这些是多此一举，或者你对自己写代码时的仔细程度非常自信。你只有经历了现实的捶打，经历了熬夜通宵的折磨，才会深刻地意识到人类永远无法克服基因决定的共同弱点，才会理解这些文字背后是前人的智慧和血的教训。&lt;/p&gt;
&lt;p&gt;笔者在高中时曾参加一项极其重要的编程比赛。他针对一道难题推导出了一个极其复杂的数学公式并编码实现了它，但在比赛结束前的 5 分钟他发现自己的程序处处漏了取模——他永远不会忘记在手指被汗水浸湿以至于键盘打滑的情况下狂按 ctrl+F, ctrl+C, ctrl+V 是怎样的紧张和绝望，也不会忘记最终也没有把取模问题解决完，因为这样一个小细节与自己想要的结果失之交臂的痛苦。从那之后，他再也没有犯过低级的漏取模错误。&lt;/p&gt;
&lt;p&gt;我不期望你看完这段话就真的能听进去 (因为这也是人类刻在基因里的弱点之一)，但我衷心希望你为之付出的代价能比我小一些。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>矩阵快速幂</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/coding/matmul/</link>
      <pubDate>Wed, 22 Mar 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/coding/matmul/</guid>
      <description>&lt;p&gt;按照线性代数中的矩阵乘法规则，常见的矩阵乘法写法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;for (int i = 1; i &amp;lt;= n; i++)
    for (int j = 1; j &amp;lt;= n; j++)
        for (int k = 1; k &amp;lt;= n; k++)
            c[i][j] += a[i][k] * b[k][j]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是我们强烈建议你调整循环的顺序，按照如下方式书写矩阵乘法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;for (int i = 1; i &amp;lt;= n; i++)
    for (int k = 1; k &amp;lt;= n; k++)
        for (int j = 1; j &amp;lt;= n; j++)
            c[i][j] += a[i][k] * b[k][j]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然这样有点“反直觉”，但在稍大规模的数据下运行时，你会发现这种写法的效率比前者高很多。理解效率提高的原因需要对计算机体系结构和 C/C++ 语言中数组在内存中的存储有一定的了解，这里不作赘述。你可以暂且将其背下来 😂&lt;/p&gt;
&lt;p&gt;为了更优雅地实现矩阵快速幂，我们还强烈建议你学习 C++ Class 相关的内容并了解操作符重载。这样你可以自己定义矩阵类并为矩阵类书写乘法规则，从而直接复用“快速幂”一讲中的代码计算矩阵快速幂。下面给出一个参考实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Matrix
{
    int b[10][10];
    Matrix () { memset(b, 0, sizeof(b)); }
    void init_I() { for (int i = 1; i &amp;lt;= n; i++) b[i][i] = 1; }
    Matrix operator * (Matrix other)
    {
        Matrix res;
        for (int i = 1; i &amp;lt;= n; i++)
            for (int k = 1; k &amp;lt;= n; k++)
                for (int j = 1; j &amp;lt;= n; j++)
                    res.b[i][j] += b[i][k] * other.b[k][j];
        return res;
    }
};

Matrix quick_pow(Matrix x, int y)
{
    T res; res.init_I();
    while (y)
    {
        if (y &amp;amp; 1) res = res * x;
        x = x * x; y &amp;gt;&amp;gt;= 1;
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
