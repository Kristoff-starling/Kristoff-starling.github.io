<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Coding | Yuyao Wang&#39;s Homepage</title>
    <link>https://kristoff-starling.github.io/courses/problemsolving22/coding/</link>
      <atom:link href="https://kristoff-starling.github.io/courses/problemsolving22/coding/index.xml" rel="self" type="application/rss+xml" />
    <description>Coding</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Wed, 19 Apr 2023 00:00:00 +0000</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>Coding</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/coding/</link>
    </image>
    
    <item>
      <title>快速输入输出</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/coding/fastio/</link>
      <pubDate>Wed, 19 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/coding/fastio/</guid>
      <description>&lt;p&gt;大家比较熟悉的输入输出有两种：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int x;

scanf(&amp;quot;%d&amp;quot;, &amp;amp;x);         // C Style
printf(&amp;quot;%d\n&amp;quot;, x);

std::cin &amp;gt;&amp;gt; x;           // C++ style
std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; endl; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果输入/输出量过大，以至于输入输出部分成为算法问题实现的效率瓶颈，那么采取合适的方法进行快速输入/输出就变得非常重要。本章节介绍若干种常见的输入输出优化。&lt;/p&gt;
&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    输入输出函数背后的实现非常复杂，其效率与缓冲区设计、操作系统、磁盘IO等多个环节息息相关。因此本章节会尽可能略去原理的讲解 (或者以补充链接的形式给出)。如果你无法理解这其中的奥妙，不用担心，先把写法学会，等你学过了计算机体系结构/计算机系统基础/操作系统后就会对它们有更深刻的认识。
  &lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;关闭与-stdio-的同步&#34;&gt;关闭与 stdio 的同步&lt;/h3&gt;
&lt;p&gt;一种
&lt;a href=&#34;https://stackoverflow.com/questions/1042110/using-scanf-in-c-programs-is-faster-than-using-cin&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;主流的说法&lt;/a&gt; 是: &lt;code&gt;cin&lt;/code&gt; 比 &lt;code&gt;scanf&lt;/code&gt; 读入要慢。在选择接受这条“定理”之前，你应当自己做个实验来验证一下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int N = 30000000;
int a[N];
int main ()
{
    for (int i = 0; i &amp;lt; N; i++) cin &amp;gt;&amp;gt; a[i];
    for (int i = 0; i &amp;lt; N; i++) scanf(&amp;quot;%d&amp;quot;, a + i);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将 $N$ 设置成一个很大的数，并用 &lt;code&gt;cin&lt;/code&gt; 和 &lt;code&gt;scanf&lt;/code&gt; 分别跑一遍测试时间。不出意外的话你会发现这条定理确有其正确之处。但事实上 &lt;code&gt;cin&lt;/code&gt; 比 &lt;code&gt;scanf&lt;/code&gt; 看上去慢的一个主要原因是：&lt;code&gt;cin&lt;/code&gt; 花了很多代价进行缓冲区同步，从而让你可以在混用 &lt;code&gt;cin&lt;/code&gt; 和 &lt;code&gt;scanf&lt;/code&gt; 的情况保证程序的正确性。我们可以在 &lt;code&gt;main()&lt;/code&gt; 函数开头显式地通过添加一句 &lt;code&gt;ios::sync_with_stdio(false);&lt;/code&gt; 来关闭这种同步。关闭同步后，你可以再尝试一次上述的效率实验，你会发现 &lt;code&gt;cin&lt;/code&gt; 和 &lt;code&gt;scanf&lt;/code&gt; 其实没什么差别。&lt;/p&gt;
&lt;p&gt;需要注意的是：一旦手动关闭了同步，你就不能再混用两种风格的输入函数。你可以尝试运行下面的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int main ()
{
	ios::sync_with_stdio(false);
	int a, b, c;
	cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
	scanf(&amp;quot;%d&amp;quot;, &amp;amp;c);
	cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你会发现该程序会给你意想不到的结果。&lt;/p&gt;
&lt;h3 id=&#34;使用-getchar-代替-scanf&#34;&gt;使用 &lt;code&gt;getchar()&lt;/code&gt; 代替 &lt;code&gt;scanf()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;C库提供的 &lt;code&gt;scanf()&lt;/code&gt; 函数功能丰富，例如可以用 &lt;code&gt;%d&lt;/code&gt; &lt;code&gt;%s&lt;/code&gt; &lt;code&gt;%p&lt;/code&gt; &lt;code&gt;%x&lt;/code&gt;，甚至正则表达式，去匹配各种类型的数据。但功能丰富的代价就是效率不够高。如果你确定当前场景下需要读入的一定是某种特定类型的数据 (例如整数)，那么可以考虑使用 &lt;code&gt;getchar()&lt;/code&gt; (其功能为读入一个字符) 来手写一个读入函数，这通常能获得更好的效率。下面展示一个读入 int 类型整数的函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int getint()
{
    char ch; int res; bool f;
    while (!isdigit(ch = getchar()) &amp;amp;&amp;amp; ch != &#39;-&#39;);   // 过滤所有不是数字和&amp;quot;-&amp;quot;的字符
    if (ch==&#39;-&#39;)
        f = false, res = 0;
    else
        f = true, res = ch - &#39;0&#39;;                    // 判断正负性
    while (isdigit(ch = getchar()))
        res = res * 10 + ch - &#39;0&#39;;                   // 读取数字并计算
    return f ? res : -res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用-n-代替-endl&#34;&gt;使用 &lt;code&gt;\n&lt;/code&gt; 代替 &lt;code&gt;endl&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;有的时候，你会发现 &lt;code&gt;cout &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;&lt;/code&gt; 比 &lt;code&gt;cout &amp;lt;&amp;lt; endl;&lt;/code&gt; 要快。这是因为 &lt;code&gt;endl&lt;/code&gt; 会强制冲刷缓冲区，在缓冲区没满的时候多次冲刷会让效率变低。(
&lt;a href=&#34;https://stackoverflow.com/questions/213907/stdendl-vs-n&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;参考链接&lt;/a&gt; )&lt;/p&gt;
&lt;div class=&#34;alert alert-tip&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;什么是缓冲区?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;了解缓冲区设计的动机需要对计算机系统中的 memory hierarchy 有一定了解，这里尝试尽可能短和通俗地地解释清楚这个概念。&lt;/p&gt;
&lt;p&gt;假设你人在宿舍，要去图书馆借书。上午要去借A，下午要去借B，晚上去借C，于是你跑了三趟图书馆，这非常耗时。假设你是一个先知，上午就知道了自己要借 ABC 三本书，为了节省跑图书馆的时间，你在宿舍楼下放了一个书架，上午你一次性抱了三本书回来放在楼下的书架上，后面每次你需要书了就只需要下楼从书架上拿即可。还书也是相同的道理，你发现与其跑三趟，不如把要还的书先放在书架上，等手里所有的书都看完了再把书架上的书一起还到图书馆。&lt;/p&gt;
&lt;p&gt;这个例子里&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从图书馆借书/还书就是输入输出。相比较 &lt;code&gt;a[i]=b[j]&lt;/code&gt; &lt;code&gt;a++&lt;/code&gt; 这样的操作，执行一次输入输出是十分耗时的。&lt;/li&gt;
&lt;li&gt;书A/B/C是数据，或者说即将读入/准备输出的字符。&lt;/li&gt;
&lt;li&gt;书架是缓冲区。缓冲区就像一个大数组，暂存读入和输出数据。所谓的“冲刷缓冲区”就是将书架里的书全部还回图书馆/将缓冲区的数据真正输出。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，使用 &lt;code&gt;endl&lt;/code&gt; 就像每次往书架上放书时都强制把书架上所有的书放回图书馆，效率自然不高。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;使用-freadfwrite&#34;&gt;使用 &lt;code&gt;fread()&lt;/code&gt;/&lt;code&gt;fwrite()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;一般只有在读入/输出量极大的时候我们才会考虑使用 &lt;code&gt;fread()&lt;/code&gt;/&lt;code&gt;fwrite()&lt;/code&gt; 完成输入输出。如果延用之前借书的例子，&lt;code&gt;fread()&lt;/code&gt; 和 &lt;code&gt;fwrite()&lt;/code&gt; 相当于手动开辟一个巨大的书架，这个书架比 &lt;code&gt;scanf()&lt;/code&gt;/&lt;code&gt;cin&lt;/code&gt; 的书架大的多，从而显著减少了“把书从图书馆搬到书架”的次数。&lt;/p&gt;
&lt;p&gt;这里提供一份使用 fread/fwrite 的代码供参考。&lt;/p&gt;
&lt;details&gt;&lt;summary&gt;&lt;b&gt;fastio class&lt;/b&gt; &lt;i&gt;::click to expand&lt;/i&gt;&lt;/summary&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct fastio
{
    static const int S=1e7;
    char rbuf[S+48],wbuf[S+48];int rpos,wpos,len;
    fastio() {rpos=len=wpos=0;}
    inline char Getchar()
    {
        if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin);
        if (!len) return EOF;
        return rbuf[rpos++];
    }
    template &amp;lt;class T&amp;gt; inline void Get(T &amp;amp;x)
    {
        char ch;bool f;T res;
        while (!isdigit(ch=Getchar()) &amp;amp;&amp;amp; ch!=&#39;-&#39;) {}
        if (ch==&#39;-&#39;) f=false,res=0; else f=true,res=ch-&#39;0&#39;;
        while (isdigit(ch=Getchar())) res=res*10+ch-&#39;0&#39;;
        x=(f?res:-res);
    }
    inline void getstring(char *s)
    {
        char ch;
        while ((ch=Getchar())&amp;lt;=32) {}
        for (;ch&amp;gt;32;ch=Getchar()) *s++=ch;
        *s=&#39;\0&#39;;
    }
    inline void flush() {fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;}
    inline void Writechar(char ch)
    {
        if (wpos==S) flush();
        wbuf[wpos++]=ch;
    }
    template &amp;lt;class T&amp;gt; inline void Print(T x,char ch)
    {
        char s[20];int pt=0;
        if (x==0) s[++pt]=&#39;0&#39;;
        else
        {
            if (x&amp;lt;0) Writechar(&#39;-&#39;),x=-x;
            while (x) s[++pt]=&#39;0&#39;+x%10,x/=10;
        }
        while (pt) Writechar(s[pt--]);
        Writechar(ch);
    }
    inline void printstring(char *s)
    {
        int pt=1;
        while (s[pt]!=&#39;\0&#39;) Writechar(s[pt++]);
    }
}io;
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;br&gt;
&lt;p&gt;需要注意： 因为 &lt;code&gt;fread()&lt;/code&gt; 和 &lt;code&gt;fwrite()&lt;/code&gt; 开辟了大数组作为缓冲区一次性搬入很多数据，所以 &lt;code&gt;fread()&lt;/code&gt;/&lt;code&gt;fwrite()&lt;/code&gt; 不能和其他使用自带 buffer 的IO方法混用。换句话说，你只能从通过操作自定义的缓冲区的方式来输入输出。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Differential Testing</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/coding/difftest/</link>
      <pubDate>Tue, 28 Mar 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/coding/difftest/</guid>
      <description>&lt;p&gt;如何论证你写的程序是正确的？这是一个历史悠久且难以回答的问题。通常来说有两种思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Verification: 形式化验证简单来说是通过数学手段证明你的程序的行为符合预期。这是对程序正确性的强而有力的证明，但通常非常困难、局限性很大、scalability 较差，因此更多用于对于安全/可靠性要求非常严苛的场景，如自动驾驶，火星车等。问题求解一中提到的“通过 loop invariant 证明循环正确性”可以认为是 verification 的一种非常简单的形式。由于 verificaton 需要大量的程序语言(PL)/形式化方法(FM)的背景知识，且对于简单算法问题来说颇有大材小用之嫌，故在这里不作赘述。&lt;/li&gt;
&lt;li&gt;Testing: 测试是更加常用的检查程序是否有漏洞的方法，其核心思想是构造大量的输入并检查目标程序在这些输入上的输出是否符合预期。测试有着天然的局限性：它只能证明你的程序有 bug，但无法证明你的程序没有 bug (OJ 的本质也是测试，因此在 OJ 上通过的程序并不一定是对的 &lt;del&gt;而且由于助教太懒数据太水很可能确实是错的&lt;/del&gt;)。不过我们总可以认为，如果我们构造的输入足够多且足够丰富，那么通过了所有测试的程序的可靠性相对会很高。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里我们介绍一种简单易行的测试技术：differential testing (如果你曾经参加过算法竞赛，“对拍”的本质就是 DiffTest)。DiffTest 的核心思想是针对同一个问题完成两份不同的实现，然后构造大量的输入喂给两份实现观察它们的输出是否相同 (就像你每天早晨和同桌对作业答案，虽然你们都不能保证自己做的是对的，但做错且错得一样的概率毕竟很小，如果你们的解题思路不一样就更小了)。为了避免过于空洞，我们以“计算Fibonacci第n项”这个问题为例说明如何在 OJ 算法题上进行 DiffTest。&lt;/p&gt;
&lt;p&gt;假设你已经写好了一个使用矩阵快速幂优化 Fibonacci 计算的程序 &lt;code&gt;fib.cpp&lt;/code&gt;，现在希望对其进行测试。我们很容易写一个朴素版的 &lt;code&gt;fib_bruteforce.cpp&lt;/code&gt; 来实现同样的功能 (虽然它能处理的 $n$ 规模较小)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

const int MOD = 998244353;

int main ()
{
    int n, f0 = 0, f1 = 1, f2;
    cin &amp;gt;&amp;gt; n;
    for (int i = 2; i &amp;lt;= n; i++)
    {
        f2 = (f0 + f1) % MOD;
        f0 = f1; f1 = f2;
    }
    printf(&amp;quot;%d\n&amp;quot;, f2);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据我们的预期，对于任意 $n$，如果 &lt;code&gt;fib.cpp&lt;/code&gt; 和 &lt;code&gt;fib_bruteforce.cpp&lt;/code&gt; 都给出了答案，那么答案应该是相同的。这个问题的好处在于测试数据形式非常简单：只有一个数。因此我们很容易写出一个数据生成程序 &lt;code&gt;gen_data.cpp&lt;/code&gt; (注意我们的朴素版本无法处理过大的 $n$)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int main ()
{
    int limit = 10000000;
    mt19937 mt(time(nullptr));

    cout &amp;lt;&amp;lt; mt() % limit + 1 &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;mt19937&lt;/code&gt; class 是一个非常高效的伪随机数生成器。你也可以使用 &lt;code&gt;rand()&lt;/code&gt; 等其他函数来生成随机数 (注意设置随机种子，否则可能每次生成的随机数都一样)。&lt;/p&gt;
&lt;p&gt;有了两份实现和一个数据生成器，接下来的任务就是写一个脚本来做如下循环：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;while True
{
    DataGenerator &amp;gt;&amp;gt; data
    data &amp;gt;&amp;gt; Program1 &amp;gt;&amp;gt; output1
    data &amp;gt;&amp;gt; Program2 &amp;gt;&amp;gt; output2
    compare output1 and output2
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你会在 Windows 下写 Batch/Powershell 脚本，你应该可以给出一个上述伪代码的轻巧实现；如果你使用类 Unix 系统，你大概率也可以给出一个 bash 脚本。如果你啥也不会，可以考虑使用下面给出的这份 Python 程序进行测试。&lt;/p&gt;
&lt;details&gt;&lt;summary&gt;一份 Difftest Python 实现 &lt;i&gt;[Click to expand]&lt;/i&gt;&lt;/summary&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
usage: difftest.py [-h] --impl IMPL IMPL --gen GEN [--num NUM] [--time TIME]

optional arguments:
  -h, --help        show this help message and exit
  --impl IMPL IMPL  two source code files
  --gen GEN         data generator, cpp or python
  --num NUM         number of tests
  --time TIME       time limit for each test, in seconds
&amp;quot;&amp;quot;&amp;quot;

import os, subprocess
import atexit

objs = []

def compile(*progs):
    for prog in progs:
        assert os.path.exists(prog), f&amp;quot;{prog} not exist&amp;quot;
        if prog.endswith(&amp;quot;.cpp&amp;quot;):
            obj = f&amp;quot;obj-{prog}&amp;quot;
            objs.append(obj)
            p = subprocess.run(f&amp;quot;g++ -o {obj} {prog} -O2&amp;quot;, shell=True)
            assert p.returncode == 0, f&amp;quot;{prog} failed to be compiled, make sure that g++ is in your enviroment path&amp;quot;
    
def destructor():
    for obj in objs:
        if os.path.exists(obj):
            os.remove(obj)

def run(prog: str, tl: float, data: str):
    cmd = f&amp;quot;./obj-{prog}&amp;quot; if prog.endswith(&amp;quot;.cpp&amp;quot;) else f&amp;quot;python3 {prog}&amp;quot;
    p = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
    try:
        stdout, _ = p.communicate(input=data.encode(), timeout=tl)
    except subprocess.TimeoutExpired:
        p.kill()
        raise Exception(f&amp;quot;{prog} exceed {tl}s time limit&amp;quot;)
    return stdout.decode()

def dump(data, o1, o2):
    with open(&amp;quot;input&amp;quot;, &amp;quot;w&amp;quot;) as f: f.write(data)
    with open(&amp;quot;output1&amp;quot;, &amp;quot;w&amp;quot;) as f: f.write(o1)
    with open(&amp;quot;output2&amp;quot;, &amp;quot;w&amp;quot;) as f: f.write(o2)

def cmp(data, o1, o2):
    t1, t2 = o1.strip().split(&amp;quot;\n&amp;quot;), o2.strip().split(&amp;quot;\n&amp;quot;)
    if len(t1) != len(t2):
        dump(data, o1, o2)
        return False
    for line1, line2 in zip(t1, t2):
        if line1.strip() != line2.strip():
            dump(data, o1, o2)
            return False
    return True

if __name__ == &amp;quot;__main__&amp;quot;:
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument(&amp;quot;--impl&amp;quot;, nargs=2, required=True, help=&amp;quot;two source code files&amp;quot;)
    parser.add_argument(&amp;quot;--gen&amp;quot;, type=str, required=True, help=&amp;quot;data generator, cpp or python&amp;quot;)
    parser.add_argument(&amp;quot;--num&amp;quot;, type=int, default=100, help=&amp;quot;number of tests&amp;quot;)
    parser.add_argument(&amp;quot;--time&amp;quot;, type=float, default=5.0, help=&amp;quot;time limit for each test, in seconds&amp;quot;)
    args = parser.parse_args()

    atexit.register(destructor)

    compile(args.impl[0], args.impl[1], args.gen)

    for i in range(args.num):
        data = run(args.gen, args.time, &amp;quot;&amp;quot;)
        res1 = run(args.impl[0], args.time, data)
        res2 = run(args.impl[1], args.time, data)
        assert cmp(data, res1, res2), &amp;quot;Wrong answer, input/output files dumped&amp;quot;
        print(f&amp;quot;Test {i+1} OK!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;hr&gt;
&lt;p&gt;DiffTest 显然比自己出数据，运行程序，再手动验证结果要高效得多。用正确的工具和方法做事能让你事半功倍。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>优雅地取模</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/coding/modulation/</link>
      <pubDate>Wed, 22 Mar 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/coding/modulation/</guid>
      <description>&lt;p&gt;不少同学被OJ的取模问题折磨得心力憔悴——不论多么仔细地检查每一处四则运算，总会有一处漏网之鱼让程序输出错误的结果。这里我们展示一种比较优雅的代码书写方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;const int MOD = 998244353;

int add(int x, int y) { x += y; if (x &amp;gt;= MOD) x -= MOD; return x;}
int sub(int x, int y) { x -= y; if (x &amp;lt; 0) x += MOD; return x; }
int mul(int x, int y) { return 1ll * x * y % MOD; }
void Add(int &amp;amp;x, int y) { x = add(x, y); }
void Sub(int &amp;amp;x, int y) { x = sub(x, y); }
void Mul(int &amp;amp;x, int y) { x = mul(x, y); }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我们定义了 &lt;code&gt;MOD&lt;/code&gt; 这个变量以及 6 个函数统一完成加法、减法和乘法的取模操作。这样后续程序中的任何运算都可以调用这几个函数来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;c = sub(a, b);  // instead of c = (a - b) % MOD;
Add(c, d);      // instead of c += d %= MOD;
Mul(a_very_very_long_variable_name, c); 
  // instead of a_very_very_long_variable_name = 1ll * a_very_very_long_variable_name * c % MOD;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用统一的取模函数和 &lt;code&gt;MOD&lt;/code&gt; 变量有包括但不限于以下好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正确性: 你只需要仔细地书写这几个取模函数，后面的程序中你只要保证不出现 &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt;，就不会发生“漏了取模”的悲剧。&lt;/li&gt;
&lt;li&gt;简洁性: 在上述的的第三个例子中可以看出使用取模函数可以避免重复书写长变量名，使代码更加简洁。&lt;/li&gt;
&lt;li&gt;可维护性: 假设某一天我们通知需要将模数紧急换成 &lt;code&gt;1000000007&lt;/code&gt;，相比较将程序中散落在各处的 &lt;code&gt;998244353&lt;/code&gt; 修改掉，如果你定义了 &lt;code&gt;MOD&lt;/code&gt; 变量，你只需要修改一处。&lt;/li&gt;
&lt;li&gt;性能: 你也许注意到了我们在加法和减法中使用了 “if 判断 + 加减”的方式代替了取模，你可以证明只要传入的参数在 &lt;code&gt;[0, MOD)&lt;/code&gt; 范围内，该写法的正确性的可以保证的。在计算机底层实现中，进行一次取模操作的代价显著高于简单判断和加减，这样的写法有助于提升效率 (有时候这种提升是惊人的！)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们承认取模这件事情在工程开发中可能并不常见，但这样的程序设计却体现了软件工程的通用思想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;将需要频繁使用的常量定义成宏/constexpr&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将容易出错的功能单独封装成函数，之后调用接口解决问题&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;alert alert-tip&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;程序设计优化是一件&lt;b&gt;“绝知此事要躬行”&lt;/b&gt;的事情。阅读一遍这篇文章大抵不会对你的思想产生重大的影响：你也许会认为这些是多此一举，或者你对自己写代码时的仔细程度非常自信。你只有经历了现实的捶打，经历了熬夜通宵的折磨，才会深刻地意识到人类永远无法克服基因决定的共同弱点，才会理解这些文字背后是前人的智慧和血的教训。&lt;/p&gt;
&lt;p&gt;笔者在高中时曾参加一项极其重要的编程比赛。他针对一道难题推导出了一个极其复杂的数学公式并编码实现了它，但在比赛结束前的 5 分钟他发现自己的程序处处漏了取模——他永远不会忘记在手指被汗水浸湿以至于键盘打滑的情况下狂按 ctrl+F, ctrl+C, ctrl+V 是怎样的紧张和绝望，也不会忘记最终也没有把取模问题解决完，因为这样一个小细节与自己想要的结果失之交臂的痛苦。从那之后，他再也没有犯过低级的漏取模错误。&lt;/p&gt;
&lt;p&gt;我不期望你看完这段话就真的能听进去 (因为这也是人类刻在基因里的弱点之一)，但我衷心希望你为之付出的代价能比我小一些。&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>矩阵快速幂</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/coding/matmul/</link>
      <pubDate>Wed, 22 Mar 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/coding/matmul/</guid>
      <description>&lt;p&gt;按照线性代数中的矩阵乘法规则，常见的矩阵乘法写法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;for (int i = 1; i &amp;lt;= n; i++)
    for (int j = 1; j &amp;lt;= n; j++)
        for (int k = 1; k &amp;lt;= n; k++)
            c[i][j] += a[i][k] * b[k][j]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是我们强烈建议你调整循环的顺序，按照如下方式书写矩阵乘法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;for (int i = 1; i &amp;lt;= n; i++)
    for (int k = 1; k &amp;lt;= n; k++)
        for (int j = 1; j &amp;lt;= n; j++)
            c[i][j] += a[i][k] * b[k][j]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然这样有点“反直觉”，但在稍大规模的数据下运行时，你会发现这种写法的效率比前者高很多。理解效率提高的原因需要对计算机体系结构和 C/C++ 语言中数组在内存中的存储有一定的了解，这里不作赘述。你可以暂且将其背下来 😂&lt;/p&gt;
&lt;p&gt;为了更优雅地实现矩阵快速幂，我们还强烈建议你学习 C++ Class 相关的内容并了解操作符重载。这样你可以自己定义矩阵类并为矩阵类书写乘法规则，从而直接复用“快速幂”一讲中的代码计算矩阵快速幂。下面给出一个参考实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Matrix
{
    int b[10][10];
    Matrix () { memset(b, 0, sizeof(b)); }
    void init_I() { for (int i = 1; i &amp;lt;= n; i++) b[i][i] = 1; }
    Matrix operator * (Matrix other)
    {
        Matrix res;
        for (int i = 1; i &amp;lt;= n; i++)
            for (int k = 1; k &amp;lt;= n; k++)
                for (int j = 1; j &amp;lt;= n; j++)
                    res.b[i][j] += b[i][k] * other.b[k][j];
        return res;
    }
};

Matrix quick_pow(Matrix x, int y)
{
    T res; res.init_I();
    while (y)
    {
        if (y &amp;amp; 1) res = res * x;
        x = x * x; y &amp;gt;&amp;gt;= 1;
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
