<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 | Yuyao Wang&#39;s Homepage</title>
    <link>https://kristoff-starling.github.io/courses/problemsolving22/algorithms/</link>
      <atom:link href="https://kristoff-starling.github.io/courses/problemsolving22/algorithms/index.xml" rel="self" type="application/rss+xml" />
    <description>算法</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sat, 08 Apr 2023 00:00:00 +0000</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>算法</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/algorithms/</link>
    </image>
    
    <item>
      <title>分块——优雅的暴力</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/algorithms/chunking/</link>
      <pubDate>Sat, 08 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/algorithms/chunking/</guid>
      <description>&lt;p&gt;分块的思想被应用在生活的方方面面：举一个最简单的例子，大家上小学的时候通常班级里的座位被分成若干个“组”。每组有一个小组长 (传说中的“一道杠”)，班里有班干部 (传说中的“二道杠&amp;quot;)。班长在统计人数的时候，最便捷的方法就是让各个小组长统计自己组内的人数，汇总到班长手中再做一次简单加法。&lt;/p&gt;
&lt;p&gt;在算法设计中，分块的思想也常常被使用。空说无益，我们通过一个比 OJ 练习题更复杂的问题来解释分块思想的运用：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定数列 $a_1, \cdots, a_n$，高效实现 $q$ 次以下两种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 l r x&lt;/code&gt;：给区间 $[l, r]$ 中的数统一加上 $x$。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2 l r&lt;/code&gt;：查询 $\sum_{k=l}^r a_k$ 的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;暴力修改和统计有着相同的问题：如果给定的区间很长，那么操作执行就相当缓慢。总时间复杂度可以达到 $O(qn)$。&lt;/p&gt;
&lt;p&gt;我们来考虑如下的一种分块策略：将数列分成若干个长度为 $m$ 的小段 (第一段是 $[0,m)$，第二段是 $[m, 2m)$，依次类推，我们假设 $n$ 可以被 $m$ 整除)，命名为 $B_1, B_2, \cdots, B_b$。我们为每个块分配一个累加标记 $t_i$，表示这个块上的数被&lt;strong&gt;整体&lt;/strong&gt;加了多少，再维护一个和标记 $s_i$，表示在不考虑累加标记的情况下块内的数的和。那么&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于给 $[l, r]$ 上的数加 $x$ 这件事，我们可以把 $[l,r]$ 这个大区间拆分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$[l, l_1]$，开头的一段，是某个块的后缀&lt;/li&gt;
&lt;li&gt;$[l_1+1, r_1]$，这一段正好对应若干个完整的块。&lt;/li&gt;
&lt;li&gt;$[r_1+1, r]$，结尾的零碎一段，是某个块的前缀。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
对于 $[l, l_1]$ 和 $[r_1, r]$，我们一个一个地给每个数 +x (别忘了同步更新该块对应的 $s_i$)。对于中间的若干个完整的块，我们直接把 +x 标记打在对应的 $t_i$ 上 (即 &#34;ti += x&#34;)。
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;对于求 $\sum_{k=1}^ra_k$，我们仍然可以把区间拆成上述的三个部分。对于开头和结尾的零碎区间，我们一个一个地累加，对于中间的若干个完整的块，我们发现一个块的实际的和可以通过如下方式算出：
$$
sum_i = s_i + t_i * m
$$
将中间完整块的 $sum_i$ 累加起来即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了更清楚地说明上述思想，我们给出修改和查询操作的简单伪代码：&lt;/p&gt;
&lt;details&gt;&lt;summary&gt;Pseudocode :: Click to expand&lt;/summary&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void modify(int l, int r, int x)
{
    decompose [l, r] into [l, l1], [l1, r1] and [r1, r]
    suppose [l1, r1] = Bp, Bp+1, ..., Bq
    // 开头零碎段
    for (int i = l; i &amp;lt;= l1; i++)
    {
        a[i] += x;
        s[p-1] += x;
    }
    // 中间完整段
    for (int i = p; i &amp;lt;= q; i++)
        t[i] += x;
    // 结尾零碎段
    for (int i = r1 + 1; i &amp;lt;= r; i++)
    {
        a[i] += x;
        s[q+1] += x;
    }
}

int query(int l, int r)
{
    decompose [l, r] into [l, l1], [l1, r1] and [r1, r]
    suppose [l1, r1] = Bp, Bi+1, ..., Bq

    int sum = 0;
    // 开头零碎段
    for (int i = l; i &amp;lt;= l1; i++)
        sum += a[i];
    // 中间完整段 
    for (int i = p; i &amp;lt;= q; i++)
        sum += s[i] + t[i] * m;
    // 结尾零碎段 
    for (int i = r1 + 1; i &amp;lt;= r; i++)
        sum += a[i];
    
    return sum
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;
&lt;br&gt;
&lt;p&gt;接下来我们考虑这个块的长度应当如何设计。我们容易发现块如果太大，那么一个修改/查询区间首尾的零碎部分就可能太长；如果块太小，那么一个修改/查询区间就可能包含太多的块。具体的，在块大小为 $m$ 时，整个数列被划分成 $n/m$ 个块，那么在一次操作中，首尾的零碎部分的求和复杂度可以达到 $2m = O(m)$，累加区间中间包含的整块的信息的时间复杂度最多可以达到 $O(n/m)$ ，于是有
$$
\arg\min_m \left\{O(m), O(n/m)\right\} \Longrightarrow m=\sqrt n
$$
所以，将块的大小定义在 $\sqrt n$ 附近是最合理的选择，这也是分块思想通常被称为“根号暴力”的原因。可以算出，在我们的分块算法下，解决原问题的复杂度被降低到了 $O(q\sqrt n)$。&lt;/p&gt;
&lt;p&gt;数列上分块是分块思想最常见的应用，但分块的应用不仅停留在这种线性结构上。从抽象层面说，如果你发现你可以将某一些东西绑成一个整体，然后将某些操作统一在整体层面，那么便可以考虑分块。分块被称为是一种优雅的暴力，因为它没有复杂的数据结构设计，看上去就是一些加加减减，便举重若轻地解决了问题。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>快速幂</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/algorithms/repeatedsquare/</link>
      <pubDate>Sat, 18 Mar 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/algorithms/repeatedsquare/</guid>
      <description>&lt;p&gt;给定 $a,n$，考虑如何计算 $a^n$ 。如果使用如下循环计算结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int res = 1;
for (int i = 1; i &amp;lt;= n; i++)
    res = res * a;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;时间复杂度为 $O(n)$，当 $n$ 很大时效率太低。快速幂是用于计算该类问题的常见算法，其本质思想是递归/倍增:&lt;/p&gt;
&lt;p&gt;$$
a^n=\begin{cases}1&amp;amp;,n=0\\(a^{n/2})^2&amp;amp;,n是偶数, n\geq 1\\(a^{\lfloor n/2\rfloor})^2\cdot a&amp;amp;,n是奇数, n\geq 1\end{cases}
$$&lt;/p&gt;
&lt;p&gt;因此我们可以通过不断折半幂次的方式来求解 $a^n$。写出该算法的复杂度递归表达式：&lt;/p&gt;
&lt;p&gt;$$
T(n)=T(n/2)+O(1)
$$&lt;/p&gt;
&lt;p&gt;容易得出 $T(n)=O(\log n)$。&lt;/p&gt;
&lt;p&gt;直接根据递归式，我们容易写出如下递归代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int quick_pow(int a, int n)
{
    if (n == 0) return 1;
    res = quick_pow(a, n / 2);
    if (n % 2 == 0)
        return res * res;
    else
        return res * res * a;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但我们通常使用一种更加优美的写法来使用循环替代递归：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int quick_pow(int a, int n)
{
    int res = 1;
    while (n)
    {
        if (n &amp;amp; 1) res = res * a;
        a = a * a; n &amp;gt;&amp;gt;= 1;
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该实现的核心思想是利用 $n$ 的二进制表示中 1 的位置来判断 $a^n$ 是由哪些 $a^{2^k}$ 组合而成的。即如果 $n$ 的二进制表示中在 $k_1,k_2,\cdots, k_m$ 这些位置上是 1，那么&lt;/p&gt;
&lt;p&gt;$$
a^n=a^{\sum_{i=1}^m2^{k_i}}=\prod_{i=1}^ma^{2^{k_i}}
$$&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>矩阵快速幂</title>
      <link>https://kristoff-starling.github.io/courses/problemsolving22/algorithms/matmul/</link>
      <pubDate>Sat, 18 Mar 2023 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/courses/problemsolving22/algorithms/matmul/</guid>
      <description>&lt;p&gt;关于基础理论，参见
&lt;a href=&#34;https://kristoff-starling.github.io/posts/recurrences/&#34;&gt;这篇博文&lt;/a&gt;。如果你之前从未了解过线性递推相关的知识/目前以完成OJ为主要目标，只需看懂该文章的 Getting Started 章节。本文主要对矩阵乘法和矩阵快速幂的实现给出一点建议。&lt;/p&gt;
&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Don&amp;rsquo;t Panic!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只有 &lt;code&gt;Problem Solving&lt;/code&gt; 目录下的内容才是大家需要且应当掌握的内容。链接中博文的大部分内容与问题求解课程并不相关，且我不认为掌握这些数学强相关的知识对计算机思维有太多提升。因此如果你不愿意读 Getting Started 之后的内容/读不懂后面的内容，这非常正常也无关紧要！&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;你可以参考
&lt;a href=&#34;https://kristoff-starling.github.io/courses/problemsolving22/coding/matmul&#34;&gt;这篇博文&lt;/a&gt; 来学习矩阵快速幂实现的代码细节。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
