<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Volume 1: Logical Foundations | Academic</title>
    <link>https://kristoff-starling.github.io/posts/booknotes/softwarefoundations/lf/</link>
      <atom:link href="https://kristoff-starling.github.io/posts/booknotes/softwarefoundations/lf/index.xml" rel="self" type="application/rss+xml" />
    <description>Volume 1: Logical Foundations</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>Volume 1: Logical Foundations</title>
      <link>https://kristoff-starling.github.io/posts/booknotes/softwarefoundations/lf/</link>
    </image>
    
    <item>
      <title>Functional Programming in Coq</title>
      <link>https://kristoff-starling.github.io/posts/booknotes/softwarefoundations/lf/basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/posts/booknotes/softwarefoundations/lf/basics/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#data-and-functions&#34;&gt;Data and Functions&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#enumerated-types&#34;&gt;Enumerated Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#days-of-the-week&#34;&gt;Days of the Week&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#booleans&#34;&gt;Booleans&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#types&#34;&gt;Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#new-types-from-old&#34;&gt;New Types from Old&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#module&#34;&gt;Module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#tuples&#34;&gt;Tuples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#numbers&#34;&gt;Numbers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#proof-by-simplification&#34;&gt;Proof by Simplification&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#proof-by-rewriting&#34;&gt;Proof by Rewriting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#proof-by-case-analysis&#34;&gt;Proof by Case Analysis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#fixpoints-and-structural-recursion-optional&#34;&gt;Fixpoints and Structural Recursion (Optional)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercises&#34;&gt;Exercises&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-1-star-standard-nandb&#34;&gt;Exercise: 1 star, standard (nandb)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-1-star-standard-andb3&#34;&gt;Exercise: 1 star, standard (andb3)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-1-star-standard-factorial&#34;&gt;Exercise: 1 star, standard (factorial)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-1-star-standard-ltb&#34;&gt;Exercise: 1 star, standard (ltb)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-1-star-standard-plus_id_exercise&#34;&gt;Exercise: 1 star, standard (plus_id_exercise)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-1-star-standard-mult_n_1&#34;&gt;Exercise: 1 star, standard (mult_n_1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-2-stars-standard-andb_true_elim2&#34;&gt;Exercise: 2 stars, standard (andb_true_elim2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-1-star-standard-zero_nbeq_plus_1&#34;&gt;Exercise: 1 star, standard (zero_nbeq_plus_1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-2-stars-standard-optional-decreasing&#34;&gt;Exercise: 2 stars, standard, optional (decreasing)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-1-star-standard-identity_fn_applied_twice&#34;&gt;Exercise: 1 star, standard (identity_fn_applied_twice)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-1-star-standard-negation_fn_applied_twice&#34;&gt;Exercise: 1 star, standard (negation_fn_applied_twice)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-3-stars-standard-optional-andb_eq_orb&#34;&gt;Exercise: 3 stars, standard, optional (andb_eq_orb)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-3-stars-standard-binary&#34;&gt;Exercise: 3 stars, standard (binary)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;函数式编程 (functional programming) 的思想来自于：如果一个过程或方法没有副作用，那么我们只关心它如何将输入映射到输出，即这个过程/方法是一个数学函数的具体实现。函数式编程的另一个想法是：所有的函数都应当被当作 first-classs value：函数可以作为参数，可以作为返回值，就像普通的数据一样。&lt;/p&gt;
&lt;h2 id=&#34;data-and-functions&#34;&gt;Data and Functions&lt;/h2&gt;
&lt;h3 id=&#34;enumerated-types&#34;&gt;Enumerated Types&lt;/h3&gt;
&lt;p&gt;Coq 的一个显著特点在于：它的内置 features 非常的少。例如除了一些最基本的类型 (如 boolean, integer, strings)，其他的类型都可以由用户自己通过基本类型来定义。&lt;/p&gt;
&lt;h3 id=&#34;days-of-the-week&#34;&gt;Days of the Week&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Inductive day : Type := 
  | monday
  | tuesday
  | wednesday
  | thursday
  | friday
  | saturday
  | sunday.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码定义了一个叫 &lt;code&gt;day&lt;/code&gt; 的数据类型，它的成员有 7 个。基于这个类型，我们可以书写一些函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition next_weekday (d : day) : day :=
  match d with
  | monday =&amp;gt; tuesday
  | tuesday =&amp;gt; wednesday
  | wednesday =&amp;gt; thursday
  | thursday =&amp;gt; friday
  | friday =&amp;gt; monday
  | saturday =&amp;gt; monday
  | sunday =&amp;gt; monday
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码显式地给出了函数参数和返回值的类型。事实上 Coq 支持 type inference，但为了阅读方便这里还是写上了。&lt;/p&gt;
&lt;p&gt;定义了函数之后，我们可以利用 &lt;code&gt;Compute&lt;/code&gt; 命令来计算一些使用了这个函数的表达式，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Compute (next_weekday friday).
(* ==&amp;gt; monday: day *)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们还可以通过 Coq Example 来给出一个 assertion：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Example test_next_weekday:
  (next_weekday (next_weekday saturday)) = tuesday.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样的一个 Example 是需要证明的。一个合法的证明如下 (tactic 的意义见后文)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Proof.
  simpl.
  reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;booleans&#34;&gt;Booleans&lt;/h3&gt;
&lt;p&gt;类似地我们可以定义 bool 类型，以及 negation, and, or 三个运算函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Inductive bool : Type :=
  | true
  | false.

Definition negb (b : bool) : bool :=
  match b with
  | true =&amp;gt; false
  | false =&amp;gt; true
  end.

Definition andb (b1 : bool) (b2 : bool) : bool :=
  match b1 with
  | true =&amp;gt; b2
  | false =&amp;gt; false
  end.

Definition orb (b1 : bool) (b2 : bool) : bool :=
  match b1 with
  | true =&amp;gt; true
  | false =&amp;gt; b2
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以使用 &lt;code&gt;Notation&lt;/code&gt; 命令来通过已有的 definitions 定义新符号：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Notation &amp;quot;x &amp;amp;&amp;amp; y&amp;quot; := (andb x y).
Notation &amp;quot;x || y&amp;quot; := (orb x y).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Coq 中我们也可以使用条件分支语句，下面是用条件分支语句描述 and, or, neg 的例子 ( if-then-else 的折行是比较随意的)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition negb&#39; (b : bool) : bool :=
  if b then false
  else true.

Definition andb&#39; (b1 : bool) (b2 : bool) : bool :=
  if b1 then b2 else false.

Definition orb&#39; (b1 : bool) (b2 : bool) : bool :=
  if b1 then 
    true
  else
    b2.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Coq 的条件分支语句比一般编程语言的语句的功能更 general 一些：对于只有两个 constructor 的类型，&lt;code&gt;if X&lt;/code&gt; 可以表示如果 X 等于第一个 constructor，这里只是因为 bool 类型的第一个 constructor 正好是 true 所以看上去和一般编程语言没有区别。&lt;/p&gt;
&lt;h3 id=&#34;types&#34;&gt;Types&lt;/h3&gt;
&lt;p&gt;Coq 中的每个表达式都有类型，我们可以使用 &lt;code&gt;Check&lt;/code&gt; 命令来打印一个表达式的类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Check true.
(* ==&amp;gt; true: bool *)
Check (negb true) : bool.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种写法相当于一个 assertion，如果类型正确 Coq 不会有反应，如果错误 Coq 会报错。&lt;/p&gt;
&lt;p&gt;在 Coq 中，函数也是有类型的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Check negb : bool -&amp;gt; bool.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;new-types-from-old&#34;&gt;New Types from Old&lt;/h3&gt;
&lt;p&gt;我们之前定义的类型都是 enumerated types，即这些定义显式地列举了一个有穷的元素集合，这些元素被称为 constructor。下面的一个更复杂的例子中出现了 constructor 带有参数的用法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Inductive rgb : Type :=
  | red
  | blue
  | green.
Inductive color : Type :=
  | black
  | white
  | primary (p : rgb).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我们引出 constructor expression 的概念：constructor expression 指的是以符合定义的方式将一个 constructor apply 到零个或多个 constructor expression 上。这里的 red, blue, black, white, primary red 等都是 constructor expression。&lt;/p&gt;
&lt;p&gt;这里 color 类型描述了属于 color 这个集合的 constructor expression 的三种形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;black&lt;/li&gt;
&lt;li&gt;white&lt;/li&gt;
&lt;li&gt;如果 p 是一个属于 rgb 的 constructor expression，那么 primary p 就是属于 color 的 constructor expression。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们仍然可以用 pattern matching 的方式来定义函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition isred (c : color) : bool :=
  match c with
  | black =&amp;gt; false
  | white =&amp;gt; false
  | pattern red =&amp;gt; true
  | pattern _ =&amp;gt; false
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里出现了一个新用法：wildcard pattern &lt;code&gt;_&lt;/code&gt; 是通配符，在这里可以匹配所有不是 red 的其他情形。&lt;/p&gt;
&lt;h3 id=&#34;module&#34;&gt;Module&lt;/h3&gt;
&lt;p&gt;Coq 提供一套 module system：如果我们将一个定义 &lt;code&gt;foo&lt;/code&gt; 包含在了 &lt;code&gt;Module X&lt;/code&gt; 和 &lt;code&gt;End X&lt;/code&gt; 之间，那么在模块外我们想要使用 &lt;code&gt;foo&lt;/code&gt; 时就要写成 &lt;code&gt;X.foo&lt;/code&gt; 而不是直接 &lt;code&gt;foo&lt;/code&gt;。module system 让我们可以不用太担心名字重复的问题。&lt;/p&gt;
&lt;h3 id=&#34;tuples&#34;&gt;Tuples&lt;/h3&gt;
&lt;p&gt;一个拥有多个参数的 constructor 可以用来表示 tuple，下面的例子展示了一个 nybble (half byte) 类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Inductive bit : Type :=
  | B0
  | B1

Inductive nybble: Type :=
  | bits (b0, b1, b2, b3 : bit).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样地我们可以使用 pattern matching 的方式书写函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition all_zero (nb : nybble) : bool :=	
  match nb with:
  | (bits B0 B0 B0 B0) =&amp;gt; true
  | (bits _ _ _ _	) =&amp;gt; false
  end.
  
Compute (all_zero(bits B1 B0 B1 B0))
(* ===&amp;gt; false : bool *)
Compute (all_zero(bits B0 B0 B0 B0))
(* ===&amp;gt; true : bool *)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;numbers&#34;&gt;Numbers&lt;/h3&gt;
&lt;p&gt;之前我们定义的 type 都是有穷集合，而自然数集是一个无穷集合，因此我们在这里使用归纳的方法，根据自然数在朴素集合论中的定义方式给出自然数的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Inductive nat : Type :=
  | O
  | S (n : nat).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该定义的意思是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;O&lt;/code&gt; 是一个属于 nat 集合的 constructor expression。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;n&lt;/code&gt; 是一个属于 nat 集合的 constructor expression，那么 &lt;code&gt;S n&lt;/code&gt; 也属于 nat 集合。&lt;/li&gt;
&lt;li&gt;除了以上两条，没有别的 constructor expression 在 nat 集合中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;值得注意的是：这里的 &lt;code&gt;O&lt;/code&gt; 和 &lt;code&gt;S&lt;/code&gt; 没有任何实际的含义，我们可以用任意别的字符/单词来替换它们。&lt;/p&gt;
&lt;p&gt;下面展示两个函数：&lt;code&gt;pred&lt;/code&gt; 和 &lt;code&gt;minustwo&lt;/code&gt;，值得学习的是其中 pattern matching 的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition pred (n : nat) : nat :=
  match n with:
  | O =&amp;gt; O
  | S n&#39; =&amp;gt; n&#39;
  end.

Definition minustwo (n : nat) : nat :=
  match n with:
  | O =&amp;gt; O
  | S O =&amp;gt; O
  | S (S n&#39;) =&amp;gt; n&#39;
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于自然数是一种非常普遍的数据类型，所以 Coq 内置了一些解析和打印自然数的小魔法：&lt;code&gt;O&lt;/code&gt; 会被输出为 0，&lt;code&gt;S O&lt;/code&gt; 会被输出为 1，依次类推。此外我们给函数传递参数的时候也可以直接使用阿拉伯数字而不是形式化的 &lt;code&gt;S ... S O&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Compute (minustwo 4).
(* ===&amp;gt; 2 : nat *)
Check (S (S (S (S O)))).
(* ===&amp;gt; 4 : nat *)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在定义自然数时使用的 constructor S 和函数 &lt;code&gt;pred&lt;/code&gt; &lt;code&gt;minustwo&lt;/code&gt; 在类型上是一样的，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Check S : nat -&amp;gt; nat.
Check pred : nat -&amp;gt; nat.
Check minustwo : nat -&amp;gt; nat.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但 &lt;code&gt;S&lt;/code&gt; 和其他两者有着本质的区别：&lt;code&gt;pred&lt;/code&gt; 和 &lt;code&gt;minustwo&lt;/code&gt; 是通过计算规则的方式定义的，例如 &lt;code&gt;pred 4&lt;/code&gt; 和 3 没有本质区别；但 &lt;code&gt;S&lt;/code&gt; 只是一个表示数的方式，正如十进制用 0~9 这 10 个字符表示数字一样，在我们的归纳系统中我们使用 S 和 O 这两个字符表示数字，S 本身不包含任何的计算功能。&lt;/p&gt;
&lt;p&gt;接下来我们考虑一些更加复杂的关于 number 的函数。例如判断一个数是否是偶数：对于这个问题我们无法通过 pattern matching 的方法直接给出答案，因为偶数有无穷多个。我们只能使用递归的方式：首先规定 O 是偶数，然后对于整数 n 不断 -2 来判断奇偶性。这类需要使用递归的函数应当使用 &lt;code&gt;Fixpoint&lt;/code&gt; 而不是 &lt;code&gt;Definition&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint even (n : nat) : bool :=
  match n with
  | O =&amp;gt; true
  | S O =&amp;gt; false
  | S (S n&#39;) =&amp;gt; even n&#39;
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面我们来定义加法，这是一个多参数的函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint plus (n : nat) (m : nat) : nat :=
  match n with
  | O =&amp;gt; m
  | S n&#39; =&amp;gt; S (plus n&#39; m)
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加法的归纳思路十分巧妙，将第一个加数的 S 施加到结果上，直到第一个加数为 0。下面是 Coq 计算 &lt;code&gt;plus 2 3&lt;/code&gt; 的化简流程：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;(*      [plus 3 2]
   i.e. [plus (S (S (S O))) (S (S O))]
    ==&amp;gt; [S (plus (S (S O)) (S (S O)))]
          by the second clause of the [match]
    ==&amp;gt; [S (S (plus (S O) (S (S O))))]
          by the second clause of the [match]
    ==&amp;gt; [S (S (S (plus O (S (S O)))))]
          by the second clause of the [match]
    ==&amp;gt; [S (S (S (S (S O))))]
          by the first clause of the [match]
   i.e. [5]  *)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数的多个参数如果类型一样也可以合并了写，例如下面的这个减法的例子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint minus (n m : nat) : nat :=
  match n, m with
  | O   , _ =&amp;gt; O
  | _   , O =&amp;gt; n
  | S n&#39;, S m&#39; =&amp;gt; minus n&#39;, m&#39;
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个减法的思路也十分巧妙：不断将被减数和减数同时减少，直到有一个是 0 为止。&lt;/p&gt;
&lt;p&gt;我们可以为加法、减法、乘法 (代码省略) 添加符号：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Notation &amp;quot;x + y&amp;quot; := (plus x y) (at level 50, left associativity) : nat_scope.
Notation &amp;quot;x - y&amp;quot; := (minus x y) (at level 50, left associativity) : nat_scope.
Notation &amp;quot;x * y&amp;quot; := (mult x y) (at level 40, left associativity) : nat_scope.
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;More about Notations&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里出现了三个新的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;level 后面可以跟一个 0~100 的数值，这个数值规定了该运算的优先级，数字越小优先级越大。上面的例子中 + 和 - 优先级相同，乘法优先级更高，因此 &lt;code&gt;a + b * c&lt;/code&gt; 等价于 &lt;code&gt;a + (b * c)&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;associativity 有 left, right, no 三种，描述了该符号的结合性。例如 + 是左结合的意味着 &lt;code&gt;a + b + c&lt;/code&gt; 等价于 &lt;code&gt;(a + b) + c&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个符号有其 notation scope。Coq 的解释器会根据上下文自动分析符号的作用域。比如在 &lt;code&gt;S(0x0)&lt;/code&gt; 中 &lt;code&gt;x&lt;/code&gt; 会被认定为 nat_scope，而在 &lt;code&gt;bool x bool&lt;/code&gt; 中 &lt;code&gt;x&lt;/code&gt; 就会被认定为 type_scope。有些情况下我们需要显式地帮助 Coq 解释器确定 scope，我们可以使用 &lt;code&gt;%&lt;/code&gt; 语法：例如 &lt;code&gt;(x+y)%nat&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;除了符号有 notation scope，数字也可以指定 scope，例如 &lt;code&gt;0%nat&lt;/code&gt; 和 &lt;code&gt;0%Z&lt;/code&gt; 一个是自然数 0，一个是整数 0，它们来自不同的标准库。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来再展示一个给两个数比大小的函数 (在 Coq 中，一切都得自己定义)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint leb (n m : nat) : bool :=
  match n with
  | O =&amp;gt; true
  | S n&#39; =&amp;gt;
      match m with
      | O =&amp;gt; false
      | S m&#39; =&amp;gt; leb n&#39; m&#39;
      end
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，我们也可以用像减法那样的语法，这里主要想展示的是 match 的嵌套使用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Notation &amp;quot;x =? y&amp;quot; := (eqb x y) (at level 70) : nat_scope.
Notation &amp;quot;x &amp;lt;=? y&amp;quot; := (leb x y) (at level 70) : nat_scope.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里区分一下 &lt;code&gt;=&lt;/code&gt; 和 &lt;code&gt;=?&lt;/code&gt; ：&lt;code&gt;x = y&lt;/code&gt; 是一个命题 (proposition)，给出这样一个 claim 是需要证明的；而 &lt;code&gt;x =? y&lt;/code&gt; 是一个表达式，可以直接计算出 true/false。&lt;/p&gt;
&lt;h2 id=&#34;proof-by-simplification&#34;&gt;Proof by Simplification&lt;/h2&gt;
&lt;p&gt;我们已经有了一系列定义和函数，接下来我们可以证明一些定理。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem plus_O_n: forall n : nat, 0 + n = n.
Proof.
  intros n.
  simpl. reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们对定理和证明中的一些元素做一点说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Coq 中，&lt;code&gt;Example&lt;/code&gt; &lt;code&gt;Theorem&lt;/code&gt; &lt;code&gt;Lemma&lt;/code&gt; &lt;code&gt;Fact&lt;/code&gt; &lt;code&gt;Remark&lt;/code&gt; 没有本质区别。&lt;/li&gt;
&lt;li&gt;在定理中我们使用了全称量词 &lt;code&gt;forall&lt;/code&gt;。联想人类在证明的时候，我们对于这类定理通常会写下“对于任意自然数n&amp;hellip;” 从而在接下来的证明中把 n 当作一个“具体”的数使用。在 Coq 中我们可以通过 &lt;code&gt;intros&lt;/code&gt; 来完成这一步骤。值得注意的是这里 &lt;code&gt;intros&lt;/code&gt; 后面其实可以使用任意符号，不一定要和命题中的 n 保持一致。&lt;/li&gt;
&lt;li&gt;在本证明以及上面的所有证明中，用于化简的 &lt;code&gt;simpl&lt;/code&gt; 其实都是不需要的，因为 &lt;code&gt;reflexivity&lt;/code&gt; 自带了化简功能，这里有意显式地写出 &lt;code&gt;simpl&lt;/code&gt; 是为了能更好地看到证明化简的中间过程。值得一提的是 &lt;code&gt;reflexivity&lt;/code&gt; 的化简功能比 &lt;code&gt;simpl&lt;/code&gt; 更强大：它还可以将复杂定义展开。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里的关键词 &lt;code&gt;intros&lt;/code&gt; &lt;code&gt;simpl&lt;/code&gt; &lt;code&gt;reflexivity&lt;/code&gt; 都是 tactic。tactic 指的是证明过程中用于推进证明过程，检验结果正确的一些命令。&lt;/p&gt;
&lt;h2 id=&#34;proof-by-rewriting&#34;&gt;Proof by Rewriting&lt;/h2&gt;
&lt;p&gt;下面的这个定理比之前的要更加复杂和有趣一些：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem plus_id_example : forall n m : nat,
  n = m -&amp;gt; 
  n + n = m + m
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个定理中出现了蕴含关系符。由于 n 和 m 都是任意整数，我们无法直接通过简单的化简来证明最后的等式。但我们注意到在 &lt;code&gt;n = m&lt;/code&gt; 的假设下我们可以将等式中的 n 都用 m 来代替。在 Coq 中 &lt;code&gt;rewrite&lt;/code&gt; 这个 tactic 负责进行这种替换。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Proof.
  intros n m.
  intros H.
  rewrite -&amp;gt; H.
  reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二行的 &lt;code&gt;intros H&lt;/code&gt; 表示我们将 &lt;code&gt;n = m&lt;/code&gt; 这条假设加入到上下文中，并给其命名为 H。第三条语句表示利用假设 H 将目标中的等式左侧的内容替换成等式右侧的内容。&lt;code&gt;rewrite&lt;/code&gt; 中的 &lt;code&gt;-&amp;gt;&lt;/code&gt; 表示用 RHS 替换 LHS，如果写成 &lt;code&gt;&amp;lt;-&lt;/code&gt; 则是用 LHS 替换 RHS。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Check&lt;/code&gt; 命令不仅可以检查类型，还可以打印一个定理的内容。下面两个定理是在标准库中证明过的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Check mult_n_O.
(* ===&amp;gt; forall n : nat, 0 = n * 0 *)
Check mult_n_Sm.
(* ===&amp;gt; forall n m : nat, n * m + n = n * S m *)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;rewrite&lt;/code&gt; tactic 除了可以利用命题中的假设等式进行替换，还可以利用已经证明的定理进行替换，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem mult_n_0_m_0 : forall p q : nat,
  (p * 0) + (q * 0) = 0.
Proof.
  intros p q.
  rewrite &amp;lt;- mult_n_O.
  rewrite &amp;lt;- mult_n_O.
  reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;证明中连续两次利用 &lt;code&gt;mult_n_O&lt;/code&gt; 定理进行替换，每次执行替换时 Coq 的解释器会自动在目标等式中寻找定理的 instance。&lt;/p&gt;
&lt;h2 id=&#34;proof-by-case-analysis&#34;&gt;Proof by Case Analysis&lt;/h2&gt;
&lt;p&gt;有的时候我们不得不分情况讨论。这里首先给出一个分情况讨论的证明过程的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem negb_involutive : forall b : bool,
  negb (negb b) = b.
Proof.
  intros b. destruct b eqn:E
  - reflexivity.
  - reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;命题中的 &lt;code&gt;b&lt;/code&gt; 由于是一个不确定的变量，无法直接化简，我们需要分情况讨论 &lt;code&gt;b = true&lt;/code&gt; 和 &lt;code&gt;b = false&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;destruct&lt;/code&gt; 这个 tactic 用于分类讨论，它可以针对所有 inductively 定义的数据类型使用。使用 &lt;code&gt;destruct&lt;/code&gt; 相当于分别将 b 看作它定义中的第一，第二……个 constructor，作出 assumption 并创建若干个 subgoal。这里对于 bool 类型相当于分别假设 &lt;code&gt;b = true&lt;/code&gt; 和 &lt;code&gt;b = false&lt;/code&gt;。作出假设后，&lt;code&gt;destruct&lt;/code&gt; 会顺手把假设的内容 &amp;ldquo;rewrite&amp;rdquo; 进去。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eqn:E&lt;/code&gt; 负责给做出的假设命名，之后可以通过 &lt;code&gt;E&lt;/code&gt; 来使用这个假设。这一步不是必要的，但这是一个好的习惯。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-&lt;/code&gt; 称为 bullet，负责划分各个 subgoal 的证明过程。bullet 不是必要的，如果省略，Coq 会将你的按照 subgoal 的顺序将你的证明过程一一代入。但使用 bullet 会使你的证明过程结构更清晰、更可读。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是一个稍复杂的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem plus_1_neq_0_firsttry : forall n : nat,
  (n + 1) =? 0 = false.
Proof.
  intros n.
  simpl. (* does nothing! *)
Abort.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们直接使用 &lt;code&gt;simpl&lt;/code&gt; 无法化简这个式子。这里值的注意的一点是：如果我们要证明的命题是 &lt;code&gt;(1 + n) =? 0 = false&lt;/code&gt;，那么 &lt;code&gt;simpl&lt;/code&gt; 就管用了，因为 &lt;code&gt;1 + n &lt;/code&gt; 会被计算成 &lt;code&gt;S n&lt;/code&gt;，&lt;code&gt;S n =? 0&lt;/code&gt; 可以直接判定为 false。这里无法计算是因为我们定义的加法是针对第一个参数进行递归的，而第一个参数是一个无法确定具体值的 &lt;code&gt;n&lt;/code&gt;，所以 &lt;code&gt;simpl&lt;/code&gt; 无法化简。&lt;/p&gt;
&lt;p&gt;我们分类讨论的策略是看 &lt;code&gt;n&lt;/code&gt; 是 &lt;code&gt;O&lt;/code&gt; 还是 &lt;code&gt;S n&#39;&lt;/code&gt;。这里给出证明过程：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem plus_1_neg_0 : forall n : nat,
  (n + 1) ?= 0 = false.
Proof.
  intros n. destruct n as [| n&#39;] eqn:E.
  - reflexivity.
  - reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里新出现了 &lt;code&gt;[| n&#39;]&lt;/code&gt;。和上一个例子不同，自然数的定义的第二个 constructor 是带参数的，因此我们要用一对中括号 &lt;code&gt;[]&lt;/code&gt; 给出每一个 constructor 的参数列表，不同 constructor 的参数列表之间用 &lt;code&gt;|&lt;/code&gt; 隔开 (自然数的第一个 constructor 是 &lt;code&gt;O&lt;/code&gt; 没有参数，因此 &lt;code&gt;|&lt;/code&gt; 左边留空)。如果没有用 &lt;code&gt;[]&lt;/code&gt; 显式地说明参数的名称，Coq 会自动分配参数名，但自动分配的参数名可能会很奇怪，从而影响后续的证明。&lt;/p&gt;
&lt;p&gt;分类讨论可以嵌套进行，例如下面的证明 and 运算满足交换律的过程：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem andb_commutative: forall b c : bool, andb b c = andb c b.
Proof.
  intros b c. destruct b eqn Eb.
  - destruct c eqn:Ec.
    + reflexivity.
    + reflexivity.
  - destruct c eqn:Ec.
    + reflexivity.
    + reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不同层级必须使用不同的 bullet。可以使用的 bullet 有 &lt;code&gt;-&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; 以及它们的重复版本 (如 &lt;code&gt;--&lt;/code&gt; &lt;code&gt;***&lt;/code&gt; 等)。除了 bullet 我们还可以使用大括号来框出证明的层次，大括号是可以嵌套的，例如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;{ destruct c eqn:Ec.
  { reflexivity. }
  { reflexivity. } }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大括号和 bullet 还可以混合使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;{ destruct c eqn:Ec.
  - reflexivity.
  - reflexivity. }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很多时候我们使用完 &lt;code&gt;intros&lt;/code&gt; 后立刻就要开始分情况讨论，Coq 为我们准备了更加紧凑方便的语法。下面是两个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem plus_1_neq_0&#39; : forall n : nat,
  (n + 1) =? 0  = false.
Proof.
  intros [|n].
  - reflexivity.
  - refiexivity.
Qed.

Theorem andb_commutative&#39;&#39;: forall b c : nat, andb b c = andb c b.
Proof.
  intros [] [].
  - reflexivity.
  - reflexivity.
  - reflexivity.
  - reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种简洁语法的缺点在于我们无法给分情况讨论时做出的假设等式命名 (即 &lt;code&gt;eqn:E&lt;/code&gt; 的部分)。&lt;/p&gt;
&lt;h2 id=&#34;fixpoints-and-structural-recursion-optional&#34;&gt;Fixpoints and Structural Recursion (Optional)&lt;/h2&gt;
&lt;p&gt;回想加法的定义，我们对第一个加数不断 -1 递归。这样的结构递归保证了我们的参数会越来越小，因此不论输入什么参数计算都一定可以终止。&lt;/p&gt;
&lt;p&gt;Coq 要求所有 Fixpoint 类型的函数的参数都要不断变小，从而保证函数一定可以终止。事实上，有的时候存在一些可以终止的合法函数不满足这个性质 (比如如果我们以 5 和 6 为基准定义偶数，那么 0, 1, 2, 3, 4 就得往上加，从而 Coq 报错)。&lt;/p&gt;
&lt;h2 id=&#34;exercises&#34;&gt;Exercises&lt;/h2&gt;
&lt;h3 id=&#34;exercise-1-star-standard-nandb&#34;&gt;Exercise: 1 star, standard (nandb)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition nandb (b1:bool) (b2:bool) : bool :=
  match b1, b2 with
  | true, true =&amp;gt; false
  | true, false =&amp;gt; true
  | false, true =&amp;gt; true
  | false, false =&amp;gt; true
  end.

Example test_nandb1:               (nandb true false) = true.
Proof. simpl. reflexivity. Qed. 
Example test_nandb2:               (nandb false false) = true.
Proof. simpl. reflexivity. Qed.
Example test_nandb3:               (nandb false true) = true.
Proof. simpl. reflexivity. Qed.
Example test_nandb4:               (nandb true true) = false.
Proof. simpl. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-1-star-standard-andb3&#34;&gt;Exercise: 1 star, standard (andb3)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool :=
  (b1 &amp;amp;&amp;amp; b2) &amp;amp;&amp;amp; b3.

Example test_andb31:                 (andb3 true true true) = true.
Proof. reflexivity. Qed.
Example test_andb32:                 (andb3 false true true) = false.
Proof. reflexivity. Qed.
Example test_andb33:                 (andb3 true false true) = false.
Proof. reflexivity. Qed.
Example test_andb34:                 (andb3 true true false) = false.
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：如果 definition 中没有使用 match 语法，则证明过程中使用 &lt;code&gt;simpl.&lt;/code&gt; 并不能简化证明过程，这时直接使用 &lt;code&gt;reflexivity.&lt;/code&gt; 即可。&lt;/p&gt;
&lt;h3 id=&#34;exercise-1-star-standard-factorial&#34;&gt;Exercise: 1 star, standard (factorial)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint factorial (n : nat) : nat :=
  match n with
  | O =&amp;gt; S O
  | S n&#39; =&amp;gt; mult n (factorial n&#39;)
  end.

Example test_factorial1:          (factorial 3) = 6.
Proof. simpl. reflexivity. Qed.
Example test_factorial2:          (factorial 5) = (mult 10 12).
Proof. simpl. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-1-star-standard-ltb&#34;&gt;Exercise: 1 star, standard (ltb)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition ltb (n m : nat) : bool :=
  negb (m &amp;lt;=? n).

Notation &amp;quot;x &amp;lt;? y&amp;quot; := (ltb x y) (at level 70) : nat_scope.

Example test_ltb1:             (ltb 2 2) = false.
Proof. reflexivity. Qed.
Example test_ltb2:             (ltb 2 4) = true.
Proof. reflexivity. Qed.
Example test_ltb3:             (ltb 4 2) = false.
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-1-star-standard-plus_id_exercise&#34;&gt;Exercise: 1 star, standard (plus_id_exercise)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem plus_id_exercise : forall n m o : nat,
  n = m -&amp;gt; m = o -&amp;gt; n + m = m + o.
Proof.
  intros n m o.
  intros H1.
  intros H2.
  rewrite -&amp;gt; H1.
  rewrite -&amp;gt; H2.
  reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里需要注意第一条假设使用时的替换方向：如果反过来把等式中的 m 用 n 代替，由于没有 n 和 o 的直接关系，证明就被卡住了。&lt;/p&gt;
&lt;h3 id=&#34;exercise-1-star-standard-mult_n_1&#34;&gt;Exercise: 1 star, standard (mult_n_1)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem mult_n_1 : forall p : nat,
  p * 1 = p.
Proof.
  intros p.
  rewrite &amp;lt;- mult_n_Sm.
  rewrite &amp;lt;- mult_n_O.
  reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-2-stars-standard-andb_true_elim2&#34;&gt;Exercise: 2 stars, standard (andb_true_elim2)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem andb_true_elim2 : forall b c : bool,
  andb b c = true -&amp;gt; c = true.
Proof.
  intros b c. destruct c eqn:Ec.
  - reflexivity.
  - destruct b eqn:Eb.
    + intros H.
      rewrite &amp;lt;- H.
      reflexivity.
    + intros H.
      rewrite &amp;lt;- H.
      reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本题的一个有意思的点在于如何处理 contradiction：我们对 c 分情况讨论的时候会发现如果 &lt;code&gt;c = false&lt;/code&gt; 那么假设条件不可能成立，会导出 &lt;code&gt;false = true&lt;/code&gt;。对于人类来说这就已经结束了，但在 Coq 中我们需要利用这条规则继续做 rewrite (&lt;code&gt;false = true&lt;/code&gt; 的情况下天地大同了)，直到导出等式两边相等。&lt;/p&gt;
&lt;h3 id=&#34;exercise-1-star-standard-zero_nbeq_plus_1&#34;&gt;Exercise: 1 star, standard (zero_nbeq_plus_1)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem zero_nbeq_plus_1 : forall n : nat,
  0 =? (n + 1) = false.
Proof.
  intros [|n&#39;].
  - reflexivity.
  - reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里值得一提的是为何在 &lt;code&gt;n = S n&#39;&lt;/code&gt; 时 reflexivity 可以直接算出结果。此时我们的 subgoal 是证明 &lt;code&gt;0 =? (S n&#39; + 1) = false&lt;/code&gt;。根据加法的第二条规则，我们有 &lt;code&gt;S n&#39; + 1 = S (n&#39; + 1)&lt;/code&gt;。根据 &lt;code&gt;=?&lt;/code&gt; 的规则又有第一个参数为 0 第二个参数满足 &lt;code&gt;S n&lt;/code&gt; 形式时可以直接判定为 false。因此 &lt;code&gt;false = false&lt;/code&gt; 就证出来了。&lt;/p&gt;
&lt;h3 id=&#34;exercise-2-stars-standard-optional-decreasing&#34;&gt;Exercise: 2 stars, standard, optional (decreasing)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt; Fixpoint error_func (n : nat) : nat :=
  match n with
  | O =&amp;gt; error_func (S n)
  | S O =&amp;gt; S O
  | S n&#39; =&amp;gt; S (error_func n&#39;)
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-1-star-standard-identity_fn_applied_twice&#34;&gt;Exercise: 1 star, standard (identity_fn_applied_twice)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem identity_fn_applied_twice :
  forall (f : bool -&amp;gt; bool),
  (forall (x : bool), f x = x) -&amp;gt;
  forall (b : bool), f (f b) = b.
Proof.
  intros f.
  intros H.
  intros b.
  rewrite -&amp;gt; H.
  rewrite -&amp;gt; H.
  reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-1-star-standard-negation_fn_applied_twice&#34;&gt;Exercise: 1 star, standard (negation_fn_applied_twice)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem negation_fn_applied_twice :
  forall (f : bool -&amp;gt; bool),
  (forall (x : bool), f x = negb x) -&amp;gt;
  forall (b : bool), f (f b) = b.
Proof.
  intros f H b.
  rewrite -&amp;gt; H.
  rewrite -&amp;gt; H.
  destruct b eqn:E.
  - reflexivity.
  - reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-3-stars-standard-optional-andb_eq_orb&#34;&gt;Exercise: 3 stars, standard, optional (andb_eq_orb)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem andb_eq_orb :
  forall (b c : bool),
  (andb b c = orb b c) -&amp;gt;
  b = c.
Proof.
  intros [].
  - simpl.
    intros c H.
    rewrite -&amp;gt; H.
    reflexivity.
  - simpl.
    intros c H.
    rewrite &amp;lt;- H.
    reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本题最暴力的做法就是对 b, c 的四种情况分类讨论。但这样不是很聪明，根据 &lt;code&gt;andb&lt;/code&gt; 和 &lt;code&gt;orb&lt;/code&gt; 的定义，一旦 b 的值确定，表达式的结果是可以用 true, false, c 来表示的，因此我们只要对 b 讨论就可以直接得出 c 的值，这样做简洁很多。&lt;/p&gt;
&lt;h3 id=&#34;exercise-3-stars-standard-binary&#34;&gt;Exercise: 3 stars, standard (binary)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint incr (m:bin) : bin :=
  match m with
  | Z =&amp;gt; B1 Z
  | B0 m&#39; =&amp;gt; B1 m&#39;
  | B1 m&#39; =&amp;gt; B0 (incr m&#39;)
  end.

Fixpoint bin_to_nat (m : bin) : nat := 
  match m with
  | Z =&amp;gt; O
  | B0 m&#39; =&amp;gt; (bin_to_nat m&#39;) * 2
  | B1 m&#39; =&amp;gt; (bin_to_nat m&#39;) * 2 + 1
  end.

Example test_bin_incr1 : (incr (B1 Z)) = B0 (B1 Z).
Proof. reflexivity. Qed.

Example test_bin_incr2 : (incr (B0 (B1 Z))) = B1 (B1 Z).
Proof. reflexivity. Qed.

Example test_bin_incr3 : (incr (B1 (B1 Z))) = B0 (B0 (B1 Z)).
Proof. reflexivity. Qed.

Example test_bin_incr4 : bin_to_nat (B0 (B1 Z)) = 2.
Proof. reflexivity. Qed.

Example test_bin_incr5 :
        bin_to_nat (incr (B1 Z)) = 1 + bin_to_nat (B1 Z).
Proof. reflexivity. Qed.

Example test_bin_incr6 :
        bin_to_nat (incr (incr (B1 Z))) = 2 + bin_to_nat (B1 Z).
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Proof by Indution</title>
      <link>https://kristoff-starling.github.io/posts/booknotes/softwarefoundations/lf/induction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/posts/booknotes/softwarefoundations/lf/induction/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#separate-compilation&#34;&gt;Separate Compilation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#proof-by-induction&#34;&gt;Proof by Induction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#proofs-within-proofs&#34;&gt;Proofs Within Proofs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#formal-vs-informal-proof&#34;&gt;Formal vs. Informal Proof&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercises&#34;&gt;Exercises&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-2-stars-standard-especially-useful-basic_induction&#34;&gt;Exercise: 2 stars, standard, especially useful (basic_induction)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-2-stars-standard-double_plus&#34;&gt;Exercise: 2 stars, standard (double_plus)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-2-stars-standard-eqb_refl&#34;&gt;Exercise: 2 stars, standard (eqb_refl)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-2-stars-standard-optional-even_s&#34;&gt;Exercise: 2 stars, standard, optional (even_S)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-3-stars-standard-especially-useful-mul_comm&#34;&gt;Exercise: 3 stars, standard, especially useful (mul_comm)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-2-stars-standard-optional-plus_leb_compat_l&#34;&gt;Exercise: 2 stars, standard, optional (plus_leb_compat_l)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-3-stars-standard-optional-more_exercises&#34;&gt;Exercise: 3 stars, standard, optional (more_exercises)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-2-stars-standard-optional-add_shuffle3&#34;&gt;Exercise: 2 stars, standard, optional (add_shuffle3&amp;rsquo;)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-3-stars-standard-especially-useful-binary_commute&#34;&gt;Exercise: 3 stars, standard, especially useful (binary_commute)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-3-stars-standard-nat_bin_nat&#34;&gt;Exercise: 3 stars, standard (nat_bin_nat)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-2-stars-advanced-double_bin&#34;&gt;Exercise: 2 stars, advanced (double_bin)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-4-stars-advanced-bin_nat_bin&#34;&gt;Exercise: 4 stars, advanced (bin_nat_bin)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;separate-compilation&#34;&gt;Separate Compilation&lt;/h2&gt;
&lt;p&gt;如果想在新的 &lt;code&gt;.v&lt;/code&gt; 文件中使用别的文件中的所有定义和定理 (比如 &lt;code&gt;Basics.v&lt;/code&gt;)，可以使用如下语句：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;From LF Require Export Basics.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用这条语句的前置条件是 Coq 可以在有 &amp;ldquo;LF&amp;rdquo; 前缀的目录下找到编译过的 &lt;code&gt;Basics.vo&lt;/code&gt;。&lt;code&gt;.vo&lt;/code&gt; 文件之于 &lt;code&gt;.v&lt;/code&gt; 文件就好比 &lt;code&gt;.o&lt;/code&gt; 文件之于 &lt;code&gt;.c&lt;/code&gt; 文件。我们应当在当前的工作目录下建立 &lt;code&gt;_CoqProject&lt;/code&gt; 文件，在其中写上&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;-Q . LF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这会将当前目录绑定到 &amp;ldquo;LF&amp;rdquo; 前缀上。之后我们可以用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;coq_makefile -f _CoqProject *.v -o Makefile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;来自动生成用于编译工作目录下所有源文件的 Makefile，并通过&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make Basics.vo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;来编译生成 &lt;code&gt;.vo&lt;/code&gt; 文件。&lt;/p&gt;
&lt;h2 id=&#34;proof-by-induction&#34;&gt;Proof by Induction&lt;/h2&gt;
&lt;p&gt;我们之前证明了 0 是 &amp;ldquo;+&amp;rdquo; 的 neutral element，但我们只证明了 0 在左侧的情况，即 &lt;code&gt;forall n : nat, 0 + n = n.&lt;/code&gt;。如果我们要证明 &lt;code&gt;n + 0 = n&lt;/code&gt;，事情便变得复杂起来：因为我们的加法是通过对第一个加数的递归定义的，未知大小的整数 &lt;code&gt;n&lt;/code&gt; 无法递归。在这里我们必须使用归纳法 (induction)。&lt;/p&gt;
&lt;p&gt;我们先直接给出归纳法证明 &lt;code&gt;n + 0 = n&lt;/code&gt; 的步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem add_0_r: forall n : nat, n + 0 = n.
Proof.
  intros n. induction n as [| n&#39; IHn&#39;].
  - reflexivity.
  - simpl.
    rewrite -&amp;gt; IHn&#39;.
    reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;induction&lt;/code&gt; 和 &lt;code&gt;destruct&lt;/code&gt; 这个 tactic 一样，也可以在后面跟一个 as。第一种情况是令 &lt;code&gt;n = 0&lt;/code&gt;，这种情况没有参数，所以 &lt;code&gt;|&lt;/code&gt; 左侧没有东西；第二种情况是令 &lt;code&gt;n = S n&#39;&lt;/code&gt;，基于的假设是 &lt;code&gt;n&#39; + 0 = n&#39;&lt;/code&gt; ，我们给这个假设命名为 &lt;code&gt;IHn&#39;&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;proofs-within-proofs&#34;&gt;Proofs Within Proofs&lt;/h2&gt;
&lt;p&gt;我们进行大的证明的过程中时常需要一些小的结论。我们可以在证明大定理之前把小结论先证明好，然后在大定理中 rewrite。但有时候有一些杂项的、trivial 的结论单独拎出来给证明会使证明过程变得很繁杂，所以 Coq 提供了在证明内部证明另一个命题的语法。下面是一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem mult_0_plus&#39; forall n m : nat, (n + 0 + 0) * m = n * m.
Proof.
  intros n m.
  assert (H: n + 0 + 0 = n).
    { rewrite add_comm. simpl. rewrite add_comm. reflexivity. }
  rewrite -&amp;gt; H.
  reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;assert&lt;/code&gt; 这个 tactic 会引入两个 subgoal：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个 subgoal 是括号内写出的命题。上述的写法给这个命题命名为 H。我们也可以使用 &lt;code&gt;assert (n + 0 + 0 = n) as H.&lt;/code&gt; 的语法来书写这一行。这个命题的证明用一对 &lt;code&gt;{}&lt;/code&gt; 框起来。&lt;/li&gt;
&lt;li&gt;第二个 subgoal 和 assert 之前的一刻的 goal 相同，但多了 assert 证明的结论作为一条假设。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面展示另一个需要使用 &lt;code&gt;assert&lt;/code&gt; 的有趣的场景：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem plus_rearrange: forall n m p q : nat, (n + m) + (p + q) = (m + n) + (p + q).
Proof.
  intros n m p q.
  assert (H: n + m = m + n)
    { rewrite add_comm. reflexivity. }
  rewrite H.
  reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到要证明的命题中只有第一个括号内两个加数的顺序不同。但可惜的是我们不能直接利用加法的交换律来 &lt;code&gt;rewrite&lt;/code&gt;，因为 Coq 根据加法交换律在 goal 中寻找实例时会优先找到外层括号的实例，即会把两个括号的内容整体调换。在这里我们不利用加法交换律 rewrite，而是先证明 &lt;code&gt;n + m = m + n&lt;/code&gt; 然后直接 rewrite。&lt;/p&gt;
&lt;h2 id=&#34;formal-vs-informal-proof&#34;&gt;Formal vs. Informal Proof&lt;/h2&gt;
&lt;p&gt;Formal proof 指的是写给 Coq 等证明工具看的证明过程；Informal proof 指的是用自然语言写给人看的证明过程。一个好的 formal proof 应当通过适当的注释和缩进来使其对人类也比较友好。通常来说，formal proof 在细节处会写得比 informal proof 更详细 (例如 reflexivity)，informal proof 会通过一些语言让读者更好地了解当前地证明状态 (这些信息只有使用 Coq 执行代码时才会显示出来)。&lt;/p&gt;
&lt;h2 id=&#34;exercises&#34;&gt;Exercises&lt;/h2&gt;
&lt;h3 id=&#34;exercise-2-stars-standard-especially-useful-basic_induction&#34;&gt;Exercise: 2 stars, standard, especially useful (basic_induction)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem mul_0_r : forall n:nat,
  n * 0 = 0.
Proof.
  intros n. induction n as [| n&#39; IHn&#39;].
  - reflexivity.
  - simpl.
    rewrite -&amp;gt; IHn&#39;.
    reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem plus_n_Sm : forall n m : nat,
  S (n + m) = n + (S m).
Proof.
  intros n m. induction n as [| n&#39; IHn&#39;].
  - reflexivity.
  - simpl.
    rewrite -&amp;gt; IHn&#39;.
    reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem add_comm : forall n m : nat,
  n + m = m + n.
Proof.
  intros n m. induction n as [| n&#39; IHn&#39;].
  - rewrite -&amp;gt; add_0_r. 
    reflexivity.
  - rewrite &amp;lt;- plus_n_Sm.
    rewrite &amp;lt;- IHn&#39;.
    reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个证明稍微复杂一些，归纳基础和归纳步骤都需要使用之前证明过的定理。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem add_assoc : forall n m p : nat,
  n + (m + p) = (n + m) + p.
Proof.
  intros n m p. induction n as [| n&#39; IHn&#39;].
  - reflexivity.
  - simpl. 
    rewrite -&amp;gt; IHn&#39;.
    reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-2-stars-standard-double_plus&#34;&gt;Exercise: 2 stars, standard (double_plus)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Lemma double_plus : forall n, double n = n + n .
Proof.
  intros n. induction n as [| n&#39; IHn&#39;].
  - reflexivity.
  - simpl.
    rewrite -&amp;gt; IHn&#39;.
    rewrite &amp;lt;- plus_n_Sm.
    reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-2-stars-standard-eqb_refl&#34;&gt;Exercise: 2 stars, standard (eqb_refl)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem eqb_refl : forall n : nat,
  (n =? n) = true.
Proof.
  intros n. induction n as [| n&#39; IHn&#39;].
  - reflexivity.
  - simpl.
    rewrite -&amp;gt; IHn&#39;.
    reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-2-stars-standard-optional-even_s&#34;&gt;Exercise: 2 stars, standard, optional (even_S)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem even_S : forall n : nat,
  even (S n) = negb (even n).
Proof.
  intros n. induction n as [| n&#39; IHn&#39;].
  - reflexivity.
  - rewrite -&amp;gt; IHn&#39;.
    simpl.
    rewrite -&amp;gt; negb_involutive.
    reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本题需要注意的点是：归纳步骤中如果直接上 &lt;code&gt;simpl&lt;/code&gt; 化简，会将等式右侧的 &lt;code&gt;even n&#39;&lt;/code&gt; 的定义展开，所以这里笔者先 &lt;code&gt;rewrite&lt;/code&gt; 再 &lt;code&gt;simpl&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;exercise-3-stars-standard-especially-useful-mul_comm&#34;&gt;Exercise: 3 stars, standard, especially useful (mul_comm)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem add_shuffle3 : forall n m p : nat,
  n + (m + p) = m + (n + p).
Proof.
  intros n m p.
  rewrite add_assoc.
  rewrite add_assoc.
  assert (H: n + m = m + n).
    { rewrite add_comm. reflexivity. }
  rewrite H.
  reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Lemma mult_n_0: forall n : nat, n * 0 = 0.
Proof.
  induction n as [| n&#39; IHn&#39;].
  - reflexivity.
  - simpl. rewrite IHn&#39;. reflexivity.
Qed.

Lemma mult_n_Sm: forall n m : nat,
  n * (1 + m) = n + n * m.
Proof.
  intros n m.
  induction n as [| n&#39; IHn&#39;].
  - reflexivity.
  - assert (H1: S n&#39; * (1 + m) = S m + n&#39; * (1 + m)). { reflexivity. }
    rewrite H1.
    rewrite IHn&#39;.
    assert (H2: S n&#39; * m = m + n&#39; * m). { reflexivity. }
    rewrite H2.
    simpl.
    rewrite add_shuffle3.
    reflexivity.
Qed.


Theorem mul_comm : forall m n : nat,
  m * n = n * m.
Proof.
  intros n m.
  induction n as [| n&#39; IHn&#39;].
  - rewrite mult_n_0. reflexivity.
  - simpl.
    rewrite mult_n_Sm.
    rewrite IHn&#39;.
    reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这题相当有难度，需要先证明 &lt;code&gt;n * S m = n + n * m&lt;/code&gt; 这个引理，中间反复的在局部使用乘法定义/加法交换律结合律比较搞心态。&lt;/p&gt;
&lt;h3 id=&#34;exercise-2-stars-standard-optional-plus_leb_compat_l&#34;&gt;Exercise: 2 stars, standard, optional (plus_leb_compat_l)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem plus_leb_compat_l : forall n m p : nat,
  n &amp;lt;=? m = true -&amp;gt; (p + n) &amp;lt;=? (p + m) = true.
Proof.
  intros n m p H.
  induction p as [| p&#39; IHp&#39;].
  - simpl. rewrite H. reflexivity.
  - simpl. rewrite IHp&#39;. reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-3-stars-standard-optional-more_exercises&#34;&gt;Exercise: 3 stars, standard, optional (more_exercises)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem leb_refl : forall n:nat,
  (n &amp;lt;=? n) = true.
Proof.
  intros n.
  induction n as [| n&#39; IHn&#39;].
  - reflexivity.
  - simpl. rewrite IHn&#39;. reflexivity.
Qed.

Theorem zero_neqb_S : forall n:nat,
  0 =? (S n) = false.
Proof.
  intros n.
  reflexivity.
Qed.

Theorem andb_false_r : forall b : bool,
  andb b false = false.
Proof.
  intros b.
  rewrite andb_commutative.
  reflexivity.
Qed

Theorem S_neqb_0 : forall n:nat,
  (S n) =? 0 = false.
Proof.
  intros n.
  reflexivity.
Qed.

Theorem mult_1_l : forall n:nat, 1 * n = n.
Proof.
  intros n.
  simpl.
  rewrite add_comm.
  reflexivity.
Qed.

Theorem all3_spec : forall b c : bool,
  orb
    (andb b c)
    (orb (negb b)
         (negb c))
  = true.
Proof.
  intros [] [].
  - reflexivity.
  - reflexivity.
  - reflexivity.
  - reflexivity.
Qed.

Theorem mult_plus_distr_r : forall n m p : nat,
  (n + m) * p = (n * p) + (m * p).
Proof.
  intros.
  rewrite mul_comm.
  induction p as [| p&#39; IHp&#39;].
  - rewrite mult_n_0. rewrite mult_n_0. reflexivity.
  - simpl.
    rewrite mult_n_Sm.
    rewrite mult_n_Sm.
    rewrite IHp&#39;.
    rewrite add_assoc.
    rewrite add_assoc.
    assert (H1: n + m + n * p&#39; = n + (m + n * p&#39;)). { rewrite add_assoc. reflexivity. }
    rewrite H1.
    assert (H2: m + n * p&#39; = n * p&#39; + m). { rewrite add_comm. reflexivity. }
    rewrite H2.
    rewrite add_assoc.
    reflexivity.
Qed.

Theorem mult_assoc : forall n m p : nat,
  n * (m * p) = (n * m) * p.
Proof.
  intros.
  induction n as [| n&#39; IHn&#39;].
  - reflexivity.
  - simpl.
    rewrite IHn&#39;.
    rewrite mult_plus_distr_r.
    reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：乘法分配律的证明由于涉及过多繁琐的加法交换律/结合律，不能保证过程的简洁性。&lt;/p&gt;
&lt;h3 id=&#34;exercise-2-stars-standard-optional-add_shuffle3&#34;&gt;Exercise: 2 stars, standard, optional (add_shuffle3&#39;)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem add_shuffle3&#39; : forall n m p : nat,
  n + (m + p) = m + (n + p).
Proof.
  intros.
  rewrite add_assoc.
  rewrite add_assoc.
  replace (n + m) with (m + n).
  - reflexivity.
  - rewrite add_comm. reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;replace&lt;/code&gt; 这个 tactic 可以避免每次 assert 之后再 rewrite 新假设的繁琐过程。&lt;/p&gt;
&lt;h3 id=&#34;exercise-3-stars-standard-especially-useful-binary_commute&#34;&gt;Exercise: 3 stars, standard, especially useful (binary_commute)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem bin_to_nat_pres_incr : forall b : bin,
  bin_to_nat (incr b) = 1 + bin_to_nat b.
Proof.
  intros b. induction b as [| b&#39; | b&#39; IHb&#39;]. 
  - reflexivity.
  - simpl. rewrite add_comm. reflexivity.
  - simpl. rewrite IHb&#39;. simpl. rewrite add_comm. reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里值得一提的是：Coq 中只有基于结构的归纳法，只要变量类型是以 inductive 的形式定义的，我们都可以使用归纳法进行证明。之前的归纳法都针对自然数，这是因为自然数也是归纳定义的。这里的 &lt;code&gt;bin&lt;/code&gt; 有三个归纳分支，写起来和自然数大同小异。&lt;/p&gt;
&lt;h3 id=&#34;exercise-3-stars-standard-nat_bin_nat&#34;&gt;Exercise: 3 stars, standard (nat_bin_nat)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint nat_to_bin (n:nat) : bin :=
  match n with
  | O =&amp;gt; Z
  | S n&#39; =&amp;gt; incr(nat_to_bin(n&#39;))
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem nat_bin_nat : forall n, bin_to_nat (nat_to_bin n) = n.
Proof.
  intros. induction n as [| n&#39; IHn&#39;].
  - reflexivity.
  - simpl. 
    rewrite bin_to_nat_pres_incr.
    rewrite IHn&#39;.
    reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-2-stars-advanced-double_bin&#34;&gt;Exercise: 2 stars, advanced (double_bin)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Lemma double_incr : forall n : nat, double (S n) = S (S (double n)).
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition double_bin (b:bin) : bin :=
  match b with
  | Z =&amp;gt; Z
  | _ =&amp;gt; B0 b
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Example double_bin_zero : double_bin Z = Z.
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Lemma double_incr_bin : forall b,
    double_bin (incr b) = incr (incr (double_bin b)).
Proof.
  intros b.
  induction b as [| b&#39; | b&#39; IHb&#39;].
  - reflexivity.
  - reflexivity.
  - reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-4-stars-advanced-bin_nat_bin&#34;&gt;Exercise: 4 stars, advanced (bin_nat_bin)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint normalize (b:bin) : bin :=
  match b with
  | Z =&amp;gt; Z
  | B0 b&#39; =&amp;gt;
    match bin_to_nat b&#39; with
    | 0 =&amp;gt; Z
    | S n&#39; =&amp;gt; B0 (normalize b&#39;)
    end
  | B1 b&#39; =&amp;gt; B1 (normalize b&#39;)
  end.

Example normalize_example : normalize (B1 (B0 Z)) = B1 Z.
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;书中提到的 &amp;ldquo;equivalent&amp;rdquo; bin 实质上指的就是前导 0 的问题，normalize 的主要任务是去除掉 &lt;code&gt;B0 (B0 ... Z)&lt;/code&gt; 的情况，因此对 &lt;code&gt;B0 b&#39;&lt;/code&gt; 的情况进行特殊判断。&lt;/p&gt;
&lt;p&gt;这里利用了 &lt;code&gt;bin_to_nat b&#39;&lt;/code&gt; 的结果判断是否是 0 而没有直接用 &lt;code&gt;normalize b&#39;&lt;/code&gt; 的结果，是为了下面证明的方便。下面的证明中对 &lt;code&gt;bin_to_nat b&#39;&lt;/code&gt; 的结果进行了分类讨论，这样定义可以让 &lt;code&gt;simpl&lt;/code&gt; 直接拆解定义。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Lemma mult_2_plus_1_bin : forall n : nat, nat_to_bin(n * 2 + 1) = B1 (nat_to_bin n).
Proof.
  intros n.
  induction n as [| n&#39; IHn&#39;].
  - reflexivity.
  - simpl.
    rewrite IHn&#39;.
    reflexivity.
Qed.

Lemma mult_2_eq_double : forall n : nat, nat_to_bin (n * 2) = double_bin (nat_to_bin n).
Proof.
  intros n.
  induction n as [| n&#39; IHn&#39;].
  - reflexivity.
  - simpl.
    rewrite IHn&#39;.
    rewrite double_incr_bin.
    reflexivity.
Qed.

Lemma double_bin_eq_B0 : forall b : bin, double_bin (incr b) = B0 (incr b).
Proof.
  intros b.
  destruct b as [| b&#39; | b&#39;] eqn:B.
  - reflexivity.
  - reflexivity.
  - reflexivity.
Qed.

Lemma mult_2_bin : forall n : nat, nat_to_bin (S n * 2) = B0 (nat_to_bin (S n)).
Proof.
  intros n.
  simpl.
  rewrite mult_2_eq_double.
  rewrite &amp;lt;- double_incr_bin.
  rewrite double_bin_eq_B0.
  reflexivity.
Qed.

Theorem bin_nat_bin : forall b, nat_to_bin (bin_to_nat b) = normalize b.
Proof.
  intros b. induction b as [| b&#39; | b&#39; IHb&#39;].
  - reflexivity.
  - destruct (bin_to_nat b&#39;) as [| n&#39;] eqn:N.
    + simpl. rewrite N. reflexivity.
    + simpl. rewrite N. 
      rewrite &amp;lt;- IHb&#39;.
      rewrite mult_2_bin.
      reflexivity.
  - simpl.
    rewrite &amp;lt;- IHb&#39;.
    rewrite mult_2_plus_1_bin.
    reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了证明最终的定理，笔者先证明了 3 个引理，主要围绕着 &lt;code&gt;*2&lt;/code&gt;/&lt;code&gt;*2+1&lt;/code&gt; 和在 bin前面添加 B0/B1 的一致性讨论。最终定理的证明中比较精妙的部分是关于 &lt;code&gt;bin_to_nat b&#39;&lt;/code&gt; 的讨论。在归纳步骤中等式右边是 &lt;code&gt;normalize (B0 b&#39;)&lt;/code&gt;，如果我们不能确定 &lt;code&gt;b&#39;&lt;/code&gt; 不是 Z，那么括号里的 B0 就提不出来，可如果对着 b&amp;rsquo; 的结构直接进行讨论，又容易陷入循环论证 (如果 &lt;code&gt;b&#39;= B0 b&#39;&#39;&lt;/code&gt;，仍然说明不了问题)，因此在这里选择对 b&amp;rsquo; 转化成自然数后的结果进行讨论。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Woring with Structured Data</title>
      <link>https://kristoff-starling.github.io/posts/booknotes/softwarefoundations/lf/lists/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/posts/booknotes/softwarefoundations/lf/lists/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#pairs-of-numbers&#34;&gt;Pairs of Numbers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#lists-of-numbers&#34;&gt;Lists of Numbers&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#repeat&#34;&gt;Repeat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#length&#34;&gt;Length&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#append&#34;&gt;Append&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#head-ant-tail&#34;&gt;Head ant Tail&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#bags-via-lists&#34;&gt;Bags via Lists&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#reasoning-about-lists&#34;&gt;Reasoning About Lists&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#induction-on-lists&#34;&gt;Induction on Lists&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#reversing-a-list&#34;&gt;Reversing a List&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#search&#34;&gt;Search&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#options&#34;&gt;Options&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#partial-maps&#34;&gt;Partial Maps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercises&#34;&gt;Exercises&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-1-star-standard-snd_fst_is_swap&#34;&gt;Exercise: 1 star, standard (snd_fst_is_swap)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-1-star-standard-optional-fst_swap_is_snd&#34;&gt;Exercise: 1 star, standard, optional (fst_swap_is_snd)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-2-stars-standard-especially-useful-list_funs&#34;&gt;Exercise: 2 stars, standard, especially useful (list_funs)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-3-stars-advanced-alternate&#34;&gt;Exercise: 3 stars, advanced (alternate)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-3-stars-standard-especially-useful-bag_functions&#34;&gt;Exercise: 3 stars, standard, especially useful (bag_functions)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-3-stars-standard-optional-bag_more_functions&#34;&gt;Exercise: 3 stars, standard, optional (bag_more_functions)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-2-stars-standard-especially-useful-add_inc_count&#34;&gt;Exercise: 2 stars, standard, especially useful (add_inc_count)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-3-stars-standard-list_exercises&#34;&gt;Exercise: 3 stars, standard (list_exercises)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-2-stars-standard-eqblist&#34;&gt;Exercise: 2 stars, standard (eqblist)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-1-star-standard-count_member_nonzero&#34;&gt;Exercise: 1 star, standard (count_member_nonzero)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-3-stars-advanced-remove_does_not_increase_count&#34;&gt;Exercise: 3 stars, advanced (remove_does_not_increase_count)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-3-stars-standard-optional-bag_count_sum&#34;&gt;Exercise: 3 stars, standard, optional (bag_count_sum)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-3-stars-advanced-involution_injective&#34;&gt;Exercise: 3 stars, advanced (involution_injective)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-2-stars-advanced-rev_injective&#34;&gt;Exercise: 2 stars, advanced (rev_injective)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-2-stars-standard-hd_error&#34;&gt;Exercise: 2 stars, standard (hd_error)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-1-star-standard-optional-option_elim_hd&#34;&gt;Exercise: 1 star, standard, optional (option_elim_hd)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-1-star-standard-eqb_id_refl&#34;&gt;Exercise: 1 star, standard (eqb_id_refl)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-1-star-standard-update_eq&#34;&gt;Exercise: 1 star, standard (update_eq)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-1-star-standard-update_neq&#34;&gt;Exercise: 1 star, standard (update_neq)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pairs-of-numbers&#34;&gt;Pairs of Numbers&lt;/h2&gt;
&lt;p&gt;我们可以定义一个 pair 类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Inductive natprod : Type := 
  | pair (n1 n2 : nat).
Notation &amp;quot;( x, y )&amp;quot; := (pair x y).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以及一些辅助函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition fst (p : natprod) : nat :=
  match p with
  | (x, y) =&amp;gt; x
  end.
Definition snd (p : natprod) : nat :=
  match p with
  | (x, y) =&amp;gt; y
  end.
Definition swap_pair(p : natprod) : nat :=
  match p with
  | (x, y) =&amp;gt; (y, x)
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里值得注意的是在 pattern matching 中的 &lt;code&gt;(x, y)&lt;/code&gt; 和 &lt;code&gt;x, y&lt;/code&gt; 是不一样的：前者匹配的是一个 pair 类型，而后者匹配了两个东西。&lt;/p&gt;
&lt;p&gt;下面看一个有意思的证明题：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem surjective_pairing : forall p : natprod, p = (fst p, snd p).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们无法通过 &lt;code&gt;simpl&lt;/code&gt; 直接证明该题，因为 p 的具体内容不知道，&lt;code&gt;fst p&lt;/code&gt; &lt;code&gt;snd p&lt;/code&gt; 无法化简。一个好的方法是使用 &lt;code&gt;destruct&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Proof.
  intros p. destruct p as [n m].
  simpl. reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的 destruct 不是用来分类讨论，而是其字面意思：给 &lt;code&gt;p&lt;/code&gt; 一个形式，从而解构它。&lt;/p&gt;
&lt;h2 id=&#34;lists-of-numbers&#34;&gt;Lists of Numbers&lt;/h2&gt;
&lt;p&gt;我们定义一个链表类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Inductive natlist : Type :=
  | nil
  | cons (n : nat) (l : natlist).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简单来说，每一个 natlist 类型的变量要么是 nil，要么是一个自然数和另一个 natlist。下面的一些 notation 让表示链表变得简单：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Notation &amp;quot;x :: l&amp;quot; := (cons x l)
                     (at level 60, right associativity).
Notation &amp;quot;[ ]&amp;quot; := nil.
Notation &amp;quot;[ x ; .. ; y]&amp;quot; := (cons x .. (cons y nil) ..).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里值得注意两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;::&lt;/code&gt; 应当是右结合的，即 &lt;code&gt;1 :: 2 :: 3&lt;/code&gt; 等价于 &lt;code&gt;1 :: (2 :: 3)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;::&lt;/code&gt; 的优先级低于加减法，即 &lt;code&gt;1 + 2 :: 3&lt;/code&gt; 等价于 &lt;code&gt;(1 + 2) :: 3&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;repeat&#34;&gt;Repeat&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;repeat&lt;/code&gt; 函数接收两个参数 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;count&lt;/code&gt;，返回一个长度为 &lt;code&gt;count&lt;/code&gt;，每个节点都是 &lt;code&gt;n&lt;/code&gt; 的链表：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint repeat (n count : nat) -&amp;gt; natlist :=
  match count with
  | O =&amp;gt; nil
  | S count&#39; =&amp;gt; n :: (repeat n count&#39;)
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;length&#34;&gt;Length&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;length&lt;/code&gt; 函数接收一个参数 &lt;code&gt;l&lt;/code&gt;，返回链表 &lt;code&gt;l&lt;/code&gt; 的长度。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint length (l : natlist) -&amp;gt; nat :=
  match l with
  | nil =&amp;gt; 0
  | h :: t =&amp;gt; 1 + (length t)
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;append&#34;&gt;Append&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;app&lt;/code&gt; 函数用于把两个链表连接起来。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint app (l1 l2 : natlist) -&amp;gt; natlist :=
  match l1 with
  | nil =&amp;gt; l2
  | h :: t =&amp;gt; h :: (app t l2)
  end.

Notation &amp;quot;x ++ y&amp;quot; := (app x y)
                     (right associativity, at level 60).
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;head-ant-tail&#34;&gt;Head ant Tail&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;hd&lt;/code&gt; 函数返回链表的第一个元素，&lt;code&gt;tl&lt;/code&gt; 函数返回链条除了第一个元素以外的后面的部分。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition hd (default : nat) (l : natlist) -&amp;gt; nat :=
  match hd with
  | nil =&amp;gt; default
  | h :: t =&amp;gt; h
  end.
Definition tl (l : natlist) -&amp;gt; natlist :=
  match tl with
  | nil =&amp;gt; nil
  | h :: t =&amp;gt; t
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;bags-via-lists&#34;&gt;Bags via Lists&lt;/h3&gt;
&lt;p&gt;这里的 bag 指的是 multiset。我们可以用链表模拟 multiset。&lt;/p&gt;
&lt;h2 id=&#34;reasoning-about-lists&#34;&gt;Reasoning About Lists&lt;/h2&gt;
&lt;p&gt;List 的 match 定义让我们可以对于很多比较简单的命题直接使用 &lt;code&gt;reflexivity&lt;/code&gt; 或者分类讨论解决。但稍复杂的问题还是要借助归纳法。&lt;/p&gt;
&lt;h3 id=&#34;induction-on-lists&#34;&gt;Induction on Lists&lt;/h3&gt;
&lt;p&gt;对于链表的归纳法和对于自然数的归纳法没有本质区别。只要使用 &lt;code&gt;Inductive&lt;/code&gt; 的方式定义的类型都可以使用归纳法进行证明。下面是 &lt;code&gt;++&lt;/code&gt; 具有结合律的一段证明：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem app_assoc : forall l1 l2 l3 : natlist,
  (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).
Proof.
  intros l1 l2 l3. induction l1 as [| n l1&#39; IHl&#39;].
  - (* l1 = nil *)
    reflexivity.
  - (* l1 = cons n l1&#39; *)
    simpl. rewrite IHl&#39;. reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;reversing-a-list&#34;&gt;Reversing a List&lt;/h3&gt;
&lt;p&gt;考虑如下的翻转链表的函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint rev (l : natlist) : natlist :=
  match l with
  | nil =&amp;gt; nil
  | h :: t =&amp;gt; (rev t) ++ [h]
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面我们尝试证明链表翻转后长度不变：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem rev_length : forall l : natlist, length (rev l) = length l.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果直接使用数学归纳法证明，在 successor case 中，我们会被 &lt;code&gt;length(rev l&#39; ++ [n]) = S (length (rev l&#39;))&lt;/code&gt; 这个结论卡住。因此我们需要先证明一个引理：链表结合后的长度等于结合前两个链表的长度之和。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem app_length : forall l1 l2 : natlist, length (l1 ++ l2) = (length l1) + (length l2).
Proof.
  intros l1 l2. induction l1 as [| n l1&#39; IHl1&#39;].
  - reflexivity.
  - simpl. rewrite IHl1&#39;. reflexivity.
Qed.

Theorem rev_length : forall l : natlist, length (rev l) = length l.
Proof.
  intros l. induction l as [| n l&#39; IHl&#39;].
  - reflexivity.
  - simpl. rewrite app_length.
    simpl. rewrite IHl&#39;. rewrite add_comm.
    reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;search&#34;&gt;Search&lt;/h3&gt;
&lt;p&gt;我们在证明的时候时常要使用之前证明过的引理，但使用这些引理需要知道它们的名字，如果现场不记得名字，可以使用 &lt;code&gt;Search name&lt;/code&gt; 的方式来查找，Coq 会输出所有名字中带有 name 的引理。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Search&lt;/code&gt; tactic 还支持更加丰富的查找功能，例如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Search (_ + _ = _ + _) inside Induction. 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会在 Induction 模块中寻找符合上述形式的定理。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Search (?x + ?y = ?y + ?x).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;几乎可以直接锁定到加法交换律。这里变量前加一个 &lt;code&gt;?&lt;/code&gt; 表示这是搜索时使用的 pattern，而不是在当前环境中要求存在的变量。&lt;/p&gt;
&lt;h2 id=&#34;options&#34;&gt;Options&lt;/h2&gt;
&lt;p&gt;这一章节讲述了 error handling 的重要性。假设我们要写一个函数返回链表的第 n 个元素，我们必须要考虑如果链表的长度小于 n 应当返回什么，如果我们这样写代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint nth_bad (l : natlist) (n : nat) : nat :=
  match l with
  | nil =&amp;gt; 42
  | a :: l&#39; =&amp;gt; match n with
               | 0 ⇒ a
               | S n&#39; ⇒ nth_bad l&#39; n&#39;
               end
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么如果函数返回了 42，我们必须再检查一遍链表才能确定究竟是链表太短了还是第 n 个元素正好是 42。一个好的方法是重新定义返回类型，在 error 时返回一个特殊的东西：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Inductive natoption : Type :=
  | Some (n : nat)
  | None.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint nth_error (l : natlist) (n : nat) : natoption :=
  match l with
  | nil =&amp;gt; None
  | a :: l&#39; =&amp;gt; match n with
               | O ⇒ Some a
               | S n&#39; ⇒ nth_error l&#39; n&#39;
               end
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后我们还可以根据具体的情境来选择不同的不可能出现的值作为返回值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition option_elim (d : nat) (o : natoption) : nat :=
  match o with
  | Some n&#39; =&amp;gt; n&#39;
  | None =&amp;gt; d
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;partial-maps&#34;&gt;Partial Maps&lt;/h2&gt;
&lt;p&gt;这一章介绍了用 Coq 定义 map 这一数据结构。map 本质上就是 key-value pair 的集合。这里我们先为 key 定义一个单独的类型 (没有什么特殊的作用，只是为了封装一下好看)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Inductive id : Type :=
  | Id (n : nat)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来我们定义 partial map:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Inductive partial_map : Type :=
  | empty
  | record (i : id) (v : nat) (m : partial_map)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该定义的意思是：partial map 要么是 empty (空集)，要么是一个 key-value pair 接上另一个 partial map。&lt;/p&gt;
&lt;p&gt;下面的 update 函数可以完成向 partial map 中添加一个 key-value pair 的功能：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition update (d : partial_map) (x : id) (value : nat) -&amp;gt; partial_map :=
  record x value d.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;find 函数可以查询 partial map 中是否存在某个 id，并返回对应的 value：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint find (x : id) (d : partial_map) : natoption :=
  match d with
  | empty =&amp;gt; None.
  | y v d&#39; =&amp;gt; if eqb_id x y
              then Some v
              else find x d&#39;
  end.s
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;exercises&#34;&gt;Exercises&lt;/h2&gt;
&lt;h3 id=&#34;exercise-1-star-standard-snd_fst_is_swap&#34;&gt;Exercise: 1 star, standard (snd_fst_is_swap)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem snd_fst_is_swap : forall (p : natprod),
  (snd p, fst p) = swap_pair p.
Proof.
  intros p. destruct p as [n m].
  reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-1-star-standard-optional-fst_swap_is_snd&#34;&gt;Exercise: 1 star, standard, optional (fst_swap_is_snd)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem fst_swap_is_snd : forall (p : natprod),
  fst (swap_pair p) = snd p.
Proof.
  intros p. destruct p as [n m].
  reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-2-stars-standard-especially-useful-list_funs&#34;&gt;Exercise: 2 stars, standard, especially useful (list_funs)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint nonzeros (l:natlist) : natlist :=
  match l with
  | nil =&amp;gt; nil
  | O :: t =&amp;gt; nonzeros t
  | S n :: t =&amp;gt; S n :: (nonzeros t)
  end.

Example test_nonzeros:
  nonzeros [0;1;0;2;3;0;0] = [1;2;3].
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint oddmembers (l:natlist) : natlist :=
  match l with
  | nil =&amp;gt; nil
  | h :: t =&amp;gt; if (even h) then (oddmembers t) else (h :: (oddmembers t))
  end.

Example test_oddmembers:
  oddmembers [0;1;0;2;3;0;0] = [1;3].
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition countoddmembers (l:natlist) : nat :=
  length (oddmembers l).

Example test_countoddmembers1:
  countoddmembers [1;0;3;1;4;5] = 4.
Proof. reflexivity. Qed.

Example test_countoddmembers2:
  countoddmembers [0;2;4] = 0.
Proof. reflexivity. Qed.

Example test_countoddmembers3:
  countoddmembers nil = 0.
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-3-stars-advanced-alternate&#34;&gt;Exercise: 3 stars, advanced (alternate)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint alternate (l1 l2 : natlist) : natlist :=
  match l1, l2 with
  | nil, nil =&amp;gt; nil
  | nil, _ =&amp;gt; l2
  | _, nil =&amp;gt; l1
  | h1 :: t1, h2 :: t2 =&amp;gt; h1 :: h2 :: (alternate t1 t2)
  end.

Example test_alternate1:
  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].
Proof. reflexivity. Qed.

Example test_alternate2:
  alternate [1] [4;5;6] = [1;4;5;6].
Proof. reflexivity. Qed.

Example test_alternate3:
  alternate [1;2;3] [4] = [1;4;2;3].
Proof. reflexivity. Qed.

Example test_alternate4:
  alternate [] [20;30] = [20;30].
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-3-stars-standard-especially-useful-bag_functions&#34;&gt;Exercise: 3 stars, standard, especially useful (bag_functions)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint count (v : nat) (s : bag) : nat :=
  match s with
  | nil =&amp;gt; 0
  | h :: t =&amp;gt; if (v =? h) then 1 + (count v t) else (count v t)
  end.

Example test_count1:              count 1 [1;2;3;1;4;1] = 3.
Proof. reflexivity. Qed.
Example test_count2:              count 6 [1;2;3;1;4;1] = 0.
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition sum : bag -&amp;gt; bag -&amp;gt; bag := app.

Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里可以注意一下不显式给出参数名称的定义函数的方法。在这种情况下，我们只能把一个参数类型和返回值类型相同的函数赋给当前函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition add (v : nat) (s : bag) : bag := v :: s.

Example test_add1:                count 1 (add 1 [1;4;1]) = 3.
Proof. reflexivity. Qed.
Example test_add2:                count 5 (add 1 [1;4;1]) = 0.
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint member (v : nat) (s : bag) : bool :=
  match s with
  | nil =&amp;gt; false
  | h :: t =&amp;gt; if (v =? h) then true else (member v t)
  end.

Example test_member1:             member 1 [1;4;1] = true.
Proof. reflexivity. Qed.
Example test_member2:             member 2 [1;4;1] = false.
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-3-stars-standard-optional-bag_more_functions&#34;&gt;Exercise: 3 stars, standard, optional (bag_more_functions)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint remove_one (v : nat) (s : bag) : bag :=
  match s with
  | nil =&amp;gt; nil
  | h :: t =&amp;gt; if (h =? v) then t else (h :: (remove_one v t))
  end.

Example test_remove_one1:
  count 5 (remove_one 5 [2;1;5;4;1]) = 0.
Proof. reflexivity. Qed.

Example test_remove_one2:
  count 5 (remove_one 5 [2;1;4;1]) = 0.
Proof. reflexivity. Qed.

Example test_remove_one3:
  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.
Proof. reflexivity. Qed.

Example test_remove_one4:
  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint remove_all (v:nat) (s:bag) : bag :=
  match s with
  | nil =&amp;gt; nil
  | h :: t =&amp;gt; if (h =? v) then (remove_all v t) else (h :: (remove_all v t))
  end.

Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.
Proof. reflexivity. Qed.
Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.
Proof. reflexivity. Qed.
Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.
Proof. reflexivity. Qed.
Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint included (s1 : bag) (s2 : bag) : bool :=
  match s1 with
  | nil =&amp;gt; true
  | h :: t =&amp;gt; if ((count h s2) =? 0) then
                false
              else
                included t (remove_one h s2)
  end.

Example test_included1:              included [1;2] [2;1;4;1] = true.
Proof. reflexivity. Qed.
Example test_included2:              included [1;2;2] [2;1;4;1] = false.
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-2-stars-standard-especially-useful-add_inc_count&#34;&gt;Exercise: 2 stars, standard, especially useful (add_inc_count)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem add_inc_count : forall (v : nat) (s : bag),
  count v (add v s) = 1 + count v s.
Proof.
  intros. 
  simpl.
  rewrite eqb_refl. (* n =? n = true *)
  reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-3-stars-standard-list_exercises&#34;&gt;Exercise: 3 stars, standard (list_exercises)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem app_nil_r : forall l : natlist,
  l ++ [] = l.
Proof.
  intros l. induction l as [| n l&#39; IHl&#39;].
  - reflexivity.
  - simpl. rewrite IHl&#39;. reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem rev_app_distr: forall l1 l2 : natlist,
  rev (l1 ++ l2) = rev l2 ++ rev l1.
Proof.
  intros l1 l2.
  induction l1 as [|n l1&#39; IHl1&#39;].
  - rewrite app_nil_r. reflexivity.
  - simpl. 
    rewrite IHl1&#39;. 
    rewrite app_assoc. 
    reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem rev_involutive : forall l : natlist,
  rev (rev l) = l.
Proof.
  intros l.
  induction l as [| n l&#39; IHl&#39;].
  - reflexivity.
  - simpl. 
    rewrite rev_app_distr.
    rewrite IHl&#39;.
    reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem app_assoc4 : forall l1 l2 l3 l4 : natlist,
  l1 ++ (l2 ++ (l3 ++ l4)) = ((l1 ++ l2) ++ l3) ++ l4.
Proof.
  intros l1 l2 l3 l4.
  rewrite app_assoc.
  rewrite app_assoc.
  reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Lemma nonzeros_app : forall l1 l2 : natlist,
  nonzeros (l1 ++ l2) = (nonzeros l1) ++ (nonzeros l2).
Proof.
  intros l1 l2.
  induction l1 as [| n l1&#39; IHl1&#39;].
  - reflexivity.
  - destruct n as [| n&#39;] eqn:N.
    + simpl. rewrite IHl1&#39;. reflexivity.
    + simpl. rewrite IHl1&#39;. reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-2-stars-standard-eqblist&#34;&gt;Exercise: 2 stars, standard (eqblist)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint eqblist (l1 l2 : natlist) : bool :=
  match l1, l2 with
  | nil, nil =&amp;gt; true
  | nil, _ =&amp;gt; false
  | _, nil =&amp;gt; false
  | h1 :: t1, h2 :: t2 =&amp;gt;
    if (h1 =? h2) then (eqblist t1 t2) else false
  end.

Example test_eqblist1 :
  (eqblist nil nil = true).
Proof. reflexivity. Qed.

Example test_eqblist2 :
  eqblist [1;2;3] [1;2;3] = true.
Proof. reflexivity. Qed.

Example test_eqblist3 :
  eqblist [1;2;3] [1;2;4] = false.
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem eqblist_refl : forall l:natlist,
  true = eqblist l l.
Proof.
  intros l.
  induction l as [| n l&#39; IHl&#39;].
  - (* l = nil *)
    reflexivity.
  - (* l = con n l&#39; *)
    simpl. 
    rewrite eqb_refl. (* n =? n = true *)
    rewrite IHl&#39;.
    reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-1-star-standard-count_member_nonzero&#34;&gt;Exercise: 1 star, standard (count_member_nonzero)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem count_member_nonzero : forall (s : bag),
  1 &amp;lt;=? (count 1 (1 :: s)) = true.
Proof.
  intros s.
  reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-3-stars-advanced-remove_does_not_increase_count&#34;&gt;Exercise: 3 stars, advanced (remove_does_not_increase_count)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem remove_does_not_increase_count: forall (s : bag),
  (count 0 (remove_one 0 s)) &amp;lt;=? (count 0 s) = true.
Proof.
  intros s.
  induction s as [| n s&#39; IHs&#39;].
  - reflexivity.
  - destruct n as [| n&#39;] eqn:N.
    + simpl.
      rewrite leb_n_Sn.
      reflexivity.
    + simpl.
      rewrite IHs&#39;.
      reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-3-stars-standard-optional-bag_count_sum&#34;&gt;Exercise: 3 stars, standard, optional (bag_count_sum)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem count_sum : forall (v : nat) (l1 l2 : bag),
  count v l1 + count v l2 = count v (sum l1 l2).
Proof.
  intros v l1 l2.
  induction l1 as [| n l1&#39; IHl1&#39;].
  - reflexivity.
  - simpl.
    destruct (v =? n) as [].
    + simpl. rewrite IHl1&#39;. reflexivity.
    + rewrite IHl1&#39;. reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这题一个值得注意的细节是：我们不方便利用 destruct 直接去讨论 n 是否等于 v，但我们可以通过讨论 &lt;code&gt;v =? n&lt;/code&gt; 是 true 还是 false 来实现这一需求。&lt;/p&gt;
&lt;h3 id=&#34;exercise-3-stars-advanced-involution_injective&#34;&gt;Exercise: 3 stars, advanced (involution_injective)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem involution_injective : forall (f : nat -&amp;gt; nat),
    (forall n : nat, n = f (f n)) -&amp;gt; (forall n1 n2 : nat, f n1 = f n2 -&amp;gt; n1 = n2).
Proof.
  intros f H1 n1 n2 H2.
  rewrite H1.
  rewrite &amp;lt;- H2.
  rewrite &amp;lt;- H1.
  reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-2-stars-advanced-rev_injective&#34;&gt;Exercise: 2 stars, advanced (rev_injective)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem rev_injective : forall (l1 l2 : natlist),
  rev l1 = rev l2 -&amp;gt; l1 = l2.
Proof.
  intros l1 l2 H.
  rewrite &amp;lt;- rev_involutive.
  rewrite &amp;lt;- H.
  rewrite rev_involutive.
  reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该定理的证明具有一定的技巧性。如果直接对某个链表使用归纳法会比较繁琐。这里利用 involutive 定理 &lt;code&gt;l = rev (rev l)&lt;/code&gt;先把 &lt;code&gt;l2&lt;/code&gt; 换成 &lt;code&gt;rev (rev l2)&lt;/code&gt;，再利用条件把 &lt;code&gt;rev l2&lt;/code&gt; 换成 &lt;code&gt;rev l1&lt;/code&gt;，最后换一个方向利用 involutive 完成证明。&lt;/p&gt;
&lt;h3 id=&#34;exercise-2-stars-standard-hd_error&#34;&gt;Exercise: 2 stars, standard (hd_error)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition hd_error (l : natlist) : natoption :=
  match l with
  | nil =&amp;gt; None
  | h :: t =&amp;gt; (Some h)
  end.

Example test_hd_error1 : hd_error [] = None.
Proof. reflexivity. Qed.

Example test_hd_error2 : hd_error [1] = Some 1.
Proof. reflexivity. Qed.

Example test_hd_error3 : hd_error [5;6] = Some 5.
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-1-star-standard-optional-option_elim_hd&#34;&gt;Exercise: 1 star, standard, optional (option_elim_hd)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem option_elim_hd : forall (l:natlist) (default:nat),
  hd default l = option_elim default (hd_error l).
Proof.
  intros l d.
  destruct l as [| h l&#39;] eqn:L.
  - reflexivity.
  - reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-1-star-standard-eqb_id_refl&#34;&gt;Exercise: 1 star, standard (eqb_id_refl)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem eqb_id_refl : forall x, eqb_id x x = true.
Proof.
  intros x.
  destruct x as [n].
  simpl.
  rewrite eqb_refl.
  reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-1-star-standard-update_eq&#34;&gt;Exercise: 1 star, standard (update_eq)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem update_eq :
  forall (d : partial_map) (x : id) (v: nat),
    find x (update d x v) = Some v.
Proof.
  intros d x v.
  simpl.
  destruct x as [x&#39;].
  simpl.
  rewrite eqb_refl.
  reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-1-star-standard-update_neq&#34;&gt;Exercise: 1 star, standard (update_neq)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem update_neq :
  forall (d : partial_map) (x y : id) (o: nat),
    eqb_id x y = false -&amp;gt; find x (update d y o) = find x d.
Proof.
  intros d x y o H.
  simpl.
  rewrite H.
  reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Polymorphism and Higher-Order Functions</title>
      <link>https://kristoff-starling.github.io/posts/booknotes/softwarefoundations/lf/poly/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://kristoff-starling.github.io/posts/booknotes/softwarefoundations/lf/poly/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#polymorphism&#34;&gt;Polymorphism&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#polymorphic-lists&#34;&gt;Polymorphic Lists&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#type-annotation-inference&#34;&gt;Type Annotation Inference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#type-argument-synthesis&#34;&gt;Type Argument Synthesis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#implicit-arguments&#34;&gt;Implicit Arguments&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#supplying-type-arguments-explicitly&#34;&gt;Supplying Type Arguments Explicitly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#polymorphic-pairs&#34;&gt;Polymorphic Pairs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#polymorphic-options&#34;&gt;Polymorphic Options&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#functions-as-data&#34;&gt;Functions as Data&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#higher-order-functions&#34;&gt;Higher-Order Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#filter&#34;&gt;Filter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#anonymous-functions&#34;&gt;Anonymous Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#maps&#34;&gt;Maps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#fold&#34;&gt;Fold&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#functions-that-construct-functions&#34;&gt;Functions That Construct Functions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercises&#34;&gt;Exercises&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-2-stars-standard-optional-mumble_grumble&#34;&gt;Exercise: 2 stars, standard, optional (mumble_grumble)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-1-star-standard-optional-combine_checks&#34;&gt;Exercise: 1 star, standard, optional (combine_checks)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-2-stars-standard-especially-useful-split&#34;&gt;Exercise: 2 stars, standard, especially useful (split)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-1-star-standard-optional-hd_error_poly&#34;&gt;Exercise: 1 star, standard, optional (hd_error_poly)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-2-stars-standard-filter_even_gt7&#34;&gt;Exercise: 2 stars, standard (filter_even_gt7)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-3-stars-standard-partition&#34;&gt;Exercise: 3 stars, standard (partition)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-3-stars-standard-map_rev&#34;&gt;Exercise: 3 stars, standard (map_rev)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-2-stars-standard-especially-useful-flat_map&#34;&gt;Exercise: 2 stars, standard, especially useful (flat_map)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-1-star-standard-optional-fold_types_different&#34;&gt;Exercise: 1 star, standard, optional (fold_types_different)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-2-stars-standard-fold_length&#34;&gt;Exercise: 2 stars, standard (fold_length)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-3-stars-standard-fold_map&#34;&gt;Exercise: 3 stars, standard (fold_map)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-2-stars-advanced-currying&#34;&gt;Exercise: 2 stars, advanced (currying)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#church-numerals-advanced&#34;&gt;Church Numerals (Advanced)&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-2-stars-advanced-church_scc&#34;&gt;Exercise: 2 stars, advanced (church_scc)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-3-stars-advanced-church_plus&#34;&gt;Exercise: 3 stars, advanced (church_plus)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-3-stars-advanced-church_mult&#34;&gt;Exercise: 3 stars, advanced (church_mult)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#exercise-3-stars-advanced-church_exp&#34;&gt;Exercise: 3 stars, advanced (church_exp)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一章节我们主要关注函数式编程的两个基本概念：多态 (polymorphism)，即对函数操作的对象的类型进行抽象；高阶函数，即将函数本身看作数据。&lt;/p&gt;
&lt;h2 id=&#34;polymorphism&#34;&gt;Polymorphism&lt;/h2&gt;
&lt;h3 id=&#34;polymorphic-lists&#34;&gt;Polymorphic Lists&lt;/h3&gt;
&lt;p&gt;上一章节中我们定义的列表只能处理自然数。在真正的程序中列表中的元素类型是丰富的，甚至可以有 list of lists。我们不可能对每种类型都定义一种列表——因为我们不仅要定义类型，还要将列表相关的所有定理对每种类型都证明一遍，这几乎是不可能的。&lt;/p&gt;
&lt;p&gt;基于以上需求，Coq 支持了 polymorphic 的 inductive type definition。比如下面是一个多态的 list 类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Inductive list (X : Type) : Type :=
  | nil
  | cons (x : X) (l : list X).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多态的本质很简单：我们之前定义的类型以归纳的方式描述了一个集合，现在 list 是一个 Type -&amp;gt; Type 的函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Check list: Type -&amp;gt; Type
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它接收一个类型 X 作为参数，返回 list X 这个类型，“list X” 类型是一个包含了所有由 X 类型元素构成的链表的集合。&lt;/p&gt;
&lt;p&gt;list 定义中的类型 X 会自动成为 constructor 的参数——即现在 nil 和 con 都是多态 constructor，以后使用它们时需要在后面写上类型。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Check (cons nat 3 (nil nat)) : list nat.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;nil 和 cons 的类型也都是从 Type 映射到 list X 的“函数”：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Check nil : forall X : Type, list X.
Check cons: forall X : Type, X -&amp;gt; list X -&amp;gt; list X.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了多态的列表定义后，我们可以把之前写的函数也改成多态的。下面以 repeat 为例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint repeat (X : Type) (x : X) (count : nat) : list X :=
  match count with
  | 0 =&amp;gt; nil X
  | S count&#39; =&amp;gt; cons X x (repeat X x count&#39;)
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;type-annotation-inference&#34;&gt;Type Annotation Inference&lt;/h4&gt;
&lt;p&gt;如果我们在书写函数时不显式声明参数的类型，例如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint repeat&#39; X x count : list X :=
  match count with
  | 0 =&amp;gt; nil X
  | S count&#39; =&amp;gt; cons X x (repeat X x count&#39;)
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们会发现 &lt;code&gt;Check repeat&lt;/code&gt; 和 &lt;code&gt;Check repeat&#39;&lt;/code&gt; 的结果是完全一样的。这是因为 Coq 可以自动进行 type inference，例如根据 count match 的方法可以看出 count 一定是 nat 类型等等。&lt;/p&gt;
&lt;h4 id=&#34;type-argument-synthesis&#34;&gt;Type Argument Synthesis&lt;/h4&gt;
&lt;p&gt;synthesis 和 inference 的原理类似：在某些地方你可以直接用 &lt;code&gt;_&lt;/code&gt; 来代替类型名，Coq 会结合所有的上下文信息自动分析出这里该填写什么。例如下面两句代码在功能上是等价的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition list123 := cons nat 1 (cons nat 2 (cons nat 3 (nil nat))).
Definition list123&#39; := cons _ 1 (cons _ 2 (cons _ 3 (nil _))).
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;implicit-arguments&#34;&gt;Implicit Arguments&lt;/h4&gt;
&lt;p&gt;利用 implicit argument 技术，我们甚至可以将 &lt;code&gt;_&lt;/code&gt; 省略掉。&lt;/p&gt;
&lt;p&gt;第一种方法是使用 Arguments 语法：Arguments 可以指定一个函数/constructor的名字，以及需要被处理为 implicit 的类型名，以后再使用该函数/constructor时就不需要再显式地给出类型名或类型名的占位符。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Arguments nil {X}.
Arguments cons {X}.
Arguments repeat {X}.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时我们定义 list123 就可以直接写：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition list123&#39;&#39; := cons 1 (cons 2 (cons 3 nil)).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种更方便的语法是：我们在定义 Type/函数的时候，可以用 &lt;code&gt;{}&lt;/code&gt; 代替 &lt;code&gt;()&lt;/code&gt; 把用于多态的类型名框起来，这样以后自动省略类型名参数。下面我们用这种语法把 list 的其他几个重要函数重写一下，可以看到使用了 implicit arguments 后，函数体内部的代码就和之前的没有区别了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint app {X : Type} (l1 l2 : list X) : list X :=
  match l1 with
  | nil =&amp;gt; l2
  | cons h t =&amp;gt; cons h (app t l2)  (* 注意我们还没有对多态的list定义::等notation，所以现在还不能
                                      用 h::t 的方式书写，一会儿定义了之后就可以了*)
  end.

Fixpoint rev {X : Type} (l : list X) : list X :=
  match l with
  | nil =&amp;gt; nil
  | cons h t =&amp;gt; app (rev t) (cons h nil)
  end.

Fixpoint length {X : Type} (l : list X) : list X :=
  match l with
  | nil =&amp;gt; 0
  | cons h t =&amp;gt; 1 + (length t)
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;supplying-type-arguments-explicitly&#34;&gt;Supplying Type Arguments Explicitly&lt;/h4&gt;
&lt;p&gt;将参数定义为隐式的一个坏处在于，某些特殊情况下 Coq 可能无法自动识别参数类型。这种情况下我们需要临时地显式给出参数类型。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fail Definition mynil := nil.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（注：这里的 Fail 命令表示如果后面的语句执行失败，Coq 会在交互区打印出错误信息，但程序仍然可以继续执行。）&lt;/p&gt;
&lt;p&gt;这样的定义是不成立的，因为完全没有上下文信息可以看出 nil X 的 X 是什么类型。我们有两种解决方法，一种是显式地指定 mynil 的类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition mynil : list nat := nil.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种是使用 &lt;code&gt;@&lt;/code&gt; 让 nil 临时显式地接收一个类型参数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition mynil&#39; := @nil nat.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们定义的多态 list 和之前的 list 本质上是两种类型，因此所有的 Notation 我们也要重新定义一遍：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Notation &amp;quot;x :: y&amp;quot; := (cons x y)
                     (at level 60, right associativity).
Notation &amp;quot;[ ]&amp;quot; := nil.
Notation &amp;quot;[ x ; .. ; y ]&amp;quot; := (cons x .. (cons y []) ..).
Notation &amp;quot;x ++ y&amp;quot; := (app x y)
                     (at level 60, right associativity).
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;polymorphic-pairs&#34;&gt;Polymorphic Pairs&lt;/h3&gt;
&lt;p&gt;在上一章节中我们定义的两个自然数的 pair 也可以拓展成多态的 pair，这就是离散数学中的笛卡尔积：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Inductive prod (X Y : Type) : Type :=
  | pair (x : X) (y : Y).
Argument pair {X} {Y}.

Notation &amp;quot;( x, y )&amp;quot; := (pair x y).
Notation &amp;quot;X * Y&amp;quot; := (prod X Y) : type_scope.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的 &amp;ldquo;type_scope&amp;rdquo; 表明了笛卡尔积只作用在两个类型 (集合) 上，避免和自然数上的乘法混淆。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(x, y)&lt;/code&gt; 和 &lt;code&gt;X * Y&lt;/code&gt; 在初期容易混淆。一个好的理解方式是：&lt;code&gt;X * Y&lt;/code&gt; 是一个类型，即一个集合。如果 &lt;code&gt;x&lt;/code&gt; 的类型是 &lt;code&gt;X&lt;/code&gt;，&lt;code&gt;y&lt;/code&gt; 的类型是 &lt;code&gt;Y&lt;/code&gt;，那么 &lt;code&gt;(x, y)&lt;/code&gt; 是类型 &lt;code&gt;X * Y&lt;/code&gt; 的一个实例 (集合 &lt;code&gt;X * Y&lt;/code&gt; 中的一个元素)。&lt;/p&gt;
&lt;p&gt;下面的函数 combine 接收两个 list，返回一个把对应 index 元素打包成 pair 的 list。这个函数在通常的编程语言中称为 &lt;code&gt;zip()&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint combine {X, Y : Type} (l1 : list X) (l2 : list Y) -&amp;gt; list (X * Y) :=
  match lx, ly with
  | nil, _ =&amp;gt; nil
  | _, nil =&amp;gt; nil
  | x :: tx, y :: ty =&amp;gt; (x, y) :: (combine tx ty)
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;polymorphic-options&#34;&gt;Polymorphic Options&lt;/h3&gt;
&lt;p&gt;对于之前定义的 natoption，我们也将其转化为多态：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Inductive option (X : Type) : Type :=
  | Some (x : X)
  | None.

Arguments Some {X}.
Arguments None {X}.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后我们可以将 &lt;code&gt;nth_error&lt;/code&gt; 函数也转化为多态：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint nth_error {X : Type} (l : list X) (n : nat) : option X :=
  match l with
  | nil =&amp;gt; None
  | a :: l&#39; =&amp;gt; match n with
               | 0 =&amp;gt; a
               | S n&#39; =&amp;gt; nth_error l&#39; n&#39;
               end
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;functions-as-data&#34;&gt;Functions as Data&lt;/h2&gt;
&lt;p&gt;和多数函数式编程语言一样，Coq 将函数视为 first-class citizen，即函数可以作为函数参数，可以作为函数返回值，可以作为数据存储在数据结构中。&lt;/p&gt;
&lt;h3 id=&#34;higher-order-functions&#34;&gt;Higher-Order Functions&lt;/h3&gt;
&lt;p&gt;下面是一个简单的接受函数作为参数的高阶函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition doit3times {X : Type} (f : X -&amp;gt; X) (n : X) : X :=
  f (f (f n)).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数 &lt;code&gt;f&lt;/code&gt; 是一个从 X 映射到 X 的函数，我们可以检查 &lt;code&gt;doit3times&lt;/code&gt; 的类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Check @doit3times : forall X : Type, (X -&amp;gt; X) -&amp;gt; X -&amp;gt; X.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;filter&#34;&gt;Filter&lt;/h3&gt;
&lt;p&gt;下面展示一个更有意思的高阶函数：&lt;code&gt;filter&lt;/code&gt; 函数接收一个函数 test 和一个 list，返回一个新的 list，其中包含原 list 中通过 test 测试的元素：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint filter {X : Type} (test : X -&amp;gt; bool) (l : list X) : list X :=
  match l with
  | nil =&amp;gt; nil
  | h :: t =&amp;gt;
    if test h then h :: (filter test t)
    else filter test t
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多态的 list 可以接收任何类型的元素，甚至是 list 自己，形成 list of lists，下面是一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition length_is_1 {X : Type} (l : list X) : bool :=
  (length l) =? 1.

Example test_filter :
  filter length_is_1 [ [1; 2]; [3]; [4]; [5; 6; 7]; []; [8] ] = [ [3]; [4]; [8]; ].
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;anonymous-functions&#34;&gt;Anonymous Functions&lt;/h3&gt;
&lt;p&gt;有的时候，必须给函数命名以方便使用是一件令人沮丧的事情，因为很多时候我们只是想临时创建一个函数丢给高阶函数当参数使用，比如上面例子中的 &lt;code&gt;length_is_1&lt;/code&gt;。Coq 为我们提供了一种临时创建函数的方式，这种方式类似于 Python 中的 lambda 表达式，不需要给函数命名，该函数也不会出现在 top level environment 中。下面是一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Example test_filter&#39; :
  filter (fun l =&amp;gt; (length l) =? 1)
         [ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ]
  = [ [3]; [4]; [8] ].
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;(fun l =&amp;gt; (length l) =? 1)&lt;/code&gt; 的意思是该函数接收一个参数 &lt;code&gt;l&lt;/code&gt;，返回 &lt;code&gt;(length l) =? 1&lt;/code&gt; (我们可以不指明参数和返回值的类型，Coq 会自己做 type inference)。&lt;/p&gt;
&lt;h3 id=&#34;maps&#34;&gt;Maps&lt;/h3&gt;
&lt;p&gt;map 也是许多函数式语言支持的常用高阶函数。它接收一个转换函数 f 和一个列表 l，返回一个新列表，其内容是把 f 作用到 l 里的每个元素后的结果。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint map {X Y : Type} (f : X -&amp;gt; Y) (l : list X) : list Y :=
  match l with
  | nil =&amp;gt; nil
  | h :: t =&amp;gt; (f h) :: (map f t)
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;值得注意的是传入的列表的元素类型和返回的列表的元素类型不一定一样。&lt;/p&gt;
&lt;p&gt;我们不仅可以对 list 做 map，也可以对其他的数据类型做 map，比如下面的例子对 option 做 map：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition option_map {X Y : Type} (f : X -&amp;gt; Y) (xo : option X) : option Y :=
  match xo with
  | None =&amp;gt; None
  | Some x =&amp;gt; Some (f x)
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;fold&#34;&gt;Fold&lt;/h3&gt;
&lt;p&gt;一个更加强大的高阶函数是 fold，它是 Google map-reduced 框架的 reduce 函数的灵感来源：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint fold {X Y : Type} (f : X -&amp;gt; Y -&amp;gt; Y) (l : list X) (b : Y) : Y :=
  match l with
  | nil =&amp;gt; b
  | h :: t =&amp;gt; f h (fold f t b)
  end.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从直观上来理解，该函数接收函数 f，列表 l 和初始值 b。然后从初始值 b 开始，把列表中的元素按照从右往左的顺序依次与 type Y 的结果做函数 f 操作。比如 &lt;code&gt;fold plus [1; 2; 3; 4] 0&lt;/code&gt; 就意味着 &lt;code&gt;1+(2+(3+(4+0)))&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;functions-that-construct-functions&#34;&gt;Functions That Construct Functions&lt;/h3&gt;
&lt;p&gt;我们之前讨论的高阶函数都是将函数作为参数传入，我们在这里看一些将函数作为函数返回值的例子。下面是一个比较 dummy 的例子，constfun 返回的函数不论接收什么都会输出固定值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition constfun {X : Type} (x : X) : nat -&amp;gt; X :=
  fun (k : nat) =&amp;gt; x.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;事实上，函数式编程本质上不支持多参数的函数，我们之前看到的多参数的函数都是通过 currying 完成的。以 plus 为例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Check plus : nat -&amp;gt; nat -&amp;gt; nat.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的 &lt;code&gt;-&amp;gt;&lt;/code&gt; 可以理解为作用在 type 类型元素上的一种二元运算符，它是 right associative 的，即 plus 的类型实际上是 &lt;code&gt;nat -&amp;gt; (nat -&amp;gt; nat)&lt;/code&gt;。我们使用 plus 时都给它传两个参数，但实际上传一个也是可以的，按照 &lt;code&gt;nat -&amp;gt; (nat -&amp;gt; nat)&lt;/code&gt;，plus 可以被理解为 “这是一个函数，它接收一个加数，返回另一个函数，这个返回的函数接收另一个加数作为参数，返回加法的结果”。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition plus3 := plus 3
Check plus3 : nat -&amp;gt; nat.

Example test_plus3 : plus3 4 = 7.
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种给 currying 的函数传一个参数的手法称为 partial application。&lt;/p&gt;
&lt;h2 id=&#34;exercises&#34;&gt;Exercises&lt;/h2&gt;
&lt;h3 id=&#34;exercise-2-stars-standard-optional-mumble_grumble&#34;&gt;Exercise: 2 stars, standard, optional (mumble_grumble)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;d (b a 5)           (* NO, the first argument of d should be a type *)
d mumble (b a 5)    (* YES, grumble mumble *)
d bool (b a 5)      (* YES, grumble bool   *)
e bool true         (* YES, grumble bool   *)
e mumble (b c 0)    (* YES, grumble mumble *)
e bool (b c 0)      (* NO, the second argument shoule be type bool *)
c                   (* YES, mumble *)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-1-star-standard-optional-combine_checks&#34;&gt;Exercise: 1 star, standard, optional (combine_checks)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Check @combine : forall X Y : Type, list X -&amp;gt; list Y -&amp;gt; list (X * Y).
Compute (combine [1; 2] [false; false; true; true]).
  (* [(1, false); (2, false)] *)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-2-stars-standard-especially-useful-split&#34;&gt;Exercise: 2 stars, standard, especially useful (split)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint split {X Y : Type} (l : list (X*Y)) : (list X) * (list Y) :=
  match l with
  | nil =&amp;gt; (nil, nil)
  | (x, y) :: l&#39; =&amp;gt; (x :: fst (split l&#39;), y :: snd (split l&#39;))
  end.

Example test_split:
  split [(1,false);(2,false)] = ([1;2],[false;false]).
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-1-star-standard-optional-hd_error_poly&#34;&gt;Exercise: 1 star, standard, optional (hd_error_poly)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition hd_error {X : Type} (l : list X) : option X :=
  match l with
  | nil =&amp;gt; None
  | h :: t =&amp;gt; Some h
  end.

Check @hd_error : forall X : Type, list X -&amp;gt; option X.

Example test_hd_error1 : hd_error [1;2] = Some 1.
Proof. reflexivity. Qed.
Example test_hd_error2 : hd_error  [[1];[2]]  = Some [1].
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-2-stars-standard-filter_even_gt7&#34;&gt;Exercise: 2 stars, standard (filter_even_gt7)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition filter_even_gt7 (l : list nat) : list nat :=
  filter (fun n =&amp;gt; (even n) &amp;amp;&amp;amp; (8 &amp;lt;=? n)) l.

Example test_filter_even_gt7_1 :
  filter_even_gt7 [1;2;6;9;10;3;12;8] = [10;12;8].
Proof. reflexivity. Qed.

Example test_filter_even_gt7_2 :
  filter_even_gt7 [5;2;6;19;129] = [].
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-3-stars-standard-partition&#34;&gt;Exercise: 3 stars, standard (partition)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition partition {X : Type}
                     (test : X -&amp;gt; bool)
                     (l : list X)
                   : list X * list X :=
  ((filter test l), (filter (fun x =&amp;gt; negb(test x)) l)).

Example test_partition1: partition odd [1;2;3;4;5] = ([1;3;5], [2;4]).
Proof. reflexivity. Qed.
Example test_partition2: partition (fun x =&amp;gt; false) [5;9;0] = ([], [5;9;0]).
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-3-stars-standard-map_rev&#34;&gt;Exercise: 3 stars, standard (map_rev)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Lemma app_map : forall (X Y : Type) (f : X -&amp;gt; Y) (l1 l2 : list X),
  map f (l1 ++ l2) = (map f l1) ++ (map f l2).
Proof.
  intros X Y f l1 l2.
  induction l1 as [| n l1&#39; IHl1&#39;].
  - reflexivity.
  - simpl. rewrite IHl1&#39;. reflexivity.
Qed.

Theorem map_rev : forall (X Y : Type) (f : X -&amp;gt; Y) (l : list X),
  map f (rev l) = rev (map f l).
Proof.
  intros X Y f l.
  induction l as [| n l&#39; IHl&#39;].
  - reflexivity.
  - simpl. 
    rewrite &amp;lt;- IHl&#39;.
    rewrite app_map.
    reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在证明主要定理之前，需要先证明一个和列表 append 相关的引理。&lt;/p&gt;
&lt;h3 id=&#34;exercise-2-stars-standard-especially-useful-flat_map&#34;&gt;Exercise: 2 stars, standard, especially useful (flat_map)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Fixpoint flat_map {X Y: Type} (f: X -&amp;gt; list Y) (l: list X)
                   : list Y :=
  match l with
  | nil =&amp;gt; nil
  | h :: t =&amp;gt; (f h) ++ (flat_map f t)
  end.

Example test_flat_map1:
  flat_map (fun n =&amp;gt; [n;n;n]) [1;5;4]
  = [1; 1; 1; 5; 5; 5; 4; 4; 4].
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-1-star-standard-optional-fold_types_different&#34;&gt;Exercise: 1 star, standard, optional (fold_types_different)&lt;/h3&gt;
&lt;p&gt;fold 参数中的函数 f 的类型是 &lt;code&gt;f : X -&amp;gt; Y -&amp;gt; Y&lt;/code&gt;，X 和 Y 不同的情况也是很有用的，比如传入的 list 是一系列动作 (上下左右)，b 是一个初始位置，那么使用 fold 函数就可以得出做完这一系列移动后的最终位置。&lt;/p&gt;
&lt;h3 id=&#34;exercise-2-stars-standard-fold_length&#34;&gt;Exercise: 2 stars, standard (fold_length)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem fold_length_correct : forall X (l : list X),
  fold_length l = length l.
Proof.
  intros X l.
  induction l as [|n l&#39; IHl&#39;].
  - reflexivity.
  - simpl.
    rewrite &amp;lt;- IHl&#39;.
    reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段证明有一个值得关注的细节：在 successor case 的最后一步之前，证明的 goal 是&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;fold_length (n :: l&#39;) = S (fold_length l&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这一步使用 &lt;code&gt;simpl.&lt;/code&gt; 无法化简，但我们知道根据 fold_length 的定义这一步是可以化简的，事实上使用 &lt;code&gt;reflexivity.&lt;/code&gt; 就可以直接解决问题。reflexivity 使用了更加 aggressive 的化简方法，有时卡壳时可以一试。&lt;/p&gt;
&lt;h3 id=&#34;exercise-3-stars-standard-fold_map&#34;&gt;Exercise: 3 stars, standard (fold_map)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition fold_map {X Y: Type} (f: X -&amp;gt; Y) (l: list X) : list Y :=
  fold (fun x l =&amp;gt; [f x] ++ l) l nil.

Theorem fold_map_correct : forall (X Y : Type) (f : X -&amp;gt; Y) (l : list X),
  fold_map f l = map f l.
Proof.
  intros X Y f l.
  induction l as [| n l&#39; IHl&#39;].
  - reflexivity.
  - simpl.
    rewrite &amp;lt;- IHl&#39;.
    reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;exercise-2-stars-advanced-currying&#34;&gt;Exercise: 2 stars, advanced (currying)&lt;/h3&gt;
&lt;p&gt;将一个 &lt;code&gt;(X * Y) -&amp;gt; Z&lt;/code&gt; 类型的函数转换为 &lt;code&gt;X -&amp;gt; (Y -&amp;gt; Z)&lt;/code&gt; 类型的函数的过程称为 currying，反过来称为 uncurrying。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition prod_uncurry {X Y Z : Type}
  (f : X -&amp;gt; Y -&amp;gt; Z) (p : X * Y) : Z := (f (fst p))(snd p).
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Theorem uncurry_curry : forall (X Y Z : Type)
                        (f : X -&amp;gt; Y -&amp;gt; Z)
                        x y,
  prod_curry (prod_uncurry f) x y = f x y.
Proof.
  intros X Y Z f x y.
  reflexivity.
Qed.

Theorem curry_uncurry : forall (X Y Z : Type)
                        (f : (X * Y) -&amp;gt; Z) (p : X * Y),
  prod_uncurry (prod_curry f) p = f p.
Proof.
  intros X Y Z f p.
  destruct p as [n m].
  reflexivity.
Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;prod_uncurry f&lt;/code&gt; 接收了一个 &lt;code&gt;X -&amp;gt; Y -&amp;gt; Z&lt;/code&gt; 类型的函数参数，返回了一个 &lt;code&gt;(X * Y) -&amp;gt; Z &lt;/code&gt; 类型的参数。&lt;code&gt;prod_curry&lt;/code&gt; 正好相反。&lt;/p&gt;
&lt;p&gt;注意第二个证明中，由于我们定义 &lt;code&gt;prod_uncurry&lt;/code&gt; 时使用了 &lt;code&gt;fst&lt;/code&gt; 和 &lt;code&gt;snd&lt;/code&gt;，所以使用 reflexivity 之前要先用 destruct 把 pair p 给展开。&lt;/p&gt;
&lt;h3 id=&#34;church-numerals-advanced&#34;&gt;Church Numerals (Advanced)&lt;/h3&gt;
&lt;h4 id=&#34;exercise-2-stars-advanced-church_scc&#34;&gt;Exercise: 2 stars, advanced (church_scc)&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition scc (n : cnat) : cnat :=
  fun (X : Type) (f : X -&amp;gt; X) (x : X) =&amp;gt; n X f (f x).
Example scc_1 : scc zero = one.
Proof. reflexivity. Qed.

Example scc_2 : scc one = two.
Proof. reflexivity. Qed.

Example scc_3 : scc two = three.
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;exercise-3-stars-advanced-church_plus&#34;&gt;Exercise: 3 stars, advanced (church_plus)&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition plus (n m : cnat) : cnat :=
  fun (X : Type) (f : X -&amp;gt; X) (x : X) =&amp;gt; m X f (n X f x).

Example plus_1 : plus zero one = one.
Proof. reflexivity. Qed.

Example plus_2 : plus two three = plus three two.
Proof. reflexivity. Qed.

Example plus_3 :
  plus (plus two two) three = plus one (plus three three).
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;exercise-3-stars-advanced-church_mult&#34;&gt;Exercise: 3 stars, advanced (church_mult)&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition mult (n m : cnat) : cnat :=
  fun (X : Type) (f : X -&amp;gt; X) (x : X) =&amp;gt; n X (m X f) x. 

Example mult_1 : mult one one = one.
Proof. reflexivity. Qed.

Example mult_2 : mult zero (plus three three) = zero.
Proof. reflexivity. Qed.

Example mult_3 : mult two three = plus three three.
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;exercise-3-stars-advanced-church_exp&#34;&gt;Exercise: 3 stars, advanced (church_exp)&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-plaintext&#34;&gt;Definition exp (n m : cnat) : cnat :=
  fun (X : Type) (f : X -&amp;gt; X) (x : X) =&amp;gt; (m (X -&amp;gt; X) (n X) f) x.

Example exp_1 : exp two two = plus two two.
Proof. reflexivity. Qed.

Example exp_2 : exp three zero = one.
Proof. reflexivity. Qed.

Example exp_3 : exp three two = plus (mult two (mult two two)) one.
Proof. reflexivity. Qed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于 church numeral 可以参考 UCB CS61A 的作业。这里额外再对乘方函数做一点解读，因为其结构比较复杂。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n X&lt;/code&gt; 的类型是 &lt;code&gt;(X -&amp;gt; X) -&amp;gt; X -&amp;gt; X&lt;/code&gt;，根据 &lt;code&gt;-&amp;gt;&lt;/code&gt; right associativity 的性质也可以看作 &lt;code&gt;(X -&amp;gt; X) -&amp;gt; (X -&amp;gt; X)&lt;/code&gt;，即传给它一个 &lt;code&gt;X -&amp;gt; X&lt;/code&gt; 的函数，它会返回另一个 &lt;code&gt;X -&amp;gt; X&lt;/code&gt; 的函数。这里我们将 &lt;code&gt;f&lt;/code&gt; 作为底层参数传给 m，可以认为整个操作提高了一阶，我们不是将一个 &lt;code&gt;X -&amp;gt; X&lt;/code&gt; 的函数作用在元素 &lt;code&gt;X&lt;/code&gt; 上 m 次，而是将一个 &lt;code&gt;(X -&amp;gt; X) -&amp;gt; (X -&amp;gt; X)&lt;/code&gt; 的函数作用在函数 &lt;code&gt;f&lt;/code&gt; 上 m 次，这个作用函数的语义又恰好是将接收的函数参数重复 n 次，所以就形成了 $1 \to n \to n^2 \to \cdots \to n^m $ 的格局。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
