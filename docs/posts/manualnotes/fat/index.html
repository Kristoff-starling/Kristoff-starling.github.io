<!DOCTYPE html>
<html lang="en-us">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academic 4.8.0">

  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="Yuyao Wang">

  
  
  
    
  
  <meta name="description" content="该笔记是对 Microsoft Fat Specification 的精华部分的翻译和解读。">

  
  <link rel="alternate" hreflang="en-us" href="https://kristoff-starling.github.io/posts/manualnotes/fat/">

  


  
  
  
  <meta name="theme-color" content="#2962ff">
  

  
  
  
  <script src="/js/mathjax-config.js"></script>
  

  
  
  
  
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-1/css/all.min.css" integrity="sha256-4w9DunooKSr3MFXHXWyFER38WmPdm361bQS/2KUWZbU=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin="anonymous" title="hl-light">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" disabled>
        
      
    

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.css" integrity="sha256-SHMGCYmST46SoyGgo4YR/9AlK1vf3ff84Aq9yK4hdqM=" crossorigin="anonymous">
    

    

    
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.1.2/lazysizes.min.js" integrity="sha256-Md1qLToewPeKjfAHU1zyPwOutccPAm5tahnaw7Osw0A=" crossorigin="anonymous" async></script>
      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" integrity="" crossorigin="anonymous" async></script>
      
    
      

      
      

      
    

  

  
  
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:400,700%7CRoboto:400,400italic,700%7CRoboto+Mono&display=swap">
  

  
  
  
  
  <link rel="stylesheet" href="/css/academic.css">

  




  


  

  <link rel="manifest" href="/index.webmanifest">
  <link rel="icon" type="image/png" href="/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_32x32_fill_lanczos_center_3.png">
  <link rel="apple-touch-icon" type="image/png" href="/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_192x192_fill_lanczos_center_3.png">

  <link rel="canonical" href="https://kristoff-starling.github.io/posts/manualnotes/fat/">

  
  
  
  
  
    
    
  
  
  <meta property="twitter:card" content="summary">
  
  <meta property="og:site_name" content="Academic">
  <meta property="og:url" content="https://kristoff-starling.github.io/posts/manualnotes/fat/">
  <meta property="og:title" content="FAT Specification - Notes | Academic">
  <meta property="og:description" content="该笔记是对 Microsoft Fat Specification 的精华部分的翻译和解读。"><meta property="og:image" content="img/map[gravatar:%!s(bool=false) shape:circle]">
  <meta property="twitter:image" content="img/map[gravatar:%!s(bool=false) shape:circle]"><meta property="og:locale" content="en-us">
  
    
      <meta property="article:published_time" content="2022-06-14T00:00:00&#43;00:00">
    
    <meta property="article:modified_time" content="2022-06-14T00:00:00&#43;00:00">
  

  



  


  


  





  <title>FAT Specification - Notes | Academic</title>

  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</head>

<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" >

  <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search">
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>


  







<nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
  <div class="container">

    
    <div class="d-none d-lg-inline-flex">
      <a class="navbar-brand" href="/">Academic</a>
    </div>
    

    
    <button type="button" class="navbar-toggler" data-toggle="collapse"
            data-target="#navbar-content" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span><i class="fas fa-bars"></i></span>
    </button>
    

    
    <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
      <a class="navbar-brand" href="/">Academic</a>
    </div>
    

    
    
    <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

      
      <ul class="navbar-nav d-md-inline-flex">
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link  active" href="/posts"><span>Posts</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link " href="/courses"><span>Courses</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link " href="/literature"><span>Literature</span></a>
        </li>

        
        

      

        
      </ul>
    </div>

    <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">
      
      <li class="nav-item">
        <a class="nav-link js-search" href="#"><i class="fas fa-search" aria-hidden="true"></i></a>
      </li>
      

      
      <li class="nav-item">
        <a class="nav-link js-dark-toggle" href="#"><i class="fas fa-moon" aria-hidden="true"></i></a>
      </li>
      

      

    </ul>

  </div>
</nav>


  <article class="article">

  












  

  
  
  
<div class="article-container pt-3">
  <h1>FAT Specification - Notes</h1>

  

  
    


<div class="article-metadata">

  
  

  
  <span class="article-date">
    
    
      
    
    Jun 14, 2022
  </span>
  

  

  

  
  
  

  
  

</div>

    














  
</div>



  <div class="article-container">

    <div class="article-style">
      <p>
<a href="http://jyywiki.cn/pages/OS/manuals/MSFAT-spec.pdf" target="_blank" rel="noopener">Microsoft FAT Specification</a> 的 local copy 见此处。以下是对该手册的精华部分的翻译和解读。</p>
<h2 id="section-1-definitions-and-notations">Section 1: Definitions and Notations</h2>
<p>这里只记录比较重要的定义和记号。<!-- more --></p>
<h3 id="11-definition">1.1 Definition</h3>
<ul>
<li>sector：可以独立于其他单元直接获取的最小单元。</li>
<li>bad(defective) sector：损坏的 sector，其中的内容无法读写。</li>
<li>cluster：一个 cluster 里包含若干个连续的 sector。cluster 是 allocation 的最小单位，为文件分配空间时必须分配整数个 cluster。</li>
<li>volume：一段物理上连续的块地址空间 (可以理解为“全集”)。</li>
<li>partition：分区，volume 中的一部分 sector。</li>
</ul>
<h3 id="12-notations">1.2 Notations</h3>
<p>$ip(x)\triangleq [x],ceil(x)\triangleq\lceil x\rceil,rem(x/y)\triangleq x\space \text{mod}\space y$。</p>
<h2 id="section-2-volume-structure">Section 2: Volume Structure</h2>
<p>FAT 文件系统的结构如下：</p>
<table>
<thead>
<tr>
<th>BPB</th>
<th>&hellip;</th>
<th>BPB</th>
<th>&hellip;</th>
<th>File Allocation Table</th>
<th>FAT copy</th>
<th>Root Directory</th>
<th>Data</th>
<th>&hellip;</th>
<th>Data</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Reserved Region</td>
<td></td>
<td></td>
<td>FAT Region</td>
<td></td>
<td>Root Directory Region (FAT12/FAT16)</td>
<td></td>
<td>File &amp; Directory (Data) Region</td>
<td></td>
</tr>
</tbody>
</table>
<p>FAT 中的数据存储是小端的。</p>
<h2 id="section-3-boot-sector-and-bpb">Section 3: Boot Sector and BPB</h2>
<p>BPB (BIOS Parameter Block) 位于 reserved region 的第一个 sector。这个 sector 也被称为 boot sector 或者 0 号 sector。所有的 FAT 文件系统的 boot sector 中都必须有 BPB。以下的变量中以 <code>BPB_</code> 开头的属于 BPB 的内容，以 <code>BS_</code> 开头的实际上是 boot sector 的内容，不属于 BPB。</p>
<h3 id="31-bpb-structure-common-to-fat12-fat16-and-fat32-implementations">3.1 BPB structure common to FAT12, FAT16, and FAT32 Implementations</h3>
<p>这部分的 BPB 结构是 FAT12, FAT16 和 FAT32 共有的。使用 C 代码可以表示如下 (注：定义结构体时使用 <code>__attribute__((__packed__))</code> 可以不让编译器自动对齐)。</p>
<pre><code class="language-c">struct BPB_common {
    char      BS_jmpBoot[3];   /* 0  */
    char      BS_OEMName[8];   /* 3  */
    uint16_t  BPB_BytsPerSec;  /* 11 */
    uint8_t   BPB_SecPerClus;  /* 13 */
    uint16_t  BPB_RsvdSecCnt;  /* 14 */
    uint8_t   BPB_NumFATs;     /* 16 */
    uint16_t  BPB_RootEntCnt;  /* 17 */
    uint16_t  BPB_TotSec16;    /* 19 */
    uint8_t   BPB_Media;       /* 21 */     
    uint16_t  BPB_FATSz16;     /* 22 */
    uint16_t  BPB_SecPerTrk;   /* 24 */  
    uint16_t  BPB_NumHeads;    /* 26 */ 
    uint32_t  BPB_HiddSec;     /* 28 */
    uint32_t  BPB_TotSec32;    /* 32 */ 
}__attribute__((__packed__));    
</code></pre>
<p>各个字段的解释如下：</p>
<ul>
<li>
<p>BS_jmpBoot：包含了一个 3 个字节的 Inter x86 格式的无条件跳转指令，用于跳转到操作系统的 bootstrap code。boot code 通常位于 boot sector 的尾部，跟在 BPB 后面。两种常见的 jump instruction 的格式为：</p>
<pre><code class="language-c">jmpBoot[0] = 0xEB; jmpBoot[1] = 0x??; jmpBoot[2] = 0x90;
jmpBoot[0] = 0xE9; jmpBoot[1] = 0x??; jmpBoot[2] = 0x??;
</code></pre>
</li>
<li>
<p>BS_OEMName：占 8 个字节，可以在 FAT 的实现中被指定为任何值。其内容通常为格式化该磁盘的系统名称 (比如如果使用 Linux 的 <code>mkfs.fat</code> 命令创建磁盘镜像，该字段就会是 &ldquo;mfks.fat&rdquo;)。</p>
</li>
<li>
<p>BPB_BytsPerSec：每个 sector 的字节数。<u>该值只能是 512, 1024, 2048, 4096 中的一个</u>。</p>
</li>
<li>
<p>BPB_SecPerClus：每个 cluster 的 sector 数。<u>该值必须大于 0 且是 2 的幂次</u>。因为该字段只占一个字节，因此合法的值只有 1, 2, 4, 8, 16, 32, 64, 128。</p>
</li>
<li>
<p>BPB_RsvdSecCnt：reserved region 中的 reserved sector 的个数。该值可以是任何非零整数。通常情况下，这个字段用于使数据区的开头 (即 cluster #2) 地址对齐。</p>
</li>
<li>
<p>BPB_NumFATs：file allocation table 的个数。通常来说 2 是一个比较推荐的数值 (为了防止磁盘受损导致的文件系统损坏)，但 1 也是允许的。</p>
</li>
<li>
<p>BPB_RootEntCnt：对于 FAT12 和 FAT16，该字段表示根目录下 32-byte 目录项的个数，<u><code>BPB_RootEntCnt * 32</code> 理应是 <code>BPB_BytsPerSec</code> 的偶数倍。在 FAT16 中，为了达到最大的兼容性，该值应当设置为 512。对于 FAT32，该值必须是 0</u>。</p>
</li>
<li>
<p>BPB_TotSec16：对于 FAT12 和 FAT16，该字段表示了文件系统中 sector 的数目。该字段只有 2 个字节，如果 sector 的数目大于等于 <code>0x10000</code>，则高位部分会存储到 BPB_TotSec32 中。<u>对于 FAT32，该字段必须是 0</u>。</p>
</li>
<li>
<p>BPB_Media：合法的值有 0xF0, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE 和 0xFF。<u>对于不可移动的固定磁盘，0xF8 是标准值；如果是可移动设备，该字段通常是 0xF0</u>。</p>
</li>
<li>
<p>BPB_FATSz16：对于 FAT12 和 FAT16，该字段表示一个 FAT 中 16-bit sector 的个数。<u>对于 FAT32，该字段必须是 0</u>。</p>
</li>
<li>
<p>BPB_SecPerTrk：该字段只在一些有着特定几何特征 (一个 volume 被划分成多个轨道，有多个读写头) 的设备上有用，表示了每个 track 上 sector 的数目。该字段是为 0x13 号中断准备的。</p>
</li>
<li>
<p>BPB_NumHeads：读写头数量。该字段也是为 0x13 号中断准备的。</p>
</li>
<li>
<p>BPB_HiddSec：该字段表示了这个 FAT 分区后面的隐藏 sector 的数目，也是为 0x13 号中断准备的。<u>对于没有分区的设备，该字段必须为 0</u>。此外，利用该字段来对齐数据区是不正确的。</p>
</li>
<li>
<p>BPB_TotSec32：对于 FAT32，该字段表示了文件系统中 sector 的数目。对于 FAT12 和 FAT16，如果 BPB_TotSec16 足够存放对应数值，则该字段为 0，否则该字段会存储数据的高位。</p>
</li>
</ul>
<h3 id="32-extended-bpb-structure-for-fat12-and-fat16-volumes">3.2 Extended BPB structure for FAT12 and FAT16 volumes</h3>
<p>如果是 FAT12 和 FAT16，boot sector 中还有如下的一些字段 (紧跟在 BPB_common 之后)：</p>
<pre><code class="language-c">struct BPB_16bit {
    uint8_t   BS_DrvNum;        /* 36 */          
    uint8_t   BS_Reserved1;     /* 37 */     
    uint8_t   BS_BootSig;       /* 38 */   
    uint32_t  BS_VolID;         /* 39 */ 
    char      BS_VolLab[11];    /* 43 */      
    char      BS_FilSysType[8]; /* 54 */         
    uint8_t   __padding[448];   /* 62 */       
    uint16_t  Signature_word;   /* 510 */       
}__attribute__((__packed__));
</code></pre>
<p>各个字段的解释如下：</p>
<ul>
<li>BS_DrvNum：0x13 号中断的驱动号，<u>设置成 0x80 或 0x00</u>。</li>
<li>BS_Reserved1：保留字段，<u>设置为 0x0</u>。</li>
<li>BS_BootSig：<u>如果后面两个字段 (BS_VolID 和 BS_VolLab) 中的任何一个是非零数，将该字段设置为 0x29</u>。</li>
<li>BS_VolID：该字段和 BS_VolLab 共同支持了可移动设备上的 volume tracking。这些字段使得 FAT 文件系统驱动可以识别出插入到可移动驱动上的错误磁盘。<u>BS_VolID 应当通过将当前日期和时间拼接成 32 位数值的方式生成</u>。</li>
<li>BS_VolLab：Volume label。该字段的内容应当和根目录下的 11 字节 volume label 相同。FAT 文件系统应当保证如果根目录下的 volume label 被创建或者修改，该字段也会被更新。如果没有 volume label，该字段会被填充为 &ldquo;NO NAME    &ldquo;。</li>
<li>BS_FilSysType：&ldquo;FAT12   &ldquo;，&ldquo;FAT16   &quot; 或 &ldquo;FAT     &quot; 中的一个。注意该字段只是起到一个提供信息的作用，并不用于决定 FAT 的类型。</li>
<li>Signature_word：<u>偏移量为 510 的 byte 为 0x55，偏移量为 511 的 byte 为 0xaa</u>。</li>
</ul>
<h3 id="33-extended-bpb-structure-for-fat32-volumes">3.3 Extended BPB structure for FAT32 volumes</h3>
<p>如果是 FAT32，boot sector 中还会有如下的一些字段 (紧跟在 BPB_common 之后)：</p>
<pre><code class="language-c">struct BPB_32bit {
    uint32_t  BPB_FATSz32;      /* 36 */      
    uint16_t  BPB_ExtFlags;     /* 40 */       
    uint16_t  BPB_FSVer;        /* 42 */    
    uint32_t  BPB_RootClus;     /* 44 */       
    uint16_t  BPB_FSInfo;       /* 48 */     
    uint16_t  BPB_BkBootSec;    /* 50 */        
    char      BPB_Reserved[12]; /* 52 */           
    uint8_t   BS_DrvNum;        /* 64 */    
    uint8_t   BS_Reserved1;     /* 65 */           
    uint8_t   BS_BootSig;       /* 66 */           
    uint32_t  BS_VolID;         /* 67 */           
    char      BS_VolLab[11];    /* 71 */           
    char      BS_FilSysType[8]; /* 82 */           
    uint8_t   __padding[420];   /* 90 */           
    uint16_t  Signature_word;   /* 510 */           
}__attribute__((__packed__));
</code></pre>
<p>各个字段的解释如下 (和 FAT12/FAT16 相同的部分不再解释)：</p>
<ul>
<li>BPB_FATSz32：一个 FAT 中包含的 32-bit sector 数目。</li>
<li>BPB_ExtFlags：各个位的标志信息如下
<ul>
<li>0-3 位：当前 active 的 FAT 的编号，这个编号是 0-based 的，仅在 mirroring 被关闭时有效。</li>
<li>4-6 位：reserved。</li>
<li>7 位：该位是 0 表示 FAT 会在运行时镜像到所有的 FAT 中；该位是 1 表示只有一个 FAT 是活跃的，这个活跃的 FAT 的编号通过 0-3 位表示。</li>
<li>8-15 位：reserved。</li>
</ul>
</li>
<li>BPB_FSVer：高位的 byte 存储主版本号 (major)，低位的 byte 存储小版本号 (minor)。<u>现阶段该值必须被设置为 0x0</u>。</li>
<li>BPB_RootClus：该字段表示了根目录的第一个 cluster 的编号。该值通常是 2，如果有出现 cluster 损坏的情况，则该值是 2 之后第一个可用的 cluster 的编号。</li>
<li>BPB_FSInfo：该字段表示了 FAT32 的 reserved area 中 FSINFO 结构体所在的 sector 编号，通常为 1。值得注意的是，在 boot sector 的备份中也会有一个 FSINTO 结构体，但主 boot sector 和备份 boot sector 的该字段会指向同一个 FSINFO 结构体，只有那个被指向的结构体才是 up-to-date 的。</li>
<li>BPB_BkBootSec：<u>该字段的值是 0 或 6</u>。如果非零，它表示了 boot record 的备份所在的 sector 号 (6 号)。</li>
<li>BPB_Reserved：reserved。<u>必须被设置为 0x0</u>。</li>
</ul>
<h3 id="34-initialization-of-a-fat-volume">3.4 Initialization of a FAT volume</h3>
<p>Section 3.5 会介绍如何决定 FAT 的类型 (12/16/32)，本 section 主要介绍在 volume 初始化时如何填写 BPB 中的字段。FAT implementation 要保证可以挂载填写了合法数值的 BPB 的设备。</p>
<p>软盘会被格式化为 FAT12，一个简单的、事先准备好的表格决定了软盘中 BPB 的各个字段的值。注意：FAT12 要求设备容量 &lt;= 4MB。</p>
<p>对于每个 sector 大小为 512B 的设备，如果设备大小 &lt; 512MB，该设备会被格式化为 FAT16，否则会被格式化为 FAT32。覆盖默认的 FAT 类型选择是可能的。</p>
<p>下面的表格来自 Microsoft Corporation FAT format utility。对于 FAT16，填写 BPB_SecPerClus 的表格如下：</p>
<pre><code class="language-c">struct DSKSZTOSECPERCLUS {
    DWORD DiskSize;       // 以512byte sector为单位
    BYTE  SecPerClusVal;
};

DSKSZTOSECPERCLUS DskTableFAT16 [] = {
  {8400,      0},  /* disks up to 4.1 MB, the 0 value for SecPerClusVal trips an error */
  {32680,     2},  /* disks up to 16 MB, 1k cluster */
  {262144,    4},  /* disks up to 128 MB, 2k cluster */
  {524288,    8},  /* disks up to 256 MB, 4k cluster */
  {1048576,  16}, /* disks up to 512 MB, 8k cluster */
  /* The entries after this point are not used unless FAT16 is forced */
  {2097152,   32},/* disks up to 1 GB, 16k cluster */
  {4194304,   64},/* disks up to 2 GB, 32k cluster */
  {0xFFFFFFFF, 0} /*any disk greater than 2GB, 0 value for SecPerClusVal trips an error */
};
</code></pre>
<p>虽然 FAT16 一般只在 &lt;= 512 MB 的情况下使用，但表格中仍然给出了一些大于 512MB 但强制要求使用 FAT16 的设备的填写方法。该表格的使用方法是：根据当前设备的 disk size，在表格中找出第一个小于等于 disk size 的表项，并将其第二个参数作为 BPB_SecPerClus，第一个参数会被填入 BPB_TotSec16。为了使该表格中的数值可以正确工作，BPB_RsvdSecCnt 需要被设置为 1，BPB_NumFATs 需要被设置为 2，BPB_RootEntCnt 需要被设置为 512。</p>
<p>对于 FAT32，填写 BPB_SecPerClus 的表格如下：</p>
<pre><code class="language-c">DSKSZTOSECPERCLUS DskTableFAT32 [] = {
  {66600,      0}, /* disks up to 32.5 MB, the 0 value for SecPerClusVal trips an error */
  {532480,     1}, /* disks up to 260 MB, .5k cluster */
  {16777216,   8}, /* disks up to 8 GB, 4k cluster */
  {33554432,   16}, /* disks up to 16 GB, 8k cluster */
  {67108864,   32}, /* disks up to 32 GB, 16k cluster */
  {0xFFFFFFFF, 64}  /* disks greater than 32GB, 32k cluster */
};
</code></pre>
<p>为了使该表格中的数值可以正确工作，BPB_RsvdSecCnt 需要被设置为 32，BPB_NumFATs 需要被设置为 2。</p>
<p>下面的代码解释了如何计算 BPB_FATSz16/BPB_FATSz32 字段。该代码假设 BPB_RootEntCnt, BPB_RsvdSecCnt 和 BPB_NumFATs 已经被正确设置好。代码中的 DiskSize 是以 sector 为单位的 (即 BPB_TotSec16/BPT_TotSec32 中的值)。</p>
<pre><code class="language-c">RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytsPerSec – 1)) / BPB_BytsPerSec;
TmpVal1 = DskSize - (BPB_ResvdSecCnt + RootDirSectors);
TmpVal2 = (256 * BPB_SecPerClus) + BPB_NumFATs;
if (FATType == FAT32) {
    TmpVal2 = TmpVal2 / 2;
    FATSz = (TMPVal1 + (TmpVal2 – 1)) / TmpVal2;
}
if (FATType == FAT32) {
    BPB_FATSz16 = 0;
    BPB_FATSz32 = FATSz;
} else {
    BPB_FATSz16 = LOWORD(FATSz);
    /* there is no BPB_FATSz32 in a FAT16 BPB */
}
</code></pre>
<p>注：该代码中的数学运算不是完美的，在一些情况下它算出的 FAT size 会过大，但它一定不会算小，这保证了它不会出错 (过大只是会浪费一些空间)。该代码的简洁是它的优势。</p>
<h3 id="35-determination-of-fat-type-when-mounting-the-volume">3.5 Determination of FAT type when mounting the volume</h3>
<p>FAT 类型唯一决定于 volume 中 cluster 的数量 (CountofClusters)。下面的步骤描述了计算 cluster 数量的过程：</p>
<ul>
<li>
<p>计算根目录占据的 sector 的数量：</p>
<pre><code class="language-c">RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytsPerSec - 1)) / BPB_BytsPerSec;
</code></pre>
</li>
<li>
<p>计算数据区占据的 sector 的数量 (从总 sector 数量中扣除根目录和 FAT 的 sector 数量)：</p>
<pre><code class="language-c">FATSz   = (BPP_FATSz16 != 0) ? BPB_FATSz16 : BPB_FATSz32;
TotSec  = (BPB_TotSec16 != 0) ? BPB_TotSec16 : BPB_TotSec32;
DataSec = TotSec - (BPB_RsvdSecCnt + (BPB_NumFATs * FATSz) + RootDirSectors);
</code></pre>
</li>
<li>
<p>计算 CountOfCluster：</p>
<pre><code class="language-c">CountofClusters = DataSec / BPB_SecPerClus;
</code></pre>
</li>
</ul>
<p>下面的 if 语句决定了 FAT 的类型：</p>
<pre><code class="language-c">if (CountofClusters &lt; 4085) 
    {/* Volume is FAT12 */}
else if (CountofClusters &lt; 6525) 
    {/* Volume is FAT16 */}
else 
    {/* Volume is FAT32 */}
</code></pre>
<p>注：一个磁盘的 cluster 数目最好不要卡在边界上 (比如 4085 个 cluster 或 65525 个 cluster)，与边界值的差最好大于 16。</p>
<p>最大的可使用的 cluster 号是 <code>CountofCluster + 1</code>。</p>
<h3 id="36-backup-bpb-structure">3.6 Backup BPB Structure</h3>
<p>sector #0 的损坏会对文件系统产生毁灭性的打击，因此为 BPB 做备份是很重要的。在 FAT32 中，sector #6 必须包含 BPB 的备份。</p>
<p>无论是 sector #0 中的 BPB 还是 sector #6 中的备份 BPB，BPB_BkBootSec 字段中的值都是 6。</p>
<p>当 sector #0 无法读取时，volume repair utility 应当从 sector #6 提取信息。</p>
<h2 id="section-4-fat">Section 4: FAT</h2>
<p>File Allocation Table 中的每一个 entry 都代表了一个 cluster 的状态。FAT12 中每个 FAT entry 占 12 个 bit，FAT16 中每个 FAT entry 占 16 个 bit，FAT32 中每个 FAT entry 占 32 个 bit。FAT 表中的 entry 可能比可以分配的 cluster 的数目更多，那些多出来的 FAT entry 必须被置为 0。</p>
<p>FAT 定义了表示文件的单向链表。整个磁盘中的第一个 cluster 的编号是 2。</p>
<blockquote>
<p>注：一个 FAT 中的目录文件本身只是一个普通文件，它有一个特殊的属性表明它自己是目录，该文件的内容是一系列的 32 字节的目录项。</p>
</blockquote>
<p>FAT entry 的内容如下表：</p>
<table>
<thead>
<tr>
<th>FAT12</th>
<th>FAT16</th>
<th>FAT32</th>
<th>Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x000</td>
<td>0x0000</td>
<td>0x0000000</td>
<td>cluster 当前空闲</td>
</tr>
<tr>
<td>0x002~MAX</td>
<td>0x0002~MAX</td>
<td>0x0000002~MAX</td>
<td>cluster 在使用中，FAT entry 的内容是链表中下一个 cluster 的编号。MAX 指的是最大的合法 cluster 编号</td>
</tr>
<tr>
<td>(MAX+1)~0xFF6</td>
<td>(MAX+1)~0xFFF6</td>
<td>(MAX+1)~0xFFFFFF6</td>
<td>reserved，不可使用</td>
</tr>
<tr>
<td>0xFF7</td>
<td>0xFFF7</td>
<td>0xFFFFFF7</td>
<td>cluster 损坏</td>
</tr>
<tr>
<td>0xFF8~0xFFE</td>
<td>0xFFF8~0xFFFE</td>
<td>0xFFFFFF8~0xFFFFFFE</td>
<td>reserved，不可使用</td>
</tr>
<tr>
<td>0xFFF</td>
<td>0xFFFF</td>
<td>0xFFFFFFF</td>
<td>cluster 在使用中，是一个文件的最后一个 cluster</td>
</tr>
</tbody>
</table>
<p>注：(1) FAT32 表项中的高 4 位不使用。</p>
<p>(2) FAT12 中 FAT 的大小不能超过 6K 个 sector，FAT16 中 FAT 的大小不能超过 128K 个 sector，FAT32 没有限制。</p>
<h3 id="41-determination-of-fat-entry-for-a-cluster">4.1 Determination of FAT entry for a cluster</h3>
<p>给定一个合法的 cluster 号 $N$，该 section 主要介绍如何确定哪个 FAT entry 对应了这个 cluster。</p>
<h4 id="fat16-and-fat32">FAT16 and FAT32</h4>
<p>下面的代码给出了确定某一个 cluster 的 FAT entry 所在的 sector的方法：</p>
<pre><code class="language-c">FATSz = (BBP_FATSz16 != 0) ? BPB_FATSz16 : BPB_FATSz32;
FATOffset = (FATType == FAT16) ? (N * 2) : (N * 4);
ThisFATSecNum = BPB_RsvdSecCnt + (FATOffset / BPB_BytsPerSec);
ThisFATEntOffset = REM(FATOffset / BPB_BytsPerSec);
</code></pre>
<p>注：FATX 的 FAT 是由若干个 X bit 的 FAT entry 紧密排列而成的，因此 <code>FATOffset</code> 计算出了 $N$ 号 cluster 的 FAT entry 距离 FAT 表开头的偏移字节数，用这个字节数除以 BPB_BytsPerSec 即可得到 sector 号，取余即可得到 sector 内的偏移量。</p>
<p>上述代码求得的 ThisFATSecNum 是 cluster 在第一份 FAT 中的 FAT entry 所在 sector 号。如果要求其他 FAT 中的 FAT entry 的 sector 号，可以参考如下公式：</p>
<pre><code class="language-c">SectorNumber = (FatNumber * FATSz) + ThisFatSecNum;
</code></pre>
<p>将磁盘映射到内存中之后，我们可以用如下方法读取一个 FAT entry 的内容 (下面的代码中 SecBuff 是指向对应 sector 开头的指针，WORD 是 16bit，DWORD 是 32bit)：</p>
<pre><code class="language-c">if (FATType == FAT16)
    FAT16ClusEntryVal = *((WORD *) &amp;SecBuff[ThisFATEntOffset]);
else
    FAT32ClusEntryVal = (*((DWORD *) &amp;SecBuff[ThisFATEntOffset])) &amp; 0x0FFFFFFF;
</code></pre>
<p>可以用如下方法修改一个 FAT entry：</p>
<pre><code class="language-c">if (FATType == FAT16)    
    *((WORD *) &amp;SecBuff[ThisFATEntOffset]) = FAT16ClusEntryVal;
else {    
    FAT32ClusEntryVal &amp;= 0x0FFFFFFF;    
    *((DWORD *) &amp;SecBuff[ThisFATEntOffset]) = (0xF0000000 | FAT32ClusEntryVal);
}
</code></pre>
<p><u>注：FAT16/FAT32 的表项不能跨 sector 存储。</u></p>
<h4 id="fat12">FAT12</h4>
<p>FAT12 中的每个 FAT entry 占 12bit (1.5 个字节)。所有的计算方法和 FAT16/FAT32 类似，但由于字节数不是整数，所以涉及一些微妙的运算：</p>
<pre><code class="language-c">if (FATType == FAT12) FATOffset = N + (N / 2); // 这里的“/”是下取整
ThisFATSecNum = BPB_RsvdSecNum + (FATOffset / BPB_BytsPerSec);
ThisFATEntOffset = REM(FATOffset / BPB_BytsPerSec);
</code></pre>
<p>在 FAT12 中，一个 FAT entry 是有可能跨 sector 存储的，下面给出了判断方法：</p>
<pre><code class="language-c">if (ThisFATEntOffset == (BPB_BytsPerSec - 1)) {
    // 该FAT entry跨sector存储
    // 最简单的应对方法是每次读取时总是读取连续的两个sector:N和N+1(除非N是最后一个sector)
}
</code></pre>
<p>FAT12 中读取 FAT entry 内容的方法也有一些微妙：因为每个 FAT entry 占 12 个 bit，所以两个 FAT entry 正好占据 3 个字节。我们计算出的 ThisFATEntOffset 对应的是该 FAT entry 所在的第一个 byte 的地址，这意味着对于奇数 cluster 而言 FAT entry 是从 ThisFATEntOffset 的开头开始的，对于偶数 cluster 而言 FAT entry 是从 ThisFATEntOffset 所在字节的后 4 个 bit 开始的，因此代码逻辑如下 (注：<code>&gt;&gt;</code> 是逻辑右移)：</p>
<pre><code class="language-c">FAT12ClusEntryVal = *((WORD *) &amp;SecBuff[ThisFATEntOffset]); // 先读出16个bit
if (N &amp; 0x0001)
    FAT12ClusEntryVal &gt;&gt;= 4;     // 16个bit中只有前12个bit是表项，低位4个bit应当清空
else
    FAT12ClusEntryVal &amp;= 0x0FFF; // 16个bit中只有后12个bit是表项，高位4个bit应当清空
</code></pre>
<p>修改一个表项的方法为：</p>
<pre><code class="language-c">if (N &amp; 0x0001) {
    FAT12ClusEntryVal &lt;&lt;= 4;
    *((WORD *) &amp;SecBuff[ThisFATEntOffset]) &amp;= 0x000F;
}
else {
    FAT12ClusEntryVal &amp;= 0x0FFF;
    *((WORD *) &amp;SecBuff[ThisFATEntOffset]) &amp;= 0xF000;
}
*((WORD *) &amp;SecBuff[ThisFATEntOffset]) |= FAT12ClusEntryVal;
</code></pre>
<h3 id="42-reserved-fat-entries">4.2 Reserved FAT entries</h3>
<p>FAT 的前两个 FAT entry 是 reserved 的。</p>
<p>第一个 FAT entry (FAT[0]) 的内容为：低 8 位保存了 BPB_Media 的值，剩下的位置为 1。</p>
<p>第二个 FAT entry (FAT[1]) 的内容位：</p>
<ul>
<li>对于 FAT12：该 entry 保存了 EOC mark。</li>
<li>对于 FAT16 和 FAT32：MS Windows 的设备驱动将最高的两个位作为 dirty volume 标志位，剩下的其他位置为 1。这里的高 2 位指的是 FAT16 中的 0x8000 (ClnShutBitMask) 和 0x4000 (HrdErrBitMask)，FAT32 中的 0x08000000 (ClnShutBitMask) 和 0x04000000 (HrdErrBitMask)。
<ul>
<li>ClnShutBitMask 位：如果这个位是 1，那么这个 volume 当前是干净的，可以被挂载并访问；如果这个位是 0，那么这个 volume 是 dirty 的，FAT 文件系统驱动无法正确地解挂载这个 volume，该 volume 的内容应当被扫描一遍以确定是否有 metadata 的损坏。</li>
<li>HrdErrBitMask 位：该位是 1 说明没有遇到任何 read/write 错误。该位是 0 说明自上一次挂载以来 FAT 文件系统驱动遇到过 read/write 错误，可能有 sector 损坏了。该 volume 的内容应当被扫描一遍以确定是否有损坏的 sector。</li>
</ul>
</li>
</ul>
<h3 id="43-free-space-determination">4.3 Free space determination</h3>
<p>文件系统驱动必须扫描所有的 FAT entry 以构建一系列的文件链表和获得所有的空闲 cluster。空闲的 cluster 对应  的 FAT entry 的值为 0。空闲 cluster 在 FAT 中并没有以一个链表的形式串起来，但在 FAT32 中，BPB_FSInfo sector 可能包含了空闲 cluster 的数目。</p>
<h3 id="44-other-points-to-note">4.4 Other points to note</h3>
<ul>
<li>
<p>FAT 的实现不应当对 <code>(CountOfCluster + 1)</code> FAT entry 之后的内容有任何的假设 (这个 entry 不一定在一个 sector 的结尾处)。并且在格式化时，FAT 的最后一个 sector 中最后一个 FAT entry 之后的部分应被置为 0。</p>
</li>
<li>
<p>每个 FAT 包含的 sector 数可能比它实际需要的 sector 数多，这意味着 FAT 的最后可能会包含若干完全没有使用的 sector。驱动实现应当通过 CountOfCluster 来确定 FAT 中最后一个 valid sector 的编号。最后一个 valid sector 后面的 sector 应当全部被置为 0。</p>
</li>
</ul>
<h2 id="section-5-file-system-information-fsinfo-structure">Section 5: File System Information (FSInfo) Structure</h2>
<p>FSInfo 结构体只在 FAT32 中有。该结构体应当在文件系统初始化时设置好并放在 sector #1 中 (即紧接着 BPB)，该结构体的备份存放在 sector #7 中。</p>
<p>注：FSInfo 结构体中的所有信息都是建议性的，文件系统驱动应当在初始化时填好 FSInfo 的信息，但并不一定需要在磁盘读写的过程中动态更新这个结构体 (尽管手册建议这么做)。</p>
<p>FSInfo 的各个字段如下：</p>
<pre><code class="language-c">struct FSInfo {
    uint32_t FSI_LeadSig[4]; /*   0 */        
    uint8_t  FSI_rsvc1[480]; /*   4 */    
    uint32_t FSI_StrucBig;   /* 484 */      
    uint32_t FSI_Free_Count; /* 488 */        
    uint32_t FSI_Nxt_Free;   /* 492 */       
    uint8_t  FSI_rsvd2[12];  /* 496 */   
    uint32_t FSI_TrailSig;   /* 508 */      
};
</code></pre>
<p>各个字段的解释如下：</p>
<ul>
<li>FSI_LeadSig：值为 0x41615252，用于确认 FSInfo 格式的签名。</li>
<li>FSI_Rsvd1：reserved，必须置为 0。</li>
<li>FSI_StrucSig：值为 0x61417272，一个额外用于确认 FSInfo 格式的签名。</li>
<li>FSI_Free_Count：该字段值为磁盘中空闲 cluster 的数量，如果不清楚则置为 0xFFFFFFFF。该字段必须在 volume 挂载时确定，手册建议该字段在 volume 解挂载时仍然保存正确的 count。</li>
<li>FSI_Next_Free：保存了磁盘上第一个空闲 cluster 的编号，如果不清楚则置为 0xFFFFFFFF。该字段必须在 volume 挂载时确定，手册建议该字段在 volume 解挂载时仍然保存正确的编号。</li>
<li>FSI_Rsvd2：reserved，必须置为 0。</li>
<li>FSI_TrailSig：值为 0xAA550000，用于确认 FSInfo 格式的签名</li>
</ul>
<h2 id="section-6-directory-structure">Section 6: Directory Structure</h2>
<p>FAT 的目录是一种特殊的文件，它像是一个容器，里面装了子目录和文件的相关信息。目录文件由一系列的 32 字节的目录项 (directory entry) 构成，每个目录项描述了一个子目录或一个文件。</p>
<p>目录项的内容可以用如下结构体描述：</p>
<pre><code class="language-c">struct Dirent {
    char     DIR_Name[11];     /* 0  */            
    uint8_t  DIR_Attr;         /* 11 */        
    uint8_t  DIR_NTRes;        /* 12 */         
    uint8_t  DIR_CrtTimeTenth; /* 13 */                
    uint16_t DIR_CrtTime;      /* 14 */           
    uint16_t DIR_CrtDate;      /* 16 */           
    uint16_t DIR_LstAccDate;   /* 18 */              
    uint16_t DIR_FstClusHI;    /* 20 */             
    uint16_t DIR_WrtTime;      /* 22 */           
    uint16_t DIR_WrtDate;      /* 24 */           
    uint16_t DIR_FstClusLO;    /* 26 */             
    uint32_t DIR_FileSize;     /* 28 */            
}__attribute__((__packed__));
</code></pre>
<p>各个字段的解释如下：</p>
<ul>
<li>
<p>DIR_Name：“短”文件名，不超过 11 个字节。</p>
</li>
<li>
<p>DIR_Attr：文件的属性，合法的属性值如下所示</p>
<table>
<thead>
<tr>
<th>ATTR_READ_ONLY</th>
<th>ATTR_HIDDEN</th>
<th>ATTR_SYSTEM</th>
<th>ATTR_VOLUME_ID</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x01</td>
<td>0x02</td>
<td>0x04</td>
<td>0x08</td>
</tr>
<tr>
<td><strong>ATTR_DIRECTORY</strong></td>
<td><strong>ATTR_ARCHIVE</strong></td>
<td><strong>ATTR_LONG_NAME</strong></td>
<td></td>
</tr>
<tr>
<td>0x10</td>
<td>0x20</td>
<td>0x0F (前四个的或)</td>
<td></td>
</tr>
</tbody>
</table>
<p>DIR_Attr 的高两个 bit 保留，必须被置为 0。</p>
</li>
<li>
<p>DIR_NTRes：reserved，必须置为 0。</p>
</li>
<li>
<p>DIR_CrtTimeTenth：创建时间 (低位)，以 1/10 秒为单位，合法范围是 <code>0&lt;=DIR_CrtTimeTenth&lt;=199</code>。</p>
</li>
<li>
<p>DIR_CrtTime：创建时间 (高位)，颗粒度为 2s。</p>
</li>
<li>
<p>DIR_CrtDate：创建日期。</p>
</li>
<li>
<p>DIR_LstAccDate：上一次 access 该文件的日期。这里的 access 指的是对该文件/目录的 read/write 操作。该字段必须在文件修改时更新 (即写操作时)，填写的日期必须与 DIR_WrtDate 相同。</p>
</li>
<li>
<p>DIR_FstClusHI：该文件/目录的第一个 cluster 的编号的高 16 位。该字段仅对 FAT32 有效，FAT12/FAT16 中该字段必须置为 0。</p>
</li>
<li>
<p>DIR_WrtTime：上一次修改该文件的时间。在文件刚刚创建的时候，该字段的值应当与 DIR_CrtTime 一样。</p>
</li>
<li>
<p>DIR_WrtDate：上一次修改该文件的日期。在文件刚刚创建的时候，该字段的值应当与 DIR_CrtDate 一样。</p>
</li>
<li>
<p>DIR_FstClusLO：该文件/目录的第一个 cluster 的编号的低 16 位。</p>
</li>
<li>
<p>DIR_FileSize：文件大小，以字节为单位。</p>
</li>
</ul>
<h3 id="61-filedirectory-name-field-dir_name">6.1 File/Directory Name (field <code>DIR_Name</code>)</h3>
<p>DIR_Name 共有 11 个字节，分为两个部分：8 字节的 main part 和 3 字节的扩展名。如果某一个部分字节数不足，后面会用空格补足长度。</p>
<p>以下是一些注意点：</p>
<ul>
<li>main part 和扩展名之间默认有一个 &ldquo;.&quot;，这个点不会存储在 DIR_Name 中。</li>
<li><code>DIR_Name[0] == 0xE5</code> 代表这个目录项是空闲的。不过在 KANJI (日本语) 中 0xE5 这个字符是存在的，因此 KANJI 下 0xE5 会用 0x05 来代替。文件系统解析文件名时如果遇到首字节是 0x05 且字符集是 KANJI 时要将 0x05 替换成 0xE5 再返回。</li>
<li>除了 0xE5，<code>DIR_Name[0] == 0x00</code> 也代表这个目录项是空闲的。它与 0xE5 的不同在于 0x00 意味着后面跟着的所有目录项也都是空闲的。</li>
<li><code>DIR_Name[0]</code> 不能是 0x20，即文件名不能以空格开头。</li>
<li>一个目录下的所有名字都必须是唯一的。</li>
</ul>
<p>对于文件中字符的限制如下：</p>
<ul>
<li>小写字母不允许出现。</li>
<li>小于 0x20 的字符不允许出现 (除了上面提到的 KANJI 的 0x05)。</li>
<li>0x22, 0x2A, 0x2B, 0x2C, 0x2E, 0x2F, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x5B, 0x5C, 0x5D 和 0x7C。</li>
</ul>
<h3 id="62-filedirectory-attributes">6.2 File/Directory Attributes</h3>
<p>文件或子目录的属性值会影响文件系统驱动对该文件/子目录的操作方式。各种属性值的意义列举如下：</p>
<ul>
<li>
<p>ATTR_READ_ONLY (0x01)：该文件不可修改，对该文件的修改操作会以返回错误码告终。</p>
</li>
<li>
<p>ATTR_HIDDEN (0x02)：除非用户显式地要求列举出隐藏文件，否则 hidden files 不应在列举目录下文件时出现 (可以理解为 <code>ls -a</code> 和 <code>ls</code> 的区别)。</p>
</li>
<li>
<p>ATTR_SYSTEM (0x04)：该文件被标记为和操作系统相关的“系统文件”，除非用户显式地要求列举出系统文件，否则 system files 不应在列举目录下文件时出现。</p>
</li>
<li>
<p>ATTR_VOLUME_ID (0x08)：该文件包含 volume label，这种情况下，DIR_FstClusHI 和 DIR_FstClusLO 必须都置为 0。</p>
<p>只有根目录可以有一个 entry 包含该属性 (表示长文件名的 entry 不遵从该规则)。</p>
</li>
<li>
<p>ATTR_DIRECTORY (0x10)：该目录项表示的是一个子目录。这种情况下，DIR_FileSize 必须为 0。</p>
</li>
<li>
<p>ATTR_ARCHIVE (0x20)：当文件被创建、重命名或修改时，该属性值必须被设置，标志该文件的相关信息已经被修改。在备份时，各种工具可以利用该属性来判断一个文件是否需要备份。</p>
</li>
</ul>
<h3 id="63-datetime">6.3 Date/Time</h3>
<p>DIR_CrtTime, DIR_CrtTimeTenth, DIR_CrtDate, DIR_LstAccDate 这四个字段是选填的。文件系统驱动如果不支持这些字段，则必须将其置为 0。DIR_WrtTime 和 DIR_WrtDate 这两个字段是文件系统驱动必须正确更新的。</p>
<h4 id="date-format">Date format</h4>
<p>DIR_CrtDate, DIR_WrtDate, DIR_LstAccDate 这三个字段需要遵从日期的格式。</p>
<ul>
<li>0-4 bit：日 (1~31)</li>
<li>5-8 bit：月 (1~12)</li>
<li>9-15 bit：从 1980 年起的年份 (0~127，可以表示 1980~2107 年)</li>
</ul>
<h4 id="time-format">Time Format</h4>
<p>DIR_CrtTime, DIR_WrtTime 这两个字段需要遵从时间格式。时间是以 2s 为颗粒度的。</p>
<ul>
<li>0-4 bit：秒 (以 2s 为单位，数值范围是 0~29，可以表示 0,2,4,&hellip;,58)</li>
<li>5-10 bit：分钟 (0~59)</li>
<li>11-15 bit：小时 (0~23)</li>
</ul>
<h3 id="64-filedirectory-size">6.4 File/Directory Size</h3>
<p>文件的最大大小是 0xFFFFFFFF 个字节。最大的目录大小是 $2^{21}$ 个字节。</p>
<h3 id="65-directory-creation">6.5 Directory creation</h3>
<p>当一个新的目录被创建时，文件系统实现必须保证以下内容：</p>
<ul>
<li>DIR_Attr 的 ATTR_DIRECTORY bit 要置为 1。</li>
<li>DIR_FileSize 必须置为 0。</li>
<li>至少要分配一个 cluster，DIR_FstClusLO 和 DIR_FstClusHI 负责表示第一个 cluster 的编号。</li>
</ul>
<p>(以上三条说的时该目录在其父目录的 directory entry 中的内容)</p>
<ul>
<li>如果该目录只有一个 cluster，那么它对应的 FAT entry 应当被标记为 end-of-file。</li>
<li>初始分配的 cluster 的内容应当置为 0。</li>
<li>除了根目录，其他所有目录都必须在开头有如下的两个目录项：
<ul>
<li><code>.</code>：该目录项表示当前目录，之前提到的 DIR_Attr, DIR_FileSize 的规则仍然需要保持，DIR_FstClusLO 和   DIR_FstClusHI 以及所有的时间、日期字段必须和当前目录的保持一致。</li>
<li><code>..</code>：该目录项表示上一级目录，之前提到的 DIR_Attr, DIR_FileSize 的规则仍然需要保持，DIR_FstClusLO 和   DIR_FstClusHI 以及所有的时间、日期字段必须和上一级目录的保持一致 (如果上一级目录是根目录，则 DIR_FstClusLO 和 DIR_FstClusHI 必须都置为 0)。</li>
</ul>
</li>
</ul>
<h3 id="66-root-directory">6.6 Root Directory</h3>
<p>根目录是一个特殊的 container file，在格式化时创建。</p>
<p>在 FAT12 和 FAT16 中，根目录必须紧跟在最后一个 FAT 后，因此根目录的第一个 sector 的编号可以按照如下方式计算：</p>
<pre><code class="language-c">FirstRootDirSecNum = BPB_RsvdSecCnt + (BPB_NumFATs * BPB_FATSz16);
</code></pre>
<p>根目录的大小根据 BPB_RootEntCnt 字段的值计算。</p>
<p>在 FAT32 中，根目录是变长的，根目录的第一个 cluster 的编号存放在 BPB_RootClus 字段中。</p>
<p>只有根目录的 DIR_Attr 字段的值可以等于 ATTR_VOLUME_ID。</p>
<p>根目录没有名字 (在绝大多数操作系统中，<code>\</code> 这个名字被用作根目录)，也没有任何的时间戳 (日期/时间)，也没有 &ldquo;.&rdquo;, &ldquo;..&rdquo; 这两个目录项。</p>
<h3 id="67-file-allocation">6.7 File allocation</h3>
<p>每个文件的目录项 (存储在包含这个文件的目录中) 都有该文件第一个 cluster 的编号。如果该文件大小为 0 则编号是 0。第一个 cluster 在 FAT 中对应的 FAT entry 要么存储了下一个 cluster 的编号，要么是一个 end-of-file 标志。</p>
<p>data region 的第一个 sector (cluster #2) 的编号计算方法如下：</p>
<pre><code class="language-c">FirstDataSector = BPB_RsvdSecCnt + (BPB_NumFATs * FATSz) + RootDirSectors;
</code></pre>
<p>给定一个合法的 cluster 编号 $N$，该 cluster 的第一个 sector 的编号的计算方法如下：</p>
<pre><code class="language-c">FirstSectorofCluster = ((N - 2) * BPB_SecPerClus) + FirstDataSector;
</code></pre>
<h2 id="section-7-long-file-name-implementation-optional">Section 7: Long File Name Implementation (optional)</h2>
<p>上一个 section 中提到 DIR_Name 字段的长度只有 11 个 字节，其中前 8 个字节是 main part，后三个字节是扩展名。这种目录项被称为短名目录项。但用户很多时候喜欢给自己的文件或目录起长名字，本 section 主要关注如何存储长名的目录项。</p>
<p>长文件名的文件的相关信息存储在一些额外的长名目录项中。注意这里的长名目录项不是独立的，而是作为短名目录项的补充。即每个文件有一个短名目录项，如果文件名过长则另有一些长名目录项专门存储名字。长名目录项必须紧靠着存放在对应的短名目录项前面 (即 长*n+短 = 一个文件/目录的描述)。</p>
<p>长名目录项的内容可以用如下结构体表示：</p>
<pre><code class="language-c">struct LongDirent {
    uint8_t  LDIR_Ord;         /* 0  */       
    char     LDIR_Name1[10];   /* 1  */             
    uint8_t  LDIR_Attr;        /* 11 */        
    uint8_t  LDIR_Type;        /* 12 */        
    uint8_t  LDIR_Chksum;      /* 13 */          
    char     LDIR_Name2[12];   /* 14 */             
    uint16_t LDIR_FstClusLO;   /* 26 */             
    char     LDIR_Name3[4];    /* 28 */            
}__attribute__((__packed__));
</code></pre>
<p>各个字段的解释如下：</p>
<ul>
<li>
<p>LDIR_Ord：该字段表示该长名目录项是其对应的短名目录项的第几个 (一个很长的名字可能需要多个长名目录项来存储)。对于最后一个长名目录项，其 LDIR_Ord 必须或上 LAST_LONG_ENTRY (0x40)。</p>
</li>
<li>
<p>LDIR_Name1：长名的第 1 ~ 5 个字符。</p>
</li>
<li>
<p>LDIR_Attr：长名目录项的 LDIR_Attr 必须被设置为 ATTR_LONG_NAME：</p>
<pre><code class="language-c">ATTR_LONG_NAME = ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_VOLUME_ID;
</code></pre>
<p>用来判断一个目录项是否是长名目录项的 Mask 为</p>
<pre><code class="language-c">#define ATTR_LONG_NAME_MASK (ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_VOLUME_ID | ATTR_DIRECTORY | ATTR_ARCHIVE);
</code></pre>
</li>
<li>
<p>LDIR_Type：必须被置为 0。</p>
</li>
<li>
<p>LDIR_ChkSum：针对其对应的短名目录项算出来的一个校验值。</p>
</li>
<li>
<p>LDIR_Name2：长名的第 6 ~ 11 个字符。</p>
</li>
<li>
<p>LDIR_FstClusLO：必须被置为 0。</p>
</li>
<li>
<p>LDIR_Name3：长名的第 12 ~ 13 个字符。</p>
</li>
</ul>
<h3 id="71-ordinal-number-generation">7.1 Ordinal Number Generation</h3>
<p>一个短名目录项对应的一系列附属的长名目录项在 LDIR_Ord 这个字段上应当满足如下要求：</p>
<ul>
<li>第一个长名目录项满足 <code>LDIR_Ord == 1</code>。</li>
<li>后续的长名目录项的 LDIR_Ord 保证严格单调递增。</li>
<li>最后一个长名目录项满足 <code>LDIR_Ord == (N | LAST_LONG_ENTRY)</code>。</li>
</ul>
<p>如果以上任何一条不满足，我们就认为该长名目录项集合被损坏了。</p>
<h3 id="72-checksum-generation">7.2 Checksum Generation</h3>
<p>当短名目录项和长名目录项被创建的时候，我们需要创建一个 8 bit 的校验和。这个校验和根据短名目录项的 DIR_Name 字段生成：</p>
<pre><code class="language-c">unsigned char ChkSum (unsigned char *pFcbName) {
    short FcbNameLen;
    unsigned char Sum = 0;
    
    for (FcbNameLen = 11; FcbNameLen != 0; FcbNameLen--)
        Sum = ((Sum &amp; 1) ? 0x80 : 0) + (Sum &gt;&gt; 1) + *pFcbName++;
       return Sum;
}
</code></pre>
<p>如果长名目录项中的校验和与其对应的短名目录项算出来不一致，我们就认为该长名目录项集合被损坏了。</p>
<h3 id="73-example-illustrating-persistence-of-a-long-name">7.3 Example illustrating persistence of a long name</h3>
<p>下面的图片以 &ldquo;The quick brown.fox&rdquo; 这个名字为例展示了长名的存储方法：</p>
<p><img src="/img/FAT_LongDirent.png" alt="LongDirent"></p>
<p>长文件名不能超过 255 个字符 (不包括结尾的 NULL)。长文件名中的字符限制和短文件名基本一样 (见 Section 6.1)，一些额外的规则为：</p>
<ul>
<li>
<p>长文件名中可以使用任意多个 <code>.</code> 字符。</p>
</li>
<li>
<p><code>+</code> <code>,</code> <code>;</code> <code>=</code> <code>[</code> <code>]</code> 这六个特殊字符不能在短文件名中出现，但长文件名中也可以使用。</p>
</li>
<li>
<p>长文件名中间允许有空格。开头和结尾的空格会被忽略。</p>
</li>
</ul>
<p>长名目录项中使用 unicode 来存储字符，unicode 中每个字符占 16 个 bit (2 个字节)，这是与短名目录项不同的地方。另一个不同是长名目录项可以区分大小写。</p>
<h3 id="74-rules-governing-name-creation-and-matching">7.4 Rules governing name creation and matching</h3>
<p>一个目录下所有短文件名和长文件名构成的集合被称为一个 namespace。一个 namespace 下的文件名应当遵循如下规定：</p>
<ul>
<li>不论是短文件名还是长文件名，在一个 namespace 中必须是全局唯一的。这里比较唯一性时忽略大小写，即如果两个名字字符一样但大小写不同也被认为是冲突的。</li>
<li>如果一个 OEM 或 unicode 字符无法被转换成系统中的合适字符，文件系统应当将其翻译成 <code>_</code>。</li>
</ul>

    </div>

  

  </div>
</article>

      

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>

      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin="anonymous"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/r.min.js"></script>
        
      

    

    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.js" integrity="sha256-EErZamuLefUnbMBQbsEqu1USa+btR2oIlCpBJbyD4/g=" crossorigin="anonymous"></script>
    

    
    
    <script>const code_highlighting = true;</script>
    

    
    
    <script>const isSiteThemeDark = false;</script>
    

    
    
    
    
    
    
    <script>
      const search_config = {"indexURI":"/index.json","minLength":1,"threshold":0.3};
      const i18n = {"no_results":"No results found","placeholder":"Search...","results":"results found"};
      const content_type = {
        'post': "Posts",
        'project': "Projects",
        'publication' : "Publications",
        'talk' : "Talks"
        };
    </script>
    

    
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    

    
    

    
    
    
    
    
    
    
    
    
      
    
    
    
    
    <script src="/js/academic.min.f8eb5cb10262ef4a670903a5cb3e03ae.js"></script>

    






  
  
  <div class="container">
    <footer class="site-footer">
  

  <p class="powered-by">
    

    <span id="busuanzi_container_site_pv">
        Total Visit: <span id="busuanzi_value_site_pv"></span>
    </span>

    
    <span class="float-right" aria-hidden="true">
      <a href="#" class="back-to-top">
        <span class="button_icon">
          <i class="fas fa-chevron-up fa-2x"></i>
        </span>
      </a>
    </span>
    
  </p>
</footer>

  </div>
  

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
