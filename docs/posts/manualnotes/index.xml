<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Manual Notes | Academic</title>
    <link>/posts/manualnotes/</link>
      <atom:link href="/posts/manualnotes/index.xml" rel="self" type="application/rss+xml" />
    <description>Manual Notes</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sun, 14 Aug 2022 00:00:00 +0000</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>Manual Notes</title>
      <link>/posts/manualnotes/</link>
    </image>
    
    <item>
      <title>Flex Manual - Notes</title>
      <link>/posts/manualnotes/flex/</link>
      <pubDate>Sun, 14 Aug 2022 00:00:00 +0000</pubDate>
      <guid>/posts/manualnotes/flex/</guid>
      <description>&lt;h2 id=&#34;3-introduction&#34;&gt;3. Introduction&lt;/h2&gt;
&lt;p&gt;flex 是一个生成 scanner 的工具。flex 接受一个 &lt;code&gt;.flex&lt;/code&gt; 文件，&lt;code&gt;.flex&lt;/code&gt; 文件用于描述如何生成一个 scanner，由若干 rules 组成，每条规则都是一个正则表达式和一段 C 代码的二元组。flex 工具会输出一个 C 代码 &lt;code&gt;lex.yy.cc&lt;/code&gt;，该代码与 flex 的 runtime library 链接之后可以生成可执行文件。可执行文件执行时会分析输入的内容，如果某条规则的正则表达式与输入内容匹配则执行 rule 中定义的 C 代码。&lt;/p&gt;
&lt;h2 id=&#34;4-some-simple-examples&#34;&gt;4. Some Simple Examples&lt;/h2&gt;
&lt;p&gt;一个最简单的例子如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;    int num_lines = 0, num_chars = 0;
%%
\n    ++num_lines; ++num_chars;
.     ++num_chars
%%
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;.&lt;/code&gt; 表示匹配除了换行符以外的任何字符。上述规则可以统计输入内容中的字符数量和代码行数。&lt;/p&gt;
&lt;h2 id=&#34;5-format&#34;&gt;5. Format&lt;/h2&gt;
&lt;p&gt;一个 &lt;code&gt;.flex&lt;/code&gt; 文件的结构如下，不同 section 由 &lt;code&gt;%%&lt;/code&gt; 分开：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;definitions
%%
rules
%%
user code
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;51-definitions-section&#34;&gt;5.1 Definitions Section&lt;/h3&gt;
&lt;p&gt;Definition 区域中的条目服从如下形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name definition
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;name&lt;/code&gt; 要求以下划线或字母开头，后面接任意个数的字母，下划线和 &lt;code&gt;-&lt;/code&gt;。后续的定义中可以用 &lt;code&gt;{name}&lt;/code&gt; 的方式使用前面的定义，例如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;DIGIT    [0-9]
ID       [a-z][a-z0-9]*
FLOAT    {DIGIT}+&amp;quot;.&amp;quot;{DIGIT}*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由无缩进的 &lt;code&gt;/* */&lt;/code&gt; 或 &lt;code&gt;%{ %}&lt;/code&gt; 包裹住的内容将被原样拷贝到生成的 C 代码中。由 &lt;code&gt;%top{}&lt;/code&gt; 包裹住的内容将被拷贝到 C 代码的最前面。&lt;/p&gt;
&lt;h3 id=&#34;52-rules-section&#34;&gt;5.2 Rules Section&lt;/h3&gt;
&lt;p&gt;Rules 区域中的条目服从如下形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pattern action
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;pattern&lt;/code&gt; 是用于识别的模式，&lt;code&gt;action&lt;/code&gt; 是识别到 pattern 后执行的指令，&lt;code&gt;pattern&lt;/code&gt; 前不可以有缩进，&lt;code&gt;action&lt;/code&gt; 必须和 &lt;code&gt;pattern&lt;/code&gt; 在同一行 (如果 &lt;code&gt;action&lt;/code&gt; 有多行则第一行需要和 &lt;code&gt;pattern&lt;/code&gt; 同行)。&lt;/p&gt;
&lt;p&gt;在 rules section 的第一条 rule 之前可以用 &lt;code&gt;%{ %}&lt;/code&gt; 包裹的方式定义一些变量，这些变量可以在 scanning 的过程中使用。&lt;/p&gt;
&lt;h3 id=&#34;53-user-code-section&#34;&gt;5.3 User Code Section&lt;/h3&gt;
&lt;p&gt;User code section 会被原样拷贝到 C 代码中。这个区域是 optional 的，如果省略的话分割 rules 和 user code 的 &lt;code&gt;%%&lt;/code&gt; 也可以省略。&lt;/p&gt;
&lt;h3 id=&#34;54-comments-in-the-input&#34;&gt;5.4 Comments in the Input&lt;/h3&gt;
&lt;p&gt;flex 支持 C 风格的注释，即 &lt;code&gt;/* */&lt;/code&gt; 之间的内容都会被视为注释，这些注释会被原样拷贝到 C 代码中。注释几乎可以添加在任何地方，除了以下两条限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注释不能出现在 rules section 中本应该是 pattern 的地方，即 &lt;code&gt;/* */&lt;/code&gt; 不能无缩进地出现在一行的开头或者出现在 scanner states 之后。&lt;/li&gt;
&lt;li&gt;注释不能出现在 definitions section 中的 &lt;code&gt;%option&lt;/code&gt; 行中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6-patterns&#34;&gt;6. Patterns&lt;/h2&gt;
&lt;p&gt;本章节给出了可以用于 rules section 中 pattern 的语法。主要语法和扩展正则表达式相似。&lt;/p&gt;
&lt;h2 id=&#34;7-how-the-input-is-matched&#34;&gt;7. How the Input Is Matched&lt;/h2&gt;
&lt;p&gt;如果当前有多条规则 pattern 可以匹配，则 flex 会选择匹配长度最长的规则；如果有多条规则匹配长度相同，则 flex 会选择最先出现的规则 (这两条规则与编译器 lexical analysis 的要求相符)。&lt;/p&gt;
&lt;p&gt;如果没有规则可以匹配，那么 flex 会使用默认规则：将第一个字符原样输出。&lt;/p&gt;
&lt;p&gt;当 match 决定之后，全局变量 &lt;code&gt;yytext&lt;/code&gt; (char 指针) 会指向匹配的内容 (token)，&lt;code&gt;yyleng&lt;/code&gt; (int 变量) 会存储匹配的长度，这些变量可以在 action 的代码中使用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;yytext&lt;/code&gt; 有两种可以选取的定义方式：一个是 &lt;code&gt;char *&lt;/code&gt;，一个是 &lt;code&gt;char []&lt;/code&gt;，在 definitions section 可以通过 &lt;code&gt;%pointer&lt;/code&gt;/&lt;code&gt;%array&lt;/code&gt; 来指定 (默认采取指针)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;采取指针的好处是更快的速度以及不用担心 token 过长导致的 overflow 问题。&lt;/li&gt;
&lt;li&gt;采取数组的好处是可以自由地修改 yytext 的内容。数组的大小默认是 &lt;code&gt;YYLMAX&lt;/code&gt;，在 definitions section 可以通过宏定义的方式自定义这个长度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;8-actions&#34;&gt;8. Actions&lt;/h2&gt;
&lt;p&gt;每条 rule 中的 pattern 都有一个对应的 action，action 可以是一段任意的 C 代码。如果一个 pattern 后的 action 为空，那么这个 pattern 匹配到的输入内容将被忽略。&lt;/p&gt;
&lt;p&gt;下面是一个简单的 action 的例子，它可以将连续的多个 whitespace 缩减成一个，并且过滤行末 whitespace：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;%%
[ \t]+    putchar(&#39; &#39;);
[ \t]+$   /* ignore this token */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;action 中可以书写任意 C 代码，甚至可以使用 &lt;code&gt;return&lt;/code&gt; 向 &lt;code&gt;yylex()&lt;/code&gt; 的调用者返回内容。&lt;/p&gt;
&lt;p&gt;如果 action 中有 &lt;code&gt;{&lt;/code&gt;，那么这个 action 是可以跨行的，flex 会把直到与其对应的 &lt;code&gt;}&lt;/code&gt; 前的所有内容当作本条 rule 的 action。&lt;/p&gt;
&lt;p&gt;如果 action 的内容是 &lt;code&gt;|&lt;/code&gt;，那么它的意思是“该 rule 的 action 和下一条 rule 的 action 相同”。&lt;/p&gt;
&lt;p&gt;action 中有一些特殊的命令可以使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ECHO&lt;/code&gt;：将 yytext 复制到 scanner 的输出中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;BEGIN&lt;/code&gt;：后面跟一个 start condition，后面会详细介绍这一用法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;REJECT&lt;/code&gt;：使用 REJECT 将会使 scanner 转向下一条 second best 的规则进行匹配。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;    int word_count = 0;
%%
frob       special(); REJECT;
[^ \t\n]+  word_count++;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码的意思是遇到单词 &amp;ldquo;frob&amp;rdquo; 就执行一个特殊的函数 &lt;code&gt;special()&lt;/code&gt;。在 frob 后使用 REJECT 则会在执行完 &lt;code&gt;special()&lt;/code&gt; 后使 scanner 转向第二条规则的 pattern 再匹配一次，从而 frob 也会被计入到单词总数中。如果去掉这个 REJECT，&amp;ldquo;frob&amp;rdquo; 就只会触发第一条规则，从而单词个数统计出错。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;yymore()&lt;/code&gt;：告诉 scanner 下一次匹配到某条规则的时候要将 token 追加到本次的 token 后面而不是覆盖，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;%%
mega-    ECHO; yymore();
kludge   ECHO;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果 scanner 的输入是 &amp;ldquo;mega-kludge&amp;rdquo;，那么输出结果将会是 &amp;ldquo;mega-mega-kludge&amp;rdquo;，因为匹配到 kludge 时由于前一次 &amp;ldquo;mega-&amp;rdquo; 调用了 &lt;code&gt;yymore()&lt;/code&gt;，所以 ECHO 的时候将 &amp;ldquo;kludge&amp;rdquo; 追加到之前的 &amp;ldquo;mega-&amp;rdquo; 后面。&lt;/p&gt;
&lt;p&gt;两条注记：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;yymore()&lt;/code&gt; 的正确执行要求用户代码不能随意更改 &lt;code&gt;yyleng&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;yymore()&lt;/code&gt; 会轻微影响 scanner 匹配的效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;yyless(n)&lt;/code&gt;：将当前 token 除了前 n 个字符以外的后续字符退回到输入流中供 scanner 下次再扫描。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;%%
foobar    ECHO; yyless(3);
[a-z]+    ECHO;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果 scanner 的输入是 &amp;ldquo;foobar&amp;rdquo;，那么输出结果将会是 &amp;ldquo;foobarbar&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;特别地，&lt;code&gt;yyless(0)&lt;/code&gt; 会将整个 token 退回到输入流中，所以除非 action 中有 BEGIN，调用 &lt;code&gt;yyless(0)&lt;/code&gt; 将会导致死循环。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;unput(c)&lt;/code&gt;：将字符 c 放入到输入流中，scanner 下一个扫描到的字符将会是字符 c。例如，下面的代码会将匹配到的 token 左右加上括号退回到输入流中 (注意 &lt;code&gt;unput(c)&lt;/code&gt; 的语义要求必须要将字符按照倒序退回到输入流中，这样再次扫描得到的才是正序)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;{
int i;
/* Copy yytext because unput() trashes yytext */
char *yycopy = strdup(yytext);
unput(&#39;)&#39;);
for (i = yyleng - 1; i &amp;gt;= 0; i--)
    unput(yycopy[i]);
unput(&#39;(&#39;);
free(yycopy);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;unput()&lt;/code&gt; 需要格外注意的一点是：如果 yytext 使用的是默认的 %pointer，调用 &lt;code&gt;unput()&lt;/code&gt; 会损坏 yytext 的内容 (每调用一次都会覆盖最右侧的一个字符)，因此如果想要保留 yytext 原本的内容，要么像示例代码一样提前把内容复制出来 (不能只复制指针！)，要么使用 %array 作为 yytext。&lt;/p&gt;
&lt;p&gt;此外，不可以调用 &lt;code&gt;unput()&lt;/code&gt; 将 &lt;code&gt;&amp;lt;EOF&amp;gt;&lt;/code&gt; 放入到输入流中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;input()&lt;/code&gt;：读取输入流中的下一个字符。例如下面的代码可以吃掉输入中的 C 注释：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;%%
&amp;quot;/*&amp;quot;    {
        int c;
        for (;;)
        {
            while ((c = input()) != &#39;*&#39; &amp;amp;&amp;amp; c != EOF)
                ; /* eat up text of comment */
            if (c == &#39;*&#39;)
            {
                while ((c = input()) == &#39;*&#39;)
                    ;
                if (c == &#39;/&#39;)
                    break; /* found the end */
            }
            if (c == EOF)
            {
                error(&amp;quot;EOF in comment&amp;quot;);
                break;
            }
        }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：如果 scanner 是用 C++ 编译的，那么应当使用 &lt;code&gt;yyinput()&lt;/code&gt; 以避免函数名与 C++ 自带函数冲突。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;9-the-generated-scanner&#34;&gt;9. The Generated Scanner&lt;/h2&gt;
&lt;p&gt;flex 的输出是一个 C 文件 &lt;code&gt;lex.yy.c&lt;/code&gt;，其中有一个 scanning routine &lt;code&gt;yylex()&lt;/code&gt;，一些用于匹配 token 的表格和一些其他的辅助 routine 和 macro。默认情况下 &lt;code&gt;yylex()&lt;/code&gt; 的声明是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int yylex()
{
    ... various definitions and actions in here
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过定义 &lt;code&gt;YY_DECL&lt;/code&gt; 宏的方式我们可以修改 &lt;code&gt;yylex()&lt;/code&gt; 的声明，比如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#define YY_DECL float lexscan(a, b) float a, b;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;的方式将 &lt;code&gt;yylex()&lt;/code&gt; 改名为 &lt;code&gt;lexscan()&lt;/code&gt;，返回值是 float 且接受两个参数 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;b&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当 &lt;code&gt;yylex()&lt;/code&gt; 被调用后，它会从文件 &lt;code&gt;yyin&lt;/code&gt; (默认为 stdin) 中扫描 token 并执行 action，当 action 主动返回或者遇到 EOF (此时返回值是 0) 时 &lt;code&gt;yylex()&lt;/code&gt; 会停止运行，否则会一直执行。&lt;/p&gt;
&lt;p&gt;当 &lt;code&gt;yylex()&lt;/code&gt; 遇到 EOF 时，后续的执行过程是未定义的，除非 &lt;code&gt;yyin&lt;/code&gt; 指向了新的输入文件或者 &lt;code&gt;yyrestart()&lt;/code&gt; 被调用。注意调用 &lt;code&gt;yyrestart()&lt;/code&gt; 不会将 start condition 置为 INITIAL；当 &lt;code&gt;yylex()&lt;/code&gt; 因 action 返回而终止时，&lt;code&gt;yylex()&lt;/code&gt; 会再次被调用且从上一次终止的地方继续扫描。&lt;/p&gt;
&lt;p&gt;scanner 中的 ECHO 命令会输出到 &lt;code&gt;yyout&lt;/code&gt; 文件中 (默认为 stdout)，可以通过宏定义的方式来修改。&lt;/p&gt;
&lt;h2 id=&#34;10-start-conditions&#34;&gt;10. Start Conditions&lt;/h2&gt;
&lt;p&gt;flex 提供一种机制，可以让 rules 条件性地被激活。如果一条 rule 的前缀是 &lt;code&gt;&amp;lt;sc&amp;gt;&lt;/code&gt;，那么只有当 scanner 处于 &amp;ldquo;sc&amp;rdquo; 这个 start condition 的时候该 rule 才处于 active 的状态。&lt;/p&gt;
&lt;p&gt;start condition 在 definitions section 中定义。有两种定义方法：&lt;code&gt;%s sc&lt;/code&gt; 和 &lt;code&gt;%x sc&lt;/code&gt;，第一种方法是 inclusive 的 start condition，它的意思是没有任何前缀的规则默认也可以被该 sc 激活；第二种方法是 exclusive 的 start condition，它的意思是只有显式地标注了 &lt;code&gt;&amp;lt;sc&amp;gt;&lt;/code&gt; 前缀的规则才能被 sc 激活。举一个例子，下面的两段代码等价：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;%s example
%%
&amp;lt;example&amp;gt;foo    do_something();
bar             something_else();
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;%x example
%%
&amp;lt;example&amp;gt;foo             do_something();
&amp;lt;INITIAL, example&amp;gt;bar    something_else();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个特殊的前缀是 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;，它表示所有的 start condition，有这个前缀的规则在任何 start condition 下都处于 active 状态。&lt;/p&gt;
&lt;p&gt;在 action 中使用 &lt;code&gt;BEGIN&lt;/code&gt; 语句可以激活一个 start condition。一个特殊的用法是 &lt;code&gt;BEGIN(0)&lt;/code&gt; 和 &lt;code&gt;BEGIN(INITIAL)&lt;/code&gt;，它们的功能相同，都是指激活那些没有前缀的规则。&lt;/p&gt;
&lt;p&gt;如果有多条规则使用相同的 sc 前缀，我们可以使用如下语法简化代码的书写：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;&amp;lt;SCs&amp;gt; {
       pattern1    action1;
    pattern2    action2;
    ...
}
    /* equivalent to 
     * &amp;lt;SCs&amp;gt;pattern1    action1
     * &amp;lt;SCs&amp;gt;pattern2    action2
     * ...
     */
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>FAT Specification - Notes</title>
      <link>/posts/manualnotes/fat/</link>
      <pubDate>Tue, 14 Jun 2022 00:00:00 +0000</pubDate>
      <guid>/posts/manualnotes/fat/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;http://jyywiki.cn/pages/OS/manuals/MSFAT-spec.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Microsoft FAT Specification&lt;/a&gt; 的 local copy 见此处。以下是对该手册的精华部分的翻译和解读。&lt;/p&gt;
&lt;h2 id=&#34;section-1-definitions-and-notations&#34;&gt;Section 1: Definitions and Notations&lt;/h2&gt;
&lt;p&gt;这里只记录比较重要的定义和记号。&lt;!-- more --&gt;&lt;/p&gt;
&lt;h3 id=&#34;11-definition&#34;&gt;1.1 Definition&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;sector：可以独立于其他单元直接获取的最小单元。&lt;/li&gt;
&lt;li&gt;bad(defective) sector：损坏的 sector，其中的内容无法读写。&lt;/li&gt;
&lt;li&gt;cluster：一个 cluster 里包含若干个连续的 sector。cluster 是 allocation 的最小单位，为文件分配空间时必须分配整数个 cluster。&lt;/li&gt;
&lt;li&gt;volume：一段物理上连续的块地址空间 (可以理解为“全集”)。&lt;/li&gt;
&lt;li&gt;partition：分区，volume 中的一部分 sector。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-notations&#34;&gt;1.2 Notations&lt;/h3&gt;
&lt;p&gt;$ip(x)\triangleq [x],ceil(x)\triangleq\lceil x\rceil,rem(x/y)\triangleq x\space \text{mod}\space y$。&lt;/p&gt;
&lt;h2 id=&#34;section-2-volume-structure&#34;&gt;Section 2: Volume Structure&lt;/h2&gt;
&lt;p&gt;FAT 文件系统的结构如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;BPB&lt;/th&gt;
&lt;th&gt;&amp;hellip;&lt;/th&gt;
&lt;th&gt;BPB&lt;/th&gt;
&lt;th&gt;&amp;hellip;&lt;/th&gt;
&lt;th&gt;File Allocation Table&lt;/th&gt;
&lt;th&gt;FAT copy&lt;/th&gt;
&lt;th&gt;Root Directory&lt;/th&gt;
&lt;th&gt;Data&lt;/th&gt;
&lt;th&gt;&amp;hellip;&lt;/th&gt;
&lt;th&gt;Data&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Reserved Region&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;FAT Region&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Root Directory Region (FAT12/FAT16)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;File &amp;amp; Directory (Data) Region&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;FAT 中的数据存储是小端的。&lt;/p&gt;
&lt;h2 id=&#34;section-3-boot-sector-and-bpb&#34;&gt;Section 3: Boot Sector and BPB&lt;/h2&gt;
&lt;p&gt;BPB (BIOS Parameter Block) 位于 reserved region 的第一个 sector。这个 sector 也被称为 boot sector 或者 0 号 sector。所有的 FAT 文件系统的 boot sector 中都必须有 BPB。以下的变量中以 &lt;code&gt;BPB_&lt;/code&gt; 开头的属于 BPB 的内容，以 &lt;code&gt;BS_&lt;/code&gt; 开头的实际上是 boot sector 的内容，不属于 BPB。&lt;/p&gt;
&lt;h3 id=&#34;31-bpb-structure-common-to-fat12-fat16-and-fat32-implementations&#34;&gt;3.1 BPB structure common to FAT12, FAT16, and FAT32 Implementations&lt;/h3&gt;
&lt;p&gt;这部分的 BPB 结构是 FAT12, FAT16 和 FAT32 共有的。使用 C 代码可以表示如下 (注：定义结构体时使用 &lt;code&gt;__attribute__((__packed__))&lt;/code&gt; 可以不让编译器自动对齐)。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct BPB_common {
    char      BS_jmpBoot[3];   /* 0  */
    char      BS_OEMName[8];   /* 3  */
    uint16_t  BPB_BytsPerSec;  /* 11 */
    uint8_t   BPB_SecPerClus;  /* 13 */
    uint16_t  BPB_RsvdSecCnt;  /* 14 */
    uint8_t   BPB_NumFATs;     /* 16 */
    uint16_t  BPB_RootEntCnt;  /* 17 */
    uint16_t  BPB_TotSec16;    /* 19 */
    uint8_t   BPB_Media;       /* 21 */     
    uint16_t  BPB_FATSz16;     /* 22 */
    uint16_t  BPB_SecPerTrk;   /* 24 */  
    uint16_t  BPB_NumHeads;    /* 26 */ 
    uint32_t  BPB_HiddSec;     /* 28 */
    uint32_t  BPB_TotSec32;    /* 32 */ 
}__attribute__((__packed__));    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;各个字段的解释如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;BS_jmpBoot：包含了一个 3 个字节的 Inter x86 格式的无条件跳转指令，用于跳转到操作系统的 bootstrap code。boot code 通常位于 boot sector 的尾部，跟在 BPB 后面。两种常见的 jump instruction 的格式为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;jmpBoot[0] = 0xEB; jmpBoot[1] = 0x??; jmpBoot[2] = 0x90;
jmpBoot[0] = 0xE9; jmpBoot[1] = 0x??; jmpBoot[2] = 0x??;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BS_OEMName：占 8 个字节，可以在 FAT 的实现中被指定为任何值。其内容通常为格式化该磁盘的系统名称 (比如如果使用 Linux 的 &lt;code&gt;mkfs.fat&lt;/code&gt; 命令创建磁盘镜像，该字段就会是 &amp;ldquo;mfks.fat&amp;rdquo;)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BPB_BytsPerSec：每个 sector 的字节数。&lt;u&gt;该值只能是 512, 1024, 2048, 4096 中的一个&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BPB_SecPerClus：每个 cluster 的 sector 数。&lt;u&gt;该值必须大于 0 且是 2 的幂次&lt;/u&gt;。因为该字段只占一个字节，因此合法的值只有 1, 2, 4, 8, 16, 32, 64, 128。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BPB_RsvdSecCnt：reserved region 中的 reserved sector 的个数。该值可以是任何非零整数。通常情况下，这个字段用于使数据区的开头 (即 cluster #2) 地址对齐。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BPB_NumFATs：file allocation table 的个数。通常来说 2 是一个比较推荐的数值 (为了防止磁盘受损导致的文件系统损坏)，但 1 也是允许的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BPB_RootEntCnt：对于 FAT12 和 FAT16，该字段表示根目录下 32-byte 目录项的个数，&lt;u&gt;&lt;code&gt;BPB_RootEntCnt * 32&lt;/code&gt; 理应是 &lt;code&gt;BPB_BytsPerSec&lt;/code&gt; 的偶数倍。在 FAT16 中，为了达到最大的兼容性，该值应当设置为 512。对于 FAT32，该值必须是 0&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BPB_TotSec16：对于 FAT12 和 FAT16，该字段表示了文件系统中 sector 的数目。该字段只有 2 个字节，如果 sector 的数目大于等于 &lt;code&gt;0x10000&lt;/code&gt;，则高位部分会存储到 BPB_TotSec32 中。&lt;u&gt;对于 FAT32，该字段必须是 0&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BPB_Media：合法的值有 0xF0, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE 和 0xFF。&lt;u&gt;对于不可移动的固定磁盘，0xF8 是标准值；如果是可移动设备，该字段通常是 0xF0&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BPB_FATSz16：对于 FAT12 和 FAT16，该字段表示一个 FAT 中 16-bit sector 的个数。&lt;u&gt;对于 FAT32，该字段必须是 0&lt;/u&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BPB_SecPerTrk：该字段只在一些有着特定几何特征 (一个 volume 被划分成多个轨道，有多个读写头) 的设备上有用，表示了每个 track 上 sector 的数目。该字段是为 0x13 号中断准备的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BPB_NumHeads：读写头数量。该字段也是为 0x13 号中断准备的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BPB_HiddSec：该字段表示了这个 FAT 分区后面的隐藏 sector 的数目，也是为 0x13 号中断准备的。&lt;u&gt;对于没有分区的设备，该字段必须为 0&lt;/u&gt;。此外，利用该字段来对齐数据区是不正确的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BPB_TotSec32：对于 FAT32，该字段表示了文件系统中 sector 的数目。对于 FAT12 和 FAT16，如果 BPB_TotSec16 足够存放对应数值，则该字段为 0，否则该字段会存储数据的高位。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-extended-bpb-structure-for-fat12-and-fat16-volumes&#34;&gt;3.2 Extended BPB structure for FAT12 and FAT16 volumes&lt;/h3&gt;
&lt;p&gt;如果是 FAT12 和 FAT16，boot sector 中还有如下的一些字段 (紧跟在 BPB_common 之后)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct BPB_16bit {
    uint8_t   BS_DrvNum;        /* 36 */          
    uint8_t   BS_Reserved1;     /* 37 */     
    uint8_t   BS_BootSig;       /* 38 */   
    uint32_t  BS_VolID;         /* 39 */ 
    char      BS_VolLab[11];    /* 43 */      
    char      BS_FilSysType[8]; /* 54 */         
    uint8_t   __padding[448];   /* 62 */       
    uint16_t  Signature_word;   /* 510 */       
}__attribute__((__packed__));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;各个字段的解释如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BS_DrvNum：0x13 号中断的驱动号，&lt;u&gt;设置成 0x80 或 0x00&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;BS_Reserved1：保留字段，&lt;u&gt;设置为 0x0&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;BS_BootSig：&lt;u&gt;如果后面两个字段 (BS_VolID 和 BS_VolLab) 中的任何一个是非零数，将该字段设置为 0x29&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;BS_VolID：该字段和 BS_VolLab 共同支持了可移动设备上的 volume tracking。这些字段使得 FAT 文件系统驱动可以识别出插入到可移动驱动上的错误磁盘。&lt;u&gt;BS_VolID 应当通过将当前日期和时间拼接成 32 位数值的方式生成&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;BS_VolLab：Volume label。该字段的内容应当和根目录下的 11 字节 volume label 相同。FAT 文件系统应当保证如果根目录下的 volume label 被创建或者修改，该字段也会被更新。如果没有 volume label，该字段会被填充为 &amp;ldquo;NO NAME    &amp;ldquo;。&lt;/li&gt;
&lt;li&gt;BS_FilSysType：&amp;ldquo;FAT12   &amp;ldquo;，&amp;ldquo;FAT16   &amp;quot; 或 &amp;ldquo;FAT     &amp;quot; 中的一个。注意该字段只是起到一个提供信息的作用，并不用于决定 FAT 的类型。&lt;/li&gt;
&lt;li&gt;Signature_word：&lt;u&gt;偏移量为 510 的 byte 为 0x55，偏移量为 511 的 byte 为 0xaa&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;33-extended-bpb-structure-for-fat32-volumes&#34;&gt;3.3 Extended BPB structure for FAT32 volumes&lt;/h3&gt;
&lt;p&gt;如果是 FAT32，boot sector 中还会有如下的一些字段 (紧跟在 BPB_common 之后)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct BPB_32bit {
    uint32_t  BPB_FATSz32;      /* 36 */      
    uint16_t  BPB_ExtFlags;     /* 40 */       
    uint16_t  BPB_FSVer;        /* 42 */    
    uint32_t  BPB_RootClus;     /* 44 */       
    uint16_t  BPB_FSInfo;       /* 48 */     
    uint16_t  BPB_BkBootSec;    /* 50 */        
    char      BPB_Reserved[12]; /* 52 */           
    uint8_t   BS_DrvNum;        /* 64 */    
    uint8_t   BS_Reserved1;     /* 65 */           
    uint8_t   BS_BootSig;       /* 66 */           
    uint32_t  BS_VolID;         /* 67 */           
    char      BS_VolLab[11];    /* 71 */           
    char      BS_FilSysType[8]; /* 82 */           
    uint8_t   __padding[420];   /* 90 */           
    uint16_t  Signature_word;   /* 510 */           
}__attribute__((__packed__));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;各个字段的解释如下 (和 FAT12/FAT16 相同的部分不再解释)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BPB_FATSz32：一个 FAT 中包含的 32-bit sector 数目。&lt;/li&gt;
&lt;li&gt;BPB_ExtFlags：各个位的标志信息如下
&lt;ul&gt;
&lt;li&gt;0-3 位：当前 active 的 FAT 的编号，这个编号是 0-based 的，仅在 mirroring 被关闭时有效。&lt;/li&gt;
&lt;li&gt;4-6 位：reserved。&lt;/li&gt;
&lt;li&gt;7 位：该位是 0 表示 FAT 会在运行时镜像到所有的 FAT 中；该位是 1 表示只有一个 FAT 是活跃的，这个活跃的 FAT 的编号通过 0-3 位表示。&lt;/li&gt;
&lt;li&gt;8-15 位：reserved。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BPB_FSVer：高位的 byte 存储主版本号 (major)，低位的 byte 存储小版本号 (minor)。&lt;u&gt;现阶段该值必须被设置为 0x0&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;BPB_RootClus：该字段表示了根目录的第一个 cluster 的编号。该值通常是 2，如果有出现 cluster 损坏的情况，则该值是 2 之后第一个可用的 cluster 的编号。&lt;/li&gt;
&lt;li&gt;BPB_FSInfo：该字段表示了 FAT32 的 reserved area 中 FSINFO 结构体所在的 sector 编号，通常为 1。值得注意的是，在 boot sector 的备份中也会有一个 FSINTO 结构体，但主 boot sector 和备份 boot sector 的该字段会指向同一个 FSINFO 结构体，只有那个被指向的结构体才是 up-to-date 的。&lt;/li&gt;
&lt;li&gt;BPB_BkBootSec：&lt;u&gt;该字段的值是 0 或 6&lt;/u&gt;。如果非零，它表示了 boot record 的备份所在的 sector 号 (6 号)。&lt;/li&gt;
&lt;li&gt;BPB_Reserved：reserved。&lt;u&gt;必须被设置为 0x0&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;34-initialization-of-a-fat-volume&#34;&gt;3.4 Initialization of a FAT volume&lt;/h3&gt;
&lt;p&gt;Section 3.5 会介绍如何决定 FAT 的类型 (12/16/32)，本 section 主要介绍在 volume 初始化时如何填写 BPB 中的字段。FAT implementation 要保证可以挂载填写了合法数值的 BPB 的设备。&lt;/p&gt;
&lt;p&gt;软盘会被格式化为 FAT12，一个简单的、事先准备好的表格决定了软盘中 BPB 的各个字段的值。注意：FAT12 要求设备容量 &amp;lt;= 4MB。&lt;/p&gt;
&lt;p&gt;对于每个 sector 大小为 512B 的设备，如果设备大小 &amp;lt; 512MB，该设备会被格式化为 FAT16，否则会被格式化为 FAT32。覆盖默认的 FAT 类型选择是可能的。&lt;/p&gt;
&lt;p&gt;下面的表格来自 Microsoft Corporation FAT format utility。对于 FAT16，填写 BPB_SecPerClus 的表格如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct DSKSZTOSECPERCLUS {
    DWORD DiskSize;       // 以512byte sector为单位
    BYTE  SecPerClusVal;
};

DSKSZTOSECPERCLUS DskTableFAT16 [] = {
  {8400,      0},  /* disks up to 4.1 MB, the 0 value for SecPerClusVal trips an error */
  {32680,     2},  /* disks up to 16 MB, 1k cluster */
  {262144,    4},  /* disks up to 128 MB, 2k cluster */
  {524288,    8},  /* disks up to 256 MB, 4k cluster */
  {1048576,  16}, /* disks up to 512 MB, 8k cluster */
  /* The entries after this point are not used unless FAT16 is forced */
  {2097152,   32},/* disks up to 1 GB, 16k cluster */
  {4194304,   64},/* disks up to 2 GB, 32k cluster */
  {0xFFFFFFFF, 0} /*any disk greater than 2GB, 0 value for SecPerClusVal trips an error */
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然 FAT16 一般只在 &amp;lt;= 512 MB 的情况下使用，但表格中仍然给出了一些大于 512MB 但强制要求使用 FAT16 的设备的填写方法。该表格的使用方法是：根据当前设备的 disk size，在表格中找出第一个小于等于 disk size 的表项，并将其第二个参数作为 BPB_SecPerClus，第一个参数会被填入 BPB_TotSec16。为了使该表格中的数值可以正确工作，BPB_RsvdSecCnt 需要被设置为 1，BPB_NumFATs 需要被设置为 2，BPB_RootEntCnt 需要被设置为 512。&lt;/p&gt;
&lt;p&gt;对于 FAT32，填写 BPB_SecPerClus 的表格如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;DSKSZTOSECPERCLUS DskTableFAT32 [] = {
  {66600,      0}, /* disks up to 32.5 MB, the 0 value for SecPerClusVal trips an error */
  {532480,     1}, /* disks up to 260 MB, .5k cluster */
  {16777216,   8}, /* disks up to 8 GB, 4k cluster */
  {33554432,   16}, /* disks up to 16 GB, 8k cluster */
  {67108864,   32}, /* disks up to 32 GB, 16k cluster */
  {0xFFFFFFFF, 64}  /* disks greater than 32GB, 32k cluster */
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了使该表格中的数值可以正确工作，BPB_RsvdSecCnt 需要被设置为 32，BPB_NumFATs 需要被设置为 2。&lt;/p&gt;
&lt;p&gt;下面的代码解释了如何计算 BPB_FATSz16/BPB_FATSz32 字段。该代码假设 BPB_RootEntCnt, BPB_RsvdSecCnt 和 BPB_NumFATs 已经被正确设置好。代码中的 DiskSize 是以 sector 为单位的 (即 BPB_TotSec16/BPT_TotSec32 中的值)。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytsPerSec – 1)) / BPB_BytsPerSec;
TmpVal1 = DskSize - (BPB_ResvdSecCnt + RootDirSectors);
TmpVal2 = (256 * BPB_SecPerClus) + BPB_NumFATs;
if (FATType == FAT32) {
    TmpVal2 = TmpVal2 / 2;
    FATSz = (TMPVal1 + (TmpVal2 – 1)) / TmpVal2;
}
if (FATType == FAT32) {
    BPB_FATSz16 = 0;
    BPB_FATSz32 = FATSz;
} else {
    BPB_FATSz16 = LOWORD(FATSz);
    /* there is no BPB_FATSz32 in a FAT16 BPB */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：该代码中的数学运算不是完美的，在一些情况下它算出的 FAT size 会过大，但它一定不会算小，这保证了它不会出错 (过大只是会浪费一些空间)。该代码的简洁是它的优势。&lt;/p&gt;
&lt;h3 id=&#34;35-determination-of-fat-type-when-mounting-the-volume&#34;&gt;3.5 Determination of FAT type when mounting the volume&lt;/h3&gt;
&lt;p&gt;FAT 类型唯一决定于 volume 中 cluster 的数量 (CountofClusters)。下面的步骤描述了计算 cluster 数量的过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;计算根目录占据的 sector 的数量：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytsPerSec - 1)) / BPB_BytsPerSec;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算数据区占据的 sector 的数量 (从总 sector 数量中扣除根目录和 FAT 的 sector 数量)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;FATSz   = (BPP_FATSz16 != 0) ? BPB_FATSz16 : BPB_FATSz32;
TotSec  = (BPB_TotSec16 != 0) ? BPB_TotSec16 : BPB_TotSec32;
DataSec = TotSec - (BPB_RsvdSecCnt + (BPB_NumFATs * FATSz) + RootDirSectors);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算 CountOfCluster：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;CountofClusters = DataSec / BPB_SecPerClus;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的 if 语句决定了 FAT 的类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if (CountofClusters &amp;lt; 4085) 
    {/* Volume is FAT12 */}
else if (CountofClusters &amp;lt; 6525) 
    {/* Volume is FAT16 */}
else 
    {/* Volume is FAT32 */}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：一个磁盘的 cluster 数目最好不要卡在边界上 (比如 4085 个 cluster 或 65525 个 cluster)，与边界值的差最好大于 16。&lt;/p&gt;
&lt;p&gt;最大的可使用的 cluster 号是 &lt;code&gt;CountofCluster + 1&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;36-backup-bpb-structure&#34;&gt;3.6 Backup BPB Structure&lt;/h3&gt;
&lt;p&gt;sector #0 的损坏会对文件系统产生毁灭性的打击，因此为 BPB 做备份是很重要的。在 FAT32 中，sector #6 必须包含 BPB 的备份。&lt;/p&gt;
&lt;p&gt;无论是 sector #0 中的 BPB 还是 sector #6 中的备份 BPB，BPB_BkBootSec 字段中的值都是 6。&lt;/p&gt;
&lt;p&gt;当 sector #0 无法读取时，volume repair utility 应当从 sector #6 提取信息。&lt;/p&gt;
&lt;h2 id=&#34;section-4-fat&#34;&gt;Section 4: FAT&lt;/h2&gt;
&lt;p&gt;File Allocation Table 中的每一个 entry 都代表了一个 cluster 的状态。FAT12 中每个 FAT entry 占 12 个 bit，FAT16 中每个 FAT entry 占 16 个 bit，FAT32 中每个 FAT entry 占 32 个 bit。FAT 表中的 entry 可能比可以分配的 cluster 的数目更多，那些多出来的 FAT entry 必须被置为 0。&lt;/p&gt;
&lt;p&gt;FAT 定义了表示文件的单向链表。整个磁盘中的第一个 cluster 的编号是 2。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：一个 FAT 中的目录文件本身只是一个普通文件，它有一个特殊的属性表明它自己是目录，该文件的内容是一系列的 32 字节的目录项。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;FAT entry 的内容如下表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;FAT12&lt;/th&gt;
&lt;th&gt;FAT16&lt;/th&gt;
&lt;th&gt;FAT32&lt;/th&gt;
&lt;th&gt;Comments&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0x000&lt;/td&gt;
&lt;td&gt;0x0000&lt;/td&gt;
&lt;td&gt;0x0000000&lt;/td&gt;
&lt;td&gt;cluster 当前空闲&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x002~MAX&lt;/td&gt;
&lt;td&gt;0x0002~MAX&lt;/td&gt;
&lt;td&gt;0x0000002~MAX&lt;/td&gt;
&lt;td&gt;cluster 在使用中，FAT entry 的内容是链表中下一个 cluster 的编号。MAX 指的是最大的合法 cluster 编号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(MAX+1)~0xFF6&lt;/td&gt;
&lt;td&gt;(MAX+1)~0xFFF6&lt;/td&gt;
&lt;td&gt;(MAX+1)~0xFFFFFF6&lt;/td&gt;
&lt;td&gt;reserved，不可使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0xFF7&lt;/td&gt;
&lt;td&gt;0xFFF7&lt;/td&gt;
&lt;td&gt;0xFFFFFF7&lt;/td&gt;
&lt;td&gt;cluster 损坏&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0xFF8~0xFFE&lt;/td&gt;
&lt;td&gt;0xFFF8~0xFFFE&lt;/td&gt;
&lt;td&gt;0xFFFFFF8~0xFFFFFFE&lt;/td&gt;
&lt;td&gt;reserved，不可使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0xFFF&lt;/td&gt;
&lt;td&gt;0xFFFF&lt;/td&gt;
&lt;td&gt;0xFFFFFFF&lt;/td&gt;
&lt;td&gt;cluster 在使用中，是一个文件的最后一个 cluster&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注：(1) FAT32 表项中的高 4 位不使用。&lt;/p&gt;
&lt;p&gt;(2) FAT12 中 FAT 的大小不能超过 6K 个 sector，FAT16 中 FAT 的大小不能超过 128K 个 sector，FAT32 没有限制。&lt;/p&gt;
&lt;h3 id=&#34;41-determination-of-fat-entry-for-a-cluster&#34;&gt;4.1 Determination of FAT entry for a cluster&lt;/h3&gt;
&lt;p&gt;给定一个合法的 cluster 号 $N$，该 section 主要介绍如何确定哪个 FAT entry 对应了这个 cluster。&lt;/p&gt;
&lt;h4 id=&#34;fat16-and-fat32&#34;&gt;FAT16 and FAT32&lt;/h4&gt;
&lt;p&gt;下面的代码给出了确定某一个 cluster 的 FAT entry 所在的 sector的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;FATSz = (BBP_FATSz16 != 0) ? BPB_FATSz16 : BPB_FATSz32;
FATOffset = (FATType == FAT16) ? (N * 2) : (N * 4);
ThisFATSecNum = BPB_RsvdSecCnt + (FATOffset / BPB_BytsPerSec);
ThisFATEntOffset = REM(FATOffset / BPB_BytsPerSec);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：FATX 的 FAT 是由若干个 X bit 的 FAT entry 紧密排列而成的，因此 &lt;code&gt;FATOffset&lt;/code&gt; 计算出了 $N$ 号 cluster 的 FAT entry 距离 FAT 表开头的偏移字节数，用这个字节数除以 BPB_BytsPerSec 即可得到 sector 号，取余即可得到 sector 内的偏移量。&lt;/p&gt;
&lt;p&gt;上述代码求得的 ThisFATSecNum 是 cluster 在第一份 FAT 中的 FAT entry 所在 sector 号。如果要求其他 FAT 中的 FAT entry 的 sector 号，可以参考如下公式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;SectorNumber = (FatNumber * FATSz) + ThisFatSecNum;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将磁盘映射到内存中之后，我们可以用如下方法读取一个 FAT entry 的内容 (下面的代码中 SecBuff 是指向对应 sector 开头的指针，WORD 是 16bit，DWORD 是 32bit)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if (FATType == FAT16)
    FAT16ClusEntryVal = *((WORD *) &amp;amp;SecBuff[ThisFATEntOffset]);
else
    FAT32ClusEntryVal = (*((DWORD *) &amp;amp;SecBuff[ThisFATEntOffset])) &amp;amp; 0x0FFFFFFF;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以用如下方法修改一个 FAT entry：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if (FATType == FAT16)    
    *((WORD *) &amp;amp;SecBuff[ThisFATEntOffset]) = FAT16ClusEntryVal;
else {    
    FAT32ClusEntryVal &amp;amp;= 0x0FFFFFFF;    
    *((DWORD *) &amp;amp;SecBuff[ThisFATEntOffset]) = (0xF0000000 | FAT32ClusEntryVal);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;u&gt;注：FAT16/FAT32 的表项不能跨 sector 存储。&lt;/u&gt;&lt;/p&gt;
&lt;h4 id=&#34;fat12&#34;&gt;FAT12&lt;/h4&gt;
&lt;p&gt;FAT12 中的每个 FAT entry 占 12bit (1.5 个字节)。所有的计算方法和 FAT16/FAT32 类似，但由于字节数不是整数，所以涉及一些微妙的运算：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if (FATType == FAT12) FATOffset = N + (N / 2); // 这里的“/”是下取整
ThisFATSecNum = BPB_RsvdSecNum + (FATOffset / BPB_BytsPerSec);
ThisFATEntOffset = REM(FATOffset / BPB_BytsPerSec);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 FAT12 中，一个 FAT entry 是有可能跨 sector 存储的，下面给出了判断方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if (ThisFATEntOffset == (BPB_BytsPerSec - 1)) {
    // 该FAT entry跨sector存储
    // 最简单的应对方法是每次读取时总是读取连续的两个sector:N和N+1(除非N是最后一个sector)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;FAT12 中读取 FAT entry 内容的方法也有一些微妙：因为每个 FAT entry 占 12 个 bit，所以两个 FAT entry 正好占据 3 个字节。我们计算出的 ThisFATEntOffset 对应的是该 FAT entry 所在的第一个 byte 的地址，这意味着对于奇数 cluster 而言 FAT entry 是从 ThisFATEntOffset 的开头开始的，对于偶数 cluster 而言 FAT entry 是从 ThisFATEntOffset 所在字节的后 4 个 bit 开始的，因此代码逻辑如下 (注：&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 是逻辑右移)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;FAT12ClusEntryVal = *((WORD *) &amp;amp;SecBuff[ThisFATEntOffset]); // 先读出16个bit
if (N &amp;amp; 0x0001)
    FAT12ClusEntryVal &amp;gt;&amp;gt;= 4;     // 16个bit中只有前12个bit是表项，低位4个bit应当清空
else
    FAT12ClusEntryVal &amp;amp;= 0x0FFF; // 16个bit中只有后12个bit是表项，高位4个bit应当清空
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改一个表项的方法为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if (N &amp;amp; 0x0001) {
    FAT12ClusEntryVal &amp;lt;&amp;lt;= 4;
    *((WORD *) &amp;amp;SecBuff[ThisFATEntOffset]) &amp;amp;= 0x000F;
}
else {
    FAT12ClusEntryVal &amp;amp;= 0x0FFF;
    *((WORD *) &amp;amp;SecBuff[ThisFATEntOffset]) &amp;amp;= 0xF000;
}
*((WORD *) &amp;amp;SecBuff[ThisFATEntOffset]) |= FAT12ClusEntryVal;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;42-reserved-fat-entries&#34;&gt;4.2 Reserved FAT entries&lt;/h3&gt;
&lt;p&gt;FAT 的前两个 FAT entry 是 reserved 的。&lt;/p&gt;
&lt;p&gt;第一个 FAT entry (FAT[0]) 的内容为：低 8 位保存了 BPB_Media 的值，剩下的位置为 1。&lt;/p&gt;
&lt;p&gt;第二个 FAT entry (FAT[1]) 的内容位：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于 FAT12：该 entry 保存了 EOC mark。&lt;/li&gt;
&lt;li&gt;对于 FAT16 和 FAT32：MS Windows 的设备驱动将最高的两个位作为 dirty volume 标志位，剩下的其他位置为 1。这里的高 2 位指的是 FAT16 中的 0x8000 (ClnShutBitMask) 和 0x4000 (HrdErrBitMask)，FAT32 中的 0x08000000 (ClnShutBitMask) 和 0x04000000 (HrdErrBitMask)。
&lt;ul&gt;
&lt;li&gt;ClnShutBitMask 位：如果这个位是 1，那么这个 volume 当前是干净的，可以被挂载并访问；如果这个位是 0，那么这个 volume 是 dirty 的，FAT 文件系统驱动无法正确地解挂载这个 volume，该 volume 的内容应当被扫描一遍以确定是否有 metadata 的损坏。&lt;/li&gt;
&lt;li&gt;HrdErrBitMask 位：该位是 1 说明没有遇到任何 read/write 错误。该位是 0 说明自上一次挂载以来 FAT 文件系统驱动遇到过 read/write 错误，可能有 sector 损坏了。该 volume 的内容应当被扫描一遍以确定是否有损坏的 sector。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;43-free-space-determination&#34;&gt;4.3 Free space determination&lt;/h3&gt;
&lt;p&gt;文件系统驱动必须扫描所有的 FAT entry 以构建一系列的文件链表和获得所有的空闲 cluster。空闲的 cluster 对应  的 FAT entry 的值为 0。空闲 cluster 在 FAT 中并没有以一个链表的形式串起来，但在 FAT32 中，BPB_FSInfo sector 可能包含了空闲 cluster 的数目。&lt;/p&gt;
&lt;h3 id=&#34;44-other-points-to-note&#34;&gt;4.4 Other points to note&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;FAT 的实现不应当对 &lt;code&gt;(CountOfCluster + 1)&lt;/code&gt; FAT entry 之后的内容有任何的假设 (这个 entry 不一定在一个 sector 的结尾处)。并且在格式化时，FAT 的最后一个 sector 中最后一个 FAT entry 之后的部分应被置为 0。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个 FAT 包含的 sector 数可能比它实际需要的 sector 数多，这意味着 FAT 的最后可能会包含若干完全没有使用的 sector。驱动实现应当通过 CountOfCluster 来确定 FAT 中最后一个 valid sector 的编号。最后一个 valid sector 后面的 sector 应当全部被置为 0。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;section-5-file-system-information-fsinfo-structure&#34;&gt;Section 5: File System Information (FSInfo) Structure&lt;/h2&gt;
&lt;p&gt;FSInfo 结构体只在 FAT32 中有。该结构体应当在文件系统初始化时设置好并放在 sector #1 中 (即紧接着 BPB)，该结构体的备份存放在 sector #7 中。&lt;/p&gt;
&lt;p&gt;注：FSInfo 结构体中的所有信息都是建议性的，文件系统驱动应当在初始化时填好 FSInfo 的信息，但并不一定需要在磁盘读写的过程中动态更新这个结构体 (尽管手册建议这么做)。&lt;/p&gt;
&lt;p&gt;FSInfo 的各个字段如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct FSInfo {
    uint32_t FSI_LeadSig[4]; /*   0 */        
    uint8_t  FSI_rsvc1[480]; /*   4 */    
    uint32_t FSI_StrucBig;   /* 484 */      
    uint32_t FSI_Free_Count; /* 488 */        
    uint32_t FSI_Nxt_Free;   /* 492 */       
    uint8_t  FSI_rsvd2[12];  /* 496 */   
    uint32_t FSI_TrailSig;   /* 508 */      
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;各个字段的解释如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FSI_LeadSig：值为 0x41615252，用于确认 FSInfo 格式的签名。&lt;/li&gt;
&lt;li&gt;FSI_Rsvd1：reserved，必须置为 0。&lt;/li&gt;
&lt;li&gt;FSI_StrucSig：值为 0x61417272，一个额外用于确认 FSInfo 格式的签名。&lt;/li&gt;
&lt;li&gt;FSI_Free_Count：该字段值为磁盘中空闲 cluster 的数量，如果不清楚则置为 0xFFFFFFFF。该字段必须在 volume 挂载时确定，手册建议该字段在 volume 解挂载时仍然保存正确的 count。&lt;/li&gt;
&lt;li&gt;FSI_Next_Free：保存了磁盘上第一个空闲 cluster 的编号，如果不清楚则置为 0xFFFFFFFF。该字段必须在 volume 挂载时确定，手册建议该字段在 volume 解挂载时仍然保存正确的编号。&lt;/li&gt;
&lt;li&gt;FSI_Rsvd2：reserved，必须置为 0。&lt;/li&gt;
&lt;li&gt;FSI_TrailSig：值为 0xAA550000，用于确认 FSInfo 格式的签名&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;section-6-directory-structure&#34;&gt;Section 6: Directory Structure&lt;/h2&gt;
&lt;p&gt;FAT 的目录是一种特殊的文件，它像是一个容器，里面装了子目录和文件的相关信息。目录文件由一系列的 32 字节的目录项 (directory entry) 构成，每个目录项描述了一个子目录或一个文件。&lt;/p&gt;
&lt;p&gt;目录项的内容可以用如下结构体描述：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct Dirent {
    char     DIR_Name[11];     /* 0  */            
    uint8_t  DIR_Attr;         /* 11 */        
    uint8_t  DIR_NTRes;        /* 12 */         
    uint8_t  DIR_CrtTimeTenth; /* 13 */                
    uint16_t DIR_CrtTime;      /* 14 */           
    uint16_t DIR_CrtDate;      /* 16 */           
    uint16_t DIR_LstAccDate;   /* 18 */              
    uint16_t DIR_FstClusHI;    /* 20 */             
    uint16_t DIR_WrtTime;      /* 22 */           
    uint16_t DIR_WrtDate;      /* 24 */           
    uint16_t DIR_FstClusLO;    /* 26 */             
    uint32_t DIR_FileSize;     /* 28 */            
}__attribute__((__packed__));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;各个字段的解释如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DIR_Name：“短”文件名，不超过 11 个字节。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DIR_Attr：文件的属性，合法的属性值如下所示&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ATTR_READ_ONLY&lt;/th&gt;
&lt;th&gt;ATTR_HIDDEN&lt;/th&gt;
&lt;th&gt;ATTR_SYSTEM&lt;/th&gt;
&lt;th&gt;ATTR_VOLUME_ID&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0x01&lt;/td&gt;
&lt;td&gt;0x02&lt;/td&gt;
&lt;td&gt;0x04&lt;/td&gt;
&lt;td&gt;0x08&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;ATTR_DIRECTORY&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;ATTR_ARCHIVE&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;ATTR_LONG_NAME&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x10&lt;/td&gt;
&lt;td&gt;0x20&lt;/td&gt;
&lt;td&gt;0x0F (前四个的或)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;DIR_Attr 的高两个 bit 保留，必须被置为 0。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DIR_NTRes：reserved，必须置为 0。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DIR_CrtTimeTenth：创建时间 (低位)，以 1/10 秒为单位，合法范围是 &lt;code&gt;0&amp;lt;=DIR_CrtTimeTenth&amp;lt;=199&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DIR_CrtTime：创建时间 (高位)，颗粒度为 2s。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DIR_CrtDate：创建日期。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DIR_LstAccDate：上一次 access 该文件的日期。这里的 access 指的是对该文件/目录的 read/write 操作。该字段必须在文件修改时更新 (即写操作时)，填写的日期必须与 DIR_WrtDate 相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DIR_FstClusHI：该文件/目录的第一个 cluster 的编号的高 16 位。该字段仅对 FAT32 有效，FAT12/FAT16 中该字段必须置为 0。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DIR_WrtTime：上一次修改该文件的时间。在文件刚刚创建的时候，该字段的值应当与 DIR_CrtTime 一样。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DIR_WrtDate：上一次修改该文件的日期。在文件刚刚创建的时候，该字段的值应当与 DIR_CrtDate 一样。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DIR_FstClusLO：该文件/目录的第一个 cluster 的编号的低 16 位。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DIR_FileSize：文件大小，以字节为单位。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;61-filedirectory-name-field-dir_name&#34;&gt;6.1 File/Directory Name (field &lt;code&gt;DIR_Name&lt;/code&gt;)&lt;/h3&gt;
&lt;p&gt;DIR_Name 共有 11 个字节，分为两个部分：8 字节的 main part 和 3 字节的扩展名。如果某一个部分字节数不足，后面会用空格补足长度。&lt;/p&gt;
&lt;p&gt;以下是一些注意点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;main part 和扩展名之间默认有一个 &amp;ldquo;.&amp;quot;，这个点不会存储在 DIR_Name 中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DIR_Name[0] == 0xE5&lt;/code&gt; 代表这个目录项是空闲的。不过在 KANJI (日本语) 中 0xE5 这个字符是存在的，因此 KANJI 下 0xE5 会用 0x05 来代替。文件系统解析文件名时如果遇到首字节是 0x05 且字符集是 KANJI 时要将 0x05 替换成 0xE5 再返回。&lt;/li&gt;
&lt;li&gt;除了 0xE5，&lt;code&gt;DIR_Name[0] == 0x00&lt;/code&gt; 也代表这个目录项是空闲的。它与 0xE5 的不同在于 0x00 意味着后面跟着的所有目录项也都是空闲的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DIR_Name[0]&lt;/code&gt; 不能是 0x20，即文件名不能以空格开头。&lt;/li&gt;
&lt;li&gt;一个目录下的所有名字都必须是唯一的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于文件中字符的限制如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小写字母不允许出现。&lt;/li&gt;
&lt;li&gt;小于 0x20 的字符不允许出现 (除了上面提到的 KANJI 的 0x05)。&lt;/li&gt;
&lt;li&gt;0x22, 0x2A, 0x2B, 0x2C, 0x2E, 0x2F, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x5B, 0x5C, 0x5D 和 0x7C。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;62-filedirectory-attributes&#34;&gt;6.2 File/Directory Attributes&lt;/h3&gt;
&lt;p&gt;文件或子目录的属性值会影响文件系统驱动对该文件/子目录的操作方式。各种属性值的意义列举如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ATTR_READ_ONLY (0x01)：该文件不可修改，对该文件的修改操作会以返回错误码告终。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ATTR_HIDDEN (0x02)：除非用户显式地要求列举出隐藏文件，否则 hidden files 不应在列举目录下文件时出现 (可以理解为 &lt;code&gt;ls -a&lt;/code&gt; 和 &lt;code&gt;ls&lt;/code&gt; 的区别)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ATTR_SYSTEM (0x04)：该文件被标记为和操作系统相关的“系统文件”，除非用户显式地要求列举出系统文件，否则 system files 不应在列举目录下文件时出现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ATTR_VOLUME_ID (0x08)：该文件包含 volume label，这种情况下，DIR_FstClusHI 和 DIR_FstClusLO 必须都置为 0。&lt;/p&gt;
&lt;p&gt;只有根目录可以有一个 entry 包含该属性 (表示长文件名的 entry 不遵从该规则)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ATTR_DIRECTORY (0x10)：该目录项表示的是一个子目录。这种情况下，DIR_FileSize 必须为 0。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ATTR_ARCHIVE (0x20)：当文件被创建、重命名或修改时，该属性值必须被设置，标志该文件的相关信息已经被修改。在备份时，各种工具可以利用该属性来判断一个文件是否需要备份。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;63-datetime&#34;&gt;6.3 Date/Time&lt;/h3&gt;
&lt;p&gt;DIR_CrtTime, DIR_CrtTimeTenth, DIR_CrtDate, DIR_LstAccDate 这四个字段是选填的。文件系统驱动如果不支持这些字段，则必须将其置为 0。DIR_WrtTime 和 DIR_WrtDate 这两个字段是文件系统驱动必须正确更新的。&lt;/p&gt;
&lt;h4 id=&#34;date-format&#34;&gt;Date format&lt;/h4&gt;
&lt;p&gt;DIR_CrtDate, DIR_WrtDate, DIR_LstAccDate 这三个字段需要遵从日期的格式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0-4 bit：日 (1~31)&lt;/li&gt;
&lt;li&gt;5-8 bit：月 (1~12)&lt;/li&gt;
&lt;li&gt;9-15 bit：从 1980 年起的年份 (0~127，可以表示 1980~2107 年)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;time-format&#34;&gt;Time Format&lt;/h4&gt;
&lt;p&gt;DIR_CrtTime, DIR_WrtTime 这两个字段需要遵从时间格式。时间是以 2s 为颗粒度的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0-4 bit：秒 (以 2s 为单位，数值范围是 0~29，可以表示 0,2,4,&amp;hellip;,58)&lt;/li&gt;
&lt;li&gt;5-10 bit：分钟 (0~59)&lt;/li&gt;
&lt;li&gt;11-15 bit：小时 (0~23)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;64-filedirectory-size&#34;&gt;6.4 File/Directory Size&lt;/h3&gt;
&lt;p&gt;文件的最大大小是 0xFFFFFFFF 个字节。最大的目录大小是 $2^{21}$ 个字节。&lt;/p&gt;
&lt;h3 id=&#34;65-directory-creation&#34;&gt;6.5 Directory creation&lt;/h3&gt;
&lt;p&gt;当一个新的目录被创建时，文件系统实现必须保证以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DIR_Attr 的 ATTR_DIRECTORY bit 要置为 1。&lt;/li&gt;
&lt;li&gt;DIR_FileSize 必须置为 0。&lt;/li&gt;
&lt;li&gt;至少要分配一个 cluster，DIR_FstClusLO 和 DIR_FstClusHI 负责表示第一个 cluster 的编号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(以上三条说的时该目录在其父目录的 directory entry 中的内容)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果该目录只有一个 cluster，那么它对应的 FAT entry 应当被标记为 end-of-file。&lt;/li&gt;
&lt;li&gt;初始分配的 cluster 的内容应当置为 0。&lt;/li&gt;
&lt;li&gt;除了根目录，其他所有目录都必须在开头有如下的两个目录项：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt;：该目录项表示当前目录，之前提到的 DIR_Attr, DIR_FileSize 的规则仍然需要保持，DIR_FstClusLO 和   DIR_FstClusHI 以及所有的时间、日期字段必须和当前目录的保持一致。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;..&lt;/code&gt;：该目录项表示上一级目录，之前提到的 DIR_Attr, DIR_FileSize 的规则仍然需要保持，DIR_FstClusLO 和   DIR_FstClusHI 以及所有的时间、日期字段必须和上一级目录的保持一致 (如果上一级目录是根目录，则 DIR_FstClusLO 和 DIR_FstClusHI 必须都置为 0)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;66-root-directory&#34;&gt;6.6 Root Directory&lt;/h3&gt;
&lt;p&gt;根目录是一个特殊的 container file，在格式化时创建。&lt;/p&gt;
&lt;p&gt;在 FAT12 和 FAT16 中，根目录必须紧跟在最后一个 FAT 后，因此根目录的第一个 sector 的编号可以按照如下方式计算：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;FirstRootDirSecNum = BPB_RsvdSecCnt + (BPB_NumFATs * BPB_FATSz16);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根目录的大小根据 BPB_RootEntCnt 字段的值计算。&lt;/p&gt;
&lt;p&gt;在 FAT32 中，根目录是变长的，根目录的第一个 cluster 的编号存放在 BPB_RootClus 字段中。&lt;/p&gt;
&lt;p&gt;只有根目录的 DIR_Attr 字段的值可以等于 ATTR_VOLUME_ID。&lt;/p&gt;
&lt;p&gt;根目录没有名字 (在绝大多数操作系统中，&lt;code&gt;\&lt;/code&gt; 这个名字被用作根目录)，也没有任何的时间戳 (日期/时间)，也没有 &amp;ldquo;.&amp;rdquo;, &amp;ldquo;..&amp;rdquo; 这两个目录项。&lt;/p&gt;
&lt;h3 id=&#34;67-file-allocation&#34;&gt;6.7 File allocation&lt;/h3&gt;
&lt;p&gt;每个文件的目录项 (存储在包含这个文件的目录中) 都有该文件第一个 cluster 的编号。如果该文件大小为 0 则编号是 0。第一个 cluster 在 FAT 中对应的 FAT entry 要么存储了下一个 cluster 的编号，要么是一个 end-of-file 标志。&lt;/p&gt;
&lt;p&gt;data region 的第一个 sector (cluster #2) 的编号计算方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;FirstDataSector = BPB_RsvdSecCnt + (BPB_NumFATs * FATSz) + RootDirSectors;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给定一个合法的 cluster 编号 $N$，该 cluster 的第一个 sector 的编号的计算方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;FirstSectorofCluster = ((N - 2) * BPB_SecPerClus) + FirstDataSector;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;section-7-long-file-name-implementation-optional&#34;&gt;Section 7: Long File Name Implementation (optional)&lt;/h2&gt;
&lt;p&gt;上一个 section 中提到 DIR_Name 字段的长度只有 11 个 字节，其中前 8 个字节是 main part，后三个字节是扩展名。这种目录项被称为短名目录项。但用户很多时候喜欢给自己的文件或目录起长名字，本 section 主要关注如何存储长名的目录项。&lt;/p&gt;
&lt;p&gt;长文件名的文件的相关信息存储在一些额外的长名目录项中。注意这里的长名目录项不是独立的，而是作为短名目录项的补充。即每个文件有一个短名目录项，如果文件名过长则另有一些长名目录项专门存储名字。长名目录项必须紧靠着存放在对应的短名目录项前面 (即 长*n+短 = 一个文件/目录的描述)。&lt;/p&gt;
&lt;p&gt;长名目录项的内容可以用如下结构体表示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct LongDirent {
    uint8_t  LDIR_Ord;         /* 0  */       
    char     LDIR_Name1[10];   /* 1  */             
    uint8_t  LDIR_Attr;        /* 11 */        
    uint8_t  LDIR_Type;        /* 12 */        
    uint8_t  LDIR_Chksum;      /* 13 */          
    char     LDIR_Name2[12];   /* 14 */             
    uint16_t LDIR_FstClusLO;   /* 26 */             
    char     LDIR_Name3[4];    /* 28 */            
}__attribute__((__packed__));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;各个字段的解释如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;LDIR_Ord：该字段表示该长名目录项是其对应的短名目录项的第几个 (一个很长的名字可能需要多个长名目录项来存储)。对于最后一个长名目录项，其 LDIR_Ord 必须或上 LAST_LONG_ENTRY (0x40)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LDIR_Name1：长名的第 1 ~ 5 个字符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LDIR_Attr：长名目录项的 LDIR_Attr 必须被设置为 ATTR_LONG_NAME：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;ATTR_LONG_NAME = ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_VOLUME_ID;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用来判断一个目录项是否是长名目录项的 Mask 为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define ATTR_LONG_NAME_MASK (ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_VOLUME_ID | ATTR_DIRECTORY | ATTR_ARCHIVE);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LDIR_Type：必须被置为 0。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LDIR_ChkSum：针对其对应的短名目录项算出来的一个校验值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LDIR_Name2：长名的第 6 ~ 11 个字符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LDIR_FstClusLO：必须被置为 0。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LDIR_Name3：长名的第 12 ~ 13 个字符。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;71-ordinal-number-generation&#34;&gt;7.1 Ordinal Number Generation&lt;/h3&gt;
&lt;p&gt;一个短名目录项对应的一系列附属的长名目录项在 LDIR_Ord 这个字段上应当满足如下要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个长名目录项满足 &lt;code&gt;LDIR_Ord == 1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;后续的长名目录项的 LDIR_Ord 保证严格单调递增。&lt;/li&gt;
&lt;li&gt;最后一个长名目录项满足 &lt;code&gt;LDIR_Ord == (N | LAST_LONG_ENTRY)&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果以上任何一条不满足，我们就认为该长名目录项集合被损坏了。&lt;/p&gt;
&lt;h3 id=&#34;72-checksum-generation&#34;&gt;7.2 Checksum Generation&lt;/h3&gt;
&lt;p&gt;当短名目录项和长名目录项被创建的时候，我们需要创建一个 8 bit 的校验和。这个校验和根据短名目录项的 DIR_Name 字段生成：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;unsigned char ChkSum (unsigned char *pFcbName) {
    short FcbNameLen;
    unsigned char Sum = 0;
    
    for (FcbNameLen = 11; FcbNameLen != 0; FcbNameLen--)
        Sum = ((Sum &amp;amp; 1) ? 0x80 : 0) + (Sum &amp;gt;&amp;gt; 1) + *pFcbName++;
       return Sum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果长名目录项中的校验和与其对应的短名目录项算出来不一致，我们就认为该长名目录项集合被损坏了。&lt;/p&gt;
&lt;h3 id=&#34;73-example-illustrating-persistence-of-a-long-name&#34;&gt;7.3 Example illustrating persistence of a long name&lt;/h3&gt;
&lt;p&gt;下面的图片以 &amp;ldquo;The quick brown.fox&amp;rdquo; 这个名字为例展示了长名的存储方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/FAT_LongDirent.png&#34; alt=&#34;LongDirent&#34;&gt;&lt;/p&gt;
&lt;p&gt;长文件名不能超过 255 个字符 (不包括结尾的 NULL)。长文件名中的字符限制和短文件名基本一样 (见 Section 6.1)，一些额外的规则为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;长文件名中可以使用任意多个 &lt;code&gt;.&lt;/code&gt; 字符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;+&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;;&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;[&lt;/code&gt; &lt;code&gt;]&lt;/code&gt; 这六个特殊字符不能在短文件名中出现，但长文件名中也可以使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;长文件名中间允许有空格。开头和结尾的空格会被忽略。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;长名目录项中使用 unicode 来存储字符，unicode 中每个字符占 16 个 bit (2 个字节)，这是与短名目录项不同的地方。另一个不同是长名目录项可以区分大小写。&lt;/p&gt;
&lt;h3 id=&#34;74-rules-governing-name-creation-and-matching&#34;&gt;7.4 Rules governing name creation and matching&lt;/h3&gt;
&lt;p&gt;一个目录下所有短文件名和长文件名构成的集合被称为一个 namespace。一个 namespace 下的文件名应当遵循如下规定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不论是短文件名还是长文件名，在一个 namespace 中必须是全局唯一的。这里比较唯一性时忽略大小写，即如果两个名字字符一样但大小写不同也被认为是冲突的。&lt;/li&gt;
&lt;li&gt;如果一个 OEM 或 unicode 字符无法被转换成系统中的合适字符，文件系统应当将其翻译成 &lt;code&gt;_&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
