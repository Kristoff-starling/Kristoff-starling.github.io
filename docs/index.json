[{"authors":["admin"],"categories":null,"content":"I am Yuyao Wang (ç‹å®‡å³£), a junior in Computer Science (Elite Class) at Nanjing University. My research interest lies in topics related to the correctness, programmability and performance of computer systems.\nI have been attached to programming and algorithm design since middle school and aspire to bring elegant solutions for tackling real-world problems.\n","date":1554595200,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1554595200,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://kristoff-starling.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"I am Yuyao Wang (ç‹å®‡å³£), a junior in Computer Science (Elite Class) at Nanjing University. My research interest lies in topics related to the correctness, programmability and performance of computer systems.","tags":null,"title":"Yuyao Wang","type":"authors"},{"authors":["Xingyu Du"],"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"0d6933ca0ad9ac5c9273ee629802d4af","permalink":"https://kristoff-starling.github.io/authors/xingyudu/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/xingyudu/","section":"authors","summary":"","tags":null,"title":"Xingyu Du","type":"authors"},{"authors":null,"categories":null,"content":"Table of Contents Chapter 01: Computer Networks and the Internet Chapter 02: Application Layer ","date":1666310400,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1666310400,"objectID":"2575b8d873b8a1635316f61a7b16cacb","permalink":"https://kristoff-starling.github.io/notes/booknotes/network-topdown/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/booknotes/network-topdown/","section":"notes","summary":" ","tags":null,"title":"Computer Networking: A Top-Down Approach","type":"docs"},{"authors":null,"categories":null,"content":"Table of Contents Chapter 01: Introduction Chapter 02: The Untyped Lambda Calculus Chapter 03: Programming in the Untyped Lambda Calculus Chapter 04: The Church-Rosser Theorem Chapter 05: Combinatory Algebras Chapter 06: Simply-typed Lambda Calculus, Propositional Logic, and the CurryHoward Isomorphism Chapter 07: Polymorphism Chapter 08: Weak and Strong Normalization Chapter 09: Type Inference Chapter 10: Denotational Semantics Chapter 11: The Language PCF Chapter 12: Complete Partial Orders Chapter 13: Denotational Semantics of PCF ","date":1664928000,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1664928000,"objectID":"3fcbc6b6eb2f27e584dabb39263b2629","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-formal-semantics/material/lambda-calculus/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/nju-formal-semantics/material/lambda-calculus/","section":"notes","summary":"\\\"This is a set of lecture notes that developed out of courses on the lambda calculus that I taught at the University of Ottawa in 2001 and at Dalhousie University in 2007.\\\" â€”â€” Peter Selinger","tags":null,"title":"Peter Selinger's Lecture Notes on Lambda Calculus","type":"docs"},{"authors":null,"categories":null,"content":"Table of Contents Lecture 01: Introduction Lecture 02: Happens-before Memory Model Lecture 03: Operational Semantics for Concurrency Lecture 04: Declarative Semantics for Concurrency ","date":1664841600,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1664841600,"objectID":"2a0653b08a9cbc36b05b7dc71c957388","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-concurrency/lectures/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/nju-concurrency/lectures/","section":"notes","summary":" ","tags":null,"title":"Lectures","type":"docs"},{"authors":null,"categories":null,"content":"","date":1663200000,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1663200000,"objectID":"374c8d28ad1c9f7af1c7bf6f506abeee","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-software-analysis/lectures/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/nju-software-analysis/lectures/","section":"notes","summary":"","tags":null,"title":"Lectures","type":"docs"},{"authors":null,"categories":null,"content":"","date":1663113600,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1663113600,"objectID":"40328b85b93aeb0a52aa557afe34b0e6","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-formal-semantics/lectures/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/nju-formal-semantics/lectures/","section":"notes","summary":"","tags":null,"title":"Lectures","type":"docs"},{"authors":null,"categories":null,"content":" Introduction Cool Overview Lexical Analysis Implementation of Lexical Analysis Introduction to Parsing Syntax-Directed Translation Top-Down Parsing \u0026amp; Bottom-Up Parsing I Bottom-Up Parsing II Semantic Analysis \u0026amp; Type Checking I Type Checking II Run-time Environments Code Generation Operational Semantics Intermediate Code \u0026amp; Local Optimization Global Optimization Register Allocation Automatic Memory Management ","date":1661212800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1661212800,"objectID":"5d06d28104c09ae7aa5b926d2cac8927","permalink":"https://kristoff-starling.github.io/notes/coursenotes/stanford-compiler/lectures/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/stanford-compiler/lectures/","section":"notes","summary":"lexical analysis + parsing + semantics analysis + optimization + code generation","tags":null,"title":"Lectures","type":"docs"},{"authors":null,"categories":null,"content":"è¯¥è¯¾ç¨‹çš„ Lab ä» baremetal å¼€å§‹é€æ¸æ­å»ºä¸€ä¸ªå¯ä»¥åœ¨å¤šæ ¸ CPU ä¸Šå¹¶å‘è¿è¡Œã€æ”¯æŒç”¨æˆ·è¿›ç¨‹çš„æ“ä½œç³»ç»Ÿã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1607817600,"objectID":"21ec7694bef83cf5b0502ed09adae287","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/labs/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/labs/","section":"notes","summary":"è¯¥è¯¾ç¨‹çš„ Lab ä» baremetal å¼€å§‹é€æ¸æ­å»ºä¸€ä¸ªå¯ä»¥åœ¨å¤šæ ¸ CPU ä¸Šå¹¶å‘è¿è¡Œã€æ”¯æŒç”¨æˆ·è¿›ç¨‹çš„æ“ä½œç³»ç»Ÿã€‚","tags":null,"title":"Labs","type":"docs"},{"authors":null,"categories":null,"content":"è¯¥è¯¾ç¨‹çš„ lectures æŒ‰ç…§ Concurrency - Visualization - Persistence çš„é¡ºåºï¼Œä»‹ç»äº†æ“ä½œç³»ç»Ÿä¸­çš„åŸºæœ¬æ¦‚å¿µå’Œå‰æ²¿æŠ€æœ¯ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1607817600,"objectID":"3d067a47e16053fa3926033cf64be639","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/","section":"notes","summary":"è¯¥è¯¾ç¨‹çš„ lectures æŒ‰ç…§ Concurrency - Visualization - Persistence çš„é¡ºåºï¼Œä»‹ç»äº†æ“ä½œç³»ç»Ÿä¸­çš„åŸºæœ¬æ¦‚å¿µå’Œå‰æ²¿æŠ€æœ¯ã€‚","tags":null,"title":"Lectures","type":"docs"},{"authors":null,"categories":null,"content":"MiniLabs æ˜¯ä¸€äº›å½¼æ­¤ç›¸äº’ç‹¬ç«‹çš„å°å®éªŒï¼Œæ—¨åœ¨ä»è®¾è®¡çš„è§’åº¦ç†è§£æ“ä½œç³»ç»Ÿæä¾›çš„ API å¹¶åˆ©ç”¨è¿™äº› API å®ç°ä¸€äº›æœ‰è¶£çš„ç¨‹åºã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1607817600,"objectID":"0f7655e75b3bab2f2deb8b47a8f5f3d7","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/minilabs/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/minilabs/","section":"notes","summary":"MiniLabs æ˜¯ä¸€äº›å½¼æ­¤ç›¸äº’ç‹¬ç«‹çš„å°å®éªŒï¼Œæ—¨åœ¨ä»è®¾è®¡çš„è§’åº¦ç†è§£æ“ä½œç³»ç»Ÿæä¾›çš„ API å¹¶åˆ©ç”¨è¿™äº› API å®ç°ä¸€äº›æœ‰è¶£çš„ç¨‹åºã€‚","tags":null,"title":"MiniLabs","type":"docs"},{"authors":null,"categories":null,"content":"","date":1607817600,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1607817600,"objectID":"e1937f596829b06912cb810b6d4414f2","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-probability/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/nju-probability/","section":"notes","summary":"","tags":null,"title":"NJU-22020170 Probability and Mathematical Statistics","type":"docs"},{"authors":null,"categories":null,"content":"Table of Contents Introduction I. Visualization\nA Dialogue on Virtualization The Abstraction: The Process Interlude: Process API Mechanism: Limited Direct Execution Scheduling: Introduction Scheduling: The Multi-Level Feedback Queue Scheduling: Propositional Share Multiprocessor Scheduling (Advanced) Summary Dialogue on CPU Virtualization A Dialogue on Memory Virtualization The Abstraction: Address Spaces Interlude: Memory API Mechanism: Address Translation Segmentation Free-Space Management Paging: Introduction Paging: Faster Translations (TLBs) Paging: Smaller Tables Beyond Physical Memory: Mechanisms Beyond Physical Memory: Policies Complete Virtual Memory Systems Summary Dialogue on Memory Virtualization II. Concurrency\nA Dialogue on Concurrency Concurrency: An Introduction Interlude: Thread API Locks Lock-based Concurrent Data Structures Condition Variables Semaphores Common Concurrency Problems Event-based Concurrency (Advanced) Summary Dialogue on Concurrency III. Persistence\nA Dialogue on Persistence I/O Devices Hard Disk Drives Redundant Arrays of Inexpensive Disks (RAIDs) Interlude: Files and Directories File System Implementation Locality and The Fast File System Crash Consistency: FSCK and Journaling Log-structured File Systems Flash-based SSDs Data Integrity and Protection Summary Dialogue on Persistence A Dialogue on Distribution Distributed Systems Sun\u0026rsquo;s Network File System (NFS) The Andrew File System (AFS) Summary Dialogue on Distribution ","date":1607817600,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1607817600,"objectID":"f00baa52fc8a713c00655fb4b2b9940e","permalink":"https://kristoff-starling.github.io/notes/booknotes/ostep/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/booknotes/ostep/","section":"notes","summary":"The book is centered around three conceptual pieces that are fundamental to operating systems: virtualization, concurrency, and persistence. In understanding the conceptual, you will also learn the practical, including how an operating system does things like schedule the CPU, manage memory, and store files persistently.","tags":null,"title":"Operating Systems: Three Easy Pieces","type":"docs"},{"authors":null,"categories":null,"content":"","date":1607817600,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1607817600,"objectID":"e3aa4b99855ec6dec0bb7ea9f421b367","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-problem-solving/oj-solutions/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/nju-problem-solving/oj-solutions/","section":"notes","summary":"","tags":null,"title":"Solutions to OJ","type":"docs"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"0bb0517f08f022089f459897b2e0b5d5","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/homework/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/homework/","section":"notes","summary":"","tags":null,"title":"Homework","type":"docs"},{"authors":null,"categories":null,"content":"Labs for MIT-6.S081 include 11 independent tasks aiming at adding functionalities to xv6.\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"948ecda12c0288c0191088b06770dfd0","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-operating-system/labs/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-operating-system/labs/","section":"notes","summary":"Labs for MIT-6.S081 include 11 independent tasks aiming at adding functionalities to xv6.","tags":null,"title":"Labs","type":"docs"},{"authors":null,"categories":null,"content":"Table of Contents Lab 01: Variables \u0026amp; Functions, Control Lab 02: Higher-Order Function, Lambda Expressions Lab 04: Recursion, Tree Recursion, Python Lists Lab 05: Python Lists, Trees Lab 06: Mutability and Iterators Lab 07: Object-Oriented Programming ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"d6d74d9ba84f4cb0ea5fcdbaaed41ac0","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/labs/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/labs/","section":"notes","summary":"Labs include WWPD problems which focus on student's understanding of Python execution procedure and coding prlblems which focus on student's programming skills.","tags":null,"title":"Labs","type":"docs"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"2e983bd0deac7a2c83b0d0a442ba9af2","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-linearalgebra/lectures/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-linearalgebra/lectures/","section":"notes","summary":"","tags":null,"title":"Lectures","type":"docs"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"f535b09dd8654f24632de5ad88c5ed0f","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-operating-system/lectures/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-operating-system/lectures/","section":"notes","summary":"","tags":null,"title":"Lectures","type":"docs"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"17082a0b208b49488845e9016d984e95","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/lectures/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/lectures/","section":"notes","summary":"","tags":null,"title":"Lectures","type":"docs"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"719f3ebb42200ebd6634f258d0011403","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-ics/pa/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/nju-ics/pa/","section":"notes","summary":"","tags":null,"title":"Programming Assignments","type":"docs"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"0dbf121cfe5840e0d840af27f9d7c5f8","permalink":"https://kristoff-starling.github.io/notes/coursenotes/stanford-compiler/pa/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/stanford-compiler/pa/","section":"notes","summary":"","tags":null,"title":"Programming Assignments","type":"docs"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"289dfafecefe8104ac35d52d0ff8b86f","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/projects/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/projects/","section":"notes","summary":"","tags":null,"title":"Projects","type":"docs"},{"authors":null,"categories":null,"content":"Table of Contents Functional Programming in Coq (Basics) Proof by Induction (Induction) Working with Structured Data (Lists) Polymorphism and Higher-Order Functions (Poly) More Basic Tactics (Tactics) Logic in Coq (Logic) Inductively Defined Propositions (IndProp) Total and Partial Maps (Maps) The Curry-Howard Correspondence (ProofObjects) Induction Principles (IndPrinciples) Properties of Relations (Rel) Simple Imperative Programs (Imp) Lexing and Parsing in Coq (ImpParser) An Evaluation Function for Imp (ImpCEvalFun) Extracting OCaml from Coq (Extraction) More Automation (Auto) A Streamlined Treatment of Automation (AltAuto) ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"327a339eeb413b7d569dde88bc6210a0","permalink":"https://kristoff-starling.github.io/notes/booknotes/softwarefoundations/lf/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/booknotes/softwarefoundations/lf/","section":"notes","summary":"Logical Foundations is the entry-point to the series. It covers functional programming, basic concepts of logic, computer-assisted theorem proving, and Coq.","tags":null,"title":"Volume 1: Logical Foundations","type":"docs"},{"authors":null,"categories":null,"content":"è¯¥ç³»åˆ—æ–‡ç« é’ˆå¯¹ OJ ä¸­è¾ƒéš¾çš„ä¹ é¢˜ç»™å‡ºæç¤ºå’Œè§£æ³•ã€‚\né˜…è¯»é¢˜è§£å‰è¯·ç¡®ä¿ä½ å·²ç»ç‹¬ç«‹æ€è€ƒè¿‡è¿™äº›é¢˜ç›®ï¼ ","date":1680134400,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1680134400,"objectID":"8e32b6ef6b418a158fcccefe7f4f29ce","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/solutions/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/problemsolving22/solutions/","section":"courses","summary":" ","tags":null,"title":"OJä¹ é¢˜è®²è§£","type":"docs"},{"authors":null,"categories":null,"content":"ç®—æ³•çš„è®¾è®¡ä¸å®ç°åŒç­‰é‡è¦â€”â€”å‰è€…æ›´å€¾å‘äºåœ¨â€œæ•°å­¦â€å±‚é¢ç»™å‡ºæŠ½è±¡çš„æƒ³æ³•ï¼Œåè€…åˆ™æ˜¯å°†æƒ³æ³•åˆ‡å®åœ°è½¬æ¢æˆä¸€è¡Œè¡Œçš„ä»£ç ã€‚æ‹”å°–ç­è¯¾ç¨‹ä½“ç³»ä¸­æ²¡æœ‰ä¸€é—¨â€œç¨‹åºè®¾è®¡åŸºç¡€â€è¯¾ï¼Œè¯¾ç¨‹è®¾è®¡è€…çš„æƒ³æ³•æ˜¯â€œç¼–ç¨‹è¿™ç§ç®€å•çš„å·¥ç¨‹ä»»åŠ¡ä¸éœ€è¦æ•™â€ã€‚è¿™ä¸ªè¯´æ³•å³æ­£ç¡®åˆæœ‰å¤±åé¢‡ï¼šç®€å•çš„è¯­æ³•è§„åˆ™è‡ªç„¶æ²¡æœ‰èµ˜è¿°çš„å¿…è¦ï¼Œå„ç§æ•™ç¨‹å’Œæ‰‹å†Œå·²ç»ä¸€åº”ä¿±å…¨ï¼›ä½†å¦‚ä½•å†™å‡ºé«˜è´¨é‡çš„ä»£ç ï¼Œåˆç†åœ°è®¾è®¡ç¨‹åºå¸ƒå±€å´æ˜¯ä¸€é—¨å¾ˆå¤§çš„å­¦é—®ã€‚å¾ˆå¤šå¤§å­¦çš„ç¨‹åºè®¾è®¡è¯¾éƒ½åœç•™åœ¨äº†è¯­æ³•ä»‹ç»å±‚é¢è€Œå¿½ç•¥äº†è¿™ç‚¹ã€‚\néœ€è¦æ‰¿è®¤çš„æ˜¯ï¼Œåœ¨ OJ ç¨‹åºè¿™ç§å‡ åå‡ ç™¾è¡Œçš„â€œç©å…·ä»£ç â€ä¸­å¤§è°ˆâ€œé¢å‘å¯¹è±¡ç¼–ç¨‹â€ã€â€œé¢å‘åˆ‡å£ç¼–ç¨‹â€ç­‰å„ç§æ¦‚å¿µå¤šå°‘æœ‰äº›ä¸å¦¥ã€‚ä½†å³ä½¿åœ¨è¿™æ ·å°è§„æ¨¡çš„ç¨‹åºä¸­ä»ç„¶æœ‰å¾ˆå¤šå€¼å¾—æ³¨æ„çš„è®¾è®¡ç»†èŠ‚ã€‚æœ¬ç³»åˆ—æ–‡ç« å°†å°½å¯èƒ½å±•ç¤ºä¸€äº›è¿™æ ·çš„ç»éªŒã€‚äº‹å®ä¸Šï¼Œè¿™äº›å°ç»éªŒåœ¨çœŸæ­£å¤§è§„æ¨¡çš„è½¯ä»¶å·¥ç¨‹ä¸­ä¹Ÿæœ‰ä»¥å°è§å¤§çš„å¯ç¤ºä½œç”¨ã€‚\nSystem is art, not science.\n","date":1679961600,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1679961600,"objectID":"887fecf2f26d3cec0fafdd5ea262999c","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/coding/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/problemsolving22/coding/","section":"courses","summary":" ","tags":null,"title":"Coding","type":"docs"},{"authors":null,"categories":null,"content":"åŸºç¡€ç®—æ³•å…¥é—¨ã€‚\n","date":1679097600,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1679097600,"objectID":"bfdc6436078dbe6e546ca1358a49a856","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/algorithms/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/problemsolving22/algorithms/","section":"courses","summary":" ","tags":null,"title":"ç®—æ³•","type":"docs"},{"authors":null,"categories":null,"content":"è¯¥æ–‡ç« ä¸»è¦ä»‹ç» C/C++ æœ€åŸºç¡€çš„è¯­æ³•çŸ¥è¯†ä»¥åŠæœ€åŸºæœ¬çš„ç¨‹åºæ¶æ„ã€‚æœ¬æ–‡åŠ›æ±‚è®©ç¼–ç¨‹å°ç™½ä¹Ÿèƒ½è¯»æ‡‚å¹¶ä¸Šæ‰‹ï¼Œå› æ­¤ä¼šç•¥å»ä¸€äº›è¾ƒä¸ºå¤æ‚çš„èƒŒæ™¯çŸ¥è¯†å’Œç»†èŠ‚ã€‚\né˜…è¯»æœ¬æ–‡å‰ï¼Œä½ åº”å½“å·²ç»é…ç½®å¥½äº†ä¸€ä¸ªå¯ä»¥ä¹¦å†™ä»£ç å¹¶ç¼–è¯‘ã€è¿è¡Œä»£ç çš„ç¯å¢ƒã€‚ ","date":1667260800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1667260800,"objectID":"a8b310516b5df76edb8f6564bfd2c70e","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/c++0/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/problemsolving22/c++0/","section":"courses","summary":"è¯¥æ–‡ç« ä¸»è¦ä»‹ç» C/C++ æœ€åŸºç¡€çš„è¯­æ³•çŸ¥è¯†ä»¥åŠæœ€åŸºæœ¬çš„ç¨‹åºæ¶æ„ã€‚æœ¬æ–‡åŠ›æ±‚è®©ç¼–ç¨‹å°ç™½ä¹Ÿèƒ½è¯»æ‡‚å¹¶ä¸Šæ‰‹ï¼Œå› æ­¤ä¼šç•¥å»ä¸€äº›è¾ƒä¸ºå¤æ‚çš„èƒŒæ™¯çŸ¥è¯†å’Œç»†èŠ‚ã€‚","tags":null,"title":"C/C++åŸºç¡€å…¥é—¨","type":"docs"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"817588e3803ca2164a1c836caccc6f18","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/cser0/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/problemsolving22/cser0/","section":"courses","summary":"no summary","tags":null,"title":"ä¸€ä¸ªCSeråº”å½“æŒæ¡çš„åŸºç¡€æŠ€èƒ½åˆé›†","type":"docs"},{"authors":[],"categories":null,"content":" Click on the Slides button above to view the built-in slides feature. Slides can be added in a few ways:\nCreate slides using Academic\u0026rsquo;s Slides feature and link using slides parameter in the front matter of the talk file Upload an existing slide deck to static/ and link using url_slides parameter in the front matter of the talk file Embed your slides (e.g. Google Slides) or presentation video on this page using shortcodes. Further talk details can easily be added to this page using Markdown and $\\rm \\LaTeX$ math code.\n","date":1906549200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1906549200,"objectID":"96344c08df50a1b693cc40432115cbe3","permalink":"https://kristoff-starling.github.io/talk/example/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/talk/example/","section":"talk","summary":"An example talk using Academic's Markdown slides feature.","tags":[],"title":"Example Talk","type":"talk"},{"authors":null,"categories":null,"content":" é¢˜æ„æ¦‚è¿°\nç»™å®šä¸€ä¸ª $n\\times m$ çš„æ£‹ç›˜å’Œè±¡æ£‹æ£‹å­é©¬çš„åˆå§‹ä½ç½®ï¼Œé—®ç»è¿‡ $k$ æ­¥åˆ°è¾¾æ£‹ç›˜ä¸Šä»»æ„ç‚¹çš„æ–¹æ¡ˆæ•°ã€‚\n$n,m\\leq 15, k\\leq 10^5$ã€‚\né‚»æ¥çŸ©é˜µæ˜¯æè¿°å›¾çš„ä¸€ç§å¸¸è§æ–¹æ³•ï¼š$\\text{ga}(i,j)=1$ å½“ä¸”ä»…å½“å›¾ä¸­ç‚¹ $i,j$ ä¹‹é—´æœ‰è¾¹ã€‚å®ƒä¹‹æ‰€ä»¥è¢«ç§°ä¸ºâ€œçŸ©é˜µâ€ï¼Œæ˜¯å› ä¸ºçŸ©é˜µçš„ä¹˜æ³•æ°å¥½å¯ä»¥ç”¨äºæè¿°å›¾ä¸Šçš„æ¸¸èµ°ã€‚\nä»¤ $A_k$ ä¸ºä¸€ä¸ª $n$ é˜¶çŸ©é˜µï¼Œå…¶ä¸­ $A_k(i,j)$ è¡¨ç¤ºä»ç‚¹ $i$ èµ° $k$ æ­¥åˆ°ç‚¹ $j$ çš„æ–¹æ¡ˆæ•°ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å‘ç° $A_0=I,A_1=\\text{ga}$ã€‚æ›´ä¸€èˆ¬åœ°ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°\n$$ \\forall p, q. A_{p+q}=A_p\\cdot A_q $$\nProof: è€ƒè™‘ä»»æ„ç‚¹å¯¹ $i,j$ï¼Œä» $i$ èµ° $p+q$ æ­¥åˆ° $j$ å¯ä»¥è¢«åˆ†è§£æˆä¸¤ä¸ªé˜¶æ®µï¼š\nä» $i$ èµ° $p$ æ­¥åˆ°æŸä¸€ä¸ªèŠ‚ç‚¹ $k$ã€‚ ä» $k$ èµ° $q$ æ­¥åˆ° $j$ã€‚ å› æ­¤æˆ‘ä»¬å¯ä»¥æšä¸¾è¿™ä¸ªä¸­é—´èŠ‚ç‚¹ $k$ï¼Œå†æ ¹æ®åŠ æ³•/ä¹˜æ³•åŸç†æœ‰å¦‚ä¸‹é€’æ¨å¼ï¼š $$ A_{p+q}(i,j)=\\sum_{k=1}^n A_p(i,k)\\cdot A_q(k,j) $$\nå®¹æ˜“å‘ç°è¿™æ°å¥½æ˜¯çŸ©é˜µä¹˜æ³•çš„è®¡ç®—å…¬å¼ï¼Œä»è€ŒåŸå‘½é¢˜å¾—è¯ã€‚$\\square$\nå› æ­¤ï¼Œ$A_k=\\text{ga}^k$ã€‚è‡³äºå¦‚ä½•å°†åŸé—®é¢˜è½¬åŒ–ä¸ºä¸€ä¸ªå›¾ä¸Šçš„æ¸¸èµ°é—®é¢˜ï¼Œæƒ³å¿…ä½ èƒ½å¤Ÿè‡ªå·±è§£å†³ã€‚\n","date":1680134400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1680134400,"objectID":"a13e8da39233c7e39f2077c59ec17861","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/solutions/2-1-c/","publishdate":"2023-03-30T00:00:00Z","relpermalink":"/courses/problemsolving22/solutions/2-1-c/","section":"courses","summary":"é¢˜æ„æ¦‚è¿°\nç»™å®šä¸€ä¸ª $n\\times m$ çš„æ£‹ç›˜å’Œè±¡æ£‹æ£‹å­é©¬çš„åˆå§‹ä½ç½®ï¼Œé—®ç»è¿‡ $k$ æ­¥åˆ°è¾¾æ£‹ç›˜ä¸Šä»»æ„ç‚¹çš„æ–¹æ¡ˆæ•°ã€‚\n$n,m\\leq 15, k\\leq 10^5$ã€‚\né‚»æ¥çŸ©é˜µæ˜¯æè¿°å›¾çš„ä¸€ç§å¸¸è§æ–¹æ³•ï¼š$\\text{ga}(i,j)=1$ å½“ä¸”ä»…å½“å›¾ä¸­ç‚¹ $i,j$ ä¹‹é—´æœ‰è¾¹ã€‚å®ƒä¹‹æ‰€ä»¥è¢«ç§°ä¸ºâ€œçŸ©é˜µâ€ï¼Œæ˜¯å› ä¸ºçŸ©é˜µçš„ä¹˜æ³•æ°å¥½å¯ä»¥ç”¨äºæè¿°å›¾ä¸Šçš„æ¸¸èµ°ã€‚\nä»¤ $A_k$ ä¸ºä¸€ä¸ª $n$ é˜¶çŸ©é˜µï¼Œå…¶ä¸­ $A_k(i,j)$ è¡¨ç¤ºä»ç‚¹ $i$ èµ° $k$ æ­¥åˆ°ç‚¹ $j$ çš„æ–¹æ¡ˆæ•°ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å‘ç° $A_0=I,A_1=\\text{ga}$ã€‚æ›´ä¸€èˆ¬åœ°ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°","tags":null,"title":"ã€é—®é¢˜æ±‚è§£II-HW1.Cã€‘æ–°é©¬èµ°æ—¥","type":"docs"},{"authors":null,"categories":null,"content":"å¦‚ä½•è®ºè¯ä½ å†™çš„ç¨‹åºæ˜¯æ­£ç¡®çš„ï¼Ÿè¿™æ˜¯ä¸€ä¸ªå†å²æ‚ ä¹…ä¸”éš¾ä»¥å›ç­”çš„é—®é¢˜ã€‚é€šå¸¸æ¥è¯´æœ‰ä¸¤ç§æ€è·¯ï¼š\nVerification: å½¢å¼åŒ–éªŒè¯ç®€å•æ¥è¯´æ˜¯é€šè¿‡æ•°å­¦æ‰‹æ®µè¯æ˜ä½ çš„ç¨‹åºçš„è¡Œä¸ºç¬¦åˆé¢„æœŸã€‚è¿™æ˜¯å¯¹ç¨‹åºæ­£ç¡®æ€§çš„å¼ºè€Œæœ‰åŠ›çš„è¯æ˜ï¼Œä½†é€šå¸¸éå¸¸å›°éš¾ã€å±€é™æ€§å¾ˆå¤§ã€scalability è¾ƒå·®ï¼Œå› æ­¤æ›´å¤šç”¨äºå¯¹äºå®‰å…¨/å¯é æ€§è¦æ±‚éå¸¸ä¸¥è‹›çš„åœºæ™¯ï¼Œå¦‚è‡ªåŠ¨é©¾é©¶ï¼Œç«æ˜Ÿè½¦ç­‰ã€‚é—®é¢˜æ±‚è§£ä¸€ä¸­æåˆ°çš„â€œé€šè¿‡ loop invariant è¯æ˜å¾ªç¯æ­£ç¡®æ€§â€å¯ä»¥è®¤ä¸ºæ˜¯ verification çš„ä¸€ç§éå¸¸ç®€å•çš„å½¢å¼ã€‚ç”±äº verificaton éœ€è¦å¤§é‡çš„ç¨‹åºè¯­è¨€(PL)/å½¢å¼åŒ–æ–¹æ³•(FM)çš„èƒŒæ™¯çŸ¥è¯†ï¼Œä¸”å¯¹äºç®€å•ç®—æ³•é—®é¢˜æ¥è¯´é¢‡æœ‰å¤§æå°ç”¨ä¹‹å«Œï¼Œæ•…åœ¨è¿™é‡Œä¸ä½œèµ˜è¿°ã€‚ Testing: æµ‹è¯•æ˜¯æ›´åŠ å¸¸ç”¨çš„æ£€æŸ¥ç¨‹åºæ˜¯å¦æœ‰æ¼æ´çš„æ–¹æ³•ï¼Œå…¶æ ¸å¿ƒæ€æƒ³æ˜¯æ„é€ å¤§é‡çš„è¾“å…¥å¹¶æ£€æŸ¥ç›®æ ‡ç¨‹åºåœ¨è¿™äº›è¾“å…¥ä¸Šçš„è¾“å‡ºæ˜¯å¦ç¬¦åˆé¢„æœŸã€‚æµ‹è¯•æœ‰ç€å¤©ç„¶çš„å±€é™æ€§ï¼šå®ƒåªèƒ½è¯æ˜ä½ çš„ç¨‹åºæœ‰ bugï¼Œä½†æ— æ³•è¯æ˜ä½ çš„ç¨‹åºæ²¡æœ‰ bug (OJ çš„æœ¬è´¨ä¹Ÿæ˜¯æµ‹è¯•ï¼Œå› æ­¤åœ¨ OJ ä¸Šé€šè¿‡çš„ç¨‹åºå¹¶ä¸ä¸€å®šæ˜¯å¯¹çš„ è€Œä¸”ç”±äºåŠ©æ•™å¤ªæ‡’æ•°æ®å¤ªæ°´å¾ˆå¯èƒ½ç¡®å®æ˜¯é”™çš„)ã€‚ä¸è¿‡æˆ‘ä»¬æ€»å¯ä»¥è®¤ä¸ºï¼Œå¦‚æœæˆ‘ä»¬æ„é€ çš„è¾“å…¥è¶³å¤Ÿå¤šä¸”è¶³å¤Ÿä¸°å¯Œï¼Œé‚£ä¹ˆé€šè¿‡äº†æ‰€æœ‰æµ‹è¯•çš„ç¨‹åºçš„å¯é æ€§ç›¸å¯¹ä¼šå¾ˆé«˜ã€‚ è¿™é‡Œæˆ‘ä»¬ä»‹ç»ä¸€ç§ç®€å•æ˜“è¡Œçš„æµ‹è¯•æŠ€æœ¯ï¼šdifferential testing (å¦‚æœä½ æ›¾ç»å‚åŠ è¿‡ç®—æ³•ç«èµ›ï¼Œâ€œå¯¹æ‹â€çš„æœ¬è´¨å°±æ˜¯ DiffTest)ã€‚DiffTest çš„æ ¸å¿ƒæ€æƒ³æ˜¯é’ˆå¯¹åŒä¸€ä¸ªé—®é¢˜å®Œæˆä¸¤ä»½ä¸åŒçš„å®ç°ï¼Œç„¶åæ„é€ å¤§é‡çš„è¾“å…¥å–‚ç»™ä¸¤ä»½å®ç°è§‚å¯Ÿå®ƒä»¬çš„è¾“å‡ºæ˜¯å¦ç›¸åŒ (å°±åƒä½ æ¯å¤©æ—©æ™¨å’ŒåŒæ¡Œå¯¹ä½œä¸šç­”æ¡ˆï¼Œè™½ç„¶ä½ ä»¬éƒ½ä¸èƒ½ä¿è¯è‡ªå·±åšçš„æ˜¯å¯¹çš„ï¼Œä½†åšé”™ä¸”é”™å¾—ä¸€æ ·çš„æ¦‚ç‡æ¯•ç«Ÿå¾ˆå°ï¼Œå¦‚æœä½ ä»¬çš„è§£é¢˜æ€è·¯ä¸ä¸€æ ·å°±æ›´å°äº†)ã€‚ä¸ºäº†é¿å…è¿‡äºç©ºæ´ï¼Œæˆ‘ä»¬ä»¥â€œè®¡ç®—Fibonacciç¬¬né¡¹â€è¿™ä¸ªé—®é¢˜ä¸ºä¾‹è¯´æ˜å¦‚ä½•åœ¨ OJ ç®—æ³•é¢˜ä¸Šè¿›è¡Œ DiffTestã€‚\nå‡è®¾ä½ å·²ç»å†™å¥½äº†ä¸€ä¸ªä½¿ç”¨çŸ©é˜µå¿«é€Ÿå¹‚ä¼˜åŒ– Fibonacci è®¡ç®—çš„ç¨‹åº fib.cppï¼Œç°åœ¨å¸Œæœ›å¯¹å…¶è¿›è¡Œæµ‹è¯•ã€‚æˆ‘ä»¬å¾ˆå®¹æ˜“å†™ä¸€ä¸ªæœ´ç´ ç‰ˆçš„ fib_bruteforce.cpp æ¥å®ç°åŒæ ·çš„åŠŸèƒ½ (è™½ç„¶å®ƒèƒ½å¤„ç†çš„ $n$ è§„æ¨¡è¾ƒå°)ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MOD = 998244353; int main () { int n, f0 = 0, f1 = 1, f2; cin \u0026gt;\u0026gt; n; for (int i = 2; i \u0026lt;= n; i++) { f2 = (f0 + f1) % MOD; f0 = f1; f1 = f2; } printf(\u0026quot;%d\\n\u0026quot;, f2); return 0; } æ ¹æ®æˆ‘ä»¬çš„é¢„æœŸï¼Œå¯¹äºä»»æ„ $n$ï¼Œå¦‚æœ fib.cpp å’Œ fib_bruteforce.cpp éƒ½ç»™å‡ºäº†ç­”æ¡ˆï¼Œé‚£ä¹ˆç­”æ¡ˆåº”è¯¥æ˜¯ç›¸åŒçš„ã€‚è¿™ä¸ªé—®é¢˜çš„å¥½å¤„åœ¨äºæµ‹è¯•æ•°æ®å½¢å¼éå¸¸ç®€å•ï¼šåªæœ‰ä¸€ä¸ªæ•°ã€‚å› æ­¤æˆ‘ä»¬å¾ˆå®¹æ˜“å†™å‡ºä¸€ä¸ªæ•°æ®ç”Ÿæˆç¨‹åº gen_data.cpp (æ³¨æ„æˆ‘ä»¬çš„æœ´ç´ ç‰ˆæœ¬æ— æ³•å¤„ç†è¿‡å¤§çš„ $n$)ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main () { int limit = 10000000; mt19937 mt(time(nullptr)); cout \u0026lt;\u0026lt; mt() % limit + 1 \u0026lt;\u0026lt; endl; return 0; } mt19937 class æ˜¯ä¸€ä¸ªéå¸¸é«˜æ•ˆçš„ä¼ªéšæœºæ•°ç”Ÿæˆå™¨ã€‚ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ rand() ç­‰å…¶ä»–å‡½æ•°æ¥ç”Ÿæˆéšæœºæ•° (æ³¨æ„è®¾ç½®éšæœºç§å­ï¼Œå¦åˆ™å¯èƒ½æ¯æ¬¡ç”Ÿæˆçš„éšæœºæ•°éƒ½ä¸€æ ·)ã€‚\næœ‰äº†ä¸¤ä»½å®ç°å’Œä¸€ä¸ªæ•°æ®ç”Ÿæˆå™¨ï¼Œæ¥ä¸‹æ¥çš„ä»»åŠ¡å°±æ˜¯å†™ä¸€ä¸ªè„šæœ¬æ¥åšå¦‚ä¸‹å¾ªç¯ï¼š\nwhile True { DataGenerator \u0026gt;\u0026gt; data data \u0026gt;\u0026gt; Program1 \u0026gt;\u0026gt; output1 data \u0026gt;\u0026gt; Program2 \u0026gt;\u0026gt; output2 compare output1 and output2 } å¦‚æœä½ ä¼šåœ¨ Windows ä¸‹å†™ Batch/Powershell è„šæœ¬ï¼Œä½ åº”è¯¥å¯ä»¥ç»™å‡ºä¸€ä¸ªä¸Šè¿°ä¼ªä»£ç çš„è½»å·§å®ç°ï¼›å¦‚æœä½ ä½¿ç”¨ç±» Unix ç³»ç»Ÿï¼Œä½ å¤§æ¦‚ç‡ä¹Ÿå¯ä»¥ç»™å‡ºä¸€ä¸ª bash è„šæœ¬ã€‚å¦‚æœä½ å•¥ä¹Ÿä¸ä¼šï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨ä¸‹é¢ç»™å‡ºçš„è¿™ä»½ Python ç¨‹åºè¿›è¡Œæµ‹è¯•ã€‚\nä¸€ä»½ Difftest Python å®ç° [Click to expand] \u0026quot;\u0026quot;\u0026quot; usage: difftest.py [-h] --impl IMPL IMPL --gen GEN [--num NUM] [--time TIME] optional arguments: -h, --help show this help message and exit --impl IMPL IMPL two source code files --gen GEN data generator, cpp or python --num NUM number of tests --time TIME time limit for each test, in seconds \u0026quot;\u0026quot;\u0026quot; import os, subprocess import atexit objs = [] def compile(*progs): for prog in progs: assert os.path.exists(prog), f\u0026quot;{prog} not exist\u0026quot; if prog.endswith(\u0026quot;.cpp\u0026quot;): obj = f\u0026quot;obj-{prog}\u0026quot; objs.append(obj) p = subprocess.run(f\u0026quot;g++ -o {obj} {prog} -O2\u0026quot;, shell=True) assert p.returncode == 0, f\u0026quot;{prog} failed to be compiled, make sure that g++ is in your enviroment path\u0026quot; def destructor(): for obj in objs: if os.path.exists(obj): os.remove(obj) def run(prog: str, tl: float, data: str): cmd = f\u0026quot;./obj-{prog}\u0026quot; if prog.endswith(\u0026quot;.cpp\u0026quot;) else f\u0026quot;python3 {prog}\u0026quot; p = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE) try: stdout, _ = p.communicate(input=data.encode(), timeout=tl) except subprocess.TimeoutExpired: p.kill() raise Exception(f\u0026quot;{prog} exceed {tl}s time limit\u0026quot;) return stdout.decode() def dump(data, o1, o2): with open(\u0026quot;input\u0026quot;, \u0026quot;w\u0026quot;) as f: f.write(data) with open(\u0026quot;output1\u0026quot;, \u0026quot;w\u0026quot;) as f: f.write(o1) with open(\u0026quot;output2\u0026quot;, \u0026quot;w\u0026quot;) as f: f.write(o2) def cmp(data, o1, o2): t1, t2 = o1.strip().split(\u0026quot;\\n\u0026quot;), o2.strip().split(\u0026quot;\\n\u0026quot;) if len(t1) != len(t2): dump(data, o1, o2) return False for line1, line2 in zip(t1, t2): if line1.strip() != line2.strip(): dump(data, o1, o2) return False return True if __name__ == \u0026quot;__main__\u0026quot;: import argparse parser = argparse.ArgumentParser() parser.add_argument(\u0026quot;--impl\u0026quot;, nargs=2, required=True, help=\u0026quot;two source code files\u0026quot;) parser.add_argument(\u0026quot;--gen\u0026quot;, type=str, required=True, help=\u0026quot;data generator, cpp or python\u0026quot;) parser.add_argument(\u0026quot;--num\u0026quot;, type=int, default=100, help=\u0026quot;number of tests\u0026quot;) parser.add_argument(\u0026quot;--time\u0026quot;, type=float, default=5.0, help=\u0026quot;time limit for each test, in seconds\u0026quot;) args = parser.parse_args() atexit.register(destructor) compile(args.impl[0], args.impl[1], args.gen) for i in range(args.num): data = run(args.gen, args.time, \u0026quot;\u0026quot;) res1 = run(args.impl[0], args.time, data) res2 = run(args.impl[1], args.time, data) assert cmp(data, res1, res2), \u0026quot;Wrong answer, input/output files dumped\u0026quot; print(f\u0026quot;Test {i+1} OK!\u0026quot;) DiffTest æ˜¾ç„¶æ¯”è‡ªå·±å‡ºæ•°æ®ï¼Œè¿è¡Œç¨‹åºï¼Œå†æ‰‹åŠ¨éªŒè¯ç»“æœè¦é«˜æ•ˆå¾—å¤šã€‚ç”¨æ­£ç¡®çš„å·¥å…·å’Œæ–¹æ³•åšäº‹èƒ½è®©ä½ äº‹åŠåŠŸå€ã€‚\n","date":1679961600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1679961600,"objectID":"168ea62655884b644312eeb673a8cf22","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/coding/difftest/","publishdate":"2023-03-28T00:00:00Z","relpermalink":"/courses/problemsolving22/coding/difftest/","section":"courses","summary":"å¦‚ä½•è®ºè¯ä½ å†™çš„ç¨‹åºæ˜¯æ­£ç¡®çš„ï¼Ÿè¿™æ˜¯ä¸€ä¸ªå†å²æ‚ ä¹…ä¸”éš¾ä»¥å›ç­”çš„é—®é¢˜ã€‚é€šå¸¸æ¥è¯´æœ‰ä¸¤ç§æ€è·¯ï¼š\nVerification: å½¢å¼åŒ–éªŒè¯ç®€å•æ¥è¯´æ˜¯é€šè¿‡æ•°å­¦æ‰‹æ®µè¯æ˜ä½ çš„ç¨‹åºçš„è¡Œä¸ºç¬¦åˆé¢„æœŸã€‚è¿™æ˜¯å¯¹ç¨‹åºæ­£ç¡®æ€§çš„å¼ºè€Œæœ‰åŠ›çš„è¯æ˜ï¼Œä½†é€šå¸¸éå¸¸å›°éš¾ã€å±€é™æ€§å¾ˆå¤§ã€scalability è¾ƒå·®ï¼Œå› æ­¤æ›´å¤šç”¨äºå¯¹äºå®‰å…¨/å¯é æ€§è¦æ±‚éå¸¸ä¸¥è‹›çš„åœºæ™¯ï¼Œå¦‚è‡ªåŠ¨é©¾é©¶ï¼Œç«æ˜Ÿè½¦ç­‰ã€‚é—®é¢˜æ±‚è§£ä¸€ä¸­æåˆ°çš„â€œé€šè¿‡ loop invariant è¯æ˜å¾ªç¯æ­£ç¡®æ€§â€å¯ä»¥è®¤ä¸ºæ˜¯ verification çš„ä¸€ç§éå¸¸ç®€å•çš„å½¢å¼ã€‚ç”±äº verificaton éœ€è¦å¤§é‡çš„ç¨‹åºè¯­è¨€(PL)/å½¢å¼åŒ–æ–¹æ³•(FM)çš„èƒŒæ™¯çŸ¥è¯†ï¼Œä¸”å¯¹äºç®€å•ç®—æ³•é—®é¢˜æ¥è¯´é¢‡æœ‰å¤§æå°ç”¨ä¹‹å«Œï¼Œæ•…åœ¨è¿™é‡Œä¸ä½œèµ˜è¿°ã€‚ Testing: æµ‹è¯•æ˜¯æ›´åŠ å¸¸ç”¨çš„æ£€æŸ¥ç¨‹åºæ˜¯å¦æœ‰æ¼æ´çš„æ–¹æ³•ï¼Œå…¶æ ¸å¿ƒæ€æƒ³æ˜¯æ„é€ å¤§é‡çš„è¾“å…¥å¹¶æ£€æŸ¥ç›®æ ‡ç¨‹åºåœ¨è¿™äº›è¾“å…¥ä¸Šçš„è¾“å‡ºæ˜¯å¦ç¬¦åˆé¢„æœŸã€‚æµ‹è¯•æœ‰ç€å¤©ç„¶çš„å±€é™æ€§ï¼šå®ƒåªèƒ½è¯æ˜ä½ çš„ç¨‹åºæœ‰ bugï¼Œä½†æ— æ³•è¯æ˜ä½ çš„ç¨‹åºæ²¡æœ‰ bug (OJ çš„æœ¬è´¨ä¹Ÿæ˜¯æµ‹è¯•ï¼Œå› æ­¤åœ¨ OJ ä¸Šé€šè¿‡çš„ç¨‹åºå¹¶ä¸ä¸€å®šæ˜¯å¯¹çš„ è€Œä¸”ç”±äºåŠ©æ•™å¤ªæ‡’æ•°æ®å¤ªæ°´å¾ˆå¯èƒ½ç¡®å®æ˜¯é”™çš„)ã€‚ä¸è¿‡æˆ‘ä»¬æ€»å¯ä»¥è®¤ä¸ºï¼Œå¦‚æœæˆ‘ä»¬æ„é€ çš„è¾“å…¥è¶³å¤Ÿå¤šä¸”è¶³å¤Ÿä¸°å¯Œï¼Œé‚£ä¹ˆé€šè¿‡äº†æ‰€æœ‰æµ‹è¯•çš„ç¨‹åºçš„å¯é æ€§ç›¸å¯¹ä¼šå¾ˆé«˜ã€‚ è¿™é‡Œæˆ‘ä»¬ä»‹ç»ä¸€ç§ç®€å•æ˜“è¡Œçš„æµ‹è¯•æŠ€æœ¯ï¼šdifferential testing (å¦‚æœä½ æ›¾ç»å‚åŠ è¿‡ç®—æ³•ç«èµ›ï¼Œâ€œå¯¹æ‹â€çš„æœ¬è´¨å°±æ˜¯ DiffTest)ã€‚DiffTest çš„æ ¸å¿ƒæ€æƒ³æ˜¯é’ˆå¯¹åŒä¸€ä¸ªé—®é¢˜å®Œæˆä¸¤ä»½ä¸åŒçš„å®ç°ï¼Œç„¶åæ„é€ å¤§é‡çš„è¾“å…¥å–‚ç»™ä¸¤ä»½å®ç°è§‚å¯Ÿå®ƒä»¬çš„è¾“å‡ºæ˜¯å¦ç›¸åŒ (å°±åƒä½ æ¯å¤©æ—©æ™¨å’ŒåŒæ¡Œå¯¹ä½œä¸šç­”æ¡ˆï¼Œè™½ç„¶ä½ ä»¬éƒ½ä¸èƒ½ä¿è¯è‡ªå·±åšçš„æ˜¯å¯¹çš„ï¼Œä½†åšé”™ä¸”é”™å¾—ä¸€æ ·çš„æ¦‚ç‡æ¯•ç«Ÿå¾ˆå°ï¼Œå¦‚æœä½ ä»¬çš„è§£é¢˜æ€è·¯ä¸ä¸€æ ·å°±æ›´å°äº†)ã€‚ä¸ºäº†é¿å…è¿‡äºç©ºæ´ï¼Œæˆ‘ä»¬ä»¥â€œè®¡ç®—Fibonacciç¬¬né¡¹â€è¿™ä¸ªé—®é¢˜ä¸ºä¾‹è¯´æ˜å¦‚ä½•åœ¨ OJ ç®—æ³•é¢˜ä¸Šè¿›è¡Œ DiffTestã€‚\nå‡è®¾ä½ å·²ç»å†™å¥½äº†ä¸€ä¸ªä½¿ç”¨çŸ©é˜µå¿«é€Ÿå¹‚ä¼˜åŒ– Fibonacci è®¡ç®—çš„ç¨‹åº fib.","tags":null,"title":"Differential Testing","type":"docs"},{"authors":null,"categories":null,"content":"ä¸å°‘åŒå­¦è¢«OJçš„å–æ¨¡é—®é¢˜æŠ˜ç£¨å¾—å¿ƒåŠ›æ†”æ‚´â€”â€”ä¸è®ºå¤šä¹ˆä»”ç»†åœ°æ£€æŸ¥æ¯ä¸€å¤„å››åˆ™è¿ç®—ï¼Œæ€»ä¼šæœ‰ä¸€å¤„æ¼ç½‘ä¹‹é±¼è®©ç¨‹åºè¾“å‡ºé”™è¯¯çš„ç»“æœã€‚è¿™é‡Œæˆ‘ä»¬å±•ç¤ºä¸€ç§æ¯”è¾ƒä¼˜é›…çš„ä»£ç ä¹¦å†™æ–¹å¼ï¼š\nconst int MOD = 998244353; int add(int x, int y) { x += y; if (x \u0026gt;= MOD) x -= MOD; return x;} int sub(int x, int y) { x -= y; if (x \u0026lt; 0) x += MOD; return x; } int mul(int x, int y) { return 1ll * x * y % MOD; } void Add(int \u0026amp;x, int y) { x = add(x, y); } void Sub(int \u0026amp;x, int y) { x = sub(x, y); } void Mul(int \u0026amp;x, int y) { x = mul(x, y); } è¿™é‡Œæˆ‘ä»¬å®šä¹‰äº† MOD è¿™ä¸ªå˜é‡ä»¥åŠ 6 ä¸ªå‡½æ•°ç»Ÿä¸€å®ŒæˆåŠ æ³•ã€å‡æ³•å’Œä¹˜æ³•çš„å–æ¨¡æ“ä½œã€‚è¿™æ ·åç»­ç¨‹åºä¸­çš„ä»»ä½•è¿ç®—éƒ½å¯ä»¥è°ƒç”¨è¿™å‡ ä¸ªå‡½æ•°æ¥å®ç°ï¼š\nc = sub(a, b); // instead of c = (a - b) % MOD; Add(c, d); // instead of c += d %= MOD; Mul(a_very_very_long_variable_name, c); // instead of a_very_very_long_variable_name = 1ll * a_very_very_long_variable_name * c % MOD; ä½¿ç”¨ç»Ÿä¸€çš„å–æ¨¡å‡½æ•°å’Œ MOD å˜é‡æœ‰åŒ…æ‹¬ä½†ä¸é™äºä»¥ä¸‹å¥½å¤„ï¼š\næ­£ç¡®æ€§: ä½ åªéœ€è¦ä»”ç»†åœ°ä¹¦å†™è¿™å‡ ä¸ªå–æ¨¡å‡½æ•°ï¼Œåé¢çš„ç¨‹åºä¸­ä½ åªè¦ä¿è¯ä¸å‡ºç° + - *ï¼Œå°±ä¸ä¼šå‘ç”Ÿâ€œæ¼äº†å–æ¨¡â€çš„æ‚²å‰§ã€‚ ç®€æ´æ€§: åœ¨ä¸Šè¿°çš„çš„ç¬¬ä¸‰ä¸ªä¾‹å­ä¸­å¯ä»¥çœ‹å‡ºä½¿ç”¨å–æ¨¡å‡½æ•°å¯ä»¥é¿å…é‡å¤ä¹¦å†™é•¿å˜é‡åï¼Œä½¿ä»£ç æ›´åŠ ç®€æ´ã€‚ å¯ç»´æŠ¤æ€§: å‡è®¾æŸä¸€å¤©æˆ‘ä»¬é€šçŸ¥éœ€è¦å°†æ¨¡æ•°ç´§æ€¥æ¢æˆ 1000000007ï¼Œç›¸æ¯”è¾ƒå°†ç¨‹åºä¸­æ•£è½åœ¨å„å¤„çš„ 998244353 ä¿®æ”¹æ‰ï¼Œå¦‚æœä½ å®šä¹‰äº† MOD å˜é‡ï¼Œä½ åªéœ€è¦ä¿®æ”¹ä¸€å¤„ã€‚ æ€§èƒ½: ä½ ä¹Ÿè®¸æ³¨æ„åˆ°äº†æˆ‘ä»¬åœ¨åŠ æ³•å’Œå‡æ³•ä¸­ä½¿ç”¨äº† â€œif åˆ¤æ–­ + åŠ å‡â€çš„æ–¹å¼ä»£æ›¿äº†å–æ¨¡ï¼Œä½ å¯ä»¥è¯æ˜åªè¦ä¼ å…¥çš„å‚æ•°åœ¨ [0, MOD) èŒƒå›´å†…ï¼Œè¯¥å†™æ³•çš„æ­£ç¡®æ€§çš„å¯ä»¥ä¿è¯çš„ã€‚åœ¨è®¡ç®—æœºåº•å±‚å®ç°ä¸­ï¼Œè¿›è¡Œä¸€æ¬¡å–æ¨¡æ“ä½œçš„ä»£ä»·æ˜¾è‘—é«˜äºç®€å•åˆ¤æ–­å’ŒåŠ å‡ï¼Œè¿™æ ·çš„å†™æ³•æœ‰åŠ©äºæå‡æ•ˆç‡ (æœ‰æ—¶å€™è¿™ç§æå‡æ˜¯æƒŠäººçš„ï¼)ã€‚ æˆ‘ä»¬æ‰¿è®¤å–æ¨¡è¿™ä»¶äº‹æƒ…åœ¨å·¥ç¨‹å¼€å‘ä¸­å¯èƒ½å¹¶ä¸å¸¸è§ï¼Œä½†è¿™æ ·çš„ç¨‹åºè®¾è®¡å´ä½“ç°äº†è½¯ä»¶å·¥ç¨‹çš„é€šç”¨æ€æƒ³ï¼š\nå°†éœ€è¦é¢‘ç¹ä½¿ç”¨çš„å¸¸é‡å®šä¹‰æˆå®/constexprã€‚ å°†å®¹æ˜“å‡ºé”™çš„åŠŸèƒ½å•ç‹¬å°è£…æˆå‡½æ•°ï¼Œä¹‹åè°ƒç”¨æ¥å£è§£å†³é—®é¢˜ã€‚ ç¨‹åºè®¾è®¡ä¼˜åŒ–æ˜¯ä¸€ä»¶â€œç»çŸ¥æ­¤äº‹è¦èº¬è¡Œâ€çš„äº‹æƒ…ã€‚é˜…è¯»ä¸€éè¿™ç¯‡æ–‡ç« å¤§æŠµä¸ä¼šå¯¹ä½ çš„æ€æƒ³äº§ç”Ÿé‡å¤§çš„å½±å“ï¼šä½ ä¹Ÿè®¸ä¼šè®¤ä¸ºè¿™äº›æ˜¯å¤šæ­¤ä¸€ä¸¾ï¼Œæˆ–è€…ä½ å¯¹è‡ªå·±å†™ä»£ç æ—¶çš„ä»”ç»†ç¨‹åº¦éå¸¸è‡ªä¿¡ã€‚ä½ åªæœ‰ç»å†äº†ç°å®çš„æ¶æ‰“ï¼Œç»å†äº†ç†¬å¤œé€šå®µçš„æŠ˜ç£¨ï¼Œæ‰ä¼šæ·±åˆ»åœ°æ„è¯†åˆ°äººç±»æ°¸è¿œæ— æ³•å…‹æœåŸºå› å†³å®šçš„å…±åŒå¼±ç‚¹ï¼Œæ‰ä¼šç†è§£è¿™äº›æ–‡å­—èƒŒåæ˜¯å‰äººçš„æ™ºæ…§å’Œè¡€çš„æ•™è®­ã€‚\nç¬”è€…åœ¨é«˜ä¸­æ—¶æ›¾å‚åŠ ä¸€é¡¹æå…¶é‡è¦çš„ç¼–ç¨‹æ¯”èµ›ã€‚ä»–é’ˆå¯¹ä¸€é“éš¾é¢˜æ¨å¯¼å‡ºäº†ä¸€ä¸ªæå…¶å¤æ‚çš„æ•°å­¦å…¬å¼å¹¶ç¼–ç å®ç°äº†å®ƒï¼Œä½†åœ¨æ¯”èµ›ç»“æŸå‰çš„ 5 åˆ†é’Ÿä»–å‘ç°è‡ªå·±çš„ç¨‹åºå¤„å¤„æ¼äº†å–æ¨¡â€”â€”ä»–æ°¸è¿œä¸ä¼šå¿˜è®°åœ¨æ‰‹æŒ‡è¢«æ±—æ°´æµ¸æ¹¿ä»¥è‡³äºé”®ç›˜æ‰“æ»‘çš„æƒ…å†µä¸‹ç‹‚æŒ‰ ctrl+F, ctrl+C, ctrl+V æ˜¯æ€æ ·çš„ç´§å¼ å’Œç»æœ›ï¼Œä¹Ÿä¸ä¼šå¿˜è®°æœ€ç»ˆä¹Ÿæ²¡æœ‰æŠŠå–æ¨¡é—®é¢˜è§£å†³å®Œï¼Œå› ä¸ºè¿™æ ·ä¸€ä¸ªå°ç»†èŠ‚ä¸è‡ªå·±æƒ³è¦çš„ç»“æœå¤±ä¹‹äº¤è‡‚çš„ç—›è‹¦ã€‚ä»é‚£ä¹‹åï¼Œä»–å†ä¹Ÿæ²¡æœ‰çŠ¯è¿‡ä½çº§çš„æ¼å–æ¨¡é”™è¯¯ã€‚\næˆ‘ä¸æœŸæœ›ä½ çœ‹å®Œè¿™æ®µè¯å°±çœŸçš„èƒ½å¬è¿›å» (å› ä¸ºè¿™ä¹Ÿæ˜¯äººç±»åˆ»åœ¨åŸºå› é‡Œçš„å¼±ç‚¹ä¹‹ä¸€)ï¼Œä½†æˆ‘è¡·å¿ƒå¸Œæœ›ä½ ä¸ºä¹‹ä»˜å‡ºçš„ä»£ä»·èƒ½æ¯”æˆ‘å°ä¸€äº›ã€‚\n","date":1679443200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1679443200,"objectID":"8a5544446b554a3a6f7ed6ff4bac3409","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/coding/modulation/","publishdate":"2023-03-22T00:00:00Z","relpermalink":"/courses/problemsolving22/coding/modulation/","section":"courses","summary":"ä¸å°‘åŒå­¦è¢«OJçš„å–æ¨¡é—®é¢˜æŠ˜ç£¨å¾—å¿ƒåŠ›æ†”æ‚´â€”â€”ä¸è®ºå¤šä¹ˆä»”ç»†åœ°æ£€æŸ¥æ¯ä¸€å¤„å››åˆ™è¿ç®—ï¼Œæ€»ä¼šæœ‰ä¸€å¤„æ¼ç½‘ä¹‹é±¼è®©ç¨‹åºè¾“å‡ºé”™è¯¯çš„ç»“æœã€‚è¿™é‡Œæˆ‘ä»¬å±•ç¤ºä¸€ç§æ¯”è¾ƒä¼˜é›…çš„ä»£ç ä¹¦å†™æ–¹å¼ï¼š\nconst int MOD = 998244353; int add(int x, int y) { x += y; if (x \u0026gt;= MOD) x -= MOD; return x;} int sub(int x, int y) { x -= y; if (x \u0026lt; 0) x += MOD; return x; } int mul(int x, int y) { return 1ll * x * y % MOD; } void Add(int \u0026amp;x, int y) { x = add(x, y); } void Sub(int \u0026amp;x, int y) { x = sub(x, y); } void Mul(int \u0026amp;x, int y) { x = mul(x, y); } è¿™é‡Œæˆ‘ä»¬å®šä¹‰äº† MOD è¿™ä¸ªå˜é‡ä»¥åŠ 6 ä¸ªå‡½æ•°ç»Ÿä¸€å®ŒæˆåŠ æ³•ã€å‡æ³•å’Œä¹˜æ³•çš„å–æ¨¡æ“ä½œã€‚è¿™æ ·åç»­ç¨‹åºä¸­çš„ä»»ä½•è¿ç®—éƒ½å¯ä»¥è°ƒç”¨è¿™å‡ ä¸ªå‡½æ•°æ¥å®ç°ï¼š","tags":null,"title":"ä¼˜é›…åœ°å–æ¨¡","type":"docs"},{"authors":null,"categories":null,"content":"æŒ‰ç…§çº¿æ€§ä»£æ•°ä¸­çš„çŸ©é˜µä¹˜æ³•è§„åˆ™ï¼Œå¸¸è§çš„çŸ©é˜µä¹˜æ³•å†™æ³•å¦‚ä¸‹ï¼š\nfor (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) for (int k = 1; k \u0026lt;= n; k++) c[i][j] += a[i][k] * b[k][j] ä½†æ˜¯æˆ‘ä»¬å¼ºçƒˆå»ºè®®ä½ è°ƒæ•´å¾ªç¯çš„é¡ºåºï¼ŒæŒ‰ç…§å¦‚ä¸‹æ–¹å¼ä¹¦å†™çŸ©é˜µä¹˜æ³•ï¼š\nfor (int i = 1; i \u0026lt;= n; i++) for (int k = 1; k \u0026lt;= n; k++) for (int j = 1; j \u0026lt;= n; j++) c[i][j] += a[i][k] * b[k][j] è™½ç„¶è¿™æ ·æœ‰ç‚¹â€œåç›´è§‰â€ï¼Œä½†åœ¨ç¨å¤§è§„æ¨¡çš„æ•°æ®ä¸‹è¿è¡Œæ—¶ï¼Œä½ ä¼šå‘ç°è¿™ç§å†™æ³•çš„æ•ˆç‡æ¯”å‰è€…é«˜å¾ˆå¤šã€‚ç†è§£æ•ˆç‡æé«˜çš„åŸå› éœ€è¦å¯¹è®¡ç®—æœºä½“ç³»ç»“æ„å’Œ C/C++ è¯­è¨€ä¸­æ•°ç»„åœ¨å†…å­˜ä¸­çš„å­˜å‚¨æœ‰ä¸€å®šçš„äº†è§£ï¼Œè¿™é‡Œä¸ä½œèµ˜è¿°ã€‚ä½ å¯ä»¥æš‚ä¸”å°†å…¶èƒŒä¸‹æ¥ ğŸ˜‚\nä¸ºäº†æ›´ä¼˜é›…åœ°å®ç°çŸ©é˜µå¿«é€Ÿå¹‚ï¼Œæˆ‘ä»¬è¿˜å¼ºçƒˆå»ºè®®ä½ å­¦ä¹  C++ Class ç›¸å…³çš„å†…å®¹å¹¶äº†è§£æ“ä½œç¬¦é‡è½½ã€‚è¿™æ ·ä½ å¯ä»¥è‡ªå·±å®šä¹‰çŸ©é˜µç±»å¹¶ä¸ºçŸ©é˜µç±»ä¹¦å†™ä¹˜æ³•è§„åˆ™ï¼Œä»è€Œç›´æ¥å¤ç”¨â€œå¿«é€Ÿå¹‚â€ä¸€è®²ä¸­çš„ä»£ç è®¡ç®—çŸ©é˜µå¿«é€Ÿå¹‚ã€‚ä¸‹é¢ç»™å‡ºä¸€ä¸ªå‚è€ƒå®ç°ï¼š\nclass Matrix { int b[10][10]; Matrix () { memset(b, 0, sizeof(b)); } void init_I() { for (int i = 1; i \u0026lt;= n; i++) b[i][i] = 1; } Matrix operator * (Matrix other) { Matrix res; for (int i = 1; i \u0026lt;= n; i++) for (int k = 1; k \u0026lt;= n; k++) for (int j = 1; j \u0026lt;= n; j++) res.b[i][j] += b[i][k] * other.b[k][j]; return res; } }; Matrix quick_pow(Matrix x, int y) { T res; res.init_I(); while (y) { if (y \u0026amp; 1) res = res * x; x = x * x; y \u0026gt;\u0026gt;= 1; } return res; } ","date":1679443200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1679443200,"objectID":"add2b1461c94bca5cb2465fa9692ba01","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/coding/matmul/","publishdate":"2023-03-22T00:00:00Z","relpermalink":"/courses/problemsolving22/coding/matmul/","section":"courses","summary":"æŒ‰ç…§çº¿æ€§ä»£æ•°ä¸­çš„çŸ©é˜µä¹˜æ³•è§„åˆ™ï¼Œå¸¸è§çš„çŸ©é˜µä¹˜æ³•å†™æ³•å¦‚ä¸‹ï¼š\nfor (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) for (int k = 1; k \u0026lt;= n; k++) c[i][j] += a[i][k] * b[k][j] ä½†æ˜¯æˆ‘ä»¬å¼ºçƒˆå»ºè®®ä½ è°ƒæ•´å¾ªç¯çš„é¡ºåºï¼ŒæŒ‰ç…§å¦‚ä¸‹æ–¹å¼ä¹¦å†™çŸ©é˜µä¹˜æ³•ï¼š","tags":null,"title":"çŸ©é˜µå¿«é€Ÿå¹‚","type":"docs"},{"authors":null,"categories":["Theoretical Computer Science"],"content":" Getting Started: Fibonacci A Variation of Fibonacci When It Comes to Higher Ordersâ€¦ An â€œEigendecompositionâ€ Approach Fibonacci: Review I Cayley-Hamilton Theorem The Characteristic Polynomial For Homogeneous Linear Recurrence Matrices Magical Decomposition Summary \u0026amp; Complexity Analysis A â€œGeneratingfunctionologyâ€ Approach Fibonacci: Review II Generating Function Equation for General Linear Recurrences An Even-Odd Separation Idea Summary \u0026amp; Complexity Analysis Conclusion \u0026amp; Misc References The post focuses on solving homogeneous linear recurrences quickly with the aid of computers. Specifically, we are interested in figuring out the $n$-th term of sequences with the following recurrence formula:\n$$ f_n=\\sum_{k=1}^m c_kf_{n-k} $$\nSince the answer may be too large, we usually focus on $f\u0026rsquo;_n=f_n\\mod M$. We are more interested in cases where $M$ is suitable for FFT, such as $998,244,353$, because polynomial-related techniques can be leveraged to accelerate the computation. In the whole passage, we will use $f_n$ (instead of $f\u0026rsquo;_n$) to represent the answer under modulation for simplicity.\nGetting Started: Fibonacci Letâ€™s start with one of the simplest (and most famous) sequences: Fibonacci.\n$$ F_n=\\begin{cases}0\u0026amp;, n=1\\\\1\u0026amp;, n=2\\\\F_{n-1}+F_{n-2}\u0026amp;, n\\geq 2\\end{cases} $$\nComputing $F_n$ in $O(n)$ time complexity is trivial. But when $n$ is extremely large, say, $\\geq 10^9$, itâ€™s hard for general computers to get the answer within seconds. One of the most common approaches to solving such problems is using matrices.\nMatrices are good at describing linear relationships, and the recurrence formula of Fibonacci happens to be linear. Therefore we can rewrite it in matrix language:\n$$ \\begin{pmatrix}0 \u0026amp; 1\\\\1 \u0026amp; 1\\end{pmatrix}\\begin{pmatrix}F_{n-1}\\\\F_n\\end{pmatrix}=\\begin{pmatrix}0\\cdot F_{n-1}+1\\cdot F_n\\\\1\\cdot F_{n-1}+1\\cdot F_n\\end{pmatrix}=\\begin{pmatrix}F_n\\\\F_{n+1}\\end{pmatrix} $$\n$\\begin{pmatrix}0 \u0026amp; 1\\\\1 \u0026amp; 1\\end{pmatrix}$is a good matrix for â€œpushingâ€ the computation of $F_n$ by 1. Although this seems trivial, when we repeatedly use the matrix to push forward our computation, things become interesting:\n$$ \\begin{pmatrix}F_n\\\\F_{n+1}\\end{pmatrix}=\\begin{pmatrix}0 \u0026amp; 1\\\\1 \u0026amp; 1\\end{pmatrix}\\cdots\\left(\\begin{pmatrix}0 \u0026amp; 1\\\\1 \u0026amp; 1\\end{pmatrix}\\left(\\begin{pmatrix}0 \u0026amp; 1\\\\1 \u0026amp; 1\\end{pmatrix}\\begin{pmatrix}F_0\\\\F_1\\end{pmatrix}\\right)\\right) $$\nThanks to the associativity of matrix multiplication, we can neatly rewrite the expression as\n$$ \\begin{pmatrix}F_n\\\\F_{n+1}\\end{pmatrix}=\\begin{pmatrix}0 \u0026amp; 1\\\\1 \u0026amp; 1\\end{pmatrix}^n\\begin{pmatrix}F_0\\\\F_1\\end{pmatrix} $$\nSo far, we have not simplified the computation of $F_n$, and matrix multiplications even place more burden on the computer. However, we have powerful techniques to deal with exponents: repeated squaring, i.e., denote the transformation matrix as $M$, we first compute $M^2$, then compute $M^4$ by taking the square of $M^2$, and so on. In this way, we can compute $\\begin{pmatrix}0 \u0026amp; 1\\\\1 \u0026amp; 1\\end{pmatrix}^n$in $O(\\log n)$ complexity, and finally by applying it to the initial vector $\\begin{pmatrix}F_0\\\\F_1\\end{pmatrix}$weâ€™ll get $F_n$.\nIf youâ€™re an experienced math learner, you must have known several ways to directly compute the general term formula of the Fibonacci sequence and may complain about this â€œstupidâ€ matrix approach. However, the general term formula containing irrational coefficients is unfriendly for numerical computations. Iâ€™m not saying that those approaches are useless - instead, in the following sections weâ€™ll come back to the basic Fibonacci example again and again and see how advanced math gives insights into efficient algorithm design.\nA Variation of Fibonacci Before delving deeper into the problem, let\u0026rsquo;s consider a slightly varied version of the Fibonacci sequence:\n$$ F_n=\\begin{cases}0\u0026amp;, n=1\\\\1\u0026amp;, n=2\\\\F_{n-1}+F_{n-2}+n\u0026amp;, n\\geq 2\\end{cases} $$\nRigorously, this is not a homogeneous linear recurrence, but we list it here because itâ€™s a nice example of designing transformation matrices. The only difference is the additional $+n$ when $n\\geq 2$, but it seems much more challenging because we cannot represent $n$ as the linear combination of $F_{n-1}$ and $F_{n-2}$.\nA general insight is that we can include more terms in the â€œstate vectorâ€ ( in the standard Fibonacci sequence itâ€™s $\\begin{pmatrix}F_{n} \u0026amp; F_{n+1}\\end{pmatrix}$). Apart from necessary terms in the sequence, we can add â€œhelper termsâ€ to help us find the linear combinations of wanted expressions. Letâ€™s try adding $n$ into the state vector:\n$$ \\begin{pmatrix}F_{n-2}\\\\F_{n-1}\\\\n\\end{pmatrix}\\overset{which\\ matrix?}{\\Longrightarrow}\\begin{pmatrix}F_{n-1}\\\\F_{n}\\\\n+1\\end{pmatrix} $$\nUnfortunately, getting $n+1$ from $n$ is impossible because we have nobody to borrow the â€œ1â€ from - but why donâ€™t we add constant 1 into our state vector as well?\n$$ \\begin{pmatrix}0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0\\\\1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 0\\\\0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 1\\\\0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1\\end{pmatrix}\\begin{pmatrix}F_{n-2}\\\\F_{n-1}\\\\n\\\\1\\end{pmatrix}=\\begin{pmatrix}F_{n-1}\\\\F_n\\\\n+1\\\\1\\end{pmatrix} $$\nOnce we have the transformation matrix of a sequence, the rest is simple: do matrix multiplications by repeated squaring. To solve this Fibonacci variation, we need a matrix with rank 4, even if it\u0026rsquo;s a second-order recurrence. There\u0026rsquo;s no fixed procedure for devising such a matrix - in some subtle cases, a little human wisdom is necessary.\nWhen It Comes to Higher Ordersâ€¦ The examples shown above are all constant-order recurrences. In the Fibonacci example, we claim that the time complexity is $O(\\log n)$ because the influence from the rank is negligible. However, if weâ€™re confronted with recurrences with higher orders, say $k$, the time complexity of the matrix approach should be $O(k^3\\log n)$ (we donâ€™t take into account algorithms like Strassenâ€™s multiplication because they often come with huge constants), which is prohibitively high even if $k$ is only a few thousand.\nThe journey has just begun! The following sections introduce 2 directions for optimization: one is related to the characteristic polynomial of matrices, and the other leverages generating functions to tackle the issue.\nAn â€œEigendecompositionâ€ Approach Fibonacci: Review I A common approach to optimizing matrix powering is eigendecomposition, i.e., for a matrix $M$ with rank $n$, if $M$ has $n$ independent eigenvectors, then $M$ is diagonalizable: $M=S\\Lambda S^{-1}$, where $\\Lambda$ is a diagonal matrix consisting of eigenvalues and $S$ is a matrix consisting of (column) eigenvectors. With this diagonalized form, powering becomes super easy: $M^n=(S\\Lambda S^{-1})^n=S\\Lambda^nS^{-1}$.\nCome back to the Fibonacci example, the only thing left is to compute the eigenvalues of the transformation matrix. For $2\\times 2$ matrices, solving the following quadratic characteristic equation is simple:\n$$ M=\\begin{pmatrix}0\u0026amp;1\\\\1\u0026amp;1\\end{pmatrix}\\qquad\\qquad \\begin{align*}f(\\lambda)\u0026amp;=\\det(M-\\lambda I)=0\\\\\u0026amp;\\Longrightarrow\\lambda_{1,2}=\\frac{1\\pm\\sqrt 5}{2},\\mathbf{x}=\\begin{pmatrix} \\lambda\\\\1\\end{pmatrix}\\end{align*} $$\nTherefore,\n$$ \\begin{align*}\\begin{pmatrix}F_n\\\\F_{n+1}\\end{pmatrix}\u0026amp;=\\begin{pmatrix}0\u0026amp;1\\\\1\u0026amp;1\\end{pmatrix}^n\\begin{pmatrix}F_0\\\\F_1\\end{pmatrix}\\\\\u0026amp;=\\left[\\begin{pmatrix}\\mathbf{x}_1\u0026amp;\\mathbf{x}_2\\end{pmatrix}\\begin{pmatrix}\\lambda_1 \u0026amp; \\\\\u0026amp;\\lambda_2\\end{pmatrix}\\begin{pmatrix}\\mathbf{x}_1\u0026amp;\\mathbf{x}_2\\end{pmatrix}^{-1}\\right]^n\\begin{pmatrix}F_0\\\\F_1\\end{pmatrix}\\\\\u0026amp;=\\begin{pmatrix}\\mathbf{x}_1\u0026amp;\\mathbf{x}_2\\end{pmatrix}\\begin{pmatrix}\\lambda_1^n\u0026amp;\\\\\u0026amp;\\lambda_2^n\\end{pmatrix}\\begin{pmatrix}\\mathbf{x}_1\u0026amp;\\mathbf{x}_2\\end{pmatrix}^{-1}\\begin{pmatrix}F_0\\\\F_1\\end{pmatrix}\\end{align*} $$\nCayley-Hamilton Theorem Unfortunately, when it comes to transformation matrices with arbitrary rank, itâ€™s difficult to solve high-order characteristic equations and irrational eigenvalues are hard for numerical computations. However, the general idea still works: we should find nice properties related to characteristic polynomials and try to do decomposition.\nWe introduce the Cayley-Hamilton theorem, which describes an interesting property of square matrices.\n$\\fbox{Theorem}$ (Cayley-Hamilton)\nIn linear algebra, the Cayley-Hamilton theorem states that every square matrix over a commutative ring satisfies its own characteristic equation, i.e., denote $f(\\lambda)=\\det(\\lambda I-A)$ as the characteristic polynomial of $A$, then $f(A)=O$.\nBeginners may regard this theorem as trivial by the observation that $\\det(AI-A)=0$. However, this â€œbogus proofâ€ is totally ungrounded because $f(A)$ is a matrix, not a scalar. Since itâ€™s not a rigorous math post, weâ€™ll not prove this theorem in a detailed manner from scratch. Instead, we give the following lemma without proof:\n$\\fbox{Lemma}$ Diagonalizable matrices are dense in the space of all matrices.\nProof of Cayley-Hamilton theorem\nWe start with diagonalizable matrices. For an arbitrary diagonalizable matrix $A$ with rank $n$, it has $n$ independent eigenvectors satisfying $A\\mathbf{x_i}=\\lambda_i\\mathbf{x_i}$. Consider $f(A)\\mathbf{x_i}$, suppose $f(\\lambda)$ is a polynomial with coefficient $c_i$ for term $\\lambda^i$, then\n$$ \\begin{align*}f(A)\\mathbf{x_i}\u0026amp;=\\left(\\sum_{k=0}^nc_kA^k\\right)\\mathbf{x_i}=\\sum_{k=0}^nc_k(A^k\\mathbf{x_i})\\\\\u0026amp;=\\sum_{k=0}^nc_k(\\lambda_i^k\\mathbf{x_i})\\\\\u0026amp;=\\left(\\sum_{k=0}^nc_k\\lambda_i^k\\right)\\mathbf{x_i}\\\\\u0026amp;=f(\\lambda_i)\\mathbf{x_i}=\\mathbf{0}\\end{align*} $$\nTherefore, for each eigenvector $\\mathbf{x_i}$, $f(A)\\mathbf{x_i}=\\mathbf{0}$. By combining eigenvectors to a matrix $S=\\begin{pmatrix}\\mathbf{x_1}\u0026amp;\\cdots\u0026amp;\\mathbf{x_n}\\end{pmatrix}$, we have $f(A)S=O$. Since $S$ is a full-rank matrix, the only possibility is that $f(A)=O$.\nNow letâ€™s move to non-diagonalizable matrices, denoted as $D$. According to the density of diagonalizable matrices in the whole matrix space, there exists a matrix $H$ such that a cluster of matrices $D_t=D+tH$, $t\\in (-1, 0)\\cup (0, 1)$, are diagonalizable. Since $D_t$ is continuous on $t$, $f_{D_t}(D_t)$ is also continuous on $t$, therefore\n$$ f(D)=\\lim_{t\\to 0}f_{D_t}(D_t)=O $$\nThe Characteristic Polynomial For Homogeneous Linear Recurrence Matrices For homogeneous linear recurrence transformation matrices, characteristic polynomial $f$ is easy to compute: according to the recurrence formula, we have\n$$ A=\\begin{pmatrix}0\u0026amp; 1\\\\\u0026amp; \u0026amp; 1\\\\\u0026amp; \u0026amp; \u0026amp; \\ddots\\\\\u0026amp; \u0026amp; \u0026amp; \u0026amp; 1\\\\c_1 \u0026amp; c_2 \u0026amp; c_3 \u0026amp; \\cdots \u0026amp; c_k\\end{pmatrix} $$\nThen\n$$ f(\\lambda)=\\det(\\lambda I-A)=\\begin{vmatrix}\\lambda \u0026amp; -1\\\\\u0026amp; \\lambda \u0026amp; -1\\\\\u0026amp; \u0026amp; \\ddots\u0026amp; \\ddots\\\\\u0026amp; \u0026amp; \u0026amp; \\lambda \u0026amp; -1\\\\-c_1 \u0026amp; -c_2 \u0026amp; -c_3\u0026amp;\\cdots\u0026amp;\\lambda-c_k\\end{vmatrix} $$\nExpanding the determinant by the last row, weâ€™ll observe that every minor is easy to compute: $A_{k,i}=(-1)^{k-i}\\lambda^{i-1}$. Therefore\n$$ \\begin{align*}f(\\lambda)\u0026amp;=(-1)^{2k}(\\lambda-c_k)\\lambda^{k-1}+\\sum_{i=1}^{k-1}(-1)^{k+i}\\cdot ((-1)^{k-i}\\lambda^{i-1})\\cdot (-c_i)\\\\\u0026amp;=\\lambda^k-\\sum_{i=1}^kc_i\\lambda^{i-1}\\end{align*} $$\nMagical Decomposition Itâ€™s still unclear how Cayley-Hamilton theorem can help in optimization. The following approach was proposed by Fiduccia in 1985 [2]. For an arbitrary transformation matrix $A$ with rank $k$, consider the following decomposition:\n$$ x^n=f(x)g(x)+r(x) $$\nwhere $f$ is the characteristic polynomial of $A$ and $g(x)/r(x)$ can be computed through polynomial division/modulation. In fact, we are more interested in $r(x)$ because when we let $x=A$:\n$$ A^n=f(A)g(A)+r(A)\\overset{\\text{Cayley-Hamilton}}{=}r(A) $$\nIt seems that we havenâ€™t made solid progress because $r$ is a $k$-order polynomial and computing $r(A)$ by brute force requires $O(k^4)$ effort. However, suppose $\\displaystyle r(x)=\\sum_{i=0}^{k-1}c_ix^i$, actually weâ€™re able to compute $F_n$ in $O(k)$ thanks to the following deduction:\n$$ \\begin{align*}\\begin{pmatrix}F_n\\\\F_{n+1}\\\\\\vdots\\\\F_{n+k-1}\\end{pmatrix}\u0026amp;=A^n\\begin{pmatrix}F_0\\\\F_1\\\\\\vdots\\\\F_{k-1}\\end{pmatrix}=R(A)\\begin{pmatrix}F_0\\\\F_1\\\\\\vdots\\\\F_{k-1}\\end{pmatrix}\\\\\u0026amp;=\\left(\\sum_{i=0}^{k-1}c_iA^i\\right)\\begin{pmatrix}F_0\\\\F_1\\\\\\vdots\\\\F_{k-1}\\end{pmatrix}\\\\\u0026amp;=\\sum_{i=0}^{k-1}c_i\\left(A^i\\begin{pmatrix}F_0\\\\F_1\\\\\\vdots\\\\F_{k-1}\\end{pmatrix}\\right)\\\\\u0026amp;=\\sum_{i=0}^{k-1}c_i\\begin{pmatrix}F_i\\\\F_{i+1}\\\\\\vdots\\\\F_{i+k-1}\\end{pmatrix}\\end{align*} $$\nTherefore\n$$ F_n=\\sum_{i=0}^{k-1}c_iF_i $$\nSummary \u0026amp; Complexity Analysis Letâ€™s have a quick summary of the whole procedure and analyze the complexity:\nConstruct a transformation matrix $A$ according to the recurrence formula. Compute the characteristic polynomial $f_A$. Compute $r_A(x)=x^n\\text{ mod }f_A$. Compute $F_n$ according to the coefficients in $r_A$. The main complexity lies in the third step. Since $n$ is extremely large, itâ€™s impossible to directly do polynomial modulation. Instead, we can leverage repeated squaring:\n$$ x\\Rightarrow [x^2]=(x)^2 \\text{ mod }f_A\\Rightarrow [x^4]=[x^2]^2\\text{ mod }f_A\\Rightarrow \\cdots \\Rightarrow x^n\\text{ mod }f_A $$\nIn this way, we need to conduct $O(\\log n)$ times polynomial multiplication and modulation, which gives a $O(k^2\\log n)$ complexity. If the problem is considered in a ring that supports Fast Fourier Transformation (typically an NTT ring), we can further optimize it to $O(k\\log k\\log n)$.\nA â€œGeneratingfunctionologyâ€ Approach Fibonacci: Review II Generating function is always a powerful weapon for tackling sequence problems. Consider\n$$ G(x)=\\sum_{n=0}^\\infty F_nx^n $$\nSince $F_n=F_{n-1}+F_{n-2}$ when $n\\geq 2$, we can get\n$$ G(x)=F_0+F_1x+xG(x)+x^2G(x)=x+(x+x^2)G(x) $$\nTherefore $\\displaystyle G(x)=\\frac{x}{1-x-x^2}=\\frac{1}{\\sqrt 5}\\left(\\frac{1}{1-\\phi x}-\\frac{1}{1-\\hat\\phi x}\\right)$, where $\\phi=\\displaystyle \\frac{1+\\sqrt 5}{2}$ and $\\displaystyle \\hat\\phi=\\frac{1-\\sqrt 5}{2}$. Expand it to Taylor series, we have\n$$ \\begin{align*}G(x)\u0026amp;=\\frac{1}{\\sqrt 5}\\left(\\sum_{n\\geq 0}(\\phi x)^n-\\sum_{n\\geq 0}(\\hat\\phi x)^n\\right)\\\\\u0026amp;=\\sum_{n\\geq 0}\\left(\\frac{1}{\\sqrt 5}(\\phi^n-\\hat\\phi^n)\\right)x^n\\end{align*} $$\nThus $\\displaystyle F_n=\\frac{1}{\\sqrt 5}(\\phi^n-\\hat\\phi^n)$.\nGenerating Function Equation for General Linear Recurrences However, when it comes to recurrences with arbitrary order, techniques like Taylor expansion will lose its power for computers. Anyway, letâ€™s figure out the equation first. Put the coefficients of linear recurrence into a generation function, denoted as $G(x)$, i.e.,\n$$ G(x)=\\sum_{i=1}^kc_ix^i $$\nwe have\n$$ F(x)=F(x)G(x)+R(x) $$\nWhere $R(x)$ is a polynomial for correcting the first few terms in the sequence and can be obtained by computing $F\u0026rsquo;(x)-F\u0026rsquo;(x)G(x)$, where $F\u0026rsquo;(x)$ is the first $k$ terms of $F(x)$.\nTherefore\n$$ F(x)=\\frac{R(x)}{1-G(x)} $$\nAn Even-Odd Separation Idea Since $n$ is extremely huge, computing the polynomial inverse of $1-G(x)$ and then computing $[x^n]F(x)$ through polynomial multiplication is unreasonable. We need a quick way to compute\n$$ [x^n]F(x)=[x^n]\\frac{P(x)}{Q(x)} $$\nwhere $P(x)$ and $Q(x)$ stands for $R(x)$ and $1-G(x)$ in this case.\nConsider the following transformation:\n$$ F(x)=\\frac{P(x)}{Q(x)}=\\frac{P(x)Q(-x)}{Q(x)Q(-x)} $$\n$Q(x)Q(-x)$ is an even function. Let $U(x^2)=Q(x)Q(-x)$, and divide $P(x)Q(-x)$ into two parts according to the parity of $x^k$, we have\n$$ F(x)=\\frac{xOdd(x^2)}{U(x^2)}+\\frac{Even(x^2)}{U(x^2)} $$\nThanks to the fact that $U(x^2)$ only contains even powers, $F(x)$ is successfully separated as an odd part and an even part, and we can choose the part containing $x^n$ (according to the parity of $n$) to continue our computation.\nSummary \u0026amp; Complexity Analysis Letâ€™s have a quick summary of the whole procedure and analyze the complexity:\nCompute $R(x)$ and $G(x)$. Compute $P(x)Q(-x)$ and $Q(x)Q(-x)$ respectively. Choose the part with the same parity as $n$. Repeatedly conduct step 2 until the polynomial becomes a constant one. Step 2 contains polynomial multiplications, which requires $O(k^2)$/$O(k\\log k)$ depending on whether FFT is supported. Every time we conduct step 2, the formal variable of the generating functions grow from $x$ to $x^2$. Therefore the power grows exponentially and we can terminate within $O(\\log n)$ iterations. So the overall complexity is $O(k^2\\log n)$/$O(k\\log k\\log n)$.\nItâ€™s worth noting that although the â€œgeneratingfunctionologyâ€ approach has the same time complexity as the previous one, it requires simpler polynomial techniques (only multiplication). The paper [3] argues that this approach improves the result of Fiduccia on constant factors.\nConclusion \u0026amp; Misc The post introduces several kinds of techniques for tackling homogeneous linear recurrence problems. Matrix multiplication with repeated squaring optimizes the complexity from the most trivial $O(kn)$ to $O(k^3\\log n)$, and the following 2 approaches leverage linear algebra/generating function to further improve it to $O(k^2\\log n)$/$O(k\\log k\\log n)$. Readers can refer to the papers for deeper understanding.\nI learned most of the techniques mentioned above when I was taking part in competitive programming contests during high school. There was no detailed tutorial on the Internet at that time and the knowledge are spread through word of mouth. I would be most happy if the post can bring the wisdom of TCS researchers to more people in the world.\nReferences [1] Cayley-Hamilton Theorem. Wikipedia. [2] C. M. Fiduccia. An efficient formula for linear recurrences. SIAM Journal on Computing, 14(1):106â€“112, 1985. [3] Bostan, A., \u0026amp; Mori, R. (2020). A Simple and Fast Algorithm for Computing the N-th Term of a Linearly Recurrent Sequence. ArXiv. ","date":1679097600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1679097600,"objectID":"a68890da38a7b1b2fbc3c1d7f95155f7","permalink":"https://kristoff-starling.github.io/posts/recurrences/","publishdate":"2023-03-18T00:00:00Z","relpermalink":"/posts/recurrences/","section":"posts","summary":"How to quickly solve homogeneous linear recurrences with the aid of computers :rocket:","tags":null,"title":"Homogeneous Linear Recurrences: An Algorithmic Perspective","type":"posts"},{"authors":null,"categories":null,"content":"ç»™å®š $a,n$ï¼Œè€ƒè™‘å¦‚ä½•è®¡ç®— $a^n$ ã€‚å¦‚æœä½¿ç”¨å¦‚ä¸‹å¾ªç¯è®¡ç®—ç»“æœ\nint res = 1; for (int i = 1; i \u0026lt;= n; i++) res = res * a; æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ï¼Œå½“ $n$ å¾ˆå¤§æ—¶æ•ˆç‡å¤ªä½ã€‚å¿«é€Ÿå¹‚æ˜¯ç”¨äºè®¡ç®—è¯¥ç±»é—®é¢˜çš„å¸¸è§ç®—æ³•ï¼Œå…¶æœ¬è´¨æ€æƒ³æ˜¯é€’å½’/å€å¢:\n$$ a^n=\\begin{cases}1\u0026amp;,n=0\\\\(a^{n/2})^2\u0026amp;,næ˜¯å¶æ•°, n\\geq 1\\\\(a^{\\lfloor n/2\\rfloor})^2\\cdot a\u0026amp;,næ˜¯å¥‡æ•°, n\\geq 1\\end{cases} $$\nå› æ­¤æˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸æ–­æŠ˜åŠå¹‚æ¬¡çš„æ–¹å¼æ¥æ±‚è§£ $a^n$ã€‚å†™å‡ºè¯¥ç®—æ³•çš„å¤æ‚åº¦é€’å½’è¡¨è¾¾å¼ï¼š\n$$ T(n)=T(n/2)+O(1) $$\nå®¹æ˜“å¾—å‡º $T(n)=O(\\log n)$ã€‚\nç›´æ¥æ ¹æ®é€’å½’å¼ï¼Œæˆ‘ä»¬å®¹æ˜“å†™å‡ºå¦‚ä¸‹é€’å½’ä»£ç :\nint quick_pow(int a, int n) { if (n == 0) return 1; res = quick_pow(a, n / 2); if (n % 2 == 0) return res * res; else return res * res * a; } ä½†æˆ‘ä»¬é€šå¸¸ä½¿ç”¨ä¸€ç§æ›´åŠ ä¼˜ç¾çš„å†™æ³•æ¥ä½¿ç”¨å¾ªç¯æ›¿ä»£é€’å½’ï¼š\nint quick_pow(int a, int n) { int res = 1; while (n) { if (n \u0026amp; 1) res = res * a; a = a * a; n \u0026gt;\u0026gt;= 1; } return res; } è¯¥å®ç°çš„æ ¸å¿ƒæ€æƒ³æ˜¯åˆ©ç”¨ $n$ çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­ 1 çš„ä½ç½®æ¥åˆ¤æ–­ $a^n$ æ˜¯ç”±å“ªäº› $a^{2^k}$ ç»„åˆè€Œæˆçš„ã€‚å³å¦‚æœ $n$ çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­åœ¨ $k_1,k_2,\\cdots, k_m$ è¿™äº›ä½ç½®ä¸Šæ˜¯ 1ï¼Œé‚£ä¹ˆ\n$$ a^n=a^{\\sum_{i=1}^m2^{k_i}}=\\prod_{i=1}^ma^{2^{k_i}} $$\n","date":1679097600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1679097600,"objectID":"5461e8eca254e2e4a7f00318098c9948","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/algorithms/repeatedsquare/","publishdate":"2023-03-18T00:00:00Z","relpermalink":"/courses/problemsolving22/algorithms/repeatedsquare/","section":"courses","summary":"ç»™å®š $a,n$ï¼Œè€ƒè™‘å¦‚ä½•è®¡ç®— $a^n$ ã€‚å¦‚æœä½¿ç”¨å¦‚ä¸‹å¾ªç¯è®¡ç®—ç»“æœ\nint res = 1; for (int i = 1; i \u0026lt;= n; i++) res = res * a; æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ï¼Œå½“ $n$ å¾ˆå¤§æ—¶æ•ˆç‡å¤ªä½ã€‚å¿«é€Ÿå¹‚æ˜¯ç”¨äºè®¡ç®—è¯¥ç±»é—®é¢˜çš„å¸¸è§ç®—æ³•ï¼Œå…¶æœ¬è´¨æ€æƒ³æ˜¯é€’å½’/å€å¢:\n$$ a^n=\\begin{cases}1\u0026amp;,n=0\\\\(a^{n/2})^2\u0026amp;,næ˜¯å¶æ•°, n\\geq 1\\\\(a^{\\lfloor n/2\\rfloor})^2\\cdot a\u0026amp;,næ˜¯å¥‡æ•°, n\\geq 1\\end{cases} $$","tags":null,"title":"å¿«é€Ÿå¹‚","type":"docs"},{"authors":null,"categories":null,"content":"å…³äºåŸºç¡€ç†è®ºï¼Œå‚è§ è¿™ç¯‡åšæ–‡ã€‚å¦‚æœä½ ä¹‹å‰ä»æœªäº†è§£è¿‡çº¿æ€§é€’æ¨ç›¸å…³çš„çŸ¥è¯†/ç›®å‰ä»¥å®ŒæˆOJä¸ºä¸»è¦ç›®æ ‡ï¼Œåªéœ€çœ‹æ‡‚è¯¥æ–‡ç« çš„ Getting Started ç« èŠ‚ã€‚æœ¬æ–‡ä¸»è¦å¯¹çŸ©é˜µä¹˜æ³•å’ŒçŸ©é˜µå¿«é€Ÿå¹‚çš„å®ç°ç»™å‡ºä¸€ç‚¹å»ºè®®ã€‚\nDon\u0026rsquo;t Panic!\nåªæœ‰ Problem Solving ç›®å½•ä¸‹çš„å†…å®¹æ‰æ˜¯å¤§å®¶éœ€è¦ä¸”åº”å½“æŒæ¡çš„å†…å®¹ã€‚é“¾æ¥ä¸­åšæ–‡çš„å¤§éƒ¨åˆ†å†…å®¹ä¸é—®é¢˜æ±‚è§£è¯¾ç¨‹å¹¶ä¸ç›¸å…³ï¼Œä¸”æˆ‘ä¸è®¤ä¸ºæŒæ¡è¿™äº›æ•°å­¦å¼ºç›¸å…³çš„çŸ¥è¯†å¯¹è®¡ç®—æœºæ€ç»´æœ‰å¤ªå¤šæå‡ã€‚å› æ­¤å¦‚æœä½ ä¸æ„¿æ„è¯» Getting Started ä¹‹åçš„å†…å®¹/è¯»ä¸æ‡‚åé¢çš„å†…å®¹ï¼Œè¿™éå¸¸æ­£å¸¸ä¹Ÿæ— å…³ç´§è¦ï¼\nä½ å¯ä»¥å‚è€ƒ è¿™ç¯‡åšæ–‡ æ¥å­¦ä¹ çŸ©é˜µå¿«é€Ÿå¹‚å®ç°çš„ä»£ç ç»†èŠ‚ã€‚\n","date":1679097600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1679097600,"objectID":"10083c3eb72e99a1167e565504dc9e49","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/algorithms/matmul/","publishdate":"2023-03-18T00:00:00Z","relpermalink":"/courses/problemsolving22/algorithms/matmul/","section":"courses","summary":"å…³äºåŸºç¡€ç†è®ºï¼Œå‚è§ è¿™ç¯‡åšæ–‡ã€‚å¦‚æœä½ ä¹‹å‰ä»æœªäº†è§£è¿‡çº¿æ€§é€’æ¨ç›¸å…³çš„çŸ¥è¯†/ç›®å‰ä»¥å®ŒæˆOJä¸ºä¸»è¦ç›®æ ‡ï¼Œåªéœ€çœ‹æ‡‚è¯¥æ–‡ç« çš„ Getting Started ç« èŠ‚ã€‚æœ¬æ–‡ä¸»è¦å¯¹çŸ©é˜µä¹˜æ³•å’ŒçŸ©é˜µå¿«é€Ÿå¹‚çš„å®ç°ç»™å‡ºä¸€ç‚¹å»ºè®®ã€‚\nDon\u0026rsquo;t Panic!\nåªæœ‰ Problem Solving ç›®å½•ä¸‹çš„å†…å®¹æ‰æ˜¯å¤§å®¶éœ€è¦ä¸”åº”å½“æŒæ¡çš„å†…å®¹ã€‚é“¾æ¥ä¸­åšæ–‡çš„å¤§éƒ¨åˆ†å†…å®¹ä¸é—®é¢˜æ±‚è§£è¯¾ç¨‹å¹¶ä¸ç›¸å…³ï¼Œä¸”æˆ‘ä¸è®¤ä¸ºæŒæ¡è¿™äº›æ•°å­¦å¼ºç›¸å…³çš„çŸ¥è¯†å¯¹è®¡ç®—æœºæ€ç»´æœ‰å¤ªå¤šæå‡ã€‚å› æ­¤å¦‚æœä½ ä¸æ„¿æ„è¯» Getting Started ä¹‹åçš„å†…å®¹/è¯»ä¸æ‡‚åé¢çš„å†…å®¹ï¼Œè¿™éå¸¸æ­£å¸¸ä¹Ÿæ— å…³ç´§è¦ï¼\nä½ å¯ä»¥å‚è€ƒ è¿™ç¯‡åšæ–‡ æ¥å­¦ä¹ çŸ©é˜µå¿«é€Ÿå¹‚å®ç°çš„ä»£ç ç»†èŠ‚ã€‚","tags":null,"title":"çŸ©é˜µå¿«é€Ÿå¹‚","type":"docs"},{"authors":null,"categories":null,"content":" Problem A: BrainF**k Syntax Checker\né¢˜æ„æ¦‚æ‹¬ï¼šç»™å®šä¸€ä¸ª BF ç¨‹åºï¼Œåˆ¤æ–­å®ƒæ˜¯å¦ç¬¦åˆè¯­æ³•è¦æ±‚ã€‚\nBF ç¨‹åºä¸­çš„ + - , . \u0026gt; \u0026lt; æ˜¾ç„¶ä¸ä¼šå¯¹ç¨‹åºçš„åˆæ³•æ€§é€ æˆå½±å“ï¼Œå› æ­¤æœ¬é¢˜çš„ä¸»è¦ä»»åŠ¡æ˜¯åˆ¤æ–­ BF ç¨‹åºä¸­çš„ [ ] æ˜¯å¦å½¢æˆäº†åˆæ³•çš„æ‹¬å·åºåˆ—ï¼Œå³ä¸¤ä¸¤åŒ¹é…ã€‚\nå€¼å¾—æ³¨æ„çš„æ˜¯ï¼ŒBF ç¨‹åºä¸­ [ å’Œ ] çš„ä¸ªæ•°ç›¸åŒå¹¶ä¸æ˜¯æ‹¬å·åºåˆ—åˆæ³•çš„å……è¦æ¡ä»¶ï¼Œæ¯”å¦‚ ][ è¿™ä¸ªåºåˆ—å°±æ˜¯ä¸åˆæ³•çš„ã€‚åœ¨æ­¤åŸºç¡€ä¸Šï¼Œæˆ‘ä»¬è¿˜è¦ä¿è¯ BF ç¨‹åºçš„ä»»æ„å‰ç¼€ä¸­ï¼Œ[ çš„ä¸ªæ•°è¦å¤§äºç­‰äº ] çš„ä¸ªæ•°ã€‚\nCode [Click to expand] #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; char program[1000]; string ValidChar = \u0026quot;+-,.\u0026lt;\u0026gt;[]\u0026quot;; int main() { scanf(\u0026quot;%s\u0026quot;, program); int len = strlen(program), LeftRightDelta = 0; bool flag = true; for (int i = 0; i \u0026lt; len; i++) { if (ValidChar.find(program[i]) == string::npos) flag = false; if (program[i] == '[') LeftRightDelta++; if (program[i] == ']') LeftRightDelta--; if (LeftRightDelta \u0026lt; 0) flag = false; } puts((flag \u0026amp;\u0026amp; LeftRightDelta == 0) ? \u0026quot;Yes\u0026quot; : \u0026quot;No\u0026quot;); return 0; } Problem B: BrainF**k Interpreter\né¢˜æ„æ¦‚æ‹¬ï¼š ç»™å®šä¸€ä¸ª BF ç¨‹åºï¼Œæ¨¡æ‹Ÿå…¶è¿è¡Œè¿‡ç¨‹å¹¶è¾“å‡ºæœ€åçš„å†…å­˜çŠ¶æ€ã€‚\nè¿™æ˜¯ä¸€é“ç›¸å½“æœ‰æ„æ€çš„é¢˜ç›®ï¼Œè§£æ³•ä¹Ÿå¾ˆå¤šã€‚è¯¥é—®é¢˜çš„æ ¸å¿ƒéš¾ç‚¹æ˜¯å¦‚ä½•å¤„ç†åµŒå¥—çš„ä¸­æ‹¬å·ã€‚è€ƒåœºä¸Šæœ‰å¾ˆå¤šåŒå­¦åˆ©ç”¨é€’å½’å¤„ç†ä¸­æ‹¬å·çš„åµŒå¥—ï¼Œè¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½ä¸”å¯è¡Œçš„æ€è·¯ã€‚æˆ‘ä»¬åœ¨è¿™é‡Œä»‹ç»å¦å¤–ä¸€ç§ä¸éœ€è¦é€’å½’çš„æ€è·¯ï¼Œå®ƒä¹¦å†™èµ·æ¥æ›´åŠ ç®€æ´ï¼Œä¸”åœ¨ä¸€å®šç¨‹åº¦ä¸Šæ­ç¤ºäº†è®¡ç®—æœºè¿è¡Œçš„æœ¬è´¨â€”â€”å¤§å®¶åœ¨æœ¬å­¦æœŸçš„ æ•°å­—é€»è¾‘ä¸è®¡ç®—æœºç»„æˆ å’Œä¸‹å­¦æœŸçš„ è®¡ç®—æœºç³»ç»ŸåŸºç¡€ ä¸­ä¼šä¸æ–­ä¸è¿™ç§é€»è¾‘æ‰“äº¤é“ã€‚\nåœ¨é¢˜é¢çš„æç¤ºä¸­æˆ‘ä»¬å·²ç»ç»™å‡ºäº†è®¡ç®—æœºæ‰§è¡ŒæŒ‡ä»¤çš„å››æ­¥éª¤ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œå†é‡å¤ä¸€éï¼š\nå–æŒ‡ï¼šå–å‡ºä¸‹ä¸€æ¡æ‰§è¡Œçš„æŒ‡ä»¤ã€‚ è¯‘ç ï¼šæ ¹æ®æŒ‡ä»¤çš„æ ¼å¼ç¡®å®šè¯¥æŒ‡ä»¤çš„ç±»å‹ã€‚ æ‰§è¡Œï¼šæ ¹æ®æŒ‡ä»¤ç±»å‹ï¼Œæ‰§è¡Œè¯¥æŒ‡ä»¤å®šä¹‰çš„åŠ¨ä½œã€‚ è·³è½¬ï¼šæ ¹æ®æŒ‡ä»¤ç±»å‹å’Œæ‰§è¡Œè¿‡ç¨‹ï¼Œç¡®å®šä¸‹ä¸€æ¡åº”å½“æ‰§è¡Œçš„æŒ‡ä»¤çš„ä½ç½®ã€‚ çœŸæ­£çš„è®¡ç®—æœºå¤„ç†çš„æ˜¯â€œæ±‡ç¼–è¯­è¨€â€ï¼Œæˆ‘ä»¬çš„ BF è§£é‡Šå™¨å¤„ç†çš„æ˜¯ BF è¯­è¨€ï¼Œè¿™ä¸¤è€…åœ¨æœ¬è´¨ä¸Šæ²¡æœ‰åŒºåˆ«ã€‚è®¡ç®—æœºå†…éƒ¨é€šå¸¸æœ‰ä¸€ä¸ªç¨‹åºè®¡æ•°å™¨ (program counter, ç®€ç§° pc)ï¼Œå®ƒçš„åŠŸèƒ½å’Œè®¡æ•°æ²¡ä»€ä¹ˆå…³ç³»ï¼Œåè€Œåƒä¸€ä¸ªæŒ‡é’ˆï¼Œç”¨æ¥æŒ‡å‘ä¸‹ä¸€æ¡è¦æ‰§è¡Œçš„æŒ‡ä»¤ã€‚æˆ‘ä»¬æ¥å…·ä½“åœ°çœ‹çœ‹å››ä¸ªæ­¥éª¤å¯¹åº”åˆ° BF è¯­è¨€åº”å½“å¦‚ä½•æ“ä½œã€‚\nå–æŒ‡ï¼šè¿™æ˜¯æœ€ç®€å•çš„ä¸€æ­¥ï¼Œå¯¹åº”åˆ° C++ ä»£ç å¤§æ¦‚å°±æ˜¯ char instruction = program[pc]ã€‚\nè¯‘ç \u0026amp;æ‰§è¡Œï¼šè¿™ä¸¤æ­¥åœ¨ BF ä¸­å¯ä»¥æ”¾åœ¨ä¸€èµ·åš (å› ä¸º BF çš„æ‰€æœ‰æŒ‡ä»¤éƒ½æ²¡æœ‰â€œæ“ä½œæ•°â€)ï¼Œä½ å¤§æŠµä¼šç”¨ä¸€ä¸ª if/switch è¯­å¥æ¥åˆ¤æ–­ instruction æ˜¯ 8 ä¸ªç¬¦å·ä¸­çš„å“ªä¸€ç§å¹¶æ‰§è¡Œç›¸åº”çš„æ“ä½œã€‚å‰ 6 ç§æŒ‡ä»¤çš„æ“ä½œéƒ½éå¸¸ç®€å•ï¼Œè¿™é‡Œä¸å†èµ˜è¿°ã€‚[ å’Œ ] æœ¬è´¨ä¸Šæ˜¯åˆ†æ”¯æ§åˆ¶æŒ‡ä»¤ï¼Œæ‰€ä»¥åœ¨â€œæ‰§è¡Œâ€è¿™ä¸ªæ­¥éª¤ä¸­å®ƒä»¬ä»€ä¹ˆä¹Ÿä¸ç”¨åšã€‚\nè·³è½¬ï¼šå‰ 6 ç§æŒ‡ä»¤çš„è·³è½¬éƒ½éå¸¸ç®€å•ï¼šåšå®Œäº†å°±åšç´§æ¥ç€çš„ä¸‹ä¸€æ¡æŒ‡ä»¤ï¼Œå³ pc++ã€‚æˆ‘ä»¬ç€é‡è®²è§£ [ å’Œ ] çš„è·³è½¬å¦‚ä½•å¤„ç†ï¼š\n[ï¼šå·¦ä¸­æ‹¬å·æŒ‡ä»¤çš„é€»è¾‘æ˜¯ if (memory[pointer] != 0) pc++ // go into the loop else pc = (the position of the corresponding \u0026quot;]\u0026quot;) + 1 // skip the loop pc ç›´æ¥åŠ ä¸€æ„å‘³ç€è¿›å…¥å¾ªç¯ï¼Œpc è·³è½¬åˆ°å¯¹åº”çš„ ] çš„ä¸‹ä¸€æ¡æŒ‡ä»¤æ„å‘³ç€è·³è¿‡å¾ªç¯ã€‚ ]ï¼šå³ä¸­æ‹¬å·æŒ‡ä»¤çš„é€»è¾‘æ˜¯ pc = (the position of the corresponding \u0026quot;[\u0026quot;) é‡åˆ°å³ä¸­æ‹¬å·ï¼Œæ— æ¡ä»¶è·³è½¬åˆ°å¯¹åº”çš„å·¦ä¸­æ‹¬å·ï¼Œå¼€å§‹æ–°ä¸€è½®å¾ªç¯æ¡ä»¶åˆ¤æ–­ã€‚ æ³¨æ„åˆ° [ å’Œ ] çš„å¤„ç†éƒ½ä¾èµ–ä¸ä¹‹åŒ¹é…çš„â€œå¦ä¸€åŠâ€ï¼Œå› æ­¤åœ¨æ­£å¼å¼€å§‹æ‰§è¡Œç¨‹åºä¹‹å‰ï¼Œæˆ‘ä»¬è¦é¢„å¤„ç†ä¸€éç¨‹åºä»¥çŸ¥é“ä¸æ¯ä¸ª [/] é…å¯¹çš„ ]/[ åœ¨ä»€ä¹ˆä½ç½®ã€‚\næŒ‰ç…§è¿™å››ä¸ªæ­¥éª¤ä¹¦å†™æœ¬é¢˜çš„ä»£ç ï¼Œå¯ä»¥å®Œæˆå¾—è½»æ¾ä¸”é«˜æ•ˆï¼Œä»ä¸­ä½ ä¹Ÿå¯ä»¥é¢†æ‚Ÿåˆ°è®¡ç®—æœºç³»ç»Ÿè®¾è®¡çš„ä¼Ÿå¤§æ™ºæ…§ã€‚\nCode [Click to expand] æ³¨ï¼šä¸‹é¢å‚è€ƒç¨‹åºä»…ä»…å®ç°äº†ä¸€ä¸ª BF è§£é‡Šå™¨ï¼Œè¾“å…¥æ ¼å¼å’Œè¾“å‡ºæ ¼å¼ä¸åŸé¢˜å¹¶ä¸ç›¸åŒã€‚\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int memory[1000], pointer; char program[1000]; int n; int input_count, input[1000]; int jumpto[1000], stk[1000], stot; int main () { scanf(\u0026quot;%s\u0026quot;, program); n = strlen(program); scanf(\u0026quot;%d\u0026quot;, \u0026amp;input_count); for (int i = 1; i \u0026lt;= input_count; i++) scanf(\u0026quot;%d\u0026quot;, input + i); // é¢„å¤„ç†æ¯ä¸ª [ å’Œ ] å¯¹åº”çš„ ]/[ stot = 0; for (int i = 0; i \u0026lt; n; i++) { if (program[i] == '[') stk[++stot] = i; if (program[i] == ']') { jumpto[i] = stk[stot]; jumpto[stk[stot]] = i + 1; stot--; } } pointer = 0; int pc = 0, input_pt = 0; bool printed = false; while (pc \u0026lt; n) { int next_pc = pc + 1; switch (program[pc]) { case '+': memory[pointer]++; break; case '-': memory[pointer]--; break; case '\u0026lt;': pointer--; break; case '\u0026gt;': pointer++; break; case ',': memory[pointer] = input[++input_pt]; break; case '.': printf(\u0026quot;%d \u0026quot;, memory[pointer]); printed = true; break; case '[': if (memory[pointer] == 0) next_pc = jumpto[pc]; break; case ']': next_pc = jumpto[pc]; break; } pc = next_pc; } if (printed) puts(\u0026quot;\u0026quot;); for (int i = 0; i \u0026lt; 10; i++) printf(\u0026quot;%d \u0026quot;, memory[i]); puts(\u0026quot;\u0026quot;); return 0; } Problem C: DXY\u0026rsquo;s Graph Problem\né¢˜æ„æ¦‚æ‹¬ï¼šç»™å®šä¸€å¼ å›¾ $G=(V, E)$ï¼Œå…¶ä¸­ $V$, $E$ åˆ†åˆ«æ˜¯ç‚¹å’Œè¾¹çš„é›†åˆã€‚å¯¹äºå›¾ä¸­ä»»æ„é¡¶ç‚¹ $v\\in V$ï¼Œä»¤ $\\text{cover}(v)\\triangleq \\{(x, y)\\in E: x=v\\vee y=v\\}$ (å³ä¸è¯¥ç‚¹ç›¸é‚»çš„æ‰€æœ‰è¾¹çš„é›†åˆ)ã€‚é—®æ˜¯å¦å­˜åœ¨åŸå›¾é¡¶ç‚¹çš„åˆ’åˆ† $S_1, S_2$ï¼Œæ»¡è¶³ $S_1\\uplus S_2=V$ (å³ $S_1\\cup S_2=V$ ä¸” $S_1\\cap S_2=\\emptyset$)ï¼Œä¸”\n$$ \\bigcup_{v\\in S_1}\\text{cover}(v)=\\bigcup_{v\\in S_2}\\text{cover}(v)=E $$\n(æ³¨ï¼šæœ¬é¢˜å®Œæ•´é¢˜æ„é‡Œä¸­æ–‡æè¿°ä¸­æœ‰å…³â€œDXYå¯ä»¥é€šè¿‡è‡ªå·±çš„ç‚¹é›†å°†åŸå›¾æ¢å¤â€çš„éƒ¨åˆ†ç»™å¤§å®¶å¸¦æ¥äº†è¾ƒå¤§å›°æ‰°ï¼Œå¯¹æ­¤æˆ‘ä»¬æ·±è¡¨æ­‰æ„ã€‚)\næ¯æ¡è¾¹éƒ½æœ‰ä¸¤ä¸ªç«¯ç‚¹ï¼Œè¦æƒ³è¿™æ¡è¾¹è¢«åŒæ–¹éƒ½è¦†ç›–åˆ°ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªç«¯ç‚¹å¿…é¡»åˆ†å±äºä¸åŒçš„é›†åˆã€‚å› æ­¤å¯ä»¥æˆåŠŸåˆ’åˆ†çš„å……è¦æ¡ä»¶æ˜¯ï¼šå­˜åœ¨å°†æ•´å¼ å›¾ä¸Šçš„é¡¶ç‚¹é»‘ç™½æŸ“è‰²ï¼Œä¸”æ¯æ¡è¾¹çš„ä¸¤ä¸ªç«¯ç‚¹ä¸€é»‘ä¸€ç™½çš„æ–¹æ¡ˆã€‚\næˆ‘ä»¬å®¹æ˜“å‘ç°è¿™æ ·çš„æ–¹æ¡ˆå¦‚æœå­˜åœ¨ä¸€å®šæ˜¯å”¯ä¸€çš„ï¼Œå› ä¸ºæˆ‘ä»¬å·²ç»è§„å®šäº† 1 å·ç‚¹å±äº DXYï¼Œæˆ‘ä»¬ä¸å¦¨å°†ç™½è‰²åˆ†é…ç»™ DXYï¼Œé‚£ä¹ˆæ•´ä¸ªè¿‡ç¨‹ç›¸å½“äºä»ä¸€ä¸ªç™½è‰²çš„ 1 å·ç‚¹å¼€å§‹å‘å¤–æœç´¢ï¼Œæ¯æœç´¢åˆ°ä¸€ä¸ªæ–°çš„èŠ‚ç‚¹å°±ç»™å®ƒæ¶‚ä¸Šå’Œé‚»å±…èŠ‚ç‚¹ä¸åŒçš„é¢œè‰²ã€‚ç”±äºæ•´ä¸ªå›¾æ˜¯è¿é€šçš„ (å³ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹éƒ½å­˜åœ¨è·¯å¾„äº’ç›¸å¯è¾¾)ï¼Œæ‰€ä»¥è¿™æ ·çš„æœç´¢ä¸€å®šèƒ½ç»™æ¯ä¸ªèŠ‚ç‚¹ä¸€ä¸ªå”¯ä¸€çš„é¢œè‰² (å¦‚æœä½ æƒ³è¦ä¸¥è°¨åœ°è¯æ˜ï¼Œå¯ä»¥è€ƒè™‘æ•°å­¦å½’çº³æ³•)ã€‚åœ¨æœç´¢çš„è¿‡ç¨‹ä¸­ï¼Œå¦‚æœå‘ç°æ— æ³•è§£å†³çš„çŸ›ç›¾ (ä¾‹å¦‚æŸä¸ªèŠ‚ç‚¹åŒæ—¶å’Œä¸€ä¸ªé»‘ç‚¹å’Œç™½ç‚¹ç›¸é‚»)ï¼Œåˆ™é—®é¢˜æ— è§£ã€‚\nå¦‚æœä½ æ„¿æ„ç»§ç»­æ·±ç©¶è¿™ä¸ªé—®é¢˜ (è¿™éƒ¨åˆ†çŸ¥è¯†å¯¹äºè§£å†³è¿™é“é¢˜å¹¶æ— å¿…è¦)ï¼Œä½ ä¼šå‘ç°å¯ä»¥æˆåŠŸé»‘ç™½æŸ“è‰²å……è¦æ¡ä»¶æ˜¯å›¾ä¸­ä¸å­˜åœ¨å¥‡æ•°é•¿åº¦çš„ç¯ï¼Œè¿™ä¹Ÿæ˜¯åˆ¤æ–­äºŒåˆ†å›¾ (Bipartite Graph) çš„æ–¹æ³•ï¼Œå¤§å®¶åœ¨åç»­çš„é—®é¢˜æ±‚è§£è¯¾ç¨‹ä¸­ä¼šå­¦ä¹ åˆ°è¿™ä¸ªæ¦‚å¿µå’Œç›¸å…³çš„è¯æ˜ã€‚\nCode [Click to expand] #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MAXN = 1e5 + 10; int n, m; vector\u0026lt;int\u0026gt; v[MAXN]; int color[MAXN]; bool flag; void dfs(int cur) { for (auto neighbor : v[cur]) if (color[neighbor] == 0) { color[neighbor] = 3 - color[cur]; // ä¸¤ç§é¢œè‰²ç”¨ 1, 2 è¡¨ç¤º // 3 - color[cur] åˆ™è¡¨ç¤ºâ€œå¦ä¸€ç§é¢œè‰²â€ dfs(neighbor); } else if (color[neighbor] != 3 - color[cur]) flag = false; } int main () { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m); int x, y; for (int i = 1; i \u0026lt;= m; i++) { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;x, \u0026amp;y); v[x].push_back(y); v[y].push_back(x); } color[1] = 1; flag = true; dfs(1); if (flag) { puts(\u0026quot;Yes\u0026quot;); int cnt1 = 0, cnt2 = 0; for (int i = 1; i \u0026lt;= n; i++) if (color[i] == 1) cnt1++; else cnt2++; printf(\u0026quot;%d %d\\n\u0026quot;, cnt1, cnt2); for (int i = 1; i \u0026lt;= n; i++) if (color[i] == 1) printf(\u0026quot;%d \u0026quot;, i); puts(\u0026quot;\u0026quot;); for (int i = 1; i \u0026lt;= n; i++) if (color[i] == 2) printf(\u0026quot;%d \u0026quot;, i); puts(\u0026quot;\u0026quot;); } else puts(\u0026quot;No\u0026quot;); return 0; } ","date":1677974400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1677974400,"objectID":"fd4205e61411699e0ae5cf688465ea65","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/solutions/1-final/","publishdate":"2023-03-05T00:00:00Z","relpermalink":"/courses/problemsolving22/solutions/1-final/","section":"courses","summary":"Problem A: BrainF**k Syntax Checker\né¢˜æ„æ¦‚æ‹¬ï¼šç»™å®šä¸€ä¸ª BF ç¨‹åºï¼Œåˆ¤æ–­å®ƒæ˜¯å¦ç¬¦åˆè¯­æ³•è¦æ±‚ã€‚\nBF ç¨‹åºä¸­çš„ + - , . \u0026gt; \u0026lt; æ˜¾ç„¶ä¸ä¼šå¯¹ç¨‹åºçš„åˆæ³•æ€§é€ æˆå½±å“ï¼Œå› æ­¤æœ¬é¢˜çš„ä¸»è¦ä»»åŠ¡æ˜¯åˆ¤æ–­ BF ç¨‹åºä¸­çš„ [ ] æ˜¯å¦å½¢æˆäº†åˆæ³•çš„æ‹¬å·åºåˆ—ï¼Œå³ä¸¤ä¸¤åŒ¹é…ã€‚\nå€¼å¾—æ³¨æ„çš„æ˜¯ï¼ŒBF ç¨‹åºä¸­ [ å’Œ ] çš„ä¸ªæ•°ç›¸åŒå¹¶ä¸æ˜¯æ‹¬å·åºåˆ—åˆæ³•çš„å……è¦æ¡ä»¶ï¼Œæ¯”å¦‚ ][ è¿™ä¸ªåºåˆ—å°±æ˜¯ä¸åˆæ³•çš„ã€‚åœ¨æ­¤åŸºç¡€ä¸Šï¼Œæˆ‘ä»¬è¿˜è¦ä¿è¯ BF ç¨‹åºçš„ä»»æ„å‰ç¼€ä¸­ï¼Œ[ çš„ä¸ªæ•°è¦å¤§äºç­‰äº ] çš„ä¸ªæ•°ã€‚","tags":null,"title":"é—®é¢˜æ±‚è§£ I-Final é¢˜è§£","type":"docs"},{"authors":null,"categories":null,"content":" é¢˜æ„æ¦‚è¿°\nç»™å®š $n$ ä¸ªæ•°å¯¹ï¼Œä¿è¯ $1\\cdots n$ ä¸­çš„æ¯ä¸ªæ•°æ°å¥½å‡ºç°ä¸¤æ¬¡ã€‚æ¯æ¬¡æ“ä½œå¯ä»¥ä»»æ„äº¤æ¢ä¸¤ä¸ªæ•°çš„ä½ç½®ã€‚é—®è‡³å°‘å¤šå°‘æ¬¡äº¤æ¢å¯ä»¥ä½¿å¾—æ¯å¯¹æ•°éƒ½ç›¸åŒã€‚\nçº¦æŸæ¡ä»¶ï¼š$n\\leq 10^6$ã€‚\nè¿™é“é¢˜é¢‡æœ‰æ€ç»´éš¾åº¦ï¼Œéœ€è¦ä»”ç»†è§‚å¯Ÿå¹¶å‘ç°é—®é¢˜çš„æ€§è´¨ã€‚å‘ç°é—®é¢˜çš„æ€§è´¨ä¸èƒ½é åŒçœ¼çªç€å±å¹•â€”â€”åŠ¨èµ·æ‰‹æ¥ï¼Œç”»å‡ ä¸ªæ ·ä¾‹æ‰‹ç®—å‡ºè§£æ³•ï¼Œå¾ˆå¤šæ—¶å€™è§£å†³é—®é¢˜çš„çµæ„Ÿå°±æ˜¯ä»æ‰‹ç®—å¾—å‡ºçš„ã€‚\næˆ‘ä»¬é¦–å…ˆå¯ä»¥ç¡®å®šä¸€ä»¶äº‹ï¼šç­”æ¡ˆçš„ä¸Šé™æ˜¯ $n-1$ï¼Œå› ä¸ºæ¯è½®æ“ä½œä½ æ€»å¯ä»¥è®©æŸä¸€ä¸ªæ•°å¯¹åŒ¹é…èµ·æ¥ã€‚å¦‚æœä½ æ‰‹ç®—å°è¯•äº†ä¸€äº›æ ·ä¾‹ï¼Œä½ ä¸€å®šä¼šå‘ç°æƒ³è¦è®©äº¤æ¢æ¬¡æ•°æœ€å°‘ï¼Œæˆ‘ä»¬ä¼šæ ¼å¤–å–œæ¬¢è¿™æ ·çš„æ•°å¯¹ï¼š\n1 2 2 1 å› ä¸ºæˆ‘ä»¬åªè¦è®©ä¸Šé¢çš„ 2 å’Œä¸‹é¢çš„ 1 äº¤æ¢ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä¸€ä¸‹å­å¾—åˆ°ä¸¤ä¸ªåŒ¹é…çš„æ•°å¯¹ï¼Œè¿™çœ‹èµ·æ¥éå¸¸èµšã€‚ä½†ä¸æ˜¯ä»€ä¹ˆæ—¶å€™éƒ½èƒ½æœ‰â€œåŠ¨ä¸€æ¬¡æˆä¸¤å¯¹â€è¿™ä¹ˆèµšçš„äº‹æƒ…ï¼Œä½ å¾ˆå¿«ä¼šå‘ç°æœ‰çš„æ—¶å€™æ ¼å±€å¯èƒ½æ˜¯è¿™æ ·çš„ï¼š\n1 2 2 3 3 5 5 8 8 1 é€šè¿‡è§‚å¯Ÿä½ å¯ä»¥å‘ç°ï¼šè¿™æ ·çš„ 5 ä¸ªæ•°å¯¹ä½ åªè¦å°†å‰ 4 ä¸ªæå®šï¼Œæœ€åä¸€ä¸ªä¹Ÿä¼šéšä¹‹æå®šï¼Œä¸”ä½ æ— æ³•ç»™å‡ºæ¯” 4 æ¬¡äº¤æ¢æ›´å¥½çš„æ–¹æ¡ˆã€‚\nä½ æ˜¯å¦è§‰å¾—ä¸Šé¢çš„ 5 ä¸ªæ•°å¯¹åƒæ˜¯ 1, 2, 3, 5, 8 äº”ä¸ªæ•°æ„æˆçš„ç¯ï¼Ÿäº‹å®ä¸Šï¼Œç¨åŠ æ€ç´¢ä½ ä¾¿èƒ½å‘ç° $n$ ä¸ªæ•°å¯¹å…¶å®å°±æ˜¯ç”±è¿™æ ·çš„è‹¥å¹²ä¸ªäº’ä¸å½±å“çš„â€œç¯â€ç»„æˆçš„ã€‚æ¯ä¸ªç¯å½¢å¦‚\na1 a2 a2 a3 ... an-1 an an a1 è¿™æ ·ä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„ç¯ï¼Œæˆ‘ä»¬éœ€è¦ $n-1$ æ¬¡æ“ä½œå°†å…¶å…¨éƒ¨æå®šï¼Œæ¯æœ‰ä¸€ä¸ªâ€œç¯â€ï¼Œæˆ‘ä»¬å°±å¯ä»¥â€œèŠ‚çœâ€ä¸€æ¬¡æ“ä½œã€‚å› æ­¤ï¼Œè®¾ $n$ ä¸ªæ•°å¯¹å…±ç”± $m$ ä¸ªç¯æ„æˆï¼Œé‚£ä¹ˆæœ€å°çš„æ“ä½œæ¬¡æ•°å°±æ˜¯ $n-m$ã€‚\nåˆ¤æ–­ç¯çš„ä¸ªæ•°ç›¸å¯¹ç®€å•ï¼Œä½ å¹¶ä¸ä¸€å®šéœ€è¦ä½¿ç”¨â€œå¹¶æŸ¥é›†â€è¿™æ ·é«˜çº§çš„æ•°æ®ç»“æ„â€”â€”äº‹å®ä¸Šæœç´¢å·²ç»è¶³å¤Ÿå®Œæˆä»»åŠ¡äº†ï¼Œè¿™éƒ¨åˆ†çš„ç»†èŠ‚ç•™ç»™å¤§å®¶è‡ªè¡Œæ€è€ƒã€‚\n","date":1670976000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1670976000,"objectID":"2dae7db6a3d6f936cf02badc20b06f8b","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/solutions/1-6-c/","publishdate":"2022-12-14T00:00:00Z","relpermalink":"/courses/problemsolving22/solutions/1-6-c/","section":"courses","summary":"é¢˜æ„æ¦‚è¿°\nç»™å®š $n$ ä¸ªæ•°å¯¹ï¼Œä¿è¯ $1\\cdots n$ ä¸­çš„æ¯ä¸ªæ•°æ°å¥½å‡ºç°ä¸¤æ¬¡ã€‚æ¯æ¬¡æ“ä½œå¯ä»¥ä»»æ„äº¤æ¢ä¸¤ä¸ªæ•°çš„ä½ç½®ã€‚é—®è‡³å°‘å¤šå°‘æ¬¡äº¤æ¢å¯ä»¥ä½¿å¾—æ¯å¯¹æ•°éƒ½ç›¸åŒã€‚\nçº¦æŸæ¡ä»¶ï¼š$n\\leq 10^6$ã€‚\nè¿™é“é¢˜é¢‡æœ‰æ€ç»´éš¾åº¦ï¼Œéœ€è¦ä»”ç»†è§‚å¯Ÿå¹¶å‘ç°é—®é¢˜çš„æ€§è´¨ã€‚å‘ç°é—®é¢˜çš„æ€§è´¨ä¸èƒ½é åŒçœ¼çªç€å±å¹•â€”â€”åŠ¨èµ·æ‰‹æ¥ï¼Œç”»å‡ ä¸ªæ ·ä¾‹æ‰‹ç®—å‡ºè§£æ³•ï¼Œå¾ˆå¤šæ—¶å€™è§£å†³é—®é¢˜çš„çµæ„Ÿå°±æ˜¯ä»æ‰‹ç®—å¾—å‡ºçš„ã€‚\næˆ‘ä»¬é¦–å…ˆå¯ä»¥ç¡®å®šä¸€ä»¶äº‹ï¼šç­”æ¡ˆçš„ä¸Šé™æ˜¯ $n-1$ï¼Œå› ä¸ºæ¯è½®æ“ä½œä½ æ€»å¯ä»¥è®©æŸä¸€ä¸ªæ•°å¯¹åŒ¹é…èµ·æ¥ã€‚å¦‚æœä½ æ‰‹ç®—å°è¯•äº†ä¸€äº›æ ·ä¾‹ï¼Œä½ ä¸€å®šä¼šå‘ç°æƒ³è¦è®©äº¤æ¢æ¬¡æ•°æœ€å°‘ï¼Œæˆ‘ä»¬ä¼šæ ¼å¤–å–œæ¬¢è¿™æ ·çš„æ•°å¯¹ï¼š\n1 2 2 1 å› ä¸ºæˆ‘ä»¬åªè¦è®©ä¸Šé¢çš„ 2 å’Œä¸‹é¢çš„ 1 äº¤æ¢ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä¸€ä¸‹å­å¾—åˆ°ä¸¤ä¸ªåŒ¹é…çš„æ•°å¯¹ï¼Œè¿™çœ‹èµ·æ¥éå¸¸èµšã€‚ä½†ä¸æ˜¯ä»€ä¹ˆæ—¶å€™éƒ½èƒ½æœ‰â€œåŠ¨ä¸€æ¬¡æˆä¸¤å¯¹â€è¿™ä¹ˆèµšçš„äº‹æƒ…ï¼Œä½ å¾ˆå¿«ä¼šå‘ç°æœ‰çš„æ—¶å€™æ ¼å±€å¯èƒ½æ˜¯è¿™æ ·çš„ï¼š\n1 2 2 3 3 5 5 8 8 1 é€šè¿‡è§‚å¯Ÿä½ å¯ä»¥å‘ç°ï¼šè¿™æ ·çš„ 5 ä¸ªæ•°å¯¹ä½ åªè¦å°†å‰ 4 ä¸ªæå®šï¼Œæœ€åä¸€ä¸ªä¹Ÿä¼šéšä¹‹æå®šï¼Œä¸”ä½ æ— æ³•ç»™å‡ºæ¯” 4 æ¬¡äº¤æ¢æ›´å¥½çš„æ–¹æ¡ˆã€‚","tags":null,"title":"ã€é—®é¢˜æ±‚è§£I-HW6.Cã€‘ä¸‡åœ£èŠ‚çš„æ–°å¨˜","type":"docs"},{"authors":[],"categories":[],"content":"TF/Pytorch with Sanitizers PyTorch Summary 1085 APIs are tested. ASan+UBSan / Compute Sanitizer Two kinds of false positives are filtered: Invalid argument error Out-of-memory allocations Results #APIs #Bugs ASan 7 5 UBSan 19 8 CSan 2+ 2+ ASan: heap-buffer-overflow heap use-after-free SEGV on unknown address UBSan: signed integer overflow non-zero offset to null pointer negative shift exponent CSan: Warp assertion CudaInvalidConfiguration TensorFlow Results #APIs #Bugs CSan 2+ 2+ Out-of-bound reads ","date":1667433600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1667433600,"objectID":"5179f8af69f584c405c5a138d255acb1","permalink":"https://kristoff-starling.github.io/slides/20221104/","publishdate":"2022-11-03T00:00:00Z","relpermalink":"/slides/20221104/","section":"slides","summary":"TF/Pytorch with Sanitizers PyTorch Summary 1085 APIs are tested. ASan+UBSan / Compute Sanitizer Two kinds of false positives are filtered: Invalid argument error Out-of-memory allocations Results #APIs #Bugs ASan 7 5 UBSan 19 8 CSan 2+ 2+ ASan: heap-buffer-overflow heap use-after-free SEGV on unknown address UBSan: signed integer overflow non-zero offset to null pointer negative shift exponent CSan: Warp assertion CudaInvalidConfiguration TensorFlow Results #APIs #Bugs CSan 2+ 2+ Out-of-bound reads ","tags":[],"title":"Slides","type":"slides"},{"authors":null,"categories":null,"content":"ä¹‹å‰ç« èŠ‚ä»‹ç»çš„åˆ†æ”¯ã€å¾ªç¯ã€å‡½æ•°ã€é€’å½’â€¦â€¦ç­‰æ¦‚å¿µéƒ½æ˜¯å‘½ä»¤å¼ç¼–ç¨‹è¯­è¨€é€šç”¨çš„æ€æƒ³æ–¹æ³•ã€‚æ—¶å¸¸æœ‰åŒå­¦é—®ï¼šæˆ‘ä»¬åˆ°åº•å­¦çš„æ˜¯ C è¿˜æ˜¯ C++ï¼Ÿå¯ä»¥è¯´ä¹‹å‰å¤§å®¶å†™çš„ç¨‹åºåŸºæœ¬éƒ½æ˜¯ C é£æ ¼çš„ (é™¤äº† cin cout string ç­‰å°‘æ•°å†…å®¹ï¼‰ã€‚è¿™ä¸€ç« ä»‹ç»çš„æ ‡å‡†æ¨¡æ¿åº“ (Standard Template Library, STL)ï¼Œæ˜¯ C++ åŒºåˆ«äº C çš„é‡è¦å†…å®¹ä¹‹ä¸€ã€‚STL æä¾›çš„å†…å®¹å°†ç¨‹åºå‘˜ä»å¤æ‚çš„åº•å±‚ç®—æ³•å’Œæ•°æ®ç»“æ„ä¸­è§£æ”¾å‡ºæ¥ï¼Œä½¿å¾—ç¨‹åºå‘˜å†™ç¨‹åºæ›´åŠ å¾—å¿ƒåº”æ‰‹ã€‚\næ ‡å‡†æ¨¡æ¿åº“ç”±å››ä¸ªéƒ¨åˆ†æ„æˆï¼š\nç®—æ³• (Algorithm) å®¹å™¨ (Container) å‡½æ•° (Function) è¿­ä»£å™¨ (Iterator) è¿™ä¸€ç« ä¸»è¦è®²è§£å®¹å™¨ã€‚\nå¤§å®¶æœ€è¿‘å­¦ä¹ äº†â€œæŠ½è±¡æ•°æ®ç»“æ„â€œï¼ŒSTLçš„å®¹å™¨å¯ä»¥ç†è§£ä¸ºC++åº“ä¸ºå¤§å®¶å®ç°å¥½äº†ä¸€æ‰¹æ•°æ®ç»“æ„ï¼Œä½ åªè¦è¯»æ‡‚è¿™äº›å®¹å™¨å¯¹å¤–æš´éœ²çš„æ¥å£çš„åŠŸèƒ½è¯´æ˜ï¼Œåˆç†åœ°ä½¿ç”¨è¿™äº›æ¥å£ï¼Œå°±å¯ä»¥åœ¨ä¸çŸ¥é“åº•å±‚å®ç°çš„æƒ…å†µä¸‹äº«å—è¿™äº›æ•°æ®ç»“æ„çš„ç¦åˆ©ã€‚æˆ‘ä»¬åœ¨è¿™é‡Œä»‹ç»å‡ ä¸ªæœ€å¸¸ç”¨çš„STLå®¹å™¨å’Œç›¸å…³æ“ä½œã€‚\næ³¨ï¼šSTLå®¹å™¨çš„ç”¨æ³•æå…¶ä¸°å¯Œï¼Œè¿™é‡Œåªæ˜¯æµ®å…‰æ å½±ç®€å•ä»‹ç»ï¼Œå¤§å®¶å¯ä»¥åœ¨ cppreference ä¸ŠæŸ¥è¯¢è¯¦ç»†çš„æ–¹æ³•åˆ—è¡¨ã€‚\nvector vector çš„ä¸­æ–‡åæ˜¯å‘é‡ï¼Œä½†è¿™ä¸ªå®¹å™¨å’Œæ•°å­¦ä¸­çš„å‘é‡å‡ ä¹æ¯«æ— å…³ç³»ï¼Œvector å…¶å®æ›´åƒä¸€ä¸ªå¯ä»¥è‡ªç”±å˜æ¢é•¿åº¦ï¼Œå®Œæˆä¸€ç³»åˆ—æ“ä½œçš„â€œåŠ¨æ€æ•°ç»„â€ã€‚å½“ä½ ä¸èƒ½ç¡®å®šæ•°ç»„é•¿åº¦ï¼Œæˆ–è€…éœ€è¦åœ¨ä»»æ„ä½ç½®æ’å…¥/åˆ é™¤å…ƒç´ æ—¶ï¼Œvector å°†ä¼šæˆä¸ºä½ çš„ä¸€å¤§åŠ©åŠ›ã€‚ä¸‹é¢æˆ‘ä»¬é€šè¿‡ä¾‹å­å±•ç¤º vector çš„å¸¸è§ä½¿ç”¨æ–¹æ³•ï¼š\nåˆå§‹åŒ–\n// é€šç”¨æ ¼å¼ï¼š vector\u0026lt;ç±»å‹\u0026gt; åå­—(æœ€å¤§å®¹é‡ï¼Œåˆå§‹å€¼) #include \u0026lt;vector\u0026gt; // å¤§å®¶å¸¸ç”¨çš„ \u0026lt;bits/stdc++.h\u0026gt; å·²ç»åŒ…æ‹¬äº†è¯¥å¤´æ–‡ä»¶ int main () { vector\u0026lt;double\u0026gt; v_double(0); // ä¸€ä¸ªç©ºçš„ï¼Œå­˜å‚¨çš„å˜é‡ä¸º double ç±»å‹çš„ vector vector\u0026lt;int\u0026gt; v_int(10, 0); // ä¸€ä¸ªé•¿åº¦ä¸º 10 çš„ vectorï¼Œåˆå§‹æ‰€æœ‰å…ƒç´ ä¸º 0 } å…ƒç´ è®¿é—®\n// vector å’Œæ•°ç»„ä¸€æ ·æ”¯æŒç”¨ä¸‹æ ‡è®¿é—®ï¼Œä¸‹æ ‡ä» 0 å¼€å§‹ vector\u0026lt;int\u0026gt; v_int(10, 1); cout \u0026lt;\u0026lt; v_int[2]; // è¾“å‡ºï¼š 0 cout \u0026lt;\u0026lt; v_int[10]; // ä¸‹æ ‡è¶Šç•Œï¼Œæœªå®šä¹‰è¡Œä¸ºï¼ è¿­ä»£å™¨\nè™½ç„¶è¿­ä»£å™¨çš„æ¦‚å¿µæœ‰ç‚¹å¤æ‚ï¼Œä½†ä¸ºäº†æ›´å¥½åœ°ä½¿ç”¨å®¹å™¨ï¼Œæˆ‘ä»¬è¿˜æ˜¯ç®€å•åœ°ä»‹ç»ä¸€ä¸‹ã€‚è¿­ä»£å™¨å¯ä»¥ç†è§£ä¸ºæŒ‡å‘å®¹å™¨ä¸­æŸä¸ªå…ƒç´ çš„â€œæŒ‡é’ˆâ€ï¼Œå¦‚æœä½ ä¸çŸ¥é“ä»€ä¹ˆæ˜¯æŒ‡é’ˆï¼Œä½ å¯ä»¥æŠŠå®ƒæƒ³è±¡æˆä¸€ä¸ªâ€œå°ç®­å¤´â€ã€‚\nvector ä¸­æœ€å¸¸ç”¨çš„å‡ ä¸ªå’Œè¿­ä»£å™¨ç›¸å…³çš„å‡½æ•°æœ‰ï¼š\nbegin()ï¼šè¿”å›ä¸€ä¸ªæŒ‡å‘ç¬¬ä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨ã€‚ end()ï¼šè¿”å›ä¸€ä¸ªæŒ‡å‘æœ€åä¸€ä¸ªå…ƒç´ çš„â€œä¸‹ä¸€ä¸ªä½ç½®â€çš„è¿­ä»£å™¨ã€‚ rbegin()ï¼šè¿”å›æŒ‡å‘æœ€åä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨ã€‚ è¿­ä»£å™¨å¯ä»¥é€šè¿‡ç®€å•çš„ â€œ+1/-1â€ æ“ä½œå‘å³/å·¦ç§»åŠ¨ã€‚æˆ‘ä»¬é€šè¿‡è¿­ä»£å™¨å¯ä»¥é¡ºåºè®¿é—®æ•°ç»„ä¸­çš„æ‰€æœ‰å…ƒç´ ï¼š\n// å‡è®¾å½“å‰ vector\u0026lt;int\u0026gt; v ä¸­æœ‰ 5 ä¸ªå…ƒç´ ï¼Œåˆ†åˆ«æ˜¯ 1, 2ï¼Œ3, 4, 5 for (vector\u0026lt;int\u0026gt;::iterator iter = v.begin(); iter != v.end(); iter++) cout \u0026lt;\u0026lt; *iter \u0026lt;\u0026lt; ' '; // é€šè¿‡ *iterator çš„æ–¹å¼æ¥è·å–â€å°ç®­å¤´â€œæŒ‡å‘çš„å…ƒç´ çš„å€¼ // è¾“å‡ºç»“æœï¼š 1 2 3 4 5 for (vector\u0026lt;int\u0026gt;::iterator iter = v.rbegin(); iter != v.begin(); iter--) cout \u0026lt;\u0026lt; *iter ** ' '; // è¾“å‡ºç»“æœï¼š 5 4 3 2ï¼Œè¯·ä½“ä¼š end() ä¸ begin() çš„ä¸åŒä¹‹å¤„ï¼ å…ƒç´ çš„æ·»åŠ å’Œåˆ é™¤\nvector\u0026lt;int\u0026gt; v_int(3, 1); // vector å†…å®¹ï¼š[1, 1, 1] // push_back(x) æ–¹æ³•ç”¨äºåœ¨æœ«å°¾æ·»åŠ å…ƒç´  x v_int.push_back(2) // vector å†…å®¹ï¼š[1, 1, 1, 2] v_int.push_back(3) // vector å†…å®¹ï¼š[1, 1, 1, 2, 3] // insert(iter, x) æ–¹æ³•ç”¨äºåœ¨è¿­ä»£å™¨ iter æŒ‡å‘çš„ä½ç½®å‰æ’å…¥å…ƒç´  x v_int.insert(v_int.begin(), 3) // vector å†…å®¹ï¼š[3, 1, 1, 1, 2, 3] // pop_back() æ–¹æ³•ç”¨äºåˆ é™¤æœ€åä¸€ä¸ªå…ƒç´  v_int.pop_back() // vector å†…å®¹ï¼š[3, 1, 1, 1, 2] // erase(iter) æ–¹æ³•ç”¨äºåˆ é™¤è¿­ä»£å™¨ iter æŒ‡å‘çš„å…ƒç´  v_int.erase(v_int.begin() + 1) // vector å†…å®¹ï¼š[3, 1, 1, 2] // æ³¨ï¼šåˆ é™¤äº†ç¬¬äºŒä¸ªå…ƒç´  // clear() å‡½æ•°ç”¨äºæ¸…ç©º vector v_int.clear() // vector å†…å®¹ï¼š[] ç›¸å…³å‚æ•°\n// å‡è®¾å½“å‰ vector\u0026lt;int\u0026gt; v ä¸­æœ‰ 5 ä¸ªå…ƒç´ ï¼Œåˆ†åˆ«æ˜¯ 1, 2ï¼Œ3, 4, 5 cout \u0026lt;\u0026lt; int(v.size()); // è¾“å‡ºï¼š5 bool isEmpty = v.empty() // isEmpty = false stack stack (æ ˆ) æ˜¯ä¸€ä¸ªå…ˆè¿›åå‡ºçš„å®¹å™¨ï¼Œä½ å¯ä»¥æŠŠå®ƒæƒ³è±¡æˆä¸€ä¸ªç”µæ¢¯ï¼šç¬¬ä¸€ä¸ªè¿›å…¥ç”µæ¢¯çš„äººæ€»æ˜¯æœ€åä¸€ä¸ªå‡ºæ¥ã€‚ä¸‹é¢æ˜¯ä¸€äº›ç®€å•çš„ç”¨æ³•ï¼š\nstack\u0026lt;int\u0026gt; s; // åˆå§‹ä¸ºç©º // push(x) æ–¹æ³•å‘æ ˆé¡¶æ”¾å…¥å…ƒç´  x s.push(1); s.push(2); s.push(3); // sçš„å†…å®¹: (åº•) [1, 2, 3] (é¡¶) // top() æ–¹æ³•ç”¨äºè·å–æ ˆé¡¶å…ƒç´  int currentTop = s.top(); // currentTop = 3, s: [1, 2, 3] // pop() æ–¹æ³•ç”¨äºå¼¹å‡ºæ ˆé¡¶å…ƒç´  s.pop(); // s: [1, 2] currentTop = s.top(); // currentTop = 2 // size() æ–¹æ³•ç”¨äºè·å– s ä¸­å…ƒç´ ä¸ªæ•° cout \u0026lt;\u0026lt; int(s.size()); // è¾“å‡ºï¼š2 // empty() æ–¹æ³•ç”¨äºåˆ¤æ–­ s æ˜¯å¦ä¸ºç©º bool isEmpty = s.empty(); // isEmpty = false queue queue (é˜Ÿåˆ—) æ˜¯ä¸€ä¸ªå…ˆè¿›å…ˆå‡ºçš„å®¹å™¨ï¼Œä½ å¯ä»¥æŠŠå®ƒæƒ³è±¡æˆä¸€ä¸ªåŒå¼€é—¨ç”µæ¢¯ï¼šç¬¬ä¸€ä¸ªè¿›å…¥ç”µæ¢¯çš„äººç¬¬ä¸€ä¸ªå‡ºæ¥ã€‚ä¸‹é¢æ˜¯ä¸€äº›ç®€å•çš„ç”¨æ³•ï¼š\nqueue\u0026lt;int\u0026gt; q; // åˆå§‹ä¸ºç©º // push(x) æ–¹æ³•å‘é˜Ÿåˆ—çš„å°¾éƒ¨åŠ å…¥å…ƒç´  x q.push(1); q.push(2); q.push(3); // qçš„å†…å®¹: (é˜Ÿé¦–) [1, 2, 3] (é˜Ÿå°¾) // front() æ–¹æ³•ç”¨äºè·å–é˜Ÿé¦–å…ƒç´  int currentFront = q.front(); // currentFront = 1 // q.pop() æ–¹æ³•ç”¨äºå¼¹å‡ºé˜Ÿé¦–å…ƒç´  q.pop(); // q: [2, 3] currentFront = q.front(); // currentFront = 2 // size() æ–¹æ³•ç”¨äºè·å– q ä¸­å…ƒç´ ä¸ªæ•° int currentSize = int(q.size()); // currentSize = 2 // empty() æ–¹æ³•ç”¨äºåˆ¤æ–­ q æ˜¯å¦ä¸ºç©º bool isEmpty = q.empty(); // isEmpty = false set set (é›†åˆ) é¡¾åæ€ä¹‰å®ç°äº†ä¸€ä¸ªé›†åˆåº”æœ‰çš„åŠŸèƒ½ï¼šæ’å…¥ã€å»é‡ã€åˆ¤æ–­ä¸€ä¸ªå…ƒç´ æ˜¯å¦å­˜åœ¨ã€‚ç‰¹åˆ«çš„æ˜¯ set ä¸­çš„å…ƒç´ è¿˜æ˜¯æŒ‰ç…§é¡ºåºæ’åˆ—çš„ (è¿™å…¶å®å’Œé›†åˆå®šä¹‰ä¸­çš„æ— åºæ€§ç¨æœ‰ä¸ç¬¦)ã€‚ä¸‹é¢æ˜¯ä¸€äº›ç®€å•çš„ç”¨æ³•ï¼š\nset\u0026lt;int\u0026gt; s; // s: {} // insert(x) æ–¹æ³•å‘é›†åˆæ’å…¥å…ƒç´  x s.insert(2); // s: {2} s.insert(1); // s: {1, 2} s.insert(1); // s: {1, 2}ï¼Œé‡å¤å…ƒç´ ä¸ä¼šè¢«åå¤æ’å…¥ s.insert(3); // s: {1, 2, 3} // find(x) æ–¹æ³•æŸ¥è¯¢ x æ˜¯å¦åœ¨é›†åˆä¸­ï¼Œå¦‚æœåœ¨åˆ™è¿”å›æŒ‡å‘è¯¥å…ƒç´ çš„è¿­ä»£å™¨ï¼Œå¦åˆ™è¿”å› s.end() set\u0026lt;int\u0026gt;::iterator iter_1 = s.find(1); cout \u0026lt;\u0026lt; *iter; // è¾“å‡ºï¼š1 set\u0026lt;int\u0026gt;::iterator iter_0 = s.find(0); bool isEnd = (iter_0 == s.end()); // isEnd = true // erase(x) æ–¹æ³•ç”¨äºåˆ é™¤å…ƒç´  x s.erase(2); // s: {1, 3} // ä½¿ç”¨è¿­ä»£å™¨æŒ‰é¡ºåºè®¿é—® s,ä¼šå‘ç°å…ƒç´ æ˜¯æŒ‰é¡ºåºæ’åˆ—çš„ for (set\u0026lt;int\u0026gt;::iterator iter = s.begin(); iter != s.end(); iter++) cout \u0026lt;\u0026lt; *iter \u0026lt;\u0026lt; ' '; // è¾“å‡ºï¼š1 3 // clear() æ–¹æ³•ç”¨äºæ¸…ç©ºé›†åˆ s.clear(); // s: {} æ˜ å°„ åœ¨æ ‡é¢˜ä¸­ä½¿ç”¨ map è¿™ä¸ªå•è¯ä¼šè¢«è‡ªåŠ¨æ¸²æŸ“æˆåœ°å›¾ã€‚ã€‚ã€‚å› æ­¤ä½¿ç”¨äº†â€œæ˜ å°„â€ä½œä¸ºæ ‡é¢˜\nmap (æ˜ å°„) å’Œæ•°å­¦ä¸­çš„æ˜ å°„ä¸€æ ·ï¼Œç»´æŠ¤äº†ä¸€ä¸ª key-value pair çš„é›†åˆã€‚ä¸‹é¢æ˜¯ä¸€äº›ç®€å•çš„ç”¨æ³•ï¼š\nmap\u0026lt;string, int\u0026gt; m; // è¿™æ˜¯ä¸€ä¸ªä» string åˆ° int çš„æ˜ å°„ // æ˜ å°„çš„æ’å…¥éå¸¸ç®€å•ï¼šç›´æ¥ä½¿ç”¨æ•°ç»„èµ‹å€¼çš„è¯­æ³•æ ¼å¼å³å¯ m[\u0026quot;apple\u0026quot;] = 1; m[\u0026quot;banana\u0026quot;] = 2; // è®¿é—®ä¸€ä¸ª key å¯¹åº”çš„ valueï¼šç›´æ¥ä½¿ç”¨æ•°ç»„è®¿é—®çš„è¯­æ³•æ ¼å¼ cout \u0026lt;\u0026lt; m[\u0026quot;apple\u0026quot;]; // è¾“å‡ºï¼š1 cout \u0026lt;\u0026lt; m[\u0026quot;orange\u0026quot;]; // å¯¹äºä¸å­˜åœ¨çš„ keyï¼Œé€šå¸¸ä¼šè¾“å‡ºé»˜è®¤å€¼ 0 m[\u0026quot;apple\u0026quot;] = 3; cout \u0026lt;\u0026lt; m[\u0026quot;apple\u0026quot;]; // è¾“å‡ºï¼š3 // find(x) æ–¹æ³•ç”¨äºæŸ¥è¯¢æ˜ å°„ä¸­æ˜¯å¦æœ‰ x è¿™ä¸ª keyï¼Œå¦‚æœæœ‰åˆ™è¿”å›æŒ‡å‘è¯¥ pair çš„è¿­ä»£å™¨ï¼Œå¦åˆ™è¿”å› m.end() map\u0026lt;string, int\u0026gt;::iterator iter_pear = m.find(\u0026quot;pear\u0026quot;); bool isEnd = (iter_pear == m.end()) // isEnd = true map\u0026lt;string, int\u0026gt;::iterator iter_banana = m.find(\u0026quot;banana\u0026quot;); // ä½¿ç”¨ .first è·å– keyï¼Œ.second è·å– value cout \u0026lt;\u0026lt; *iter_banana.first \u0026lt;\u0026lt; ' ' \u0026lt;\u0026lt; *iter_banana.second; // è¾“å‡ºï¼š banana 2 ","date":1667260800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1667260800,"objectID":"b184338ae303fed1508b67ac0336ca05","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/c++0/stl-container/","publishdate":"2022-11-01T00:00:00Z","relpermalink":"/courses/problemsolving22/c++0/stl-container/","section":"courses","summary":"ä¹‹å‰ç« èŠ‚ä»‹ç»çš„åˆ†æ”¯ã€å¾ªç¯ã€å‡½æ•°ã€é€’å½’â€¦â€¦ç­‰æ¦‚å¿µéƒ½æ˜¯å‘½ä»¤å¼ç¼–ç¨‹è¯­è¨€é€šç”¨çš„æ€æƒ³æ–¹æ³•ã€‚æ—¶å¸¸æœ‰åŒå­¦é—®ï¼šæˆ‘ä»¬åˆ°åº•å­¦çš„æ˜¯ C è¿˜æ˜¯ C++ï¼Ÿå¯ä»¥è¯´ä¹‹å‰å¤§å®¶å†™çš„ç¨‹åºåŸºæœ¬éƒ½æ˜¯ C é£æ ¼çš„ (é™¤äº† cin cout string ç­‰å°‘æ•°å†…å®¹ï¼‰ã€‚è¿™ä¸€ç« ä»‹ç»çš„æ ‡å‡†æ¨¡æ¿åº“ (Standard Template Library, STL)ï¼Œæ˜¯ C++ åŒºåˆ«äº C çš„é‡è¦å†…å®¹ä¹‹ä¸€ã€‚STL æä¾›çš„å†…å®¹å°†ç¨‹åºå‘˜ä»å¤æ‚çš„åº•å±‚ç®—æ³•å’Œæ•°æ®ç»“æ„ä¸­è§£æ”¾å‡ºæ¥ï¼Œä½¿å¾—ç¨‹åºå‘˜å†™ç¨‹åºæ›´åŠ å¾—å¿ƒåº”æ‰‹ã€‚\næ ‡å‡†æ¨¡æ¿åº“ç”±å››ä¸ªéƒ¨åˆ†æ„æˆï¼š\nç®—æ³• (Algorithm) å®¹å™¨ (Container) å‡½æ•° (Function) è¿­ä»£å™¨ (Iterator) è¿™ä¸€ç« ä¸»è¦è®²è§£å®¹å™¨ã€‚","tags":null,"title":"C++æ ‡å‡†æ¨¡æ¿åº“â€”â€”å®¹å™¨","type":"docs"},{"authors":["Xingyu Du"],"categories":null,"content":"ä¸€.æœ‰é™çŠ¶æ€æœºçš„ä»‹ç» é¦–å…ˆè¯´è¯´è‡ªåŠ¨æœºæ˜¯å¹²ä»€ä¹ˆçš„ã€‚ç”¨ç®€å•çš„è¯æ¥è¯´ï¼Œæœ‰é™çŠ¶æ€æœºæ˜¯ä¸€ä¸ªé»‘ç®±ï¼Œè¾“å…¥æ˜¯ä¸€ä¸ªåˆæ³•çš„å­—ç¬¦ä¸²(éšç€ä½ ä»¬é€æ¸æ·±å…¥çš„å­¦ä¹ ï¼Œè¿™é‡Œçš„â€œå­—ç¬¦ä¸²â€çš„æ¦‚å¿µå°†ä¼šè¢«\u0026quot;Language\u0026quot;æ›¿æ¢)ï¼Œè¾“å‡º\u0026quot;Accept\u0026quot;æˆ–è€…\u0026quot;Reject\u0026quot;ï¼Œæ˜¯ä¸æ˜¯å¾ˆåƒä½ ä»¬çš„OJï¼ˆOJä¹Ÿæ˜¯çŠ¶æ€æœºï¼ç”šè‡³æ”¾å¼€äº†è¯´ï¼Œä¸€åˆ‡ç¨‹åºéƒ½æ˜¯çŠ¶æ€æœºï¼ï¼‰è€Œè¦çŸ¥é“å“ªäº›å­—ç¬¦ä¸²ä¼šè¢«\u0026quot;Accept\u0026quot;ï¼Œå“ªäº›å­—ç¬¦ä¸²ä¼šè¢«\u0026quot;Reject\u0026quot;ï¼Œæˆ‘ä»¬å°±éœ€è¦ç»§ç»­äº†è§£çŠ¶æ€æœºçš„æ¦‚å¿µã€‚\nè‡ªåŠ¨æœºçš„å·¥ä½œåŸç†å’Œåœ°å›¾å¾ˆç±»ä¼¼ã€‚å‡è®¾ä½ åœ¨ä½ ä»™æ—æ ¡åŒºï¼Œç„¶åä½ ä»ä»™æ—æ ¡åŒºåˆ°é¼“æ¥¼æ ¡åŒºï¼ŒæŒ‰é¡ºåºç»è¿‡äº†å¾ˆå¤šåœ°é“ç«™ã€‚æ¯ä¸ªåœ°é“ç«™éƒ½å¯èƒ½æœ‰å¤šæ¡æ¢ä¹˜è·¯çº¿ï¼Œè€Œä½ åœ¨æ‰€æœ‰è¿™äº›åœ°é“ç«™çš„é€‰æ‹©å°±æ„æˆäº†ä¸€ä¸ªåºåˆ—ã€‚\nä¾‹å¦‚ï¼Œä½ çš„é€‰æ‹©åºåˆ—æ˜¯â€œ å—å¤§ä»™æ—æ ¡åŒº-\u0026gt; ç¾Šå±±å…¬å›­-\u0026gt;ä»™æ—ä¸­å¿ƒ -\u0026gt;å­¦åˆ™è·¯ -\u0026gt; ä»™é¹¤é—¨ -\u0026gt; é‡‘é©¬è·¯ -\u0026gt;é©¬ç¾¤ -\u0026gt; é’Ÿçµè¡— -\u0026gt; å­é™µå« -\u0026gt; ä¸‹é©¬åŠ -\u0026gt; è‹œè“¿å›­ -\u0026gt; æ˜æ•…å®« -\u0026gt; è¥¿å®‰é—¨ -\u0026gt;å¤§è¡Œå®« -\u0026gt; æ–°è¡—å£ -\u0026gt; ï¼ˆè½¬1å·çº¿ï¼‰-\u0026gt; ç æ±Ÿè·¯ -\u0026gt; é¼“æ¥¼â€ï¼Œé‚£ä½ æŒ‰é¡ºåºç»è¿‡çš„åœ°é“çº¿è·¯å¯èƒ½æ˜¯â€œ2å·çº¿-\u0026gt;1å·çº¿\u0026quot;ã€‚å¯ä»¥å‘ç°ï¼Œé€šå‹¤çš„é€‰æ‹©åºåˆ—ä¸æ­¢è¿™ä¸€ä¸ªã€‚åŒæ ·è¦å»é¼“æ¥¼æ ¡åŒºï¼Œä½ è¿˜å¯ä»¥ä»é‡‘é©¬è·¯æ¢ä¹˜åˆ°4å·çº¿ï¼Œå†ä»4å·çº¿åˆ°é¼“æ¥¼ç«™ã€‚\nè€Œæˆ‘ä»¬å¦‚æœæ‰¾åˆ°ä¸€ä¸ªé€‰æ‹©åºåˆ—ï¼Œå°±å¯ä»¥åœ¨åœ°å›¾ä¸Šæ¯”åˆ’å‡ºè¿™ä¸ªé€‰æ‹©åºåˆ—èƒ½ä¸èƒ½å»é¼“æ¥¼æ ¡åŒºã€‚æ¯”å¦‚ï¼Œå¦‚æœä¸€ä¸ªé€‰æ‹©åºåˆ—æ˜¯â€œå—å¤§ä»™æ—æ ¡åŒº-\u0026gt; ç¾Šå±±å…¬å›­-\u0026gt;ä»™æ—ä¸­å¿ƒ -\u0026gt;å­¦åˆ™è·¯ -\u0026gt; ä»™é¹¤é—¨ -\u0026gt; é‡‘é©¬è·¯ -\u0026gt;é©¬ç¾¤ -\u0026gt; é’Ÿçµè¡— -\u0026gt; å­é™µå« -\u0026gt; ä¸‹é©¬åŠ -\u0026gt; è‹œè“¿å›­ -\u0026gt; æ˜æ•…å®« -\u0026gt; è¥¿å®‰é—¨ -\u0026gt;å¤§è¡Œå®« -\u0026gt; æ–°è¡—å£ -\u0026gt; ä¸Šæµ·è·¯-\u0026gt;æ±‰ä¸­é—¨ -\u0026gt; è«æ„æ¹– -\u0026gt; äº‘é”¦è·¯â€ï¼Œé‚£ä¹ˆå®ƒå°±ä¸ä¼šå¸¦ä½ å»å­¦æ ¡ï¼Œä½†æ˜¯ä»æ—§å¯èƒ½æ˜¯ä¸€ä¸ªå¯è¢«æ¥å—çš„åºåˆ—ï¼ˆè¿™é‡Œçš„å¯æ¥å—æ˜¯ä»»æ„ä¸¤ä¸ªç›¸é‚»çš„åœ°ç‚¹éƒ½æœ‰åœ°é“èƒ½åªç»è¿‡ä¸€ç«™è€Œåˆ°è¾¾ï¼‰ï¼Œå› ä¸ºç›®æ ‡åœ°ç‚¹å¯èƒ½ä¸æ­¢ä¸€ä¸ªã€‚\nä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬é€šè¿‡è¿™ä¸ªåœ°å›¾å’Œä¸€ç»„ç›®çš„åœ°ï¼Œå°†ä¿¡å·åºåˆ—åˆ†æˆäº†ä¸‰ç±»ï¼Œä¸€ç±»æ˜¯æ— æ³•è¯†åˆ«çš„ä¿¡å·åºåˆ—ï¼ˆä¾‹å¦‚â€œå—å¤§ä»™æ—æ ¡åŒº-\u0026gt; ???â€ï¼‰ï¼Œä¸€ç±»æ˜¯èƒ½å»å­¦æ ¡çš„ä¿¡å·åºåˆ—ï¼Œå¦ä¸€ç±»æ˜¯ä¸èƒ½çš„ä¿¡å·åºåˆ—ã€‚æˆ‘ä»¬å°†æ‰€æœ‰åˆæ³•çš„ä¿¡å·åºåˆ—åˆ†æˆäº†ä¸¤ç±»ï¼Œå®Œæˆäº†ä¸€ä¸ªåˆ¤å®šé—®é¢˜ã€‚\næ—¢ç„¶è‡ªåŠ¨æœºæ˜¯ä¸€ä¸ªæ•°å­¦æ¨¡å‹ï¼Œé‚£ä¹ˆæ˜¾ç„¶ä¸å¯èƒ½æ˜¯ä¸€å¼ åœ°å›¾ã€‚å¯¹åœ°å›¾è¿›è¡ŒæŠ½è±¡ä¹‹åï¼Œå¯ä»¥ç®€åŒ–ä¸ºä¸€ä¸ªæœ‰å‘å›¾ã€‚å› æ­¤ï¼Œè‡ªåŠ¨æœºçš„ç»“æ„å°±æ˜¯ä¸€å¼ æœ‰å‘å›¾ã€‚\nè€Œè‡ªåŠ¨æœºçš„å·¥ä½œæ–¹å¼å’Œæµç¨‹å›¾ç±»ä¼¼ï¼Œä¸åŒçš„æ˜¯ï¼šè‡ªåŠ¨æœºçš„æ¯ä¸€ä¸ªç»“ç‚¹éƒ½æ˜¯ä¸€ä¸ªåˆ¤å®šç»“ç‚¹ï¼›è‡ªåŠ¨æœºçš„ç»“ç‚¹åªæ˜¯ä¸€ä¸ªå•çº¯çš„çŠ¶æ€è€Œéä»»åŠ¡ï¼›è‡ªåŠ¨æœºçš„è¾¹å¯ä»¥æ¥å—å¤šç§å­—ç¬¦ï¼ˆä¸å±€é™äº T æˆ– Fï¼‰ã€‚\nä¾‹å¦‚ï¼Œå®Œæˆâ€œåˆ¤æ–­ä¸€ä¸ªäºŒè¿›åˆ¶æ•°æ˜¯ä¸æ˜¯å¶æ•°â€çš„è‡ªåŠ¨æœºå¦‚ä¸‹ï¼š\nä»èµ·å§‹ç»“ç‚¹å¼€å§‹ï¼Œä»é«˜åˆ°ä½æ¥å—è¿™ä¸ªæ•°çš„äºŒè¿›åˆ¶åºåˆ—ï¼Œç„¶åçœ‹æœ€ç»ˆåœåœ¨å“ªé‡Œã€‚å¦‚æœæœ€ç»ˆåœåœ¨çº¢åœˆç»“ç‚¹ï¼Œåˆ™æ˜¯å¶æ•°ï¼Œå¦åˆ™ä¸æ˜¯ã€‚\nå¦‚æœéœ€è¦åˆ¤å®šä¸€ä¸ªæœ‰é™çš„ä¿¡å·åºåˆ—å’Œå¦å¤–ä¸€ä¸ªä¿¡å·åºåˆ—çš„å…³ç³»ï¼ˆä¾‹å¦‚å¦ä¸€ä¸ªä¿¡å·åºåˆ—æ˜¯ä¸æ˜¯æŸä¸ªä¿¡å·åºåˆ—çš„å­åºåˆ—ï¼‰ï¼Œé‚£ä¹ˆå¸¸ç”¨çš„æ–¹æ³•æ˜¯é’ˆå¯¹é‚£ä¸ªæœ‰é™çš„ä¿¡å·åºåˆ—æ„å»ºä¸€ä¸ªè‡ªåŠ¨æœºã€‚è¿™ä¸ªåœ¨å­¦ä¹  KMP çš„æ—¶å€™ä¼šè®²åˆ°ã€‚ï¼ˆæ—©ç€å‘¢ï¼‰\néœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè‡ªåŠ¨æœºåªæ˜¯ä¸€ä¸ª æ•°å­¦æ¨¡å‹ï¼Œè€Œ ä¸æ˜¯ç®—æ³•ï¼Œä¹Ÿ ä¸æ˜¯æ•°æ®ç»“æ„ã€‚å®ç°åŒä¸€ä¸ªè‡ªåŠ¨æœºçš„æ–¹æ³•æœ‰å¾ˆå¤šç§ï¼Œå¯èƒ½ä¼šæœ‰ä¸ä¸€æ ·çš„æ—¶ç©ºå¤æ‚åº¦ã€‚\näºŒ.æœ‰é™çŠ¶æ€æœºçš„å½¢å¼åŒ–å®šä¹‰ ä¸€ä¸ª ç¡®å®šæœ‰é™çŠ¶æ€è‡ªåŠ¨æœºï¼ˆDFAï¼‰ ç”±ä»¥ä¸‹äº”éƒ¨åˆ†æ„æˆï¼š\nå­—ç¬¦é›†ï¼ˆ$\\Sigma$ï¼‰ï¼Œè¯¥è‡ªåŠ¨æœºåªèƒ½è¾“å…¥è¿™äº›å­—ç¬¦ã€‚ çŠ¶æ€é›†åˆï¼ˆ$Q$ï¼‰ã€‚å¦‚æœæŠŠä¸€ä¸ª DFA çœ‹æˆä¸€å¼ æœ‰å‘å›¾ï¼Œé‚£ä¹ˆ DFA ä¸­çš„çŠ¶æ€å°±ç›¸å½“äºå›¾ä¸Šçš„é¡¶ç‚¹ã€‚ï¼ˆè¿™é‡Œå¤§å®¶æ²¡å­¦è¿‡å›¾è®ºï¼Œä½†è¿™äº›åŸºæœ¬æ¦‚å¿µéœ€è¦å¤§å®¶ä¸»åŠ¨äº†è§£ï¼Œè¿™äº›æ¦‚å¿µç®—æ˜¯å›¾è®ºé‡Œçš„â€œå¸¸è¯†â€äº†) èµ·å§‹çŠ¶æ€ï¼ˆ$start$ï¼‰ï¼Œ$start \\in Q$ï¼Œæ˜¯ä¸€ä¸ªç‰¹æ®Šçš„çŠ¶æ€ã€‚èµ·å§‹çŠ¶æ€ä¸€èˆ¬ç”¨ $s$è¡¨ç¤ºï¼Œä¸ºäº†é¿å…æ··æ·†ï¼Œæœ¬æ–‡ä¸­ä½¿ç”¨$start$ ã€‚ æ¥å—çŠ¶æ€é›†åˆï¼ˆ$F$ï¼‰ï¼Œ$F \\subseteq Q$ï¼Œæ˜¯ä¸€ç»„ç‰¹æ®Šçš„çŠ¶æ€ã€‚ è½¬ç§»å‡½æ•°ï¼ˆ$\\delta$ï¼‰ï¼Œ$\\delta$ æ˜¯ä¸€ä¸ªæ¥å—ä¸¤ä¸ªå‚æ•°è¿”å›ä¸€ä¸ªå€¼çš„å‡½æ•°ï¼Œå…¶ä¸­ç¬¬ä¸€ä¸ªå‚æ•°å’Œè¿”å›å€¼éƒ½æ˜¯ä¸€ä¸ªçŠ¶æ€ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯å­—ç¬¦é›†ä¸­çš„ä¸€ä¸ªå­—ç¬¦ã€‚å¦‚æœæŠŠä¸€ä¸ª DFA çœ‹æˆä¸€å¼ æœ‰å‘å›¾ï¼Œé‚£ä¹ˆ DFA ä¸­çš„è½¬ç§»å‡½æ•°å°±ç›¸å½“äºé¡¶ç‚¹é—´çš„è¾¹ï¼Œè€Œæ¯æ¡è¾¹ä¸Šéƒ½æœ‰ä¸€ä¸ªå­—ç¬¦ã€‚ DFA çš„ä½œç”¨å°±æ˜¯è¯†åˆ«å­—ç¬¦ä¸²ï¼Œä¸€ä¸ªè‡ªåŠ¨æœº$A$ ï¼Œè‹¥å®ƒèƒ½è¯†åˆ«ï¼ˆæ¥å—ï¼‰å­—ç¬¦ä¸²$S$ ï¼Œé‚£ä¹ˆ $A(S)=True$ï¼Œå¦åˆ™$A(S)=False$ ã€‚\nå½“ä¸€ä¸ª DFA è¯»å…¥ä¸€ä¸ªå­—ç¬¦ä¸²æ—¶ï¼Œä»åˆå§‹çŠ¶æ€èµ·æŒ‰ç…§è½¬ç§»å‡½æ•°ä¸€ä¸ªä¸€ä¸ªå­—ç¬¦åœ°è½¬ç§»ã€‚å¦‚æœè¯»å…¥å®Œä¸€ä¸ªå­—ç¬¦ä¸²çš„æ‰€æœ‰å­—ç¬¦åä½äºä¸€ä¸ªæ¥å—çŠ¶æ€ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç§°è¿™ä¸ª DFA æ¥å— è¿™ä¸ªå­—ç¬¦ä¸²ï¼Œåä¹‹æˆ‘ä»¬ç§°è¿™ä¸ª DFA ä¸æ¥å— è¿™ä¸ªå­—ç¬¦ä¸²ã€‚\nå¦‚æœä¸€ä¸ªçŠ¶æ€ $v$æ²¡æœ‰å­—ç¬¦$c$ çš„è½¬ç§»ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä»¤$\\delta(v,c)=null$ ï¼Œè€Œ$null$åªèƒ½è½¬ç§»åˆ°$null$ ï¼Œä¸”$null$ä¸å±äºæ¥å—çŠ¶æ€é›†åˆã€‚æ— æ³•è½¬ç§»åˆ°ä»»ä½•ä¸€ä¸ªæ¥å—çŠ¶æ€çš„çŠ¶æ€éƒ½å¯ä»¥è§†ä½œ $null$ï¼Œæˆ–è€…è¯´ï¼Œ $null$ä»£æŒ‡æ‰€æœ‰æ— æ³•è½¬ç§»åˆ°ä»»ä½•ä¸€ä¸ªæ¥å—çŠ¶æ€çš„çŠ¶æ€ã€‚\nï¼ˆæ³¨:ä¸Šä¸€æ®µè¡¨ç¤ºä¸€æ—¦ä¸å­˜åœ¨å½“å‰çŠ¶æ€çš„æŸä¸ªè½¬ç§»ï¼Œé‚£ä¹ˆçŠ¶æ€æœºä¸€å®šä¼šä¸æ¥å—è¿™ä¸ªå­—ç¬¦ä¸²)\næˆ‘ä»¬æ‰©å±•å®šä¹‰è½¬ç§»å‡½æ•° $\\delta$ï¼Œä»¤å…¶ç¬¬äºŒä¸ªå‚æ•°å¯ä»¥æ¥æ”¶ä¸€ä¸ªå­—ç¬¦ä¸²ï¼š$\\delta(v,s)=\\delta(\\delta(v,s[1]),s[2..|s|])$ï¼Œæ‰©å±•åçš„è½¬ç§»å‡½æ•°å°±å¯ä»¥è¡¨ç¤ºä»ä¸€ä¸ªçŠ¶æ€èµ·æ¥æ”¶ä¸€ä¸ªå­—ç¬¦ä¸²åè½¬ç§»åˆ°çš„çŠ¶æ€ã€‚é‚£ä¹ˆï¼Œ$A(s)=[\\delta(start,s)\\in F]$ã€‚è¿™é‡Œéš¾ä»¥ç†è§£æŠ½è±¡å‡½æ•°çš„è¯ï¼Œå¯ä»¥å½“æˆåœ¨å­—ç¬¦ä¸²ä¸­ä¸€ä¸ªä¸ªè¯»å–å­—ç¬¦ï¼Œç„¶åä¸€æ­¥æ­¥è½¬ç§»å½“å‰çŠ¶æ€ï¼Œæœ€ååœ¨æœ€ç»ˆçŠ¶æ€åˆ¤æ–­æ˜¯å¦ä¸ºæ¥å—çŠ¶æ€\nå¦‚ï¼Œä¸€ä¸ªæ¥å—ä¸”ä»…æ¥å—å­—ç¬¦ä¸² \u0026ldquo;a\u0026rdquo;, \u0026ldquo;ab\u0026rdquo;, \u0026ldquo;aac\u0026rdquo; çš„ DFAï¼š\nNFAæ˜¯åœ¨DFAçš„åŸºç¡€ä¸Šå­˜åœ¨æŸäº›çŠ¶æ€$v$ï¼Œæ»¡è¶³$\\delta(v,\\epsilon)\\neq null$ï¼Œè¿™é‡Œçš„$\\epsilon$è¡¨ç¤ºç©ºå­—ç¬¦ä¸²ï¼Œè¿™å°±å¯¼è‡´NFAå¯èƒ½å¤„äºå¤šç§çŠ¶æ€çš„å åŠ æ€ä¸­ï¼ˆè¿™æ˜¯åé¢å°†NFAè½¬åŒ–æˆDFAçš„å…³é”®ï¼Œå°†å½“å‰çš„å¤šç§çŠ¶æ€å½“æˆä¸€ä¸ªæ–°çŠ¶æ€ï¼è¿™æ ·è®°åŸçŠ¶æ€æ•°ä¸ºkç§ï¼Œæ­¤æ—¶æ€»çŠ¶æ€æ•°å°±ä¼šæœ‰$2^k$ç§ï¼Œä½†æ¯ä¸€æ¬¡çŠ¶æ€è½¬ç§»éƒ½æ˜¯å”¯ä¸€çš„ï¼)ï¼Œä¸€ä¸ªNFAçš„ä¾‹å­å¦‚ä¸‹ï¼Œæˆ‘ä»¬åˆ¤æ–­ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ä»¥\u0026quot;01\u0026quot;ç»“å°¾ï¼Œæ­£åˆ™è¡¨è¾¾å¼è¡¨ç¤ºä¸º\u0026quot;$.*01$\u0026ldquo;çš„NFAå¦‚ä¸‹ (S3ä¸ºæ¥æ”¶èŠ‚ç‚¹)ï¼š\ngraph TD state1((s1)) --\u0026gt;|0| state2((s2)) state2 --\u0026gt;|e/ä»»æ„å­—æ¯|state1 state2 --\u0026gt; |1| state3((s3)) state3 --\u0026gt; |e/ä»»æ„å­—æ¯|state1 ä»¥ä¸Šå†…å®¹èŠ‚é€‰è‡ªOI-Wiki\nä¸‰.æœ‰é™çŠ¶æ€æœºçš„ä»£ç å®ç° 1.DFAä»£ç å®ç° I.éå›¾è®ºå»ºæ¨¡ éå›¾è®ºå»ºæ¨¡DFAï¼Œä¸»è¦è¦ç¡®å®šçŠ¶æ€æœºçš„å„ä¸ªçŠ¶æ€ï¼Œå’ŒçŠ¶æ€ä¹‹é—´çš„è½¬ç§»ï¼Œä»¥ä¸Šæ–‡çš„åªæ¥å—\u0026quot;a\u0026rdquo;,\u0026ldquo;ab\u0026rdquo;,\u0026ldquo;aac\u0026quot;çš„DFAä¸ºä¾‹ï¼Œå¯ä»¥å®ç°ä¸€ä¸ªå‡½æ•°â€œget_nxt_state()\u0026ldquo;å®ç°çŠ¶æ€çš„è½¬ç§»ã€‚ç¼ºç‚¹å¾ˆæ˜æ˜¾ï¼Œæ²¡æœ‰å»ºå›¾çš„è¿‡ç¨‹ï¼Œç”¨ä¸€ä¸ªä¸ªifåˆ¤æ–­ï¼Œä»£ç ä¼šå†—é•¿ä¸å¥½çœ‹\n//å‡½æ•°è¿”å›å€¼ä¸ºtrueè¡¨ç¤ºè½¬ç§»åˆ°ä¸€ä¸ªåˆæ³•çŠ¶æ€ï¼Œå‡½æ•°è¿”å›å€¼ä¸ºfalseè¡¨ç¤ºè½¬ç§»åˆ°ä¸€ä¸ªéæ³•çŠ¶æ€ bool get_nxt_state(char ch,int\u0026amp; state){ switch(state){ case 0:{ if(ch=='a')state=1;//åˆæ³•è¾“å…¥ else return false;//éæ³•è¾“å…¥ return true; } case 1:{ ... } case 2:{ } } } bool dfa(string str){ int status; for(int i=0;i\u0026lt;str.size();i++){ if(get_nxt_status(str[i],state)==false) return false; } return statusåœ¨æ¥å—çŠ¶æ€ä¸­; } II.å›¾è®ºå»ºæ¨¡ å›¾è®ºå»ºæ¨¡DFAï¼ŒåŒä¸Šï¼Œåªæ˜¯åœ¨æ¯ä¸ªçŠ¶æ€å†…éƒ¨é¢„å…ˆå¤„ç†ç¢°åˆ°ä¸åŒå­—ç¬¦åçš„ä¸‹ä¸€ä¸ªçŠ¶æ€ï¼Œä¸€ç§å¯èƒ½çš„å®ç°æ–¹æ¡ˆä¸º\nstruct Node{ int nxt[128];//ä¸å¤ªå¥½çš„ç¼–ç¨‹ä¹ æƒ¯ }Nodes[100000];//ä¸å¤ªå¥½çš„ç¼–ç¨‹ä¹ æƒ¯2ï¼Œå½“ç„¶è¿™æ ·ä¼šè¶…ç©ºé—´ void add(int from,int to,char ch){ Nodes[from].nxt[ch]=to; } bool dfa(string str){ int tNode=0;//0æ˜¯åˆå§‹èŠ‚ç‚¹ //é¢„å…ˆè®¾ç½®å¥½æ¯ä¸ªèŠ‚ç‚¹æ˜¯å¦æ˜¯available; for(int i=0;i\u0026lt;str.size();i++){ tNode=Nodes[tNode].nxt[str[i]]; if(tNode==0x3f3f3f3f)return false; } return tNodeæ˜¯ä¸€ä¸ªæ¥å—çŠ¶æ€; } 2.NFAä»£ç å®ç° I.ä»¥çŸ©é˜µå’Œå‘é‡çš„å½¢å¼å»ºæ¨¡ï¼ˆNFA è½¬æ¢æˆ DFA) NFAå¯èƒ½åœ¨ä¸€æ¬¡çŠ¶æ€è½¬ç§»åï¼Œå¯èƒ½åŒæ—¶æ»¡è¶³å¤šä¸ªçŠ¶æ€ï¼Œè®°NFAçš„æ€»çŠ¶æ€æ•°ä¸ºk,åˆ™å¯ä»¥ç”¨ä¸€ä¸ªé•¿åº¦ä¸ºkçš„åˆ—å‘é‡è¡¨ç¤ºå½“å‰æ‰€å¤„çŠ¶æ€ï¼Œè¯¥åˆ—å‘é‡çš„ç¬¬iä½è¡¨ç¤ºå½“å‰æ˜¯å¦å¯èƒ½å¤„äºç¬¬iç§çŠ¶æ€ï¼ŒåŒæ—¶å¯ä»¥ä½¿ç”¨çŸ©é˜µè¡¨ç¤ºçŠ¶æ€ä¹‹é—´çš„è½¬ç§»ï¼Œè½¬ç§»çŸ©é˜µéœ€è¦æå‰æ„é€ ã€‚\nè¿™ä¸ªæ€è·¯ä¸­çš„åˆ—å‘é‡ç›¸å½“äºæŠŠæ‰€æœ‰çš„çŠ¶æ€å‹ç¼©è¿›ä¸€ä¸ªåˆ—å‘é‡ä¸­ï¼Œæ¯”å¦‚å…±æœ‰4ä¸ªçŠ¶æ€ï¼ŒçŠ¶æ€1å’ŒçŠ¶æ€2å‡æœ‰å¯èƒ½ï¼Œåˆ™åˆ—å‘é‡ä¸º{0,1,1,0}ï¼Œåˆ—å‘é‡å…±æœ‰2^kç§ä¸åŒçš„å¯èƒ½ä»£è¡¨\ntypedef vector\u0026lt;int\u0026gt;arr; typedef vector\u0026lt;arr\u0026gt;matrix; arr operator*(matrix mat,arr vec){ int n=mat.size(); arr ret(n,0); for(int i=0;i\u0026lt;n;i++) for(int j=0;j\u0026lt;n;j++) ret[i]|=mat[i][j]\u0026amp;vec[j]; return ret; }//çŸ©é˜µä¹˜åˆ—å‘é‡ matrix transition_matrix[256];//è½¬ç§»çŸ©é˜µï¼Œå…¶ä¸­ç¬¬iä¸ªè½¬ç§»çŸ©é˜µè¡¨ç¤ºå½“å‰é‡åˆ°çš„å­—ç¬¦ä¸º iæ—¶çš„è½¬ç§»çŸ©é˜µï¼Œå…¶ç¬¬jè¡Œç¬¬kåˆ—è¡¨ç¤ºå¯ä»¥ä»ç¬¬kä¸ªçŠ¶æ€è½¬ç§»åˆ°ç¬¬jä¸ªçŠ¶æ€ int state_count;//æ€»çš„çŠ¶æ€æ•°ï¼Œåˆå§‹çŠ¶æ€ä¸ºçŠ¶æ€0 void dfa_init(string patton){ //TBD ç¡®è®¤çŠ¶æ€æ•° //TBD æ„é€ è½¬ç§»çŸ©é˜µ } bool nfa(string str){ arr vec(state_count,0); vec[0]=1; for(int i=0;i\u0026lt;str.size();i++){ vec=vec*transition_matrix[str[i]]; } //æœ€åç»“æœéå†æ‰€æœ‰vecä¸­ä¸ºtrueçš„ä½ï¼Œåˆ¤æ–­å®ƒæ˜¯å¦æ˜¯æ¥å—çŠ¶æ€ return vec[state_count-1]; } II.ä»¥å›¾è®ºå»ºæ¨¡ï¼Œç”¨DFSæœç´¢ ç”¨DFSå»å°è¯•æ‰€æœ‰çš„åŒ¹é…å¯èƒ½ï¼Œå¦‚æœåœ¨DFSè¿‡ç¨‹ä¸­å®Œæˆå­—ç¬¦ä¸²åŒ¹é…åå¤„äºæ¥å—çŠ¶æ€ï¼Œåˆ™æ¥å—è¿™ä¸ªå­—ç¬¦ä¸²ï¼Œå¦åˆ™ä¸æ¥å—\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;graph[10000];//ä¸å¥½çš„ç¼–ç¨‹é£æ ¼ //graph[i][j][k]è¡¨ç¤ºå½“å‰çŠ¶æ€ä¸ºiï¼Œè¯»å…¥çš„å­—ç¬¦ä¸ºjï¼Œèƒ½åˆ°è¾¾çš„ç¬¬kä¸ªçŠ¶æ€çš„çŠ¶æ€å· void add(int from,int to, char ch){ graph[from][ch].push_back(to); } bool nfa_dfs(int status,string str,int pl){ if(pl==patton.size())return statusä¸ºæ¥å—çŠ¶æ€; if(graph[status][str[pl]].size()==0)return false; bool flag=false; for(int i=0;i\u0026lt;graph[status][str[pl]].size();i++){ flag|=nfa_dfs(graph[status][str[pl]][i],str,pl+1); if(flag)return true;//å‰ªæ } return false; } bool nfa(string str){ return nfa_dfs(0,str,0); } å››.ä»¥å®é™…åº”ç”¨ä¸ºä¾‹ï¼Œè¿›è¡Œæ¨¡å‹æ„å»ºå’Œä»£ç å®ç° 1.ä»¥åŒ¹é…åˆæ³•é‚®ä»¶åœ°å€ä¸ºä¾‹ ä¸ºäº†æ–¹ä¾¿è¡¨ç¤ºï¼Œæˆ‘ä»¬ä¸è€ƒè™‘åˆ¤æ–­åˆæ³•åŸŸåï¼Œä»¥åŠåˆæ³•é‚®ä»¶åœ°å€ï¼Œæˆ‘ä»¬ç»™å‡ºé‚®ä»¶åœ°å€çš„BNFèŒƒå¼\nemail address::=\\\u0026lt;string '@' domain\u0026gt; string::=\\\u0026lt;word|digit\u0026gt;{word|digit} domain::=\\\u0026lt;string '.' string\u0026gt; wordå’Œdigitåˆ†åˆ«è¡¨ç¤ºå•è¯å’Œæ•°å­—ï¼Œå®šä¹‰ä¸ç»™å‡º\nä¾‹å­åˆ†æ: æˆ‘ä»¬é¦–å…ˆç¡®å®šçŠ¶æ€çš„ä¸ªæ•°\nåˆå§‹çŠ¶æ€ ä½äºç¬¬ä¸€ä¸ªstringçš„çŠ¶æ€ ä½äº\u0026rsquo;@\u0026lsquo;çš„çŠ¶æ€ ä½äºç¬¬äºŒä¸ªstringçš„çŠ¶æ€ ä½äº\u0026rsquo;.\u0026lsquo;çš„çŠ¶æ€ ä½äºç¬¬ä¸‰ä¸ªstringçš„çŠ¶æ€ æˆ‘ä»¬æ³¨æ„åˆ°ï¼Œå¯¹äºæœ¬é¢˜ï¼Œåˆæ³•çš„é‚®ä»¶åœ°å€è¦æ±‚ä¸‹ï¼Œåªæœ‰çŠ¶æ€6æ‰æ˜¯æ¥å—çŠ¶æ€\næ¥ä¸‹æ¥åˆ†æçŠ¶æ€è½¬ç§»\nå¯¹äºçŠ¶æ€1,å½“æ¥æ”¶åˆ°æ•°å­—æˆ–å­—æ¯æ—¶,ä¼šè½¬ç§»åˆ°çŠ¶æ€2,å…¶ä»–æƒ…å†µå‡ä¸åˆæ³•\nå¯¹äºçŠ¶æ€2,å½“æ¥æ”¶åˆ°æ•°å­—æˆ–å­—æ¯æ—¶,ä¿æŒå½“å‰çŠ¶æ€,æ¥æ”¶åˆ°\u0026rsquo;@\u0026lsquo;æ—¶,è½¬ç§»åˆ°çŠ¶æ€3,å…¶ä»–æƒ…å†µå‡ä¸åˆæ³•\nå¯¹äºçŠ¶æ€3,å½“æ¥æ”¶åˆ°æ•°å­—æˆ–å­—æ¯æ—¶,ä¼šè½¬ç§»åˆ°çŠ¶æ€4,å…¶ä»–æƒ…å†µå‡ä¸åˆæ³•\nå¯¹äºçŠ¶æ€4,å½“æ¥æ”¶åˆ°æ•°å­—æˆ–å­—æ¯æ—¶,ä¿æŒå½“å‰çŠ¶æ€,æ¥æ”¶åˆ°\u0026rsquo;.\u0026lsquo;æ—¶,è½¬ç§»åˆ°çŠ¶æ€5,å…¶ä»–æƒ…å†µå‡ä¸åˆæ³•\nå¯¹äºçŠ¶æ€5,å½“æ¥æ”¶åˆ°æ•°å­—æˆ–å­—æ¯æ—¶,ä¼šè½¬ç§»åˆ°çŠ¶æ€6,å…¶ä»–æƒ…å†µå‡ä¸åˆæ³•\nå¯¹äºçŠ¶æ€6,å½“æ¥æ”¶åˆ°æ•°å­—æˆ–å­—æ¯æ—¶,ä¿æŒå½“å‰çŠ¶æ€,å…¶ä»–æƒ…å†µå‡ä¸åˆæ³•\nä»£ç å®ç°ï¼š æ¥ä¸‹æ¥æœ‰ä¸¤ç§ä»£ç å®ç°æ–¹å¼ï¼Œå¤´æ–‡ä»¶åœ¨æ­¤å‡å¿½ç•¥ä¸è®¡\n//æ–¹æ¡ˆ1ï¼ŒçŠ¶æ€è½¬ç§» bool isdigit(char ch){ return '0'\u0026lt;=ch\u0026amp;\u0026amp;ch\u0026lt;='9'; } bool isletter(char ch){ return ('a'\u0026lt;=ch\u0026amp;\u0026amp;ch\u0026lt;='z')||('A'\u0026lt;=ch\u0026amp;\u0026amp;ch\u0026lt;='Z'); //æ³¨æ„ä¸è¦å†™æˆ 'a'\u0026lt;=ch\u0026lt;='z'è¿™æ ·çš„æƒ…å†µï¼Œå¦åˆ™ç›¸å½“äº('a'\u0026lt;=ch)\u0026lt;='z' } //æ­¤å‡½æ•°æ˜¯è¡¨ç¤ºç»™å‡ºå½“å‰çŠ¶æ€å’Œå½“å‰è¯»å…¥çš„å­—ç¬¦ï¼Œåˆ¤æ–­æ˜¯å¦å­˜åœ¨åˆæ³•è½¬ç§»ï¼Œä»¥åŠå¦‚æœåˆæ³•ï¼Œè·³è½¬åˆ°ä¸‹ä¸€ä¸ªçŠ¶æ€ //å¯¹äºå‡½æ•°çš„å‚æ•°çš„\u0026quot;\u0026amp;\u0026quot;ç¬¦å·ï¼Œå¯ä»¥äº†è§£ä¸€ä¸‹å®å‚å’Œå½¢å‚ï¼Œä»¥åŠå‡½æ•°çš„å‰¯ä½œç”¨ //æ³¨æ„è¿™ç§å†™æ³•è¾ƒä¸ºå†—é•¿ï¼Œå¯ä»¥å»ºç«‹ä¸€ä¸ªacceptçš„åˆ—è¡¨ bool get_next_state(char ch,int\u0026amp; state){ switch(state){ case '1':{ if(isdigit(ch)||isletter(ch)){ state=2; return true; } return false; break;//è¿™é‡Œçš„breakä¸éœ€è¦ï¼Œä»…ä»…æ˜¯ä¸ºäº†æé†’å¤§å®¶switché‡Œè®°å¾—ä¸è¦æ¼æ‰breakè¯­å¥ } case '2':{ if(isdigit(ch)||isletter(ch)){ state=2; return true; } else if(ch=='@'){ state=3; return true; } return false; break; } case '3':{ if(isdigit(ch)||isletter(ch)){ state=4; return true; } return false; break; } case '4':{ if(isdigit(ch)||isletter(ch)){ state=4; return true; } else if(ch=='.'){ state=5; return true; } return false; break; } case '5':{ if(isdigit(ch)||isletter(ch)){ state=6; return true; } return false; break; } case '6':{ if(isdigit(ch)||isletter(ch)){ state=6; return true; } return false; break; } } } //å¦ä¸€ç§get_next_stateçš„å®ç°å¦‚ä¸‹ bool get_next_state(char ch,int\u0026amp; state){ static bool init=false; struct table{ string str; int next_state; }; static vector\u0026lt;table\u0026gt;nextstate[7]; if(!init){ //å°†åˆæ³•çŠ¶æ€åŠ å…¥è¡¨æ ¼ä¸­ï¼Œè¿™ä¸ªåˆæ³•çŠ¶æ€å­—ç¬¦ä¸²å¸¸é‡å¯ä»¥ç”¨ä¸€ä¸ªconst string è¡¨ç¤ºï¼Œä¸‹æ–‡ç”¨Stringè¡¨ç¤ºå­—ç¬¦ä¸²å¸¸é‡\u0026quot;abcdefghijklmnopqrstuvwxyz0123456789\u0026quot; table[1].push_back((table){String,2}); table[2].push_back((table){String,2}); table[3].push_back((table){String,4}); table[4].push_back((table){String,4}); table[5].push_back((table){String,6}); table[6].push_back((table){String,6}); table[2].push_back((table){\u0026quot;@\u0026quot;,3}); table[4].push_back((table){\u0026quot;.\u0026quot;,5}); init=true; //å½“ç„¶è¿™ä¸ªæ­¥éª¤å¯ä»¥åœ¨å‡½æ•°å¤–éƒ¨å®Œæˆ } for(int i=0;i\u0026lt;nextstate[state].size();i++){ //éå†åˆæ³•çŠ¶æ€ string availstr=nextstate[state][i].str; for(int j=0;j\u0026lt;availstr.size();j++){ if(ch==availstr[j]){ state=nextstate[state][i].next_state; return true; } } } return false; } bool solve(){ string str;//æ¨èä½¿ç”¨stringå­˜æ”¾å­—ç¬¦ä¸²æ•°æ® cin\u0026gt;\u0026gt;str; int state=1; for(int i=0;i\u0026lt;str.size();i++){ if(!get_next_state(str[i],state)){ return false;//å¦‚æœè½¬ç§»ä¸åˆæ³•ï¼Œåˆ™è¿”å›false } } return state==6;//åªæœ‰çŠ¶æ€6æ˜¯æ¥å—çŠ¶æ€ } int main(){ int t=1; while(t--)solve(); } å¦‚æœå¤§å®¶æ³¨æ„åˆ°çš„è¯ï¼Œç¬¬äºŒç§æ–¹å¼å¯ä»¥å½“åšâ€å›¾â€œæ¥ç†è§£ï¼Œâ€å›¾â€œåœ¨è®¡ç®—æœºä¸­åªæ˜¯ä¸€ç§æ¨¡å‹ï¼Œå¹¶ä¸ä¸€å®šåªæœ‰äº†è§£â€å›¾â€œçš„çŸ¥è¯†ï¼Œæ‰èƒ½å†™å‡ºæ¥å«æœ‰â€å›¾â€œæ€æƒ³çš„é¢˜ç›®ï¼Œæˆ‘è¿™é‡Œé¿å…äº†ä½¿ç”¨ä¼ ç»Ÿå»ºå›¾çš„æ–¹å¼ï¼Œä¸è¿‡è¿™é‡Œçš„çŠ¶æ€è½¬ç§»è¡¨çš„æ€æƒ³å’Œâ€å›¾\u0026quot;ç±»ä¼¼\nå…¶ä»–ä¾‹é¢˜ï¼š https://leetcode.cn/problems/valid-number/ (è¿™ç©æ„å±…ç„¶è¿˜æ ‡äº†å›°éš¾\u0026hellip;æ˜¯æˆ‘å¤§æ„äº†ï¼Œä»¥ä¸ºæ˜¯ä¸ªæ¯”è¾ƒç®€å•çš„é¢˜ç›®\u0026hellip;ä¸è¿‡LeetCodeä¸Šçš„å›°éš¾é¢˜å¤§å®¶å¤§äºŒä»¥åéƒ½æ˜¯éšä¾¿æ‰‹æ’•çš„ï¼ˆè¯¯ï¼‰ ä½†æ€»çš„æ¥è¯´ï¼ŒLeetCodeæ˜¯ä¸€ä¸ªé€‚åˆæ–°æ‰‹ç»ƒä¹ çš„ç½‘ç«™ï¼ŒLeetCodeä¸­ï¼Œæ‰€æœ‰é”™è¯¯éƒ½ä¼šæŠŠé”™è¯¯æ ·ä¾‹ç»™ä½ ï¼Œä¾¿äºè°ƒè¯•å’Œdebug)\n2.æ›´ç®€æ˜“æ­£åˆ™è¡¨è¾¾å¼ ä¸ºäº†ç»™å¤§å®¶ä¸€ä¸ªNFAå»ºæ¨¡çš„ä¾‹å­ï¼ŒåŒæ—¶ä¿è¯ä¸ç›´æ¥æä¾›OJä»£ç ï¼Œæˆ‘è¿™é‡Œå°†ä»¥ä¸€ä¸ªæ›´ç®€æ˜“ç‰ˆçš„æ­£åˆ™è¡¨è¾¾å¼çš„åˆ¤åˆ«\nè¿™é‡Œçš„æ­£åˆ™è¡¨è¾¾å¼åªåŒ…å«26ä¸ªå°å†™å­—æ¯å’Œ\u0026rdquo;*\u0026ldquo;ç¬¦å·ï¼Œå…¶å«ä¹‰å’ŒOJä¸­æ­£åˆ™è¡¨è¾¾å¼çš„å«ä¹‰ç›¸åŒ\nä¾‹å­åˆ†æ é¦–å…ˆè¦å¯¹æ­£åˆ™è¡¨è¾¾å¼è¿›è¡Œè¯­æ³•åˆ†æï¼Œå¾—åˆ°è¯¥æ­£åˆ™è¡¨è¾¾å¼å¯¹åº”çš„æ‰€æœ‰çŠ¶æ€\nå¯¹äºæ­£åˆ™è¡¨è¾¾å¼â€a*a*â€œæ¥è¯´ï¼Œç”¨å®ƒå»åŒ¹é…\u0026quot;aa\u0026rdquo;ï¼Œå¯èƒ½æœ‰å¤šé‡åŒ¹é…çš„ç»“æœï¼Œæ¯”å¦‚ç¬¬ä¸€ä¸ª\u0026rsquo;a\u0026rsquo;åŒ¹é…äº†ä¸¤æ¬¡ï¼Œç¬¬äºŒä¸ª\u0026rsquo;a\u0026rsquo;åŒ¹é…äº†é›¶æ¬¡ï¼Œå’Œç¬¬ä¸€ä¸ª\u0026rsquo;a\u0026rsquo;åŒ¹é…ä¸€æ¬¡ï¼Œç¬¬äºŒä¸ª\u0026rsquo;a\u0026rsquo;åŒ¹é…ä¸€æ¬¡ï¼Œå’Œç¬¬ä¸€ä¸ª\u0026rsquo;a\u0026rsquo;åŒ¹é…é›¶æ¬¡ï¼Œç¬¬äºŒä¸ª\u0026rsquo;a\u0026rsquo;åŒ¹é…ä¸¤æ¬¡ã€‚å› æ­¤åŒä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå¯èƒ½åœ¨æ­£åˆ™è¡¨è¾¾å¼ä¸­æœ‰å¤šç§å¯¹åº”çš„åŒ¹é…**ï¼ˆæ€è€ƒä¸€ä¸‹å¦‚ä½•è®¡ç®—åˆ°åº•æœ‰å¤šå°‘ç§å¯èƒ½çš„åŒ¹é…æ–¹å¼å‘¢ï¼‰**ã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥å°†æ­£åˆ™è¡¨è¾¾å¼å»ºæ¨¡æˆNFA\nä»¥\u0026quot;a*aba*\u0026ldquo;ä¸ºæ­£åˆ™è¡¨è¾¾å¼ä¸¾ä¾‹ï¼Œè¿åŒåˆå§‹çŠ¶æ€ï¼Œå®ƒä¸€å…±æœ‰ä»¥ä¸‹å››ä¸ªçŠ¶æ€\nåˆå§‹çŠ¶æ€ æ­£åœ¨åŒ¹é…ç¬¬ä¸€ä¸ª\u0026quot;a*\u0026rdquo; æ­£åœ¨åŒ¹é…\u0026quot;b\u0026rdquo; æ­£åœ¨åŒ¹é…ç¬¬äºŒä¸ª\u0026quot;a*\u0026quot; æ³¨æ„:ç”±äºæ­£åˆ™è¡¨è¾¾å¼çš„NFAç‰¹æ€§ï¼Œå¯¼è‡´åˆå§‹çŠ¶æ€æ—¶ï¼Œæ—¢å¯ä»¥å¤„åœ¨çŠ¶æ€1ï¼Œä¹Ÿå¯ä»¥å¤„åœ¨çŠ¶æ€2(å½“å‰åŒ¹é…äº†0æ¬¡\u0026rsquo;a\u0026rsquo;ï¼Œä¸ºåˆæ³•çš„åŒ¹é…)\nä»£ç å®ç°ï¼š æˆ‘è¿™é‡Œå°†ç»™å‡ºä¸Šæ–‡æåˆ°çš„ä¸¤ç§å®ç°æ–¹å¼å»è§£å†³è¯¥é—®é¢˜ï¼Œå½“ç„¶ï¼Œå¯¹äºæœ¬é¢˜ï¼ŒåŠ¨æ€è§„åˆ’ä¹Ÿæ˜¯ä¸€ä¸ªå¯è¡Œçš„ç®—æ³•ï¼Œè¿™é‡Œä¸å¤šèµ˜è¿°\n//NFAè½¬åŒ–æˆDFAå»åš typedef vector\u0026lt;int\u0026gt; arr; typedef vector\u0026lt;arr\u0026gt; matrix; arr operator*(matrix mat,arr vec){ assert(mat.size()\u0026gt;0\u0026amp;\u0026amp;vec.size()\u0026gt;0\u0026amp;\u0026amp;mat[0].size()==vec.size());//çŸ©é˜µè¿ç®—çš„å‰æ int n=mat.size(),m=vec.size(); arr ret(n,0); for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ ret[i]|=mat[i][j]\u0026amp;vec[j];//0-1çŸ©é˜µè®¡ç®— } } return ret; } struct _state{ char ch=0;//è¿™é‡Œå› ä¸ºæ²¡æœ‰å‡ºç°ä¸€ä¸ªstateé‡Œå…è®¸å¤šå­—ç¬¦çš„'[]'å’Œ'.'å‡ºç°ï¼Œäºæ˜¯ç”¨charè¡¨ç¤ºå½“å‰çŠ¶æ€å…è®¸çš„å­—ç¬¦ int type=0;//å½“å‰stateçš„ä¿®é¥°ç¬¦çŠ¶æ€ï¼Œ0è¡¨ç¤ºæ— ä¿®é¥°ç¬¦ï¼Œ1è¡¨ç¤ºç”¨'*'ä¿®é¥°,è¿™é‡Œå»ºè®®äº†è§£ä¸€äº›enumï¼Œåœ¨å®Œæˆè¾ƒå¤§å·¥ç¨‹æ—¶é€‚åˆä½¿ç”¨ }; //æ­£åˆ™è¡¨è¾¾å¼çš„parseè¿‡ç¨‹ï¼Œå°†æ­£åˆ™è¡¨è¾¾å¼æ ‡è®°æˆå¤šä¸ªçŠ¶æ€ vector\u0026lt;_state\u0026gt; parse(string regex){ vector\u0026lt;_state\u0026gt;states; for(int i=0;i\u0026lt;regex.size();i++){ _state state; state.ch=regex[i]; state.type=0; if(i+1\u0026lt;regex.size()\u0026amp;\u0026amp;regex[i+1]=='*'){ i++; state.type=1; } states.push_back(state); } return states; } bool solve(){ string regex;//æ­£åˆ™è¡¨è¾¾å¼ string str;//è¢«åŒ¹é…çš„å­—ç¬¦ä¸² cin\u0026gt;\u0026gt;regex\u0026gt;\u0026gt;str; vector\u0026lt;_state\u0026gt;states=parse(regex); int state_count=states.size()+1;//æ€»å…±çš„çŠ¶æ€æ•° //åˆå§‹åŒ–åˆæ³•çŠ¶æ€ arr state(state_count,0);//è¡¨ç¤ºå½“å‰çŠ¶æ€ state[0]=1; for(int i=0;i\u0026lt;states.size();i++){ if(states[i].type==1){ state[i+1]=1; } else break; } //æ¥ä¸‹æ¥æ„å»ºè½¬ç§»çŸ©é˜µçš„éƒ¨åˆ†ï¼Œæ¯ä¸€ä¸ªå­—æ¯æœ‰ä¸€ä¸ªç‹¬ç‰¹çš„è½¬ç§»çŸ©é˜µï¼Œè½¬ç§»çŸ©é˜µå«ä¹‰ç…§ä¸Šæ–‡è§£è¯» vector\u0026lt;matrix\u0026gt;trans_matrix(26,matrix(state_count,arr(state_count,0))); int lastavail=0;//è¿™é‡Œè¡¨ç¤ºè¿ç»­çš„'*'çš„å¼€å§‹ä½ for(int i=0;i\u0026lt;states.size();i++){ int index=states[i].ch-'a'; int type=states[i].type; if(type==1){ //å¦‚æœå½“å‰æ˜¯\u0026quot;*\u0026quot;çš„è¯ï¼Œé‚£ä¹ˆå¯¹äºä¹‹å‰çš„çŠ¶æ€ï¼Œåªè¦ä»–ä»¬èƒ½åˆ°è¾¾ä¸Šä¸€ä¸ªçŠ¶æ€ï¼Œéƒ½èƒ½å®ç°è½¬ç§»åˆ°å½“å‰çŠ¶æ€(epsilonè¾¹) for(int j=0;j\u0026lt;=i;j++){ for(int k=0;k\u0026lt;26;k++)trans_matrix[k][i+1][j]=trans_matrix[k][i][j]; } trans_matrix[index][i+1][i+1]=1; trans_matrix[index][i+1][i]=1;//è¿™ä¸ªæ˜¯å¤šä½™çš„(å› ä¸ºèƒ½åˆ°è¾¾içš„è¯ï¼Œä¸€å®šèƒ½åˆ°è¾¾çŠ¶æ€i+1ï¼Œä½†æ˜¯æ˜¯å¯è¡Œçš„) } else{ trans_matrix[index][i+1][i]=1; //å¦åˆ™åªèƒ½å®ç°ä»iåˆ°i+1çš„è½¬ç§» } } //ä¸æ–­è½¬ç§»è®¡ç®— for(int i=0;i\u0026lt;str.size();i++){ state=trans_matrix[str[i]-'a']*state; } return state[state_count-1];//æ­£åˆ™è¡¨è¾¾å¼çš„æ”¯æŒçŠ¶æ€åªæœ‰æœ«çŠ¶æ€. } int main(){ int t=1; while(t--){ solve(); } } //DFSå»åš struct _state{ char ch=0;//è¿™é‡Œå› ä¸ºæ²¡æœ‰å‡ºç°ä¸€ä¸ªstateé‡Œå…è®¸å¤šå­—ç¬¦çš„'[]'å’Œ'.'å‡ºç°ï¼Œäºæ˜¯ç”¨charè¡¨ç¤ºå½“å‰çŠ¶æ€å…è®¸çš„å­—ç¬¦ int type=0;//å½“å‰stateçš„ä¿®é¥°ç¬¦çŠ¶æ€ï¼Œ0è¡¨ç¤ºæ— ä¿®é¥°ç¬¦ï¼Œ1è¡¨ç¤ºç”¨'*'ä¿®é¥°,è¿™é‡Œå»ºè®®äº†è§£ä¸€äº›enumï¼Œåœ¨å®Œæˆè¾ƒå¤§å·¥ç¨‹æ—¶é€‚åˆä½¿ç”¨ }; //æ­£åˆ™è¡¨è¾¾å¼çš„parseè¿‡ç¨‹ï¼Œå°†æ­£åˆ™è¡¨è¾¾å¼æ ‡è®°æˆå¤šä¸ªçŠ¶æ€ vector\u0026lt;_state\u0026gt; parse(string regex){ vector\u0026lt;_state\u0026gt;states; for(int i=0;i\u0026lt;regex.size();i++){ _state state; state.ch=regex[i]; state.type=0; if(i+1\u0026lt;regex.size()\u0026amp;\u0026amp;regex[i+1]=='*'){ i++; state.type=1; } states.push_back(state); } return state; } vector\u0026lt;_state\u0026gt;states; int lastavail;//è¯¦æƒ…è§dfs bool dfs(string str,int index, int state){ if(index==str.size())return state==states.size(); //é¦–å…ˆåˆ¤æ–­å½“å‰stateå¯ä»¥è½¬ç§»çš„state vector\u0026lt;int\u0026gt;availstate; //æ³¨æ„å½“å‰çš„stateä¸‹æ ‡åœ¨statesæ•°ç»„é‡Œåº”è¯¥æ˜¯states[state-1] if(state\u0026gt;0\u0026amp;\u0026amp;states[state-1].type==1\u0026amp;\u0026amp;str[index]==states[state-1].ch)availstate.push_back(state); //å¯ä»¥è´ªå¿ƒï¼Œå¯¹äºæ‰€æœ‰çš„å¯åˆ°è¾¾çš„\u0026quot;*\u0026quot;æ ‡å¿—ï¼Œåªè¦è¿›å…¥æœ€å°ä¸‹æ ‡çš„å¯åˆ°è¾¾çš„\u0026quot;*\u0026quot;æ ‡è®°ä½ç½®å³å¯,è¿™æ˜¯ä¸€ç§å‰ªæç­–ç•¥ï¼Œè¿™é‡Œä¸ä½¿ç”¨è¯¥å‰ªæç­–ç•¥ï¼Œä¸ç”¨å‰ªæç­–ç•¥çš„è¯ï¼Œå¤æ‚åº¦æœ€é«˜å¯ä»¥è¾¾åˆ°2^n //(ä¸ºä»€ä¹ˆå¯ä»¥è¿™æ ·è´ªå¿ƒï¼Œè¯·è‡ªå·±ç†è§£ï¼Œä¸æ‡‚å¯ä»¥é—®åŠ©æ•™) for(int i=state;i\u0026lt;states.size();i++){ if(states[i].type!=1){ if(states[i].ch==str[index])availstate.push_back(i+1); break; //è¿™é‡Œç¢°åˆ°ä¸€æ¬¡type==0çš„æƒ…å†µåï¼Œä»ç„¶å¯ä»¥è½¬ç§»åˆ°å®ƒåé¢çš„type==1çš„æƒ…å†µï¼Œä½†æ˜¯é‚£æ ·æ˜¯æ— æ„ä¹‰çš„ï¼Œäºæ˜¯è¿™é‡Œæˆ‘å†™äº†ä¸€ä¸ªlastavailçš„æ ‡å¿—ï¼Œè¡¨ç¤ºå¯ä»¥é€šè¿‡epsilonè½¬ç§»åˆ°æœ€åä¸€ä¸ªçŠ¶æ€çš„æœ€å°state } else{ if(states[i].ch==str[index])availstate.push_back(i+1); } } for(int i=0;i\u0026lt;availstate.size();i++){ if(dfs(str,index+1,availstate[i]))return true;//è¿™é‡Œä¹Ÿæ˜¯ç®€å•çš„å‰ªæ,ä¸å‰ªæçš„å†™æ³•å¦‚ä¸‹ } /* ä¸å‰ªæçš„å†™æ³• bool flag=false; for(int i=0;i\u0026lt;availstate.size();i++){ flag|=dfs(str,index+1,availstate[i]); } return flag; */ return false; } bool solve(){ string regex; string str; cin\u0026gt;\u0026gt;regex\u0026gt;\u0026gt;str; states=parse(regex); vector\u0026lt;int\u0026gt;initialstate; initialstate.push_back(0); lastavail = states.size(); for (int i = states.size()-1; i \u0026gt;= 0; i--) { if (states[i].type == 1)lastavail = i; else break; } return dfs(str,0,0); } åŠ¨æ€è§„åˆ’è§£æ³•ï¼š è‡ªè¡Œäº†è§£ä¸€ä¸‹ ( https://leetcode.cn/problems/regular-expression-matching/)\n","date":1667260800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1667260800,"objectID":"40b45547b6550c1bdd40cdeb11f7a5f3","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/dfa/","publishdate":"2022-11-01T00:00:00Z","relpermalink":"/courses/problemsolving22/dfa/","section":"courses","summary":"é¸£è°¢dxyåŠ©æ•™çš„è´¡çŒ®ï¼","tags":null,"title":"æœ‰é™çŠ¶æ€æœºç®€ä»‹","type":"courses"},{"authors":null,"categories":null,"content":" å£°æ˜\nPythonè¯­è¨€çš„å­¦ä¹ ä¸æ˜¯è¿™é—¨è¯¾çš„ç¡¬æ€§è¦æ±‚ï¼Œå› æ­¤æˆ‘ä»¬ä¸ä¼šåœ¨OJä½œä¸š/æœŸæœ«æµ‹è¯•ä¸­å¼ºåˆ¶å¤§å®¶ä½¿ç”¨Pythonå®Œæˆä¹ é¢˜ã€‚ä½†æˆ‘ä»¬ä»ç„¶å¼ºçƒˆå»ºè®®ä½ åœ¨åˆå­¦é˜¶æ®µè‡³å°‘æ¶‰çŒä¸€ä¸‹è¿™æ ·ä¸€é—¨ä¸ C/C++ é£æ ¼è¿¥å¼‚çš„è¯­è¨€ã€‚\næ¥è§¦ Python å¯ä»¥ç»™ä½ å¸¦æ¥ä¸é™äºä»¥ä¸‹å¥½å¤„ï¼š\næ„Ÿå— Python ç²¾ç®€çµæ´»çš„è¯­æ³•ï¼šåœ¨è¿™é‡Œä½ ä¸ç”¨ä¹¦å†™å¤´æ–‡ä»¶ï¼Œä¸éœ€è¦ä¹¦å†™ main() å‡½æ•°ï¼Œä¸éœ€è¦åœ¨æ¯è¡Œåé¢å†™åˆ†å·ï¼Œä¸éœ€è¦å®šä¹‰å˜é‡â€¦â€¦Python æä¾›çš„ä¸°å¯Œçš„å†…ç½®æ•°æ®ç±»å‹è®©ä½ å¯ä»¥è½»æ¾è‡ªç”±åœ°æ“çºµæ•°æ®ã€‚ æ„Ÿå—å‡½æ•°å¼ç¼–ç¨‹èŒƒå¼ï¼šPython æ˜¯ä¸€é—¨å…¼æœ‰å‘½ä»¤å¼å’Œå‡½æ•°å¼é£æ ¼çš„è¯­è¨€ã€‚åœ¨ Python ä¸­ä½ å¯ä»¥è½»è€Œæ˜“ä¸¾åœ°ç©è½¬é«˜é˜¶å‡½æ•°ã€lambdaè¡¨è¾¾å¼ç­‰ï¼Œæ„Ÿå—å‡½æ•°å¼ç¼–ç¨‹çš„ç‹¬ç‰¹æ€æƒ³å’Œé­…åŠ›ã€‚ å¼ºå¤§çš„ç¬¬ä¸‰æ–¹åº“ï¼šPython ä¸°å¯Œçš„ç¬¬ä¸‰æ–¹åº“çš„æ”¯æŒå¯ä»¥è®©ä½ è½»æ¾åœ°å®Œæˆä¸€äº›â€œæƒŠä¸ºå¤©äººâ€çš„ä¸œè¥¿ï¼Œæ¯”å¦‚å¤„ç†ç”µè„‘æ–‡ä»¶çš„è‡ªåŠ¨åŒ–è„šæœ¬ï¼Œå¸¦æœ‰å›¾å½¢ç•Œé¢çš„å°æ¸¸æˆç­‰ç­‰ã€‚ æ¥è§¦ Python å¯èƒ½å¸¦æ¥çš„åå¤„ï¼šæ€»æ˜¯åœ¨ C/C++ ç¨‹åºä¸­å†™å‡º Python é£æ ¼çš„ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯çš„ä»£ç ã€‚\næˆ‘ä»¬ä¸ä¼šä»‹ç» Python çš„å®‰è£…ï¼Œå¦‚æœä½ æ„Ÿå…´è¶£å¯ä»¥ä¸Šç½‘è‡ªè¡Œæœç´¢æ•™ç¨‹å®‰è£… Python çš„è¿è¡Œç¯å¢ƒï¼Œå¹¶äº²è‡ªä¸Šæ‰‹æ„Ÿå—è¿™æ ·ä¸€é—¨ç°ä»£è¯­è¨€ã€‚ä½ ç›®å‰åªéœ€è¦èƒ½çœ‹æ‡‚è¿™ä»½æ•™ç¨‹å³å¯ã€‚\næƒ³å¿…å¤§å®¶å¬è¿‡ä¸€å¥è‘—åçš„å¹¿å‘Šè¯â€œäººç”Ÿè‹¦çŸ­ï¼Œæˆ‘ç”¨Pythonâ€ã€‚Pythonæ˜¯ä¸–ç•Œä¸Šç¨‹åºå‘˜æœ€å–œçˆ±çš„ç¼–ç¨‹è¯­è¨€ä¹‹ä¸€ (ä¸»è¦åŸå› å·²ç»åœ¨ä¸Šæ–¹çš„è“æ¡†ä¸­æ¶‰åŠäº†ä¸€éƒ¨åˆ†)ã€‚æˆ‘ä»¬ä»ç„¶ç”¨è¾“å‡º \u0026ldquo;Hello, world!\u0026rdquo; çš„ä¾‹å­æ¥å…¥é—¨ï¼š\nprint('Hello, world!') æ˜¯çš„ï¼Œåªéœ€è¦ä¸€è¡Œã€‚ä¸éœ€è¦å¤´æ–‡ä»¶ã€main() å‡½æ•°ï¼Œä¹Ÿä¸éœ€è¦ç†è§£å¤æ‚çš„ scanf()/printf() è¯­æ³•å’Œè¾“å…¥è¾“å‡ºæµï¼Œä¸€ä¸ªç›´è§‚çš„ print() å‡½æ•°è§£å†³ä¸€åˆ‡ï¼\nä¸‹ä¸€ä¸ªä¾‹å­æ˜¯å–œé—»ä¹è§çš„ a+b problemï¼š\na = int(input()) b = int(input()) print(a + b) åœ¨ Python ä¸­ä½ ä¸éœ€è¦æå‰å®šä¹‰å˜é‡ï¼Œå¯ä»¥â€œæ‹¿æ¥å°±ç”¨â€ï¼Œè¿™æ˜¯å› ä¸º Python æ˜¯ä¸€é—¨åŠ¨æ€è¯­è¨€ï¼Œå¯ä»¥åœ¨æ‰§è¡Œçš„è¿‡ç¨‹ä¸­è¿›è¡Œ type inferenceã€‚è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ input() è¯»å…¥è¿›æ¥çš„å†…å®¹é»˜è®¤æ˜¯å­—ç¬¦ä¸²ç±»å‹ï¼Œæˆ‘ä»¬éœ€è¦ç”¨ int() å°†å…¶è½¬æ¢ä¸ºæ•´æ•°ç±»å‹ã€‚å¦‚æœä½ æƒ³è¦æŸ¥çœ‹ä¸€ä¸ªå˜é‡å­˜å‚¨çš„æ•°æ®çš„ç±»å‹ï¼Œä½ å¯ä»¥ä½¿ç”¨ type() å‡½æ•°ï¼š\na = input() print(type(a)) # åœ¨ Python ä¸­ï¼Œä½ å¯ä»¥ç”¨\u0026quot;#\u0026quot;è¿›è¡Œè¡Œæœ«æ³¨é‡Šï¼ \u0026quot;\u0026quot;\u0026quot; åœ¨ Python ä¸­ï¼Œä½ å¯ä»¥ç”¨ä¸‰å¼•å·æ¡†ä½ ä¸€æ®µæ³¨é‡Šï¼ \u0026quot;\u0026quot;\u0026quot; åœ¨ Python ä¸­å®šä¹‰å‡½æ•°å¯ä»¥ä½¿ç”¨ \u0026ldquo;def\u0026rdquo; å…³é”®å­—ï¼š\ndef add(a, b): # æ³¨æ„è¿™é‡Œå¿…é¡»æœ‰å†’å·ï¼ return a + b print(add(1, 2)) # è¾“å‡ºï¼š3 å€¼å¾—æ³¨æ„çš„æ˜¯ï¼ŒPythonæ²¡æœ‰C/C++è¯­è¨€ä¸­ä¸€å±‚å±‚çš„å¤§æ‹¬å·ï¼Œæ‰€ä»¥Pythonç¨‹åºéœ€è¦ä¾é ä¸¥æ ¼çš„ç¼©è¿›æ¥ä¿è¯æ¸…æ™°çš„ç¨‹åºç»“æ„ã€‚å› æ­¤å‡½æ•°ä½“çš„è¯­å¥å‰æ–¹å¿…é¡»æœ‰ç¼©è¿›ï¼ç±»ä¼¼åœ°ï¼Œifè¯­å¥çš„åˆ†æ”¯ï¼Œå¾ªç¯è¯­å¥çš„å¾ªç¯ä½“ä¹Ÿå¿…é¡»ä¿è¯æ­£ç¡®çš„ç¼©è¿›ã€‚\nPythonä¸­çš„åˆ¤æ–­è¯­å¥ï¼š\ndef judge_even_odd(x): if x % 2 == 0: # æ³¨æ„è¿™é‡Œè¦æœ‰å†’å·ï¼ return 'even' else: # æ³¨æ„è¿™é‡Œè¦æœ‰å†’å·ï¼ return 'odd' print(judge_even_odd(1)) # è¾“å‡ºï¼šodd Pythonä¸­çš„å¾ªç¯è¯­å¥ï¼š\ndef cumulative_sum(n): res = 0 while n \u0026gt;= 0: # æ³¨æ„è¿™é‡Œè¦æœ‰å†’å·ï¼ res += n n -= 1 return res print(cumulative_sum(10)) # è¾“å‡ºï¼š55 æ³¨æ„ï¼šåœ¨ Python ä¸­ if/while çš„åˆ¤æ–­æ¡ä»¶å·¦å³æ˜¯ä¸éœ€è¦åŠ æ‹¬å·çš„ã€‚\nä¸€ä¸ªç®€å•çš„é€’å½’ç¨‹åºï¼š\ndef fibonacci(n): if n == 0: return 0 elif n == 1: return 1 else: return fibonacci(n-1) + fibonacci(n-2) print(fibonacci(9)) # è¾“å‡ºï¼š34 ","date":1667174400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1667174400,"objectID":"a5e0fe7a78a60762adfe8e30afe04623","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/python-intro/","publishdate":"2022-10-31T00:00:00Z","relpermalink":"/courses/problemsolving22/python-intro/","section":"courses","summary":"ä¸€ä»½ç®€çŸ­çš„ Python æ•™ç¨‹ï¼Œå¸®åŠ©ä½ å¿«é€ŸæŒæ¡ Python ä¸­æœ€åŸºç¡€çš„è¯­æ³•(æ­£åœ¨æ›´æ–°ä¸­ï¼‰","tags":null,"title":"Python å¿«é€Ÿå…¥é—¨æ•™ç¨‹","type":"courses"},{"authors":null,"categories":null,"content":" é¢˜æ„æ¦‚è¿°\nç»™å®šå­—ç¬¦ä¸² $s$ï¼Œæ±‚ $|\\{(i,j,k)|s_i=j,s_j=y,s_k=y\\}|$ã€‚\nçº¦æŸæ¡ä»¶ï¼š$|s|\\leq 10^6$ã€‚\nå¤§å®¶å®¹æ˜“æƒ³åˆ°çš„ä¸€ä¸ªéå¸¸ç®€æ˜çš„åšæ³•æ˜¯ä½¿ç”¨ä¸‰é‡å¾ªç¯è®¡æ•°ï¼š\nans = 0; for (int i = 0; i \u0026lt; int(s.size()); i++) for (int j = i + 1; j \u0026lt; int(s.size()); j++) for (int k = j + 1; k \u0026lt; int(s.size()); k++) if (s[i] == 'j' \u0026amp;\u0026amp; s[j] == 'y' \u0026amp;\u0026amp; s[k] == 'y') ans++; ä½†ç”±äºæ­¤é¢˜ä¸­ $|s|$ è¾¾åˆ°äº† $10^6$ï¼Œä½¿ç”¨ä¸‰é‡å¾ªç¯æ„å‘³ç€å¾ªç¯æœ€å†…å±‚çš„æ ¸å¿ƒè¯­å¥è¢«æ‰§è¡Œäº†å°†è¿‘ $|s|^3$ æ¬¡ã€‚è®¡ç®—æœºä¸€ç§’é’Ÿå¯ä»¥æ‰§è¡Œçš„ C/C++ åŸºæœ¬è¯­å¥æ•°ç›®å¤§çº¦åœ¨ $10^8$ é‡çº§ï¼Œè¿™æ ·çš„ç¨‹åºæ˜¾ç„¶ä¼šè¶…æ—¶ã€‚\næœ¬é¢˜çš„å‡ºé¢˜åŠ©æ•™ (aka. dxy) å¸Œæœ›å¤§å®¶æ„é€ è‡ªåŠ¨æœºè§£é¢˜ã€‚è¿™é‡Œæˆ‘ä»¬ç»™å‡ºä¸€ä¸ªå¦å¤–çš„æ¯”è¾ƒç®€å•çš„æ€è·¯ï¼š\næˆ‘ä»¬å°†ä¸Šé¢çš„ç¨‹åºæ”¹å†™ä¸ºå¦‚ä¸‹ä¼ªä»£ç ï¼š\nans = 0; for (int i = 0; i \u0026lt; int(s.size()); i++) if (s[i] == 'j') ans += \u0026quot;s[i]çš„åé¢(å¯ä»¥ä¸è¿ç»­)çš„yyçš„æ•°ç›®\u0026quot;; ä¹‹å‰çš„ä»£ç ä¸­æˆ‘ä»¬ä½¿ç”¨åŒé‡å¾ªç¯æ¥æ•° \u0026ldquo;yy\u0026rdquo; çš„ä¸ªæ•°ï¼Œä½†äº‹å®ä¸Šæˆ‘ä»¬æœ‰æ›´å¿«é€Ÿçš„æ–¹æ³•ï¼šå‡è®¾ s[i] çš„åé¢ä¸€å…±æœ‰ n ä¸ªå­—æ¯yï¼Œé‚£ä¹ˆä»»æ„æŒ‘é€‰ä¸¤ä¸ªéƒ½å¯ä»¥ç»„æˆä¸€ä¸ªyyï¼Œæ‰€ä»¥yyçš„æ€»æ•°ç›®æ˜¯ $\\binom{n}{2}=\\frac{1}{2}n(n-1)$ã€‚åŸºäºè¿™ä¸ªæƒ³æ³•ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªäºŒé‡å¾ªç¯è§£å†³è¯¥é—®é¢˜ï¼š\nans = 0; for (int i = 0; i \u0026lt; int(s.size()); i++) if (s[i] == 'j') { int y_count = 0; for (int j = i + 1; j \u0026lt; int(s.size()); j++) if (s[j] == 'y') y_count++; ans += C(y_count, 2); // ç»„åˆæ•°éœ€è¦å¦å¤–å®ç° } æˆ‘ä»¬çš„ç®—æ³•å·²ç»å¾—åˆ°äº†æ”¹è¿›ï¼Œä½† $|s|^2$ æ¬¡è¿è¡Œä»ç„¶æ— æ³•åœ¨è§„å®šæ—¶é—´å†…è·å¾—ç»“æœï¼Œç®—æ³•è¿˜éœ€è¦è¿›ä¸€æ­¥çš„ä¼˜åŒ–ã€‚ä¸Šè¿°æ–¹æ³•çš„ç“¶é¢ˆåœ¨äºæˆ‘ä»¬æ¯é‡åˆ°ä¸€ä¸ªjéƒ½ä¼šæŠŠå®ƒåé¢çš„yæ•°ä¸€éï¼Œè¿™æ ·æœ‰å¾ˆå¤šçš„å­—æ¯yè¢«åå¤æ•°äº†å¾ˆå¤šéï¼Œè¿™æ— ç–‘æ‹–æ…¢äº†é€Ÿåº¦ã€‚\näº‹å®ä¸Šï¼Œä¸€ä¸ªå·§å¦™çš„é¡ºåºçš„æ”¹å˜å°±å¯ä»¥â€œæŸ³æš—èŠ±æ˜â€ï¼šæˆ‘ä»¬å°†å¤–å±‚å¾ªç¯çš„é¡ºåºå€’è¿‡æ¥ï¼Œä¸€è¾¹å¯»æ‰¾jä¸€è¾¹æŠŠjâ€œèº«åâ€çš„yçš„ä¸ªæ•°æ•°å‡ºæ¥ï¼Œè¿™æ ·å°±ä¸éœ€è¦å†…å±‚å¾ªç¯äº†ï¼š\nans = y_count = 0; for (int i = int(s.size()) - 1; i \u0026gt;= 0; i--) { if (s[i] == 'y') y_count++; if (s[i] == 'j') ans += C(y_count, 2); } å¾ªç¯çš„ä½¿ç”¨æ–¹æ³•åšå¤§ç²¾æ·±ï¼Œå¤§å®¶å¯ä»¥ä»”ç»†ä½“ä¼šè¿™æ®µä»£ç ã€‚\næ­¤å¤–ï¼Œæœ¬é¢˜ç”±äºç»“æœè¿‡å¤§ï¼Œæœ€ç»ˆéœ€è¦è¾“å‡ºç­”æ¡ˆå¯¹ $998244353$ å–æ¨¡çš„ç»“æœã€‚å¤§å®¶åœ¨æœ¬é¢˜ä¸­å¯èƒ½ä¼šä½¿ç”¨ä¹˜æ³•ï¼Œæ­¤æ—¶å¿…é¡»æ ¼å¤–å°å¿ƒä¸¤ä¸ª int ç±»å‹å˜é‡ç›¸ä¹˜ (è¿˜æ²¡æ¥å¾—åŠå–æ¨¡æ—¶) ç»“æœæº¢å‡ºçš„æƒ…å†µï¼Œä¸€ä¸ªå¥½çš„è§£å†³æ–¹æ¡ˆæ˜¯ä½¿ç”¨æ›´å¤§çš„æ•°æ®ç±»å‹å­˜å‚¨ä¸­é—´ç»“æœã€‚\n","date":1666828800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1666828800,"objectID":"18ce0a6d4d94910fde56fd2b3af6d845","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/solutions/1-4-c/","publishdate":"2022-10-27T00:00:00Z","relpermalink":"/courses/problemsolving22/solutions/1-4-c/","section":"courses","summary":"é¢˜æ„æ¦‚è¿°\nç»™å®šå­—ç¬¦ä¸² $s$ï¼Œæ±‚ $|\\{(i,j,k)|s_i=j,s_j=y,s_k=y\\}|$ã€‚\nçº¦æŸæ¡ä»¶ï¼š$|s|\\leq 10^6$ã€‚\nå¤§å®¶å®¹æ˜“æƒ³åˆ°çš„ä¸€ä¸ªéå¸¸ç®€æ˜çš„åšæ³•æ˜¯ä½¿ç”¨ä¸‰é‡å¾ªç¯è®¡æ•°ï¼š\nans = 0; for (int i = 0; i \u0026lt; int(s.size()); i++) for (int j = i + 1; j \u0026lt; int(s.size()); j++) for (int k = j + 1; k \u0026lt; int(s.","tags":null,"title":"ã€é—®é¢˜æ±‚è§£I-HW4.Cã€‘jyyä¸ºä»€ä¹ˆæ˜¯ç¥","type":"docs"},{"authors":null,"categories":null,"content":" 2.1 Principles of Network Applications 2.1.1 Network Application Architectures 2.1.2 Processes Communicating Client and Server Processes The Interface Between the Process and the Computer Network Addressing Processes 2.1.3 Transport Services Available to Applications Reliable Data Transfer Throughput Timing Security 2.1.4 Transport Services Provided by the Internet TCP Services UDP Services Services Not Provided by Internet Transport Protocols 2.1.5 Application-Layer Protocols 2.1.6 Network Applications Covered in This Book 2.2 The Web and HTTP 2.2.1 Overview of HTTP 2.2.2 Non-Persistent and Persistent Connections HTTP with Non-Persistent Connections HTTP with Persistent Connections 2.2.3 HTTP Message Format HTTP Request Message HTTP Response Message 2.2.4 User-Server Interaction: Cookies 2.2.5 Web Caching The Conditional GET 2.2.6 HTTP/2 HTTP/2 Framing Response Message Prioritization and Server Pushing 2.3 Electronic Mail in the Internet 2.3.1 SMTP 2.3.2 Mail Message Formats 2.3.3 Mail Access Protocols 2.4 DNS - The Internet\u0026rsquo;s Directory Service 2.4.1 Services Provided by DNS 2.4.2 Overview of How DNS Works A Distributed, Hierarchical Database DNS Caching 2.4.3 DNS Records and Messages DNS Message Inserting Records into the DNS Database 2.5 Peer-to-Peer File Distribution Scalability of P2P Architecture BitTorrent 2.6 Video Streaming and Content Distribution Networks 2.6.1 Internet Video 2.6.2 HTTP Streaming and DASH 2.6.3 Content Distribution Networks CDN Operation Cluster Selection Strategies 2.6.4 Case Studies: Netflix and YouTube Netflix YouTube 2.7 Socket Programming: Creating Network Applications 2.1 Principles of Network Applications å¼€å‘ç½‘ç»œåº”ç”¨çš„æ ¸å¿ƒæ˜¯ä¹¦å†™å¯ä»¥åœ¨ä¸åŒçš„ç»ˆç«¯è®¾å¤‡ä¸Šè¿è¡Œçš„ä»£ç â€”â€”å€¼å¾—æ³¨æ„çš„æ˜¯æˆ‘ä»¬ä¸éœ€è¦ä½¿æˆ‘ä»¬çš„ç¨‹åºå¯ä»¥åœ¨ network core ä¸­è¿è¡Œï¼Œå› ä¸º network core ä¸­çš„ router/switch æ ¹æœ¬æ²¡æœ‰åº”ç”¨å±‚ã€‚\n2.1.1 Network Application Architectures éœ€è¦æ³¨æ„çš„æ˜¯ application architecture å’Œä¹‹å‰çš„ network architecture (å³åº”ç”¨/ä¼ è¾“/ç½‘ç»œ/é“¾è·¯/ç‰©ç†äº”å±‚æ¶æ„) æ˜¯ä¸åŒçš„ã€‚åº”ç”¨æ¶æ„ (application architecture) ç”±è½¯ä»¶å¼€å‘è€…æå‡ºï¼Œç”¨æ¥æè¿°ä¸€ä¸ªç½‘ç»œåº”ç”¨åº”å½“ä»¥ä»€ä¹ˆæ ·çš„ç»“æ„åˆ†å¸ƒåœ¨å„ä¸ªç»ˆç«¯è®¾å¤‡ä¸Šã€‚ç°åœ¨æœ€æµè¡Œçš„ä¸¤ç§åº”ç”¨æ¶æ„æ˜¯æ‰€è°“çš„ client-server æ¶æ„å’Œ P2P æ¶æ„ã€‚\nåœ¨å®¢æˆ·æœº-æœåŠ¡å™¨æ¶æ„ (client-server architecture) ä¸­ï¼Œæœ‰ä¸€å°ä¸€ç›´è¿ä½œçš„ä¸»æœºç§°ä¸ºæœåŠ¡å™¨ (server)ï¼Œå®ƒçš„åŠŸèƒ½æ˜¯ä¸ºè®¸è®¸å¤šå¤šçš„å…¶ä»–ä¸»æœºï¼Œç§°ä¸ºå®¢æˆ·æœº (client)ï¼Œæä¾›æœåŠ¡ã€‚åœ¨ client-server æ¶æ„ä¸­ï¼Œä¸åŒçš„å®¢æˆ·æœºä¹‹é—´ä¸ä¼šç›´æ¥å»ºç«‹é€šè®¯ï¼Œä»–ä»¬éƒ½åªå’ŒæœåŠ¡å™¨äº¤äº’ï¼ŒæœåŠ¡å™¨æœ‰ä¸€ä¸ªå›ºå®šä¸”ä¸ºå¤§å®¶æ‰€çŸ¥çš„ IP åœ°å€ï¼Œå®¢æˆ·æœºå¯ä»¥é€šè¿‡å‘è¯¥ IP åœ°å€å‘é€ packet çš„æ–¹å¼ä¸æœåŠ¡å™¨å»ºç«‹é€šè®¯ã€‚\né€šå¸¸åœ¨ client-server åº”ç”¨ä¸­ï¼Œä¸€ä¸ªæœåŠ¡å™¨ä¸»æœºå¾ˆéš¾æ”¯æ’‘ç¹é‡çš„ä¸šåŠ¡ï¼Œæ‰€ä»¥å¼€å‘è€…ä¸€èˆ¬ä¼šå»ºç«‹æ•°æ®ä¸­å¿ƒ (data center)ã€‚æ•°æ®ä¸­å¿ƒé‡Œæœ‰å¤§é‡çš„ä¸»æœºï¼Œå®ƒä»¬åˆèµ·æ¥å¯¹å¤–å½¢æˆä¸€ä¸ªè™šæ‹ŸæœåŠ¡å™¨ã€‚\nåœ¨ç‚¹å¯¹ç‚¹æ¶æ„ (peer=to=peer/P2P architecture) ä¸­ï¼Œæˆ‘ä»¬ä¸å†æœ‰æœåŠ¡å™¨å’Œæ•°æ®ä¸­å¿ƒçš„æ¦‚å¿µã€‚ç”¨æˆ·çš„ä¸»æœºä¹‹é—´ç›´æ¥å»ºç«‹è”ç³»ï¼Œè¿™ç§ pair è¢«ç§°ä¸ºåŒä¼´ (peer)ã€‚P2P çš„ä¸€å¤§ä¼˜åŠ¿åœ¨äºå…¶ self-scalabilityï¼Œä¾‹å¦‚åœ¨ä¸€ä¸ª P2P æ–‡ä»¶åˆ†äº«åº”ç”¨ä¸­ï¼Œè™½ç„¶æ¯ä¸ªç”¨æˆ·ç´¢å–æ–‡ä»¶ä¼šä¸ºç½‘ç»œå¸¦æ¥ workloadï¼Œä½†æ¯ä¸ªç”¨æˆ·ä¹Ÿä¼šå°†è‡ªå·±çš„æ–‡ä»¶è´¡çŒ®ç»™åŒä¼´ï¼Œä¸ºç½‘ç»œå¢æ·»æœåŠ¡èƒ½åŠ›ã€‚æ­¤å¤–ï¼ŒP2P èŠ‚çœäº†å»ºè®¾æœåŠ¡å™¨ç­‰æœåŠ¡åŸºç¡€è®¾æ–½çš„é’±è´¢å’Œç²¾åŠ›ã€‚ä¸è¿‡ P2P é«˜åº¦å»ä¸­å¿ƒåŒ–çš„ç»“æ„ä½¿å…¶åœ¨å®‰å…¨æ€§ã€å¯é æ€§ç­‰æ–¹é¢å­˜åœ¨ä¸€å®šçš„æŒ‘æˆ˜ã€‚\n2.1.2 Processes Communicating è¿™ä¸ª section ä¸»è¦è®¨è®ºä½äºä¸åŒç»ˆç«¯è®¾å¤‡çš„ç¨‹åºä¹‹é—´æ˜¯å¦‚ä½•äº¤äº’çš„ã€‚æ ¹æ®æ“ä½œç³»ç»Ÿçš„æœ¯è¯­ï¼Œäº‹å®ä¸Šå¹¶ä¸æ˜¯ç¨‹åºåœ¨äº¤äº’ï¼Œè€Œæ˜¯è¿›ç¨‹åœ¨äº¤äº’ã€‚ä¸¤ä¸ªè¿›ç¨‹å¤„äºä¸¤ä¸ªä¸åŒç»ˆç«¯è®¾å¤‡çš„åº”ç”¨å±‚ï¼Œå®ƒä»¬é€šè¿‡å‘ç½‘ç»œå‘é€æŠ¥æ–‡çš„æ–¹å¼äº¤æ¢ä¿¡æ¯ã€‚\nClient and Server Processes å¯¹äºæ¯ä¸€å¯¹é€šä¿¡çš„è¿›ç¨‹ï¼Œæˆ‘ä»¬é€šå¸¸å°†å…¶ä¸­æä¾›æœåŠ¡çš„è¿›ç¨‹ç§°ä¸º serverï¼Œä½¿ç”¨æœåŠ¡çš„è¿›ç¨‹ç§°ä¸º clientã€‚ä¾‹å¦‚åœ¨ Web åº”ç”¨ä¸­ï¼Œç½‘é¡µæµè§ˆå™¨æ˜¯ client è¿›ç¨‹ï¼ŒWeb server æ˜¯ server è¿›ç¨‹ï¼›åœ¨ P2P æ–‡ä»¶å…±äº«ä¸­ï¼Œä¸‹è½½æ–‡ä»¶çš„è¿›ç¨‹æ˜¯ client è¿›ç¨‹ï¼Œä¸Šä¼ æ–‡ä»¶çš„è¿›ç¨‹æ˜¯ server è¿›ç¨‹ã€‚äº‹å®ä¸Šï¼Œåœ¨ P2P ä¸­ï¼Œå¾ˆå¤šæƒ…å†µä¸‹ä¸€ä¸ªè¿›ç¨‹å¯èƒ½åŒæ—¶åœ¨ä¸Šä¼ å’Œä¸‹è½½ï¼Œä½†å…·ä½“åˆ°ä¸€ä¸ªå›ºå®šçš„ pair ä¸­æ—¶å®ƒè¦ä¹ˆæ˜¯ server è¦ä¹ˆæ˜¯ clientã€‚\nå…³äº client side å’Œ server side æœ‰ä¸€ä¸ªæ›´æ­£å¼çš„å®šä¹‰ï¼šå¯¹äºä¸€å¯¹æ­£åœ¨é€šä¿¡çš„è¿›ç¨‹æ¥è¯´ï¼Œåˆå§‹åŒ–é€šä¿¡ä¼šè¯çš„é‚£ä¸ªè¿›ç¨‹æ˜¯ clientï¼Œé‚£ä¸ªç­‰å¾…å®ƒäººä¸è‡ªå·±è¿æ¥å¹¶å¼€å¯ä¼šè¯çš„è¿›ç¨‹æ˜¯ serverã€‚\nThe Interface Between the Process and the Computer Network åº”ç”¨å±‚çš„ application é€šè¿‡å¥—æ¥å­— (socket) å‘é€å’Œæ¥æ”¶æ¶ˆæ¯ã€‚socket æ˜¯ä¼ è¾“å±‚å‘åº”ç”¨å±‚æä¾›çš„ APIï¼Œå®ƒä¸ºåº”ç”¨å±‚æä¾›çš„ä¿è¯æ˜¯ application åªè¦å‘ socket ä¼ è¾“å†…å®¹ï¼Œä¸‹å±‚çš„åŸºç¡€è®¾æ–½å°±ä¼šå°†å†…å®¹ä¼ è¾“åˆ°è¿æ¥å¦å¤–ä¸€ç«¯çš„ socketã€‚åº”ç”¨å¼€å‘è€…ä¸èƒ½ä¹Ÿä¸åº”è¯¥ç›´æ¥è§¦ç¢°åº•å±‚çš„ä¼ è¾“ç»†èŠ‚ï¼Œä»–ä»¬åªèƒ½é€šè¿‡é€‰æ‹©ä¼ è¾“åè®®å’Œç»™å®šä¸€äº›å‚æ•°çš„æ–¹å¼æ¥å®šåˆ¶è‡ªå·±æ‰€éœ€çš„æœåŠ¡ã€‚\nAddressing Processes å‘é€æ¶ˆæ¯æ—¶å‘é€æ–¹éœ€è¦çŸ¥é“æ¥æ”¶ä¸»æœºçš„ IP åœ°å€ (IP address)ã€‚æ­¤å¤–ï¼Œç”±äºä¸€ä¸ªä¸»æœºå¯ä»¥åŒæ—¶è¿è¡Œå¤šä¸ªç½‘ç»œåº”ç”¨/è¿›ç¨‹ï¼Œæˆ‘ä»¬è¿˜éœ€è¦ä¸€ä¸ªæ–¹æ³•æ¥è¾¨åˆ«æ¥æ”¶æ¶ˆæ¯çš„è¿›ç¨‹ï¼Œè¿™å°±æ˜¯ç«¯å£å· (port number) çš„åŠŸèƒ½ã€‚ç«¯å£å·æœ‰ä¸€äº›conventionï¼Œæ¯”å¦‚ Web server çš„ç«¯å£å·é€šå¸¸æ˜¯ 80ï¼Œmail server é€šå¸¸æ˜¯ 25 ç­‰ç­‰ã€‚\n2.1.3 Transport Services Available to Applications application å°†æ¶ˆæ¯å‘é€åˆ° socket ä¹‹åï¼Œä¸‹é¢çš„ä¼ è¾“å±‚åè®®å°±è¦è´Ÿè´£å°†æ¶ˆæ¯ä¼ åˆ°å¯¹é¢çš„ socketã€‚å¤§éƒ¨åˆ†çš„ç½‘ç»œæä¾›å¤šç§ä¼ è¾“åè®®ï¼Œä¸åŒçš„åè®®åœ¨å„é¡¹æ€§èƒ½æŒ‡æ ‡ä¸Šå­˜åœ¨å·®å¼‚ï¼Œæˆ‘ä»¬ä¸€èˆ¬ä» reliable data transfer, throughput, timing å’Œ security å››ä¸ªç»´åº¦æ¥è¡¡é‡ä¸€ä¸ªä¼ è¾“åè®®ã€‚\nReliable Data Transfer packet åœ¨ç½‘ç»œä¼ è¾“çš„è¿‡ç¨‹ä¸­å¯èƒ½å› ä¸ºå„ç§åŸå› ä¸¢å¤±ï¼Œå¯¹äºè®¸å¤šåº”ç”¨ (ä¾‹å¦‚ç”µå­é‚®ä»¶ã€ç½‘ç»œé“¶è¡Œç­‰)ï¼Œä¸¢å¤±æ•°æ®ä¼šé€ æˆä¸¥é‡çš„åæœã€‚å¦‚æœä¸€ä¸ªåè®®å¯ä»¥ä¿è¯ä¸€ç«¯å‘å‡ºçš„æ•°æ®å¯ä»¥å®Œæ•´åœ°è¢«å¦ä¸€ç«¯æ¥æ”¶ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç§°è¯¥åè®®æä¾›å¯é æ•°æ®ä¼ è¾“ (reliable data transfer)ã€‚\nå¯¹äºä¸€äº› loss-tolerable çš„åº”ç”¨ï¼Œæ¯”å¦‚å„ç§æµåª’ä½“ï¼Œå®ƒä»¬å°±ä¸å¿…è¦é€‰æ‹©æä¾›å¯é æ•°æ®ä¼ è¾“çš„åè®®ã€‚ä¸¢å¤±ä¸€ç‚¹æ•°æ®å¯èƒ½åªæ˜¯é€ æˆä¸€ç‚¹ç”»é¢å¤±çœŸè€Œå·²ï¼Œå®ƒä»¬æ›´åœ¨ä¹ä¼ è¾“çš„æµç•…åº¦ã€‚\nThroughput ç½‘ç»œçš„æ‹¥å¡ç¨‹åº¦ä¼šå¯¹ä¼ è¾“çš„å®é™…ååç‡äº§ç”Ÿå¾ˆå¤§çš„å½±å“ã€‚æœ‰çš„ä¼ è¾“åè®®å¯ä»¥å‘åº”ç”¨å±‚æä¾› throughput çš„ä¿è¯ï¼Œä¾‹å¦‚æ— è®ºç½‘ç»œå¤šä¹ˆæ‹¥å¡æˆ‘éƒ½ä¿è¯ååç‡ä¸å°äº $r$ bits/secã€‚è¿™æ ·çš„ä¿è¯å¯¹äºä¸€äº› bandwidth-sensitive application åŠå…¶é‡è¦ã€‚å¯¹äºåƒç”µå­é‚®ä»¶ã€æ–‡ä»¶ä¼ è¾“è¿™æ ·çš„ elastic applicationï¼Œå³æ—¶ååç‡çš„ä¿è¯å°±æ— å…³ç´§è¦ã€‚\nTiming ç±»ä¼¼äº throughputï¼Œä¼ è¾“åè®®ä¹Ÿå¯ä»¥æä¾› timing ä¿è¯ï¼Œä¾‹å¦‚ä¿è¯ä¸€ä¸ª bit åœ¨å†™å…¥ socket åå¯ä»¥åœ¨ $t$ sec å†…ä¼ è¾“åˆ°å¦ä¸€ç«¯çš„ socketã€‚è¿™ç§ä¿è¯å¯¹å³æ—¶åº”ç”¨ååˆ†é‡è¦ã€‚\nSecurity ä¼ è¾“åè®®å¯ä»¥æä¾›ä¸€äº›å®‰å…¨æ€§çš„ä¿è¯ï¼Œä¾‹å¦‚åœ¨å‘é€ç«¯å¯¹ä¿¡æ¯åŠ å¯†ï¼Œæ¥æ”¶ç«¯å†å¯¹ä¿¡æ¯è§£å¯†ï¼Œè¿™æ ·ä¸­é€”å³ä½¿è¢«çªƒå¬ä¹Ÿä¸ä¼šæ³„éœ²ç”¨æˆ·éšç§ã€‚\n2.1.4 Transport Services Provided by the Internet å› ç‰¹ç½‘ (æˆ–è€…æ›´ä¸€èˆ¬åœ°ï¼ŒTCP/IP ç½‘ç»œ) æä¾›ä¸¤ç§ä¼ è¾“åè®®ï¼šTCP å’Œ UDPã€‚å½“æˆ‘ä»¬ç¼–å†™ç½‘ç»œåº”ç”¨æ—¶ï¼Œæˆ‘ä»¬éœ€è¦åœ¨è¿™ä¸¤ä¸ªä¼ è¾“åè®®ä¸­åšå‡ºé€‰æ‹©ã€‚\nTCP Services TCP åè®®ä¸ºå‘é€å’Œæ¥æ”¶åŒæ–¹æä¾›å¦‚ä¸‹æœåŠ¡ï¼š\nConnection-oriented service: TCP ä¼šè®©ä¼ è¾“åŒæ–¹åœ¨å¼€å§‹æ­£å¼ä¼ è¾“ä¿¡æ¯ä¹‹å‰å…ˆäº¤æ¢ä¸€äº›æ§åˆ¶ä¿¡æ¯ï¼Œè¿™ä¸ªè¿‡ç¨‹è¢«ç§°ä¸ºæ¡æ‰‹ (handshaking)ã€‚å®Œæˆæ¡æ‰‹åï¼Œä¸¤ä¸ªè¿›ç¨‹çš„ socket ä¹‹é—´ä¼šå»ºç«‹èµ· TCP è¿æ¥ (TCP connection)ã€‚è¿™ä¸ª TCP connection æ˜¯åŒå‘çš„ï¼Œå³ä¸¤ä¸ªè¿›ç¨‹å¯ä»¥åŒæ—¶äº’å‘æ¶ˆæ¯ã€‚æ¶ˆæ¯ä¼ è¾“å®Œæˆåï¼Œè¿›ç¨‹å¿…é¡»é”€æ¯è¿™ä¸ªè¿æ¥ã€‚ Reliable data transfer service: TCP ä¿è¯ä¸€æ–¹å‘é€çš„æ•°æ®ä¼šä¸é‡å¤ä¸ä»¥æ¼åœ°ä¼ è¾“åˆ°å¦ä¸€æ–¹ï¼Œä¸”æ¥æ”¶æ¶ˆæ¯çš„é¡ºåºå’Œå‘é€æ¶ˆæ¯çš„é¡ºåºç›¸åŒã€‚ TCP ä¸­è¿˜æœ‰ä¸€äº›æ‹¥å¡æ§åˆ¶æœºåˆ¶ï¼Œå½“å‘é€æ–¹å’Œæ¥æ”¶æ–¹ä¹‹é—´çš„ç½‘ç»œè¿‡äºæ‹¥å¡æ—¶ï¼ŒTCP ä¼šæš‚æ—¶æŒ‚èµ·å‘é€è¿›ç¨‹ä»¥ç¼“è§£ç½‘ç»œçš„æ‹¥å¡ç¨‹åº¦ã€‚è¯¥æœºåˆ¶å¹¶ä¸æ˜¯ç›´æ¥ä¸ºé€šä¿¡è¿›ç¨‹æœåŠ¡çš„ï¼Œè€Œæ˜¯ä¸ºæ•´ä¸ªäº’è”ç½‘æä¾›çš„ç¦åˆ©ã€‚\nUDP Services UDP æ˜¯ä¸€ä¸ªè½»é‡çº§çš„ä¼ è¾“åè®®ï¼Œå®ƒåªæä¾›æœ€å°‘çš„èƒ½ä¿è¯æ­£å¸¸è¿è½¬çš„æœåŠ¡ã€‚UDP åœ¨å¼€å§‹é€šä¿¡ä¹‹å‰ä¸ä¼šæ¡æ‰‹ï¼›ä¼ è¾“ä¸å…·æœ‰å¯é æ€§ï¼Œå³ä¸èƒ½ä¿è¯å‘é€çš„æ•°æ®ä¸€å®šä¼šè¢«æ”¶åˆ°ï¼›æ­¤å¤–ï¼Œåœ¨ UDP ä¸­å‘é€çš„æ¶ˆæ¯å¯èƒ½ä¼šä¹±åºåœ°åˆ°è¾¾æ¥æ”¶æ–¹ã€‚UDP ä¸­ä¹Ÿæ²¡æœ‰æ‹¥å¡æ§åˆ¶æœºåˆ¶ï¼Œå‘é€æ–¹å¯ä»¥ä»¥ä»»ä½• (ç‰©ç†é™åˆ¶ä»¥å†…çš„) é€Ÿç‡æŠŠæ•°æ®é€å‡ºå»ã€‚\nSecuring TCP\næ— è®ºæ˜¯ TCP è¿˜æ˜¯ UDP éƒ½ä¸ä¼šå¯¹æ•°æ®è¿›è¡Œä»»ä½•åŠ å¯†ï¼Œè¿™ä½¿å¾—ç”¨æˆ·æ•°æ®åœ¨ä¼ è¾“é€”ä¸­éšæ—¶å¯èƒ½è¢«çªƒå–ã€‚å› æ­¤äº’è”ç½‘ç¤¾åŒºæ¨å‡ºäº† TCP çš„ä¸€ä¸ªå¢å¼ºæœåŠ¡ï¼šTransport Layer Security (TLS)ã€‚æœ‰ TLS å¢å¼ºçš„ TCP é™¤äº†å¯ä»¥æä¾› TCP åŸæœ‰çš„æ‰€æœ‰æœåŠ¡ï¼Œè¿˜å¯ä»¥æä¾›ä¸€äº›å®‰å…¨æœåŠ¡ï¼Œä¾‹å¦‚ encryption, data integrity, end-point authentication ç­‰ã€‚\nå€¼å¾—æ³¨æ„çš„æ˜¯ TLS ä¸æ˜¯å’Œ TCP, UDP åŒä¸€çº§åˆ«çš„ä¼ è¾“åè®®ï¼Œå®ƒåªæ˜¯ä¸€ä¸ªâ€œå¢å¼ºæ‰©å±•åŒ…â€ã€‚æƒ³è¦ä½¿ç”¨ TLS éœ€è¦åœ¨å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ç«¯éƒ½å®‰è£… TLS ä»£ç ã€‚TLS æä¾›ä¸€å¥—å’Œ TCP å‡ ä¹ç›¸åŒçš„ API æ¥å£ï¼Œç”¨æˆ·æŠŠä¿¡æ¯ä¼ è¾“ç»™ TLS socket åï¼ŒTLS å¯¹æ•°æ®åšåŠ å¯†ï¼Œç„¶åä¼ ç»™ TCP socketï¼ŒTCP å°†æ•°æ®ä¼ åˆ°å¦ä¸€ç«¯çš„ TCP socket åï¼ŒTCP æŠŠåŠ å¯†æ•°æ®ä¼ ç»™ TLSï¼ŒTLS å®Œæˆè§£å¯†åå°†æ•°æ®é€šè¿‡ TLS socket æä¾›ç»™ä¸Šå±‚åº”ç”¨ã€‚\nServices Not Provided by Internet Transport Protocols å€¼å¾—æ³¨æ„çš„æ˜¯æ— è®ºæ˜¯ TCP è¿˜æ˜¯ UDP éƒ½æ²¡æœ‰æä¾› throughput æˆ– timing çš„ä¿è¯ï¼Œä½†è¿™å¹¶ä¸æ„å‘³ç€å³æ—¶é€šè®¯è½¯ä»¶æ— æ³•åœ¨äº’è”ç½‘ä¸­ä½¿ç”¨ï¼Œå› ä¸ºåº”ç”¨çš„å¼€å‘è€…å°½å¯èƒ½ä¿è¯äº†å®ƒä»¬çš„äº§å“åœ¨ç³Ÿç³•çš„ç½‘ç»œç¯å¢ƒä¸‹ä¹Ÿèƒ½æ­£å¸¸è¿è½¬ã€‚\nå¤§éƒ¨åˆ†çš„ç½‘ç»œåº”ç”¨ (ä¾‹å¦‚ç”µå­é‚®ä»¶ã€æ–‡ä»¶ä¼ è¾“ã€è¿œç¨‹æ§åˆ¶) éƒ½é‡‡ç”¨ TCP åè®®ï¼Œå› ä¸º reliable data transfer å¯¹å®ƒä»¬æ¥è¯´éå¸¸é‡è¦ã€‚ä¸€äº›ç½‘ç»œç”µè¯åº”ç”¨å¯¹æ•°æ®ä¸¢å¤±å®¹å¿åº¦è¾ƒé«˜ï¼Œå¯èƒ½ä¼šé‡‡å– UDP åè®®æ¥ç»•è¿‡ TCP çš„æ‹¥å¡æ§åˆ¶å’Œ packet overheadï¼›ä½†ç”±äºå¾ˆå¤šé˜²ç«å¢™ä¼šæ‹¦æˆªå¤§éƒ¨åˆ†çš„ UDP trafficï¼Œæ‰€ä»¥ç½‘ç»œç”µè¯åº”ç”¨é€šå¸¸ä¼šæŠŠ TCP å½“ä½œ UDP å¤±æ•ˆæ—¶çš„åå¤‡é€‰é¡¹ã€‚\n2.1.5 Application-Layer Protocols ä¹‹å‰æˆ‘ä»¬è®¨è®ºçš„éƒ½æ˜¯ä¸‹å±‚å¦‚ä½•ä¼ è¾“ messageï¼Œä½† message æœ¬èº«çš„ç»“æ„å’Œå†…å®¹ä¹Ÿååˆ†é‡è¦ã€‚åº”ç”¨å±‚åè®® (application-layer protocol) è´Ÿè´£è¿™ä¸€éƒ¨åˆ†ã€‚é€šå¸¸æ¥è¯´åº”ç”¨å±‚åè®®ä¼šå®šä¹‰ï¼š\nmessage çš„ç±»å‹ (request/response etc.)ï¼› å„ç§ç±»å‹çš„ message çš„è¯­æ³•ã€å„ä¸ªå­—æ®µçš„è¯­ä¹‰ï¼› ä¸€ç³»åˆ—è§„åˆ™ï¼Œå®šä¹‰ä¸€ä¸ªè¿›ç¨‹åº”è¯¥ä»€ä¹ˆæ—¶å€™ä»¥ä»€ä¹ˆæ–¹å¼å‘é€ messageã€‚ æˆ‘ä»¬éœ€è¦æ³¨æ„åŒºåˆ†ç½‘ç»œåº”ç”¨å’Œåº”ç”¨å±‚åè®®ï¼šåè€…åªæ˜¯å‰è€…çš„ä¸€ä¸ªç»„æˆéƒ¨åˆ† (ä¸è¿‡æ˜¯å¾ˆé‡è¦çš„ä¸€éƒ¨åˆ†)ã€‚ä»¥ç½‘é¡µä¸ºä¾‹ï¼Œç½‘é¡µè¿™ä¸ªåº”ç”¨åŒ…å«äº†æ–‡æ¡£çš„æ ¼å¼æ ‡å‡† (HTML)ã€ç½‘é¡µæµè§ˆå™¨ã€ç½‘é¡µæœåŠ¡å™¨ï¼Œä»¥åŠåº”ç”¨å±‚åè®®ã€‚ç½‘é¡µæ‰€é‡‡ç”¨çš„ HTTP åè®®è§„å®šäº†æµè§ˆå™¨å’ŒæœåŠ¡å™¨äº¤æ¢æ•°æ®çš„æ–¹å¼ï¼Œåªæ˜¯ç½‘é¡µè¿™ä¸€åº”ç”¨çš„ä¸€ä¸ªç»„æˆéƒ¨åˆ†ã€‚\n2.1.6 Network Applications Covered in This Book æœ¬ä¹¦è®¨è®º 5 ä¸ªé‡è¦çš„åº”ç”¨ï¼šç½‘é¡µã€ç”µå­é‚®ä»¶ã€ç›®å½•æœåŠ¡ã€è§†é¢‘æµå’Œ P2Pã€‚\n2.2 The Web and HTTP åœ¨ 20 ä¸–çºª 90 å¹´ä»£åˆï¼Œå› ç‰¹ç½‘ä»ç„¶åªæ˜¯ä¸€ä¸ªç ”ç©¶å‘˜ã€å­¦è€…ã€é«˜æ ¡å­¦ç”Ÿè¿œç¨‹è¿æ¥ã€ä¼ è¾“æ•°æ®çš„å°åœˆå­ã€‚ä½† World Wide Web è¿™ä¸€åº”ç”¨çš„å‡ºç°è®©å› ç‰¹ç½‘ç«çˆ†å…¨çƒã€‚ç½‘é¡µæœ€å¤§çš„ç‰¹ç‚¹å°±æ˜¯æä¾› on demand çš„æœåŠ¡ï¼Œç”¨æˆ·å¯ä»¥åœ¨ä»»æ„æ—¶åˆ»è·å–ä¿¡æ¯ï¼Œè€Œä¸æ˜¯åƒçœ‹ç”µè§†ï¼Œå¬æ”¶éŸ³æœºé‚£æ ·è¦åœ¨æŒ‡å®šçš„æ—¶é—´å®ˆå€™ã€‚\n2.2.1 Overview of HTTP è¶…æ–‡æœ¬ä¼ è¾“åè®® (HyperText Transfer Protocol, HTTP) æ˜¯ç½‘é¡µä½¿ç”¨çš„åº”ç”¨å±‚åè®®ï¼Œå¤„åœ¨æ•´ä¸ªåº”ç”¨çš„æ ¸å¿ƒä½ç½®ã€‚HTTP åˆ†ä¸ºå®¢æˆ·ç«¯ç¨‹åºå’ŒæœåŠ¡ç«¯ç¨‹åºï¼Œè¿™ä¸¤ä¸ªç¨‹åºé€šè¿‡äº¤æ¢ HTTP message é€šä¿¡ï¼ŒHTTP å®šä¹‰äº† message çš„ç»“æ„å’Œæ¶ˆæ¯äº¤æ¢çš„æ–¹å¼ã€‚\né¦–å…ˆä»‹ç»ä¸€äº›æ¦‚å¿µï¼šä¸€ä¸ª Web page (aka. document) åŒ…å«ä¸€ç³»åˆ—çš„å¯¹è±¡ï¼Œä¸€ä¸ªå¯¹è±¡å°±æ˜¯ä¸€ä¸ªå¯ä»¥é€šè¿‡ URL ç´¢å¼•çš„æ–‡ä»¶ (HTML, JPG, Javascript, CSS ç­‰ç­‰)ã€‚Web page åŒ…å«çš„å¯¹è±¡ä¸­æœ‰ä¸€ä¸ªæ˜¯ base HTML æ–‡ä»¶ï¼Œè¯¥æ–‡ä»¶é€šè¿‡ URL å»ç´¢å¼•åˆ«çš„å¯¹è±¡ã€‚æ¯ä¸ª URL éƒ½æœ‰ host name å’Œ path name ä¸¤ä¸ªéƒ¨åˆ†ã€‚ä¾‹å¦‚\nhttp://www.someSchool.edu/someDepartment/picture.gif ä¸­ www.someSchool.edu æ˜¯ host nameï¼Œ/someDepartment/picture.gif æ˜¯ path nameã€‚\nHTTP è§„å®šçš„ client-server äº¤äº’æ–¹å¼ç®€å•æ¥è¯´å°±æ˜¯ client å‘ server å‘é€ HTTP requestï¼Œserver æ”¶åˆ°åå‘ client å‘é€ HTTP responseã€‚HTTP ä½¿ç”¨ TCP ä½œä¸ºä¸‹å±‚çš„ä¼ è¾“åè®®ï¼Œå› æ­¤ TCP connection å»ºç«‹åï¼Œåœ¨ client çœ¼ä¸­å®ƒåªè¦æŠŠ HTTP request å‘é€åˆ° socketï¼Œç„¶åç­‰ä¸€ä¼šå„¿è¿™ä¸ªâ€œç¥å¥‡çš„å°é—¨â€å°±ä¼šæŠŠ HTTP response å‘ˆç°å‡ºæ¥ï¼›åœ¨ server çœ¼ä¸­å®ƒåªè¦ä» socket ä¸­å–å‡º HTTP requestï¼Œåˆ†æåæŠŠç›¸å…³çš„æ•°æ®ç”¨ socket ä¼ å›å»å³å¯ã€‚è®¡ç®—æœºç½‘ç»œçš„å±‚çŠ¶ç»“æ„ä½¿å¾— HTTP è¿™æ ·çš„é¡¶å±‚åè®®å®Œå…¨ä¸éœ€è¦æ‹…å¿ƒæ•°æ®ä¸¢å¤±ã€é‡æ–°å‘é€ç­‰é—®é¢˜ï¼Œè¿™äº›ç»†èŠ‚éƒ½ç”± TCP ä»¥åŠæ›´ä¸‹æ¬¡å±‚çš„åè®®æ ˆæå®šã€‚\næœåŠ¡å™¨ç«¯ä¸ä¼šå­˜å‚¨ä»»ä½•çš„é¢å¤–ä¿¡æ¯ã€‚ä¾‹å¦‚å¦‚æœ client è¿ç»­ä¸¤æ¬¡è¯·æ±‚åŒä¸€ä¸ªæ–‡ä»¶ï¼Œserver å°±ä¼šè¿ç»­å‘ä¸¤æ¬¡ï¼Œè€Œä¸ä¼šæ™ºèƒ½åœ°åœ¨ç¬¬äºŒæ¬¡å›å¤â€œä½ å·²ç»è¯·æ±‚è¿‡è¿™ä¸ªæ–‡ä»¶äº†â€ã€‚å› æ­¤ HTTP æ˜¯ä¸€ç§æ— çŠ¶æ€åè®® (stateless protocol)ã€‚\n2.2.2 Non-Persistent and Persistent Connections åœ¨è®¸å¤šç½‘ç»œåº”ç”¨ä¸­ client å’Œ server ä¹‹é—´ä¼šè¿›è¡Œå¤šæ¬¡é€šä¿¡ï¼Œäºæ˜¯ä¸€ä¸ªéœ€è¦æ€è€ƒçš„é—®é¢˜æ˜¯åº”è¯¥ä¸ºæ¯ä¸€æ¬¡é€šä¿¡å»ºç«‹ä¸€ä¸ª TCP connection è¿˜æ˜¯ç”¨ä¸€ä¸ª TCP connection å®Œæˆå¤šæ¬¡é€šä¿¡ã€‚å‰è€…è¢«ç§°ä¸º non-persistent connectionï¼Œåè€…è¢«ç§°ä¸º persistent connectionã€‚è¿™ä¸¤è€…å„æœ‰åˆ©å¼Šï¼Œè™½ç„¶ HTTP é»˜è®¤ persistentï¼Œä½† client/server å¯ä»¥é€‰æ‹©å°†å…¶é…ç½®ä¸º non-persistentã€‚\nHTTP with Non-Persistent Connections åœ¨ non-persistent çš„è¿æ¥ä¸­ï¼Œclient å‘ server ç´¢å–ä¸€ä¸ªé¡µé¢ (base HTML + 10 JPG) ä¼šç»å†å¦‚ä¸‹çš„è¿‡ç¨‹ï¼š\nclient ä¸ server å»ºç«‹ TCP connectionï¼Œå¹¶å‘ server å‘é€ HTTP requestã€‚ server æ¥æ”¶åˆ°è¯·æ±‚åï¼Œå°†ç›¸å…³çš„æ–‡ä»¶ä¼ è¾“å›å»ï¼Œå¹¶å‘Šè¯‰ TCP å…³é—­è¿æ¥ (è¿æ¥ä¸ä¼šç›´æ¥å…³é—­ï¼Œä¼šç­‰ client æ¥æ”¶åˆ°æ–‡ä»¶å†å…³é—­)ã€‚ client æ¥æ”¶åˆ°æ–‡ä»¶å (æ­¤æ—¶ connection æ­£å¼å…³é—­)ï¼Œå‘ç° HTML æ–‡ä»¶ä¸­ç´¢å¼•äº† 10 å¼ å›¾ç‰‡ï¼Œäºæ˜¯ç”¨ step1\u0026amp;2 çš„æ–¹å¼å°† 10 å¼ å›¾ç‰‡æ‹¿åˆ°æ‰‹ã€‚ å¯ä»¥çœ‹åˆ°åœ¨ non-persistent connection ä¸­ï¼Œæ¯ä¸ª TCP connection åªèƒ½ä¼ è¾“ä¸€ä¸ªå¯¹è±¡ã€‚ä¸è¿‡ä¸Šè¿°è¿‡ç¨‹ä¹Ÿæœ‰ä¸€äº›ä¼˜åŒ–çš„ç©ºé—´ï¼Œæ¯”å¦‚è·å–å›¾ç‰‡æ—¶ client-server ä¹‹é—´å¯ä»¥å¹¶è¡Œåœ°å¼€å¤šä¸ª connection ä¸€èµ·ä¼ è¾“ï¼Œè¿™æ ·å¯ä»¥èŠ‚çœæ—¶é—´ã€‚\nä¹‹å‰çš„æè¿°ä¸­æˆ‘ä»¬ç®€åŒ–äº†å»ºç«‹è¿æ¥çš„è¿‡ç¨‹ï¼Œäº‹å®ä¸Šå»ºç«‹ TCP connection æœ‰ä¸€å®šçš„ overheadã€‚æˆ‘ä»¬å®šä¹‰ round-trip time (RTT) ä¸ºä¸€ä¸ª packet ä» client åˆ° server å†å›åˆ° client æ‰€éœ€çš„æ—¶é—´ï¼Œclient å’Œ server ä¹‹é—´å®Œæˆä¸€ä¸ªå¯¹è±¡çš„ä¼ è¾“éœ€è¦ç»å†â€œä¸‰æ­¥æ¡æ‰‹â€â€”â€” client å‘ server å‘é€ä¸€ä¸ª segmentã€server å›å¤ä¸€ä¸ª segment (æ­¤æ—¶è¿æ¥å»ºç«‹)ã€client å‘ server å‘é€ requestï¼Œç„¶å server å°†å¯¹è±¡æ–‡ä»¶ä»¥æµæ°´çº¿çš„æ–¹å¼é€šè¿‡ connection å‘é€å›æ¥ã€‚è·å–ä¸€ä¸ªå¯¹è±¡æ€»å…±éœ€è¦çš„æ—¶é—´ä¸º $$ 2\\times RTT+\\frac{Size(object)}{\\text{server\u0026rsquo;s transmission rate}} $$\nHTTP with Persistent Connections å»ºç«‹ persistent connection å¯ä»¥å…å»åˆ›å»ºè¿æ¥çš„ overheadï¼Œè€Œä¸”å¤šæ¬¡ request å¯ä»¥ç”¨æµæ°´çº¿çš„æ–¹å¼å‘é€ï¼Œä¸éœ€è¦ç­‰å‰ä¸€ä¸ª request å¾—åˆ° response åå†å‘é€ä¸‹ä¸€ä¸ªï¼Œå› æ­¤æ•ˆç‡å¾ˆé«˜ã€‚\n2.2.3 HTTP Message Format HTTP Request Message ä¸€ä¸ª HTTP request message çš„é€šç”¨æ ¼å¼å¦‚ä¸‹ï¼š\nmethod URL Version \\r\\n // Request line HeaderFieldName: value \\r\\n /* */ ... /* Header lines */ HeaderFieldName: value \\r\\n /* */ \\r\\n ... /* */ ... /* Entity body */ ... /* */ request message çš„ç¬¬ä¸€è¡Œè¢«ç§°ä¸º request lineï¼Œåç»­çš„è‹¥å¹²è¡Œç§°ä¸º header lineã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªå…·ä½“çš„ä¾‹å­ï¼š\nGET /somedir/page.html HTTP/1.1 Host: www.someschool.edu Connection: close User-agent: Mozilla/5.0 Request line ä¸­ï¼ŒGET æ˜¯ä¸€ä¸ª method (æœ€å¸¸ç”¨)ï¼Œé€šå¸¸ç”¨äºä»æœåŠ¡å™¨è·å–å†…å®¹ï¼›URL æŒ‡å®šäº†æœåŠ¡å™¨ä¸­æ–‡ä»¶çš„è·¯å¾„ï¼›Version æŒ‡å®šäº† HTTP ç‰ˆæœ¬ã€‚Header line ä¸­ï¼ŒHost æŒ‡å®šäº†ä¸»æœºåœ°å€ï¼›Connection: close è¡¨ç¤ºå»ºç«‹ä¸€ä¸ª non-persistent çš„è¿æ¥ï¼Œæœ¬æ¬¡ä¼ è¾“å®Œæˆåå°±å…³é—­ï¼›User-agent æŒ‡å®šäº†å®¢æˆ·ç«¯ (æµè§ˆå™¨) çš„ç‰ˆæœ¬ï¼ŒæœåŠ¡å™¨å¯ä»¥æ ¹æ®ç‰ˆæœ¬è¿”å›æ›´åŠ é€‚é…çš„ message (æ¯”å¦‚åŒä¸€ä¸ªæ–‡ä»¶çš„ä¸åŒç‰ˆæœ¬)ã€‚é™¤æ­¤ä¹‹å¤–è¿˜æœ‰å¾ˆå¤šçš„ header line å¯ä»¥é€‰æ‹©ã€‚\nGET æ–¹æ³•åé¢æ²¡æœ‰ entity bodyï¼Œä½†å…¶ä»–æ–¹æ³•åé¢æ˜¯å¯ä»¥æœ‰ entity body çš„ï¼Œä¾‹å¦‚ POST æ–¹æ³•é€šå¸¸ç”¨äºå¡«å†™ç½‘é¡µä¸­çš„è¡¨æ ¼ï¼Œç”¨æˆ·å¡«å†™çš„å†…å®¹å°±æ”¾åœ¨ entity body ä¸­ä¼ ç»™æœåŠ¡å™¨ã€‚(æ³¨ï¼šå€¼å¾—ä¸€æçš„æ˜¯äº‹å®ä¸Šç°åœ¨å¤§éƒ¨åˆ†çš„åº”ç”¨è¿˜æ˜¯ä½¿ç”¨ GET æ–¹æ³•æ¥ä¼ è¾“å¡«è¡¨ç»“æœï¼Œå®ƒä»¬ä¼šæŠŠå¡«å†™çš„å†…å®¹æ”¾åˆ° URL é‡Œï¼Œæ¯”å¦‚å¡«å†™äº† apple å’Œ bananaï¼Œé‚£ä¹ˆ URL å°±ä¼šå½¢å¦‚ www.somesite.com/fruitsearch?apple\u0026amp;bananaã€‚)\né™¤äº† GET å’Œ POSTï¼ŒHEAD æ–¹æ³•å’Œ GET ç±»ä¼¼ï¼Œä½†æœåŠ¡å™¨ä¸ä¼šè¿”å›è¯·æ±‚çš„å¯¹è±¡ï¼Œé€šå¸¸ç”¨äº debuggingï¼›PUT æ–¹æ³•ç”¨äºå‘æœåŠ¡å™¨ä¸Šä¼ æ–‡ä»¶ï¼›DELETE æ–¹æ³•ç”¨äºåœ¨æœåŠ¡å™¨ä¸­åˆ é™¤æ–‡ä»¶ã€‚\nHTTP Response Message ä¸€ä¸ª HTTP request message çš„é€šç”¨æ ¼å¼å¦‚ä¸‹ï¼š\nversion StatusCode Phrase \\r\\n // Status line HeaderFieldName: value \\r\\n /* */ ... /* Header lines */ HeaderFieldName: value \\r\\n /* */ \\r\\n ... /* */ ... /* Entity body */ ... /* */ Response message çš„ç¬¬ä¸€è¡Œè¢«ç§°ä¸º status lineï¼Œåç»­çš„è‹¥å¹²è¡Œè¢«ç§°ä¸º header lineã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªå…·ä½“çš„ä¾‹å­ï¼š\nHTTP/1.1 200 OK Connection: close Date: Tue, 18 Aug 2015 15:44:04 GMT Server: Apache/2.2.3 (CentOS) Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT Content-Length: 6821 Content-Type: text/html (data data data data data ...) æ‹¬å·ä¸­çš„ (data data ...) è¡¨ç¤º entity body çš„å†…å®¹ (å³ client è¦çš„æ•°æ®)ã€‚\nstatus line ä¸­ï¼ŒHTTP/1.1 è¡¨ç¤ºäº† protocol versionï¼Œ200 OK æ˜¯ status code å’Œå¯¹åº”çš„çŠ¶æ€æè¿°ã€‚å¸¸è§çš„ status code å¦‚ä¸‹ï¼š\n200 OKï¼šè¯·æ±‚æˆåŠŸã€‚ 301 Moved Permanentlyï¼šè¯·æ±‚çš„èµ„æºå·²ç»è¢«æ°¸ä¹…ç§»é™¤ã€‚è¯¥èµ„æºçš„æ–°åœ°å€ä¼šåœ¨ header line åŒºåŸŸä¸­ä»¥ Location: ... çš„å½¢å¼ç»™å‡ºã€‚ 400 Bad Requestï¼šè¯·æ±‚æ— æ³•è§£æã€‚ 404 Not Foundï¼šè¯·æ±‚çš„ä¸œè¥¿ä¸å­˜åœ¨ã€‚ 505 HTTP Version Not Supportedï¼šHTTP åè®®ç‰ˆæœ¬ä¸æ”¯æŒã€‚ header line ä¸­ï¼Œæ¯”è¾ƒæœ‰æ„æ€çš„ä¸€äº› line åŒ…æ‹¬ï¼šConnection: close å‘Šè¯‰ client è¯¥æ¶ˆæ¯ä¼ è¾“å®Œæˆå TCP connection å°±ä¼šè¢«å…³é—­ï¼›Date: ä¸­çš„æ—¥æœŸæŒ‡çš„æ˜¯æœåŠ¡å™¨æ¥æ”¶åˆ°è¯·æ±‚ï¼Œå°†èµ„æºæå–å‡ºæ¥çš„æ—¶é—´ (è€Œä¸æ˜¯æ–‡ä»¶çš„åˆ›å»ºæ—¶é—´)ï¼›Content-Type æŒ‡æ˜äº†è¿”å›æ–‡ä»¶çš„ç±»å‹ï¼Œæ–‡ä»¶çš„ç±»å‹ç”±è¯¥å­—æ®µå†³å®šè€Œä¸ç”±å…¶æ‰©å±•åå†³å®šã€‚\næµè§ˆå™¨çš„ç‰ˆæœ¬ã€ç±»å‹ï¼Œç”¨æˆ·é…ç½®ï¼Œä»¥åŠå½“å‰æœ¬åœ°æ˜¯å¦æœ‰ cached çš„å¯¹è±¡æ—§ç‰ˆæœ¬â€¦â€¦è¿™äº›å› ç´ éƒ½ä¼šå½±å“ client å‘é€ request æ—¶åŒ…å«å“ªäº› header lineï¼Œåœ¨æœåŠ¡å™¨ç«¯å½±å“å› ç´ æ˜¯ç±»ä¼¼çš„ã€‚\n2.2.4 User-Server Interaction: Cookies æˆ‘ä»¬ä¹‹å‰æåˆ° HTTP æ˜¯ä¸€ä¸ª stateless çš„åè®®ï¼Œä½†å¾ˆå¤šæ—¶å€™æœåŠ¡å™¨å¸Œæœ›èƒ½è¯†åˆ«ç”¨æˆ·ä»¥åŠè®°å½•ç”¨æˆ·çš„çŠ¶æ€ï¼Œä»è€Œæä¾›æ›´å¥½çš„æœåŠ¡/å°†ä¸€äº›ç”¨æˆ·å†™å…¥é»‘åå•ã€‚HTTP ä½¿ç”¨ cookie å®Œæˆè¯¥åŠŸèƒ½ã€‚\nCookie æŠ€æœ¯åŒ…å« 4 ä¸ªç»„æˆéƒ¨åˆ†ï¼š(1) HTTP response message ä¸­çš„ cookie header line (2) HTTP request message ä¸­çš„ cookie header line (3) æµè§ˆå™¨è´Ÿè´£ç®¡ç†çš„æœ¬åœ° cookie file (4) æœåŠ¡å™¨ç«¯å­˜å‚¨ cookie ç›¸å…³ä¿¡æ¯çš„æ•°æ®åº“ã€‚ Cookie çš„å·¥ä½œæµç¨‹å¦‚ä¸‹ï¼š\nå‡è®¾ä¸€ä¸ªæ–°ç”¨æˆ·ç¬¬ä¸€æ¬¡è®¿é—®æŸç½‘ç«™ (å‘é€ request message)ï¼Œè¯¥ç½‘ç«™è¯†åˆ«åˆ°è¿™æ˜¯ä¸€ä¸ªæ–°ç”¨æˆ·åï¼Œä¼šåœ¨æ•°æ®åº“ä¸­ä¸ºè¯¥ç”¨æˆ·åˆ›å»ºä¸€ä¸ª cookie idã€åœ¨æ•°æ®åº“ä¸­å­˜å‚¨ä¸€äº›ç”¨æˆ·ç›¸å…³çš„ä¿¡æ¯ï¼Œå¹¶åœ¨ response message ä¸­åŠ å…¥ä¸€æ¡ cookie header lineï¼Œæ ¼å¼ä¸º Set-cookie: cookie-idã€‚ æµè§ˆå™¨å¤„ç† response message å‘ç°å½¢å¦‚ Set-cookie çš„ header line åï¼Œä¼šæŠŠè¯¥æœåŠ¡å™¨åˆ†é…çš„ cookie id å­˜å…¥æœ¬åœ°çš„ä¸€ä¸ª cookie file ä¸­ã€‚ ä¹‹åè¿™ä¸ªç”¨æˆ·å¦‚æœå†è®¿é—®è¯¥ç½‘ç«™ï¼Œæµè§ˆå™¨ä¼šæ£€ç´¢ cookie fileï¼Œå‘ç°æœ‰å¯¹åº”çš„ cookie id åˆ™ä¼šä»¥ Cookie: cookie-id çš„å½¢å¼åœ¨ request message ä¸­æ·»åŠ ä¸€ä¸ª cookie header lineã€‚æœåŠ¡å™¨å¤„ç† request message æ—¶åˆ™å¯ä»¥æ ¹æ® cookie-id åœ¨æ•°æ®åº“ä¸­è°ƒå–è¯¥ç”¨æˆ·ç›¸å…³çš„ä¿¡æ¯ã€‚ å°½ç®¡ Cookie å¯ä»¥ä¼˜åŒ–ç”¨æˆ·çš„ä¸Šç½‘ä½“éªŒï¼Œä½†å…¶åœ¨éšç§æ³„æ¼ä¸Šçš„é—®é¢˜ä¹Ÿä½¿å…¶å€å—äº‰è®®ã€‚\n2.2.5 Web Caching Web cache (ä¹Ÿç§° proxy server) é€šå¸¸ç”± ISP è´­ä¹°å’Œå®‰è£…ï¼Œå…¶ä½œç”¨å’Œè®¡ç®—æœºç³»ç»Ÿä¸­çš„ cache ç±»ä¼¼ï¼šå½“ç”¨æˆ·å¸Œæœ›ä»çœŸæ­£çš„æœåŠ¡å™¨è·å–æ–‡ä»¶æ—¶ï¼Œå®ƒä¼šå’Œ proxy server å»ºç«‹ TCP connectionï¼Œproxy server ä¼šé¦–å…ˆæ£€æŸ¥è‡ªå·±æœ¬åœ°æœ‰æ²¡æœ‰è¯¥æ–‡ä»¶ï¼Œå¦‚æœæœ‰å°±ç›´æ¥ä¼ å›ç»™ç”¨æˆ·ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä¼šä¸çœŸæ­£çš„æœåŠ¡å™¨å»ºç«‹ä¸€ä¸ª TCP connectionï¼Œè·å–æ–‡ä»¶åä¸€æ–¹é¢ä¼ å›ç»™ç”¨æˆ·ï¼Œä¸€æ–¹é¢åœ¨è‡ªå·±æœ¬åœ°ç•™ä¸€ä¸ªå‰¯æœ¬ä»¥ä¾¿åç»­ç”¨æˆ·ç›´æ¥å–ç”¨ã€‚\nWeb cache æœ‰ä¸¤ç‚¹å¥½å¤„ï¼šä¸€æ–¹é¢å®ƒä¸ç”¨æˆ·æœºå™¨å»ºç«‹è¿æ¥ã€ä¼ è¾“æ•°æ®çš„é€Ÿåº¦æ›´å¿«ï¼Œå¯ä»¥ä¼˜åŒ–ç”¨æˆ·çš„ delayï¼›å¦ä¸€æ–¹é¢åœ¨ä¸€ä¸ªå°å±€åŸŸç½‘ä¸­å®‰è£… web cache å¯ä»¥é˜²æ­¢å¤§é‡çš„è¯·æ±‚å¤–æº¢åˆ°å› ç‰¹ç½‘ä¸­ï¼Œä»è€Œå‡å°‘å› ç‰¹ç½‘çš„æµé‡å‹åŠ›ï¼Œå‡å°‘æ•´ä¸ªç½‘ç»œçš„ queuing delay ç­‰ç­‰ã€‚\nThe Conditional GET æ‰€æœ‰çš„ç±» cache ç­–ç•¥éƒ½è¦è€ƒè™‘æ•°æ®ä¸€è‡´æ€§çš„é—®é¢˜ã€‚HTTP åè®®æä¾›äº† conditional GET è¿™ä¸€æœºåˆ¶æ¥ä½¿ cache å®Œæˆå’ŒæœåŠ¡å™¨çš„åŒæ­¥ã€‚å…·ä½“æ¥è¯´ï¼Œå½“ cache å¸Œæœ›ç¡®è®¤è‡ªå·±æ‰‹ä¸Šçš„å‰¯æœ¬æ˜¯å¦æ˜¯æœ€æ–°ç‰ˆæ—¶ï¼Œå®ƒä¼šå‘çœŸæ­£çš„æœåŠ¡å™¨å‘é€ä¸€ä¸ª GET requestï¼Œå…¶ä¸­å¢åŠ ä¸€ä¸ª header lineï¼šIf-modified-since: xxxã€‚æœåŠ¡å™¨æ£€æŸ¥æœ¬åœ°æ–‡ä»¶çš„æœ€åä¿®æ”¹æ—¶é—´ï¼Œå¦‚æœæ­£å¥½åŒ¹é…åˆ™ä¼šè¿”å›ç©ºæ¶ˆæ¯å‘Šè¯‰ cache å‰¯æœ¬å·²æ˜¯æœ€æ–° (status code ä¸º 304 Not Modified)ï¼Œå¦åˆ™ä¼šå°†æ–°ç‰ˆæœ¬ä¼ å›ã€‚\n2.2.6 HTTP/2 2015 å¹´æ ‡å‡†åŒ–çš„ HTTP/2 ç›¸è¾ƒäº HTTP/1.1 çš„ä¸»è¦ä¼˜åŠ¿æ˜¯å®ƒèƒ½å¤Ÿåªä½¿ç”¨ä¸€ä¸ª TCP connection å®Œæˆ response multiplexingã€‚\nHTTP/1.1 é»˜è®¤ä½¿ç”¨ persistent TCP connectionï¼Œå³åªä½¿ç”¨ä¸€ä¸ª TCP connection ä»ä¸€ä¸ªæœåŠ¡å™¨è·å–å¤šä¸ªæ–‡ä»¶ã€‚è¿™æ ·çš„åšæ³•å­˜åœ¨ä¸€ä¸ª Head of Line (HOL) blocking çš„é—®é¢˜ï¼šå‡è®¾å½“å‰ç½‘é¡µçš„ç¬¬ä¸€ä¸ª object æ˜¯ä¸€ä¸ªç‰¹åˆ«å¤§çš„è§†é¢‘ï¼Œåé¢è·Ÿç€çš„æ˜¯ä¸€å †å°çš„ objectï¼Œé‚£ä¹ˆ HTTP/1.1 æŒ‰é¡ºåºä¼ è¾“ä¼šå¯¼è‡´åœ¨ç¬¬ä¸€ä¸ª object ä¸ŠèŠ±è´¹å¾ˆå¤šæ—¶é—´ï¼Œä»è€Œæ•´ä¸ªç½‘é¡µå¾ˆä¹…éƒ½å®Œå…¨æ˜¾ç°ä¸å‡ºæ¥ã€‚ä¸ºäº†ç»•è¿‡è¿™ä¸ªé—®é¢˜ï¼ŒHTTP/1.1 ä¼šå¼€å¾ˆå¤šä¸ª TCP connection æ¥å¹¶è¡Œä¼ è¾“ã€‚ä¸è¿‡å¤šä¸ª TCP connection ä¼šå…±äº«å¸¦å®½ï¼Œè¿™ä½¿å¾—ç½‘ç»œåº”ç”¨ä¼šå°½å¯èƒ½â€œå¤šå¼€ä¸€ç‚¹â€ TCP connection ä»¥å å–æ›´å¤§ä»½é¢çš„å¸¦å®½ (æ¯”å¦‚ä¸¤ä¸ªåº”ç”¨å„å¼€ä¸€ä¸ªï¼Œé‚£ä¹ˆä¸€äººä¸€åŠå¸¦å®½ï¼Œä½†å¦‚æœæœ‰äººæ¶æ„å¼€äº† 10 ä¸ªè¿æ¥ï¼Œä»–å°±èƒ½å æ® 10/11 çš„å¸¦å®½)ã€‚\nHTTP/2 Framing HTTP/2 è§£å†³è¿™ä¸ªé—®é¢˜çš„æ–¹æ³•ç±»ä¼¼äºæ“ä½œç³»ç»Ÿçš„åˆ†æ—¶å¤šä»»åŠ¡ï¼šåœ¨ HTTP/1.1 ä¸­ä¸€ä¸ª response message æ²¡æ³•æ‹†å¼€ï¼Œä½† HTTP/2 å…è®¸å°†ä¸€ä¸ªå¤§çš„ message æ‹†æˆè‹¥å¹²ä¸ª frameï¼Œç„¶åå¤šä¸ª message è½®æµä¸€äººä¸€ä¸ª frame åœ°ä¼ è¾“ï¼Œè¿™æ ·å° message å°±å¯ä»¥å¾ˆå¿«åœ°ä¼ å®Œã€‚\nè¯¥ç­–ç•¥çš„æŠ€æœ¯éš¾ç‚¹æ˜¯å¦‚ä½•å°†å¤§çš„ message æ‹†åˆ†ã€‚HTTP/2 é‡Œä¸“é—¨è®¾è®¡äº†ä¸€ä¸ª framing sub-layerï¼Œè´Ÿè´£ message çš„æ‹†åˆ†å’Œé‡ç»„ã€‚\nResponse Message Prioritization and Server Pushing HTTP/2 åœ¨â€œåˆ†æ—¶å¤šä»»åŠ¡â€çš„åŸºç¡€ä¸Šæ”¯æŒä¸€å®šç¨‹åº¦çš„â€œç”¨æˆ·è‡ªå®šä¹‰â€ï¼Œä¾‹å¦‚ç”¨æˆ·å¯ä»¥ä¸ºå„ä¸ª request è®¾ç½®ä¼˜å…ˆçº§ã€ä¾èµ–å…³ç³»ç­‰ç­‰ã€‚\nHTTP/2 çš„å¦ä¸€ä¸ªç‰¹æ€§æ˜¯å…è®¸ server å¯¹ä¸€ä¸ª request è¿”å›å¤šä¸ª responseã€‚ä¾‹å¦‚ç”¨æˆ·è¯·æ±‚ä¸€ä¸ªç½‘é¡µï¼ŒæœåŠ¡å™¨è‡ªåŠ¨åˆ†æå‘ç°è¿™ä¸ªç½‘é¡µé™„å¸¦ä¸€äº› objectï¼Œå°±å¯ä»¥ response æ—¶ push ä¸€äº›é¢å¤–çš„ object ç»™å®¢æˆ·ç«¯ï¼Œè¿™æ ·åœ¨ç”¨æˆ·å‘å‡º object è¯·æ±‚ä¹‹å‰å°±è¿”å›æ–‡ä»¶ï¼Œçœå»äº†ä¸€äº›å»¶è¿Ÿã€‚\n2.3 Electronic Mail in the Internet ç”µå­é‚®ä»¶ç³»ç»Ÿä¸»è¦ç”±ä¸‰ä¸ªéƒ¨åˆ†ç»„æˆï¼šuser agent, mail server å’Œç®€å•é‚®ä»¶ä¼ è¾“åè®® (Simple Mail Transfer Protocol, SMTP)ã€‚æ¯ä¸ªç”µå­é‚®ä»¶ç”¨æˆ·éƒ½åœ¨è‡ªå·±çš„ mail server ä¸Šæœ‰è‡ªå·±çš„é‚®ç®± (mailbox)ã€‚user agent å¯ä»¥ç†è§£ä¸ºåœ¨ç”¨æˆ·ä¸»æœºä¸Šå’Œè‡ªå·±çš„ mail server äº¤äº’ï¼Œæ“æ§é‚®ç®±çš„è½¯ä»¶ã€‚å‡è®¾ Alice ç»™ Bob å‘é€é‚®ä»¶ï¼Œé¦–å…ˆ Alice çš„ user agent å°†é‚®ä»¶ä¸Šä¼ åˆ° Alice çš„é‚®ç®±ä¸­ï¼Œç„¶å mail server è´Ÿè´£å°†é‚®ä»¶å‘é€åˆ° Bob çš„ mail server (æ›´å‡†ç¡®åœ°è¯´ï¼Œæ˜¯å°†è¯¥é‚®ä»¶ append åˆ° message queue ä¸­ï¼Œç­‰å¾…å‘é€)ï¼ŒBob çš„ mail server æ¥æ”¶åˆ°é‚®ä»¶åå°†å…¶å­˜æ”¾åœ¨ Bob çš„é‚®ç®±ä¸­ã€‚å½“ Bob æ‰“å¼€è‡ªå·±çš„ user agent æŸ¥çœ‹é‚®ä»¶æ—¶ï¼Œuser agent å°†é‚®ä»¶å†…å®¹ä» mail server ä¸ŠæŠ“å–ä¸‹æ¥ã€‚å¦‚æœ Alice çš„ mail server è¿Ÿè¿Ÿæ— æ³•å‘é€æˆåŠŸï¼Œå®ƒåœ¨å°è¯•å¤šæ¬¡åä¼šåˆ é™¤è¿™ä¸ª message å¹¶å‘ Alice è¿”å›å‘é€å¤±è´¥ã€‚\nSMTP åè®®è´Ÿè´£çš„æ˜¯ä¸åŒ mail server ä¹‹é—´ä¼ è¾“çš„éƒ¨åˆ†ã€‚å®ƒä½¿ç”¨ TCP æä¾›çš„ reliable data transfer service ä¼ è¾“é‚®ä»¶ã€‚SMTP æœ‰ client å’Œ server ä¸¤ä¸ªç«¯ï¼Œæ¯ä¸ª mail server æ—¢è¦è¿è¡Œ client ä¹Ÿè¦å®‰è£… serverï¼Œå®ƒå‘é€é‚®ä»¶æ—¶æ˜¯ clientï¼Œæ¥æ”¶é‚®ä»¶æ—¶æ˜¯ serverã€‚\n2.3.1 SMTP SMTP æ˜¯æ¯” HTTP å¤è€å¾—å¤šçš„åº”ç”¨å±‚åè®®ã€‚å› æ­¤å®ƒæœ‰ä¸€äº›â€œè¿‡æ—¶çš„ç‰¹å¾â€ï¼Œä¾‹å¦‚å®ƒè¦æ±‚æ•´ä¸ª mail message éƒ½è¦ä½¿ç”¨ 7-bit çš„ ASCII ç ä¼ è¾“ï¼Œè¿™ä½¿å¾—ä½¿ç”¨ SMTP å‰åéœ€è¦æœ‰ encoding/decoding çš„é¢å¤–æ­¥éª¤ã€‚\nSMTP å·¥ä½œçš„åŸºæœ¬æµç¨‹ä¸ºï¼š\nmail server å°†å¾…å‘é€çš„é‚®ä»¶æ”¾å…¥ message queue åï¼Œå®‰è£…åœ¨ mail server ä¸Šçš„ SMTP å®¢æˆ·ç«¯å‘ç°æœ‰æ–°é‚®ä»¶ï¼Œäºæ˜¯æ ¹æ®å…¶å†…å®¹ä¸ç›®æ ‡åœ°å€å»ºç«‹ TCP connectionï¼Œè¿æ¥ç›®æ ‡æœºå™¨çš„ 25 å·ç«¯å£ã€‚ TCP connection å»ºç«‹ååŒæ–¹ä¼šç»è¿‡ä¸€ä¸ªæ¡æ‰‹è¿‡ç¨‹ï¼Œè¯¥è¿‡ç¨‹ä¸­åŒæ–¹ä¼šäº¤æ¢é‚®ä»¶çš„å‘é€äººã€æ¥æ”¶äººç­‰ä¿¡æ¯ã€‚ æ¡æ‰‹å®Œæˆåï¼Œæ­£å¼å¼€å§‹é‚®ä»¶å†…å®¹çš„ä¼ è¾“ã€‚ ä¸‹é¢æ˜¯ä¸€ä¸ªå…·ä½“çš„ä¾‹å­ï¼š\nS: 220 hamburger.edu C: HELO crepes.fr S: 250 Hello crepes.fr, pleased to meet you C: MAIL FROM: \u0026lt;alice@crepes.fr\u0026gt; S: 250 alice@crepes.fr ... Sender ok C: RCPT TO: \u0026lt;bob@hamburger.edu\u0026gt; S: 250 bob@hamburger.edu ... Recipient ok C: DATA S: 354 Enter mail, end with \u0026quot;.\u0026quot; on a line by itself C: (data) C: (data) C: . S: 250 Mesage accepted for delivery C: QUIT S: 221 hmburger.edu closing connection è¿™é‡Œæ‰€æœ‰çš„è¡Œéƒ½æ˜¯ client/server ç›´æ¥é€šè¿‡ TCP ä¼ è¾“çš„å†…å®¹ã€‚client åœ¨è¿™é‡Œä½¿ç”¨äº† HELO MAIL FROM RCPT TO DATA QUIT ç­‰å‘½ä»¤ï¼Œserver å¯¹äºæ¯æ¡å‘½ä»¤éƒ½ä¼šè¿”å› reply code ä»¥åŠ (optional) ä¸€äº›è‹±æ–‡è§£é‡Šã€‚\nå€¼å¾—æ³¨æ„çš„æ˜¯ SMTP ä½¿ç”¨ persistent TCP connectionï¼Œå³ä¸¤ä¸ª mail server ä¹‹é—´å¯ä»¥é€šè¿‡ä¸€ä¸ª TCP connection ä¼ è¾“å¤šå°é‚®ä»¶ã€‚æ¯å°é‚®ä»¶çš„ä¼ è¾“éƒ½ä» MAIL FROM å¼€å§‹ï¼Œåˆ°ä¼ è¾“å®Œæ•°æ®åçš„ . ç»“æŸã€‚ä¼ è¾“å®Œæ‰€æœ‰é‚®ä»¶å client å†ä½¿ç”¨ QUIT é€€å‡ºã€‚\n2.3.2 Mail Message Formats SMTP å¯¹é‚®ä»¶å†…å®¹çš„æ ¼å¼ä¹Ÿæœ‰ä¸€å®šçš„è¦æ±‚ã€‚ä¸€å°é‚®ä»¶é™¤äº†å…¶ä¸»ä½“å†…å®¹å¤–è¿˜æœ‰è‹¥å¹² header lineï¼Œå…¶ä¸­ From å’Œ To è¿™ä¸¤ä¸ª header line å¿…é¡»æœ‰ï¼ŒSubject ç­‰ header line æ˜¯å¯é€‰çš„ã€‚ä¸€å°å…¸å‹çš„é‚®ä»¶å†…å®¹å¦‚ä¸‹ï¼š\nFrom: alice@crepes.fr To: bob@hamburger.edu Subject: Searching for the meaning of life. (body) (body) (body) ... éœ€è¦æ³¨æ„çš„æ˜¯ä¹‹å‰æåˆ°çš„ MAIL FROM RCPT TO å’Œè¿™é‡Œçš„ From å’Œ To ä¸ä¸€æ ·ï¼šå‰è€…æ˜¯ä¸¤ä¸ª mail server æ¡æ‰‹é˜¶æ®µä½¿ç”¨çš„å‘½ä»¤ï¼Œåè€…æ˜¯é‚®ä»¶æœ¬èº«å†…å®¹çš„ä¸€éƒ¨åˆ†ã€‚\n2.3.3 Mail Access Protocols æœ‰äººè®¤ä¸º Bob (æ¥æ”¶è€…) æ²¡æœ‰å¿…è¦æ‹¥æœ‰ä¸€ä¸ªé¢å¤–çš„ mail serverï¼Œä»–è‡ªå·±çš„ç»ˆç«¯è®¾å¤‡å°±å¯ä»¥æ˜¯ serverï¼Œè¿™æ ·å‘é€è€…ç›´æ¥æŠŠé‚®ä»¶å‘é€åˆ°å®ƒçš„ç»ˆç«¯è®¾å¤‡ä¸Šå°±å¥½ã€‚ä½†ä¸€ä¸ªé—®é¢˜æ˜¯ç”¨æˆ·çš„ç»ˆç«¯è®¾å¤‡å¹¶ä¸ä¸€å®šä¸€ç›´å¤„äºè”ç½‘çŠ¶æ€ (æ¯”å¦‚æ²¡ä¿¡å·ï¼Œæˆ–è€…æ²¡ç”µå…³æœºäº†)ï¼Œè¿™æ ·å‘é€è€…å°±ä¼šå‘é€å¤±è´¥ã€‚å› æ­¤æˆ‘ä»¬æ€»æ˜¯éœ€è¦ä¸€å° 24 å°æ—¶å¾…å‘½çš„æœåŠ¡å™¨è´Ÿè´£æ¥æ”¶é‚®ä»¶ï¼ŒBob åœ¨è‡ªå·± available çš„æ—¶å€™å†å»æŸ¥çœ‹é‚®ä»¶ã€‚\nmail server å‘ mail server å‘é€é‚®ä»¶ä½¿ç”¨ SMTP åè®®ï¼ŒAlice (å‘é€è€…) å‘è‡ªå·±çš„ mail server ä¸Šä¼ é‚®ä»¶ä¹Ÿå¯ä»¥ä½¿ç”¨ SMTP åè®® (æˆ–è€… HTTP) åè®®ï¼Œä½†åœ¨ Bob (æ¥æ”¶è€…) è¿™ä¸€ç«¯ï¼Œä»–ä¸èƒ½ä½¿ç”¨ SMTP åè®®ï¼Œå› ä¸ºä»–éœ€è¦çš„æ˜¯ä¸€ä¸ª pull æ“ä½œï¼Œè€Œ SMTP æ˜¯ä¸€ä¸ª push åè®®ã€‚ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå¦‚æœæ¥æ”¶è€…ä½¿ç”¨ç½‘é¡µç‰ˆçš„ e-mail æˆ–è€…æ‰‹æœºåº”ç”¨ï¼Œuser agent ä¼šä½¿ç”¨ HTTP åè®®æ¥è·å–é‚®ä»¶ï¼›å¦å¤–ä¸€ç§æ–¹å¼ (ä¾‹å¦‚ Microsoft Outlook)ï¼Œåˆ™æ˜¯ä½¿ç”¨ Internet Mail Access Protocol (IMAP) åè®®æ¥è·å–é‚®ä»¶ã€‚è¿™ä¸¤ä¸ªåè®®éƒ½å¯ä»¥è®© Bob å¯¹ä½äº mail server ä¸­çš„è‡ªå·±çš„é‚®ç®±é‡Œçš„å†…å®¹è¿›è¡Œè®¿é—®ã€ä¿®æ”¹ã€æ ‡è®°ç­‰ç­‰ã€‚\n2.4 DNS - The Internet\u0026rsquo;s Directory Service ä¸€å°ä¸»æœºåœ¨ç½‘ç»œä¸­æœ‰å¤šç§â€ç§°å‘¼æ–¹æ³•â€œï¼Œæœ€å¸¸è§çš„ identifier æ˜¯ hostnameï¼Œä¾‹å¦‚ www.facebook.comã€‚hostname å¯¹äººç±»éå¸¸å‹å¥½ï¼Œä½†æä¾›çš„ä¿¡æ¯æœ‰é™ï¼Œå…¶ä¸å›ºå®šçš„é•¿åº¦ä¹Ÿä¸ä¾¿äºè·¯ç”±å™¨å¤„ç†ã€‚å› æ­¤ç½‘ç»œå®ç°ä¸­æ›´æ™®éä½¿ç”¨çš„ identifier æ˜¯ IP åœ°å€ (IP address)ã€‚IP åœ°å€ (IPv4) å…±å  4 ä¸ªå­—èŠ‚ï¼Œç”¨ 4 ä¸ª [0,256) çš„æ•´æ•°è¡¨ç¤ºã€‚IP åœ°å€æœ‰ç€ä¸¥æ ¼çš„ç­‰çº§ç»“æ„ï¼Œå°±åƒ postal address ä¸€æ ·ï¼Œè¶Šå¾€åå¾—åˆ°çš„ä¿¡æ¯è¶Šè¯¦ç»†è¶Šç»†èŠ‚ã€‚\n2.4.1 Services Provided by DNS åŸŸåç³»ç»Ÿ (domain name system, DNS) çš„ä¸»è¦ä»»åŠ¡æ˜¯å°† hostname ç¿»è¯‘æˆå¯¹åº”çš„ IP åœ°å€ã€‚DNS æ˜¯ä¸€ä¸ªåº”ç”¨å±‚åè®®ï¼Œåœ¨æœåŠ¡å™¨ç«¯å®ƒæœ‰ä¸€ç¾¤åˆ†å¸ƒå¼çš„ DNS server å­˜å‚¨åŸŸåä¿¡æ¯ã€‚DNS åè®®åŸºäº UDP è¿è¡Œï¼Œé»˜è®¤ç«¯å£å·æ˜¯ 53ã€‚\nDNS é€šå¸¸è¢« HTTP, SMTP ç­‰å…¶ä»–åº”ç”¨å±‚åè®®ä½¿ç”¨ï¼Œä¾‹å¦‚ HTTP åè®®æƒ³è¦å‘é€ request message æ—¶ï¼Œä¼šå¯åŠ¨ DNS åº”ç”¨çš„å®¢æˆ·ç«¯ï¼Œå°†åŸŸåå‘é€ç»™ DNS serverï¼ŒDNS server è¿”å›å¯¹åº”çš„ IP åœ°å€ï¼Œç„¶å HTTP é€šè¿‡ IP åœ°å€å»ºç«‹ TCP connectionã€‚DNS è§£æçš„æ­¥éª¤æ˜¯é€šä¿¡è¿‡ç¨‹çš„ä¸€ä¸ªé¢å¤–çš„ delayã€‚\né™¤äº†åŸŸåè§£æï¼ŒDNS è¿˜æä¾›ä»¥ä¸‹çš„æœåŠ¡ï¼š\nHost aliasingï¼šä¸€å°æœ‰ç€æ¯”è¾ƒå¤æ‚çš„ hostname çš„æœºå™¨è¿˜å¯ä»¥æœ‰ä¸€äº›æ›´å¥½è®°çš„åˆ«åã€‚åŸæœ¬çš„ hostname ç§°ä¸º canonical hostnameï¼Œåˆ«ååˆ™ç§°ä¸º alias hostnameã€‚DNS æä¾›å°† alias hostname ç¿»è¯‘æˆ canonical hostname (ä»¥åŠ IP åœ°å€) çš„æœåŠ¡ã€‚ Mail server aliasingï¼šå’Œ host aliasing ç±»ä¼¼ï¼Œmail server ä¹Ÿå¯ä»¥æœ‰æ›´å¥½è®°çš„åˆ«åï¼ŒDNS æä¾›ç¿»è¯‘æœåŠ¡ã€‚ Load distributionï¼šæœ‰å¾ˆå¤šç½‘é¡µèƒŒåä¼šä½¿ç”¨ä¸€ç¾¤æœåŠ¡å™¨æ¥æä¾›æ”¯æŒï¼Œæ¯å°æœåŠ¡å™¨æœ‰å„è‡ªçš„ IP åœ°å€ï¼Œä½†å®ƒä»¬å…±äº«ä¸€ä¸ª hostnameã€‚å½“ DNS è§£æè¿™æ ·çš„ hostname æ—¶ï¼Œå®ƒä¼šè¿”å›ä¸€ä¸ª IP åœ°å€çš„ listï¼Œä¸è¿‡æ¯æ¬¡è¯·æ±‚å®ƒè¿”å›çš„ç»“æœéƒ½ä¼š shift ä¸€ä¸‹ï¼Œè¿™æ˜¯å› ä¸ºå¤§éƒ¨åˆ†çš„åè®®é€šå¸¸é€‰æ‹© list çš„ç¬¬ä¸€ä¸ª IP åœ°å€å‘é€è¯·æ±‚ï¼Œæ¯æ¬¡ shift ä¸€ä¸‹å¯ä»¥ä½¿å¾—å„ä¸ªæœåŠ¡å™¨å‡åŒ€åœ°æ‰¿å—æµé‡ã€‚ 2.4.2 Overview of How DNS Works æœ€ç®€å•çš„æƒ³æ³•æ˜¯ä½¿ç”¨ä¸€å° DNS server å¤„ç†æ‰€æœ‰çš„è¯·æ±‚ï¼Œå¯æƒœè¿™æ ·ç®€å•çš„è®¾è®¡è‡³å°‘æœ‰å¦‚ä¸‹çš„ä¸€äº›é—®é¢˜ï¼š\nA single point of failureï¼šåªè¦è¿™å° DNS server æŒ‚äº†ï¼Œå…¨çƒçš„ DNS æœåŠ¡å°±éƒ½æŒ‚äº†ã€‚ Traffic volumeï¼šè¿™å°æœåŠ¡å™¨æ‰¿å—å…¨çƒçš„ DNS request çš„æµé‡ï¼Œä¼šå¯¼è‡´ä¸¥é‡çš„ delayã€‚ Distant centralized databaseï¼šåœ°çƒä¸Šæ€»æœ‰ä¸€äº›åœ°åŒºç¦»è¿™å°æœåŠ¡å™¨å¾ˆè¿œï¼Œè¿™äº›åœ°åŒºä½¿ç”¨ DNS æœåŠ¡ä¼šæœ‰å¾ˆé«˜çš„ delayã€‚ Maintenanceï¼šè¿™ä¸€å°æœåŠ¡å™¨éœ€è¦å¤§å¾—æƒŠäººçš„å®¹é‡æ¥å­˜å‚¨æ‰€æœ‰çš„ IP åœ°å€ï¼Œè¿˜éœ€è¦ä¸æ–­æ›´æ–°ã€‚ å› æ­¤ï¼Œåˆ†å¸ƒå¼æˆä¸ºäº† DNS server å¿…é¡»çš„é€‰æ‹©ã€‚\nA Distributed, Hierarchical Database ä¸ºäº†è§£å†³ä¸Šé¢çš„é—®é¢˜ï¼ŒDNS ä½¿ç”¨äº†å¤§é‡çš„æœåŠ¡å™¨ï¼Œä»¥ hierarchical çš„æ–¹å¼ç»„ç»‡èµ·æ¥åˆ†å¸ƒåœ¨å…¨ä¸–ç•Œã€‚DNS ç­‰çº§ä½“ç³»ä¸­å…±æœ‰ä¸‰ç±»æœåŠ¡å™¨ï¼š\nRoot DNS serverï¼šå…¨çƒå…±æœ‰ 1000 å¤šä¸ªï¼Œå®ƒä»¬æ˜¯ 13 ä¸ªä¸åŒçš„ root server çš„å¤åˆ¶ï¼Œå®ƒä»¬çš„ä¸»è¦ä»»åŠ¡æ˜¯æ ¹æ®é¡¶çº§åŸŸåæä¾›å¯¹åº”çš„ TLD server çš„ IP åœ°å€ã€‚ Top-level domain (TLD) serverï¼šæ¯ä¸€ä¸ªé¡¶çº§åŸŸåâ€”â€”å¦‚ com org net eduï¼Œä»¥åŠå›½å®¶é¡¶çº§åŸŸåâ€”â€”å¦‚ us cn jp fr éƒ½å„è‡ªæœ‰å¯¹åº”çš„ TLD server (æˆ– server cluster)ã€‚å®ƒä»¬çš„ä¸»è¦ä»»åŠ¡æ˜¯æ ¹æ®ä¸‹ä¸€çº§åŸŸåæä¾› authoritative server çš„ IP åœ°å€ã€‚ Authoritative DNS serverï¼šæ¯ä¸€ä¸ªæ¥å…¥å…¬ç½‘çš„ç»„ç»‡éƒ½å¿…é¡»æä¾›å¤–ç•Œå¯è®¿é—®çš„ DNS è®°å½•ï¼Œè¿™äº›è®°å½•ä¿å­˜åœ¨ç»„ç»‡çš„ authoritative DNS server ä¸Šã€‚ é™¤äº†è¿™ä¸‰ç±»æœåŠ¡å™¨ï¼Œè¿˜æœ‰ä¸€ç±»æœåŠ¡å™¨ç§°ä¸º local DNS server (aka. default name server)ï¼Œå®ƒä¸å±äºç­‰çº§ä½“ç³»ä¸­ä½†ä¹Ÿéå¸¸é‡è¦ï¼Œå¯ä»¥ç†è§£ä¸ºä¸»æœºä½¿ç”¨ DNS æœåŠ¡çš„ proxy serverã€‚\nä¸€å°ä¸»æœºé€šè¿‡ DNS æœåŠ¡æŸ¥è¯¢å¦ä¸€å°ä¸»æœºçš„ IP åœ°å€çš„è¿‡ç¨‹å¤§è‡´å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚è¯¥æŸ¥è¯¢è¿‡ç¨‹æ˜¯ iterative + recursive å½¢å¼çš„ã€‚Local DNS server ä½œä¸º requesting server çš„ä»£è¡¨ï¼Œé¡ºåºåœ°å‘å„ä¸ªå±‚çº§çš„ DNS server å‘é€è¯·æ±‚ï¼Œæœ€ç»ˆå°†ç»“æœè¿”å›ç»™ requesting serverã€‚\nè¯¥æŸ¥è¯¢è¿‡ç¨‹ä¹Ÿå¯ä»¥æ˜¯ fully recursive çš„ï¼Œæ¯ä¸€ä¸ªæœåŠ¡å™¨éƒ½æŠŠæ•´ä¸ªä»»åŠ¡äº¤ç»™ä¸‹ä¸€çº§æœåŠ¡å™¨ï¼Œå¹¶å°†æœ€ç»ˆç»“æœè¿”å›ç»™ä¸Šä¸€å±‚æœåŠ¡å™¨ã€‚\nå¯ä»¥çœ‹åˆ°ä¸è®ºæ˜¯å“ªç§é¡ºåºï¼Œåœ¨è¯¥ä¾‹å­ä¸­ requesting server æ€»æ˜¯éœ€è¦ 8 æ¬¡æ¶ˆæ¯ä¼ è¾“æ‰èƒ½è·å¾— IP åœ°å€ï¼Œæ•ˆç‡ä¸é«˜ã€‚\nDNS Caching DNS caching æ˜¯å‡å°‘ DNS æŸ¥è¯¢è¿‡ç¨‹ delay çš„ä¸€é¡¹å…³é”®æŠ€æœ¯ã€‚å„ä¸ªå±‚çº§çš„ DNS server å†…éƒ¨éƒ½æœ‰ cache ç»´æŠ¤hostname åˆ° IP åœ°å€çš„æ˜ å°„è¡¨ã€‚è¿™æ ·å¦‚æœæœ‰å¤šæ¬¡å¯¹åŒä¸€ä¸ª hostname çš„æŸ¥è¯¢ï¼ŒDNS server å°±ä¸ç”¨æŠŠæŸ¥è¯¢ä¸‹æ”¾åˆ°åº•å±‚çš„ authoritative server è€Œå¯ä»¥ç›´æ¥è¿”å›ã€‚ä¸è¿‡ç”±äº hostname çš„ IP åœ°å€æ˜¯å¯ä»¥å˜çš„ï¼Œé€šå¸¸ DNS server ä¸¤å¤©å°±ä¼š flush ä¸€æ¬¡ cacheã€‚\nCache ä¸­é™¤äº†å­˜å‚¨ hostname çš„ IP åœ°å€ï¼Œè¿˜å¯ä»¥å­˜å‚¨ä¸€äº› DNS server çš„ IP åœ°å€ï¼Œè¿™æ ·çš„å¥½å¤„æ˜¯å¯ä»¥ç»•è¿‡ä¸Šçº§ server ç›´æ¥å‘é€æŸ¥è¯¢ç»™ä¸‹å±‚ serverã€‚\n2.4.3 DNS Records and Messages å„çº§ DNS server å®Œæˆäº†å¯¹åˆ†å¸ƒå¼ DNS æ•°æ®åº“çš„æŠ½è±¡ã€‚DNS æ•°æ®åº“ä¸­å­˜å‚¨çš„æ•°æ®ç§°ä¸º resource record (RR)ã€‚ä¸€æ¡ RR æ˜¯ä¸€ä¸ªå››å…ƒç»„ (Name, Value, Type, TTL)ã€‚å…¶ä¸­ TTL è¡¨ç¤ºè¯¥æ•°æ®çš„ç”Ÿå­˜å‘¨æœŸï¼Œå³æœåŠ¡å™¨åº”è¯¥è¿‡å¤šä¹…å°†å…¶ä» cache ä¸­ flush æ‰ã€‚å‰©ä¸‹çš„ä¸‰ä¸ªå±æ€§ï¼š\nè‹¥ Type=Aï¼Œåˆ™ Name æ˜¯ä¸€ä¸ª hostnameï¼ŒValue æ˜¯ä¸€ä¸ª IP åœ°å€ï¼ŒA record æ˜¯ hostname-IP mappingã€‚ è‹¥ Type=NSï¼Œåˆ™ Name æ˜¯ä¸€ä¸ª domainï¼ŒValue æ˜¯ä¿å­˜äº†è¯¥ domain ä¸‹æ‰€æœ‰ host åœ°å€çš„ authoritative server çš„ hostnameã€‚NS record ç”¨äºæŒ‡å¼• DNS server ç»§ç»­æ·±å…¥ query chainã€‚ è‹¥ Type=CNAMEï¼Œåˆ™ Name æ˜¯ä¸€ä¸ª alias hostnameï¼ŒValue ä¿å­˜äº†å¯¹åº”çš„ canonical hostnameã€‚CNAME record ç”¨äº host aliasing çš„ç¿»è¯‘ã€‚ è‹¥ Type=MXï¼Œåˆ™ Name æ˜¯ä¸€ä¸ª mail server çš„åˆ«åï¼ŒValue ä¿å­˜äº†å¯¹åº”çš„ canonical hostnameã€‚MX record ç”¨äº mail server aliasing çš„ç¿»è¯‘ã€‚ å¦‚æœä¸€ä¸ª DNS server æ˜¯æŸä¸ª hostname çš„ authoritative serverï¼Œé‚£ä¹ˆå®ƒé‡Œé¢ä¼šå­˜å‚¨è¯¥ hostname çš„ A recordã€‚å¦‚æœä¸€ä¸ª DNS server ä¸æ˜¯æŸä¸ª hostname çš„ authoritative serverï¼Œé‚£ä¹ˆå®ƒä¼šå­˜å‚¨åŒ…æ‹¬äº†è¯¥ hostname çš„ domain çš„ NS recordï¼Œä»¥åŠä¸€æ¡è®°å½• NS record ä¸­ä¸»æœºçš„ IP åœ°å€çš„ A recordã€‚\nDNS Message DNS message çš„æ ¼å¼å¦‚ä¸‹ï¼š\nIdentification Flags // Number of questions Number of answer RRs // 12 bytes Number of authority RRs Number of additional RRs // ---------------------------------------------------------------------- Questions (variable number of questions) // Name, type field for a query ---------------------------------------------------------------------- Answers (variable number of RRs) // RRs in response to query ---------------------------------------------------------------------- Authority (variable number of RRs) // Records for authoritative servers ---------------------------------------------------------------------- Additional information (variable number of RRs) // Additional info that may be used query å’Œ reply message æœ‰ç€ç›¸åŒçš„æ ¼å¼ï¼š\nheader section å…± 12 ä¸ªå­—èŠ‚ï¼Œç”±ä¸€ç³»åˆ—çš„å­—æ®µç»„æˆã€‚ç¬¬ä¸€ä¸ªå­—æ®µæ˜¯ 16 bit çš„ identifierï¼Œreply message çš„ identifier æ˜¯å¯¹åº” query çš„ identifierï¼Œè¿™æ · client å°±å¯ä»¥æŠŠè¯·æ±‚å’Œå›å¤å¯¹åº”ä¸Šï¼›Flag å­—æ®µåŒ…æ‹¬æŒ‡æ˜è¿™æ˜¯ query è¿˜æ˜¯ reply çš„ flagï¼ŒDNS server æ˜¯å¦æ˜¯ authoritative server çš„ flagï¼Œè¦æ±‚æ˜¯å¦ä½¿ç”¨ recursion çš„ flag ç­‰ã€‚æ­¤å¤–è¿˜æœ‰ 4 ä¸ªè®¡æ•°çš„å­—æ®µã€‚ question section åŒ…å«è¯¢é—®ä¿¡æ¯ï¼Œä¸»è¦æœ‰è¯¢é—®çš„ name å’Œ typeã€‚ answer section ç”± reply message ä½¿ç”¨ï¼ŒåŒ…å«ä¸€æ¡æˆ–å¤šæ¡ resource recordã€‚ authority section åŒ…å«å…¶ä»– authoritative server çš„ recordã€‚ additional section åŒ…å«å…¶ä»–çš„æœ‰ç”¨ä¿¡æ¯ï¼Œæ¯”å¦‚æŸäº› canonical hostname çš„ IP åœ°å€ã€‚ Inserting Records into the DNS Database æƒ³è¦æ–°å»ºç½‘ç«™çš„äººéœ€è¦é€šè¿‡ registrar è·å¾—åŸŸåä¸”éœ€è¦æä¾›è‡ªå·±çš„ hostname å’Œ IP åœ°å€ï¼Œæ•°æ®åº“ç®¡ç†å‘˜è´Ÿè´£å°†æ•°æ®å½•å…¥æ•°æ®åº“ã€‚\nDNS Vulnerabilities\nå¯¹ DNS çš„æ”»å‡»ä¸»è¦æœ‰ä»¥ä¸‹å‡ ç±»ï¼š\nDDoS æ”»å‡»ï¼šå†å²ä¸Šå‘ç”Ÿè¿‡ä¸¤æ¬¡é‡å¤§çš„é’ˆå¯¹ DNS çš„ DDoS æ”»å‡»ï¼šä¸€æ¬¡æ”»å‡»é’ˆå¯¹æ‰€æœ‰çš„ root DNS serverï¼Œç”±äº root server æœ‰è¾ƒå¥½çš„ä¿æŠ¤æœºåˆ¶ï¼Œä¸”å¤§å¤šæ•°çš„ local DNS server çš„ cache å¯ä»¥ç»•è¿‡ root server ç›´æ¥èµ°ä¸‹å±‚ï¼Œæ‰€ä»¥è¯¥æ”»å‡»æ²¡æœ‰å–å¾—å¥½çš„æ•ˆæœã€‚å¦ä¸€æ¬¡æ”»å‡»é’ˆå¯¹ top-level domain DNS serverï¼Œè¿™æ¬¡æ”»å‡»å°±æ¯”è¾ƒæœ‰æ•ˆã€‚ man-in-the-middle attackï¼šæˆªè· DNS queryï¼Œå¹¶è¿”å›ä¸€ä¸ªè™šå‡çš„ reply ç»™ç”¨æˆ·ã€‚ DNS poisoning attackï¼šå’Œä¸­é—´äººæ”»å‡»ç±»ä¼¼ï¼Œä¸è¿‡è¿™ç§æ”»å‡»çš„ç›®çš„æ˜¯å°† DNS server å°†é”™è¯¯çš„ä¿¡æ¯å†™å…¥ cacheï¼Œç›´æ¥æ±¡æŸ“æ•°æ®åº“ã€‚ 2.5 Peer-to-Peer File Distribution å‰é¢ç« èŠ‚ä»‹ç»çš„æ‰€æœ‰åº”ç”¨éƒ½æ˜¯ client-server æ¨¡å¼çš„ï¼Œåº”ç”¨çš„æ­£å¸¸è¿è½¬éœ€è¦ä¸€ç›´å¤„äºè¿è¡ŒçŠ¶æ€çš„æœåŠ¡å™¨ã€‚åœ¨ P2P æ¨¡å¼ä¸­ï¼Œäº’ç›¸è¿æ¥çš„ host å¯ä»¥ç›´æ¥äº¤äº’ï¼ŒèŠ‚çœäº†ä¸€äº› overheadã€‚\nScalability of P2P Architecture è€ƒè™‘å¦‚ä¸‹çš„ä¸€ä¸ªç®€åŒ–çš„åœºæ™¯ï¼šæœ‰ $N$ ä¸ªèŠ‚ç‚¹éœ€è¦æœåŠ¡å™¨ä¸Šçš„ä¸€ä¸ªæ–‡ä»¶ï¼Œè¯¥æ–‡ä»¶çš„å¤§å°ä¸º $F$ bitsã€‚æœåŠ¡å™¨ä¸Šä¼ çš„é€Ÿåº¦æ˜¯ $u_s$ï¼Œç¬¬ $i$ å°å®¢æˆ·æœºä¸‹è½½çš„é€Ÿåº¦æ˜¯ $d_i$ï¼Œä¸Šä¼ çš„é€Ÿåº¦æ˜¯ $u_i$ã€‚\nåœ¨ client-server æ¶æ„ä¸­ï¼Œæ²¡æœ‰äººå¸®åŠ©æœåŠ¡å™¨åˆ†å‘æ–‡ä»¶ï¼Œæ‰€ä»¥ $N$ ä¸ªèŠ‚ç‚¹å…± $NF$ bits çš„æ•°æ®éƒ½è¦ç”±æœåŠ¡å™¨è‡ªå·±ä¸Šä¼ ã€‚æ­¤å¤–æ¯ä¸ªèŠ‚ç‚¹ä¸‹è½½è‡ªå·±çš„æ–‡ä»¶éœ€è¦æ—¶é—´ã€‚å‡è®¾ä¸Šä¼ å’Œä¸‹è½½å¯ä»¥å¹¶è¡Œåœ°å®Œæˆï¼Œä»¤ $d_{min}=\\min\\{d_1,\\cdots, d_n\\}$ï¼Œåˆ™ $$ D_{cs}\\geq \\max\\left\\{\\frac{NF}{u_s},\\frac{F}{d_{min}}\\right\\} $$ åœ¨ P2P æ¶æ„ä¸­ï¼Œä¸€æ–¹é¢ç¬¬ä¸€ä»½æ–‡ä»¶éœ€è¦æœåŠ¡å™¨è‡ªå·±ä¸Šä¼ ï¼Œä¸€æ–¹é¢æ¯ä¸ªèŠ‚ç‚¹ä¸‹è½½è‡ªå·±çš„æ–‡ä»¶éœ€è¦æ—¶é—´ï¼Œä¸€æ–¹é¢æ¯ä¸ªèŠ‚ç‚¹åœ¨ä¸‹è½½çš„åŒæ—¶ä¹Ÿå‚ä¸åˆ°ä¸Šä¼ ä¸­ï¼Œåç»­çš„ä¸Šä¼ å·¥ä½œå¯ä»¥åˆåŠ›å®Œæˆã€‚æ‰€ä»¥ $$ D_{P2P}\\geq \\max\\left\\{\\frac{F}{u_s},\\frac{F}{d_{min}},\\frac{NF}{u_s+\\sum_{i=1}^nu_i}\\right\\} $$ å¯ä»¥è¯æ˜åœ¨ç²¾å·§çš„è®¾è®¡ä¸‹ä¸¤ä¸ªæ—¶é—´éƒ½å¯ä»¥è¾¾åˆ°ä¸‹ç•Œã€‚å¯ä»¥çœ‹åˆ° client-server æ¨¡å¼ä¸‹æ—¶é—´æ˜¯å…³äº $N$ çš„çº¿æ€§å‡½æ•°ï¼Œ P2P æ¨¡å¼ä¸‹æ—¶é—´å…³äº $N$ çš„å‡½æ•°ä¸Šå‡é€Ÿåº¦ç¼“æ…¢ä¸”æœ‰æé™ï¼Œæ‰€ä»¥ P2P æ¨¡å¼çš„ scalability æ›´å¥½ã€‚\nBitTorrent BitTorrent æ˜¯å½“ä¸‹æœ€æµè¡Œçš„ P2P æ–‡ä»¶åˆ†å‘åè®®ä¹‹ä¸€ã€‚è¿™é‡Œç®€å•ä»‹ç»ä¸€äº› BitTorrent çš„æœºç†ã€‚åœ¨ BitTorrent ä¸­å‚ä¸ä¸€ä¸ªæ–‡ä»¶ distribution çš„ peer çš„é›†åˆç§°ä¸ºä¸€ä¸ª torrentã€‚æ¯ä¸ª torrent ä¸­éƒ½æœ‰ä¸€ä¸ªèŠ‚ç‚¹ç§°ä¸º trackerï¼Œä¸€ä¸ªèŠ‚ç‚¹æ–°åŠ å…¥ torrent æ—¶ä¼šåˆ° tracker é‚£é‡Œæ³¨å†Œï¼Œtracker ä¼šæ¯éš”ä¸€æ®µæ—¶é—´æ£€æŸ¥æ¯ä¸ªèŠ‚ç‚¹æ˜¯å¦è¿˜åœ¨ torrent ä¸­å¹¶æ›´æ–° active listã€‚\nå¯¹äºä¸€ä¸ªæ–°åŠ å…¥çš„èŠ‚ç‚¹ï¼Œtracker ä¼šéšæœºé€‰æ‹©ä¸€äº› peer å¹¶å°†å…¶ IP åœ°å€å‘é€ç»™æ–°èŠ‚ç‚¹ï¼Œæ–°èŠ‚ç‚¹ä¼šå°è¯•å’Œè¿™äº› peer å»ºç«‹ TCP connectionï¼ŒæˆåŠŸå»ºç«‹ connection çš„ peer è¢«ç§°ä¸º neighboring peerã€‚ç”±äº torrent ä¸­éšæ—¶ä¼šæœ‰èŠ‚ç‚¹é€€å‡ºä¹Ÿéšæ—¶ä¼šæœ‰æ–°èŠ‚ç‚¹åŠ å…¥ï¼Œä¸€ä¸ªèŠ‚ç‚¹çš„ neighboring peer é›†åˆæ˜¯åŠ¨æ€å˜åŒ–çš„ã€‚\næ–‡ä»¶çš„å…±äº«ä»¥ chunk (256KB) ä¸ºå•ä½ã€‚åœ¨ä»»æ„æ—¶åˆ»ï¼Œä¸€ä¸ªèŠ‚ç‚¹æ‰‹é‡Œä¼šæœ‰è¯¥æ–‡ä»¶çš„æŸäº› chunkï¼Œå®ƒçš„ç›®æ ‡æ˜¯æ”¶é›†è‡ªå·±è¿˜æ²¡æœ‰çš„å…¶ä»– chunkï¼Œæ‰€ä»¥æ¯éš”ä¸€æ®µæ—¶é—´èŠ‚ç‚¹ä¼šå‘è‡ªå·±çš„ neighbor è¯¢é—®ä»–ä»¬æ‰‹é‡Œæ‹¥æœ‰å“ªäº› chunkï¼Œå¹¶æ ¹æ®ä¿¡æ¯å‘ä¸€äº› neighbor å‘é€ç´¢æ±‚ chunk çš„ç”³è¯·ã€‚äºæ˜¯å¯¹äºæ¯ä¸ªèŠ‚ç‚¹æ¥è¯´ï¼Œå®ƒæœ‰ä¸¤ä»¶äº‹æƒ…éœ€è¦è€ƒè™‘ï¼šä¸€æ˜¯åº”å½“å…ˆå»ç´¢è¦å“ªäº› chunkï¼ŒäºŒæ˜¯å¦‚ä½•åº”ä»˜åˆ«çš„èŠ‚ç‚¹å‘é€è¿‡æ¥çš„ requestã€‚\nå¯¹äºç¬¬ä¸€ä¸ªé—®é¢˜ï¼ŒBitTorrent é‡‡å– rarest first çš„ç­–ç•¥ï¼Œå³ä¼˜å…ˆç”³è¯·é‚£äº›è‡ªå·±æ²¡æœ‰çš„ï¼Œä¸”åœ¨ neighbor ä¸­å‡ºç°æ¬¡æ•°æœ€å°‘çš„ chunkã€‚è¿™æ ·çš„å¥½å¤„æ˜¯å¯ä»¥è®©é‚£äº›æ¯”è¾ƒç¨€æœ‰çš„ chunk è¿…é€Ÿåœ¨ç½‘ç»œä¸­ä¼ æ’­å¼€æ¥ï¼Œæé«˜æ–‡ä»¶åˆ†äº«çš„é€Ÿç‡ã€‚\nå¯¹äºç¬¬äºŒä¸ªé—®é¢˜ï¼ŒBitTorrent é‡‡å–äº†ä¸€ä¸ªéå¸¸èªæ˜çš„ trading algorithmï¼Œç§°ä¸º tit-for-tatã€‚æ¯ä¸ªèŠ‚ç‚¹ä¼šå®æ—¶ç»´æŠ¤è‡ªå·±çš„æ‰€æœ‰ neighbor å‘è‡ªå·±ä¼ è¾“æ–‡ä»¶çš„é€Ÿç‡ (æ¯è¿‡ 10s åˆ·æ–°ï¼Œæ›´å‡†ç¡®åœ°è¯´æ˜¯åœ¨ä¸€ä¸ª time interval å†…ä¼ è¾“çš„æ•°æ®é‡)ï¼Œå¹¶é€‰æ‹©æ’åå‰ 4 é«˜çš„èŠ‚ç‚¹å‘å®ƒä»¬å‘é€æ•°æ®ã€‚æ’åå‰ 4 çš„ neighbor è¢«ç§°ä¸º unchokedã€‚æ­¤å¤–æ¯è¿‡ 30s èŠ‚ç‚¹ä¼šéšæœºé€‰æ‹©ä¸€ä¸ªè‡ªå·±çš„ neighbor å¹¶å‘å…¶å‘é€æ•°æ® (ä¸è®ºå…¶æ’åå¦‚ä½•)ï¼Œè¿™ä¸ªèŠ‚ç‚¹è¢«ç§°ä¸º optimistically unchokedã€‚é™¤äº†è¿™ 4+1 ä¸ª neighborï¼Œå‰©ä¸‹çš„ neighbor éƒ½è¢«ç§°ä¸º chokedï¼Œå®ƒä»¬æ— æ³•è·å¾—è¯¥èŠ‚ç‚¹çš„æ•°æ®ã€‚\nunchoked å’Œ optimistically unchoked å„è‡ªæœ‰é“ç†ã€‚unchoked çš„é€‰æ‹©ä½¿å¾—èŠ‚ç‚¹ä¹‹é—´å€¾å‘äºäº’ç›¸å¸®åŠ©äº’æƒ å…±åˆ©ï¼ŒåŒæ—¶ä¸€å®šç¨‹åº¦ä¸Šé¿å…äº†ä¸€äº›åªç´¢å–ä¸ä»˜å‡ºçš„â€œå¸è¡€èŠ‚ç‚¹â€æ¥æ£ä¹±ã€‚optimistically unchoked çš„é€‰æ‹©å¯ä»¥ç†è§£ä¸ºå‘ä¸€ä¸ªâ€œé™Œç”Ÿâ€èŠ‚ç‚¹ç¤ºå¥½ï¼Œå°è¯•ä¸å…¶å»ºç«‹â€œå¤–äº¤å…³ç³»â€ï¼Œå¦‚æœé™Œç”ŸèŠ‚ç‚¹ç§¯æçš„äºˆä»¥åé¦ˆï¼Œé‚£ä¹ˆè¿™å¯¹èŠ‚ç‚¹å°±å¯èƒ½é€æ¸åœ°å°†å¯¹æ–¹å‡çº§ä¸ºè‡ªå·±çš„ top 4ã€‚æ­¤å¤–ï¼Œä¸€ä¸ªåˆšè¿›å…¥ç½‘ç»œçš„èŠ‚ç‚¹æ‰‹é‡Œæ²¡æœ‰ä»»ä½• chunkï¼Œæ— æ³•å‘å¤–ç•Œæä¾›æ•°æ®ï¼Œæ‰€ä»¥åˆšå¼€å§‹ä¸å¯èƒ½æˆä¸ºä»»ä½•èŠ‚ç‚¹çš„ top 4ã€‚optimistically unchoked å¯ä»¥è®©è¿™äº›èŒæ–°èŠ‚ç‚¹å…è´¹è·å¾—ä¸€äº›åˆå§‹æˆæœ¬ï¼Œå¸®åŠ©å…¶å¿«é€Ÿèå…¥ç½‘ç»œã€‚\n2.6 Video Streaming and Content Distribution Networks 2.6.1 Internet Video Video çš„æœ¬è´¨æ˜¯ sequence of imagesï¼Œå…¶æœ€æ˜¾è‘—çš„ç‰¹ç‚¹å°±æ˜¯ high bit rateï¼Œå› æ­¤è§†é¢‘ä¼šæ¶ˆè€—å¤§é‡å­˜å‚¨ï¼Œè§†é¢‘çš„ä¼ è¾“ä¼šæ¶ˆè€—å¤§é‡çš„æµé‡ã€‚å½“ç„¶ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å‹ç¼©æŠ€æœ¯æ¥è·å¾—åŒä¸€ä¸ªè§†é¢‘çš„ä¸åŒç ç‡çš„ç‰ˆæœ¬ï¼Œç ç‡è¶Šé«˜ï¼Œè§†é¢‘è´¨é‡è¶Šé«˜ï¼Œæ¶ˆè€—èµ„æºä¹Ÿè¶Šå¤§ã€‚\n2.6.2 HTTP Streaming and DASH åœ¨ HTTP streaming ä¸­ï¼Œè§†é¢‘æ–‡ä»¶å’Œæ™®é€šçš„æ–‡ä»¶æ— å¼‚ï¼Œæœ‰ä¸€ä¸ªå¯ä»¥ç´¢å¼•çš„ URLã€‚client å¯ä»¥é€šè¿‡ HTTP GET æŒ‡ä»¤æ¥è·å–è§†é¢‘ã€‚ç”±äºè§†é¢‘è¾ƒé•¿è·å–è¾ƒæ…¢ï¼Œé€šå¸¸å®¢æˆ·ç«¯ä¼šå‡†å¤‡ä¸€ä¸ª client application bufferï¼ŒGET æŒ‡ä»¤ä¸æ–­è·å–æ•°æ®å­˜å…¥ bufferï¼Œå½“ buffer ä¸­çš„æ•°æ®é‡è¶…è¿‡ä¸€ä¸ªé˜ˆå€¼æ—¶ï¼Œå®¢æˆ·ç«¯ç¨‹åºå°±ä¼šå¼€å§‹æ’­æ”¾â€”â€”ä» buffer ä¸­æŠ“å– video frameã€è§£å‹ã€å‘ˆç°åœ¨ç”¨æˆ·å±å¹•ä¸Šã€‚è¿™æ ·å®¢æˆ·ç«¯å°±å®ç°äº†è¾¹ä¸‹è½½è¾¹è§‚çœ‹ã€‚\nHTTP streaming çš„ä¸€ä¸ªé—®é¢˜æ˜¯ï¼šæ— è®ºå½“å‰ç”¨æˆ·çš„ç½‘ç»œçŠ¶å†µå¦‚ä½•ï¼Œå®ƒéƒ½åªèƒ½è·å–å›ºå®šç ç‡çš„è§†é¢‘ï¼Œå› æ­¤ç½‘é€Ÿä¸å¥½æ—¶è§†é¢‘æ’­æ”¾å®¹æ˜“å¡é¡¿ã€‚åŠ¨æ€è‡ªé€‚åº”æµåª’ä½“ (Dynamic Adaptive Streaming over HTTP, DASH) æŠ€æœ¯è‡´åŠ›äºç¼“è§£è¯¥é—®é¢˜ã€‚åœ¨ DASH ä¸­ä¸€ä¸ªè§†é¢‘ä¼šæœ‰å¤šä¸ªä¸åŒç ç‡çš„ç‰ˆæœ¬ï¼Œä»¥ä¸åŒçš„ URL å­˜æ”¾åœ¨ server ä¸­ã€‚æ­¤å¤– server é‡Œæœ‰ä¸€ä¸ª manifest file æä¾›äº†å¯é€‰æ‹©çš„ç ç‡ç‰ˆæœ¬å’Œå¯¹åº”çš„ URLã€‚ä¸€ä¸ªå®Œæ•´çš„è§†é¢‘è¢«åˆ’åˆ†æˆäº†è‹¥å¹²å°çš„ chunkï¼Œclient é¦–å…ˆä¼šè·å– manifest fileï¼Œäº†è§£ä¸åŒçš„ç ç‡ç‰ˆæœ¬ï¼Œç„¶åæ ¹æ®å½“å‰çš„ç½‘ç»œçŠ¶å†µé€‰æ‹©ä¸€ä¸ªåˆé€‚çš„ç ç‡ç‰ˆæœ¬ç”¨ HTTP GET è·å–ä¸€ä¸ª chunkï¼Œè·å–çš„è¿‡ç¨‹ä¸­å®¢æˆ·ç«¯åŒæ—¶æ”¶é›†æœ¬æ¬¡è·å–çš„ç½‘é€Ÿç­‰ä¿¡æ¯ï¼Œä»è€Œå†³å®šä¸‹ä¸€ä¸ª chunk é€‰å“ªä¸ªç‰ˆæœ¬ã€‚è¿™æ ·ï¼ŒDASH å…è®¸äº† client åœ¨å¤šä¸ªä¸åŒç‰ˆæœ¬çš„è§†é¢‘ä¸­è‡ªç”±åˆ‡æ¢ã€‚\n2.6.3 Content Distribution Networks Content provider éœ€è¦å»ºç«‹ data center æ¥å­˜å‚¨æä¾›ç»™ç”¨æˆ·çš„è§†é¢‘èµ„æºã€‚æ­£å¦‚ DNS server åªå»ºä¸€ä¸ªæœ‰è¯¸å¤šå¼Šç«¯ï¼Œå¦‚æœæœåŠ¡å•†åªå»ºä¸€ä¸ªè¶…å¤§çš„ data centerï¼Œå°±ä¼šæœ‰éƒ¨åˆ†åœ°åŒºå»¶æ—¶é«˜ã€å•ç‚¹å´©æºƒæ„å‘³ç€å…¨ç›˜å´©æºƒç­‰é—®é¢˜ã€‚å› æ­¤å‡ ä¹æ‰€æœ‰çš„ video-streaming å…¬å¸éƒ½é‡‡ç”¨äº† Content Distribution Network (CDN)ï¼Œå»ºç«‹ä¸€ä¸ªåˆ†å¸ƒå¼çš„æœåŠ¡å™¨ç¾¤ï¼ŒæœåŠ¡å™¨çš„é€‰å€é€šå¸¸æœ‰å¦‚ä¸‹ä¸¤ç§ç­–ç•¥ï¼š\nEnter Deepï¼šå°†æœåŠ¡å™¨æ‰“å…¥åˆ° access network å†…éƒ¨ï¼Œæµ·é‡éƒ¨ç½²å°æœåŠ¡å™¨ï¼Œå°½å¯èƒ½é è¿‘ç”¨æˆ·ä»¥å‡å°ç”¨æˆ·çš„ delay å¹¶æé«˜ throughputã€‚è¿™ç§æ–¹å¼æˆæœ¬å’Œåç»­ç»´æŠ¤çš„ä»£ä»·éƒ½æ¯”è¾ƒé«˜ã€‚ Bring Homeï¼šå»ºç«‹æ•°é‡è¾ƒå°‘è§„æ¨¡è¾ƒå¤§çš„æœåŠ¡å™¨ï¼Œéƒ¨ç½²åœ¨ IXP ä¸­ã€‚è¿™ç§æ–¹å¼ä»£ä»·è¾ƒä½ä½†ç”¨æˆ·ä½“éªŒä¹Ÿç›¸å¯¹è¾ƒå·®ã€‚ é€šå¸¸æ¥è¯´ CDN ä¸ä¼šè®©æ¯å°æœåŠ¡å™¨éƒ½å­˜å‚¨æ‰€æœ‰èµ„æºçš„å‰¯æœ¬ï¼Œè€Œæ˜¯è®©æœåŠ¡å™¨æ‰®æ¼” cache çš„è§’è‰²ã€‚å¦‚æœç”¨æˆ·ç´¢æ±‚çš„èµ„æºåœ¨å½“å‰æœåŠ¡å™¨ä¸­æ²¡æœ‰ï¼ŒæœåŠ¡å™¨ä¼šå‘ä¸Šå±‚åš pull requestï¼Œå¾—åˆ°åå‘é€ç»™ç”¨æˆ·çš„åŒæ—¶åœ¨è‡ªå·±æœ¬åœ°ç•™ä¸€ä¸ªå‰¯æœ¬ã€‚\nCDN Operation è¿™é‡Œä»¥ä¸€ä¸ªä¾‹å­è®²è¿° CDN çš„è¿è¡Œè¿‡ç¨‹ã€‚å‡è®¾ content provider å…¬å¸ NetCinema ä½¿ç”¨äº†ç¬¬ä¸‰æ–¹ CDN å…¬å¸ KingCDN çš„æœåŠ¡ã€‚NetCinema çš„ä¸€ä¸ªè§†é¢‘çš„ URL æ˜¯ video.netcinema.com/abcï¼Œé‚£ä¹ˆç”¨æˆ·è·å–è§†é¢‘çš„æµç¨‹å¦‚ä¸‹ï¼š\nç”¨æˆ·è®¿é—®è¯¥è§†é¢‘é“¾æ¥æ—¶ï¼Œç”¨æˆ·ä¸»æœºå‘å‡ºäº†ä¸€æ¡å…³äº vidio.netcinema.com çš„ DNS requestã€‚ ç”¨æˆ·çš„ Local DNS server (LDNS) ä¸€å±‚å±‚è®¿é—®åˆ° NetCinema å…¬å¸çš„ authoritative server å¹¶å°†å…¶å‘é€è¯·æ±‚ã€‚authoritative server æ³¨æ„åˆ°è¯¥åŸŸåçš„å‰ç¼€æ˜¯ videoï¼ŒçŸ¥é“è§†é¢‘å…¶å®æ˜¯äº¤ç»™ KingCDN æ‰˜ç®¡çš„ï¼Œæ‰€ä»¥å®ƒè¿”å›äº† KingCDN çš„åŸŸåç»™ç”¨æˆ·çš„ LDNSï¼Œä»è€Œå°†ç”¨æˆ· redirect åˆ° KingCDNã€‚ LDNS æ”¶åˆ°äº†ä¸€ä¸ªæ–°åŸŸåï¼Œäºæ˜¯å®ƒå†æ¬¡å‘é€ DNS queryï¼Œä¸€å±‚å±‚è®¿é—®åˆ°äº† KingCDN çš„ authoritative serverï¼Œauthoritative server ä¼šé€‰æ‹©ä¸€ä¸ª CDN server å¹¶å°†å…¶ IP åœ°å€è¿”å›ç»™ LDNSã€‚ LDNS å°† IP åœ°å€ç»™ç”¨æˆ·åï¼Œç”¨æˆ·ä¸»æœºä¸æŒ‡å®šçš„ CDN server å»ºç«‹ TCP connection å¹¶è·å–è§†é¢‘ã€‚ Cluster Selection Strategies ä¸Šè¿°è¿‡ç¨‹ä¸­æœ‰ä¸€æ­¥â€œé€‰æ‹©ä¸€ä¸ª CDN serverâ€ï¼Œè¿™å…¶ä¸­å¾ˆæœ‰è®²ç©¶ã€‚CDN deployment çš„æ ¸å¿ƒä¾¿æ˜¯ cluster selection strategyã€‚CDN çš„ authoritative server æ¥æ”¶åˆ° LDNS çš„ DNS query æ—¶å¯ä»¥è·çŸ¥ç”¨æˆ·çš„ IP åœ°å€ï¼Œä»è€Œè·å¾—ä¸€äº›ç”¨æˆ·ç›¸å…³çš„ä¿¡æ¯ã€‚authoritative server å¯ä»¥æ ¹æ®è¿™äº›ä¿¡æ¯é€‰æ‹©ä¸€ä¸ªâ€œæœ€å¥½â€œçš„ CDN serverã€‚\næœ€ç®€å•å¸¸ç”¨çš„ä¸€ä¸ªç­–ç•¥æ˜¯ geographically closestã€‚åœ°ç†è·ç¦»è¿‘é€šå¸¸æ„å‘³ç€ä¼ è¾“æ—¶é—´çŸ­ï¼Œä½†è¿™ä¸ªç­–ç•¥æœ‰æ—¶ä¸çµå…‰â€”â€”ç¬¬ä¸€ï¼Œåœ°ç†è·ç¦»çŸ­å¹¶ä¸ä¸€å®šæ„å‘³ç€ link å°‘ï¼›ç¬¬äºŒï¼Œæœ‰äº›ç”¨æˆ·çš„ LDNS å’Œç»ˆç«¯è®¾å¤‡ä¹‹é—´å¯èƒ½éš”äº†å¾ˆè¿œï¼›ç¬¬ä¸‰ï¼Œè¯¥ç­–ç•¥å®Œå…¨æ²¡æœ‰è€ƒè™‘ç½‘ç»œçš„åŠ¨æ€çŠ¶å†µã€‚å› æ­¤ï¼Œé™¤äº†è¯¥ç­–ç•¥å¤– CDN è¿˜å¯ä»¥é€šè¿‡ä¸€äº› real-time measurement æ¥å½±å“ CDN server åˆ†é…çš„å†³ç­–ã€‚\n2.6.4 Case Studies: Netflix and YouTube Netflix Netflix çš„ç‰¹è‰²åœ¨äºå®ƒæœ‰ä¸€ä¸ªå·¨å¤§çš„ Amazon cloud å¤„äºæ ¸å¿ƒä½ç½®ï¼ŒAmazon cloud è´Ÿè´£è§†é¢‘çš„å¤„ç†ï¼Œä¸åŒç‰ˆæœ¬çš„ç”Ÿæˆï¼Œå¹¶å°†å†…å®¹æ¨é€åˆ° CDN server ä¸­ã€‚ç”±äº Netflix å»ºç«‹äº†è‡ªå·±çš„ private CDN networkï¼ŒCDN operation çš„æ­¥éª¤ä¸åƒä¸Šä¸€èŠ‚é‚£æ ·æœ‰ä¸€ä¸ª redirect çš„è¿‡ç¨‹ï¼ŒAmazon cloud å¯ä»¥ç›´æ¥æŒ‡å®š CDN serverã€‚æ­¤å¤–ï¼ŒNetflix ä½¿ç”¨çš„æ˜¯ push cacheï¼Œå³ Amazon cloud ä¼šåœ¨éé«˜å³°æ—¶é—´å°†å†…å®¹ä¸»åŠ¨æ¨é€åˆ° CDN server ä¸Šï¼Œè€Œä¸æ˜¯è®© CDN server åŠ¨æ€åœ°åœ¨ cache miss æ—¶ç´¢å–ã€‚\nYouTube ç±»ä¼¼äº Amazon cloudï¼ŒGoogle data center ä¼šå®Œæˆè§†é¢‘çš„å¤„ç†ï¼Œç‰ˆæœ¬ç”Ÿæˆç­‰å·¥ä½œã€‚YouTube ä¹Ÿæœ‰è‡ªå·±çš„ private CDN networkã€‚å’Œ Netflix ä¸åŒçš„åœ°æ–¹åœ¨äºï¼šYouTube ä½¿ç”¨ pull cacheï¼Œä»¥åŠ YouTube ä¸æ”¯æŒ DASHï¼Œåªèƒ½è®©ç”¨æˆ·æ‰‹åŠ¨é€‰æ‹©ç ç‡åä½¿ç”¨ HTTP streamingã€‚\n2.7 Socket Programming: Creating Network Applications ç•¥\n","date":1666310400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1666310400,"objectID":"64927882c3ac1613eaede8e85ab65306","permalink":"https://kristoff-starling.github.io/notes/booknotes/network-topdown/ch02/","publishdate":"2022-10-21T00:00:00Z","relpermalink":"/notes/booknotes/network-topdown/ch02/","section":"notes","summary":"2.1 Principles of Network Applications 2.1.1 Network Application Architectures 2.1.2 Processes Communicating Client and Server Processes The Interface Between the Process and the Computer Network Addressing Processes 2.1.3 Transport Services Available to Applications Reliable Data Transfer Throughput Timing Security 2.","tags":null,"title":"Chapter 2: Application Layer","type":"docs"},{"authors":[],"categories":[],"content":"TF with Sanitizers Address/Memory/UB Sanitizer asan/msan: build fail (GCC/Clang) ubsan: stuck during linking GitHub issue (#50892): \"Currently we don't officially support an OSS ASAN build, although one is in the long term roadmap.\"\nAug 2, 2021\nCompute Sanitizer Don\u0026rsquo;t need additional flags for compilation, even a binary version works (?)\nCommand: compute-sanitizer --tool memcheck python3 test.py\nimport tensorflow as tf _ = tf.config.list_physical_device('GPU') =\u0026gt; terminate w/o error\nimport tensorflow as tf _ = tf.abs(1) =\u0026gt; deadlock\n","date":1665014400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1665014400,"objectID":"e76b6dbbe2109a79aa27398f7cbc9e3c","permalink":"https://kristoff-starling.github.io/slides/20221007/","publishdate":"2022-10-06T00:00:00Z","relpermalink":"/slides/20221007/","section":"slides","summary":"TF with Sanitizers Address/Memory/UB Sanitizer asan/msan: build fail (GCC/Clang) ubsan: stuck during linking GitHub issue (#50892): \"Currently we don't officially support an OSS ASAN build, although one is in the long term roadmap.","tags":[],"title":"Slides","type":"slides"},{"authors":null,"categories":null,"content":" 1.1 Extenional vs. Intensional View of Functions 1.2 The Lambda Calculu 1.3 Untyped v. Typed Lambda-Calculi 1.4 Lambda Calculu and Computability 1.5 Connection to Computer cience 1.6 Connection to Logic 1.1 Extenional vs. Intensional View of Functions æ ¹æ®ç°ä»£æ•°å­¦çš„è§‚ç‚¹ï¼Œå‡½æ•°æ˜¯ä¸€ä¸ªå…³ç³»çš„é›†åˆã€‚ä¸€ä¸ªå‡½æ•° $f:X\\to Y$ æœ‰å®šä¹‰åŸŸ $X$ å’Œå€¼åŸŸ $Y$ï¼Œ$f\\subseteq X\\times Y$ ä¸”å¯¹äºä»»æ„ $x\\in X$ï¼Œ$(x,y_1)\\in f\\wedge (x,y_2)\\in f\\implies y_1=y_2$ã€‚æˆ‘ä»¬å°†è¿™ç§è§‚å¿µç§°ä½œ function as graphã€‚\nä½† 20 ä¸–çºªä»¥å‰å¾ˆå°‘æœ‰äººç”¨è¿™æ ·çš„æ–¹æ³•çœ‹å¾…å‡½æ•°ã€‚æ›´æ—©çš„å…³äºå‡½æ•°çš„æ¦‚å¿µæ›´å¤šæ˜¯ function a ruleï¼Œå³æˆ‘ä»¬åº”å½“é€šè¿‡ç»™å‡ºè§£æå¼çš„æ–¹å¼æ¥å®šä¹‰ä¸€ä¸ªå‡½æ•°ã€‚ä¸¤ä¸ªå‡½æ•° extensionally equal å½“ä¸”ä»…å½“å®ƒä»¬çš„ input-output behavior å®Œå…¨ç›¸åŒï¼›ä¸¤ä¸ªå‡½æ•° intensionally equal å½“ä¸”ä»…å½“å®ƒä»¬çš„è§£æå¼ä¸€æ ·ã€‚\nåœ¨æ•°å­¦ç•Œäººä»¬æ™®éè®¤ä¸º function a graph çš„è§‚å¿µæ›´åŠ ç®€æ´ï¼Œå› ä¸ºå®ƒæ›´è§¦åŠå‡½æ•°çš„æœ¬è´¨â€”â€”æœ‰ä¸€äº›å‡½æ•°æ˜¯æ— æ³•å†™å‡ºè§£æå¼çš„ã€‚ä½†åœ¨è®¡ç®—æœºç§‘å­¦ä¸­äººä»¬æ›´å–œæ¬¢ä½¿ç”¨ function as ruleï¼Œå› ä¸ºè®¡ç®—æœºæ˜¯ä¸€é¡¹å…·ä½“çš„å·¥ç¨‹ï¼Œæˆ‘ä»¬ä¸ä»…åœ¨æ„å‡½æ•°çš„å¤–åœ¨è¡Œä¸ºï¼Œè¿˜å¿…é¡»å…³æ³¨ä¸€ä¸ªå‡½æ•°åº”å½“å¦‚ä½•è®¡ç®—ï¼Œè®¡ç®—å®ƒæœ‰å¤šå°‘å¼€é”€ç­‰ç­‰ã€‚\n1.2 The Lambda Calculu Lambda calculu æ˜¯ä¸€é—¨å…³äº functions as formulas çš„ç†è®ºï¼Œå…¶æ ¸å¿ƒåœ¨äºå°†å‡½æ•°è¡¨ç¤ºæˆç®€å•çš„è¡¨è¾¾å¼ã€‚å®ƒçš„ç®€æ´ä¹‹å¤„åœ¨äºï¼Œæˆ‘ä»¬å¯ä»¥å°† \u0026ldquo;Let $f$ be the function that maps $x$ to $x^2$, then consider $A=f(5)$\u0026rdquo; è¿™å¥è¯å†™æˆï¼š $$ A = (\\lambda x.x^2)(5). $$ å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œä¸Šå¼ä¸­çš„ $x$ æ˜¯ä¸€ä¸ªâ€œå±€éƒ¨å˜é‡â€ï¼Œå®ƒåªç”¨äºæè¿°å‡½æ•°çš„è¡Œä¸ºï¼ŒæŠŠå®ƒæ¢æˆ $\\lambda y.y^2$ æ²¡æœ‰ä»»ä½•åŒºåˆ«çš„ã€‚è¿™æ ·çš„å˜é‡ç§°ä¸º bound variableã€‚\nLambda notation çš„ä¸€å¤§ä¼˜åŠ¿åœ¨äºå®ƒå¯ä»¥éå¸¸è½»æ¾åœ°è¡¨è¾¾é«˜é˜¶å‡½æ•°ã€‚æ¯”å¦‚å°† $f$ æ˜ å°„åˆ° $f\\circ f$ å¯ä»¥è¿™æ ·å†™ï¼š $$ \\lambda f.\\lambda x.f(f(x)). $$\n1.3 Untyped v. Typed Lambda-Calculi å½“æˆ‘ä»¬ç”¨ function a rules çš„è§‚ç‚¹æ¥çœ‹å¾…å‡½æ•°æ—¶ï¼Œæˆ‘ä»¬ä¸é‚£ä¹ˆåœ¨æ„å‡½æ•°çš„å®šä¹‰åŸŸå’Œå€¼åŸŸã€‚æ¯”å¦‚å‡½æ•° $f=\\lambda x.x$ã€‚åªè¦å®šä¹‰åŸŸå’Œå€¼åŸŸä¸€æ ·è¿™ä¸ªå‡½æ•°æ€»æ˜¯æœ‰æ„ä¹‰çš„ã€‚æˆ‘ä»¬å¯ä»¥è¯´ $\\text{type}(f)=X\\to X$ã€‚ä¸€ä¸ªç¨å¤æ‚çš„ä¾‹å­æ˜¯ $g=\\lambda f.\\lambda x.f(f(x))$ï¼Œæˆ‘ä»¬å¯ä»¥è®¤ä¸ºç»™ $g$ ä¼ é€’ä¸€ä¸ª $X\\to X$ ç±»å‹çš„å‡½æ•°ä½œä¸ºå‚æ•°ï¼Œå®ƒä¼šè¿”å› $X\\to X$ ç±»å‹çš„å‡½æ•°ï¼Œæ‰€ä»¥ $\\text{type}(g)=(X\\to X)\\to(X\\to X)$ã€‚\nLambda Calculu è‡ªç”±çš„å®šä¹‰åŸŸå€¼åŸŸå¯ä»¥è®©æˆ‘ä»¬åšåˆ°ä¸€äº›æ›´ç¥å¥‡çš„äº‹æƒ…ï¼Œæ¯”å¦‚è‹¥ $f=\\lambda x.x$ï¼Œé‚£ä¹ˆ $f(f)=f$ã€‚è¿™ä»¶äº‹åœ¨æ™®é€šçš„æ•°å­¦ä¸­æ˜¯åšä¸åˆ°çš„ï¼Œå› ä¸ºç½—ç´ æ‚–è®ºçš„åŸå› ï¼Œä¸€ä¸ªå‡½æ•°è‡ªå·±ä¸å¯èƒ½åœ¨è¯¥å‡½æ•°çš„å®šä¹‰åŸŸä¸­ã€‚\nä¸€ä¸ªæœ‰è¶£çš„é—®é¢˜\nä»¤ $\\omega=\\lambda x.x(x)$ï¼Œé‚£ä¹ˆ $\\omega(\\omega)$ æ˜¯ä»€ä¹ˆï¼Ÿ $$ \\begin{align} \\omega(\\omega)\u0026amp;=(\\lambda x.x(x))(\\omega)\\\\ \u0026amp;=(x(x))[x/\\omega]\\\\ \u0026amp;=\\omega(\\omega) \\end{align} $$ è¯¥è¡¨è¾¾å¼ä¸å­˜åœ¨ normal formã€‚\nåœ¨ type æ–¹é¢ lambda calculu åˆ†æˆä»¥ä¸‹å‡ ç±»ï¼š\nUntyped lambda calculuï¼šä»ä¸å¯¹ä»»ä½•å‚æ•°çš„ç±»å‹è¿›è¡ŒæŒ‡å®šï¼Œåœ¨éå¸¸è‡ªç”±çš„åŒæ—¶å¼•å…¥äº†ä¸€äº›ä¸å®‰å…¨çš„å› ç´  (æ¯”å¦‚å‡½æ•°å¯èƒ½ä¼šæ— æ³•è¯†åˆ«è¾“å…¥å‚æ•°)ã€‚ imply-typed lambda calculusï¼šä¸ºæ¯ä¸ªå‚æ•°éƒ½å®Œæ•´åœ°æŒ‡å®šå…·ä½“çš„ç±»å‹ï¼Œè¿™æ ·æˆ‘ä»¬çš„å‡½æ•°å°±å’Œé›†åˆè®ºä¸­çš„å‡½æ•°åŸºæœ¬æ²¡æœ‰åŒºåˆ«ï¼Œ$f(f)$ è¿™æ ·çš„ä¸œè¥¿ä¸ä¼šå‡ºç°ã€‚ Polymorphically typed lambda calculuï¼šä»‹äºå‰ä¸¤è€…ä¹‹é—´ï¼Œåœ¨æŒ‡å®šç±»å‹çš„æ—¶å€™å…è®¸å¤šæ€ï¼Œæ¯”å¦‚ $X\\to X$ è¿™æ ·çš„ç±»å‹ã€‚ 1.4 Lambda Calculu and Computability Computability æ˜¯ä¸€ä¸ªå¤è€çš„é—®é¢˜ï¼šç»™å®šä¸€ä¸ªå‡½æ•° $f:X\\to X$ï¼Œæˆ‘ä»¬å¦‚ä½•åˆ¤å®šå®ƒæ˜¯å¦æ˜¯å¯è®¡ç®—çš„ï¼Ÿä¸åŒçš„ç ”ç©¶è€…ç»™å‡ºäº†ä¸åŒçš„å®šä¹‰æ–¹æ³•ï¼š\nTurningï¼š å®šä¹‰å›¾çµæœºï¼Œå¹¶å®šä¹‰ä¸€ä¸ªå‡½æ•°å¯è®¡ç®—å½“ä¸”ä»…å½“å®ƒåœ¨å›¾çµæœºä¸Šå¯ä»¥å¾—åˆ°ç»“æœã€‚ Godelï¼šå®šä¹‰äº†ä¸€ä¸ªé›†åˆ general recurive functionï¼Œå¹¶å®šä¹‰ä¸€ä¸ªå‡½æ•°å¯è®¡ç®—å½“ä¸”ä»…å½“å®ƒåœ¨è¿™ä¸ªé›†åˆä¸­ã€‚ Churchï¼šå®šä¹‰äº† lambda calculuï¼Œå¹¶å®šä¹‰ä¸€ä¸ªå‡½æ•°å¯è®¡ç®—å½“ä¸”ä»…å½“å®ƒå¯ä»¥è¢«å†™ä¸ºä¸€ä¸ª lambda termã€‚ åæ¥äººä»¬è¯æ˜ï¼šè¿™ä¸‰ç§å®šä¹‰æ˜¯ç­‰ä»·çš„ï¼Œè¿™å°±æ˜¯è‘—åçš„ Church-Turning theisã€‚\n1.5 Connection to Computer cience lambda calculu æ˜¯ä¸€ç§éå¸¸ç†æƒ³åŒ–çš„ç¼–ç¨‹è¯­è¨€ï¼Œä¹Ÿæ˜¯æœ€ç®€å•çš„æ»¡è¶³ Turning-complete çš„ç¼–ç¨‹è¯­è¨€ã€‚å®ƒå¸¸å¸¸ç”¨æ¥å®šä¹‰å’Œè¯æ˜ç¨‹åºç›¸å…³çš„æ€§è´¨ã€‚å‡ ä¹æ‰€æœ‰çš„å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ (Lisp, Haskell, Scheme etc.) éƒ½æ˜¯åœ¨ lambda calculus çš„åŸºç¡€ä¸Šï¼Œå¢æ·»äº†ä¸€äº›è‡ªå·±çš„åŠŸèƒ½ã€‚\n1.6 Connection to Logic åœ¨ 19 ä¸–çºªåˆ° 20 ä¸–çºªåˆæœŸï¼Œæ•°å­¦å®¶å¯¹è¯æ˜çš„æœ¬è´¨æœ‰è¿‡ä¸€åœºäº‰è®ºã€‚ä¸€ä¸ªæµæ´¾æ˜¯æ‰€è°“çš„ contructivistï¼Œä»–ä»¬è®¤ä¸ºè¯æ˜ä¸€ä¸ªä¸œè¥¿å­˜åœ¨å°±å¿…é¡»æ˜¾å¼åœ°å°†å…¶æ„é€ å‡ºæ¥ï¼›å¦ä¸€ä¸ªæµæ´¾æ˜¯ classical logiciansï¼Œä»–ä»¬è®¤ä¸ºåªè¦èƒ½ä»ä¸€ä¸ªä¸œè¥¿ä¸å­˜åœ¨è¿™ä¸ªå‘½é¢˜å‡ºå‘å¯¼å‡ºçŸ›ç›¾å³å¯ï¼Œä¸ä¸€å®šè¦ç»™å‡ºæ„é€ ã€‚\nå¯¹äº contructivist æ¥è¯´ï¼Œä¸€æ®µè¯æ˜å¿…é¡»æ˜¯ä¸€ä¸ªæ„é€ ï¼Œæˆ–è€…è¯´ä¸€ä¸ªç¨‹åºã€‚lambda calculus å°±æ˜¯è¡¨è¾¾è¿™ç§æ„é€ çš„ä¸€ä¸ªç¬¦å·ç³»ç»Ÿã€‚constructivist å¹¶æ²¡æœ‰æˆä¸ºä¸»æµï¼Œä½†æ„é€ æ€§çš„è¯æ˜æœ‰å…¶ç‹¬ç‰¹çš„ä»·å€¼ã€‚ç›¸è¾ƒäºåè¯æ³•ï¼Œæ„é€ æ€§è¯æ˜ä¸­æå‡ºçš„æ„é€ æ–¹æ³•å¯ä»¥å¯¹å¤šä¸ªé¢†åŸŸæä¾›å¸®åŠ©ã€‚\n","date":1664928000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1664928000,"objectID":"10de94d5dc2d00512909a528250fbf4d","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-formal-semantics/material/lambda-calculus/ch01/","publishdate":"2022-10-05T00:00:00Z","relpermalink":"/notes/coursenotes/nju-formal-semantics/material/lambda-calculus/ch01/","section":"notes","summary":"1.1 Extenional vs. Intensional View of Functions 1.2 The Lambda Calculu 1.3 Untyped v. Typed Lambda-Calculi 1.4 Lambda Calculu and Computability 1.5 Connection to Computer cience 1.6 Connection to Logic 1.","tags":null,"title":"Chapter 01: Introduction","type":"docs"},{"authors":null,"categories":null,"content":" 2.1 Syntax 2.2 Free and Bound Variable, $\\alpha$-Equivalence 2.3 Substitution 2.4 Introduction to $\\beta$-Reduction 2.5 Formal Definitions of $\\beta$-reduction and $\\beta$-equivalence 2.1 Syntax $\\fbox{Definition}$ (lambda term) åœ¨ä¸€ä¸ªæ— é™çš„å˜é‡é›†åˆ $V$ ä¸‹ (å°†å…¶ä¸­çš„å˜é‡å‘½åä¸º $x,y,z\u0026hellip;$)ï¼Œlambda term å¯ä»¥ç”±å¦‚ä¸‹çš„ BNF èŒƒå¼å®šä¹‰ï¼š $$ \\text{Lambda terms:}\\quad M,N::=x|(M\\space N)|(\\lambda x.M) $$ ä¸Šé¢çš„ä¸‰ç§å½¢å¼åˆ†åˆ«è¢«ç§°ä¸º variable, application å’Œ lambda abstractionã€‚\nä¹¦å†™ lambda è¡¨è¾¾å¼çš„ä¸€äº› conventionï¼š\næœ€å¤–å±‚çš„æ‹¬å·å¯ä»¥çœç•¥ã€‚ application æ˜¯å·¦ç»“åˆçš„ï¼Œå³ $M\\space N\\space P$ æŒ‡çš„æ˜¯ $(M\\space N)\\space P$ã€‚ lambda abstraction çš„å‡½æ•°ä½“å‘å³æå¤§å»¶ä¼¸ï¼Œå³ $\\lambda x.M\\space N$ æŒ‡çš„æ˜¯ $\\lambda x.(M\\space N)$ è€Œä¸æ˜¯ $(\\lambda x. M)\\space N$ã€‚ å¤šä¸ª lambda abstraction å¯ä»¥åˆå¹¶äº†å†™ï¼Œä¾‹å¦‚ $\\lambda xyz.M$ å’Œ $\\lambda x.\\lambda y.\\lambda z. M$ ç­‰ä»·ã€‚ 2.2 Free and Bound Variable, $\\alpha$-Equivalence è‡ªç”±å˜é‡çš„å½’çº³å®šä¹‰ï¼šä»¤ $FV(M)$ è¡¨ç¤º $M$ è¿™ä¸ª lambda term ä¸­çš„è‡ªç”±å˜é‡çš„é›†åˆï¼Œåˆ™ $$ \\begin{align} \u0026amp;FV(x)=\\{x\\}\\\\ \u0026amp;FV(M\\space N)=FV(M)\\cup FV(N)\\\\ \u0026amp;FV(\\lambda x.M)=FV(M)-\\{x\\} \\end{align} $$ ä¾‹å¦‚ $\\lambda x.N$ ä¸­çš„ $x$ å°±æ˜¯ bound variableï¼Œ$\\lambda x$ è¢«ç§°ä¸º binderï¼Œ$N$ è¢«ç§°ä¸ºè¯¥å‡½æ•°çš„ scopeã€‚\nåœ¨å®šä¹‰ $\\alpha$-equivalence ä¹‹å‰ï¼Œæˆ‘ä»¬è¦å…ˆç»™å‡ºå˜é‡æ¢åçš„å½’çº³å®šä¹‰ï¼š $$ \\begin{align} x\\{y/x\\}\u0026amp;\\triangleq y\\\\ z\\{y/x\\}\u0026amp;\\triangleq z,\\qquad\\qquad\\qquad\\qquad\\qquad\\text{ if }z\\neq x\\\\ (M\\space N)\\{y/x\\}\u0026amp;\\triangleq (M\\{y/x\\})(N\\{y/x\\})\\\\ (\\lambda x.M)\\{y/x\\}\u0026amp;\\triangleq (\\lambda y.M\\{y/x\\})\\\\ (\\lambda z.M)\\{y/x\\}\u0026amp;\\triangleq (\\lambda z.M\\{y/x\\})\\qquad\\qquad\\quad \\text{ if }z\\neq x \\end{align} $$ $\\fbox{Definition}$ ($\\alpha$-equivalence) å¯¹äºä»»æ„ lambda term $M$ å’Œå˜é‡ $y$ï¼Œ$\\alpha$-equivalence æŒ‡ $$ \\frac{y\\notin M}{\\lambda x.M=_{\\alpha}\\lambda y.M\\{y/x\\}} $$\n2.3 Substitution ä¸Šä¸€èŠ‚ä¸­æˆ‘ä»¬ç»™å‡ºçš„æ˜¯å˜é‡æ¢åçš„è§„åˆ™ï¼Œå³å°†ä¸€ä¸ªå˜é‡è½¬åŒ–æˆå¦ä¸€ä¸ªå˜é‡ï¼Œè¿™ä¸€èŠ‚æˆ‘ä»¬ç»™å‡ºå˜é‡æ›¿æ¢çš„è§„åˆ™ã€‚å˜é‡æ›¿æ¢å¯ä»¥å°†ä¸€ä¸ªå˜é‡æ¢æˆä»»æ„ä¸€ä¸ª lambda termã€‚å˜é‡æ›¿æ¢å’Œå˜é‡æ¢åç±»ä¼¼ï¼Œä½†è¦æ³¨æ„ä¸¤ç‚¹ï¼š\næˆ‘ä»¬åªå¯¹ free variable è¿›è¡Œæ›¿æ¢ï¼Œscope ä¸­çš„ bound variable ä¸èƒ½æ¢ã€‚ è¦å°å¿ƒ unintended captureï¼Œå³å¦‚æœå½“å‰çš„æ–° term é‡Œå‡ºç°äº†æŸä¸ª bound variableï¼Œæˆ‘ä»¬éœ€è¦å…ˆå¯¹ bound variable è¿›è¡Œä¸€æ¬¡å˜é‡æ¢åã€‚ å…·ä½“çš„è§„åˆ™å¦‚ä¸‹ï¼š $$ \\begin{align} x[N/x]\u0026amp;\\triangleq N\\\\ y[N/x]\u0026amp;\\triangleq y\\\\ (M\\space P)[N/x]\u0026amp;\\triangleq (M[N/x])(P[N/x])\\\\ (\\lambda x.M)[N/x]\u0026amp;\\triangleq \\lambda x.M\\\\ (\\lambda y.M)[N/x]\u0026amp;\\triangleq \\lambda y.(M[N/x])\\qquad\\qquad \\text{if }x\\neq y\\text{ and }y\\neq FV(N)\\\\ (\\lambda y.M)[N/x]\u0026amp;\\triangleq \\lambda y\u0026rsquo;.(M\\{y\u0026rsquo;/y\\}[N/x])\\quad \\text{if }x\\neq y,y\\in FV(N) \\text{ and }y\u0026rsquo; \\text{ fresh} \\end{align} $$\n2.4 Introduction to $\\beta$-Reduction Conventionï¼šä»ç°åœ¨èµ·æˆ‘ä»¬ä¸å†å…³æ³¨ bound variable æ˜¯å¦ç›¸åŒï¼Œå½“æˆ‘ä»¬è¯´ $M=N$ æ—¶ï¼Œæˆ‘ä»¬æŒ‡çš„æ˜¯å®ƒä»¬åœ¨ $\\alpha$-equivalence è¿™ä¸ªå…³ç³»ä¸‹å±äºåŒä¸€ä¸ªç­‰ä»·ç±»ã€‚\nå°†å‡½æ•°çš„å‚æ•°å–å€¼ä»£å…¥å‡½æ•°çš„è¿‡ç¨‹ç§°ä¸º $\\beta$-reductionã€‚ä¸€ä¸ªå½¢å¦‚ $(\\lambda x.M)N$ çš„ä¸œè¥¿ï¼Œå³æŠŠä¸€ä¸ª lambda abstraction ä½œç”¨åˆ°å¦ä¸€ä¸ª lambda term ä¸Šï¼Œç§°ä¸º $\\beta$-redexï¼Œå®ƒå¯ä»¥è¢«åŒ–ç®€æˆ $M[N/x]$ï¼ŒåŒ–ç®€åçš„å¼å­ç§°ä¸º reductã€‚åŒ–ç®€çš„è¿‡ç¨‹å°±æ˜¯ä¸æ–­å¯»æ‰¾ $\\beta$-redex å¹¶ç”¨ç›¸åº”çš„ reduct ä»£æ›¿å®ƒï¼Œä¸€ä¸ªæ²¡æœ‰ä»»ä½• $\\beta$-redex çš„ lambda term è¢«ç§°ä¸º $\\beta$-normal formã€‚\nä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„åˆ©ç”¨ $\\beta$-reduction åŒ–ç®€çš„ä¾‹å­ï¼š $$ \\begin{align} (\\lambda x.y)((\\lambda z.zz)(\\lambda w.w))\u0026amp;\\to_\\beta(\\lambda x.y)((\\lambda w.w)(\\lambda w.w))\\\\ \u0026amp;\\to_\\beta(\\lambda x.y)(\\lambda w.w)\\\\ \u0026amp;\\to_\\beta y \\end{align} $$ å½“ç„¶ï¼Œå¦‚æœæˆ‘ä»¬é€‰æ‹©äº†æœ€å¤–å±‚çš„ redex åŒ–ç®€ï¼Œå¯ä»¥åªèŠ±ä¸€æ­¥å¾—åˆ° $y$ã€‚ä¸åŒçš„ reduction é¡ºåºç¹çç¨‹åº¦å¯èƒ½ä¸åŒï¼Œæœ‰çš„é¡ºåºå¯èƒ½å¾—ä¸åˆ°ç»“æœï¼Œä½†æ‰€æœ‰èƒ½å¾—åˆ°ç»“æœçš„ reduction order å¾—åˆ°çš„ç»“æœæ˜¯å”¯ä¸€çš„ã€‚\n$\\beta$-reduction ä¸ä¸€å®šä¼šä½¿å¼å­å˜çŸ­ï¼Œç”šè‡³å¯èƒ½è®©å¼å­æ›´é•¿ã€‚æœ‰äº› lambda term è¿ç”¨ $\\beta$-reduction æ˜¯æ— æ³•åŒ–ç®€ä¸º $\\beta$-normal form çš„ï¼Œä¾‹å¦‚ $$ \\begin{align} (\\lambda x.xx)(\\lambda y.yyy)\u0026amp;\\to_\\beta(\\lambda y.yyy)(\\lambda y.yyy)\\\\ \u0026amp;\\to_\\beta(\\lambda y.yyy)(\\lambda y.yyy)(\\lambda y.yyy)\\\\ \u0026amp;\\to_\\beta \\ldots \\end{align} $$\n2.5 Formal Definitions of $\\beta$-reduction and $\\beta$-equivalence $\\beta$-reduction çš„è§„åˆ™å’Œå¯ä»¥è¿ç”¨ $\\beta$-reduction çš„æƒ…å½¢è§„å®šå¦‚ä¸‹ï¼š $$ \\frac{}{(\\lambda x.M)N\\to_\\beta M[N/x]} $$\n$$ \\begin{align} \\frac{M\\to_\\beta M\u0026rsquo;}{M\\space N\\to_\\beta M\u0026rsquo;\\space N}\\\\ \\frac{N\\to_\\beta N\u0026rsquo;}{M\\space N\\to_\\beta M\\space N\u0026rsquo;}\\\\ \\frac{M\\to_\\beta M\u0026rsquo;}{\\lambda x.M\\to_\\beta \\lambda x.M\u0026rsquo;} \\end{align} $$\n$\\fbox{Definition}$ $M\\twoheadrightarrow_\\beta M\u0026rsquo;$ å½“ä¸”ä»…å½“ $M$ å¯ä»¥é€šè¿‡ä»»æ„å¤šæ­¥ (åŒ…æ‹¬ 0 æ­¥) $\\beta$-reduction å¾—åˆ° $M\u0026rsquo;$ã€‚å½¢å¼åŒ–åœ°ï¼Œ$\\twoheadrightarrow_\\beta$ å®šä¹‰äº† $\\to_\\beta$ çš„ä¼ é€’é—­åŒ…ã€‚\n$\\fbox{Definition}$ æˆ‘ä»¬ç§° $M$ å’Œ $M\u0026rsquo;$ æ»¡è¶³ $\\beta$-equivalenceï¼Œè®°ä½œ $M=\\beta M\u0026rsquo;$ï¼Œå½“ä¸”ä»…å½“ $M$ å¯ä»¥é€šè¿‡ä»»æ„å¤šæ­¥ (åŒ…æ‹¬ 0 æ­¥) $\\beta$-reduction åŠå…¶é€†æ“ä½œå¾—åˆ° $M\u0026rsquo;$ã€‚å½¢å¼åŒ–åœ°ï¼Œ$=\\beta$ å®šä¹‰äº† $\\to_\\beta$ çš„å¯¹ç§°é—­åŒ…ã€‚\n","date":1664928000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1664928000,"objectID":"0619a13b7de4444c319450559fde6435","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-formal-semantics/material/lambda-calculus/ch02/","publishdate":"2022-10-05T00:00:00Z","relpermalink":"/notes/coursenotes/nju-formal-semantics/material/lambda-calculus/ch02/","section":"notes","summary":"2.1 Syntax 2.2 Free and Bound Variable, $\\alpha$-Equivalence 2.3 Substitution 2.4 Introduction to $\\beta$-Reduction 2.5 Formal Definitions of $\\beta$-reduction and $\\beta$-equivalence 2.1 Syntax $\\fbox{Definition}$ (lambda term) åœ¨ä¸€ä¸ªæ— é™çš„å˜é‡é›†åˆ $V$ ä¸‹ (å°†å…¶ä¸­çš„å˜é‡å‘½åä¸º $x,y,z\u0026hellip;$)ï¼Œlambda term å¯ä»¥ç”±å¦‚ä¸‹çš„ BNF èŒƒå¼å®šä¹‰ï¼š $$ \\text{Lambda terms:}\\quad M,N::=x|(M\\space N)|(\\lambda x.","tags":null,"title":"Chapter 02: The Untyped Lambda Calculus","type":"docs"},{"authors":null,"categories":null,"content":"Untyped lambda calculus çš„å¼ºå¤§ä¹‹å¤„åœ¨äºå®ƒå¯ä»¥è¢«ç”¨æ¥è¡¨ç¤ºå„ç§å„æ ·çš„æ•°æ®ï¼Œæ¯”å¦‚ boolean, è‡ªç„¶æ•°ï¼Œå¤æ‚æ•°æ®ç»“æ„ï¼Œå‡½æ•°ç­‰ã€‚è¿™ä¸€åˆ‡éƒ½åªéœ€è¦çº¯ç²¹çš„ lambda è¯­æ³•ï¼Œä¸éœ€è¦é¢å¤–çš„ syntax å’Œ axiomã€‚\n3.1 Boolean True å’Œ False çš„å®šä¹‰ï¼š $$ \\begin{align} \\mathbf{True}\u0026amp;\\triangleq \\lambda x.\\lambda y.x\\\\ \\mathbf{False}\u0026amp;\\triangleq \\lambda x.\\lambda y.y\\\\ \\end{align} $$ å¸ƒå°”ä»£æ•°çš„åŸºæœ¬æ“ä½œï¼š $$ \\begin{align} \\mathbf{not}\u0026amp;\\triangleq \\lambda b.b\\space \\mathbf{False}\\space \\mathbf{True}\\\\ \\mathbf{and}\u0026amp;\\triangleq \\lambda b.\\lambda b\u0026rsquo;.b\\space b\u0026rsquo;\\space \\mathbf{False}\\\\ \\mathbf{or}\u0026amp;\\triangleq \\lambda b.\\lambda b\u0026rsquo;.b\\space \\mathbf{True}\\space b' \\end{align} $$ if-then-elseï¼š $$ \\text{if-then-else}\\triangleq \\lambda x.x $$\n$$ \\begin{align} \\text{if-then-else }\\mathbf{True}\\space M\\space N\u0026amp;\\twoheadrightarrow_\\beta M\\\\ \\text{if-then-else }\\mathbf{False}\\space M\\space N\u0026amp;\\twoheadrightarrow_\\beta M\\\\ \\end{align} $$\n3.2 Natural Numbers è¿™é‡Œä¸»è¦ä»‹ç» Church numeral ä½“ç³»ã€‚æˆ‘ä»¬å®šä¹‰ï¼š $$ \\overline{n}\\triangleq \\lambda f.\\lambda x.f^nx $$ æ¥ä¸‹æ¥å¯ä»¥å®šä¹‰ä¸€äº›ä½œç”¨åœ¨ church numeral ä¸Šçš„å‡½æ•°ã€‚æœ€åŸºæœ¬çš„æ˜¯ $\\mathbf{succ}\\triangleq \\lambda n.\\lambda f.\\lambda x.f\\space (n\\space f\\space x)$ã€‚æˆ‘ä»¬å¯ä»¥éªŒè¯å…¶åŠŸèƒ½çš„æ­£ç¡®æ€§ï¼šå¯¹äºä»»æ„ $\\overline n$ï¼Œ $$ \\begin{align} \\mathbf{succ}\\space \\overline{n}\u0026amp;=(\\lambda nfx.f\\space (n\\space f\\space x))(\\lambda f.\\lambda x.f^nx)\\\\ \u0026amp;\\to_\\beta\\lambda fx.f\\space ((\\lambda f.\\lambda x.f^nx)\\space f\\space x)\\\\ \u0026amp;\\to_\\beta\\lambda fx.f(f^n\\space x)\\\\ \u0026amp;=\\lambda fx.f^{n+1}x\\\\ \u0026amp;=\\overline{n+1} \\end{align} $$ ä¸‹é¢æ˜¯åŠ æ³•ã€ä¹˜æ³•ã€ä¹˜æ–¹çš„å®šä¹‰ï¼š $$ \\begin{align} \\mathbf{add}\u0026amp;\\triangleq \\lambda nmfx.n\\space f\\space (m\\space f\\space x).\\\\ \\mathbf{mult}\u0026amp;\\triangleq \\lambda nmfx.n\\space (m\\space f)\\space x.\\\\ \\mathbf{exp}\u0026amp;\\triangleq \\lambda nmfx.n\\space m\\space f\\space x. \\end{align} $$ æ³¨æ„ lambda application æ˜¯å·¦ç»“åˆçš„ï¼Œè¿™å¯¼è‡´äº† $\\mathbf{exp}$ å’Œ $\\mathbf{mult}$ çš„å¾®å°å·®åˆ«ã€‚å…·ä½“çš„ç†è§£ç»†èŠ‚å‚è€ƒ Software Foundation å’Œ UCB CS61A HW02ã€‚\n$\\fbox{Definition}$ è®¾ $f:\\mathbb{N}^k\\to\\mathbb N$ ä¸ºå‡½æ•°ï¼Œ$M$ æ˜¯ä¸€ä¸ª lambda termï¼Œæˆ‘ä»¬ç§° $M$ è¡¨ç¤ºäº† $f$ å½“ä¸”ä»…å½“å¯¹äºä»»æ„ $n_1,\\cdots, n_k\\in \\mathbb N$ï¼Œå‡æœ‰ $$ M\\space \\overline{n_1}\\space \\ldots\\space \\overline{n_k}\\twoheadrightarrow_\\beta \\overline{f(n_1,\\ldots, n_k)}. $$ å¦ä¸€ä¸ªç®€å•æœ‰ç”¨çš„å‡½æ•°æ˜¯ $\\mathbf{iszero}$ï¼Œæ¥æ”¶ä¸€ä¸ª church numeralï¼Œç”¨ä¸Šä¸€èŠ‚å®šä¹‰çš„ boolean æ¥è¿”å› True/Falseï¼š $$ \\mathbf{iszero}\\triangleq \\lambda nxy.n\\space (\\lambda z.y)\\space x $$ è¯¥å‡½æ•°çš„æ ¸å¿ƒè¦ä¹‰åœ¨ä¸å¦‚æœ $n$ æ˜¯ 0ï¼Œé‚£ä¹ˆ $\\lambda z.y$ è¿™ä¸ªå‡½æ•°ä¸ä¼šä½¿ç”¨ï¼Œæœ€åçš„ç»“æœå°±æ˜¯ $\\lambda xy.x=\\mathbf{True}$ã€‚åªè¦ $\\lambda z.y$ è¢«ä½¿ç”¨äº†ä¸€æ¬¡ï¼Œæœ€åå‰©ä¸‹çš„å°±æ˜¯ $\\lambda xy.y=\\mathbf{False}$ã€‚\n3.3 Fixpoints and Recursive Functions å¯¹äºå‡½æ•° $f$ï¼Œæˆ‘ä»¬ç§° $x$ æ˜¯å‡½æ•° $f$ çš„ä¸åŠ¨ç‚¹ (fixpoint) å½“ä¸”ä»…å½“ $f(x)=x$ã€‚åœ¨ lambda calculus ä¸­ï¼Œä¸åŠ¨ç‚¹çš„å®šä¹‰æ˜¯ç±»ä¼¼çš„ï¼šå¯¹äºä»»æ„ lambda term $F,N$ï¼Œè‹¥ $N=F\\space N$ï¼Œåˆ™ç§° $N$ æ˜¯ $F$ çš„ fixpointã€‚\n$\\fbox{Theorem}$ åœ¨ untyped lambda calculus ä¸­ï¼Œæ‰€æœ‰çš„ lambda term éƒ½æœ‰ fixpointã€‚\nè¯æ˜ï¼šä»¤ $A=\\lambda xy.y(xxy)$ï¼Œå†å®šä¹‰ $\\Theta=A\\space A$ã€‚æˆ‘ä»¬å‘ç°å¯¹äºä»»æ„ $F$ï¼Œ$N=\\Theta\\space F$ å°±æ˜¯ $F$ çš„ä¸åŠ¨ç‚¹ï¼š $$ \\begin{align} N\u0026amp;=\\Theta F\\\\ \u0026amp;=A A F\\\\ \u0026amp;=(\\lambda xy.y(xxy))AF\\\\ \u0026amp;=F(AAF)\\\\ \u0026amp;=F(\\Theta F)\\\\ \u0026amp;=F\\space N\\qquad\\qquad\\qquad\\qquad \\square \\end{align} $$ $\\Theta$ è¢«ç§°ä¸º Turning\u0026rsquo;s fixpoint combinatorã€‚\næœ‰äº† fixpoint è¿™ä¸€å·¥å…·ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡æ±‚è§£æ–¹ç¨‹çš„æ–¹æ³•æ¥è®¡ç®—ä¸€äº›é€’å½’å‡½æ•°ï¼Œè¿™é‡Œä»¥ Fibonacci æ•°åˆ—ä¸ºä¾‹ï¼š $$ \\mathbf{Fib}\\space \\overline{n}=\\text{if-then-else}(n=?0)(\\overline{0})(\\text{if-then-else}(n=?1)(\\overline{1})(\\mathbf{Fib}(\\overline{n}-\\overline{1})+\\mathbf{Fib}(\\overline{n}-\\overline{2}))) $$ æ³¨: $=?$ å’Œå‡æ³•è¿™äº›æ“ä½œå¯ä»¥é€šè¿‡ $\\mathbf{iszero}$,$\\mathbf{pred}$ ç­‰å½¢å¼åŒ–åœ°å®šä¹‰ã€‚\næˆ‘ä»¬åè¿‡æ¥åšä¸€æ­¥ $\\beta$-reductionï¼Œå¾—åˆ° $$ \\mathbf{Fib}=(\\lambda f.\\lambda n.\\text{if-then-else}(n=?0)(\\overline{0})(\\text{if-then-else}(n=?1)(\\overline{1})(f(\\overline{n}-\\overline{1})+f(\\overline{n}-\\overline{2}))))(\\mathbf{Fib}) $$ ä»¤ $$ F=\\lambda f.\\lambda n.\\text{if-then-else}(n=?0)(\\overline{0})(\\text{if-then-else}(n=?1)(\\overline{1})(f(\\overline{n}-\\overline{1})+f(\\overline{n}-\\overline{2}))) $$ åˆ™ $$ \\mathbf{Fib}=F\\space \\mathbf{Fib} $$ åˆ©ç”¨ Turning fixpoint combinator å¯ä»¥ç›´æ¥è§£å‡º $$ \\begin{align} \\mathbf{Fib}\u0026amp;=\\Theta F\\\\ \u0026amp;=\\Theta(\\lambda f.\\lambda n.\\text{if-then-else}(n=?0)(\\overline{0})(\\text{if-then-else}(n=?1)(\\overline{1})(f(\\overline{n}-\\overline{1})+f(\\overline{n}-\\overline{2})))) \\end{align} $$\n3.4 Other Data Type: Pairs, Tuples, Lists, Trees, etc. ä½¿ç”¨ untyped lambda calculus å¯ä»¥è½»æ¾åœ°å®šä¹‰ç¼–ç¨‹è¯­è¨€ä¸­å¸¸è§çš„æ•°æ®ç»“æ„ã€‚\nPairs å¯¹äº lambda term $M$ å’Œ $N$ï¼Œæˆ‘ä»¬å®šä¹‰ $$ \\begin{align} \\langle M,N\\rangle\u0026amp;\\triangleq \\lambda z.zMN\\\\ \\mathbf{left}\u0026amp;\\triangleq\\lambda p.p(\\lambda xy.x)\\\\ \\mathbf{right}\u0026amp;\\triangleq\\lambda p.p(\\lambda xy.y) \\end{align} $$ å®¹æ˜“éªŒè¯ $\\mathbf{left}\\langle M,N\\rangle\\twoheadrightarrow_\\beta M,\\mathbf{right}\\langle M,N\\rangle\\twoheadrightarrow_\\beta N$ã€‚è¿™é‡Œçš„ $\\mathbf{left},\\mathbf{right}$ è¢«ç§°ä¸ºå·¦/å³æŠ•å½±ã€‚\nTuples åœ¨ pairs çš„åŸºç¡€ä¸Šæ‰©å±•æˆ‘ä»¬å¾ˆå®¹æ˜“å®šä¹‰ tupleï¼š $$ \\begin{align} \\langle M_1,M_2\\cdots, M_n\\rangle\u0026amp;\\triangleq \\lambda z.zM_1M_2\\cdots M_n\\\\ \\pi_i^n\u0026amp;\\triangleq \\lambda p.p(\\lambda x_1\\cdots x_n.x_i) \\end{align} $$ å®¹æ˜“éªŒè¯ $\\pi_i^n\\langle M_1,\\cdots, M_n\\rangle\\twoheadrightarrow_\\beta M_i$ã€‚\nLists list å’Œ tuple çš„åŒºåˆ«åœ¨äº list æ˜¯å˜é•¿çš„ï¼Œå¯ä»¥å¢åŠ å…ƒç´ ã€‚ä¸€ä¸ª list éœ€è¦ä»¥ $\\mathbf{nil}$ ä½œä¸ºç»“å°¾ï¼Œæˆ‘ä»¬ä»¥ $H::T$ æ¥è¡¨ç¤º list çš„å¤´éƒ¨å…ƒç´ æ˜¯ $H$ï¼Œå‰©ä¸‹çš„å…ƒç´ ç»„æˆçš„å°¾å·´æ˜¯å¦ä¸€ä¸ªå…ƒç´  $T$ã€‚æˆ‘ä»¬å®šä¹‰ $$ \\begin{align} \\mathbf{nil}\u0026amp;\\triangleq\\lambda xy.y\\\\ H::T\u0026amp;\\triangleq \\lambda xy.xHT \\end{align} $$\nåœ¨è¯¥å®šä¹‰çš„åŸºç¡€ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€äº›æœ‰ç”¨çš„å‡½æ•°ï¼Œä¾‹å¦‚ $\\mathbf{addlist}$ å¯ä»¥å°† list ä¸­æ‰€æœ‰çš„æ•°æ±‚å’Œï¼š $$ \\mathbf{addlist}\\space l= l(\\lambda ht.\\mathbf{add}\\space h\\space (\\mathbf{addlist}\\space t))(\\overline{0}) $$ å…¶ä¸­ç¬¬äºŒä¸ªå‚æ•° $\\overline{0}$ æ˜¯ä¸“é—¨ä¸º $\\mathbf{nil}$ å‡†å¤‡çš„ã€‚è¿™æ˜¯ä¸€ä¸ªé€’å½’çš„å®šä¹‰ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ 3.3 èŠ‚çš„æ–¹æ³•å°†å…¶è½¬åŒ–æˆä¸€ä¸ªæ­£å¼çš„å‡½æ•°ã€‚\næˆ‘ä»¬å°è¯•ä»æ–¹æ³•è®ºçš„è§’åº¦å¯¹ pair, list çš„å®šä¹‰æ–¹å¼åšå‡ºä¸€ç‚¹è§£é‡Šã€‚æ¯”å¦‚ pair ä¸­ä¹‹æ‰€ä»¥è¦åœ¨å®šä¹‰ä¸­å¼•å…¥ $z$ è¿™ä¸ªä¸œè¥¿ï¼Œæ˜¯æ–¹ä¾¿å°†æ¥ä¼ å…¥ä¸€ä¸ªå‡½æ•°ä»£å…¥ $z$ å¯¹ $M\\space N$ åšä¸€äº›æ“ä½œã€‚list ä¸­é¢„ç•™çš„ $xHT$ ä¸­çš„ $x$ ä¹Ÿæ˜¯æ–¹ä¾¿å°†æ¥ä¼ å…¥ä¸€äº›æ“ä½œå‡½æ•°ã€‚ä¹‹æ‰€ä»¥ list ä¸­æˆ‘ä»¬éœ€è¦é¢„ç•™ $x,y$ ä¸¤ä¸ªæ“ä½œå‡½æ•°â€œå ä½ç¬¦â€ï¼Œæ˜¯å› ä¸ºæˆ‘ä»¬å¯¹æ™®é€šèŠ‚ç‚¹å’Œ $\\mathbf{nil}$ çš„å¤„ç†æ–¹å¼ä¸åŒã€‚\nTrees äºŒå‰æ ‘è¦ä¹ˆæ˜¯ä¸€ä¸ªå¶å­ (ä¿å­˜äº†ä¸€ä¸ªè‡ªç„¶æ•°)ï¼Œè¦ä¹ˆæ˜¯ä¸€ä¸ªèŠ‚ç‚¹ã€‚ä¸€ä¸ªèŠ‚ç‚¹æœ‰è‡ªå·±çš„å·¦å³å­©å­ï¼Œæ¯ä¸ªå­©å­ä¹Ÿæ˜¯ä¸€ä¸ªäºŒå‰æ ‘ã€‚æˆ‘ä»¬å®šä¹‰ $$ \\begin{align} \\mathbf{leaf}\\space n\u0026amp;\\triangleq \\lambda xn.xn\\\\ \\mathbf{node}\\space L\\space R\u0026amp;\\triangleq \\lambda xy.yLR \\end{align} $$ å’Œä¸Šé¢ç±»ä¼¼åœ°ï¼Œæˆ‘ä»¬å®šä¹‰ä¸€ä¸ªå‡½æ•° $\\mathbf{addtreesq}$ï¼Œå°†æ ‘ä¸­æ‰€æœ‰å¶å­èŠ‚ç‚¹ä¸Šçš„æ•°çš„å¹³æ–¹æ±‚å’Œï¼š $$ \\mathbf{addtreesq}\\space t=t(\\lambda n.\\mathbf{mult}\\space n\\space n)(\\lambda lr.\\mathbf{add}(\\mathbf{addtreesq}\\space l)(\\mathbf{addtreesq}\\space r)) $$\n","date":1664928000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1664928000,"objectID":"bd1c81b7c62e2fdcaacb2dfe71159878","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-formal-semantics/material/lambda-calculus/ch03/","publishdate":"2022-10-05T00:00:00Z","relpermalink":"/notes/coursenotes/nju-formal-semantics/material/lambda-calculus/ch03/","section":"notes","summary":"Untyped lambda calculus çš„å¼ºå¤§ä¹‹å¤„åœ¨äºå®ƒå¯ä»¥è¢«ç”¨æ¥è¡¨ç¤ºå„ç§å„æ ·çš„æ•°æ®ï¼Œæ¯”å¦‚ boolean, è‡ªç„¶æ•°ï¼Œå¤æ‚æ•°æ®ç»“æ„ï¼Œå‡½æ•°ç­‰ã€‚è¿™ä¸€åˆ‡éƒ½åªéœ€è¦çº¯ç²¹çš„ lambda è¯­æ³•ï¼Œä¸éœ€è¦é¢å¤–çš„ syntax å’Œ axiomã€‚\n3.1 Boolean True å’Œ False çš„å®šä¹‰ï¼š $$ \\begin{align} \\mathbf{True}\u0026amp;\\triangleq \\lambda x.\\lambda y.x\\\\ \\mathbf{False}\u0026amp;\\triangleq \\lambda x.\\lambda y.y\\\\ \\end{align} $$ å¸ƒå°”ä»£æ•°çš„åŸºæœ¬æ“ä½œï¼š $$ \\begin{align} \\mathbf{not}\u0026amp;\\triangleq \\lambda b.","tags":null,"title":"Chapter 03: Programming in the Untyped Lambda Calculus","type":"docs"},{"authors":null,"categories":null,"content":" Overview Execution Graph Concepts Consistency Predicate Sequential Consistency Coherent Consistency Release/Acquire Consistency Happen-before and C/C++11 Memory Model Overview The basic procedure of declarative/axiomatic concurrency semantics:\nDefine the notion of a program execution (generalization of an execution trace) Map a program to a set of executions Define a consistency predicate on executions Semantics = the set of consistent executions of a program Exception: \u0026ldquo;catch-fire\u0026rdquo; semantics\n\u0026ldquo;catch-fire\u0026rdquo; semantics are those existing at least one \u0026ldquo;bad\u0026rdquo; consistent execution, which implies undefined behavior. (mainly appear in C/C++)\nExecution Graph The vertices stands for the events in the program. There are 4 event types: read, write, update, fence. The edges represents relations between events. There are two relation types: program order po (also called sequenced-before, sb), and reads-from, rf.\nConcepts $\\fbox{Definition}$ (label) A label has one of the following forms: $$ R\\space x\\space v_r\\qquad W\\space x\\space v_w\\qquad U(x\\space v_r\\space v_w)\\qquad F $$ where $x\\in \\text{Loc}$ and $v_r,v_w\\in \\text{Val}$.\n$\\fbox{Definition}$ (event) An event is a triple $\\langle id, i, l\\rangle$ where\n$id\\in \\mathbb N$ is an event identifier. $i\\in \\text{Tid}\\cup {0}$ is a thread identifier. $l$ is a label. Note: the thread identifier \u0026ldquo;0\u0026rdquo; is used for some initial statements that don\u0026rsquo;t belong to any specific thread.\n$\\fbox{Definition}$ (execution graph) An execution graph is a tuple $\\langle E, po,rf\\rangle$, where\n$E$ is a finite set of events. $po$ (program order) is a partial order on $E$. $rf$ (reads-from) is a binary relation on $E$ such that For every $\\langle w,r\\rangle\\in rf$: $\\text{type}(w)\\in {W,U},\\text{type}(r)\\in {R, U}$ $\\text{loc}(w)=\\text{loc}(r)$ $val_w=val_r$. $rf^{-1}$ is a function, i.e., every read operation can read from only one write. $\\fbox{Definition}$ (sequential) An execution graph $G$ is called sequential if\n$\\text{tid}(a)=0$ for every $a\\in G.E$. $G.po$ is a total order on $G.E$. $G.rf=\\emptyset$. A sequential graph can be constructed from commands by the following rules:\nSilent: $$ \\frac{c,s\\overset{\\epsilon}{\\to}c\u0026rsquo;,s\u0026rsquo;}{c,s,G\\Rightarrow c\u0026rsquo;,s\u0026rsquo;,G} $$ Non-silent: $$ \\frac{c,s\\overset{l}{\\to}c\u0026rsquo;,s\u0026rsquo;\\qquad a=\\langle n,0,l\\rangle\\qquad n\\notin {\\text{id}(b)|b\\in G.E}}{c,s,G\\Rightarrow c\u0026rsquo;,s\u0026rsquo;,Add(a,G)} $$ where $Add(a,G)$ yields an execution graph $G\u0026rsquo;$ givens by\n$G\u0026rsquo;.E=G.E\\cup {a}$ $G\u0026rsquo;.po=G.po\\cup (G.E\\times {a})$ $G\u0026rsquo;.rf=G.rf$ $G$ is an execution graph of a command c with a final store s if $c,s_0,G_\\emptyset\\Rightarrow^*\\mathbf{skip},s,G$.\nConsistency Predicate The restriction of execution graph is quite loose. Given a program, we can draw a huge number of execution graphs satisfying the requirements above, but not all of them are reasonable. Therefore our goal is to define some consistency rules to specify \u0026ldquo;valid\u0026rdquo; execution graphs.\nLet $X$ be some consistency predicate. We say an outcome $O$ is allowed for a program $P$ under $X$ if there exists an execution graph $G$ such that $G$ is X-consistent and $G$ belongs to $P$ with outcome $O$.\nException: \u0026ldquo;catch-fire\u0026rdquo; semantics\nor if there exists an execution graph $G$ such that $G$ is X-consistent, $G$ is an execution graph of $P$ and $G$ is \u0026ldquo;bad\u0026rdquo;.\n$\\fbox{Definition}$ (completeness) An execution graph $G$ is called complete if $codom(G.rf)=G.R$, i.e., every read reads from some write.\nSequential Consistency $\\fbox{Definition}$ (SC-consistent, Lamport) Let $sc$ be a total order of $G.E$, $G$ is called SC-consistent wrt (with respect to) $sc$ if\nIf $\\langle a,b\\rangle\\in G.po$, $\\langle a, b\\rangle \\in sc$. If $\\langle a, b\\rangle\\in G.rf$, then $\\langle a,b\\rangle\\in sc$ and there does not exist $c\\in G.W_{loc(b)}$ such that $\\langle a,c\\rangle\\in sc$ and $\\langle c,b\\rangle\\in sc$. Notes: the first condition requires that program order should be consistent with the $sc$ total order. The second condition requires that a read should read from a write prior to it and there shouldn\u0026rsquo;t be another write (on the same location) between them, i.e., read from the latest write.\nThere\u0026rsquo;s an alternative version of SC-consistency:\n$\\fbox{Definition}$ (modification order) $mo$ is called a modification order for an execution graph $G$ if $mo=\\bigcup_{x\\in \\text{Loc}}mo_x$, where each $mo_x$ is a total order on $G.W_x$.\n$\\fbox{Definition}$ (SC-consistent, alternative) An execution graph $G$ is called SC-consistent if the following hold:\n$G$ is complete.\nThere exists a modification order $mo$ for $G$ such that $G.po\\cup G.rf\\cup mo\\cup rb$ is acyclic.\nHere $rb\\triangleq (G.rf^{-1};mo) -{id}$. The \u0026ldquo;;\u0026rdquo; operator means that if there exists $\\langle a,c\\rangle\\in G.rf^{-1}$ and $\\langle c,b\\rangle\\in mo$, then $\\langle a,b\\rangle\\in rb$. The ${id}$ is used to filter out some dummy relations generated by $U$ (an operation $U$ reads from another write $W$ and $W\\to U$ is also in $mo$.)\n$\\fbox{Theorem}$ The two SC definitions are equivalent.\nProof:\nLamport SC $\\Rightarrow$ alternative SC: We\u0026rsquo;ve got an total order $sc$ which includes $po$ and $rf$, so we only need to construct $mo$. We let $mo\\triangleq [W_x]; sc; [W_x]$. (Here $[W_x]$ is a tricky way of representing the starting node should belong to $G.W_x$.). Since $mo\\subseteq sc$, we only need to proof that $rb$ won\u0026rsquo;t generate circle with $sc$. Suppose the opposite, then the execution graph should be like\ngraph TD W1 --\u0026gt;|rf| R W1 --\u0026gt;|mo| W2 W2 --\u0026gt;|sc| R R --\u0026gt;|rb| W2 which contradicts the property of $sc$ in Lamport SC\u0026rsquo;s definition.\nalternative SC $\\Rightarrow$ Lamport SC: We\u0026rsquo;ve got $po,rf,mo$. Let $sc$ be a total order satisfying $po\\cup rf\\cup mo\\cup rb\\subseteq sc$. ($po\\cup rf\\cup mo\\cup rb$ is acyclic, so it\u0026rsquo;s reasonable.) We need to prove that the total order $sc$ satisfies the second property in the definition. Suppose the opposite, i.e., there exists $\\langle a,b\\rangle, \\langle a,c\\rangle, \\langle c,b\\rangle\\in sc$ and $\\langle a,b\\rangle\\in rf,c\\in G.W_{loc(b)}$, it\u0026rsquo;s easy to discover that $b\\overset{rb}{\\to}c$ (the graph is the same as above), so $\\langle b,c\\rangle\\in sc$, which contradicts the fact that $sc$ is an total order.\nCoherent Consistency SC with interleaving semantics is (relatively) human-friendly, but it\u0026rsquo;s expensive to implement SC on hardware. What\u0026rsquo;s more, SC prohibits various optimization that are sound for sequential code. What most hardware guarantee and compilers preserve is \u0026ldquo;SC-per-location\u0026rdquo; (aka. coherence)\n$\\fbox{Definition}$ (coherent) an execution graph $G$ is coherent if the following hold:\n$G$ is complete. For every location $x$, there exists a total order $sc_x$ satisfying the Lamport SC\u0026rsquo;s properties. A few alternative definitions of coherence are shown below:\n$\\fbox{Definition}$ an execution graph $G$ is called coherent if the following hold:\n$G$ is complete. There exists a modification order $mo$ such that $G.po|_{loc}\\cup G.rf\\cup mo\\cup rb$ is acyclic. Note: $rf, mo,rb$ are naturally \u0026ldquo;per-location\u0026rdquo;, here the notation $G.po|_{loc}$ means that we only consider program order edges on the same location.\nLet\u0026rsquo;s have a loot at some prohibited patterns:\nNo future read:\ngraph TD S1(Rx) --\u0026gt; |po| S2(Wx) S2 -.-\u0026gt; |rf|S1 RMW-1 (can be triggered by an CAS(x, 1, 1) instruction):\ngraph TD S1(Ux) -.-\u0026gt;|rf| S1 coherence-ww/rw/wr/rr:\ngraph TD S1(Wx) --\u0026gt; |po| S2(Wx) -.-\u0026gt;|mo| S1 S3(Wx) -.-\u0026gt; |rf| S4(Rx) --\u0026gt; |po| S5(Wx) -.-\u0026gt; |mo| S3 S6(Wx) -.-\u0026gt; |mo| S7(Wx) --\u0026gt; |po| S8(Rx) S6 -.-\u0026gt; |rf| S8 S9(Wx) -.-\u0026gt;|rf| S10(Rx) --\u0026gt; |po| S11(Rx) S12(Wx) -.-\u0026gt;|rf| S11 S12(Wx) -.-\u0026gt;|mo| S9 Note: with $rb$ edges, these graphs will have cycles.\nRMW-2:\ngraph LR S1(Wx) -.-\u0026gt; |rf| S2(Ux) -.-\u0026gt; |mo| S1 Atomicity:\ngraph LR S1(Wx) -.-\u0026gt;|mo| S2(Wx) -.-\u0026gt;|mo| S3(Ux) S1 -.-\u0026gt;|rf| S3 This pattern illustrates that RMW event may only read from the immediate $mo$-predecessor - it has synchronization.\nIt can be proved that the bad patterns above cover all the cases of invalid execution graphs, so\n$\\fbox{Definition}$ an execution graph $G$ is coherent if $G$ is complete and there exists a modification order $mo$ satisfying:\n$rf;po$ is irreflexive (no-future-read) $mo;po$ is irreflexive (coherence-ww) $mo;rf;po$ is irreflexive (coherence-rw) $rf^{-1};mo;po$ is irreflexive (coherence-wr) $rf^{-1};mo;rf;po$ is irreflexive (coherence-rr) $rf$ is irreflexive (RMW-1) $mo;rf$ is irreflexive (RMW-2) $rf^{-1};mo;mo$ is irreflexive (RMW-atomicity) Release/Acquire Consistency COH is often too weak. For example, the common implementation of spinlock fails to work in COH since the variables used in the lock have no relation with the variables used in the critical section:\nlock(l): unlock(l): r := 0 l := 0 while not r do r := CAS(l, 0, 1) Initially: x = y = 0; lock(l); || lock(l); x = 1; || y = 1; a = y; /* 0 */ || b = x; /* 0 */ // store buffering is allowed even with spinlock! unlock(l); || unlock(l); In addition, COH also doesn\u0026rsquo;t support message passing:\nInitially: x = y = 0; x = 42; || a = y; y = 1; || while (!a) a = y; // Message passing: y = 1 ==\u0026gt; x = 42 is expected. || b = x; // 0 // b = 0 is allowable in COH! The lesson we can learn from these examples is that the $rb$ relation in one variable should influence the global program order, i.e., $rb$ should serve as a synchronization. This leads to the RA memory model:\n$\\fbox{Definition}$ (RA-consistent) an execution graph $G$ is RA-consistent if it\u0026rsquo;s complete and there exists a modification order $mo$ such that $(po\\cup rf)^+|_{loc}\\cup mo\\cup rb$ is acyclic.\nThe subtle difference between $po|{loc}\\cup rf$ and $(po\\cup rf)^+|{loc}$ is that the latter allow $rf$ relation on one location to connect events on other locations. Let\u0026rsquo;s check it on message passing example:\nCOH on x : allowed\ngraph TD S1(x=0) --\u0026gt;|po| S2(x=42) S1 -.-\u0026gt; |mo| S2 S1 --\u0026gt; |po| S3(b=x // 0?) S1 -.-\u0026gt; |rf| S3 RA on x : not allowed\ngraph TD S1(x=0) --\u0026gt; |po| S2(x=42) --\u0026gt; |\u0026quot;(po,rf)+\u0026quot;| S3(y=1) S1 --\u0026gt; |po| S4(a=y // 1) S3 --\u0026gt;|\u0026quot;(po,rf)+\u0026quot;| S4 S4 --\u0026gt; |\u0026quot;(po,rf)+\u0026quot;| S5(b=x // 0?) S1 -.-\u0026gt; |rf| S5 S5 -.-\u0026gt; |rb| S2 In RA, the $rf$ relation between y=1 and a=y serves as a bridge that connects x=42 and b=x. In this situation If b=x reads from x=0, the $rb$ edge generated will cause a cycle.\nHappen-before and C/C++11 Memory Model We\u0026rsquo;ve already known that according to the strength, COH\u0026lt;RA\u0026lt;SC, but there\u0026rsquo;s still some room between COH and RA: in the message passing example, we only need the $rf$ relation on y to have the synchronization effect and we don\u0026rsquo;t care about x. The idea is that we can introduce access modes on variables:\nx =(rlx) 42; || a = y(rlx) y =(rel) 1; || while (!a) a = y; || a = y(acq) || b = x(rlx) Each memory access has a mode:\nReads: $\\text{rlx}$ or $\\text{acq}$. Writes: $\\text{rlx}$ or $\\text{rel}$. RMWs: $\\text{rlx}$ or $\\text{acq}$ or $\\text{rel}$ or $\\text{acq-rel}$. The strength order can be represented as the following graph:\ngraph LR S1(rlx) --\u0026gt; S2(acq) S1 --\u0026gt; S3(rel) S2 --\u0026gt; S4(acq-rel) S3 --\u0026gt; S4 S1 --\u0026gt; S4 And we do synchronization only on $\\text{rel/acq}$: $$ \\begin{align} G.sw\u0026amp;\\triangleq [W^{\\supseteq\\text{rel}}];G.rf;[R^{\\supseteq \\text{acq}}]\\\\ G.hb\u0026amp;\\triangleq (G.po\\cup G.sw)^+ \\end{align} $$ Here $W^{\\supseteq \\text{rel}}$ means the set of write events that have access mode not weaker than $\\text{rel}$.\n$\\fbox{Definition}$ (C11 Consistency) an execution graph $G$ is C11-consistent if $G$ is complete and there exists a modification order $mo$ such that $hb_{loc}\\cup rf\\cup mo\\cup rb$ is acyclic.\nNote: the definition of RA-consistency doesn\u0026rsquo;t need to additionally include $rf$ because the transitive closure $(po\\cup rf)^+$ has include all the information in $rf$. However, in C11-consistency $hb_{loc}$ only consider $rf$ edges between \u0026ldquo;strong\u0026rdquo; r/w/rmw events so we still need to include $rf$.\nThe full C/C++11 memory model is more general in that it includes more access modes and fences.\n","date":1664841600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1664841600,"objectID":"7ca388c34fb448496fed5d134084d086","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-concurrency/lectures/lec04/","publishdate":"2022-10-04T00:00:00Z","relpermalink":"/notes/coursenotes/nju-concurrency/lectures/lec04/","section":"notes","summary":"Overview Execution Graph Concepts Consistency Predicate Sequential Consistency Coherent Consistency Release/Acquire Consistency Happen-before and C/C++11 Memory Model Overview The basic procedure of declarative/axiomatic concurrency semantics:\nDefine the notion of a program execution (generalization of an execution trace) Map a program to a set of executions Define a consistency predicate on executions Semantics = the set of consistent executions of a program Exception: \u0026ldquo;catch-fire\u0026rdquo; semantics","tags":null,"title":"Lecture 04: Declarative Semantics for Concurrency","type":"docs"},{"authors":null,"categories":null,"content":" 1.1 What Is the Internet 1.1.1 A Nuts-and-Bolts Description 1.1.2 A Services Description 1.1.3 What Is a Protocol 1.2 The Network Edge 1.2.1 Access Networks Home Access Enterprise Access Wide-Area Wireless Access 1.2.2 Physical Media 1.3 The Network Core 1.3.1 Packet Switching Store-and-Forward Transmission Queuing Delays and Packet Loss Forwarding Tables and Routing Protocols 1.3.2 Circuit Switching Multiplexing in Circuit-Switched Networks Packet Switching Versus Circuit Switching 1.3.3 A Network of Networks 1.4 Delay, Loss, and Throughput in Packet-Switched Networks 1.4.1 Overview of Delay in Packet-Switched Networks Processing Delay Queuing Delay Transmission Delay Propagation Delay Comparing Transmission and Propagation Delay 1.4.2 Queuing Delay and Packet Loss Packet Loss 1.4.3 End-to-End Delay Traceroute End System, Application, and Other Delays 1.4.4 Throughput in Computer Networks 1.5 Protocol Layers and Their Service Models 1.5.1 Layered Architecture Protocol Layering Application Layer Transport Layer Network Layer Link Layer Physical Layer 1.5.2 Encapsulation 1.6 Networks Under Attack Put Malware into Your Host Via the Internet Attack Servers and Network Infrastructure Sniff Packets Masquerade as Someone You Trust 1.7 History of Computer Networking and the Internet 1.1 What Is the Internet 1.1.1 A Nuts-and-Bolts Description è¿™é‡Œçš„ \u0026ldquo;nuts-and-bolts\u0026rdquo; æŒ‡ä»‹ç»ç½‘ç»œä¸­ä¸€äº›åŸºæœ¬çš„å…ƒç´ å’Œç»„ä»¶ã€‚ç½‘ç»œä¸­ç”¨æˆ·ä½¿ç”¨çš„ç”µè„‘ã€æ‰‹æœºã€æ‰‹æŸ„â€¦â€¦ç­‰ç‰©å“ç§°ä¸ºä¸»æœº (host) æˆ–ç»ˆç«¯è®¾å¤‡ (end system)ã€‚ç»ˆç«¯è®¾å¤‡é€šè¿‡ç”±é€šä¿¡çº¿è·¯ (communication links) å’ŒåŒ…äº¤æ¢æœº (packet switches) ç»„æˆçš„ç½‘ç»œç›¸äº’è¿æ¥ï¼Œä¸åŒçš„é“¾è·¯å…·æœ‰ä¸åŒçš„ transmission rateï¼Œåœ¨é“¾è·¯ä¸Šä¼ é€çš„æ•°æ®æ˜¯ä¸€ä»½ä¸€ä»½çš„ï¼Œç§°ä¸ºä¸€ä¸ªä¸ªåŒ… (packet)ã€‚\nPacket switch è´Ÿè´£æ¥æ”¶ packet å¹¶å°†å…¶è½¬å‘åˆ°å…¶ä»–çš„é“¾è·¯ä¸Šã€‚æœ€ä¸»è¦çš„ä¸¤ç§ packet switch å°±æ˜¯è·¯ç”±å™¨ (router) å’Œé“¾è·¯å±‚äº¤æ¢æœº (link-layer switch)ï¼Œå‰è€…é€šå¸¸ç”¨äº network coreï¼Œåè€…é€šå¸¸ç”¨äº access networkã€‚Packet-switched network å’Œæ—¥å¸¸ç”Ÿæ´»ä¸­çš„äº¤é€šè¿è¾“ç½‘ç»œå¾ˆåƒï¼špacket å°±å¥½æ¯”å¡è½¦ä¸Šçš„è´§ç‰©ï¼Œcommunication links å°±å¥½æ¯”é«˜é€Ÿå…¬è·¯ï¼Œpacket switch å°±å¥½æ¯”åå­—è·¯å£ï¼Œend system å°±å¥½æ¯”ä»“åº“å’Œå¤§æ¥¼ã€‚\nç»ˆç«¯è®¾å¤‡éœ€è¦é€šè¿‡å› ç‰¹ç½‘æœåŠ¡æä¾›å•† (Internet Service Provider, ISP) æ¥æ¥å…¥ç½‘ç»œã€‚ISP åˆ†ä¸ºè‹¥å¹²å±‚çº§ï¼Œå½¼æ­¤äº’è”ï¼Œå½¢æˆç½‘ç»œã€‚\nç»ˆç«¯è®¾å¤‡ã€åŒ…äº¤æ¢æœºç­‰åœ¨ç½‘ç»œä¸­æ”¶å‘æ•°æ®éƒ½è¦éµå¾ªç›¸å…³çš„åè®® (protocol)ã€‚ä¼ è¾“æ§åˆ¶åè®® (Transmission Control Protocol, TCP) å’Œç½‘ç»œäº’è”åè®® (Internet Protocol, IP) æ˜¯æœ€é‡è¦çš„ä¸¤ä¸ªåè®®ã€‚IP åè®®æè¿°äº† packet çš„æ ¼å¼ã€‚\n1.1.2 A Services Description è¿™ä¸ªè§’åº¦æ—¨åœ¨è¯´æ˜è®¡ç®—æœºç½‘ç»œæ˜¯ç”±è‹¥å¹²æœåŠ¡ç»„æˆçš„ï¼šå¯¹äºæ¯ä¸ªæœåŠ¡é¡¹ç›®ï¼Œä½ éœ€è¦éµå®ˆå®ƒæå‡ºçš„ specificationï¼Œè¿™æ ·ä½ å°±å¯ä»¥äº«å—å®ƒçš„è‹¥å¹²æœåŠ¡ã€‚\næˆ‘ä»¬å¼€å‘çš„ç½‘ç»œæ¸¸æˆã€ç¤¾äº¤è½¯ä»¶ç­‰ç§°ä¸º distributed applicationï¼Œå› ä¸ºå®ƒä»¬éœ€è¦è¿è¡Œåœ¨å¤šä¸ªç»ˆç«¯è®¾å¤‡ä¸Šï¼Œè¿™äº›ç»ˆç«¯è®¾å¤‡éœ€è¦å½¼æ­¤äº¤æ¢ä¿¡æ¯ã€‚ç»ˆç«¯è®¾å¤‡é€šè¿‡å¥—æ¥å­—æ¥å£ (socket interface) æ¥è¿å…¥äº’è”ç½‘ï¼Œsocket interface ä¸»è¦è§„å®šäº†ç¨‹åºåº”å½“å¦‚ä½•å‘é€æ•°æ® (æ¯”å¦‚æ ¼å¼)ï¼Œå°±åƒé‚®å±€è§„å®šå¯„ä¿¡éœ€è¦è£…ä¿¡å°è´´é‚®ç¥¨ä¸€æ ·ã€‚\n1.1.3 What Is a Protocol ä¸€ä¸ªåè®®å®šä¹‰äº†ä¸¤ä¸ªé€šè®¯å®ä½“ä¹‹é—´å‘é€ä¿¡æ¯çš„æ ¼å¼å’Œé¡ºåºï¼Œä»¥åŠæ”¶åˆ°æŸäº›ä¿¡æ¯ååº”å½“é‡‡å–çš„è¡ŒåŠ¨ã€‚\n1.2 The Network Edge Hosts æœ‰æ—¶å¯ä»¥ç»†åˆ†æˆä¸¤ç±»ï¼šå®¢æˆ·ç«¯ (client) å’ŒæœåŠ¡å™¨ (server)ã€‚å®¢æˆ·ç«¯å°±æ˜¯ç”µè„‘ã€æ‰‹æœºç­‰ï¼ŒæœåŠ¡å™¨é€šå¸¸æŒ‡æ›´åŠ å¼ºå¤§çš„ï¼Œå­˜å‚¨å’Œåˆ†å‘ç½‘é¡µã€è§†é¢‘ç­‰çš„æœºå™¨ã€‚å…ˆåœ¨å¤§å¤šæ•°çš„ç½‘é¡µå†…å®¹éƒ½å­˜å‚¨åœ¨æ•°æ®ä¸­å¿ƒ (data center)ã€‚\n1.2.1 Access Networks æ¥å…¥ç½‘ç»œ (access network) æŒ‡å°†ç»ˆç«¯è®¾å¤‡å’Œç¬¬ä¸€ä¸ªè·¯ç”±å™¨ç‰©ç†åœ°è¿æ¥èµ·æ¥çš„ç½‘ç»œã€‚\nHome Access å¯¹äºå®¶åº­æ¥è¯´ï¼Œå¸¸è§çš„ access network æœ‰ä»¥ä¸‹å‡ ç§ï¼š\nç”µè¯çº¿æ¥å…¥ (digital subscriber line, DSL)ï¼šç”µè„‘é€šè¿‡ä¸€ä¸ª DSL modem è¿æ¥åˆ°ç”µè¯çº¿ä¸Šï¼ŒDSL modem è´Ÿè´£å°†æ•°å­—ä¿¡å·è½¬æ¢æˆå¯ä»¥åœ¨ç”µè¯çº¿ä¸Šä¼ è¾“çš„é«˜é¢‘æ¨¡æ‹Ÿä¿¡å·ã€‚ç”µè¯çº¿ä¸Šä¸åŒçš„é¢‘ç‡å¯ä»¥ä¼ è¾“ä¸åŒçš„ä¿¡å·ã€‚æ¥è‡ªä¸€ä¸ªåœ°åŒºå„å®¶å„æˆ·çš„ä¿¡å·ä¼šæ±‡æ€»åˆ°ä¸€ä¸ª digital subscriber line access multiplexer (DSLAM) å¤„ï¼Œå®ƒè´Ÿè´£å°†æ¨¡æ‹Ÿä¿¡å·è½¬æ¢å›æ•°å­—ä¿¡å·ï¼Œå¹¶å°†ä¿¡å·è½¬å‘åˆ° Internet / telephone network ä¸­ã€‚\nDSL çš„ä¸Šä¼ é€Ÿç‡å’Œä¸‹è½½é€Ÿç‡æ˜¯ä¸ä¸€æ ·çš„ï¼Œå› æ­¤ DSL è¢«ç§°ä¸ºæ˜¯ä¸€é¡¹éå¯¹ç§°æŠ€æœ¯ã€‚\nç”µç¼†æ¥å…¥ (cable)ï¼šåŸºæœ¬åŸç†å’Œ DSL ç›¸åŒï¼Œç”µè„‘é€šè¿‡ cable modem è¿æ¥åˆ°ç”µç¼†ä¸Šï¼Œä¸€ä¸ª cable modem termination system (CMTS) è´Ÿè´£å’Œ DSLAM ç›¸åŒçš„å·¥ä½œã€‚\ncable network access çš„ä¸€ä¸ªæ˜¾è‘—ç‰¹å¾æ˜¯è¿™æ˜¯ä¸€ä¸ªå…±äº«çš„ä¼ è¾“ä»‹è´¨ï¼Œå› æ­¤åŒä¸€ä¸ªæ—¶åˆ»ä½¿ç”¨ç½‘ç»œçš„äººè¶Šå¤šï¼Œå®é™…çš„ç½‘é€Ÿå°±ä¼šè¶Šä½ã€‚\nå…‰çº¤åˆ°æˆ· (fiber to the home, FTTH)ï¼šä» central office ç›´æ¥æ‹‰å…‰çº¤åˆ°å®¶é‡Œã€‚\n5Gï¼šä¿¡å·ä»æœåŠ¡å•†çš„ 5G åŸºç«™é€šè¿‡æ— çº¿çš„æ–¹å¼ä¼ è¾“åˆ°å®¶åº­çš„ modemã€‚\nEnterprise Access ä¼ä¸š/é«˜æ ¡ä¼šéƒ¨ç½²ä¸€ä¸ª local area network (LAN) ä½œä¸ºæ¥å…¥ç½‘ç»œï¼Œæœ€å¸¸ç”¨çš„æ˜¯ä»¥å¤ªç½‘ (Ethernet)ï¼šå¤šå°ç»ˆç«¯è®¾å¤‡é€šè¿‡ twisted-pair copper wire è¿æ¥åˆ°ä»¥å¤ªç½‘äº¤æ¢æœºä¸Šï¼Œä»¥å¤ªç½‘äº¤æ¢æœºå†è¿æ¥åˆ°æ›´å¤§çš„å› ç‰¹ç½‘ä¸­ã€‚wireless LAN åº”ç”¨çš„ä¹Ÿå¾ˆå¹¿æ³›ã€‚\nWide-Area Wireless Access ç”µä¿¡å…¬å¸èŠ±è´¹äº†å¤§é‡è´¢åŠ›éƒ¨ç½²æ— çº¿ç½‘ç»œçš„åŸºç«™ã€‚è¿™ç§æŠ€æœ¯å’Œ WiFi ä¸å¤ªä¸€æ ·ï¼Œåªè¦ç»ˆç«¯è®¾å¤‡å’ŒåŸºç«™è·ç¦»åœ¨å‡ åƒç±³ä¹‹å†…å°±å¯ä»¥æ”¶åˆ°ä¿¡å·ã€‚\n1.2.2 Physical Media ç•¥ã€‚\n1.3 The Network Core Network Core æ˜¯ç”±é“¾è·¯å’ŒåŒ…äº¤æ¢æœºç»„æˆçš„ç½‘ç»œï¼Œç”¨äºå°†å„åœ°çš„ç»ˆç«¯è®¾å¤‡è¿æ¥èµ·æ¥ã€‚\n1.3.1 Packet Switching åœ¨ç½‘ç»œä¸­ä¸åŒçš„ç»ˆç«¯è®¾å¤‡ä¹‹é—´éœ€è¦ä¼ é€’ä¿¡æ¯ã€‚é•¿çš„ä¿¡æ¯ä¼šè¢«åˆ‡å‰²æˆä¸€å—ä¸€å—å°çš„æ•°æ®ï¼Œè¿™äº›å—è¢«ç§°ä¸ºåŒ… (packet)ã€‚åŒ…åœ¨ communication link ä¸Šçš„ä¼ è¾“é€Ÿåº¦ç­‰äºè¯¥ link çš„ full transmission rateï¼Œå³å¦‚æœä¸€ä¸ª $L$ bits çš„åŒ…åœ¨ä¸€ä¸ª $R$ bits/s çš„é“¾è·¯ä¸Šä¼ è¾“ï¼Œåˆ™éœ€è¦ $L/R$ ç§’ã€‚\nStore-and-Forward Transmission ç»å¤§å¤šæ•°çš„ packet switches é‡‡å–å­˜å‚¨è½¬å‘ä¼ è¾“ (store-and-forward transmission)ï¼Œè¿™æ„å‘³ç€äº¤æ¢æœºä¸€å®šä¼šåœ¨æ¥æ”¶åˆ°æ•´ä¸ª packet ä¹‹åæ‰ä¼šå¼€å§‹å°† packet è½¬å‘åˆ°ä¸‹ä¸€æ¡é“¾è·¯ï¼Œä¸å­˜åœ¨å¹¶è¡Œçš„ä¸€è¾¹æ¥æ”¶ä¸€è¾¹è½¬å‘çš„æƒ…å†µã€‚\nå‡è®¾æ¯ä¸ªåŒ…çš„å¤§å°éƒ½æ˜¯ $L$ bitsï¼Œæ¯æ¡é“¾è·¯çš„ transmission rate éƒ½æ˜¯ $R$ bitsï¼Œé‚£ä¹ˆ\n$N$ ä¸ªåŒ…è½¬å‘ 1 æ¬¡ (å³ src å’Œ dst ä¹‹é—´åªæœ‰ä¸€ä¸ª packet switch)ï¼Œéœ€è¦çš„æ—¶é—´æ˜¯ $(N+1)\\cdot L/R$ï¼Œæ³¨æ„å‘é€ç¬¬äºŒä¸ªåŒ…çš„æ—¶å€™ï¼Œpacket switch å¯ä»¥å¹¶è¡Œåœ°æ¥æ”¶ç¬¬äºŒä¸ªåŒ…å’Œè½¬å‘ç¬¬ä¸€ä¸ªåŒ…ã€‚ 1 ä¸ªåŒ…ç»è¿‡ $N$ ä¸ª link (å³ $N-1$ ä¸ª packet switch)ï¼Œéœ€è¦çš„æ—¶é—´æ˜¯ $N\\cdot L/R$ã€‚ $P$ ä¸ªåŒ…ç»è¿‡ $N$ ä¸ª linkï¼Œéœ€è¦çš„æ—¶é—´æ˜¯ $(P+N-1)\\cdot L/R$ã€‚ Queuing Delays and Packet Loss æ¯ä¸ª packet switch ä¸Šéƒ½è¿æ¥äº†å¤šä¸ª linkï¼Œå¯¹äºæ¯æ¡ linkï¼Œpacket switch éƒ½æœ‰ä¸€ä¸ªè¾“å‡ºç¼“å†²åŒº (output buffer, also called output queue)ï¼Œå­˜æ”¾é‚£äº›å³å°†è¢«å‘å‡ºå»çš„åŒ…ã€‚å¦‚æœä¸€ä¸ªæ–°åˆ°æ¥çš„åŒ…éœ€è¦ä»æŸæ¡ link è½¬å‘å‡ºå»ï¼Œä½†è¿™æ¡ link æ­£åœ¨è½¬å‘åˆ«çš„åŒ…ï¼Œé‚£ä¹ˆè¿™ä¸ªæ–°çš„åŒ…å°±è¦åˆ°è¯¥ link çš„ output buffer ä¸­ç­‰å¾…ã€‚å› æ­¤é™¤äº† store-and-forward delayï¼ŒåŒ…åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­è¿˜æœ‰æ’é˜Ÿå»¶è¿Ÿ (queuing delay)ï¼Œå…¶é•¿çŸ­å–å†³äºç½‘ç»œçš„æ‹¥å¡ç¨‹åº¦ã€‚\nç”±äº buffer çš„å¤§å°æ˜¯æœ‰é™çš„ï¼Œæœ‰æ—¶å€™æ–°æ¥çš„åŒ…ä¼šå‘ç° output buffer å·²ç»æ»¡äº†ï¼Œè¿™æ—¶å°±ä¼šå‘ç”ŸåŒ…ä¸¢å¤± (packet loss)â€”â€”è¦ä¹ˆæ–°æ¥çš„åŒ…è¢«ä¸¢å¼ƒï¼Œè¦ä¹ˆ buffer é‡Œçš„æŸä¸€ä¸ªå…¶ä»–æ­£åœ¨ç­‰å¾…çš„åŒ…è¢«ä¸¢å¼ƒã€‚\nForwarding Tables and Routing Protocols å¯¹äº packet switch æ¥è¯´ï¼Œæ”¶åˆ°ä¸€ä¸ªåŒ…ä»¥åè¯¥é€‰æ‹©å“ªä¸€æ¡ link å»è½¬å‘æ˜¯å®ƒä¸»è¦å…³å¿ƒçš„é—®é¢˜ã€‚åœ¨ Internet ä¸­ï¼Œæ¯ä¸ªç»ˆç«¯è®¾å¤‡éƒ½æœ‰ä¸€ä¸ª IP åœ°å€ã€‚å½“ src æƒ³è¦ç»™ dst å‘é€æ¶ˆæ¯æ—¶ï¼Œå®ƒä¼šå°† dst çš„ IP åœ°å€å†™åœ¨ packet header ä¸­ã€‚è·¯é€”ä¸­çš„æ¯ä¸ª router ä¼šè§£æ IP åœ°å€çš„ä¸€éƒ¨åˆ†ï¼Œæ ¹æ®æœ¬åœ°çš„è½¬å‘è¡¨ (forwarding table) å†³å®šæ²¿ç€å“ªæ¡é“¾è·¯ç»§ç»­ä¼ è¾“ã€‚\nInternet æœ‰ä¸€ç³»åˆ—çš„è·¯ç”±åè®® (routing protocol)ï¼Œè¿™äº›åè®®ç”¨æ¥è‡ªåŠ¨ç”Ÿæˆå„ä¸ªè·¯ç”±å™¨çš„è½¬å‘è¡¨ã€‚ä¸€ä¸ªè·¯ç”±åè®®å¯ä»¥æ ¹æ®å…¨å±€çš„æƒ…å†µæ¥ç»Ÿç­¹è§„åˆ’ï¼Œæ¯”å¦‚è®¾è®¡ä¸€æ¡å¤§åŸå¸‚ä¹‹é—´çš„æœ€çŸ­è½¬å‘è·¯å¾„ã€‚\n1.3.2 Circuit Switching åœ¨ç½‘ç»œä¸­ä¸»è¦æœ‰ä¸¤ç§ä¼ è¾“æ•°æ®çš„æ–¹å¼ï¼špacket switching å’Œ circuit switchingã€‚è¿™ä¸€èŠ‚ä¸»è¦ä»‹ç»åè€…ã€‚åœ¨ circuit-switched ç½‘ç»œä¸­ï¼Œä¸¤ä¸ªç»ˆç«¯è®¾å¤‡ä¹‹é—´è”ç»œéœ€è¦æå‰é¢„å®šèµ„æºï¼Œä¸€æ—¦å»ºç«‹äº† end-to-end connection åï¼Œåœ¨ä¸¤ä¸ªè®¾å¤‡é€šè¯æœŸé—´ï¼Œè¿™æ¡è·¯å¾„ä¸Šé¢„å®šçš„èµ„æºä¼šè¢«è¿™ä¸¤ä¸ªè®¾å¤‡ç‹¬å ï¼Œä»è€Œå¯ä»¥ä¿è¯ä¸€ä¸ªç¨³å®šçš„ transmission rate (æ³¨æ„ï¼šåœ¨ circuit switching ä¸­ä¼ è¾“é€Ÿç‡å’Œ link çš„ä¸ªæ•°æ— å…³ï¼Œå³ä¸å†æœ‰æ‰€è°“çš„ store-and-forward delay)ã€‚\nMultiplexing in Circuit-Switched Networks switches ä¹‹é—´ç”± link è¿æ¥ï¼Œä¸€ä¸ª link ä¸­åŒ…å«å¤šä¸ª circuitã€‚circuit ä¸Šä¸€èˆ¬ä¼šé‡‡ç”¨é¢‘åˆ†å¤ç”¨ (frequency-division multiplexing, FDM) æˆ–æ—¶åˆ†å¤ç”¨ (time-division multiplexing, TDM) æŠ€æœ¯ã€‚å‰è€…æŒ‡çš„æ˜¯å°†é¢‘è°±åˆ†æˆå¤šä¸ª band ç»™ä¸åŒçš„äººç”¨ï¼Œåè€…æŒ‡çš„æ˜¯å°†æ—¶é—´è½´åˆ‡åˆ†æˆå¤šä¸ªæ—¶é—´ç‰‡ç»™ä¸åŒçš„äººç”¨ã€‚\nPacket Switching Versus Circuit Switching Packet Switching çš„åŠ£åŠ¿ä¸»è¦åœ¨äºï¼Œç”±äºå­˜åœ¨ä¸å¯é¢„æµ‹çš„å»¶è¿Ÿï¼Œå®ƒä¸èƒ½ä¿è¯å³æ—¶æœåŠ¡çš„ç¨³å®šæ€§ã€‚ä½† packet switching æ€»ä½“æ¥è¯´æ¯” circuit switching æ›´é«˜æ•ˆï¼Œå› ä¸º packet switching å¯ä»¥æ›´åŠ¨æ€ã€æ›´çµæ´»åœ°åˆ†é…èµ„æºã€‚ä¸‹é¢æ˜¯ä¸¤ä¸ªä¾‹å­ï¼š\nå‡è®¾ link çš„ä¼ è¾“é€Ÿç‡æ˜¯ 1Mbpsï¼Œæœ‰ä¸€äº›ç”¨æˆ·éœ€è¦ 100kbps çš„ä¼ è¾“é€Ÿç‡ã€‚åœ¨ circuit switching ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ TDM æŠ€æœ¯ï¼ŒæŠŠ 1s åˆ†æˆ 10 ä»½ï¼Œæ¯ä¸ªç”¨æˆ·åœ¨ 1s ä¸­è·å–ä¸€ä¸ªæ—¶é—´ç‰‡ï¼Œè¿™æ ·å¯ä»¥æœ‰ 10 ä¸ªç”¨æˆ·åŒæ—¶ä½¿ç”¨ç½‘ç»œã€‚ä½†åœ¨ packet switching ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥è¯æ˜åœ¨æ¯ä¸ªå®¢æˆ·æ¯ä¸ªæ—¶åˆ»æœ‰ 0.1 çš„æ¦‚ç‡ active çš„æƒ…å†µä¸‹ï¼Œå³ä½¿æœ‰ 35 ä¸ªç”¨æˆ·åŒæ—¶ active ä¹Ÿæœ‰ 0.9996 çš„æ¦‚ç‡åªæœ‰ä¸è¶…è¿‡ 10 äºº activeï¼Œè¿™æ · packet switching åœ¨å‡ ä¹ä¿è¯äº†ç”¨æˆ·éœ€æ±‚çš„æƒ…å†µä¸‹æ”¯æŒäº†æ›´å¤šç”¨æˆ·ã€‚ å‡è®¾ 10 ä¸ªç”¨æˆ·æœ‰ 9 ä¸ªåœ¨ä¼‘æ¯ï¼Œæœ‰ä¸€ä¸ªåœ¨å¤§é‡äº§ç”Ÿæ•°æ®ï¼Œé‚£ä¹ˆåœ¨ circuit switching ä¸­ï¼Œæœ‰éœ€æ±‚çš„ç”¨æˆ·ä»ç„¶åªèƒ½å¾—åˆ° 1/10 çš„æ—¶é—´ç‰‡ï¼Œè€Œåœ¨ packet switching ä¸­ï¼Œæ‰€æœ‰çš„ä¼ è¾“èµ„æºéƒ½å¯ä»¥ä¸ºå”¯ä¸€çš„æ´»è·ƒç”¨æˆ·æ‰€ç”¨ã€‚ ç°åœ¨çš„ä¸»æµæ˜¯å‘ packet switching é æ‹¢ã€‚\n1.3.3 A Network of Networks æˆ‘ä»¬ä¹‹å‰è®¨è®ºäº† home network, enterprise network ç­‰ç­‰ï¼Œæ— æ•°çš„ç»ˆç«¯è®¾å¤‡è¿æ¥åˆ°ç”±ç”µè¯å…¬å¸ã€ç”µç¼†å…¬å¸ã€é«˜æ ¡â€¦â€¦æ­å»ºçš„ access ISP ä¸Šã€‚è¿™äº› access ISP ä¹‹é—´ä¹Ÿéœ€è¦è¿æ¥èµ·æ¥ï¼Œå½¢æˆä¸€ä¸ª network of networksã€‚\nç°ä»£çš„äº’è”ç½‘æ ¼å±€å¤§è‡´å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š\næ•´ä¸ªäº’è”ç½‘å¤§è‡´æ˜¯ä¸€ä¸ªä¸‰çº§æ ¼å±€ï¼šaccess ISP è¿å‘ regional ISPï¼Œregional ISP è¿å‘ Tier 1 ISPï¼Œåº•å±‚çš„ ISP å¯ä»¥è¿æ¥å¤šä¸ªä¸Šå±‚ ISPï¼Œè¿˜å¯ä»¥è·¨çº§è¿æ¥ã€‚å¤„äºä¸‹å±‚çš„ ISP è¿å‘ä¸Šå±‚æ˜¯ä¸ºäº†å’Œåˆ«çš„ ISP è¿é€šï¼Œå› æ­¤ä¸‹å±‚çš„ ISP æ˜¯ customerï¼Œä¸Šå±‚çš„ ISP æ˜¯ providerï¼Œcustomer ç»™ provider ä»˜è´¹ï¼Œprovider æä¾›æœåŠ¡ã€‚é¡¶å±‚çš„ Tier 1 ISP å…¨çƒåªæœ‰å‡ åä¸ªï¼Œé€šå¸¸æ˜¯å›½å®¶çº§çš„ï¼Œå®ƒä»¬å½¼æ­¤ä¹‹é—´è¿æ¥ï¼Œä¿è¯ç½‘ç»œçš„è¿é€šã€‚\nåœ¨åŸºæœ¬çš„ hierarchical æ¶æ„ä¸‹è¿˜æœ‰å¦‚ä¸‹çš„ä¸€äº›ç‰¹æ€§ï¼š\nPoints of presence (PoP)ï¼šPoP æ˜¯ provider network é‡Œçš„ä¸€ç»„è·¯ç”±å™¨ï¼Œè´Ÿè´£å’Œ customer è”ç»œã€‚ customer ä¸ºäº†å‡å°‘ç»™ provider ä»˜è´¹ï¼ŒåŒçº§çš„ ISP ä¹‹é—´ä¹Ÿå¯ä»¥è‡ªå·±å»ºç«‹é€šè®¯ï¼Œè¿™ç§æ–¹å¼ç§°ä¸º peerã€‚æœ‰ä¸€äº›ç¬¬ä¸‰æ–¹å…¬å¸å»ºç«‹äº†äº’è”ç½‘äº¤æ¢ä¸­å¿ƒ (Internet Exchange Point, IXP)ï¼Œä¸º peer æä¾›æœåŠ¡ã€‚è¿™ç§æœºåˆ¶ä¹Ÿå¯ä»¥å‡è½»ä¸Šå±‚ ISP çš„é€šè®¯å‹åŠ›ã€‚ æœ‰ä¸€äº›æœ¬åº”å¤„äºåº•å±‚çš„ content provider (æ¯”å¦‚ Google)ï¼Œç”±äºè‡ªèº«å®åŠ›è¿‡äºé›„åšï¼Œæ‹¥æœ‰æ— æ•°çš„æ•°æ®ä¸­å¿ƒå’ŒæœåŠ¡å™¨ï¼Œæ‰€ä»¥å»ºç«‹äº†è‡ªå·±çš„ç§æœ‰ç½‘ç»œã€‚Google å’Œ Tier 1 ISP å»ºç«‹è”ç»œä»¥ä¿è¯è‡ªå·±çš„å†…å®¹å¯ä»¥å‘é€ç»™ä¸–ç•Œå„åœ°ï¼Œå®ƒåœ¨å„åœ°ä¹Ÿæœ‰ä¸€äº› IXP å¯ä»¥ç›´æ¥å’Œåº•å±‚çš„ ISP å»ºç«‹è”ç³» (ä»è€Œä¸ç”¨ä»˜é’±èµ°åˆ«çš„ Tier 1 ISP)ã€‚ 1.4 Delay, Loss, and Throughput in Packet-Switched Networks 1.4.1 Overview of Delay in Packet-Switched Networks åœ¨ packet ä¼ è¾“çš„è¿‡ç¨‹ä¸­ï¼Œå®ƒåœ¨æ¯ä¸ªèŠ‚ç‚¹éƒ½ä¼šå—åˆ°ä¸€äº› delayï¼Œæœ€é‡è¦çš„å››ç§ delay æ˜¯å¤„ç†æ—¶å»¶ (processing delay)ï¼Œæ’é˜Ÿæ—¶å»¶ (queuing delay)ï¼Œå‘é€æ—¶å»¶ (transmission delay) å’Œä¼ æ’­æ—¶å»¶ (propagation delay)ï¼Œè¿™äº› delay ç»¼åˆèµ·æ¥å½¢æˆä¸€ä¸ªèŠ‚ç‚¹çš„ total nodal delayã€‚\nProcessing Delay processing delay æŒ‡çš„æ˜¯å¤„ç† packet header ä»¥åŠç¡®å®šè¿™ä¸ª packet è¯¥å¦‚ä½•è½¬å‘æ‰€èŠ±è´¹çš„æ—¶é—´ã€‚åœ¨é«˜é€Ÿè·¯ç”±å™¨ä¸­ processing delay é€šå¸¸ä»¥å¾®ç§’è®¡ã€‚\nQueuing Delay queuing delay æŒ‡çš„æ˜¯åœ¨è·¯ç”±å™¨çš„ output buffer ä¸Šæ’é˜Ÿç­‰å¾…çš„æ—¶é—´ï¼Œè¯¥ delay å’Œæ•´ä¸ªç½‘ç»œçš„æ‹¥å¡ç¨‹åº¦æœ‰å…³ã€‚é‡çº§ä»å¾®ç§’åˆ°æ¯«ç§’ä¸ç­‰ã€‚\nTransmission Delay transmission delay æŒ‡çš„æ˜¯æŠŠè¦ä¼ è¾“çš„æ•°æ® push åˆ° link ä¸Šæ‰€èŠ±è´¹çš„æ—¶é—´ï¼Œé‡çº§ä»å¾®ç§’åˆ°æ¯«ç§’ä¸ç­‰ã€‚\nPropagation Delay propagation delay æŒ‡çš„æ˜¯æ•°æ®åœ¨ link ä¸Šä¼ è¾“æ‰€èŠ±è´¹çš„æ—¶é—´ï¼Œè¯¥ delay å’Œ link çš„ç‰©ç†æè´¨ä»¥åŠè·ç¦»çš„è¿œè¿‘æœ‰å…³ï¼Œé‡çº§ä»¥æ¯«ç§’è®¡ã€‚\nComparing Transmission and Propagation Delay transmission delay æŒ‡çš„æ˜¯æŠŠæ•°æ® push out åˆ° link ä¸Šçš„æ—¶é—´ï¼Œå®ƒå’Œ packet çš„å¤§å°ä»¥åŠ link çš„ transmission rate æœ‰å…³ã€‚propagation delay æŒ‡çš„æ˜¯æ•°æ®åœ¨ link ä¸Šä¼ æ’­çš„æ—¶é—´ï¼Œå®ƒä¸»è¦å’Œè·¯é€”çš„è·ç¦»æœ‰å…³ã€‚ä¸€ä¸ªèŠ‚ç‚¹çš„æ€»æ—¶å»¶å¯ä»¥å†™ä¸º $$ d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop} $$ é€šå¸¸æ¥è¯´ $d_{proc}$ è¿™ä¸€é¡¹æ€»æ˜¯å¯ä»¥å¿½ç•¥ä¸è®¡çš„ï¼Œè€Œå…¶ä»–å‡ é¡¹åœ¨ä¸åŒçš„åœºæ™¯ä¸‹å¯èƒ½å¾ˆå°ä¹Ÿå¯èƒ½å¾ˆå¤§ã€‚\n1.4.2 Queuing Delay and Packet Loss queuing delay æ˜¯æœ€å¤æ‚å’Œæœ‰è¶£çš„ä¸€ç§æ—¶å»¶ï¼Œæ¯ä¸ªåŒ…çš„ queuing delay å¯èƒ½éƒ½ä¸ä¸€æ · (æ¯”å¦‚ä¸¤ä¸ªåŒ…æ¥åˆ°ä¸€ä¸ª routerï¼Œå…ˆæ¥çš„åŒ…å¯èƒ½æ²¡æœ‰ queuing delayï¼Œåæ¥çš„åŒ…å°±å¯èƒ½è¦ç­‰ä¸€ä¸ªåŒ…çš„æ—¶é—´)ï¼Œå› æ­¤æˆ‘ä»¬åœ¨åˆ»ç”» queuing delay çš„æ—¶å€™é€šå¸¸é‡‡å–ä¸€äº›ç»Ÿè®¡é‡ï¼Œæ¯”å¦‚ queuing delay çš„å¹³å‡å€¼ã€æ–¹å·®ã€è¶…è¿‡æŸä¸ªé˜ˆå€¼çš„æ¦‚ç‡ç­‰ç­‰ã€‚\nqueuing delay çš„å¤§å°å’Œå½“å‰çš„æµé‡ï¼Œlink çš„ transmission rate (transmission rate å¤§ï¼Œpush out ä¸€ä¸ªåŒ…å°±è¦æ›´é•¿çš„æ—¶é—´ï¼Œæ’é˜Ÿçš„åŒ…å°±è¦ç­‰æ›´ä¹…) ä»¥åŠæµé‡çš„ç‰¹å¾ (arrive periodically/in burst) ç­‰æœ‰å…³ã€‚æˆ‘ä»¬è¿™é‡Œè€ƒè™‘ä¸€ä¸ªç®€å•æƒ…å½¢ï¼šå¯¹äºä¸€ä¸ª routerï¼Œbuffer æ²¡æœ‰å®¹é‡é™åˆ¶ï¼ŒåŒ…çš„åˆ°æ¥é€Ÿç‡æ˜¯ $a$ ä¸ª/ç§’ï¼Œæ¯ä¸ªåŒ…çš„å¤§å°éƒ½æ˜¯ $L$ bitsï¼Œå³æµé‡æ˜¯ $La$ bits/sï¼›link çš„ transmission rate æ˜¯ $R$ bits/sï¼Œé‚£ä¹ˆ $La/R$ è¿™ä¸ªå€¼ä»é‡çº²ä¸Šçœ‹æ˜¯æ²¡æœ‰å•ä½çš„ï¼Œé€šå¸¸ç§°ä¸ºæµé‡å¼ºåº¦ (traffic intensity)ã€‚(æ›´ä¸€èˆ¬çš„å®šä¹‰æ˜¯ $\\frac{\\text{arrival rate of bits}}{\\text{service rate of bits}}$ã€‚) æµé‡å¼ºåº¦æ˜¯è¡¡é‡ queuing delay çš„é‡è¦æŒ‡æ ‡ï¼Œå¦‚æœ $La/R\u0026gt;1$ï¼Œé‚£ä¹ˆå¯æƒ³è€ŒçŸ¥å‘é€çš„é€Ÿåº¦æ¯”åˆ°æ¥çš„é€Ÿåº¦æ»¡ï¼Œä¹…è€Œä¹…ä¹‹ queuing delay å°†è¶‹å‘äºæ— é™ï¼Œå› æ­¤ç½‘ç»œç³»ç»Ÿå»ºè®¾çš„ä¸€ä¸ªé»„é‡‘åŸåˆ™å°±æ˜¯ï¼šä¿è¯ system çš„ traffic intensity ä¸å¤§äº 1ã€‚\nå½“ $La/R\\leq 1$ æ—¶ï¼Œç ”ç©¶è¡¨æ˜å¦‚æœå°†å¹³å‡ queuing delay çœ‹ä½œå…³äºæµé‡å¼ºåº¦çš„å‡½æ•°ï¼Œåˆ™è¯¥å‡½æ•°å‘ˆæŒ‡æ•°å‹ï¼Œå› æ­¤ç¨ç¨å‡å°æµé‡å¼ºåº¦å°±å¯èƒ½å¯¹ queuing delay æœ‰å¾ˆæ˜æ˜¾çš„æ”¹å–„ã€‚\nPacket Loss åœ¨å®é™…ç”Ÿæ´»ä¸­ router çš„ buffer å¤§å°æ˜¯æœ‰é™çš„ï¼Œå› æ­¤å½“æµé‡å¼ºåº¦è¶‹å‘äº 1 çš„æ—¶å€™ queuing delay å¹¶ä¸ä¼šè¶‹å‘äºæ— ç©·ã€‚å½“ buffer æ»¡äº†çš„æ—¶å€™ï¼Œrouter ä¼šé€‰æ‹©ä¸¢å¼ƒ (drop) æ–°æ¥çš„åŒ…ï¼Œæˆ–è€…è¯´æ–°æ¥çš„åŒ…ä¸¢å¤± (lost) äº†ã€‚è¡¡é‡ç½‘ç»œæ€§èƒ½æ—¶ï¼Œæˆ‘ä»¬ä¸ä»…ä¼šå…³æ³¨æ¯ä¸ªèŠ‚ç‚¹çš„ delayï¼Œè¿˜ä¼šå…³æ³¨å‘ç”ŸåŒ…ä¸¢å¤±çš„æ¦‚ç‡ã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œä¸ºäº†ä¿è¯æ•°æ®çš„å®Œæ•´æ€§ï¼Œå‘ç”ŸåŒ…ä¸¢å¤±æ—¶ï¼Œä¸¢å¤±çš„åŒ…ä¼šå†æ¬¡ä» source å‘å‡ºã€‚\n1.4.3 End-to-End Delay æˆ‘ä»¬ä¹‹å‰è®¨è®ºçš„éƒ½æ˜¯ä¸€ä¸ª router/èŠ‚ç‚¹ä¸Šçš„å»¶è¿Ÿï¼Œåœ¨è¿™ä¸ª section ä¸­æˆ‘ä»¬è®¨è®º end-to-end çš„å»¶è¿Ÿã€‚å‡è®¾ä»èµ·ç‚¹åˆ°ç»ˆç‚¹ä¸€å…±æœ‰ $N-1$ ä¸ª routerï¼Œå½“å‰æµé‡å¾ˆå°‘èŠ‚ç‚¹ä¸Šä¸ä¼šå‘ç”Ÿ queuing delayï¼Œé‚£ä¹ˆ end-to-end çš„ delay ä¸º $$ d_{end-end}=N(d_{proc}+d_{trans}+d_{prop}) $$ è¿™é‡Œå‰é¢çš„ç³»æ•°ä¹‹æ‰€ä»¥æ˜¯ $N$ è€Œä¸æ˜¯ $N-1$ æ˜¯å› ä¸ºèµ·ç‚¹èŠ‚ç‚¹æŠŠ packet å‘é€åˆ°ç¬¬ä¸€ä¸ª router ä¸Šä¹Ÿæœ‰ä¸€ä¸ªä¸€ç»„å¤„ç†+å‘é€+ä¼ æ’­ã€‚\nTraceroute traceroute æ˜¯ä¸€ä¸ªå‘½ä»¤è¡Œå·¥å…·ï¼Œå‘½ä»¤æ ¼å¼ä¸ºï¼š\ntraceroute hostname å®ƒçš„åŠŸèƒ½æ˜¯ä»è¿è¡Œå‘½ä»¤çš„ä¸»æœºå‘ç›®æ ‡ä¸»æœºå‘é€ä¸€ç³»åˆ—çš„ special packetã€‚åŒ…åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­ä¼šç»è¿‡ä¸€ç³»åˆ—çš„ routerï¼Œå‡è®¾æ²¿è·¯ä¸€å…±æœ‰ $N$ ä¸ª routerï¼Œç¼–å· 1~Nï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„ä¸»æœºå°±ä¼šå‘é€ $N+1$ ä¸ªåŒ…ã€‚å½“ router æ¥æ”¶åˆ°ä¸€ä¸ª special packet æ—¶ï¼Œå®ƒä¼šè¿”å›ä¸€æ¡åŒ…å«è‡ªå·±çš„åå­—ã€åœ°å€ç­‰ä¿¡æ¯çš„ç®€çŸ­æ¶ˆæ¯ï¼Œä¸”ä¸ä¼šæŠŠ special packet ç»§ç»­è½¬å‘ä¸‹å»ã€‚è¿™æ ·æ²¿è·¯çš„æ‰€æœ‰ router ä»¥åŠç›®æ ‡ä¸»æœºéƒ½ä¼šæ”¶åˆ°ä¸€ä¸ª special packet å¹¶æŠŠè‡ªå·±çš„ä¿¡æ¯ä¼ è¾“å›å»ï¼Œæˆ‘ä»¬çš„ä¸»æœºå°±å¯ä»¥æ ¹æ®è¿™äº›ä¿¡æ¯åˆ†æåˆ°æ¯ä¸ªèŠ‚ç‚¹çš„ä¼ è¾“æ—¶é•¿ï¼Œdelay ç­‰ã€‚traceroute ä¼šæŠŠè¿™ä¸ªè¿‡ç¨‹åš 3 æ¬¡å¹¶å–å¹³å‡å€¼ã€‚\nç”±äº queuing delay çš„å½±å“ï¼Œè·¯å¾„ä¸Šå¤„åœ¨å‰é¢çš„èŠ‚ç‚¹çš„å¹³å‡ä¼ è¾“æ—¶é•¿æ˜¯æœ‰å¯èƒ½æ¯”åé¢çš„èŠ‚ç‚¹é•¿çš„ã€‚\nEnd System, Application, and Other Delays é™¤äº†ä¹‹å‰æåˆ°çš„ 4 ç§ delayï¼Œç½‘ç»œç³»ç»Ÿä¸­è¿˜æœ‰è®¸å¤šå…¶ä»–ç±»å‹çš„ delayï¼Œæ¯”å¦‚å¤šä¸ªè®¾å¤‡æ¥å…¥ WiFi æ—¶ï¼Œéœ€è¦éµå®ˆåè®®ä¿è¯èµ„æºå…±äº«ï¼Œä»è€Œå½¢æˆ delayï¼›å†ä¾‹å¦‚åœ¨å› ç‰¹ç½‘è¯­éŸ³ (Voice over IP, VoIP) ä¸­ï¼Œæ¶ˆæ¯çš„å‘é€æ–¹å¿…é¡»è¦åœ¨åŒ…é‡Œå¡«å†™ä¸ŠåŠ å¯†çš„è¯­éŸ³ä¿¡æ¯ï¼Œè¿™ä¸€æ­¥æ—¶å»¶è¢«ç§°ä¸º media packetization delayã€‚\n1.4.4 Throughput in Computer Networks é™¤äº† delay å’Œ packet lossï¼Œè¡¡é‡ç½‘ç»œç³»ç»Ÿçš„å¦ä¸€ä¸ªé‡è¦æŒ‡æ ‡å°±æ˜¯ end-to-end çš„ååç‡ã€‚åœ¨ä¸€åœº end-to-end çš„ä¼ è¾“ä¸­ï¼Œä»»æ„æ—¶åˆ»çš„å³æ—¶ååç‡ (instantaneous throughput) æŒ‡çš„æ˜¯è¯¥æ—¶åˆ»æ¥æ”¶ç«¯åœ¨ 1s å†…æ¥å—çš„ bit é‡ (å•ä½ï¼šbit/s)ï¼Œç±»ä¼¼çš„å¹³å‡ååç‡åˆ™åº”ç”¨ä¸€æ®µæ—¶é—´å†…æ¥å—çš„ bit æ•°é™¤ä»¥æ—¶é—´é•¿åº¦ã€‚ä¸€ä¸ªç½‘ç»œçš„ååç‡å–å†³äºæ•´ä¸ªç½‘ç»œçš„ç“¶é¢ˆé“¾è·¯ (bottleneck link)ï¼Œå³ transmission rate æœ€å°çš„é“¾è·¯ã€‚é€šå¸¸æ¥è¯´ access network ä¸­çš„é“¾è·¯å¾ˆæœ‰å¯èƒ½ç§°ä¸ºç“¶é¢ˆ (å› ä¸º network core ä¸­çš„ä¸€èˆ¬éƒ½æ˜¯é«˜é€Ÿé“¾è·¯)ï¼›å¦‚æœæœ‰å¤šæ¡ä¼ è¾“è·¯å¾„å…±äº«æŸä¸€æ¡é“¾è·¯ï¼Œé‚£ä¹ˆè¿™ä¸ªâ€œç‹¬æœ¨æ¡¥â€ä¹Ÿå¾ˆæœ‰å¯èƒ½æˆä¸ºç“¶é¢ˆã€‚\n1.5 Protocol Layers and Their Service Models 1.5.1 Layered Architecture æˆ‘ä»¬ä»¥äººç±»åé£æœºä¸ºä¾‹ï¼Œæ•´ä¸ªæµç¨‹å¤§è‡´å¦‚ä¸‹ï¼š\nTicket(purchase) Ticket(complain) | | Baggage(check) Baggage(claim) | | Gates(load) Gates(unload) | | Runaway takeoff Airplane routing Runaway landing -------------------------\u0026gt; å¯ä»¥çœ‹åˆ°æ•´ä¸ªç³»ç»Ÿçš„åŠŸèƒ½è¢«åˆ†æˆäº†è‹¥å¹²å±‚ã€‚æ¯ä¸ªå±‚éƒ½å¯ä»¥æä¾›ä¸€äº›æœåŠ¡ï¼Œè¿™äº›æœåŠ¡åŒ…å«ä¸¤ä¸ªæ–¹é¢ï¼šä¸€æ˜¯å¯¹æ¥çš„æ—…å®¢åšä¸€äº›æ“ä½œï¼ŒäºŒæ˜¯ä½¿ç”¨æ›´ä¸‹ä¸€å±‚æä¾›çš„æœåŠ¡ (ä¸ä¼šè·¨å±‚è°ƒç”¨)ã€‚\nå¯¹äºå¤æ‚ç³»ç»Ÿæ¥è¯´ï¼Œè¿™ç§æ¨¡å—åŒ–çš„è®¾è®¡å¾ˆæœ‰å¥½å¤„ï¼šæ¯å±‚åªå¯¹ä¸Šå±‚æä¾›ä¸€äº› specificationï¼Œè¿™æ ·æŸä¸€å±‚çš„ implementation å¦‚æœå˜äº†ï¼Œåªè¦ä¿è¯ specification ä¸å˜ï¼Œç³»ç»Ÿçš„å…¶ä»–éƒ¨åˆ†å°±ä¸éœ€è¦æ”¹å˜ã€‚\nProtocol Layering åœ¨ç½‘ç»œç³»ç»Ÿä¸­ï¼Œç½‘ç»œçš„è®¾è®¡è€…è®¾è®¡äº†ä¸€äº›åè®®ï¼Œæ¯ä¸ªåè®®å±äºä¸€ä¸ª layerã€‚å¯¹äºä¸€ä¸ª layerï¼Œæˆ‘ä»¬å…³å¿ƒå®ƒå¯ä»¥å¯¹ä¸Šé¢çš„å±‚æä¾›çš„æœåŠ¡ï¼Œå³æ‰€è°“çš„æœåŠ¡æ¨¡å‹ (service model)ã€‚ä¸€ä¸ª protocol layer å³å¯ä»¥ç”¨ç¡¬ä»¶å®ç°ï¼Œä¹Ÿå¯ä»¥ç”¨è½¯ä»¶å®ç°ï¼Œä¹Ÿå¯ä»¥ç¡¬è½¯ç»“åˆï¼Œä¾‹å¦‚åº”ç”¨å±‚çš„åè®® (å¦‚ HTTP, SMTP) é€šå¸¸æ˜¯ç”±ç»ˆç«¯è®¾å¤‡ä¸­çš„è½¯ä»¶å®ç°çš„ï¼Œè€Œç½‘ç»œå±‚çš„åè®®åˆ™é€šå¸¸æ˜¯ç¡¬è½¯ç»“åˆå®ç°çš„ã€‚ä¸€ä¸ªå€¼å¾—æ³¨æ„çš„ç‚¹æ˜¯ï¼Œæ­£å¦‚å…¨ä¸–ç•Œå„åœ°çš„æ¯ä¸ªæœºåœºéƒ½æœ‰å€¼æœºç‚¹ä¸€æ ·ï¼Œä¸€ä¸ªåè®®æ˜¯åˆ†å¸ƒå¼åœ°å­˜åœ¨äºç½‘ç»œç³»ç»Ÿä¸­çš„å„ä¸ªè®¾å¤‡ä¸Šçš„ã€‚\nå°½ç®¡ protocol layer çš„æ€æƒ³æœ‰å¾ˆå¤šå¥½å¤„ï¼Œä½†ä»æœ‰ä¸€äº›è§‚ç‚¹åå¯¹ layeringã€‚layering çš„ä¸€ä¸ªæ½œåœ¨çš„ç¼ºç‚¹æ˜¯æœ‰æ—¶å€™å¤šä¸ªå±‚ä¸å¾—ä¸å®ç°ç›¸åŒçš„åŠŸèƒ½æ¨¡å—ï¼›å¦ä¸€ä¸ªæ½œåœ¨çš„ç¼ºç‚¹æ˜¯æœ‰æ—¶å€™ä¸€äº›å±‚ä¸å¾—ä¸è·å–ä¸‹ä¸€ä¸ªå±‚çš„ä¿¡æ¯ï¼Œè¿™æ‰“ç ´äº† layer separationã€‚\nå„ä¸ªå±‚çš„ protocol åˆèµ·æ¥æ€»ç§°åè®®æ ˆ (protocol stack)ã€‚å› ç‰¹ç½‘çš„åè®®æ ˆå…±æœ‰äº”ä¸ªå±‚ï¼šåº”ç”¨å±‚ (application layer)ï¼Œä¼ è¾“å±‚ (transport layer)ï¼Œç½‘ç»œå±‚ (network layer)ï¼Œé“¾è·¯å±‚ (link layer) å’Œç‰©ç†å±‚ (physical layer)ã€‚\nApplication Layer ç½‘ç»œåº”ç”¨å’Œåº”ç”¨å±‚åè®®å¤„äºåº”ç”¨å±‚ã€‚å¸¸è§çš„åº”ç”¨å±‚åè®®æœ‰ HTTP, SMTP, FTP ç­‰ã€‚æˆ‘ä»¬æ—¥å¸¸å¯è§çš„ä¸€äº›æœåŠ¡ï¼Œæ¯”å¦‚åœ¨åœ°å€æ é‡Œè¾“å…¥ human-readable çš„ç½‘å€å°±å¯ä»¥è®¿é—®ç½‘ç«™ï¼Œä¹Ÿæ˜¯ç”±åº”ç”¨å±‚çš„ DNS æ”¯æŒçš„ã€‚\nåº”ç”¨å±‚çš„ packet é€šå¸¸ç§°ä¸ºæŠ¥æ–‡ (message)ã€‚\nTransport Layer åœ¨å› ç‰¹ç½‘ä¸­ï¼Œä¼ è¾“å±‚åè®®æœ‰ä¸¤ä¸ªï¼šTCP å’Œ UDPï¼Œå®ƒä»¬éƒ½å¯ä»¥ä¼ è¾“åº”ç”¨å±‚çš„æŠ¥æ–‡ã€‚TCP å’Œ UDP çš„ä¸åŒç‚¹åœ¨äºå‰è€…å¯ä»¥å¯¹ reliability, flow control, congestion control æä¾›ä¸€äº›ä¿è¯ã€‚\nä¼ è¾“å±‚çš„ packet é€šå¸¸ç§°ä¸ºæ®µ (segment)ã€‚\nNetwork Layer ç½‘ç»œå±‚çš„ packet é€šå¸¸ç§°ä¸ºæ•°æ®æŠ¥ (datagram)ã€‚source host çš„ä¼ è¾“å±‚åè®® (TCP/UDP) ä¼šå°†è¦å‘é€çš„ segment å’Œç›®æ ‡ä¸»æœºçš„åœ°å€ä¼ ç»™ç½‘ç»œå±‚ï¼Œç½‘ç»œå±‚è´Ÿè´£å‘é€è¿™äº›å†…å®¹ã€‚\nç½‘ç»œå±‚æœ€é‡è¦çš„åè®®æ˜¯ IPï¼Œå®ƒå®šä¹‰äº† datagram çš„æ¯ä¸€ä¸ªå­—æ®µçš„å†…å®¹ä»¥åŠç»ˆç«¯è®¾å¤‡å’Œè·¯ç”±å™¨åº”å½“å¦‚ä½•å¤„ç†è¿™äº›å­—æ®µã€‚ç½‘ç»œä¸­çš„æ¯ä¸ªè®¾å¤‡éƒ½è¦éµå®ˆ IPã€‚é™¤æ­¤ä¹‹å¤–ï¼Œç½‘ç»œå±‚ä¸­è¿˜æœ‰å¾ˆå¤šå°çš„è·¯ç”±åè®®ã€‚\nLink Layer ç½‘ç»œå±‚ä¼šä¸º datagram çš„ä¼ è¾“è§„åˆ’å‡ºä¸€æ¡ç»è¿‡è‹¥å¹²è·¯ç”±å™¨çš„è·¯çº¿ï¼Œä½†ç½‘ç»œå±‚éœ€è¦ä¾é é“¾è·¯å±‚å®Œæˆå…·ä½“çš„ä¼ è¾“ã€‚å…·ä½“åœ°ï¼Œåœ¨æŸä¸€ä¸ªèŠ‚ç‚¹ä¸­ï¼Œç½‘ç»œå±‚ä¼šæŠŠ datagram ä¼ ç»™é“¾è·¯å±‚ï¼Œé“¾è·¯å±‚æŠŠ datagram ä¼ ç»™å¦ä¸€ä¸ªèŠ‚ç‚¹çš„é“¾è·¯å±‚ï¼Œå¦ä¸€ä¸ªèŠ‚ç‚¹å†æŠŠ datagram ä¸Šä¼ ç»™è‡ªå·±çš„ç½‘ç»œå±‚ã€‚å¸¸è§çš„é“¾è·¯å±‚åè®®æœ‰ Ethernet, WiFi ç­‰ã€‚\né“¾è·¯å±‚çš„ packet é€šå¸¸ç§°ä¸ºå¸§ (frame)ã€‚\nPhysical Layer ç‰©ç†å±‚çš„ä»»åŠ¡å°±æ˜¯å°† frame é‡Œä¸€ä¸ªä¸€ä¸ªçš„ bit ä»ä¸€ä¸ªèŠ‚ç‚¹ä¼ è¾“åˆ°å¦ä¸€ä¸ªã€‚æ ¹æ®ä¸åŒçš„çº¿æ (twisted-pair copper, single-mode fiber etc.)ï¼Œç‰©ç†å±‚ä¹Ÿæœ‰ä¸åŒçš„åè®®ã€‚\n1.5.2 Encapsulation ç½‘ç»œä¸­ä¸æ˜¯æ‰€æœ‰çš„è®¾å¤‡éƒ½ implement äº†5å±‚åè®®ã€‚æ‰€æœ‰çš„ host éƒ½ implement äº†5å±‚ï¼Œåƒäº¤æ¢æœºã€è·¯ç”±å™¨ç­‰å¯èƒ½åªåšäº†ä½ä¸‹çš„ä¸¤ä¸‰å±‚ã€‚\næ•°æ®ä¼ è¾“è¿‡ç¨‹ä¸­çš„ä¸€ä¸ªé‡è¦çš„æ¦‚å¿µå°±æ˜¯å°è£… (encapsulation)ã€‚æ¯ä¸€å±‚éƒ½ä¼šä»ä¸Šé¢ä¸€å±‚æ¥æ”¶ packetï¼Œåœ¨ packet å‰åŠ ä¸Šè‡ªå·±è¿™ä¸€å±‚ç›¸å…³ä¿¡æ¯çš„ headerï¼Œç„¶åæ‰“åŒ…å‘ç»™ä¸‹ä¸€å±‚ã€‚åœ¨æ¯ä¸€å±‚ packet éƒ½åˆ†ä¸º header field å’Œ payload field ä¸¤éƒ¨åˆ†ï¼Œpayload field æœ¬è´¨ä¸Šå°±æ˜¯ä¸Šä¸€å±‚ä¼ ä¸‹æ¥çš„åŒ…ã€‚\nLayer Packet Application $M$ Transport $H_t\\space M$ Network $H_n\\space H_t\\space M$ Link $H_l\\space H_n\\space H_t\\space M$ Physical è§£æçš„è¿‡ç¨‹æ­£å¥½ç›¸åï¼šæ¯ä¸€å±‚æŠŠè‡ªå·±è¿™å±‚çš„ header æ‹”ä¸‹æ¥ï¼Œæ ¹æ® header ä¸­çš„ä¿¡æ¯åšä¸€äº›æ“ä½œï¼Œç„¶åæŠŠå‰©ä¸‹çš„ payload field å¾€ä¸Šä¼ ã€‚\n1.6 Networks Under Attack äº’è”ç½‘æœ€åˆå»ºç«‹æ—¶çš„ç›®æ ‡ç”¨æˆ·æ˜¯ â€a group of mutually trusting users\u0026quot;ï¼Œä½†ç°åœ¨äº’è”ç½‘å˜å¾—éå¸¸åºå¤§ï¼Œå…¶ä¸­çš„äººä¸å¯èƒ½åšåˆ°äº’ç›¸ä¿¡èµ–ã€‚äº’è”ç½‘æœ€åˆçš„ä¸€å¥—åº•å±‚çš„è®¾è®¡ä¸èƒ½æ¨å€’é‡æ¥ï¼Œæ‰€ä»¥å°±æœ‰äº†å„ç§æ”»å‡»æ‰‹æ®µå’Œé˜²å¾¡æ‰‹æ®µã€‚\nPut Malware into Your Host Via the Internet ç½‘ç»œä¸Šé™¤äº†å¥½çš„ç¨‹åºï¼Œè¿˜æœ‰ä¸€äº›æ¶æ„è½¯ä»¶ (malware)ï¼Œå®ƒä»¬ä¼šä¾µå…¥è®¾å¤‡å¹¶åšä¸€åˆ‡å¯èƒ½çš„åäº‹ã€‚æ­¤å¤–ï¼Œæˆåƒä¸Šä¸‡çš„ä¸»æœºå¯èƒ½ä¼šè¢«åˆ©ç”¨å¹¶æ„å»ºæˆä¸€ä¸ªåƒµå°¸ç½‘ç»œ (botnet)ï¼Œåäººåˆ©ç”¨ botnet æ¥å…è´¹ä¸ºä»–ä»¬è‡ªå·±åšäº‹ã€‚å¤§éƒ¨åˆ†çš„æ¶æ„è½¯ä»¶éƒ½å…·æœ‰è‡ªæˆ‘å¤åˆ¶çš„åŠŸèƒ½ï¼šä¸€æ—¦æ„ŸæŸ“äº†ä¸€å°è®¾å¤‡ï¼Œå®ƒå°±ä¼šé¡ºç€è¿™å°è®¾å¤‡åœ¨äº’è”ç½‘ä¸­çš„è¿æ¥å»æ„ŸæŸ“åˆ«çš„è®¾å¤‡ï¼Œä»è€Œå½¢æˆä¸€ä¸ªæŒ‡æ•°çº§çš„æ„ŸæŸ“è§„æ¨¡ã€‚\nAttack Servers and Network Infrastructure å¦ä¸€ç±»å¸¸è§çš„æ”»å‡»æ‰‹æ®µæ˜¯æ‹’ç»æœåŠ¡æ”»å‡» (denial-of-service, DoS attack)ã€‚DoS æ”»å‡»é¡¾åæ€ä¹‰å°±æ˜¯è®©æŸäº› server åœæ­¢å·¥ä½œï¼Œé€šå¸¸åˆ†ä¸ºä¸‰å¤§ç±»ï¼š\nVulnerability attackï¼šåˆ©ç”¨åº”ç”¨æˆ–æ“ä½œç³»ç»Ÿçš„å¼±ç‚¹ä»£ç æ”»å‡»ï¼Œä½¿ç³»ç»Ÿå´©æºƒã€‚ Bandwidth floodingï¼šå‘ç›®æ ‡ä¸»æœºä¼ è¾“å¤§é‡çš„æ•°æ®ï¼Œä½¿å…¶åº”æ¥ä¸æš‡ï¼Œæ— æ³•æ¥æ”¶å…¶ä»–çš„æ­£å¸¸æ•°æ®ã€‚ Connection floodingï¼šæ”»å‡»è€…å’Œç›®æ ‡ä¸»æœºå»ºç«‹å¤§é‡çš„ TCP è¿æ¥ï¼Œä½¿å…¶åº”æ¥ä¸æš‡ï¼Œæ— æ³•å»ºç«‹å…¶ä»–çš„æ­£å¸¸è¿æ¥ã€‚ è¿™é‡Œç€é‡è®¨è®ºä¸€ä¸‹ bandwidth floodingã€‚æœ‰çš„æ—¶å€™ä¸€ä¸ª link çš„ transmission rate å¾ˆé«˜ï¼Œç”¨ä¸€å°æœºå™¨å¾ˆéš¾å‘é€è¶³å¤Ÿæµ·é‡çš„æ•°æ®ï¼Œè€Œä¸”å¦‚æœæ‰€æœ‰çš„åƒåœ¾æ•°æ®éƒ½æ¥è‡ªåŒä¸€å°æœºå™¨ï¼Œä¸Šæ¸¸çš„ router å¾ˆå®¹æ˜“ç›‘æµ‹åˆ°è¿™ç§æ”»å‡»å¹¶ä½œå‡ºç›¸åº”çš„é˜²å¾¡ã€‚å› æ­¤ç°åœ¨æ”»å‡»è€…æ›´å€¾å‘äºä½¿ç”¨åˆ†å¸ƒå¼æ‹’ç»æœåŠ¡æ”»å‡» (distributed Dos, DDoS)ã€‚æ”»å‡»è€…æ§åˆ¶ä¸€ä¸ªæœ‰æˆåƒä¸Šä¸‡å°åƒµå°¸æœºçš„ botnet æ¥å‘ç›®æ ‡ä¸»æœºå€¾æ³„åƒåœ¾æ•°æ®ã€‚\nSniff Packets åäººå¯èƒ½ä¼šåœ¨ä¸€ä¸ªç½‘ç»œä¸­æ”¾ç½®ä¸€ä¸ªè¢«åŠ¨çš„æ¥å—å™¨ï¼Œè¿™ä¸ªæ¥å—å™¨å¯ä»¥å°†ç½‘ç»œä¸­ä¼ è¾“çš„æ¯ä¸ª packet éƒ½å¤åˆ¶ä¸€ä»½ï¼Œè¿™æ ·çš„è¢«åŠ¨æ¥å—å™¨è¢«ç§°ä¸ºåŒ…å—…æ¢å™¨ (packet sniffer)ã€‚\nsniffer å¯ä»¥è¢«ç”¨æ¥çªƒå–ç”¨æˆ·çš„éšç§ä¿¡æ¯ï¼Œå…¶ç”±äºå®ƒæ˜¯å®Œå…¨è¢«åŠ¨çš„ï¼Œä¸ä¼šå‘ç½‘ç»œä¸»åŠ¨å‘é€ packetï¼Œæ‰€ä»¥å®ƒå¾ˆéš¾è¢«å‘ç°ã€‚é¢„é˜² packet sniffer çš„æœ‰æ•ˆæ‰‹æ®µæ˜¯å¯¹åŒ…çš„å†…å®¹è¿›è¡ŒåŠ å¯†ã€‚\nMasquerade as Someone You Trust åœ¨ç½‘ç»œä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“åœ°åˆ¶ä½œä¸€ä¸ªåŒ…å«ä»»æ„æºåœ°å€ï¼Œç›®æ ‡åœ°å€å’Œå†…å®¹çš„ packetã€‚ç½‘ç»œä¸­çš„èŠ‚ç‚¹åªä¼šè´Ÿè´£åœ°å¸®åŠ©æˆ‘ä»¬è½¬å‘è¿™ä¸ªåŒ…ï¼Œä½†ä¸ä¸€å®šèƒ½æ£€éªŒè¿™ä¸ªåŒ…çš„çœŸå®æ€§ã€‚è¿™ç§å‘ç½‘ç»œä¸­å‘é€åŒ…å«è™šå‡æºåœ°å€çš„åŒ…çš„æ”»å‡»æ‰‹æ®µè¢«ç§°ä¸º IP æ¬ºéª— (IP spoofing)ã€‚é€šè¿‡ IP spoofingï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ç½‘ç»œä¸­ä¼ªè£…æˆå¦ä¸€ä¸ªäººä¸ä»–äººé€šä¿¡ã€‚\nä¸ºäº†é˜²å¾¡ IP spoofingï¼Œæˆ‘ä»¬éœ€è¦åœ¨ç½‘ç»œä¸­æ·»åŠ  end-point authenticationï¼Œå³æ£€éªŒæ¶ˆæ¯çš„æºåœ°å€çš„çœŸå®æ€§ã€‚\n1.7 History of Computer Networking and the Internet ç•¥ã€‚\n","date":1663891200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1663891200,"objectID":"a0bae3c162ead46f0d0f5607f3c6fd01","permalink":"https://kristoff-starling.github.io/notes/booknotes/network-topdown/ch01/","publishdate":"2022-09-23T00:00:00Z","relpermalink":"/notes/booknotes/network-topdown/ch01/","section":"notes","summary":"1.1 What Is the Internet 1.1.1 A Nuts-and-Bolts Description 1.1.2 A Services Description 1.1.3 What Is a Protocol 1.2 The Network Edge 1.2.1 Access Networks Home Access Enterprise Access Wide-Area Wireless Access 1.","tags":null,"title":"Chapter 1: Computer Networks and the Internet","type":"docs"},{"authors":null,"categories":null,"content":" A Simple Concurrent Programming Language Basic Setup Thread Subsystem Storage Subsystem Linking the Two The Thread Subsystem Thread Local Steps Lifting to Concurrent Programs SC Storage subsystem Linking the Thread and Storage Subsystems x86\u0026rsquo;s TSO Storage Subsystem: Linking The Thread and Storage Subsystem Exercise: PSO Storage System A Simple Concurrent Programming Language Basic domains:\nRegisters: $r\\in \\text{Reg}$. Memory locations: $x\\in \\text{Loc}$. Values (including 0): $v\\in \\text{Val}$. Thread identifiers: $i\\in \\text{Tid}=\\{1,\\cdots,N\\}$. Expressions and commands (here all commands are atomic):\ne ::= r | v | e +(-*/) e | ... c ::= skip | if e then c else c | while e do c | c ; c (sequential) | r := e | r := x (read) | x := e (write) r := FAA(x, e) | r := CAS(x, e, e) | fence FAA means \u0026ldquo;fetch-and-add\u0026rdquo;, r = FAA(x, e) will do\nr = x; x += e; atomically.\nCAS means \u0026ldquo;compare-and-set/swap\u0026rdquo;, r = CAS(x, er, ew) will do\nr = x; if (r == er) { x = ew; r = 1; } else r = 0; atomically.\nfence only takes effect under WMM. It forces previous writes to be propagated into memory.\nPrograms: $P:Tid\\to Cmd$, written as $P=c_1||c_2||\\cdots ||c_N$.\nBasic Setup Different memory models usually share the same thread behaviors while have different implementation on the read/write side. Therefore we decompose the system into thread subsystem and storage subsystem and set an \u0026ldquo;virtual\u0026rdquo; interface between them.\nThread Subsystem thread local step: $(c,s)\\overset{l}{\\to}(c\u0026rsquo;,s\u0026rsquo;)$, Lift them to program steps: $(P,S)\\overset{i,l}{\\to}(P\u0026rsquo;,S\u0026rsquo;)$. Storage Subsystem It\u0026rsquo;s memory-model-dependent.\nDescribe the effect of memory accesses and fences.\n$M\\overset{i:l}{\\to}M\u0026rsquo;$.\nLinking the Two Either the thread or the storage subsystem make an internel step, i.e., $\\epsilon$, or they make matching $i:l$ steps. The transformation is denoted as $P,S,M\\Rightarrow P\u0026rsquo;,S\u0026rsquo;,M\u0026rsquo;$.\nThe Thread Subsystem Thread Local Steps Store: $s:\\text{Reg}\\to \\text{Val}$ (initially $s_0\\triangleq \\lambda r.0$).\nState: $(c,s)\\in \\text{Command}\\times \\text{Store}$\nTransitions:\n$\\mathbf{skip}$: $$ \\frac{}{\\mathbf{skip};c,s\\overset{\\epsilon}{\\to}c,s} $$\nSequential:\n$$ \\frac{c_1,s\\overset{l}{\\to}c_1\u0026rsquo;,s\u0026rsquo;}{c_1;c_2,s\\overset{l}{\\to}c_1\u0026rsquo;,c_2,s\u0026rsquo;} $$\nRegister operations: $$ \\frac{s\u0026rsquo;=s[r\\mapsto s(e)]}{\\text{r:=e},s\\overset{\\epsilon}{\\to}\\mathbf{skip},s\u0026rsquo;} $$ Memory read: $$ \\frac{l=R(x, v)}{\\text{r:=x},s\\overset{l}{\\to}\\mathbf{skip},s[r\\to v]} $$ Here $l=R(x, v)$ means that we read from the memory and $M[x] = v$.\nMemory write: $$ \\frac{l=W(x, s(e))}{\\text{x:=e,s}\\overset{l}{\\to}\\mathbf{skip},s} $$ $\\mathbf{if}$-$\\mathbf{then}$-$\\mathbf{else}$ branch: $$ \\frac{s(e)\\neq 0}{\\mathbf{if}\\space e\\space \\mathbf{then}\\space c_1\\space \\mathbf{else}\\space c_2,s\\overset{\\epsilon}{\\to}c_1,s} $$\n$$ \\frac{s(e)= 0}{\\mathbf{if}\\space e\\space \\mathbf{then}\\space c_1\\space \\mathbf{else}\\space c_2,s\\overset{\\epsilon}{\\to}c_2,s} $$\n$\\mathbf{while}$ loop: $$ \\frac{}{\\mathbf{while}\\space e\\space \\mathbf{do}\\space c,s\\overset{\\epsilon}{\\to}\\mathbf{if}\\space e\\space\\mathbf{then}\\space (c;\\mathbf{while}\\space e\\space \\mathbf{do}\\space c)\\space \\mathbf{else}\\space \\mathbf{skip},s} $$ Fetch-and-add: $$ \\frac{l=U(x, v, v + s(e))}{\\text{r:=}\\mathbf{FAA}(x,e),s\\overset{l}{\\to}\\mathbf{skip},s[r\\to v]} $$ Here we define a new way to interact with memory: U (update). U(x, vr, vw) means that we fetch $v_r$ from $M[x]$ and write $v_w$ to $M[x]$.\nCompare-and-swap: $$ \\frac{l=R(x, v)\\quad v\\neq s(e_r)}{\\text{r:=}\\mathbf{CAS}(x, e_r,e_w),s\\overset{l}{\\to}\\mathbf{skip},s[r\\to 0]} $$\n$$ \\frac{l=U(x, s(e_r), s(e_w))}{\\text{r:=}\\mathbf{CAS}(x, e_r,e_w),s\\overset{l}{\\to}\\mathbf{skip},s[r\\to 1]} $$\nIt\u0026rsquo;s worth noticing that when compare-and-swap fails, it acts as a normal read operation (\u0026ldquo;R\u0026rdquo; instead of \u0026ldquo;U\u0026rdquo;)\nFence: $$ \\frac{}{\\mathbf{fence},s\\overset{F}{\\to}\\mathbf{skip},s} $$ For WMM, when the memory receives \u0026ldquo;F\u0026rdquo;, it will do particular operations.\nLifting to Concurrent Programs State: $(P,S)\\in\\text{Program}\\times (\\text{Tid}\\to \\text{Store})$. (initially $(P,S_0)$, where $S_0\\triangleq \\lambda i.s_0$)\nTransitions: $$ \\frac{P(i),S(i)\\overset{l}{\\to}c,s}{P,S\\overset{i:l}{\\mapsto}P[i\\to c],S[i\\mapsto s]} $$\nSC Storage subsystem Machine state: $M:\\text{Loc}\\to\\text{Val}$ (initially $M_0\\triangleq \\lambda x.0$).\nTransitions: $$ \\frac{l=W(x, v)}{M\\overset{i:l}{\\to}M[x\\mapsto v]} $$\n$$ \\frac{l=R(x, v)\\quad M[x]=v}{M\\overset{i:l}{\\to}M} $$\n$$ \\frac{l=U(x,v_r,v_w)\\quad M[x]=v_r}{M\\overset{i:l}{\\to}M[x\\mapsto v_w]} $$\n$$ \\frac{l=F}{M\\overset{i:l}{\\to}M} $$\n(fence doesn\u0026rsquo;t take effect in SC memory model.)\nLinking the Thread and Storage Subsystems Silent: $$ \\frac{P,S\\overset{i:\\epsilon}{\\to}P\u0026rsquo;, S\u0026rsquo;}{P,S,M\\Rightarrow P\u0026rsquo;,S\u0026rsquo;,M} $$ Non-silent: $$ \\frac{P,S\\overset{i:l}{\\to}P\u0026rsquo;,S\u0026rsquo;\\quad M\\overset{i:l}{\\to}M\u0026rsquo;}{P,S,M\\Rightarrow P\u0026rsquo;,S\u0026rsquo;,M\u0026rsquo;} $$ An outcome $O:\\text{Tid}\\to\\text{Store}$ is allowed for a program $P$ under SC if there exists $M$ such that $$ P,S_0,M_0\\Rightarrow^* \\mathbf{skip}||\u0026hellip;||\\mathbf{skip},O,M. $$\nx86\u0026rsquo;s TSO Storage Subsystem: Machine states:\nA memory $M:\\text{Loc}\\to\\text{Val}$ A function $B:\\text{Tid}\\to (\\text{Loc},\\text{Val})^*$ assigning a store buffer to every thread. Here a pair $(x, v)$ stands for a write. The most recent write appears at the left most position of the write sequence. (Initially, $M_0\\triangleq \\lambda x.0$,$B_0=\\lambda i.\\epsilon$).\nTransitions:\nWrite (only to the thread-local buffer): $$ \\frac{l=W(x, v)}{M,B\\overset{i:l}{\\to}M,B[i\\mapsto (x,v)\\cdot B(i)]} $$ Propagate (flush the least recent operation in the buffer to the memory): $$ \\frac{B(i)=b\\cdot (x,v)}{M,B\\overset{i:\\epsilon}{\\to}M[x\\mapsto v],B[i\\mapsto b]} $$ Read $$ \\frac{l=R(x,v)\\quad B(i)=(x_n,v_n)\\cdot\\ldots\\cdot(x_1,v_1)\\quad M[x_1\\mapsto v_1]\\cdots[x_n\\mapsto v_n] (x)=v}{M,B\\overset{i:l}{\\to}M,B} $$ Notice that during a read, the buffer won\u0026rsquo;t be flushed into the memory.\nRMW (read-modify-write): $$ \\frac{l=U(x,v_r,v_w)\\quad B(i)=\\epsilon \\quad M(x)=v_r}{M,B\\overset{i:l}{\\to}M[x\\mapsto v_w],B} $$ The condition $B(i)=\\epsilon$ indicates that RMW will automatically synchronize the state. Notice that in $\\mathbf{CAS}$, if the comparison failed, $\\mathbf{CAS}$ would act as a normal \u0026ldquo;read\u0026rdquo; operation and in TSO no synchronization would be conducted.\nFence: $$ \\frac{l=F\\quad B(i)=\\epsilon}{M,B\\overset{i:l}{\\to}M,B} $$ Fence is used as forced synchronization.\nLinking The Thread and Storage Subsystem Silent thread: $$ \\frac{P,S\\overset{i:\\epsilon}{\\to}P\u0026rsquo;,S\u0026rsquo;}{P,S,M,B\\Rightarrow P,S\u0026rsquo;,M,B} $$ Silent storage: $$ \\frac{M,B\\overset{i:\\epsilon}{\\to}M\u0026rsquo;,B\u0026rsquo;}{P,S,M,B\\Rightarrow P,S,M\u0026rsquo;,B\u0026rsquo;} $$ Non silent: $$ \\frac{P,S\\overset{i:l}{\\to}P\u0026rsquo;,S\u0026rsquo;\\qquad M,B\\overset{i:l}{\\to}M\u0026rsquo;,B\u0026rsquo;}{P,S,M,B\\Rightarrow P\u0026rsquo;,S\u0026rsquo;,M\u0026rsquo;,B\u0026rsquo;} $$ The definition of allowed outcome is similar to that of SC.\nExercise: PSO Storage System Partial Store Ordering (PSO) is a WMM similar to TSO, but it does not guarantee that stores to different locations propagate to the main memory in the order they were issued. In particular, it allows the following weak behavior:\nInitially, x = y = 0; x = 1; || a = y; // 1 y = 1; || b = x; // 0; (1) Operational semantics for PSO:\nWe only need to redefine the propagate rule in TSO: $$ \\frac{B(i)=b\u0026rsquo;\\cdot(x,v)\\cdot b\\qquad b=(x_t,v_t)\\cdot\\ldots\\cdot(x_1,v_1),\\forall 1\\leq i\\leq t,x_i\\neq x}{M,B\\overset{i:\\epsilon}{\\to}M[x\\mapsto v],B[i\\mapsto b\u0026rsquo;\\cdot b]} $$ (2) store-store fence:\nIn the thread subsystem: $$ \\frac{}{\\mathbf{ssfence};c,s\\overset{SSF}{\\to}\\mathbf{skip};c,s} $$ In the storage subsystem:\nSSF rule: add a special mark into the buffer array: $$ \\frac{}{M,B\\overset{SSF}{\\to}M,B[i\\mapsto F\\cdot B(i)]} $$ Propagation rule needn\u0026rsquo;t be changed because our conditions implicitly require that there\u0026rsquo;s no store-store fence before the target operation. But we need an additional rule to move away \u0026ldquo;F\u0026rdquo; marks: $$ \\frac{B(i)=b\\cdot F}{M,B\\overset{i:\\epsilon}{\\to}M\u0026rsquo;,B[i\\mapsto b]} $$ (3) Show that programs containing store-store fences between every two writes have the same outcomes under TSO and PSO:\nTSO and PSO differ only in their propagation rules. If there is a store-store fence between every two writes, it\u0026rsquo;s easy to prove that at any point, the buffer of arbitrary thread should be in the form of $(x_n,v_n)\\cdot F\\cdot \\ldots \\cdot F\\cdot (x_2,v_2)\\cdot F\\cdot (x_1,v_1)$. Therefore at any point the propagation rule in PSO can only choose the least recent operation in the buffer to propagate, which makes it completely the same as TSO\u0026rsquo;s propagation rule.\n","date":1663632000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1663632000,"objectID":"0fd5c9e5a384c343cc49e9aa239ed5f3","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-concurrency/lectures/lec03/","publishdate":"2022-09-20T00:00:00Z","relpermalink":"/notes/coursenotes/nju-concurrency/lectures/lec03/","section":"notes","summary":"A Simple Concurrent Programming Language Basic Setup Thread Subsystem Storage Subsystem Linking the Two The Thread Subsystem Thread Local Steps Lifting to Concurrent Programs SC Storage subsystem Linking the Thread and Storage Subsystems x86\u0026rsquo;s TSO Storage Subsystem: Linking The Thread and Storage Subsystem Exercise: PSO Storage System A Simple Concurrent Programming Language Basic domains:","tags":null,"title":"Lecture 03: Operational Semantics for Concurrency","type":"docs"},{"authors":null,"categories":null,"content":" PL and Static Analysis Why We Learn Static Analysis What is Static Analysis Static Analysis Features and Examples Static Analysis: Bird\u0026rsquo;s Eye View Static Analysis: An Example Abstraction Over-approximation PL and Static Analysis Programming Languages:\nTheory: language design, type system, semantics and logics. etc. Environment: compilers, runtime system etc. Application: ensure the soundness, performance, security of projects =\u0026gt; program analysis/verification/synthesis. Background: in recent decades, the language cores had few changes, but the programs became significantly larger and more complicated.\nPL Categories\nImperative languages (e.g. Java, C++): fine control on program states (hardware) Functional languages (e.g. Haskell, OCaml, scheme): reduce side effects (states of programs), but less control on states Declarative languages (e.g. SQL, prolog) abstraction on computing process, describe targets of programs. Challenge: How to ensure the reliability, security and other promises of large-scale and complex programs?\nWhy We Learn Static Analysis Static Analysis (static means at compile time, before execution) are helpful in\nProgram Reliability: null pointer dereferences, memory leak etc. Program Security: private information leak, injection attack etc. Compiler Optimization: dead code elimination, code motion etc. Program Understanding: IDE call hierarchy, type indication etc. What is Static Analysis Static analysis analyzes a program $P$ to reason about its behaviors and determines whether it satisfies some properties before running $P$.\nCan two pointers point to the same memory location? Does $P$ dereference any null pointers? Will certain assert() statements in $P$ fail? â€¦â€¦ Unfortunately, by Rice\u0026rsquo;s Theorem, there is no such approach to determine whether $P$ satisfies such non-trivial properties, i.e., giving exact answer: Yes or No.\nRice Theorem\nAny non-trivial property of the behavior of programs in a r.e.(recursively enumerable, recognizable by a Turning-machine) language is undecidable.\nA property is trivial if either it\u0026rsquo;s not satisfied by any language or it\u0026rsquo;s satisfied by all languages. (Non-trivial properties $\\approx$ properties related with run-time behaviors of programs)\nâ€œPerfect\u0026quot;, i.e., sound and complete, static analysis does not exist.\nSoundness and Completeness\nSoundness: over-approximation, the result is a superset of the truth.\nCompleteness: under-approximation, the result is a subset of the truth.\nUseful static analysis should compromise. If we compromise soundness, we introduce false negatives; if we compromise completeness, we introduce false positives. Mostly static analysis techniques compromise completeness, i.e. sound but not fully precise static analysis.\nSoundness is critical to a collection of important applications. For example:\nB b = new B(); | C c = new C(); a.fld = b; | a.fld = c; fld = (B) a.fld; // \u0026lt;- is the casting safe? (This is a control flow graph, not concurrent threads.) If the analysis is unsound, e.g. only contains the behavior of the first snippet, we may come to the false conclusion that the casting is safe.\nStatic Analysis Features and Examples Static Analysis: Bird\u0026rsquo;s Eye View if (input) x = 1; else x = 0; // x = ? Two analysis results:\nWhen input is true, x = 1; when input is false, x = 0. - Sound, precise, expensive. x = 1 or x = 0. - Sound imprecise, cheap. The goal of static analysis is to ensure soundness while making good trade-offs between analysis precision and analysis speed.\nTwo words to conclude: abstraction \u0026amp; over-approximation.\nStatic Analysis: An Example Target: determine the sign (+/-/0) of all the variables of a given program (useful in divided-by-0 detection, negative indices detection\u0026hellip;).\nAbstraction Under this specific goal we don\u0026rsquo;t care about the exact value (e.g. 10 or 20), we only care about the sign. The abstraction construct a mapping from concrete domain to abstract domain: ($+,-,0,T,\\top,\\bot$) ($\\top$ stands for unknown, $\\bot$ stands for undefined).\nOver-approximation Transfer functions define how to evaluate different program statements on abstract values.\ne.g. + ++ =+, + +- =T.\nx = 10; + y = -1; - z = 0; 0 a = x + y; unknown b = z / y; 0 c = a / b; undefined -\u0026gt; divided by zero p = arr[y]; undefined -\u0026gt; negative index q = arr[a]; undefined -\u0026gt; negative index c and p shows the usefulness of static analysis. q shows that static analysis may lead to false positives.\nControl flow\nx = 1; if (input) y = 10; else y = -1; z = x + y; graph TD S1(x=1) --\u0026gt; |y=+|S2(y=10) S1 --\u0026gt; |y=-|S3(y=-1) S2 --\u0026gt; S4(\u0026quot;z=x+y\u0026lt;br\u0026gt;(merge: y=unknown)\u0026quot;) S3 --\u0026gt; S4 As it\u0026rsquo;s impossible to enumerate all paths in practice, flow merging is taken for granted in most static analysis.\n","date":1663200000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1663200000,"objectID":"84d6c299b611d8382515418c9e207221","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-software-analysis/lectures/lec01/","publishdate":"2022-09-15T00:00:00Z","relpermalink":"/notes/coursenotes/nju-software-analysis/lectures/lec01/","section":"notes","summary":"PL and Static Analysis Why We Learn Static Analysis What is Static Analysis Static Analysis Features and Examples Static Analysis: Bird\u0026rsquo;s Eye View Static Analysis: An Example Abstraction Over-approximation PL and Static Analysis Programming Languages:","tags":null,"title":"Lecture 01: Introduction","type":"docs"},{"authors":null,"categories":null,"content":" Sets Generalized Unions of Sets Generalized Intersections of Sets Relations Basic notations Equivalence Relations Functions Variation Function Types Currying Products Tuples as Functions Generalized Products Exponentiation Sums Sets Generalized Unions of Sets $$ \\begin{align} \\bigcup S \u0026amp;\\triangleq \\{x\\space |\\space \\exists \\space T\\in S. x\\in T\\}\\\\ \\bigcup_{i\\in I} S(i) \u0026amp;\\triangleq \\bigcup\\{S(i) \\space|\\space i\\in I\\}\\\\ \\bigcup_{i=m}^n S(i) \u0026amp;\\triangleq \\bigcup_{i\\in [m,n]} S(i) \\end{align} $$\nNote: in the first definition, $S$ is a a set of sets.\nGeneralized Intersections of Sets $$ \\begin{align} \\bigcap S \u0026amp;\\triangleq \\{x\\space|\\space \\forall\\space T\\in S. x\\in T\\}\\\\ \\bigcap_{i\\in I} S(i) \u0026amp;\\triangleq \\bigcup\\{S(i)\\space |\\space i\\in I\\}\\\\ \\bigcap_{i=m}^n S(i) \u0026amp;\\triangleq \\bigcup_{i\\in [m,n]} S(i) \\end{align} $$\nLet\u0026rsquo;s consider $\\emptyset$. For union: $$ \\begin{align} \\bigcup \\emptyset \u0026amp;= \\{x\\space|\\space \\exists\\space T\\in \\emptyset. x\\in T\\}\\\\ \u0026amp;= \\{x\\space|\\space \\exists\\space T. T\\in \\emptyset\\space \\wedge x\\in T\\}\\\\ \u0026amp;=\\emptyset \\end{align} $$ For intersection: $$ \\begin{align} \\bigcap \\emptyset \u0026amp;= \\{x\\space|\\space \\forall\\space T\\in \\emptyset.x\\in T\\}\\\\ \u0026amp;=\\{x\\space|\\space \\forall\\space T.T\\in \\emptyset\\to x\\in T\\}\\\\ \u0026amp;=\\{x\\space|\\space \\forall\\space T.\\text{false}\\to x\\in T\\}\\\\ \\end{align} $$ This results in \u0026ldquo;a set of everything\u0026rdquo;, which contradicts the Russel paradox. Therefore $\\bigcap \\emptyset$ is meaningless.\nRussel Paradox\nIf there exists \u0026ldquo;a set of everything\u0026rdquo;, denoted as $A$. Consider $$ B=\\{x\\in A\\space |\\space x\\notin x\\} $$ Since $A$ is a set of everything, $B\\in A$. The question is whether $B\\in B$.\nIf $B\\in B$, then according to the definition of $B$, $B\\notin B$ holds. If $B\\notin B$, then according to the definition of $B$, $B\\in B$ holds. Relations $$ A\\times B\\triangleq \\{(x, y)\\space|\\space x\\in A \\text{ and }y\\in B\\} $$\nHere $(x, y)$ is called a pair. We denote $\\pi_0(x, y)=x,\\pi_1(x, y)=y$.\n$\\rho$ is a relation from $A$ to $B$ if $\\rho \\subseteq A\\times B$, or equivalently, $\\rho \\in \\mathcal P(A\\times B)$\nBasic notations Identity: $\\text{Id}_s\\triangleq \\{(x, y)\\space |\\space x\\in S\\}$. Domain: $dom(\\rho)\\triangleq \\{x\\space |\\space \\exists\\space y. (x,y)\\in \\rho\\}$. Range: $ran(\\rho)\\triangleq \\{y\\space |\\space \\exists\\space x. (x, y)\\in\\rho\\}$. Composition: $\\rho\u0026rsquo;\\circ\\rho\\triangleq \\{(x,z)\\space |\\space \\exists\\space y.(x,y)\\in \\rho \\space\\wedge\\space (y,z)\\in\\rho\u0026rsquo;\\}$. Inverse: $\\rho^{-1}\\triangleq \\{(x, y)\\space |\\space (y,x)\\in \\rho\\}$ Equivalence Relations $\\rho$ is an equivalence relation on $S$ if it\u0026rsquo;s reflexive, symmetric and transitive.\nReflexivity: $\\text{Id}_s\\subseteq \\rho$. Symmetry: $\\rho^{-1}\\subseteq \\rho$. Transitivity: $\\rho \\circ\\rho \\subseteq \\rho$. Functions A relation $\\rho$ is a function if for all $x,y,y\u0026rsquo;$, $(x,y)\\in \\rho$ and $(x,y\u0026rsquo;)\\in\\rho$ imply $y=y\u0026rsquo;$.\nEmpty set is a special function (check the definition).\nFunctions can be denoted by Typed Lambda Expressions: $\\lambda x\\in S. E$ denotes the function $f$ with domain $S$ such that $f(x)=E$ for all $x\\in S$.\nVariation Variation of a function at a single argument: $$ f\\{x\\rightsquigarrow n\\}\\triangleq \\lambda z. \\begin{cases} f\\space z\u0026amp;, z\\neq x\\\\ n\u0026amp;,z=x \\end{cases} $$ Note that $x$ does not have to be in $dom(f)$.\nFunction Types We use $A\\to B$ to represent the set of all functions from $A$ to $B$.\n$\\to$ is right associative, i.e., $A\\to B\\to C=A\\to(B\\to C)$.\nExample: if $f\\in A\\to B\\to C$, then for any $a\\in A$ and $b\\in B$ $f\\space a\\space b=(f(a))b\\in C$ (here $f(a)$ is another function).\nCurrying $f\\in A_1\\times A_2\\times \\cdots \\times A_n\\to B$, $f(a_1, a_2, \\cdots, a_n)=b$\nCurrying: $g\\in A_1\\to A_2\\to \\cdots A_n$. $g\\space a_1\\space a_2\\cdots a_n=b$.\nProducts Product: $$ S_0\\times S_1\\times S_{n-1}\\triangleq \\{(x_0,\\cdots, x_{n-1}\\space|\\space \\forall\\space i=1,\\cdots ,n.x_i\\in S_i\\} $$ $\\pi_i(x_0,\\cdots, x_{n-1})=x_i$.\nTuples as Functions $(x_0,x_1,\\cdots, x_{n-1})$ can be viewed as a function: $$ \\lambda i\\in \\mathbf{n}.\\begin{cases}x_0\u0026amp;,i=0\\\\x_1\u0026amp;,i=1\\\\\u0026amp;\\cdots\\\\x_{n-1}\u0026amp;,i={n-1}\\end{cases} $$ where $\\mathbf{n}=\\{0,1,\\cdots n-1\\}$.\nThen $$ S_0\\times \\cdots \\times S_{n-1}\\triangleq \\{f\\space|\\space dom(f)=\\mathbf{n}, \\forall\\space i\\in \\mathbf{n}, f\\space i\\in S_i\\} $$\nGeneralized Products $$ \\prod_{i\\in I}S(i)\\triangleq \\{f\\space |\\space dom(f)=I, \\forall \\space i\\in I,f\\space i\\in S(i)\\} $$\nLet $\\theta$ be a function from a set of indices to a set of sets, i.e., $\\theta$ is an indexed family of sets. Then $$ \\Pi\\theta\\triangleq \\{f\\space |\\space dom(f)=dom(\\theta), \\forall\\space i\\in dom(\\theta).f\\space i\\in \\theta\\space i\\} $$ Some interesting corner cases:\n$\\Pi \\emptyset=\\{\\emptyset\\}$. If there exists $i\\in dom(\\theta)$, $\\theta\\space i=\\emptyset$, then $\\Pi\\theta=\\emptyset$. Exponentiation We denote $S^T$ for $\\displaystyle{\\prod_{x\\in T} S}$ if $S$ is independent of $x$. An interesting fact is that $$ \\begin{align} S^T\u0026amp;=\\prod_{x\\in T}S=\\Pi\\lambda x\\in T. S\\\\ \u0026amp;=\\{f\\space|\\space dom(f)=T,\\forall\\space x\\in T,f\\space x\\in S\\}\\\\ \u0026amp;=(T\\to S) \\end{align} $$ We always use $\\mathbf{2}^S$ for power set $\\mathcal P(S)$. That\u0026rsquo;s because $\\mathbf{2}^S=(S\\to 2)$. For any subset $T$ of $S$, we can define $$ f = \\lambda x\\in S. \\begin{cases}1\u0026amp;, x\\in T\\\\0\u0026amp;,x\\notin T\\end{cases} $$ Then $f\\in (S\\to 2)$. For any $f\\in (S\\to \\mathbf{2})$, we can also construct a subset of $S$.\nSums $$ S_0+S_1+\\cdots+S_n\\triangleq \\{(i,x)\\space|\\space i\\in \\mathbf{n}, x\\in S_i\\} $$\nGeneralized form: $$ \\sum_{i\\in I}S(i)\\triangleq\\{(i,x)\\space |\\space i\\in I, x\\in S(i)\\} $$\n$$ \\Sigma\\theta\\triangleq \\{(i,x)\\space |\\space i\\in dom(\\theta),x\\in \\theta\\space i\\} $$\nWe can prove that $\\displaystyle{\\sum_{x\\in T}S}=T\\times S$: $$ \\begin{align} \\sum_{x\\in T}S=\\{(x,y)\\space|\\space x\\in T,y\\in S\\}=T\\times S \\end{align} $$\n","date":1663113600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1663113600,"objectID":"d034510a12dc95c82064711411c6b67a","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-formal-semantics/lectures/lec02/","publishdate":"2022-09-14T00:00:00Z","relpermalink":"/notes/coursenotes/nju-formal-semantics/lectures/lec02/","section":"notes","summary":"Sets Generalized Unions of Sets Generalized Intersections of Sets Relations Basic notations Equivalence Relations Functions Variation Function Types Currying Products Tuples as Functions Generalized Products Exponentiation Sums Sets Generalized Unions of Sets $$ \\begin{align} \\bigcup S \u0026amp;\\triangleq \\{x\\space |\\space \\exists \\space T\\in S.","tags":null,"title":"Lecture 02: Mathematical Background","type":"docs"},{"authors":null,"categories":null,"content":" The Need of Weak Memory Model Design Criteria Happened-before Memory Model (HMM) Example: Store Buffering Example: Out-of-thin-Air Read Example: Independent Reads of Independent Writes (IRIW) Example: HMM - No DRF guarantee. Memory models define which reads see which writes. Sequential Consistency (SC) model is the simplest memory model: several threads\u0026rsquo; executions are interleaved (interleaving semantics), every read fetches the most recent write (full visibility).\nThe Need of Weak Memory Model SC mode prohibits many optimizations, e.g. store buffering\nInitially: x = y = 0; x = 1; || y = 1; r1 = y; || r2 = x; r1 = r2 = 0 is impossible in SC model. However, compilers are unaware of concurrency and may adjust the order of statements, which violates SC model:\nr1 = y; #1 || y = 1; #2 x = 1 #4 || r2 = x; #3 SC model is inconsistent with the current compiler \u0026amp; architecture implementations. That\u0026rsquo;s why we need weak memory models, which allow more behaviors.\nDesign Criteria Usability: DRF guarantee. DRF programs should have the same behaviors as in SC model. DRF stands for Data-Race-Freedom. A data race occurs when we have two concurrent conflicting operations.\nConflicting: two operations both access the same memory location and at least one is a write.\nConcurrent: two operations are not ordered by \u0026ldquo;happens-before\u0026rdquo;. Here \u0026ldquo;happens-before\u0026rdquo; varies under different memory models. In SC, \u0026ldquo;happens-before\u0026rdquo; means:\nProgram order: statement $S_1$ appears before $S_2$. Synchronization-with: lock - unlock Implementability: WMM cannot be too strong. It should be compatible with the mainstream compilers/architecture design:\nAllow common optimization techniques. Allow standard compilation schemes to major modern architectures. That is, for an arbitrary code $C$, let $WMM(C)$ be the set of possible behaviors of $C$ under WMM, $Compiler(C)$ be the set of possible behaviors after compilation, $Compiler(C)\\subseteq WMM(C)$ should hold.\nHowever, WMM cannot be too week either. e.g., type-safety and security guarantee shall be preserved.\nCompiler Optimization Can Be Smart\nIt\u0026rsquo;s difficult to put forward a good WMM because optimizations are complex. For example,\nr1 = x; || y = 2; r2 = x; || x = r3; if (r1 == r2) y = 2; || The code can be optimized like this:\ny = 2; // reorder r1 = x; r2 = r1; // reduce memory access if (true); // \u0026quot;r2 = r1\u0026quot; guarantees (r1 == r2) Happened-before Memory Model (HMM) Program execution: a set of events, and some orders between them.\nHappened-before order is the transitive closure of po (program order) and sw (synchronize-with). In HMM, a read can see\nThe most recent write that happens before it. A write that has no happens-before relation. In WMM, we consider declarative semantics, i.e., instead of constructing the execution, we firstly do assumptions on the result of reads, then we draw execution graph and check whether the result is reasonable.\nExample: Store Buffering graph LR S1(x=y=0) --\u0026gt; S2(x=1) --\u0026gt; S3(r1=y // 0?) S1 --\u0026gt; S4(y=1) --\u0026gt; S5(r2=x // 0?) S5 -.-\u0026gt; S1 S3 -.-\u0026gt; S1 Assumption: r1 = r2 = 0, we find that x = y = 0 is the most recent write that happens before r1 = y and r2 = x. Therefore the assumption is reasonable.\nExample: Out-of-thin-Air Read Out-of-thin-air (OOTA) read means that the result is completely unreasonable.\nInitially: x = y = 0; r1 = x; | r2 = y; y = r1; | x = r2; assumption: r1 = r2 = 42; graph LR S1(x=y=0) --\u0026gt; S2(r1=x // 42?) --\u0026gt; S3(y=42) S1 --\u0026gt; S4(r2=y // 42?) --\u0026gt; S5(x=42) S2 -.-\u0026gt; S5 S4 -.-\u0026gt; S3 Another understanding:\nSpeculation: r2 should be 42, which means that y needs to be 42. If r2 equals 42, then in thread #2 x will be 42. If x equals 42, then in thread #1 r1 will be 42. If r1 equals 42, then in thread #1 y will be 42. -\u0026gt; cycle formed, justified! OOTA reads should be prohibited, otherwise malicious inputs may challenge the safety of programming languages. Java\u0026rsquo;s JMM spare great efforts to eliminate OOTA from HMM, resulting in JMM\u0026rsquo;s complexity, and JMM may generate some surprising behaviors.\nJMM\u0026rsquo;s Suprising Behaviors - Example\nC1; || lock I || lock I; || C3; ===\u0026gt; C1; || C3; C2; || C2; || unlock I; || unlock I; || Adding more synchronization may increase behaviors!\nC1; || C2 || C3; ===\u0026gt; C1; || C3; C2; || Inlining threads may increase behaviors!\nExample: Independent Reads of Independent Writes (IRIW) Initially: x = y = 0; x = 1; || r1 = x; || r3 = y; || y = 1; || r2 = y; || r4 = x; || Assumption: r1 = 1, r2 = 0, r3 = 1, r4 = 0; The assumption means that thread #2 shows x=1 happens before y=1 while thread #3 shows y=1 happens before x=1, which is impossible in SC.\ngraph LR S1(x=y=0) --\u0026gt; S2(x=1) S1 --\u0026gt; S3(r1=x // 1?) --\u0026gt; S6(r2=y // 0?) S1 --\u0026gt; S4(r3=y // 1?) --\u0026gt; S7(r4=x // 0?) S1 --\u0026gt; S5(y=1) S3 -.-\u0026gt; S2 S4 -.-\u0026gt; S5 S6 -.-\u0026gt; S1 S7 -.-\u0026gt; S1 However, In HMM, it\u0026rsquo;s allowed.\nExample: HMM - No DRF guarantee. Initially: x = y = 0; r1 = x; || r2 = y; if (r1 != 0) || if (r2 != 0) y = 42; || x = 42; In SC, since both if statements yield false, the two threads have no data race and the program satisfies DRF property. However, in HMM, r1 = r2 = 42 is possible, demonstrating that HMM doesn\u0026rsquo;t have DRF guarantee:\ngraph LR S1(x=y=0) --\u0026gt; S2(r1=x // 42?) --\u0026gt; |if pass|S3(y=42) S1 --\u0026gt; S4(r2=y // 42?) --\u0026gt; |if pass|S5(x=42) S4 -.-\u0026gt; S3 S2 -.-\u0026gt; S5 ","date":1663027200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1663027200,"objectID":"0e698f9c856517156b4061455a34c981","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-concurrency/lectures/lec02/","publishdate":"2022-09-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-concurrency/lectures/lec02/","section":"notes","summary":"The Need of Weak Memory Model Design Criteria Happened-before Memory Model (HMM) Example: Store Buffering Example: Out-of-thin-Air Read Example: Independent Reads of Independent Writes (IRIW) Example: HMM - No DRF guarantee.","tags":null,"title":"Lecture 02: Happens-before Memory Model","type":"docs"},{"authors":null,"categories":null,"content":"Limitations of Testing Tests can show the precense, not the absense of bugs.\nTesting is not useful in concurrent/network situations. Even if we find a bug, it\u0026rsquo;s difficult to reproduce it.\nCoq A formal proof management system. Refer to Software Foundations for Coq learning.\n","date":1662508800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1662508800,"objectID":"f70306b941c084dffeb8b64c1aad7e79","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-formal-semantics/lectures/lec01/","publishdate":"2022-09-07T00:00:00Z","relpermalink":"/notes/coursenotes/nju-formal-semantics/lectures/lec01/","section":"notes","summary":"Limitations of Testing Tests can show the precense, not the absense of bugs.\nTesting is not useful in concurrent/network situations. Even if we find a bug, it\u0026rsquo;s difficult to reproduce it.","tags":null,"title":"Lecture 01: Introduction","type":"docs"},{"authors":null,"categories":null,"content":" Implementations of Concurrent Programs Problem with Concurrency Model Summary Programmers View Memory Model Store Buffering Load Buffering WMM for High-Level Languages Implementations of Concurrent Programs Python:\nimport threading def func(): ... if __name__ == '__main__': t = threading.Thread(target=func,args=...) t.start() t.join() Java: use \u0026ldquo;Runnable\u0026rdquo; module\nC++: use \u0026lt;thread\u0026gt; header file.\nSome programming languages use message-passing mechanism instead of sharing memory, such as Go. But we can use the same abstraction.\nProblem with Concurrency Interleaving semantics means that the execution is non-deterministic, which is difficult for bug detection and reproduction.\nvoid thread_function() { for (int i = 0; i \u0026lt; 100; i++) std::cout \u0026lt;\u0026lt; \u0026quot;new thread\u0026quot; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; '\\n'; } int main () { std::thread t(thread_function); for (int i = 0; i \u0026lt; 100; i++) std::cout \u0026lt;\u0026lt; \u0026quot;main thread\u0026quot; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; '\\n'; } If we use \u0026lt;\u0026lt; to concatenate multiple outputs, the printing is not thread-safe and the example code results in interleaving outputs.\nThe simplest solution to this is to use locks (synchronization operations):\nstd::mutex mu; void shared_output(std::string msg, int i) { std::lock_guard\u0026lt;std::mutex\u0026gt; guard(mu); std::cout \u0026lt;\u0026lt; msg \u0026lt;\u0026lt; i \u0026lt;\u0026lt; '\\n'; } Model Summary Multiple threads Single shared memory Objects live in memory Unpredictable asynchronous delays. Programmers View Parallel composition, shared memory \u0026amp; interleaving semantics Lock \u0026amp; synchronization operations Concurrent objects (e.g. implementation of locks) and their clients Memory Model In computing, a memory model describes the interactions of threads through memory and their shared use of data.\nWhen we write codes, we use sequential consistency (SC) model to understand it. However:\nNo multiprocessor implements SC. Modern compilers may invalidate the order. Each hardware has its own memory model. Theses models are called weak/relaxed memory model. (Here the \u0026ldquo;weak\u0026rdquo; means that practical memory model may have more \u0026ldquo;unexpected\u0026rdquo; behavior.)\nStore Buffering Initially: x = y = 0; x = 1; | y = 1; r1 = y; | r2 = x; It\u0026rsquo;s possible that r1 = r2 = 0 ! (e.g. in X86.)\nX86\u0026rsquo;s TSO memory model:\nWhen we write data to the memory, the processor puts the data to the buffer and updates the buffer to the memory later. Each processor\u0026rsquo;s buffer is invisible to other processors.\nA possible execution leading to r1 = r2 = 0 is shown as follows:\nx = 1 in T1 (write to buffer) y = 1 in T2 (write to buffer) r1 = y in T1 (no y in T1\u0026rsquo;s buffer, read from memory, get 0) r2 = x in T2 (no x in T2\u0026rsquo;s buffer, read from memory, get 0) Update buffers to memory. Load Buffering Initially: x = y = 0; r1 = x; || r2 = y; y = 1; || x = 1; It\u0026rsquo;s possible that r1 = r2 = 1 ! (e.g. in ARM)\nWMM for High-Level Languages For programmers, if they write code that satisfies DRF property, the compilers and processors guarantee SC behavior.\nWe should embrace WMM since it\u0026rsquo;s part of the reality. Furthermore, many programs don\u0026rsquo;t rely on the strict SC model to ensure correctness.\n","date":1662422400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1662422400,"objectID":"ca23a34ca6964790afa6ab50b6eb4ab1","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-concurrency/lectures/lec01/","publishdate":"2022-09-06T00:00:00Z","relpermalink":"/notes/coursenotes/nju-concurrency/lectures/lec01/","section":"notes","summary":"Implementations of Concurrent Programs Problem with Concurrency Model Summary Programmers View Memory Model Store Buffering Load Buffering WMM for High-Level Languages Implementations of Concurrent Programs Python:\nimport threading def func(): .","tags":null,"title":"Lecture 01: Introduction","type":"docs"},{"authors":null,"categories":null,"content":"Error Handling Purpose of the compiler:\nto detect non-valid programs to translate the valid ones. The error handler should\nReport errors accurately and clearly Recover from an error quickly Not slow down compilation too much. Panic Mode When an error is detected, the parser discards tokens until one with a clear role is found and continues from there. The tokens \u0026ldquo;with a clear role\u0026rdquo; are referred to as syncrhonizing tokens and typically are the statement or expression terminators.\nFor example, the expression (1++2)+3 is invalid. When the parser sees the second +, it knows that it\u0026rsquo;s invalid to have 2 consecutive + and enters panic mode. In panic mode, a possible recovery strategy is to skip ahead to next integer and then continue, i.e., continue at 2.\nIn Bison, we can use the special terminal error to describe how much input to skip. For example, if we write $$ E\\to \\text{int}\\space |\\space E+E\\space |\\space (E)\\space |\\space \\text{error int}\\space |\\space (\\text{error}) $$ when the parser enters panic mode, error will match any number of characters and the rule error int will let the parser continue at the next integer.\nError Productions Another way to handle errors is to specify known common mistakes into the grammar. For example, it\u0026rsquo;s common for programmers to forget * (i.e. 5x instead of 5 * x), so we can write $$ E\\to\\space \u0026hellip;\\space |\\space E\\space E $$ The E E is responsible for matching errors.\nThe disadvantages of error productions is that it significantly slows down the compilation.\nError Correction Some compilers support error correction. When it encounters an error, it will find a correct \u0026ldquo;nearby\u0026rdquo; program through exhaustive search or token insertions/deletions.\nThe disadvantages of error correction:\nhard to implement. slows down parsing of correct programs. \u0026ldquo;nearby\u0026rdquo; is not necessarily \u0026ldquo;the intended\u0026rdquo; program. Abstract Syntax Trees For an expression 5+(12+3), we have a parse tree:\ngraph TD s1((E)) --\u0026gt; s2((E)) s1 --\u0026gt; s8((+)) s1 --\u0026gt; s3((E)) s2 --\u0026gt; s4((5)) s3 --\u0026gt; s5((\u0026quot;(\u0026quot;)) s3 --\u0026gt; s6((E)) s3 --\u0026gt; s7((\u0026quot;)\u0026quot;)) s6 --\u0026gt; s9((E)) s6 --\u0026gt; s10((+)) s6 --\u0026gt; s11((E)) s9 --\u0026gt; s12((12)) s11 --\u0026gt; s14((3)) However, the parse tree contains too much unnecessary information: parentheses, single-successor nodes etc. Therefore in compilers we use the abstract syntax tree (abbr: AST) instead.\ngraph TD s1(a) --\u0026gt; s2((5)) s1 --\u0026gt; s3(a) s3 --\u0026gt; s4((12)) s3 --\u0026gt; s5((3)) Recursive Descent Parsing In this algorithm, the parse tree is constructed from the top and from left to right. The general procedure is: we continuously check the left-most unchecked node:\nIf it\u0026rsquo;s an unterminal, we try the productions in order and recursively do the parsing. If it\u0026rsquo;s an terminal, we compare the node with the current character in the input string (backtracking is needed if they fail to match). Recursive Descent Algorithm Let TOKEN be the type of tokens. Let the global next pointer to the next input token.\nSome needed boolean functions:\nbool term(TOKEN tok) // whether a given token terminal matches the input bool Sn(); // whether the n-th production of S works bool S(); // whether there exists any production of S that works An example: productions for arithmetic expressions with + * and parentheses: $$ \\begin{align} E\u0026amp;\\to T\\space |\\space T+E\\\\ T\u0026amp;\\to \\text{int}\\space |\\space \\text{int}\\space *\\space T\\space |\\space (E) \\end{align} $$ Our code should be\nbool term(TOKEN tok) { return *next++ = tok; } bool E1() { return T(); } bool E2() { return T() \u0026amp;\u0026amp; term(PLUS) \u0026amp;\u0026amp; E(); } bool T1() { return term(INT); } bool T2() { return term(INT) \u0026amp;\u0026amp; term(TIMES) \u0026amp;\u0026amp; T(); } bool T3() { return term(OPEN) \u0026amp;\u0026amp; E() \u0026amp;\u0026amp; term(CLOSE); } bool E() { TOKEN *save = next; return (next = save, E1()) || (next = save, E2()); } bool T() { TOKEN *save = next; return (next = sava, T1()) || (next = save, T2()) || (next = save, T3()); } To start the parser, set next to the first character of the input string and call E().\nLeft Recursion Consider the following grammar: $S\\to S\\alpha\\space |\\space \\beta$, which accepts strings with $\\beta$ at the beginning and arbitrary $\\alpha$ after. If we write the code:\nbool S1() { return S() \u0026amp;\u0026amp; term(ALPHA); } bool S2() { return term(BETA); } bool S() { TOKEN *save = next; return (next = save, S1()) || (next = save, S2()); } The program will result in infinite loop (S() calls S1(), S1() calls S() and so on). The problem is that the grammar is left recursive - the derivation generate strings from right to left, but our parser scans from left to right. We need to rewrite the grammars as right recursive: $$ \\begin{align} S\u0026amp;\\to \\beta S\u0026rsquo;\\\\ S\u0026rsquo;\u0026amp;\\to \\alpha S\u0026rsquo;\\space |\\space \\epsilon \\end{align} $$ In principle, grammars can be transformed to right recursive ones automatically. But in practice people manually do the transformation.\n","date":1661212800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1661212800,"objectID":"44408969ca3660ac1a4a39cad428f574","permalink":"https://kristoff-starling.github.io/notes/coursenotes/stanford-compiler/lectures/lec06/","publishdate":"2022-08-23T00:00:00Z","relpermalink":"/notes/coursenotes/stanford-compiler/lectures/lec06/","section":"notes","summary":"Error Handling Purpose of the compiler:\nto detect non-valid programs to translate the valid ones. The error handler should\nReport errors accurately and clearly Recover from an error quickly Not slow down compilation too much.","tags":null,"title":"Stanford-CS143 Lecture 06: Syntax-Directed Translation","type":"docs"},{"authors":null,"categories":null,"content":"Regular expression is the weakest formal language. There are lots of languages that cannot be represented by regular expression. e.g. $\\{(^i)^i:i\\geq 1\\}=\\{(),(()), ((())),\u0026hellip;\\}$ (the set of balanced parentheses).\nThe parser takes the output of lexer, i.e. sequence of tokens as input, and outputs the parse tree of the program.\nCool code: if x = y then 1 else 2 fi\nParser input/lexer output: IF ID = ID THEN INT ELSE INT FI\nParser output:\nIF-THEN-ELSE---+----=---+---ID | | +---INT +---ID | +---INT Context-Free Grammars The parser must distinguish between valid and invalid strings of tokens. Therefore we need a language, and a method, for describing valid strings of tokens.\nProgramming languages have recursive structure, which makes parsing difficult, and context-free grammars are a natural notation for this recursive structure.\nA CFG consists of\nA set of terminals, denoted as $T$. A set of non-terminals, denoted as $N$. A start symbol $s\\in N$. A set of productions. Each production is of format $X\\to Y_1,\\cdots, Y_n$, where $X\\in N$, $Y_i\\in T\\cup N\\cup {\\epsilon}$. Productions can be read as rules, meaning that LHS can be replaced by RHS. Example: all balanced parentheses sequence: $T={(,)},N={s}$, two rules: $$ \\begin{align} s \u0026amp;\\to (s)\\\\ s \u0026amp;\\to \\epsilon \\end{align} $$ The way to understand a CFG:\nBegin with a string with only the start symbol $S$. Replace any non-terminal $X$ in the string by the right-hand side of some production $X\\to Y_1,\\cdots Y_n$. Repeat (2) until there are no non-terminals. Formally, we use $\\alpha_1\\overset{*}{\\to}\\alpha_2$ to represent that string $\\alpha_1$ can be transformed to string $\\alpha_2$ in 0 or more steps (applying productions). Let $G$ be a context-free grammar with start symbol $S$, then the language $L(G)$ of $G$ is $$ L(G)=\\{a_1a_2\\cdots a_n|\\forall i.a_i\\in T \\wedge S\\overset{*}{\\to}a_1\\cdots a_n\\} $$ Terminals have no productions. In parsing terminals are usually tokens.\nSome parsing examples: $$ \\begin{align} \\text{EXPR} \u0026amp;\\to id\\\\ \u0026amp;\\quad |\\space if\\space \\text{EXPR}\\space then\\space \\text{EXPR}\\space else\\space \\text{EXPR}\\space fi\\\\ \u0026amp;\\quad |\\space while\\space \\text{EXPR}\\space loop\\space \\text{EXPR}\\space pool\\\\ \u0026amp;\\quad |\\space \\cdots \\end{align} $$\nDerivations A derivation is a sequence of productions: $s\\to \\alpha_1\\to \\alpha_2\\to \\cdots$. Derivations can be represented as parse trees. For example, the arithmetic expression $id*id+id$ has a derivation $$ E\\to E+E\\to E*E+E\\to id*E+E\\to id*id+E\\to id*id +id $$ and the parse tree is\ngraph TD s1((E)) --\u0026gt; s2((E)) s1((E)) --\u0026gt; s3(+) s1 --\u0026gt; s4((E)) s2 --\u0026gt; s5((E)) s2 --\u0026gt; s6(*) s2 --\u0026gt; s7((E)) s4 --\u0026gt; s8((id)) s5 --\u0026gt; s9((id)) s7 --\u0026gt; s10((id)) Terminals are on the leaves of the parse tree and the in-order traversal of leaves results in the original string.\nFor one string, there are various derivations. The most commonly used ones are left-most and right-most derivations. But one string has only one parse tree.\nAmbiguity A grammar is ambiguous if it has more than one parse tree for some string.\nFor example, id * id + id has two different computing orders (*-first v.s. +-first). There are mainly two ways to handle with ambiguity:\nRewrite grammar unambiguously. Write $$ \\begin{align} E\u0026amp;\\to E\u0026rsquo;+E\\space |\\space E\u0026rsquo;\\\\ E\u0026rsquo;\u0026amp;\\to id*E\u0026rsquo;\\space |\\space id\\space |\\space (E)*E\u0026rsquo;\\space |\\space (E) \\end{align} $$ instead of one production ( $E$ can represent arbitrary $E\u0026rsquo;$s summing together, $E\u0026rsquo;$ is responsible for * )\nEnforces precedence of operators (* over +).\nThe next example illustrates that it\u0026rsquo;s difficult to write unambiguous grammars. It\u0026rsquo;s common for us to write the grammar for \u0026ldquo;if-then-else\u0026rdquo; like this: $$ \\begin{align} E\u0026amp;\\to if\\space E\\space then\\space E\\\\ \u0026amp;\\quad |\\space if\\space E\\space then\\space E\\space else\\space E\\\\ \u0026amp;\\quad |\\space \\text{OTHERS} \\end{align} $$\nHowever, the statement IF E1 THEN IF E2 THEN E3 ELSE E4 is ambiguous following the above grammar because we don\u0026rsquo;t know whether ELSE E4 belongs to the inner IF or the outer IF. Usually, we want the ELSE statement to match the nearest unmatched IF, i.e. the statement should be understood as IF E1 THEN(IF E2 THEN E3 ELSE E4). To solve this, we need to define \u0026ldquo;MIF\u0026rdquo; (matched IF) and \u0026ldquo;UIF\u0026rdquo; (unmatched IF) in the grammar:\n$$ \\begin{align} E\u0026amp;\\to \\text{MIF}\\space |\\space \\text{UIF}\\space\\\\ \\text{MIF} \u0026amp;\\to if\\space E\\space then\\space \\text{MIF}\\space else\\space \\text{MIF}\\\\ \u0026amp;\\quad |\\space \\text{OTHERS}\\\\ \\text{UIF} \u0026amp;\\to if\\space E\\space then\\space E\\\\ \u0026amp;\\quad |\\space if\\space E\\space then\\space \\text{MIF}\\space else\\space \\text{UIF}\\\\ \u0026amp;\\quad |\\space \\text{OTHERS} \\end{align} $$\nIt\u0026rsquo;s impossible to automatically convert an ambiguous grammar to an unambiguous one, and it\u0026rsquo;s also hard to manually write those complicated grammars. Besides, ambiguous grammar are more natural and concise, so the common practice is to choose more natural grammar along with disambiguating declarations.\nMost tools allow precedence and associativity declarations to disambiguate grammars. Take id * id + id as an example, the natural grammar $$ \\begin{align} E\u0026amp;\\to E + E\\\\ \u0026amp;\\quad |\\space E * E\\\\ \u0026amp;\\quad |\\space (E) \\end{align} $$ along with declarations\n%left + %left * can erase ambiguity. The declarations say that both + and * are left associative, and because *\u0026rsquo;s declaration comes later, * has higher priority than +.\n","date":1661126400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1661126400,"objectID":"2b6bdbf76649e58241f7efcfeef88326","permalink":"https://kristoff-starling.github.io/notes/coursenotes/stanford-compiler/lectures/lec05/","publishdate":"2022-08-22T00:00:00Z","relpermalink":"/notes/coursenotes/stanford-compiler/lectures/lec05/","section":"notes","summary":"Regular expression is the weakest formal language. There are lots of languages that cannot be represented by regular expression. e.g. $\\{(^i)^i:i\\geq 1\\}=\\{(),(()), ((())),\u0026hellip;\\}$ (the set of balanced parentheses).\nThe parser takes the output of lexer, i.","tags":null,"title":"Stanford-CS143 Lecture 05: Introduction to Parsing","type":"docs"},{"authors":null,"categories":null,"content":"3. Introduction flex æ˜¯ä¸€ä¸ªç”Ÿæˆ scanner çš„å·¥å…·ã€‚flex æ¥å—ä¸€ä¸ª .flex æ–‡ä»¶ï¼Œ.flex æ–‡ä»¶ç”¨äºæè¿°å¦‚ä½•ç”Ÿæˆä¸€ä¸ª scannerï¼Œç”±è‹¥å¹² rules ç»„æˆï¼Œæ¯æ¡è§„åˆ™éƒ½æ˜¯ä¸€ä¸ªæ­£åˆ™è¡¨è¾¾å¼å’Œä¸€æ®µ C ä»£ç çš„äºŒå…ƒç»„ã€‚flex å·¥å…·ä¼šè¾“å‡ºä¸€ä¸ª C ä»£ç  lex.yy.ccï¼Œè¯¥ä»£ç ä¸ flex çš„ runtime library é“¾æ¥ä¹‹åå¯ä»¥ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶ã€‚å¯æ‰§è¡Œæ–‡ä»¶æ‰§è¡Œæ—¶ä¼šåˆ†æè¾“å…¥çš„å†…å®¹ï¼Œå¦‚æœæŸæ¡è§„åˆ™çš„æ­£åˆ™è¡¨è¾¾å¼ä¸è¾“å…¥å†…å®¹åŒ¹é…åˆ™æ‰§è¡Œ rule ä¸­å®šä¹‰çš„ C ä»£ç ã€‚\n4. Some Simple Examples ä¸€ä¸ªæœ€ç®€å•çš„ä¾‹å­å¦‚ä¸‹ï¼š\nint num_lines = 0, num_chars = 0; %% \\n ++num_lines; ++num_chars; . ++num_chars %% . è¡¨ç¤ºåŒ¹é…é™¤äº†æ¢è¡Œç¬¦ä»¥å¤–çš„ä»»ä½•å­—ç¬¦ã€‚ä¸Šè¿°è§„åˆ™å¯ä»¥ç»Ÿè®¡è¾“å…¥å†…å®¹ä¸­çš„å­—ç¬¦æ•°é‡å’Œä»£ç è¡Œæ•°ã€‚\n5. Format ä¸€ä¸ª .flex æ–‡ä»¶çš„ç»“æ„å¦‚ä¸‹ï¼Œä¸åŒ section ç”± %% åˆ†å¼€ï¼š\ndefinitions %% rules %% user code 5.1 Definitions Section Definition åŒºåŸŸä¸­çš„æ¡ç›®æœä»å¦‚ä¸‹å½¢å¼ï¼š\nname definition å…¶ä¸­ name è¦æ±‚ä»¥ä¸‹åˆ’çº¿æˆ–å­—æ¯å¼€å¤´ï¼Œåé¢æ¥ä»»æ„ä¸ªæ•°çš„å­—æ¯ï¼Œä¸‹åˆ’çº¿å’Œ -ã€‚åç»­çš„å®šä¹‰ä¸­å¯ä»¥ç”¨ {name} çš„æ–¹å¼ä½¿ç”¨å‰é¢çš„å®šä¹‰ï¼Œä¾‹å¦‚\nDIGIT [0-9] ID [a-z][a-z0-9]* FLOAT {DIGIT}+\u0026quot;.\u0026quot;{DIGIT}* ç”±æ— ç¼©è¿›çš„ /* */ æˆ– %{ %} åŒ…è£¹ä½çš„å†…å®¹å°†è¢«åŸæ ·æ‹·è´åˆ°ç”Ÿæˆçš„ C ä»£ç ä¸­ã€‚ç”± %top{} åŒ…è£¹ä½çš„å†…å®¹å°†è¢«æ‹·è´åˆ° C ä»£ç çš„æœ€å‰é¢ã€‚\n5.2 Rules Section Rules åŒºåŸŸä¸­çš„æ¡ç›®æœä»å¦‚ä¸‹å½¢å¼ï¼š\npattern action å…¶ä¸­ pattern æ˜¯ç”¨äºè¯†åˆ«çš„æ¨¡å¼ï¼Œaction æ˜¯è¯†åˆ«åˆ° pattern åæ‰§è¡Œçš„æŒ‡ä»¤ï¼Œpattern å‰ä¸å¯ä»¥æœ‰ç¼©è¿›ï¼Œaction å¿…é¡»å’Œ pattern åœ¨åŒä¸€è¡Œ (å¦‚æœ action æœ‰å¤šè¡Œåˆ™ç¬¬ä¸€è¡Œéœ€è¦å’Œ pattern åŒè¡Œ)ã€‚\nåœ¨ rules section çš„ç¬¬ä¸€æ¡ rule ä¹‹å‰å¯ä»¥ç”¨ %{ %} åŒ…è£¹çš„æ–¹å¼å®šä¹‰ä¸€äº›å˜é‡ï¼Œè¿™äº›å˜é‡å¯ä»¥åœ¨ scanning çš„è¿‡ç¨‹ä¸­ä½¿ç”¨ã€‚\n5.3 User Code Section User code section ä¼šè¢«åŸæ ·æ‹·è´åˆ° C ä»£ç ä¸­ã€‚è¿™ä¸ªåŒºåŸŸæ˜¯ optional çš„ï¼Œå¦‚æœçœç•¥çš„è¯åˆ†å‰² rules å’Œ user code çš„ %% ä¹Ÿå¯ä»¥çœç•¥ã€‚\n5.4 Comments in the Input flex æ”¯æŒ C é£æ ¼çš„æ³¨é‡Šï¼Œå³ /* */ ä¹‹é—´çš„å†…å®¹éƒ½ä¼šè¢«è§†ä¸ºæ³¨é‡Šï¼Œè¿™äº›æ³¨é‡Šä¼šè¢«åŸæ ·æ‹·è´åˆ° C ä»£ç ä¸­ã€‚æ³¨é‡Šå‡ ä¹å¯ä»¥æ·»åŠ åœ¨ä»»ä½•åœ°æ–¹ï¼Œé™¤äº†ä»¥ä¸‹ä¸¤æ¡é™åˆ¶ï¼š\næ³¨é‡Šä¸èƒ½å‡ºç°åœ¨ rules section ä¸­æœ¬åº”è¯¥æ˜¯ pattern çš„åœ°æ–¹ï¼Œå³ /* */ ä¸èƒ½æ— ç¼©è¿›åœ°å‡ºç°åœ¨ä¸€è¡Œçš„å¼€å¤´æˆ–è€…å‡ºç°åœ¨ scanner states ä¹‹åã€‚ æ³¨é‡Šä¸èƒ½å‡ºç°åœ¨ definitions section ä¸­çš„ %option è¡Œä¸­ã€‚ 6. Patterns æœ¬ç« èŠ‚ç»™å‡ºäº†å¯ä»¥ç”¨äº rules section ä¸­ pattern çš„è¯­æ³•ã€‚ä¸»è¦è¯­æ³•å’Œæ‰©å±•æ­£åˆ™è¡¨è¾¾å¼ç›¸ä¼¼ã€‚\n7. How the Input Is Matched å¦‚æœå½“å‰æœ‰å¤šæ¡è§„åˆ™ pattern å¯ä»¥åŒ¹é…ï¼Œåˆ™ flex ä¼šé€‰æ‹©åŒ¹é…é•¿åº¦æœ€é•¿çš„è§„åˆ™ï¼›å¦‚æœæœ‰å¤šæ¡è§„åˆ™åŒ¹é…é•¿åº¦ç›¸åŒï¼Œåˆ™ flex ä¼šé€‰æ‹©æœ€å…ˆå‡ºç°çš„è§„åˆ™ (è¿™ä¸¤æ¡è§„åˆ™ä¸ç¼–è¯‘å™¨ lexical analysis çš„è¦æ±‚ç›¸ç¬¦)ã€‚\nå¦‚æœæ²¡æœ‰è§„åˆ™å¯ä»¥åŒ¹é…ï¼Œé‚£ä¹ˆ flex ä¼šä½¿ç”¨é»˜è®¤è§„åˆ™ï¼šå°†ç¬¬ä¸€ä¸ªå­—ç¬¦åŸæ ·è¾“å‡ºã€‚\nå½“ match å†³å®šä¹‹åï¼Œå…¨å±€å˜é‡ yytext (char æŒ‡é’ˆ) ä¼šæŒ‡å‘åŒ¹é…çš„å†…å®¹ (token)ï¼Œyyleng (int å˜é‡) ä¼šå­˜å‚¨åŒ¹é…çš„é•¿åº¦ï¼Œè¿™äº›å˜é‡å¯ä»¥åœ¨ action çš„ä»£ç ä¸­ä½¿ç”¨ã€‚\nyytext æœ‰ä¸¤ç§å¯ä»¥é€‰å–çš„å®šä¹‰æ–¹å¼ï¼šä¸€ä¸ªæ˜¯ char *ï¼Œä¸€ä¸ªæ˜¯ char []ï¼Œåœ¨ definitions section å¯ä»¥é€šè¿‡ %pointer/%array æ¥æŒ‡å®š (é»˜è®¤é‡‡å–æŒ‡é’ˆ)ã€‚\né‡‡å–æŒ‡é’ˆçš„å¥½å¤„æ˜¯æ›´å¿«çš„é€Ÿåº¦ä»¥åŠä¸ç”¨æ‹…å¿ƒ token è¿‡é•¿å¯¼è‡´çš„ overflow é—®é¢˜ã€‚ é‡‡å–æ•°ç»„çš„å¥½å¤„æ˜¯å¯ä»¥è‡ªç”±åœ°ä¿®æ”¹ yytext çš„å†…å®¹ã€‚æ•°ç»„çš„å¤§å°é»˜è®¤æ˜¯ YYLMAXï¼Œåœ¨ definitions section å¯ä»¥é€šè¿‡å®å®šä¹‰çš„æ–¹å¼è‡ªå®šä¹‰è¿™ä¸ªé•¿åº¦ã€‚ 8. Actions æ¯æ¡ rule ä¸­çš„ pattern éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„ actionï¼Œaction å¯ä»¥æ˜¯ä¸€æ®µä»»æ„çš„ C ä»£ç ã€‚å¦‚æœä¸€ä¸ª pattern åçš„ action ä¸ºç©ºï¼Œé‚£ä¹ˆè¿™ä¸ª pattern åŒ¹é…åˆ°çš„è¾“å…¥å†…å®¹å°†è¢«å¿½ç•¥ã€‚\nä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„ action çš„ä¾‹å­ï¼Œå®ƒå¯ä»¥å°†è¿ç»­çš„å¤šä¸ª whitespace ç¼©å‡æˆä¸€ä¸ªï¼Œå¹¶ä¸”è¿‡æ»¤è¡Œæœ« whitespaceï¼š\n%% [ \\t]+ putchar(' '); [ \\t]+$ /* ignore this token */ action ä¸­å¯ä»¥ä¹¦å†™ä»»æ„ C ä»£ç ï¼Œç”šè‡³å¯ä»¥ä½¿ç”¨ return å‘ yylex() çš„è°ƒç”¨è€…è¿”å›å†…å®¹ã€‚\nå¦‚æœ action ä¸­æœ‰ {ï¼Œé‚£ä¹ˆè¿™ä¸ª action æ˜¯å¯ä»¥è·¨è¡Œçš„ï¼Œflex ä¼šæŠŠç›´åˆ°ä¸å…¶å¯¹åº”çš„ } å‰çš„æ‰€æœ‰å†…å®¹å½“ä½œæœ¬æ¡ rule çš„ actionã€‚\nå¦‚æœ action çš„å†…å®¹æ˜¯ |ï¼Œé‚£ä¹ˆå®ƒçš„æ„æ€æ˜¯â€œè¯¥ rule çš„ action å’Œä¸‹ä¸€æ¡ rule çš„ action ç›¸åŒâ€ã€‚\naction ä¸­æœ‰ä¸€äº›ç‰¹æ®Šçš„å‘½ä»¤å¯ä»¥ä½¿ç”¨ï¼š\nECHOï¼šå°† yytext å¤åˆ¶åˆ° scanner çš„è¾“å‡ºä¸­ã€‚\nBEGINï¼šåé¢è·Ÿä¸€ä¸ª start conditionï¼Œåé¢ä¼šè¯¦ç»†ä»‹ç»è¿™ä¸€ç”¨æ³•ã€‚\nREJECTï¼šä½¿ç”¨ REJECT å°†ä¼šä½¿ scanner è½¬å‘ä¸‹ä¸€æ¡ second best çš„è§„åˆ™è¿›è¡ŒåŒ¹é…ã€‚ä¾‹å¦‚ï¼š\nint word_count = 0; %% frob special(); REJECT; [^ \\t\\n]+ word_count++; è¿™æ®µä»£ç çš„æ„æ€æ˜¯é‡åˆ°å•è¯ \u0026ldquo;frob\u0026rdquo; å°±æ‰§è¡Œä¸€ä¸ªç‰¹æ®Šçš„å‡½æ•° special()ã€‚åœ¨ frob åä½¿ç”¨ REJECT åˆ™ä¼šåœ¨æ‰§è¡Œå®Œ special() åä½¿ scanner è½¬å‘ç¬¬äºŒæ¡è§„åˆ™çš„ pattern å†åŒ¹é…ä¸€æ¬¡ï¼Œä»è€Œ frob ä¹Ÿä¼šè¢«è®¡å…¥åˆ°å•è¯æ€»æ•°ä¸­ã€‚å¦‚æœå»æ‰è¿™ä¸ª REJECTï¼Œ\u0026ldquo;frob\u0026rdquo; å°±åªä¼šè§¦å‘ç¬¬ä¸€æ¡è§„åˆ™ï¼Œä»è€Œå•è¯ä¸ªæ•°ç»Ÿè®¡å‡ºé”™ã€‚\nyymore()ï¼šå‘Šè¯‰ scanner ä¸‹ä¸€æ¬¡åŒ¹é…åˆ°æŸæ¡è§„åˆ™çš„æ—¶å€™è¦å°† token è¿½åŠ åˆ°æœ¬æ¬¡çš„ token åé¢è€Œä¸æ˜¯è¦†ç›–ï¼Œä¾‹å¦‚ï¼š\n%% mega- ECHO; yymore(); kludge ECHO; å¦‚æœ scanner çš„è¾“å…¥æ˜¯ \u0026ldquo;mega-kludge\u0026rdquo;ï¼Œé‚£ä¹ˆè¾“å‡ºç»“æœå°†ä¼šæ˜¯ \u0026ldquo;mega-mega-kludge\u0026rdquo;ï¼Œå› ä¸ºåŒ¹é…åˆ° kludge æ—¶ç”±äºå‰ä¸€æ¬¡ \u0026ldquo;mega-\u0026rdquo; è°ƒç”¨äº† yymore()ï¼Œæ‰€ä»¥ ECHO çš„æ—¶å€™å°† \u0026ldquo;kludge\u0026rdquo; è¿½åŠ åˆ°ä¹‹å‰çš„ \u0026ldquo;mega-\u0026rdquo; åé¢ã€‚\nä¸¤æ¡æ³¨è®°ï¼š\nyymore() çš„æ­£ç¡®æ‰§è¡Œè¦æ±‚ç”¨æˆ·ä»£ç ä¸èƒ½éšæ„æ›´æ”¹ yylengã€‚ yymore() ä¼šè½»å¾®å½±å“ scanner åŒ¹é…çš„æ•ˆç‡ã€‚ yyless(n)ï¼šå°†å½“å‰ token é™¤äº†å‰ n ä¸ªå­—ç¬¦ä»¥å¤–çš„åç»­å­—ç¬¦é€€å›åˆ°è¾“å…¥æµä¸­ä¾› scanner ä¸‹æ¬¡å†æ‰«æã€‚ä¾‹å¦‚ï¼š\n%% foobar ECHO; yyless(3); [a-z]+ ECHO; å¦‚æœ scanner çš„è¾“å…¥æ˜¯ \u0026ldquo;foobar\u0026rdquo;ï¼Œé‚£ä¹ˆè¾“å‡ºç»“æœå°†ä¼šæ˜¯ \u0026ldquo;foobarbar\u0026rdquo;ã€‚\nç‰¹åˆ«åœ°ï¼Œyyless(0) ä¼šå°†æ•´ä¸ª token é€€å›åˆ°è¾“å…¥æµä¸­ï¼Œæ‰€ä»¥é™¤é action ä¸­æœ‰ BEGINï¼Œè°ƒç”¨ yyless(0) å°†ä¼šå¯¼è‡´æ­»å¾ªç¯ã€‚\nunput(c)ï¼šå°†å­—ç¬¦ c æ”¾å…¥åˆ°è¾“å…¥æµä¸­ï¼Œscanner ä¸‹ä¸€ä¸ªæ‰«æåˆ°çš„å­—ç¬¦å°†ä¼šæ˜¯å­—ç¬¦ cã€‚ä¾‹å¦‚ï¼Œä¸‹é¢çš„ä»£ç ä¼šå°†åŒ¹é…åˆ°çš„ token å·¦å³åŠ ä¸Šæ‹¬å·é€€å›åˆ°è¾“å…¥æµä¸­ (æ³¨æ„ unput(c) çš„è¯­ä¹‰è¦æ±‚å¿…é¡»è¦å°†å­—ç¬¦æŒ‰ç…§å€’åºé€€å›åˆ°è¾“å…¥æµä¸­ï¼Œè¿™æ ·å†æ¬¡æ‰«æå¾—åˆ°çš„æ‰æ˜¯æ­£åº)ï¼š\n{ int i; /* Copy yytext because unput() trashes yytext */ char *yycopy = strdup(yytext); unput(')'); for (i = yyleng - 1; i \u0026gt;= 0; i--) unput(yycopy[i]); unput('('); free(yycopy); } ä½¿ç”¨ unput() éœ€è¦æ ¼å¤–æ³¨æ„çš„ä¸€ç‚¹æ˜¯ï¼šå¦‚æœ yytext ä½¿ç”¨çš„æ˜¯é»˜è®¤çš„ %pointerï¼Œè°ƒç”¨ unput() ä¼šæŸå yytext çš„å†…å®¹ (æ¯è°ƒç”¨ä¸€æ¬¡éƒ½ä¼šè¦†ç›–æœ€å³ä¾§çš„ä¸€ä¸ªå­—ç¬¦)ï¼Œå› æ­¤å¦‚æœæƒ³è¦ä¿ç•™ yytext åŸæœ¬çš„å†…å®¹ï¼Œè¦ä¹ˆåƒç¤ºä¾‹ä»£ç ä¸€æ ·æå‰æŠŠå†…å®¹å¤åˆ¶å‡ºæ¥ (ä¸èƒ½åªå¤åˆ¶æŒ‡é’ˆï¼)ï¼Œè¦ä¹ˆä½¿ç”¨ %array ä½œä¸º yytextã€‚\næ­¤å¤–ï¼Œä¸å¯ä»¥è°ƒç”¨ unput() å°† \u0026lt;EOF\u0026gt; æ”¾å…¥åˆ°è¾“å…¥æµä¸­ã€‚\ninput()ï¼šè¯»å–è¾“å…¥æµä¸­çš„ä¸‹ä¸€ä¸ªå­—ç¬¦ã€‚ä¾‹å¦‚ä¸‹é¢çš„ä»£ç å¯ä»¥åƒæ‰è¾“å…¥ä¸­çš„ C æ³¨é‡Šï¼š\n%% \u0026quot;/*\u0026quot; { int c; for (;;) { while ((c = input()) != '*' \u0026amp;\u0026amp; c != EOF) ; /* eat up text of comment */ if (c == '*') { while ((c = input()) == '*') ; if (c == '/') break; /* found the end */ } if (c == EOF) { error(\u0026quot;EOF in comment\u0026quot;); break; } } } æ³¨ï¼šå¦‚æœ scanner æ˜¯ç”¨ C++ ç¼–è¯‘çš„ï¼Œé‚£ä¹ˆåº”å½“ä½¿ç”¨ yyinput() ä»¥é¿å…å‡½æ•°åä¸ C++ è‡ªå¸¦å‡½æ•°å†²çªã€‚\n9. The Generated Scanner flex çš„è¾“å‡ºæ˜¯ä¸€ä¸ª C æ–‡ä»¶ lex.yy.cï¼Œå…¶ä¸­æœ‰ä¸€ä¸ª scanning routine yylex()ï¼Œä¸€äº›ç”¨äºåŒ¹é… token çš„è¡¨æ ¼å’Œä¸€äº›å…¶ä»–çš„è¾…åŠ© routine å’Œ macroã€‚é»˜è®¤æƒ…å†µä¸‹ yylex() çš„å£°æ˜æ˜¯è¿™æ ·çš„ï¼š\nint yylex() { ... various definitions and actions in here } é€šè¿‡å®šä¹‰ YY_DECL å®çš„æ–¹å¼æˆ‘ä»¬å¯ä»¥ä¿®æ”¹ yylex() çš„å£°æ˜ï¼Œæ¯”å¦‚\n#define YY_DECL float lexscan(a, b) float a, b; çš„æ–¹å¼å°† yylex() æ”¹åä¸º lexscan()ï¼Œè¿”å›å€¼æ˜¯ float ä¸”æ¥å—ä¸¤ä¸ªå‚æ•° a bã€‚\nå½“ yylex() è¢«è°ƒç”¨åï¼Œå®ƒä¼šä»æ–‡ä»¶ yyin (é»˜è®¤ä¸º stdin) ä¸­æ‰«æ token å¹¶æ‰§è¡Œ actionï¼Œå½“ action ä¸»åŠ¨è¿”å›æˆ–è€…é‡åˆ° EOF (æ­¤æ—¶è¿”å›å€¼æ˜¯ 0) æ—¶ yylex() ä¼šåœæ­¢è¿è¡Œï¼Œå¦åˆ™ä¼šä¸€ç›´æ‰§è¡Œã€‚\nå½“ yylex() é‡åˆ° EOF æ—¶ï¼Œåç»­çš„æ‰§è¡Œè¿‡ç¨‹æ˜¯æœªå®šä¹‰çš„ï¼Œé™¤é yyin æŒ‡å‘äº†æ–°çš„è¾“å…¥æ–‡ä»¶æˆ–è€… yyrestart() è¢«è°ƒç”¨ã€‚æ³¨æ„è°ƒç”¨ yyrestart() ä¸ä¼šå°† start condition ç½®ä¸º INITIALï¼›å½“ yylex() å›  action è¿”å›è€Œç»ˆæ­¢æ—¶ï¼Œyylex() ä¼šå†æ¬¡è¢«è°ƒç”¨ä¸”ä»ä¸Šä¸€æ¬¡ç»ˆæ­¢çš„åœ°æ–¹ç»§ç»­æ‰«æã€‚\nscanner ä¸­çš„ ECHO å‘½ä»¤ä¼šè¾“å‡ºåˆ° yyout æ–‡ä»¶ä¸­ (é»˜è®¤ä¸º stdout)ï¼Œå¯ä»¥é€šè¿‡å®å®šä¹‰çš„æ–¹å¼æ¥ä¿®æ”¹ã€‚\n10. Start Conditions flex æä¾›ä¸€ç§æœºåˆ¶ï¼Œå¯ä»¥è®© rules æ¡ä»¶æ€§åœ°è¢«æ¿€æ´»ã€‚å¦‚æœä¸€æ¡ rule çš„å‰ç¼€æ˜¯ \u0026lt;sc\u0026gt;ï¼Œé‚£ä¹ˆåªæœ‰å½“ scanner å¤„äº \u0026ldquo;sc\u0026rdquo; è¿™ä¸ª start condition çš„æ—¶å€™è¯¥ rule æ‰å¤„äº active çš„çŠ¶æ€ã€‚\nstart condition åœ¨ definitions section ä¸­å®šä¹‰ã€‚æœ‰ä¸¤ç§å®šä¹‰æ–¹æ³•ï¼š%s sc å’Œ %x scï¼Œç¬¬ä¸€ç§æ–¹æ³•æ˜¯ inclusive çš„ start conditionï¼Œå®ƒçš„æ„æ€æ˜¯æ²¡æœ‰ä»»ä½•å‰ç¼€çš„è§„åˆ™é»˜è®¤ä¹Ÿå¯ä»¥è¢«è¯¥ sc æ¿€æ´»ï¼›ç¬¬äºŒç§æ–¹æ³•æ˜¯ exclusive çš„ start conditionï¼Œå®ƒçš„æ„æ€æ˜¯åªæœ‰æ˜¾å¼åœ°æ ‡æ³¨äº† \u0026lt;sc\u0026gt; å‰ç¼€çš„è§„åˆ™æ‰èƒ½è¢« sc æ¿€æ´»ã€‚ä¸¾ä¸€ä¸ªä¾‹å­ï¼Œä¸‹é¢çš„ä¸¤æ®µä»£ç ç­‰ä»·ï¼š\n%s example %% \u0026lt;example\u0026gt;foo do_something(); bar something_else(); %x example %% \u0026lt;example\u0026gt;foo do_something(); \u0026lt;INITIAL, example\u0026gt;bar something_else(); ä¸€ä¸ªç‰¹æ®Šçš„å‰ç¼€æ˜¯ \u0026lt;*\u0026gt;ï¼Œå®ƒè¡¨ç¤ºæ‰€æœ‰çš„ start conditionï¼Œæœ‰è¿™ä¸ªå‰ç¼€çš„è§„åˆ™åœ¨ä»»ä½• start condition ä¸‹éƒ½å¤„äº active çŠ¶æ€ã€‚\nåœ¨ action ä¸­ä½¿ç”¨ BEGIN è¯­å¥å¯ä»¥æ¿€æ´»ä¸€ä¸ª start conditionã€‚ä¸€ä¸ªç‰¹æ®Šçš„ç”¨æ³•æ˜¯ BEGIN(0) å’Œ BEGIN(INITIAL)ï¼Œå®ƒä»¬çš„åŠŸèƒ½ç›¸åŒï¼Œéƒ½æ˜¯æŒ‡æ¿€æ´»é‚£äº›æ²¡æœ‰å‰ç¼€çš„è§„åˆ™ã€‚\nå¦‚æœæœ‰å¤šæ¡è§„åˆ™ä½¿ç”¨ç›¸åŒçš„ sc å‰ç¼€ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¦‚ä¸‹è¯­æ³•ç®€åŒ–ä»£ç çš„ä¹¦å†™ï¼š\n\u0026lt;SCs\u0026gt; { pattern1 action1; pattern2 action2; ... } /* equivalent to * \u0026lt;SCs\u0026gt;pattern1 action1 * \u0026lt;SCs\u0026gt;pattern2 action2 * ... */ ","date":1660435200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1660435200,"objectID":"172b98679ef5af42d7887e657255f944","permalink":"https://kristoff-starling.github.io/notes/manualnotes/flex/","publishdate":"2022-08-14T00:00:00Z","relpermalink":"/notes/manualnotes/flex/","section":"notes","summary":"è¯¥ç¬”è®°æ˜¯å¯¹ flex å·¥å…·æ‰‹å†Œç²¾åéƒ¨åˆ†çš„ç¿»è¯‘å’Œè§£è¯»ã€‚flex æ˜¯ä¸€æ¬¾åŸºäº C/C++ çš„é€šè¿‡æ­£åˆ™è¡¨è¾¾å¼ç”Ÿæˆç¼–è¯‘å™¨ scanner ä»£ç çš„å·¥å…·ã€‚","tags":null,"title":"Flex Manual - Notes","type":"notes"},{"authors":null,"categories":null,"content":"Summary of (extended) regular expression rules:\nAt least one: $A^{+}\\triangleq AA^*$ Union: $A | B \\triangleq A + B$ Option: $A?\\triangleq A+\\epsilon$ Range: $[a- z]\\triangleq a+b+\\cdots+z$ Excluded range: $[$^$a- z]\\triangleq$ complement of $[a- z]$ Lexical Specification The procedure of lexical analysis:\nWrite a rexp for the lexemes of each token class, i.e., number, identifier, keywords etc.\nConstruct $R$, matching all lexemes i.e. $R = R_1 + R_2 + \\cdots$.\nLet input be $x_1x_2\\cdots x_n$, for each $1\\leq i\\leq n$, check whether $x_1\\cdots x_i\\in L(R)$.\nWhich prefix to choose?\nSometimes we may have $x_1\\cdots x_i\\in L(R)$, $x_1\\cdots x_j\\in L(R)$ and $i\\neq j$ (e.g. == and =). In this situation we follow the \u0026ldquo;maximal munch\u0026rdquo; principle, i.e., we always choose the longer one.\nWhat if no rule matches?\nCompilers should do error handling instead of crashing when there is an lexical error. A common way to handle this is to define an extra set $\\text{Error}\\triangleq \\text{all strings}$ and give it the lowest priority.\nIf success, then we know that $x_1\\cdots x_i\\in L(R_j)$ for some $j$.\nWhich token to choose?\nSometimes we may have $x_1\\cdots x_i\\in L(R_j)$, $x_1\\cdots x_i\\in L(R_k)$ and $j\\neq k$. (e.g. if is a keyword, but it also satisfies the definition of identifiers). In this situation we choose the one with higher priority.\n(Actually, usually in the definition of identifiers keywords are explicitly excluded.)\nRemove $x_1\\cdots x_i$ from input and go to (3).\nFinite Automata A regular expression $R$ formally defines a set of strings $L(R)$. However, we need an implementation to identify that given a string $s$, whether $s\\in L(R)$. Finite automata is a good implementation model.\nA finite automaton consists of\nAn input alphabet $\\Sigma$ A finite set of states $S$ A start state $n$ A set of accepting states $F\\subseteq S$ A set of transitions $\\text{state1}\\overset{input}{\\to}\\text{state2}$ Given an input string, If we reach the end of input and we\u0026rsquo;re an accepting state, the automaton accept the string. The automaton reject a string if 1) we\u0026rsquo;re not in an accepting state. 2) we get stuck (no transition).\nThe language of a finite automaton is the set of accepted strings.\nExample: a finite automaton accepting strings with any number of 1 and a 0 at the end.\ngraph LR s1((A)) s2(B) s1 --\u0026gt; |0|s2 s1 --\u0026gt; |1|s1 There\u0026rsquo;s a special transition called $\\epsilon$ transition: $A\\overset{\\epsilon}{\\to}B$. This transition doesn\u0026rsquo;t consume any character, i.e., we can choose to go to $B$ from $A$ with no condition.\nThere are 2 kinds of FA:\nDeterministic Finite Automata (DFA):\nOne transition per input label per state No $\\epsilon$-moves Nondeterministic Finite Automata (NFA):\nCan have multiple transitions for one input label in a given state Can have $\\epsilon$-moves Actually, the first condition is not essential because we can use $\\epsilon$-moves to transform it into a normal one. Here\u0026rsquo;s an example:\ngraph LR s1(1) --\u0026gt; |1|s2(2) s1 --\u0026gt; |1|s3(3) s4(1) --\u0026gt; |e|s5(N/A) s4 --\u0026gt; |e|s6(N/A) s5 --\u0026gt; |1|s7(2) s6 --\u0026gt; |1|s8(3) A crucial difference between DFA and NFA is that given an input, after receiving several characters, we\u0026rsquo;re in a certain state in DFA while we may be in a set of possible states in NFA. An NFA accepts a string if there exists a path that reaches an accepting state.\nNFA, DFA and regular expressions have the equivalent power of representing languages. Usually DFA are faster to execute (there\u0026rsquo;s no choice to consider), but NFA is much smaller (exponentially smaller).\nRegular Expressions to NFAs Target: lexical specification $\\to$ regular expressions $\\to$ NFA $\\to$ DFA $\\to$ table-driven implementation of DFA\nThe way we transform regular expressions to NFAs is to design an NFA for each RE rule.\nWe denote the NFA for expression A as\ngraph LR s1((st)) --\u0026gt; s2([A's NFA]) --\u0026gt; s3[ed] $\\epsilon$:\ngraph LR s1((st)) --\u0026gt; |e| s2[ed] A character $a$:\ngraph LR s1((st)) --\u0026gt; |a| s2[ed] Rule $AB$:\ngraph LR s1((A's st)) --\u0026gt; s2([A's NFA]) --\u0026gt; s3(A's ed) --\u0026gt;|e| s4(B's st) --\u0026gt; s5([B's NFA]) --\u0026gt; s6[B's ed] Rule $A + B$:\ngraph LR s1((st)) --\u0026gt; |e| s2(A's st) s1 --\u0026gt; |e| s3(B's st) s2 --\u0026gt; s4([A's NFA]) s3 --\u0026gt; s5([B's NFA]) s4 --\u0026gt; s6(A's ed) s5 --\u0026gt; s7(B's ed) s6 --\u0026gt; |e| s8[ed] s7 --\u0026gt; |e| s8[ed] Rule $A^*$:\ngraph LR s1((st)) --\u0026gt; |e| s2(A's st) --\u0026gt; s3([A's NFA]) --\u0026gt; s4(A's ed) --\u0026gt;|e| s5[ed] s4 --\u0026gt; |e| s1 s1 --\u0026gt; |e| s5 An example: $(1+0)^*1$:\nNFA to DFA An NFA may be in many states at any time. However, for a n-state NFA, there are at most $2^N-1$ different subsets of states, which is finite. That\u0026rsquo;s the core idea of how to transform NFA to DFA.\n$\\fbox{Definition}$ ($\\epsilon$-closure) The $\\epsilon$-closure of a node $q$ in NFA, denoted as $\\epsilon\\text{-closure}(q)$, is the set of nodes that can be reached from $q$ by walking through only $\\epsilon$ edges. For example, in the NFA above, $\\epsilon\\text{-closure}(q_6)={q_0,q_1,q_2,q_4,q_7,q_8}$.\n$\\fbox{Definition}$ For a set of states $X$ and a character $a$ in NFA, $a(X)\\triangleq {y|\\exists x\\in X, x\\overset{a}{\\to}y}$.\nComponents of an NFA:\nstates: a set $S$. start: a state $s\\in S$. final: a set $F\\subseteq S$. Corresponding DFA:\nstates: nonempty subsets of $S$. start: $\\epsilon\\text{-closure}(s)$. final: ${X\\subseteq S|X\\cap F\\neq \\emptyset}$. transitions: $X\\overset{a}{\\to}Y$ exists iff $Y=\\epsilon\\text{-closure}(a(X))$. An example: $(1+0)^*1$:\nImplementing Finite Automata A DFA can be represented as a 2D table. States and input symbols are the two dimensions and the contents of the table are transition. Pseudocode can be written based on this:\ni = 0; state = initial; while (input[i] != '\\0') { state = table[state][input[i]]; i++; } If the table is too huge, we can directly use NFA: the table should add a column representing $\\epsilon$ transitions and all the contents are set of states instead of states.\nAlthough NFA\u0026rsquo;s table is more concise, the simulation is more expensive because we have to maintain a set of current states.\n","date":1660089600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1660089600,"objectID":"b17e8a092f542e94d353d8953595cd83","permalink":"https://kristoff-starling.github.io/notes/coursenotes/stanford-compiler/lectures/lec04/","publishdate":"2022-08-10T00:00:00Z","relpermalink":"/notes/coursenotes/stanford-compiler/lectures/lec04/","section":"notes","summary":"Summary of (extended) regular expression rules:\nAt least one: $A^{+}\\triangleq AA^*$ Union: $A | B \\triangleq A + B$ Option: $A?\\triangleq A+\\epsilon$ Range: $[a- z]\\triangleq a+b+\\cdots+z$ Excluded range: $[$^$a- z]\\triangleq$ complement of $[a- z]$ Lexical Specification The procedure of lexical analysis:","tags":null,"title":"Stanford-CS143 Lecture 04: Implementation of Lexical Analysis","type":"docs"},{"authors":null,"categories":null,"content":"Token classes:\nIn English: nouns, verbs, adjactives etc. In programming languages: identifiers, keywords, \u0026ldquo;()\u0026rdquo; etc. Identifier: strings of letters or digits, staring with a letter (variable names). Integer: a non-empty string of digits (leading zeroes are allowed). Keywords: \u0026ldquo;if\u0026rdquo;, \u0026ldquo;else\u0026rdquo;, \u0026ldquo;begin\u0026rdquo; etc. Whitespace: a non-empty sequence of blanks, newlines and tabs Operator: relational operators like == \u0026lt; \u0026gt; etc. ( ) ; = : these are special token classes which consist of only one string. A key-value pair of format \u0026lt;class, string\u0026gt; is called a token. The lexical analyzer takes in a string(program) and outputs tokens to the parser. For exampleï¼š\nInput: foo=42 Output: \u0026lt;identifier, \u0026quot;foo\u0026quot;\u0026gt; , \u0026lt;operator, \u0026quot;=\u0026quot;\u0026gt; , \u0026lt;integer, \u0026quot;42\u0026quot;\u0026gt; (note: here \u0026ldquo;42\u0026rdquo; is a string, not a number!) An implementation of LA must do two things:\nRecognize substrings corresponding to tokens, which are called lexemes. Idenfity the token class of each lexeme. LA Examples FORTRAN rule: whitespace is insignificant. So VAR1 is the same as VA R 1.\nAn Example:\nDO 5 I = 1, 25 DO 5 I = 1.25 The first line is a do-loop where variable I iterates from 1 to 25. The second line, however, is a variable definition - DO5I = 1.25. When we scan the string from left to right, at tht point we finish \u0026ldquo;DO\u0026rdquo; we\u0026rsquo;re not sure whether it\u0026rsquo;s a keyword, we must look ahead to see whether there\u0026rsquo;s a comma. Therefore, \u0026ldquo;lookahead\u0026rdquo; may be required to decide where one token ends and the next token begins.\n\u0026ldquo;lookahead\u0026rdquo; is a universal need even in modern PLs. For example,\nif (i == j) x = 1; else x = 2; when we encounter =, we need to look ahead to decide whether it\u0026rsquo;s a double-equal; when we encounter e we need to look ahead to decide whether it\u0026rsquo;s a variable name or a keyword.\nPL/1 rule: keywords are not reserved (i.e. keywords can be used as variable names).\nIF ELSE THEN THEN = ELSE; ELSE ELSE = THEN It\u0026rsquo;s challenging to recognize which ELSE\u0026amp;THEN are variables.\nDECLARE(ARG1, ..., ARGN) we\u0026rsquo;re not sure whether DECLARE is a keyword or an array reference. Since it can have arbitrary number of arguments, an unbounded lookahead will be required.\nRegular Languages We must specify what set of strings is in a token class, and the solution is to use regular languages.\n2 base cases:\nSingle character: $c\\triangleq {c}$ Epsilon: $\\epsilon\\triangleq {\u0026rsquo;\u0026rsquo;}$ 3 compound expressions:\nUnion: $A+B\\triangleq \\{a|a\\in A\\}\\cup \\{|b\\in B\\}$ Concatenation: $AB\\triangleq \\{ab|a\\in A,b\\in B\\}$ Iteration: $A^* \\triangleq \\left\\{\\bigcup_{i\\geq 0}A^i \\right\\}$, here $A^0=\\epsilon$. $\\fbox{Definition 3.1}$ The regular expressions over $\\Sigma$ are the smallest set of expressions including: $$ \\begin{align} R::=\u0026amp;\\quad\\space \\epsilon\\\\ \u0026amp;|\\quad c, c\\in \\Sigma\\\\ \u0026amp;|\\quad R + R\\\\ \u0026amp;|\\quad RR\\\\ \u0026amp;|\\quad R^* \\end{align} $$\nFormal Languages $\\fbox{Definition 3.2}$ Let $\\Sigma$ be a set of characters (an alphabet), a language over $\\Sigma$ is a set of strings of characters drawn from $\\Sigma$.\ne.g. Alphabet = English characters, Language = sentences (maybe we need a strict definition of valid sentences)\ne.g. Alphabet = ASCII, Language = C programs (this is rigorous, the language is exactly what C compilers accept)\nA meaning function $L:\\text{expression}\\to \\text{set of strings}$ is a mapping that maps syntax to semantics. For example, the rigorous way of defining regular expression symbols are: $$ \\begin{align} L(\\epsilon)\u0026amp;={\u0026rsquo;\u0026rsquo;}\\\\ L(c)\u0026amp;={c}\\\\ L(A+B)\u0026amp;=L(A)\\cup L(B)\\\\ L(AB)\u0026amp;={ab:a\\in L(A),b\\in L(B)}\\\\ L(A^*)\u0026amp;=\\bigcup_{i\\geq 0}L(A^i) \\end{align} $$ The mappings between expressions and meanings are not 1-to-1. it\u0026rsquo;s many-to-1: e.g. $L(11+10)=L(1(1+0))$. This is the foundation of optimization: we can use simpler expressions to do exactly the same thing. But meaning functions should never be 1-to-many, indicating that the language is ambiguous.\nMeaning function makes clear what is syntax and what is semantics. It allows us to consider notation as a separate issue. It\u0026rsquo;s important to think about syntax/notation separately. For example, Roman numerals and Arabic numerals are two systems having the same semantics, but the latter is popular because of its simplicity in syntax.\nLexical Specifications Lexemes We use regular expressions to specify lexemes.\nKeywords: if/else/then/\u0026hellip;\n$\\text{Keywords}=\\text{if}+\\text{else}+\\text{then}+\\cdots$\nInteger: a non-empty string of digits.\n$\\text{digit}=0+1+2+3+\\ldots+8+9$ï¼Œ$\\text{Integer}=\\text{digit}\\space \\text{digit}^*$.\nRepresenting non-empty strings is a common need, so we denote $A^+\\triangleq AA^*$. Therefore we can also write $\\text{Integer}=\\text{digit}^+$.\nIdentifier: strings of letters of digits, starting with a letter.\n$\\text{letter}=a+b+\\cdots+y+z+A+B+\\cdots+Y+Z$. There is a convenient notation for ranges: $\\text{letter}=[a- z]+[A- Z]=[a- zA- Z]$.\n$\\text{Identifier}=\\text{letter}\\space (\\text{letter}+\\text{digit})^*$.\nWhitespace: a non-empty sequence of blanks, newlines and tabs.\n$\\text{Whitespace}=(\\text{\u0026rsquo; \u0026lsquo;}+\\text{\u0026rsquo;\\n\u0026rsquo;}+\\text{\u0026rsquo;\\t\u0026rsquo;})^+$.\nExample: Pascal Numbers $$ \\begin{align} \\text{num} \u0026amp;= \\text{digits}\\space\\space \\text{opt_fraction}\\space\\space \\text{opt_exponent}\\\\ \\text{opt_fraction}\u0026amp;=(\\text{\u0026rsquo;.\u0026rsquo;}\\space\\space \\text{digits})+\\epsilon\\\\ \\text{opt_exponent}\u0026amp;=(\\text{\u0026lsquo;E\u0026rsquo;}\\space (\\text{\u0026rsquo;+\u0026rsquo;}+\\text{\u0026rsquo;-\u0026rsquo;}+\\epsilon)\\space \\text{digits})+\\epsilon\\\\ \\text{digits}\u0026amp;=\\text{digit}^+\\\\ \\text{digit}\u0026amp;=[0-9] \\end{align} $$\nWe observe that \u0026ldquo;$+\\epsilon$\u0026rdquo; in regular expressions indicates \u0026ldquo;optional\u0026rdquo;, i.e. the elements before can be either present or absent. For convenience, we denote $A?\\triangleq A+\\epsilon$, so the rules above can be rewritten as $$ \\begin{align} \\text{opt_fraction} \u0026amp;= (\\text{\u0026rsquo;.\u0026rsquo;}\\space \\text{digits})?\\\\ \\text{opt_exponent} \u0026amp;= (\\text{\u0026lsquo;E\u0026rsquo;}\\space (\\text{\u0026rsquo;+\u0026rsquo;}+\\text{\u0026rsquo;-\u0026rsquo;})?\\space \\text{digits})? \\end{align} $$ It\u0026rsquo;s worth notice that regular expressions defines the set of strings we want, but we still need an implementation, i.e. given a string $s$ and a regular expression $R$, we want to know whether $s\\in L(R)$.\n","date":1657411200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1657411200,"objectID":"15f3ff7fe0d2c7ab5e48039d9e47ff8a","permalink":"https://kristoff-starling.github.io/notes/coursenotes/stanford-compiler/lectures/lec03/","publishdate":"2022-07-10T00:00:00Z","relpermalink":"/notes/coursenotes/stanford-compiler/lectures/lec03/","section":"notes","summary":"Token classes:\nIn English: nouns, verbs, adjactives etc. In programming languages: identifiers, keywords, \u0026ldquo;()\u0026rdquo; etc. Identifier: strings of letters or digits, staring with a letter (variable names). Integer: a non-empty string of digits (leading zeroes are allowed).","tags":null,"title":"Stanford-CS143 Lecture 03: Lexical Analysis","type":"docs"},{"authors":null,"categories":null,"content":"Cool (Classroom Object Oriented Language).\n5 programming assignments (all the 4 layers should be plug compatible)\nwrite a cool program lexical analysis parsing semantic analysis code generation Example: Hello World class Main { i : IO \u0026lt;- new IO; main():Int { { i.out_string(\u0026quot;Hello World!\\n\u0026quot;); 1; } }; }; A cool program (*.cl) should have class Main. A class contains several methods and attributes. Here i is an attribute with type IO. main() is a method with return value type Int. The method contains a block of statements enclosed in parentheses. Each statement should end with a semi-colon. Notice that we write 1; instead of return 1;.\nSome equivalent code snippets:\nclass Main { i : IO \u0026lt;- new IO; main():IO { i.out_string(\u0026quot;Hello World!\\n\u0026quot;) }; } class Main { i : IO \u0026lt;- new IO; main():Object { i.out_string(\u0026quot;Hello World!\\n\u0026quot;) }; } class Main { main():Object { (new IO).out_string(\u0026quot;Hello World\\n\u0026quot;) }; } class Main inherits IO { main():Object { self.out_string(\u0026quot;Hello World\\n\u0026quot;) }; } Here \u0026ldquo;inherit\u0026rdquo; means that class Main inherits all the attributes and methods of class IO. In the fourth code snippet, the \u0026ldquo;self\u0026rdquo; can be omitted.\nExample: Factorial An example program that reads from stdin, adds 1 and writes to stdout:\nclass Main inherits A2I{ main() : Object { (new IO).out_string( i2a(a2i((new IO).in_string()) + 1).concat(\u0026quot;\\n\u0026quot;) ) }; }; New grammar: i2a() and a2i() in atoi.cl implements ascii-integer transformation. concat() can concatenate 2 strings together. If you want to compile a library, just list all the file names to the compiler.\nA recursive version of fact.cl:\nclass Main inherits A2I { main() : Object { (new IO).out_string( i2a(a2i(fact((new IO).in_string()))).concat(\u0026quot;\\n\u0026quot;) ) }; fact(i: Int): Int { if (i = 0) then 1 else i * fact(i-1) fi }; }; New grammar: if-then-else-fi structure.\nAn iterative version of fact.cl:\nclass Main inherits A2I { main() : Object { (new IO).out_string( i2a(a2i(fact((new IO).in_string()))).concat(\u0026quot;\\n\u0026quot;) ) }; fact(i: Int): Int { let fact: Int \u0026lt;- 1 in { while (not (i = 0)) loop { fact \u0026lt;- fact * i; i \u0026lt;- i - 1; } pool; fact; } }; }; New grammar: while-loop-pool structure, let to define a local variable.\nPay attention that = in cool is a comparison operator, assignment operator should be \u0026lt;- !\nExample: list class List { item: String; next: List; init(i: String, n: List): List { { item \u0026lt;- i; next \u0026lt;- n; self; } }; flatten(): String { if (isvoid next) then item else item.concat(next.flatten()) fi }; }; class Main inherits IO { main(): Object { let hello: String \u0026lt;- \u0026quot;Hello \u0026quot;, world: String \u0026lt;- \u0026quot;World!\u0026quot;, newline: String \u0026lt;- \u0026quot;\\n\u0026quot;, nil: List, list: List \u0026lt;- (new List).init(hello, (new List).init(world, (new List).init(newline, nil))) in out_string(list.flatten()) }; }; New grammar: define multiple variables at the same time, the \u0026ldquo;isvoid\u0026rdquo; function.\nA more sophisticated flatten() function:\nclass List { item: String; next: List; init(i: String, n: List): List { { item \u0026lt;- i; next \u0026lt;- n; self; } }; flatten(): String { let string: String \u0026lt;- case item of i: Int =\u0026gt; i2a(i); s: String =\u0026gt; s; o: Object =\u0026gt; { abort(); \u0026quot;\u0026quot;; }; esac in if (isvoid next) then string else string.concat(next.flatten()) fi }; }; New grammar: case of - esac structure, abort() function\nNote: the \u0026quot;\u0026quot; is used to convince the type checker that the return value is of type String.\n","date":1656806400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1656806400,"objectID":"cf8617baea8bb68b74040953d3a3fdd8","permalink":"https://kristoff-starling.github.io/notes/coursenotes/stanford-compiler/lectures/lec02/","publishdate":"2022-07-03T00:00:00Z","relpermalink":"/notes/coursenotes/stanford-compiler/lectures/lec02/","section":"notes","summary":"Cool (Classroom Object Oriented Language).\n5 programming assignments (all the 4 layers should be plug compatible)\nwrite a cool program lexical analysis parsing semantic analysis code generation Example: Hello World class Main { i : IO \u0026lt;- new IO; main():Int { { i.","tags":null,"title":"Stanford-CS143 Lecture 02: Cool Overview","type":"docs"},{"authors":null,"categories":null,"content":"Interpreters: it takes in program and data and and immediately generates output (an on-line process).\nCompilers: it takes in program and generates an executable (assembly/bytecode). The executable takes in data and generates output (an off-line process).\nThe Structure of Compilers Lexical Analysis: divide program text into \u0026ldquo;words\u0026rdquo; or \u0026ldquo;tokens\u0026rdquo;.\nif x == y then z = 1; else z = 2; tokens: if x == z then z = 1 ; else z = 2 ;\nParsing: understand the sentence structure.\nif x == y then z = 1; else z = 2; if-then-else-+-predicate---relation-+-'x' | | | +-'==' | | | +-'y' | +-then-stmt---assign-+-'z' | | | +-'1' | +-else-stmt---assign-+-'z' | +-'2' Semantic Analysis: understand the \u0026ldquo;meaning\u0026rdquo; of sentences.\nIt\u0026rsquo;s too hard for compilers and compilers usually only perform limited semantic analysis to catch inconsistencies, they don\u0026rsquo;t know what programs are supposed to do.\nThe Complexity of Semantics\n\u0026ldquo;Jack said that Jack forgot his homework at home\u0026rdquo;. We even don\u0026rsquo;t know how many people are involved in this sentence without contexts.\nProgramming languages define strict rules to avoid such ambiguities. e.g.\n{ int jack = 3; { int jack = 4; cout \u0026lt;\u0026lt; jack; // should print 4 } } Optimization: automatically modify programs so that they run faster and use less memory, power, network resources etc.\nThe complexity of Optimizations\nX = Y * 0 is the same as X = 0 ? It\u0026rsquo;s not necessarily correct! If X Y are floating points and Y is NAN, then NAN * 0 = NAN, instead of zero.\nCode Generation: a translation into another language (assembly usually).\nThe proportions of each phase have changed since FORTRAN:\nFORTRAN: LLLLLL PPPPPP SS OOOOOO GGGGGG Modern: LL PP SSSSSS OOOOOOOOOO GG The Economy of Programming Languages Why so many PLs? Application domains have distinctive/conflicting needs. It\u0026rsquo;s hard to design one system for all.\nscientific computing: good floating points, good array/tensor operations, parallelism etc. (FORTRAN) business applications: persistence, report generation, data analysis etc. (SQL) systems programming: control of low-level resources, real-time constraints (C/C++) Why new PLs? Claim: Programmer training is the dominant cost for a programming language. (Lots of people need to learn this language!)\nCorollaries:\nWidely-used languages are slow to change. Easy to start a new language (zero user at the start). New languages are usually adopted to fill a void (it\u0026rsquo;s easy for new language to adapt to new situations). New languages tend to look like old languages (to reduce the training cost). What\u0026rsquo;s a good PL? Thers is no universally accepted metric for language design.\n","date":1656633600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1656633600,"objectID":"87ddeb54ae3fbf77c65e34f3b50c8d03","permalink":"https://kristoff-starling.github.io/notes/coursenotes/stanford-compiler/lectures/lec01/","publishdate":"2022-07-01T00:00:00Z","relpermalink":"/notes/coursenotes/stanford-compiler/lectures/lec01/","section":"notes","summary":"A brief introduction to interpreters and compilers + The economy of programming languages","tags":null,"title":"Stanford-CS143 Lecture 01: Introduction","type":"docs"},{"authors":null,"categories":null,"content":" Microsoft FAT Specification çš„ local copy è§æ­¤å¤„ã€‚ä»¥ä¸‹æ˜¯å¯¹è¯¥æ‰‹å†Œçš„ç²¾åéƒ¨åˆ†çš„ç¿»è¯‘å’Œè§£è¯»ã€‚\nSection 1: Definitions and Notations è¿™é‡Œåªè®°å½•æ¯”è¾ƒé‡è¦çš„å®šä¹‰å’Œè®°å·ã€‚\n1.1 Definition sectorï¼šå¯ä»¥ç‹¬ç«‹äºå…¶ä»–å•å…ƒç›´æ¥è·å–çš„æœ€å°å•å…ƒã€‚ bad(defective) sectorï¼šæŸåçš„ sectorï¼Œå…¶ä¸­çš„å†…å®¹æ— æ³•è¯»å†™ã€‚ clusterï¼šä¸€ä¸ª cluster é‡ŒåŒ…å«è‹¥å¹²ä¸ªè¿ç»­çš„ sectorã€‚cluster æ˜¯ allocation çš„æœ€å°å•ä½ï¼Œä¸ºæ–‡ä»¶åˆ†é…ç©ºé—´æ—¶å¿…é¡»åˆ†é…æ•´æ•°ä¸ª clusterã€‚ volumeï¼šä¸€æ®µç‰©ç†ä¸Šè¿ç»­çš„å—åœ°å€ç©ºé—´ (å¯ä»¥ç†è§£ä¸ºâ€œå…¨é›†â€)ã€‚ partitionï¼šåˆ†åŒºï¼Œvolume ä¸­çš„ä¸€éƒ¨åˆ† sectorã€‚ 1.2 Notations $ip(x)\\triangleq [x],ceil(x)\\triangleq\\lceil x\\rceil,rem(x/y)\\triangleq x\\space \\text{mod}\\space y$ã€‚\nSection 2: Volume Structure FAT æ–‡ä»¶ç³»ç»Ÿçš„ç»“æ„å¦‚ä¸‹ï¼š\nBPB \u0026hellip; BPB \u0026hellip; File Allocation Table FAT copy Root Directory Data \u0026hellip; Data Reserved Region FAT Region Root Directory Region (FAT12/FAT16) File \u0026amp; Directory (Data) Region FAT ä¸­çš„æ•°æ®å­˜å‚¨æ˜¯å°ç«¯çš„ã€‚\nSection 3: Boot Sector and BPB BPB (BIOS Parameter Block) ä½äº reserved region çš„ç¬¬ä¸€ä¸ª sectorã€‚è¿™ä¸ª sector ä¹Ÿè¢«ç§°ä¸º boot sector æˆ–è€… 0 å· sectorã€‚æ‰€æœ‰çš„ FAT æ–‡ä»¶ç³»ç»Ÿçš„ boot sector ä¸­éƒ½å¿…é¡»æœ‰ BPBã€‚ä»¥ä¸‹çš„å˜é‡ä¸­ä»¥ BPB_ å¼€å¤´çš„å±äº BPB çš„å†…å®¹ï¼Œä»¥ BS_ å¼€å¤´çš„å®é™…ä¸Šæ˜¯ boot sector çš„å†…å®¹ï¼Œä¸å±äº BPBã€‚\n3.1 BPB structure common to FAT12, FAT16, and FAT32 Implementations è¿™éƒ¨åˆ†çš„ BPB ç»“æ„æ˜¯ FAT12, FAT16 å’Œ FAT32 å…±æœ‰çš„ã€‚ä½¿ç”¨ C ä»£ç å¯ä»¥è¡¨ç¤ºå¦‚ä¸‹ (æ³¨ï¼šå®šä¹‰ç»“æ„ä½“æ—¶ä½¿ç”¨ __attribute__((__packed__)) å¯ä»¥ä¸è®©ç¼–è¯‘å™¨è‡ªåŠ¨å¯¹é½)ã€‚\nstruct BPB_common { char BS_jmpBoot[3]; /* 0 */ char BS_OEMName[8]; /* 3 */ uint16_t BPB_BytsPerSec; /* 11 */ uint8_t BPB_SecPerClus; /* 13 */ uint16_t BPB_RsvdSecCnt; /* 14 */ uint8_t BPB_NumFATs; /* 16 */ uint16_t BPB_RootEntCnt; /* 17 */ uint16_t BPB_TotSec16; /* 19 */ uint8_t BPB_Media; /* 21 */ uint16_t BPB_FATSz16; /* 22 */ uint16_t BPB_SecPerTrk; /* 24 */ uint16_t BPB_NumHeads; /* 26 */ uint32_t BPB_HiddSec; /* 28 */ uint32_t BPB_TotSec32; /* 32 */ }__attribute__((__packed__)); å„ä¸ªå­—æ®µçš„è§£é‡Šå¦‚ä¸‹ï¼š\nBS_jmpBootï¼šåŒ…å«äº†ä¸€ä¸ª 3 ä¸ªå­—èŠ‚çš„ Inter x86 æ ¼å¼çš„æ— æ¡ä»¶è·³è½¬æŒ‡ä»¤ï¼Œç”¨äºè·³è½¬åˆ°æ“ä½œç³»ç»Ÿçš„ bootstrap codeã€‚boot code é€šå¸¸ä½äº boot sector çš„å°¾éƒ¨ï¼Œè·Ÿåœ¨ BPB åé¢ã€‚ä¸¤ç§å¸¸è§çš„ jump instruction çš„æ ¼å¼ä¸ºï¼š\njmpBoot[0] = 0xEB; jmpBoot[1] = 0x??; jmpBoot[2] = 0x90; jmpBoot[0] = 0xE9; jmpBoot[1] = 0x??; jmpBoot[2] = 0x??; BS_OEMNameï¼šå  8 ä¸ªå­—èŠ‚ï¼Œå¯ä»¥åœ¨ FAT çš„å®ç°ä¸­è¢«æŒ‡å®šä¸ºä»»ä½•å€¼ã€‚å…¶å†…å®¹é€šå¸¸ä¸ºæ ¼å¼åŒ–è¯¥ç£ç›˜çš„ç³»ç»Ÿåç§° (æ¯”å¦‚å¦‚æœä½¿ç”¨ Linux çš„ mkfs.fat å‘½ä»¤åˆ›å»ºç£ç›˜é•œåƒï¼Œè¯¥å­—æ®µå°±ä¼šæ˜¯ \u0026ldquo;mfks.fat\u0026rdquo;)ã€‚\nBPB_BytsPerSecï¼šæ¯ä¸ª sector çš„å­—èŠ‚æ•°ã€‚è¯¥å€¼åªèƒ½æ˜¯ 512, 1024, 2048, 4096 ä¸­çš„ä¸€ä¸ªã€‚\nBPB_SecPerClusï¼šæ¯ä¸ª cluster çš„ sector æ•°ã€‚è¯¥å€¼å¿…é¡»å¤§äº 0 ä¸”æ˜¯ 2 çš„å¹‚æ¬¡ã€‚å› ä¸ºè¯¥å­—æ®µåªå ä¸€ä¸ªå­—èŠ‚ï¼Œå› æ­¤åˆæ³•çš„å€¼åªæœ‰ 1, 2, 4, 8, 16, 32, 64, 128ã€‚\nBPB_RsvdSecCntï¼šreserved region ä¸­çš„ reserved sector çš„ä¸ªæ•°ã€‚è¯¥å€¼å¯ä»¥æ˜¯ä»»ä½•éé›¶æ•´æ•°ã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œè¿™ä¸ªå­—æ®µç”¨äºä½¿æ•°æ®åŒºçš„å¼€å¤´ (å³ cluster #2) åœ°å€å¯¹é½ã€‚\nBPB_NumFATsï¼šfile allocation table çš„ä¸ªæ•°ã€‚é€šå¸¸æ¥è¯´ 2 æ˜¯ä¸€ä¸ªæ¯”è¾ƒæ¨èçš„æ•°å€¼ (ä¸ºäº†é˜²æ­¢ç£ç›˜å—æŸå¯¼è‡´çš„æ–‡ä»¶ç³»ç»ŸæŸå)ï¼Œä½† 1 ä¹Ÿæ˜¯å…è®¸çš„ã€‚\nBPB_RootEntCntï¼šå¯¹äº FAT12 å’Œ FAT16ï¼Œè¯¥å­—æ®µè¡¨ç¤ºæ ¹ç›®å½•ä¸‹ 32-byte ç›®å½•é¡¹çš„ä¸ªæ•°ï¼ŒBPB_RootEntCnt * 32 ç†åº”æ˜¯ BPB_BytsPerSec çš„å¶æ•°å€ã€‚åœ¨ FAT16 ä¸­ï¼Œä¸ºäº†è¾¾åˆ°æœ€å¤§çš„å…¼å®¹æ€§ï¼Œè¯¥å€¼åº”å½“è®¾ç½®ä¸º 512ã€‚å¯¹äº FAT32ï¼Œè¯¥å€¼å¿…é¡»æ˜¯ 0ã€‚\nBPB_TotSec16ï¼šå¯¹äº FAT12 å’Œ FAT16ï¼Œè¯¥å­—æ®µè¡¨ç¤ºäº†æ–‡ä»¶ç³»ç»Ÿä¸­ sector çš„æ•°ç›®ã€‚è¯¥å­—æ®µåªæœ‰ 2 ä¸ªå­—èŠ‚ï¼Œå¦‚æœ sector çš„æ•°ç›®å¤§äºç­‰äº 0x10000ï¼Œåˆ™é«˜ä½éƒ¨åˆ†ä¼šå­˜å‚¨åˆ° BPB_TotSec32 ä¸­ã€‚å¯¹äº FAT32ï¼Œè¯¥å­—æ®µå¿…é¡»æ˜¯ 0ã€‚\nBPB_Mediaï¼šåˆæ³•çš„å€¼æœ‰ 0xF0, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE å’Œ 0xFFã€‚å¯¹äºä¸å¯ç§»åŠ¨çš„å›ºå®šç£ç›˜ï¼Œ0xF8 æ˜¯æ ‡å‡†å€¼ï¼›å¦‚æœæ˜¯å¯ç§»åŠ¨è®¾å¤‡ï¼Œè¯¥å­—æ®µé€šå¸¸æ˜¯ 0xF0ã€‚\nBPB_FATSz16ï¼šå¯¹äº FAT12 å’Œ FAT16ï¼Œè¯¥å­—æ®µè¡¨ç¤ºä¸€ä¸ª FAT ä¸­ 16-bit sector çš„ä¸ªæ•°ã€‚å¯¹äº FAT32ï¼Œè¯¥å­—æ®µå¿…é¡»æ˜¯ 0ã€‚\nBPB_SecPerTrkï¼šè¯¥å­—æ®µåªåœ¨ä¸€äº›æœ‰ç€ç‰¹å®šå‡ ä½•ç‰¹å¾ (ä¸€ä¸ª volume è¢«åˆ’åˆ†æˆå¤šä¸ªè½¨é“ï¼Œæœ‰å¤šä¸ªè¯»å†™å¤´) çš„è®¾å¤‡ä¸Šæœ‰ç”¨ï¼Œè¡¨ç¤ºäº†æ¯ä¸ª track ä¸Š sector çš„æ•°ç›®ã€‚è¯¥å­—æ®µæ˜¯ä¸º 0x13 å·ä¸­æ–­å‡†å¤‡çš„ã€‚\nBPB_NumHeadsï¼šè¯»å†™å¤´æ•°é‡ã€‚è¯¥å­—æ®µä¹Ÿæ˜¯ä¸º 0x13 å·ä¸­æ–­å‡†å¤‡çš„ã€‚\nBPB_HiddSecï¼šè¯¥å­—æ®µè¡¨ç¤ºäº†è¿™ä¸ª FAT åˆ†åŒºåé¢çš„éšè— sector çš„æ•°ç›®ï¼Œä¹Ÿæ˜¯ä¸º 0x13 å·ä¸­æ–­å‡†å¤‡çš„ã€‚å¯¹äºæ²¡æœ‰åˆ†åŒºçš„è®¾å¤‡ï¼Œè¯¥å­—æ®µå¿…é¡»ä¸º 0ã€‚æ­¤å¤–ï¼Œåˆ©ç”¨è¯¥å­—æ®µæ¥å¯¹é½æ•°æ®åŒºæ˜¯ä¸æ­£ç¡®çš„ã€‚\nBPB_TotSec32ï¼šå¯¹äº FAT32ï¼Œè¯¥å­—æ®µè¡¨ç¤ºäº†æ–‡ä»¶ç³»ç»Ÿä¸­ sector çš„æ•°ç›®ã€‚å¯¹äº FAT12 å’Œ FAT16ï¼Œå¦‚æœ BPB_TotSec16 è¶³å¤Ÿå­˜æ”¾å¯¹åº”æ•°å€¼ï¼Œåˆ™è¯¥å­—æ®µä¸º 0ï¼Œå¦åˆ™è¯¥å­—æ®µä¼šå­˜å‚¨æ•°æ®çš„é«˜ä½ã€‚\n3.2 Extended BPB structure for FAT12 and FAT16 volumes å¦‚æœæ˜¯ FAT12 å’Œ FAT16ï¼Œboot sector ä¸­è¿˜æœ‰å¦‚ä¸‹çš„ä¸€äº›å­—æ®µ (ç´§è·Ÿåœ¨ BPB_common ä¹‹å)ï¼š\nstruct BPB_16bit { uint8_t BS_DrvNum; /* 36 */ uint8_t BS_Reserved1; /* 37 */ uint8_t BS_BootSig; /* 38 */ uint32_t BS_VolID; /* 39 */ char BS_VolLab[11]; /* 43 */ char BS_FilSysType[8]; /* 54 */ uint8_t __padding[448]; /* 62 */ uint16_t Signature_word; /* 510 */ }__attribute__((__packed__)); å„ä¸ªå­—æ®µçš„è§£é‡Šå¦‚ä¸‹ï¼š\nBS_DrvNumï¼š0x13 å·ä¸­æ–­çš„é©±åŠ¨å·ï¼Œè®¾ç½®æˆ 0x80 æˆ– 0x00ã€‚ BS_Reserved1ï¼šä¿ç•™å­—æ®µï¼Œè®¾ç½®ä¸º 0x0ã€‚ BS_BootSigï¼šå¦‚æœåé¢ä¸¤ä¸ªå­—æ®µ (BS_VolID å’Œ BS_VolLab) ä¸­çš„ä»»ä½•ä¸€ä¸ªæ˜¯éé›¶æ•°ï¼Œå°†è¯¥å­—æ®µè®¾ç½®ä¸º 0x29ã€‚ BS_VolIDï¼šè¯¥å­—æ®µå’Œ BS_VolLab å…±åŒæ”¯æŒäº†å¯ç§»åŠ¨è®¾å¤‡ä¸Šçš„ volume trackingã€‚è¿™äº›å­—æ®µä½¿å¾— FAT æ–‡ä»¶ç³»ç»Ÿé©±åŠ¨å¯ä»¥è¯†åˆ«å‡ºæ’å…¥åˆ°å¯ç§»åŠ¨é©±åŠ¨ä¸Šçš„é”™è¯¯ç£ç›˜ã€‚BS_VolID åº”å½“é€šè¿‡å°†å½“å‰æ—¥æœŸå’Œæ—¶é—´æ‹¼æ¥æˆ 32 ä½æ•°å€¼çš„æ–¹å¼ç”Ÿæˆã€‚ BS_VolLabï¼šVolume labelã€‚è¯¥å­—æ®µçš„å†…å®¹åº”å½“å’Œæ ¹ç›®å½•ä¸‹çš„ 11 å­—èŠ‚ volume label ç›¸åŒã€‚FAT æ–‡ä»¶ç³»ç»Ÿåº”å½“ä¿è¯å¦‚æœæ ¹ç›®å½•ä¸‹çš„ volume label è¢«åˆ›å»ºæˆ–è€…ä¿®æ”¹ï¼Œè¯¥å­—æ®µä¹Ÿä¼šè¢«æ›´æ–°ã€‚å¦‚æœæ²¡æœ‰ volume labelï¼Œè¯¥å­—æ®µä¼šè¢«å¡«å……ä¸º \u0026ldquo;NO NAME \u0026ldquo;ã€‚ BS_FilSysTypeï¼š\u0026ldquo;FAT12 \u0026ldquo;ï¼Œ\u0026ldquo;FAT16 \u0026quot; æˆ– \u0026ldquo;FAT \u0026quot; ä¸­çš„ä¸€ä¸ªã€‚æ³¨æ„è¯¥å­—æ®µåªæ˜¯èµ·åˆ°ä¸€ä¸ªæä¾›ä¿¡æ¯çš„ä½œç”¨ï¼Œå¹¶ä¸ç”¨äºå†³å®š FAT çš„ç±»å‹ã€‚ Signature_wordï¼šåç§»é‡ä¸º 510 çš„ byte ä¸º 0x55ï¼Œåç§»é‡ä¸º 511 çš„ byte ä¸º 0xaaã€‚ 3.3 Extended BPB structure for FAT32 volumes å¦‚æœæ˜¯ FAT32ï¼Œboot sector ä¸­è¿˜ä¼šæœ‰å¦‚ä¸‹çš„ä¸€äº›å­—æ®µ (ç´§è·Ÿåœ¨ BPB_common ä¹‹å)ï¼š\nstruct BPB_32bit { uint32_t BPB_FATSz32; /* 36 */ uint16_t BPB_ExtFlags; /* 40 */ uint16_t BPB_FSVer; /* 42 */ uint32_t BPB_RootClus; /* 44 */ uint16_t BPB_FSInfo; /* 48 */ uint16_t BPB_BkBootSec; /* 50 */ char BPB_Reserved[12]; /* 52 */ uint8_t BS_DrvNum; /* 64 */ uint8_t BS_Reserved1; /* 65 */ uint8_t BS_BootSig; /* 66 */ uint32_t BS_VolID; /* 67 */ char BS_VolLab[11]; /* 71 */ char BS_FilSysType[8]; /* 82 */ uint8_t __padding[420]; /* 90 */ uint16_t Signature_word; /* 510 */ }__attribute__((__packed__)); å„ä¸ªå­—æ®µçš„è§£é‡Šå¦‚ä¸‹ (å’Œ FAT12/FAT16 ç›¸åŒçš„éƒ¨åˆ†ä¸å†è§£é‡Š)ï¼š\nBPB_FATSz32ï¼šä¸€ä¸ª FAT ä¸­åŒ…å«çš„ 32-bit sector æ•°ç›®ã€‚ BPB_ExtFlagsï¼šå„ä¸ªä½çš„æ ‡å¿—ä¿¡æ¯å¦‚ä¸‹ 0-3 ä½ï¼šå½“å‰ active çš„ FAT çš„ç¼–å·ï¼Œè¿™ä¸ªç¼–å·æ˜¯ 0-based çš„ï¼Œä»…åœ¨ mirroring è¢«å…³é—­æ—¶æœ‰æ•ˆã€‚ 4-6 ä½ï¼šreservedã€‚ 7 ä½ï¼šè¯¥ä½æ˜¯ 0 è¡¨ç¤º FAT ä¼šåœ¨è¿è¡Œæ—¶é•œåƒåˆ°æ‰€æœ‰çš„ FAT ä¸­ï¼›è¯¥ä½æ˜¯ 1 è¡¨ç¤ºåªæœ‰ä¸€ä¸ª FAT æ˜¯æ´»è·ƒçš„ï¼Œè¿™ä¸ªæ´»è·ƒçš„ FAT çš„ç¼–å·é€šè¿‡ 0-3 ä½è¡¨ç¤ºã€‚ 8-15 ä½ï¼šreservedã€‚ BPB_FSVerï¼šé«˜ä½çš„ byte å­˜å‚¨ä¸»ç‰ˆæœ¬å· (major)ï¼Œä½ä½çš„ byte å­˜å‚¨å°ç‰ˆæœ¬å· (minor)ã€‚ç°é˜¶æ®µè¯¥å€¼å¿…é¡»è¢«è®¾ç½®ä¸º 0x0ã€‚ BPB_RootClusï¼šè¯¥å­—æ®µè¡¨ç¤ºäº†æ ¹ç›®å½•çš„ç¬¬ä¸€ä¸ª cluster çš„ç¼–å·ã€‚è¯¥å€¼é€šå¸¸æ˜¯ 2ï¼Œå¦‚æœæœ‰å‡ºç° cluster æŸåçš„æƒ…å†µï¼Œåˆ™è¯¥å€¼æ˜¯ 2 ä¹‹åç¬¬ä¸€ä¸ªå¯ç”¨çš„ cluster çš„ç¼–å·ã€‚ BPB_FSInfoï¼šè¯¥å­—æ®µè¡¨ç¤ºäº† FAT32 çš„ reserved area ä¸­ FSINFO ç»“æ„ä½“æ‰€åœ¨çš„ sector ç¼–å·ï¼Œé€šå¸¸ä¸º 1ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œåœ¨ boot sector çš„å¤‡ä»½ä¸­ä¹Ÿä¼šæœ‰ä¸€ä¸ª FSINTO ç»“æ„ä½“ï¼Œä½†ä¸» boot sector å’Œå¤‡ä»½ boot sector çš„è¯¥å­—æ®µä¼šæŒ‡å‘åŒä¸€ä¸ª FSINFO ç»“æ„ä½“ï¼Œåªæœ‰é‚£ä¸ªè¢«æŒ‡å‘çš„ç»“æ„ä½“æ‰æ˜¯ up-to-date çš„ã€‚ BPB_BkBootSecï¼šè¯¥å­—æ®µçš„å€¼æ˜¯ 0 æˆ– 6ã€‚å¦‚æœéé›¶ï¼Œå®ƒè¡¨ç¤ºäº† boot record çš„å¤‡ä»½æ‰€åœ¨çš„ sector å· (6 å·)ã€‚ BPB_Reservedï¼šreservedã€‚å¿…é¡»è¢«è®¾ç½®ä¸º 0x0ã€‚ 3.4 Initialization of a FAT volume Section 3.5 ä¼šä»‹ç»å¦‚ä½•å†³å®š FAT çš„ç±»å‹ (12/16/32)ï¼Œæœ¬ section ä¸»è¦ä»‹ç»åœ¨ volume åˆå§‹åŒ–æ—¶å¦‚ä½•å¡«å†™ BPB ä¸­çš„å­—æ®µã€‚FAT implementation è¦ä¿è¯å¯ä»¥æŒ‚è½½å¡«å†™äº†åˆæ³•æ•°å€¼çš„ BPB çš„è®¾å¤‡ã€‚\nè½¯ç›˜ä¼šè¢«æ ¼å¼åŒ–ä¸º FAT12ï¼Œä¸€ä¸ªç®€å•çš„ã€äº‹å…ˆå‡†å¤‡å¥½çš„è¡¨æ ¼å†³å®šäº†è½¯ç›˜ä¸­ BPB çš„å„ä¸ªå­—æ®µçš„å€¼ã€‚æ³¨æ„ï¼šFAT12 è¦æ±‚è®¾å¤‡å®¹é‡ \u0026lt;= 4MBã€‚\nå¯¹äºæ¯ä¸ª sector å¤§å°ä¸º 512B çš„è®¾å¤‡ï¼Œå¦‚æœè®¾å¤‡å¤§å° \u0026lt; 512MBï¼Œè¯¥è®¾å¤‡ä¼šè¢«æ ¼å¼åŒ–ä¸º FAT16ï¼Œå¦åˆ™ä¼šè¢«æ ¼å¼åŒ–ä¸º FAT32ã€‚è¦†ç›–é»˜è®¤çš„ FAT ç±»å‹é€‰æ‹©æ˜¯å¯èƒ½çš„ã€‚\nä¸‹é¢çš„è¡¨æ ¼æ¥è‡ª Microsoft Corporation FAT format utilityã€‚å¯¹äº FAT16ï¼Œå¡«å†™ BPB_SecPerClus çš„è¡¨æ ¼å¦‚ä¸‹ï¼š\nstruct DSKSZTOSECPERCLUS { DWORD DiskSize; // ä»¥512byte sectorä¸ºå•ä½ BYTE SecPerClusVal; }; DSKSZTOSECPERCLUS DskTableFAT16 [] = { {8400, 0}, /* disks up to 4.1 MB, the 0 value for SecPerClusVal trips an error */ {32680, 2}, /* disks up to 16 MB, 1k cluster */ {262144, 4}, /* disks up to 128 MB, 2k cluster */ {524288, 8}, /* disks up to 256 MB, 4k cluster */ {1048576, 16}, /* disks up to 512 MB, 8k cluster */ /* The entries after this point are not used unless FAT16 is forced */ {2097152, 32},/* disks up to 1 GB, 16k cluster */ {4194304, 64},/* disks up to 2 GB, 32k cluster */ {0xFFFFFFFF, 0} /*any disk greater than 2GB, 0 value for SecPerClusVal trips an error */ }; è™½ç„¶ FAT16 ä¸€èˆ¬åªåœ¨ \u0026lt;= 512 MB çš„æƒ…å†µä¸‹ä½¿ç”¨ï¼Œä½†è¡¨æ ¼ä¸­ä»ç„¶ç»™å‡ºäº†ä¸€äº›å¤§äº 512MB ä½†å¼ºåˆ¶è¦æ±‚ä½¿ç”¨ FAT16 çš„è®¾å¤‡çš„å¡«å†™æ–¹æ³•ã€‚è¯¥è¡¨æ ¼çš„ä½¿ç”¨æ–¹æ³•æ˜¯ï¼šæ ¹æ®å½“å‰è®¾å¤‡çš„ disk sizeï¼Œåœ¨è¡¨æ ¼ä¸­æ‰¾å‡ºç¬¬ä¸€ä¸ªå°äºç­‰äº disk size çš„è¡¨é¡¹ï¼Œå¹¶å°†å…¶ç¬¬äºŒä¸ªå‚æ•°ä½œä¸º BPB_SecPerClusï¼Œç¬¬ä¸€ä¸ªå‚æ•°ä¼šè¢«å¡«å…¥ BPB_TotSec16ã€‚ä¸ºäº†ä½¿è¯¥è¡¨æ ¼ä¸­çš„æ•°å€¼å¯ä»¥æ­£ç¡®å·¥ä½œï¼ŒBPB_RsvdSecCnt éœ€è¦è¢«è®¾ç½®ä¸º 1ï¼ŒBPB_NumFATs éœ€è¦è¢«è®¾ç½®ä¸º 2ï¼ŒBPB_RootEntCnt éœ€è¦è¢«è®¾ç½®ä¸º 512ã€‚\nå¯¹äº FAT32ï¼Œå¡«å†™ BPB_SecPerClus çš„è¡¨æ ¼å¦‚ä¸‹ï¼š\nDSKSZTOSECPERCLUS DskTableFAT32 [] = { {66600, 0}, /* disks up to 32.5 MB, the 0 value for SecPerClusVal trips an error */ {532480, 1}, /* disks up to 260 MB, .5k cluster */ {16777216, 8}, /* disks up to 8 GB, 4k cluster */ {33554432, 16}, /* disks up to 16 GB, 8k cluster */ {67108864, 32}, /* disks up to 32 GB, 16k cluster */ {0xFFFFFFFF, 64} /* disks greater than 32GB, 32k cluster */ }; ä¸ºäº†ä½¿è¯¥è¡¨æ ¼ä¸­çš„æ•°å€¼å¯ä»¥æ­£ç¡®å·¥ä½œï¼ŒBPB_RsvdSecCnt éœ€è¦è¢«è®¾ç½®ä¸º 32ï¼ŒBPB_NumFATs éœ€è¦è¢«è®¾ç½®ä¸º 2ã€‚\nä¸‹é¢çš„ä»£ç è§£é‡Šäº†å¦‚ä½•è®¡ç®— BPB_FATSz16/BPB_FATSz32 å­—æ®µã€‚è¯¥ä»£ç å‡è®¾ BPB_RootEntCnt, BPB_RsvdSecCnt å’Œ BPB_NumFATs å·²ç»è¢«æ­£ç¡®è®¾ç½®å¥½ã€‚ä»£ç ä¸­çš„ DiskSize æ˜¯ä»¥ sector ä¸ºå•ä½çš„ (å³ BPB_TotSec16/BPT_TotSec32 ä¸­çš„å€¼)ã€‚\nRootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytsPerSec â€“ 1)) / BPB_BytsPerSec; TmpVal1 = DskSize - (BPB_ResvdSecCnt + RootDirSectors); TmpVal2 = (256 * BPB_SecPerClus) + BPB_NumFATs; if (FATType == FAT32) { TmpVal2 = TmpVal2 / 2; FATSz = (TMPVal1 + (TmpVal2 â€“ 1)) / TmpVal2; } if (FATType == FAT32) { BPB_FATSz16 = 0; BPB_FATSz32 = FATSz; } else { BPB_FATSz16 = LOWORD(FATSz); /* there is no BPB_FATSz32 in a FAT16 BPB */ } æ³¨ï¼šè¯¥ä»£ç ä¸­çš„æ•°å­¦è¿ç®—ä¸æ˜¯å®Œç¾çš„ï¼Œåœ¨ä¸€äº›æƒ…å†µä¸‹å®ƒç®—å‡ºçš„ FAT size ä¼šè¿‡å¤§ï¼Œä½†å®ƒä¸€å®šä¸ä¼šç®—å°ï¼Œè¿™ä¿è¯äº†å®ƒä¸ä¼šå‡ºé”™ (è¿‡å¤§åªæ˜¯ä¼šæµªè´¹ä¸€äº›ç©ºé—´)ã€‚è¯¥ä»£ç çš„ç®€æ´æ˜¯å®ƒçš„ä¼˜åŠ¿ã€‚\n3.5 Determination of FAT type when mounting the volume FAT ç±»å‹å”¯ä¸€å†³å®šäº volume ä¸­ cluster çš„æ•°é‡ (CountofClusters)ã€‚ä¸‹é¢çš„æ­¥éª¤æè¿°äº†è®¡ç®— cluster æ•°é‡çš„è¿‡ç¨‹ï¼š\nè®¡ç®—æ ¹ç›®å½•å æ®çš„ sector çš„æ•°é‡ï¼š\nRootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytsPerSec - 1)) / BPB_BytsPerSec; è®¡ç®—æ•°æ®åŒºå æ®çš„ sector çš„æ•°é‡ (ä»æ€» sector æ•°é‡ä¸­æ‰£é™¤æ ¹ç›®å½•å’Œ FAT çš„ sector æ•°é‡)ï¼š\nFATSz = (BPP_FATSz16 != 0) ? BPB_FATSz16 : BPB_FATSz32; TotSec = (BPB_TotSec16 != 0) ? BPB_TotSec16 : BPB_TotSec32; DataSec = TotSec - (BPB_RsvdSecCnt + (BPB_NumFATs * FATSz) + RootDirSectors); è®¡ç®— CountOfClusterï¼š\nCountofClusters = DataSec / BPB_SecPerClus; ä¸‹é¢çš„ if è¯­å¥å†³å®šäº† FAT çš„ç±»å‹ï¼š\nif (CountofClusters \u0026lt; 4085) {/* Volume is FAT12 */} else if (CountofClusters \u0026lt; 6525) {/* Volume is FAT16 */} else {/* Volume is FAT32 */} æ³¨ï¼šä¸€ä¸ªç£ç›˜çš„ cluster æ•°ç›®æœ€å¥½ä¸è¦å¡åœ¨è¾¹ç•Œä¸Š (æ¯”å¦‚ 4085 ä¸ª cluster æˆ– 65525 ä¸ª cluster)ï¼Œä¸è¾¹ç•Œå€¼çš„å·®æœ€å¥½å¤§äº 16ã€‚\næœ€å¤§çš„å¯ä½¿ç”¨çš„ cluster å·æ˜¯ CountofCluster + 1ã€‚\n3.6 Backup BPB Structure sector #0 çš„æŸåä¼šå¯¹æ–‡ä»¶ç³»ç»Ÿäº§ç”Ÿæ¯ç­æ€§çš„æ‰“å‡»ï¼Œå› æ­¤ä¸º BPB åšå¤‡ä»½æ˜¯å¾ˆé‡è¦çš„ã€‚åœ¨ FAT32 ä¸­ï¼Œsector #6 å¿…é¡»åŒ…å« BPB çš„å¤‡ä»½ã€‚\næ— è®ºæ˜¯ sector #0 ä¸­çš„ BPB è¿˜æ˜¯ sector #6 ä¸­çš„å¤‡ä»½ BPBï¼ŒBPB_BkBootSec å­—æ®µä¸­çš„å€¼éƒ½æ˜¯ 6ã€‚\nå½“ sector #0 æ— æ³•è¯»å–æ—¶ï¼Œvolume repair utility åº”å½“ä» sector #6 æå–ä¿¡æ¯ã€‚\nSection 4: FAT File Allocation Table ä¸­çš„æ¯ä¸€ä¸ª entry éƒ½ä»£è¡¨äº†ä¸€ä¸ª cluster çš„çŠ¶æ€ã€‚FAT12 ä¸­æ¯ä¸ª FAT entry å  12 ä¸ª bitï¼ŒFAT16 ä¸­æ¯ä¸ª FAT entry å  16 ä¸ª bitï¼ŒFAT32 ä¸­æ¯ä¸ª FAT entry å  32 ä¸ª bitã€‚FAT è¡¨ä¸­çš„ entry å¯èƒ½æ¯”å¯ä»¥åˆ†é…çš„ cluster çš„æ•°ç›®æ›´å¤šï¼Œé‚£äº›å¤šå‡ºæ¥çš„ FAT entry å¿…é¡»è¢«ç½®ä¸º 0ã€‚\nFAT å®šä¹‰äº†è¡¨ç¤ºæ–‡ä»¶çš„å•å‘é“¾è¡¨ã€‚æ•´ä¸ªç£ç›˜ä¸­çš„ç¬¬ä¸€ä¸ª cluster çš„ç¼–å·æ˜¯ 2ã€‚\næ³¨ï¼šä¸€ä¸ª FAT ä¸­çš„ç›®å½•æ–‡ä»¶æœ¬èº«åªæ˜¯ä¸€ä¸ªæ™®é€šæ–‡ä»¶ï¼Œå®ƒæœ‰ä¸€ä¸ªç‰¹æ®Šçš„å±æ€§è¡¨æ˜å®ƒè‡ªå·±æ˜¯ç›®å½•ï¼Œè¯¥æ–‡ä»¶çš„å†…å®¹æ˜¯ä¸€ç³»åˆ—çš„ 32 å­—èŠ‚çš„ç›®å½•é¡¹ã€‚\nFAT entry çš„å†…å®¹å¦‚ä¸‹è¡¨ï¼š\nFAT12 FAT16 FAT32 Comments 0x000 0x0000 0x0000000 cluster å½“å‰ç©ºé—² 0x002~MAX 0x0002~MAX 0x0000002~MAX cluster åœ¨ä½¿ç”¨ä¸­ï¼ŒFAT entry çš„å†…å®¹æ˜¯é“¾è¡¨ä¸­ä¸‹ä¸€ä¸ª cluster çš„ç¼–å·ã€‚MAX æŒ‡çš„æ˜¯æœ€å¤§çš„åˆæ³• cluster ç¼–å· (MAX+1)~0xFF6 (MAX+1)~0xFFF6 (MAX+1)~0xFFFFFF6 reservedï¼Œä¸å¯ä½¿ç”¨ 0xFF7 0xFFF7 0xFFFFFF7 cluster æŸå 0xFF8~0xFFE 0xFFF8~0xFFFE 0xFFFFFF8~0xFFFFFFE reservedï¼Œä¸å¯ä½¿ç”¨ 0xFFF 0xFFFF 0xFFFFFFF cluster åœ¨ä½¿ç”¨ä¸­ï¼Œæ˜¯ä¸€ä¸ªæ–‡ä»¶çš„æœ€åä¸€ä¸ª cluster æ³¨ï¼š(1) FAT32 è¡¨é¡¹ä¸­çš„é«˜ 4 ä½ä¸ä½¿ç”¨ã€‚\n(2) FAT12 ä¸­ FAT çš„å¤§å°ä¸èƒ½è¶…è¿‡ 6K ä¸ª sectorï¼ŒFAT16 ä¸­ FAT çš„å¤§å°ä¸èƒ½è¶…è¿‡ 128K ä¸ª sectorï¼ŒFAT32 æ²¡æœ‰é™åˆ¶ã€‚\n4.1 Determination of FAT entry for a cluster ç»™å®šä¸€ä¸ªåˆæ³•çš„ cluster å· $N$ï¼Œè¯¥ section ä¸»è¦ä»‹ç»å¦‚ä½•ç¡®å®šå“ªä¸ª FAT entry å¯¹åº”äº†è¿™ä¸ª clusterã€‚\nFAT16 and FAT32 ä¸‹é¢çš„ä»£ç ç»™å‡ºäº†ç¡®å®šæŸä¸€ä¸ª cluster çš„ FAT entry æ‰€åœ¨çš„ sectorçš„æ–¹æ³•ï¼š\nFATSz = (BBP_FATSz16 != 0) ? BPB_FATSz16 : BPB_FATSz32; FATOffset = (FATType == FAT16) ? (N * 2) : (N * 4); ThisFATSecNum = BPB_RsvdSecCnt + (FATOffset / BPB_BytsPerSec); ThisFATEntOffset = REM(FATOffset / BPB_BytsPerSec); æ³¨ï¼šFATX çš„ FAT æ˜¯ç”±è‹¥å¹²ä¸ª X bit çš„ FAT entry ç´§å¯†æ’åˆ—è€Œæˆçš„ï¼Œå› æ­¤ FATOffset è®¡ç®—å‡ºäº† $N$ å· cluster çš„ FAT entry è·ç¦» FAT è¡¨å¼€å¤´çš„åç§»å­—èŠ‚æ•°ï¼Œç”¨è¿™ä¸ªå­—èŠ‚æ•°é™¤ä»¥ BPB_BytsPerSec å³å¯å¾—åˆ° sector å·ï¼Œå–ä½™å³å¯å¾—åˆ° sector å†…çš„åç§»é‡ã€‚\nä¸Šè¿°ä»£ç æ±‚å¾—çš„ ThisFATSecNum æ˜¯ cluster åœ¨ç¬¬ä¸€ä»½ FAT ä¸­çš„ FAT entry æ‰€åœ¨ sector å·ã€‚å¦‚æœè¦æ±‚å…¶ä»– FAT ä¸­çš„ FAT entry çš„ sector å·ï¼Œå¯ä»¥å‚è€ƒå¦‚ä¸‹å…¬å¼ï¼š\nSectorNumber = (FatNumber * FATSz) + ThisFatSecNum; å°†ç£ç›˜æ˜ å°„åˆ°å†…å­˜ä¸­ä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å¦‚ä¸‹æ–¹æ³•è¯»å–ä¸€ä¸ª FAT entry çš„å†…å®¹ (ä¸‹é¢çš„ä»£ç ä¸­ SecBuff æ˜¯æŒ‡å‘å¯¹åº” sector å¼€å¤´çš„æŒ‡é’ˆï¼ŒWORD æ˜¯ 16bitï¼ŒDWORD æ˜¯ 32bit)ï¼š\nif (FATType == FAT16) FAT16ClusEntryVal = *((WORD *) \u0026amp;SecBuff[ThisFATEntOffset]); else FAT32ClusEntryVal = (*((DWORD *) \u0026amp;SecBuff[ThisFATEntOffset])) \u0026amp; 0x0FFFFFFF; å¯ä»¥ç”¨å¦‚ä¸‹æ–¹æ³•ä¿®æ”¹ä¸€ä¸ª FAT entryï¼š\nif (FATType == FAT16) *((WORD *) \u0026amp;SecBuff[ThisFATEntOffset]) = FAT16ClusEntryVal; else { FAT32ClusEntryVal \u0026amp;= 0x0FFFFFFF; *((DWORD *) \u0026amp;SecBuff[ThisFATEntOffset]) = (0xF0000000 | FAT32ClusEntryVal); } æ³¨ï¼šFAT16/FAT32 çš„è¡¨é¡¹ä¸èƒ½è·¨ sector å­˜å‚¨ã€‚\nFAT12 FAT12 ä¸­çš„æ¯ä¸ª FAT entry å  12bit (1.5 ä¸ªå­—èŠ‚)ã€‚æ‰€æœ‰çš„è®¡ç®—æ–¹æ³•å’Œ FAT16/FAT32 ç±»ä¼¼ï¼Œä½†ç”±äºå­—èŠ‚æ•°ä¸æ˜¯æ•´æ•°ï¼Œæ‰€ä»¥æ¶‰åŠä¸€äº›å¾®å¦™çš„è¿ç®—ï¼š\nif (FATType == FAT12) FATOffset = N + (N / 2); // è¿™é‡Œçš„â€œ/â€æ˜¯ä¸‹å–æ•´ ThisFATSecNum = BPB_RsvdSecNum + (FATOffset / BPB_BytsPerSec); ThisFATEntOffset = REM(FATOffset / BPB_BytsPerSec); åœ¨ FAT12 ä¸­ï¼Œä¸€ä¸ª FAT entry æ˜¯æœ‰å¯èƒ½è·¨ sector å­˜å‚¨çš„ï¼Œä¸‹é¢ç»™å‡ºäº†åˆ¤æ–­æ–¹æ³•ï¼š\nif (ThisFATEntOffset == (BPB_BytsPerSec - 1)) { // è¯¥FAT entryè·¨sectorå­˜å‚¨ // æœ€ç®€å•çš„åº”å¯¹æ–¹æ³•æ˜¯æ¯æ¬¡è¯»å–æ—¶æ€»æ˜¯è¯»å–è¿ç»­çš„ä¸¤ä¸ªsector:Nå’ŒN+1(é™¤éNæ˜¯æœ€åä¸€ä¸ªsector) } FAT12 ä¸­è¯»å– FAT entry å†…å®¹çš„æ–¹æ³•ä¹Ÿæœ‰ä¸€äº›å¾®å¦™ï¼šå› ä¸ºæ¯ä¸ª FAT entry å  12 ä¸ª bitï¼Œæ‰€ä»¥ä¸¤ä¸ª FAT entry æ­£å¥½å æ® 3 ä¸ªå­—èŠ‚ã€‚æˆ‘ä»¬è®¡ç®—å‡ºçš„ ThisFATEntOffset å¯¹åº”çš„æ˜¯è¯¥ FAT entry æ‰€åœ¨çš„ç¬¬ä¸€ä¸ª byte çš„åœ°å€ï¼Œè¿™æ„å‘³ç€å¯¹äºå¥‡æ•° cluster è€Œè¨€ FAT entry æ˜¯ä» ThisFATEntOffset çš„å¼€å¤´å¼€å§‹çš„ï¼Œå¯¹äºå¶æ•° cluster è€Œè¨€ FAT entry æ˜¯ä» ThisFATEntOffset æ‰€åœ¨å­—èŠ‚çš„å 4 ä¸ª bit å¼€å§‹çš„ï¼Œå› æ­¤ä»£ç é€»è¾‘å¦‚ä¸‹ (æ³¨ï¼š\u0026gt;\u0026gt; æ˜¯é€»è¾‘å³ç§»)ï¼š\nFAT12ClusEntryVal = *((WORD *) \u0026amp;SecBuff[ThisFATEntOffset]); // å…ˆè¯»å‡º16ä¸ªbit if (N \u0026amp; 0x0001) FAT12ClusEntryVal \u0026gt;\u0026gt;= 4; // 16ä¸ªbitä¸­åªæœ‰å‰12ä¸ªbitæ˜¯è¡¨é¡¹ï¼Œä½ä½4ä¸ªbitåº”å½“æ¸…ç©º else FAT12ClusEntryVal \u0026amp;= 0x0FFF; // 16ä¸ªbitä¸­åªæœ‰å12ä¸ªbitæ˜¯è¡¨é¡¹ï¼Œé«˜ä½4ä¸ªbitåº”å½“æ¸…ç©º ä¿®æ”¹ä¸€ä¸ªè¡¨é¡¹çš„æ–¹æ³•ä¸ºï¼š\nif (N \u0026amp; 0x0001) { FAT12ClusEntryVal \u0026lt;\u0026lt;= 4; *((WORD *) \u0026amp;SecBuff[ThisFATEntOffset]) \u0026amp;= 0x000F; } else { FAT12ClusEntryVal \u0026amp;= 0x0FFF; *((WORD *) \u0026amp;SecBuff[ThisFATEntOffset]) \u0026amp;= 0xF000; } *((WORD *) \u0026amp;SecBuff[ThisFATEntOffset]) |= FAT12ClusEntryVal; 4.2 Reserved FAT entries FAT çš„å‰ä¸¤ä¸ª FAT entry æ˜¯ reserved çš„ã€‚\nç¬¬ä¸€ä¸ª FAT entry (FAT[0]) çš„å†…å®¹ä¸ºï¼šä½ 8 ä½ä¿å­˜äº† BPB_Media çš„å€¼ï¼Œå‰©ä¸‹çš„ä½ç½®ä¸º 1ã€‚\nç¬¬äºŒä¸ª FAT entry (FAT[1]) çš„å†…å®¹ä½ï¼š\nå¯¹äº FAT12ï¼šè¯¥ entry ä¿å­˜äº† EOC markã€‚ å¯¹äº FAT16 å’Œ FAT32ï¼šMS Windows çš„è®¾å¤‡é©±åŠ¨å°†æœ€é«˜çš„ä¸¤ä¸ªä½ä½œä¸º dirty volume æ ‡å¿—ä½ï¼Œå‰©ä¸‹çš„å…¶ä»–ä½ç½®ä¸º 1ã€‚è¿™é‡Œçš„é«˜ 2 ä½æŒ‡çš„æ˜¯ FAT16 ä¸­çš„ 0x8000 (ClnShutBitMask) å’Œ 0x4000 (HrdErrBitMask)ï¼ŒFAT32 ä¸­çš„ 0x08000000 (ClnShutBitMask) å’Œ 0x04000000 (HrdErrBitMask)ã€‚ ClnShutBitMask ä½ï¼šå¦‚æœè¿™ä¸ªä½æ˜¯ 1ï¼Œé‚£ä¹ˆè¿™ä¸ª volume å½“å‰æ˜¯å¹²å‡€çš„ï¼Œå¯ä»¥è¢«æŒ‚è½½å¹¶è®¿é—®ï¼›å¦‚æœè¿™ä¸ªä½æ˜¯ 0ï¼Œé‚£ä¹ˆè¿™ä¸ª volume æ˜¯ dirty çš„ï¼ŒFAT æ–‡ä»¶ç³»ç»Ÿé©±åŠ¨æ— æ³•æ­£ç¡®åœ°è§£æŒ‚è½½è¿™ä¸ª volumeï¼Œè¯¥ volume çš„å†…å®¹åº”å½“è¢«æ‰«æä¸€éä»¥ç¡®å®šæ˜¯å¦æœ‰ metadata çš„æŸåã€‚ HrdErrBitMask ä½ï¼šè¯¥ä½æ˜¯ 1 è¯´æ˜æ²¡æœ‰é‡åˆ°ä»»ä½• read/write é”™è¯¯ã€‚è¯¥ä½æ˜¯ 0 è¯´æ˜è‡ªä¸Šä¸€æ¬¡æŒ‚è½½ä»¥æ¥ FAT æ–‡ä»¶ç³»ç»Ÿé©±åŠ¨é‡åˆ°è¿‡ read/write é”™è¯¯ï¼Œå¯èƒ½æœ‰ sector æŸåäº†ã€‚è¯¥ volume çš„å†…å®¹åº”å½“è¢«æ‰«æä¸€éä»¥ç¡®å®šæ˜¯å¦æœ‰æŸåçš„ sectorã€‚ 4.3 Free space determination æ–‡ä»¶ç³»ç»Ÿé©±åŠ¨å¿…é¡»æ‰«ææ‰€æœ‰çš„ FAT entry ä»¥æ„å»ºä¸€ç³»åˆ—çš„æ–‡ä»¶é“¾è¡¨å’Œè·å¾—æ‰€æœ‰çš„ç©ºé—² clusterã€‚ç©ºé—²çš„ cluster å¯¹åº” çš„ FAT entry çš„å€¼ä¸º 0ã€‚ç©ºé—² cluster åœ¨ FAT ä¸­å¹¶æ²¡æœ‰ä»¥ä¸€ä¸ªé“¾è¡¨çš„å½¢å¼ä¸²èµ·æ¥ï¼Œä½†åœ¨ FAT32 ä¸­ï¼ŒBPB_FSInfo sector å¯èƒ½åŒ…å«äº†ç©ºé—² cluster çš„æ•°ç›®ã€‚\n4.4 Other points to note FAT çš„å®ç°ä¸åº”å½“å¯¹ (CountOfCluster + 1) FAT entry ä¹‹åçš„å†…å®¹æœ‰ä»»ä½•çš„å‡è®¾ (è¿™ä¸ª entry ä¸ä¸€å®šåœ¨ä¸€ä¸ª sector çš„ç»“å°¾å¤„)ã€‚å¹¶ä¸”åœ¨æ ¼å¼åŒ–æ—¶ï¼ŒFAT çš„æœ€åä¸€ä¸ª sector ä¸­æœ€åä¸€ä¸ª FAT entry ä¹‹åçš„éƒ¨åˆ†åº”è¢«ç½®ä¸º 0ã€‚\næ¯ä¸ª FAT åŒ…å«çš„ sector æ•°å¯èƒ½æ¯”å®ƒå®é™…éœ€è¦çš„ sector æ•°å¤šï¼Œè¿™æ„å‘³ç€ FAT çš„æœ€åå¯èƒ½ä¼šåŒ…å«è‹¥å¹²å®Œå…¨æ²¡æœ‰ä½¿ç”¨çš„ sectorã€‚é©±åŠ¨å®ç°åº”å½“é€šè¿‡ CountOfCluster æ¥ç¡®å®š FAT ä¸­æœ€åä¸€ä¸ª valid sector çš„ç¼–å·ã€‚æœ€åä¸€ä¸ª valid sector åé¢çš„ sector åº”å½“å…¨éƒ¨è¢«ç½®ä¸º 0ã€‚\nSection 5: File System Information (FSInfo) Structure FSInfo ç»“æ„ä½“åªåœ¨ FAT32 ä¸­æœ‰ã€‚è¯¥ç»“æ„ä½“åº”å½“åœ¨æ–‡ä»¶ç³»ç»Ÿåˆå§‹åŒ–æ—¶è®¾ç½®å¥½å¹¶æ”¾åœ¨ sector #1 ä¸­ (å³ç´§æ¥ç€ BPB)ï¼Œè¯¥ç»“æ„ä½“çš„å¤‡ä»½å­˜æ”¾åœ¨ sector #7 ä¸­ã€‚\næ³¨ï¼šFSInfo ç»“æ„ä½“ä¸­çš„æ‰€æœ‰ä¿¡æ¯éƒ½æ˜¯å»ºè®®æ€§çš„ï¼Œæ–‡ä»¶ç³»ç»Ÿé©±åŠ¨åº”å½“åœ¨åˆå§‹åŒ–æ—¶å¡«å¥½ FSInfo çš„ä¿¡æ¯ï¼Œä½†å¹¶ä¸ä¸€å®šéœ€è¦åœ¨ç£ç›˜è¯»å†™çš„è¿‡ç¨‹ä¸­åŠ¨æ€æ›´æ–°è¿™ä¸ªç»“æ„ä½“ (å°½ç®¡æ‰‹å†Œå»ºè®®è¿™ä¹ˆåš)ã€‚\nFSInfo çš„å„ä¸ªå­—æ®µå¦‚ä¸‹ï¼š\nstruct FSInfo { uint32_t FSI_LeadSig[4]; /* 0 */ uint8_t FSI_rsvc1[480]; /* 4 */ uint32_t FSI_StrucBig; /* 484 */ uint32_t FSI_Free_Count; /* 488 */ uint32_t FSI_Nxt_Free; /* 492 */ uint8_t FSI_rsvd2[12]; /* 496 */ uint32_t FSI_TrailSig; /* 508 */ }; å„ä¸ªå­—æ®µçš„è§£é‡Šå¦‚ä¸‹ï¼š\nFSI_LeadSigï¼šå€¼ä¸º 0x41615252ï¼Œç”¨äºç¡®è®¤ FSInfo æ ¼å¼çš„ç­¾åã€‚ FSI_Rsvd1ï¼šreservedï¼Œå¿…é¡»ç½®ä¸º 0ã€‚ FSI_StrucSigï¼šå€¼ä¸º 0x61417272ï¼Œä¸€ä¸ªé¢å¤–ç”¨äºç¡®è®¤ FSInfo æ ¼å¼çš„ç­¾åã€‚ FSI_Free_Countï¼šè¯¥å­—æ®µå€¼ä¸ºç£ç›˜ä¸­ç©ºé—² cluster çš„æ•°é‡ï¼Œå¦‚æœä¸æ¸…æ¥šåˆ™ç½®ä¸º 0xFFFFFFFFã€‚è¯¥å­—æ®µå¿…é¡»åœ¨ volume æŒ‚è½½æ—¶ç¡®å®šï¼Œæ‰‹å†Œå»ºè®®è¯¥å­—æ®µåœ¨ volume è§£æŒ‚è½½æ—¶ä»ç„¶ä¿å­˜æ­£ç¡®çš„ countã€‚ FSI_Next_Freeï¼šä¿å­˜äº†ç£ç›˜ä¸Šç¬¬ä¸€ä¸ªç©ºé—² cluster çš„ç¼–å·ï¼Œå¦‚æœä¸æ¸…æ¥šåˆ™ç½®ä¸º 0xFFFFFFFFã€‚è¯¥å­—æ®µå¿…é¡»åœ¨ volume æŒ‚è½½æ—¶ç¡®å®šï¼Œæ‰‹å†Œå»ºè®®è¯¥å­—æ®µåœ¨ volume è§£æŒ‚è½½æ—¶ä»ç„¶ä¿å­˜æ­£ç¡®çš„ç¼–å·ã€‚ FSI_Rsvd2ï¼šreservedï¼Œå¿…é¡»ç½®ä¸º 0ã€‚ FSI_TrailSigï¼šå€¼ä¸º 0xAA550000ï¼Œç”¨äºç¡®è®¤ FSInfo æ ¼å¼çš„ç­¾å Section 6: Directory Structure FAT çš„ç›®å½•æ˜¯ä¸€ç§ç‰¹æ®Šçš„æ–‡ä»¶ï¼Œå®ƒåƒæ˜¯ä¸€ä¸ªå®¹å™¨ï¼Œé‡Œé¢è£…äº†å­ç›®å½•å’Œæ–‡ä»¶çš„ç›¸å…³ä¿¡æ¯ã€‚ç›®å½•æ–‡ä»¶ç”±ä¸€ç³»åˆ—çš„ 32 å­—èŠ‚çš„ç›®å½•é¡¹ (directory entry) æ„æˆï¼Œæ¯ä¸ªç›®å½•é¡¹æè¿°äº†ä¸€ä¸ªå­ç›®å½•æˆ–ä¸€ä¸ªæ–‡ä»¶ã€‚\nç›®å½•é¡¹çš„å†…å®¹å¯ä»¥ç”¨å¦‚ä¸‹ç»“æ„ä½“æè¿°ï¼š\nstruct Dirent { char DIR_Name[11]; /* 0 */ uint8_t DIR_Attr; /* 11 */ uint8_t DIR_NTRes; /* 12 */ uint8_t DIR_CrtTimeTenth; /* 13 */ uint16_t DIR_CrtTime; /* 14 */ uint16_t DIR_CrtDate; /* 16 */ uint16_t DIR_LstAccDate; /* 18 */ uint16_t DIR_FstClusHI; /* 20 */ uint16_t DIR_WrtTime; /* 22 */ uint16_t DIR_WrtDate; /* 24 */ uint16_t DIR_FstClusLO; /* 26 */ uint32_t DIR_FileSize; /* 28 */ }__attribute__((__packed__)); å„ä¸ªå­—æ®µçš„è§£é‡Šå¦‚ä¸‹ï¼š\nDIR_Nameï¼šâ€œçŸ­â€æ–‡ä»¶åï¼Œä¸è¶…è¿‡ 11 ä¸ªå­—èŠ‚ã€‚\nDIR_Attrï¼šæ–‡ä»¶çš„å±æ€§ï¼Œåˆæ³•çš„å±æ€§å€¼å¦‚ä¸‹æ‰€ç¤º\nATTR_READ_ONLY ATTR_HIDDEN ATTR_SYSTEM ATTR_VOLUME_ID 0x01 0x02 0x04 0x08 ATTR_DIRECTORY ATTR_ARCHIVE ATTR_LONG_NAME 0x10 0x20 0x0F (å‰å››ä¸ªçš„æˆ–) DIR_Attr çš„é«˜ä¸¤ä¸ª bit ä¿ç•™ï¼Œå¿…é¡»è¢«ç½®ä¸º 0ã€‚\nDIR_NTResï¼šreservedï¼Œå¿…é¡»ç½®ä¸º 0ã€‚\nDIR_CrtTimeTenthï¼šåˆ›å»ºæ—¶é—´ (ä½ä½)ï¼Œä»¥ 1/10 ç§’ä¸ºå•ä½ï¼Œåˆæ³•èŒƒå›´æ˜¯ 0\u0026lt;=DIR_CrtTimeTenth\u0026lt;=199ã€‚\nDIR_CrtTimeï¼šåˆ›å»ºæ—¶é—´ (é«˜ä½)ï¼Œé¢—ç²’åº¦ä¸º 2sã€‚\nDIR_CrtDateï¼šåˆ›å»ºæ—¥æœŸã€‚\nDIR_LstAccDateï¼šä¸Šä¸€æ¬¡ access è¯¥æ–‡ä»¶çš„æ—¥æœŸã€‚è¿™é‡Œçš„ access æŒ‡çš„æ˜¯å¯¹è¯¥æ–‡ä»¶/ç›®å½•çš„ read/write æ“ä½œã€‚è¯¥å­—æ®µå¿…é¡»åœ¨æ–‡ä»¶ä¿®æ”¹æ—¶æ›´æ–° (å³å†™æ“ä½œæ—¶)ï¼Œå¡«å†™çš„æ—¥æœŸå¿…é¡»ä¸ DIR_WrtDate ç›¸åŒã€‚\nDIR_FstClusHIï¼šè¯¥æ–‡ä»¶/ç›®å½•çš„ç¬¬ä¸€ä¸ª cluster çš„ç¼–å·çš„é«˜ 16 ä½ã€‚è¯¥å­—æ®µä»…å¯¹ FAT32 æœ‰æ•ˆï¼ŒFAT12/FAT16 ä¸­è¯¥å­—æ®µå¿…é¡»ç½®ä¸º 0ã€‚\nDIR_WrtTimeï¼šä¸Šä¸€æ¬¡ä¿®æ”¹è¯¥æ–‡ä»¶çš„æ—¶é—´ã€‚åœ¨æ–‡ä»¶åˆšåˆšåˆ›å»ºçš„æ—¶å€™ï¼Œè¯¥å­—æ®µçš„å€¼åº”å½“ä¸ DIR_CrtTime ä¸€æ ·ã€‚\nDIR_WrtDateï¼šä¸Šä¸€æ¬¡ä¿®æ”¹è¯¥æ–‡ä»¶çš„æ—¥æœŸã€‚åœ¨æ–‡ä»¶åˆšåˆšåˆ›å»ºçš„æ—¶å€™ï¼Œè¯¥å­—æ®µçš„å€¼åº”å½“ä¸ DIR_CrtDate ä¸€æ ·ã€‚\nDIR_FstClusLOï¼šè¯¥æ–‡ä»¶/ç›®å½•çš„ç¬¬ä¸€ä¸ª cluster çš„ç¼–å·çš„ä½ 16 ä½ã€‚\nDIR_FileSizeï¼šæ–‡ä»¶å¤§å°ï¼Œä»¥å­—èŠ‚ä¸ºå•ä½ã€‚\n6.1 File/Directory Name (field DIR_Name) DIR_Name å…±æœ‰ 11 ä¸ªå­—èŠ‚ï¼Œåˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼š8 å­—èŠ‚çš„ main part å’Œ 3 å­—èŠ‚çš„æ‰©å±•åã€‚å¦‚æœæŸä¸€ä¸ªéƒ¨åˆ†å­—èŠ‚æ•°ä¸è¶³ï¼Œåé¢ä¼šç”¨ç©ºæ ¼è¡¥è¶³é•¿åº¦ã€‚\nä»¥ä¸‹æ˜¯ä¸€äº›æ³¨æ„ç‚¹ï¼š\nmain part å’Œæ‰©å±•åä¹‹é—´é»˜è®¤æœ‰ä¸€ä¸ª \u0026ldquo;.\u0026quot;ï¼Œè¿™ä¸ªç‚¹ä¸ä¼šå­˜å‚¨åœ¨ DIR_Name ä¸­ã€‚ DIR_Name[0] == 0xE5 ä»£è¡¨è¿™ä¸ªç›®å½•é¡¹æ˜¯ç©ºé—²çš„ã€‚ä¸è¿‡åœ¨ KANJI (æ—¥æœ¬è¯­) ä¸­ 0xE5 è¿™ä¸ªå­—ç¬¦æ˜¯å­˜åœ¨çš„ï¼Œå› æ­¤ KANJI ä¸‹ 0xE5 ä¼šç”¨ 0x05 æ¥ä»£æ›¿ã€‚æ–‡ä»¶ç³»ç»Ÿè§£ææ–‡ä»¶åæ—¶å¦‚æœé‡åˆ°é¦–å­—èŠ‚æ˜¯ 0x05 ä¸”å­—ç¬¦é›†æ˜¯ KANJI æ—¶è¦å°† 0x05 æ›¿æ¢æˆ 0xE5 å†è¿”å›ã€‚ é™¤äº† 0xE5ï¼ŒDIR_Name[0] == 0x00 ä¹Ÿä»£è¡¨è¿™ä¸ªç›®å½•é¡¹æ˜¯ç©ºé—²çš„ã€‚å®ƒä¸ 0xE5 çš„ä¸åŒåœ¨äº 0x00 æ„å‘³ç€åé¢è·Ÿç€çš„æ‰€æœ‰ç›®å½•é¡¹ä¹Ÿéƒ½æ˜¯ç©ºé—²çš„ã€‚ DIR_Name[0] ä¸èƒ½æ˜¯ 0x20ï¼Œå³æ–‡ä»¶åä¸èƒ½ä»¥ç©ºæ ¼å¼€å¤´ã€‚ ä¸€ä¸ªç›®å½•ä¸‹çš„æ‰€æœ‰åå­—éƒ½å¿…é¡»æ˜¯å”¯ä¸€çš„ã€‚ å¯¹äºæ–‡ä»¶ä¸­å­—ç¬¦çš„é™åˆ¶å¦‚ä¸‹ï¼š\nå°å†™å­—æ¯ä¸å…è®¸å‡ºç°ã€‚ å°äº 0x20 çš„å­—ç¬¦ä¸å…è®¸å‡ºç° (é™¤äº†ä¸Šé¢æåˆ°çš„ KANJI çš„ 0x05)ã€‚ 0x22, 0x2A, 0x2B, 0x2C, 0x2E, 0x2F, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x5B, 0x5C, 0x5D å’Œ 0x7Cã€‚ 6.2 File/Directory Attributes æ–‡ä»¶æˆ–å­ç›®å½•çš„å±æ€§å€¼ä¼šå½±å“æ–‡ä»¶ç³»ç»Ÿé©±åŠ¨å¯¹è¯¥æ–‡ä»¶/å­ç›®å½•çš„æ“ä½œæ–¹å¼ã€‚å„ç§å±æ€§å€¼çš„æ„ä¹‰åˆ—ä¸¾å¦‚ä¸‹ï¼š\nATTR_READ_ONLY (0x01)ï¼šè¯¥æ–‡ä»¶ä¸å¯ä¿®æ”¹ï¼Œå¯¹è¯¥æ–‡ä»¶çš„ä¿®æ”¹æ“ä½œä¼šä»¥è¿”å›é”™è¯¯ç å‘Šç»ˆã€‚\nATTR_HIDDEN (0x02)ï¼šé™¤éç”¨æˆ·æ˜¾å¼åœ°è¦æ±‚åˆ—ä¸¾å‡ºéšè—æ–‡ä»¶ï¼Œå¦åˆ™ hidden files ä¸åº”åœ¨åˆ—ä¸¾ç›®å½•ä¸‹æ–‡ä»¶æ—¶å‡ºç° (å¯ä»¥ç†è§£ä¸º ls -a å’Œ ls çš„åŒºåˆ«)ã€‚\nATTR_SYSTEM (0x04)ï¼šè¯¥æ–‡ä»¶è¢«æ ‡è®°ä¸ºå’Œæ“ä½œç³»ç»Ÿç›¸å…³çš„â€œç³»ç»Ÿæ–‡ä»¶â€ï¼Œé™¤éç”¨æˆ·æ˜¾å¼åœ°è¦æ±‚åˆ—ä¸¾å‡ºç³»ç»Ÿæ–‡ä»¶ï¼Œå¦åˆ™ system files ä¸åº”åœ¨åˆ—ä¸¾ç›®å½•ä¸‹æ–‡ä»¶æ—¶å‡ºç°ã€‚\nATTR_VOLUME_ID (0x08)ï¼šè¯¥æ–‡ä»¶åŒ…å« volume labelï¼Œè¿™ç§æƒ…å†µä¸‹ï¼ŒDIR_FstClusHI å’Œ DIR_FstClusLO å¿…é¡»éƒ½ç½®ä¸º 0ã€‚\nåªæœ‰æ ¹ç›®å½•å¯ä»¥æœ‰ä¸€ä¸ª entry åŒ…å«è¯¥å±æ€§ (è¡¨ç¤ºé•¿æ–‡ä»¶åçš„ entry ä¸éµä»è¯¥è§„åˆ™)ã€‚\nATTR_DIRECTORY (0x10)ï¼šè¯¥ç›®å½•é¡¹è¡¨ç¤ºçš„æ˜¯ä¸€ä¸ªå­ç›®å½•ã€‚è¿™ç§æƒ…å†µä¸‹ï¼ŒDIR_FileSize å¿…é¡»ä¸º 0ã€‚\nATTR_ARCHIVE (0x20)ï¼šå½“æ–‡ä»¶è¢«åˆ›å»ºã€é‡å‘½åæˆ–ä¿®æ”¹æ—¶ï¼Œè¯¥å±æ€§å€¼å¿…é¡»è¢«è®¾ç½®ï¼Œæ ‡å¿—è¯¥æ–‡ä»¶çš„ç›¸å…³ä¿¡æ¯å·²ç»è¢«ä¿®æ”¹ã€‚åœ¨å¤‡ä»½æ—¶ï¼Œå„ç§å·¥å…·å¯ä»¥åˆ©ç”¨è¯¥å±æ€§æ¥åˆ¤æ–­ä¸€ä¸ªæ–‡ä»¶æ˜¯å¦éœ€è¦å¤‡ä»½ã€‚\n6.3 Date/Time DIR_CrtTime, DIR_CrtTimeTenth, DIR_CrtDate, DIR_LstAccDate è¿™å››ä¸ªå­—æ®µæ˜¯é€‰å¡«çš„ã€‚æ–‡ä»¶ç³»ç»Ÿé©±åŠ¨å¦‚æœä¸æ”¯æŒè¿™äº›å­—æ®µï¼Œåˆ™å¿…é¡»å°†å…¶ç½®ä¸º 0ã€‚DIR_WrtTime å’Œ DIR_WrtDate è¿™ä¸¤ä¸ªå­—æ®µæ˜¯æ–‡ä»¶ç³»ç»Ÿé©±åŠ¨å¿…é¡»æ­£ç¡®æ›´æ–°çš„ã€‚\nDate format DIR_CrtDate, DIR_WrtDate, DIR_LstAccDate è¿™ä¸‰ä¸ªå­—æ®µéœ€è¦éµä»æ—¥æœŸçš„æ ¼å¼ã€‚\n0-4 bitï¼šæ—¥ (1~31) 5-8 bitï¼šæœˆ (1~12) 9-15 bitï¼šä» 1980 å¹´èµ·çš„å¹´ä»½ (0~127ï¼Œå¯ä»¥è¡¨ç¤º 1980~2107 å¹´) Time Format DIR_CrtTime, DIR_WrtTime è¿™ä¸¤ä¸ªå­—æ®µéœ€è¦éµä»æ—¶é—´æ ¼å¼ã€‚æ—¶é—´æ˜¯ä»¥ 2s ä¸ºé¢—ç²’åº¦çš„ã€‚\n0-4 bitï¼šç§’ (ä»¥ 2s ä¸ºå•ä½ï¼Œæ•°å€¼èŒƒå›´æ˜¯ 0~29ï¼Œå¯ä»¥è¡¨ç¤º 0,2,4,\u0026hellip;,58) 5-10 bitï¼šåˆ†é’Ÿ (0~59) 11-15 bitï¼šå°æ—¶ (0~23) 6.4 File/Directory Size æ–‡ä»¶çš„æœ€å¤§å¤§å°æ˜¯ 0xFFFFFFFF ä¸ªå­—èŠ‚ã€‚æœ€å¤§çš„ç›®å½•å¤§å°æ˜¯ $2^{21}$ ä¸ªå­—èŠ‚ã€‚\n6.5 Directory creation å½“ä¸€ä¸ªæ–°çš„ç›®å½•è¢«åˆ›å»ºæ—¶ï¼Œæ–‡ä»¶ç³»ç»Ÿå®ç°å¿…é¡»ä¿è¯ä»¥ä¸‹å†…å®¹ï¼š\nDIR_Attr çš„ ATTR_DIRECTORY bit è¦ç½®ä¸º 1ã€‚ DIR_FileSize å¿…é¡»ç½®ä¸º 0ã€‚ è‡³å°‘è¦åˆ†é…ä¸€ä¸ª clusterï¼ŒDIR_FstClusLO å’Œ DIR_FstClusHI è´Ÿè´£è¡¨ç¤ºç¬¬ä¸€ä¸ª cluster çš„ç¼–å·ã€‚ (ä»¥ä¸Šä¸‰æ¡è¯´çš„æ—¶è¯¥ç›®å½•åœ¨å…¶çˆ¶ç›®å½•çš„ directory entry ä¸­çš„å†…å®¹)\nå¦‚æœè¯¥ç›®å½•åªæœ‰ä¸€ä¸ª clusterï¼Œé‚£ä¹ˆå®ƒå¯¹åº”çš„ FAT entry åº”å½“è¢«æ ‡è®°ä¸º end-of-fileã€‚ åˆå§‹åˆ†é…çš„ cluster çš„å†…å®¹åº”å½“ç½®ä¸º 0ã€‚ é™¤äº†æ ¹ç›®å½•ï¼Œå…¶ä»–æ‰€æœ‰ç›®å½•éƒ½å¿…é¡»åœ¨å¼€å¤´æœ‰å¦‚ä¸‹çš„ä¸¤ä¸ªç›®å½•é¡¹ï¼š .ï¼šè¯¥ç›®å½•é¡¹è¡¨ç¤ºå½“å‰ç›®å½•ï¼Œä¹‹å‰æåˆ°çš„ DIR_Attr, DIR_FileSize çš„è§„åˆ™ä»ç„¶éœ€è¦ä¿æŒï¼ŒDIR_FstClusLO å’Œ DIR_FstClusHI ä»¥åŠæ‰€æœ‰çš„æ—¶é—´ã€æ—¥æœŸå­—æ®µå¿…é¡»å’Œå½“å‰ç›®å½•çš„ä¿æŒä¸€è‡´ã€‚ ..ï¼šè¯¥ç›®å½•é¡¹è¡¨ç¤ºä¸Šä¸€çº§ç›®å½•ï¼Œä¹‹å‰æåˆ°çš„ DIR_Attr, DIR_FileSize çš„è§„åˆ™ä»ç„¶éœ€è¦ä¿æŒï¼ŒDIR_FstClusLO å’Œ DIR_FstClusHI ä»¥åŠæ‰€æœ‰çš„æ—¶é—´ã€æ—¥æœŸå­—æ®µå¿…é¡»å’Œä¸Šä¸€çº§ç›®å½•çš„ä¿æŒä¸€è‡´ (å¦‚æœä¸Šä¸€çº§ç›®å½•æ˜¯æ ¹ç›®å½•ï¼Œåˆ™ DIR_FstClusLO å’Œ DIR_FstClusHI å¿…é¡»éƒ½ç½®ä¸º 0)ã€‚ 6.6 Root Directory æ ¹ç›®å½•æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„ container fileï¼Œåœ¨æ ¼å¼åŒ–æ—¶åˆ›å»ºã€‚\nåœ¨ FAT12 å’Œ FAT16 ä¸­ï¼Œæ ¹ç›®å½•å¿…é¡»ç´§è·Ÿåœ¨æœ€åä¸€ä¸ª FAT åï¼Œå› æ­¤æ ¹ç›®å½•çš„ç¬¬ä¸€ä¸ª sector çš„ç¼–å·å¯ä»¥æŒ‰ç…§å¦‚ä¸‹æ–¹å¼è®¡ç®—ï¼š\nFirstRootDirSecNum = BPB_RsvdSecCnt + (BPB_NumFATs * BPB_FATSz16); æ ¹ç›®å½•çš„å¤§å°æ ¹æ® BPB_RootEntCnt å­—æ®µçš„å€¼è®¡ç®—ã€‚\nåœ¨ FAT32 ä¸­ï¼Œæ ¹ç›®å½•æ˜¯å˜é•¿çš„ï¼Œæ ¹ç›®å½•çš„ç¬¬ä¸€ä¸ª cluster çš„ç¼–å·å­˜æ”¾åœ¨ BPB_RootClus å­—æ®µä¸­ã€‚\nåªæœ‰æ ¹ç›®å½•çš„ DIR_Attr å­—æ®µçš„å€¼å¯ä»¥ç­‰äº ATTR_VOLUME_IDã€‚\næ ¹ç›®å½•æ²¡æœ‰åå­— (åœ¨ç»å¤§å¤šæ•°æ“ä½œç³»ç»Ÿä¸­ï¼Œ\\ è¿™ä¸ªåå­—è¢«ç”¨ä½œæ ¹ç›®å½•)ï¼Œä¹Ÿæ²¡æœ‰ä»»ä½•çš„æ—¶é—´æˆ³ (æ—¥æœŸ/æ—¶é—´)ï¼Œä¹Ÿæ²¡æœ‰ \u0026ldquo;.\u0026rdquo;, \u0026ldquo;..\u0026rdquo; è¿™ä¸¤ä¸ªç›®å½•é¡¹ã€‚\n6.7 File allocation æ¯ä¸ªæ–‡ä»¶çš„ç›®å½•é¡¹ (å­˜å‚¨åœ¨åŒ…å«è¿™ä¸ªæ–‡ä»¶çš„ç›®å½•ä¸­) éƒ½æœ‰è¯¥æ–‡ä»¶ç¬¬ä¸€ä¸ª cluster çš„ç¼–å·ã€‚å¦‚æœè¯¥æ–‡ä»¶å¤§å°ä¸º 0 åˆ™ç¼–å·æ˜¯ 0ã€‚ç¬¬ä¸€ä¸ª cluster åœ¨ FAT ä¸­å¯¹åº”çš„ FAT entry è¦ä¹ˆå­˜å‚¨äº†ä¸‹ä¸€ä¸ª cluster çš„ç¼–å·ï¼Œè¦ä¹ˆæ˜¯ä¸€ä¸ª end-of-file æ ‡å¿—ã€‚\ndata region çš„ç¬¬ä¸€ä¸ª sector (cluster #2) çš„ç¼–å·è®¡ç®—æ–¹æ³•å¦‚ä¸‹ï¼š\nFirstDataSector = BPB_RsvdSecCnt + (BPB_NumFATs * FATSz) + RootDirSectors; ç»™å®šä¸€ä¸ªåˆæ³•çš„ cluster ç¼–å· $N$ï¼Œè¯¥ cluster çš„ç¬¬ä¸€ä¸ª sector çš„ç¼–å·çš„è®¡ç®—æ–¹æ³•å¦‚ä¸‹ï¼š\nFirstSectorofCluster = ((N - 2) * BPB_SecPerClus) + FirstDataSector; Section 7: Long File Name Implementation (optional) ä¸Šä¸€ä¸ª section ä¸­æåˆ° DIR_Name å­—æ®µçš„é•¿åº¦åªæœ‰ 11 ä¸ª å­—èŠ‚ï¼Œå…¶ä¸­å‰ 8 ä¸ªå­—èŠ‚æ˜¯ main partï¼Œåä¸‰ä¸ªå­—èŠ‚æ˜¯æ‰©å±•åã€‚è¿™ç§ç›®å½•é¡¹è¢«ç§°ä¸ºçŸ­åç›®å½•é¡¹ã€‚ä½†ç”¨æˆ·å¾ˆå¤šæ—¶å€™å–œæ¬¢ç»™è‡ªå·±çš„æ–‡ä»¶æˆ–ç›®å½•èµ·é•¿åå­—ï¼Œæœ¬ section ä¸»è¦å…³æ³¨å¦‚ä½•å­˜å‚¨é•¿åçš„ç›®å½•é¡¹ã€‚\né•¿æ–‡ä»¶åçš„æ–‡ä»¶çš„ç›¸å…³ä¿¡æ¯å­˜å‚¨åœ¨ä¸€äº›é¢å¤–çš„é•¿åç›®å½•é¡¹ä¸­ã€‚æ³¨æ„è¿™é‡Œçš„é•¿åç›®å½•é¡¹ä¸æ˜¯ç‹¬ç«‹çš„ï¼Œè€Œæ˜¯ä½œä¸ºçŸ­åç›®å½•é¡¹çš„è¡¥å……ã€‚å³æ¯ä¸ªæ–‡ä»¶æœ‰ä¸€ä¸ªçŸ­åç›®å½•é¡¹ï¼Œå¦‚æœæ–‡ä»¶åè¿‡é•¿åˆ™å¦æœ‰ä¸€äº›é•¿åç›®å½•é¡¹ä¸“é—¨å­˜å‚¨åå­—ã€‚é•¿åç›®å½•é¡¹å¿…é¡»ç´§é ç€å­˜æ”¾åœ¨å¯¹åº”çš„çŸ­åç›®å½•é¡¹å‰é¢ (å³ é•¿*n+çŸ­ = ä¸€ä¸ªæ–‡ä»¶/ç›®å½•çš„æè¿°)ã€‚\né•¿åç›®å½•é¡¹çš„å†…å®¹å¯ä»¥ç”¨å¦‚ä¸‹ç»“æ„ä½“è¡¨ç¤ºï¼š\nstruct LongDirent { uint8_t LDIR_Ord; /* 0 */ char LDIR_Name1[10]; /* 1 */ uint8_t LDIR_Attr; /* 11 */ uint8_t LDIR_Type; /* 12 */ uint8_t LDIR_Chksum; /* 13 */ char LDIR_Name2[12]; /* 14 */ uint16_t LDIR_FstClusLO; /* 26 */ char LDIR_Name3[4]; /* 28 */ }__attribute__((__packed__)); å„ä¸ªå­—æ®µçš„è§£é‡Šå¦‚ä¸‹ï¼š\nLDIR_Ordï¼šè¯¥å­—æ®µè¡¨ç¤ºè¯¥é•¿åç›®å½•é¡¹æ˜¯å…¶å¯¹åº”çš„çŸ­åç›®å½•é¡¹çš„ç¬¬å‡ ä¸ª (ä¸€ä¸ªå¾ˆé•¿çš„åå­—å¯èƒ½éœ€è¦å¤šä¸ªé•¿åç›®å½•é¡¹æ¥å­˜å‚¨)ã€‚å¯¹äºæœ€åä¸€ä¸ªé•¿åç›®å½•é¡¹ï¼Œå…¶ LDIR_Ord å¿…é¡»æˆ–ä¸Š LAST_LONG_ENTRY (0x40)ã€‚\nLDIR_Name1ï¼šé•¿åçš„ç¬¬ 1 ~ 5 ä¸ªå­—ç¬¦ã€‚\nLDIR_Attrï¼šé•¿åç›®å½•é¡¹çš„ LDIR_Attr å¿…é¡»è¢«è®¾ç½®ä¸º ATTR_LONG_NAMEï¼š\nATTR_LONG_NAME = ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_VOLUME_ID; ç”¨æ¥åˆ¤æ–­ä¸€ä¸ªç›®å½•é¡¹æ˜¯å¦æ˜¯é•¿åç›®å½•é¡¹çš„ Mask ä¸º\n#define ATTR_LONG_NAME_MASK (ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_VOLUME_ID | ATTR_DIRECTORY | ATTR_ARCHIVE); LDIR_Typeï¼šå¿…é¡»è¢«ç½®ä¸º 0ã€‚\nLDIR_ChkSumï¼šé’ˆå¯¹å…¶å¯¹åº”çš„çŸ­åç›®å½•é¡¹ç®—å‡ºæ¥çš„ä¸€ä¸ªæ ¡éªŒå€¼ã€‚\nLDIR_Name2ï¼šé•¿åçš„ç¬¬ 6 ~ 11 ä¸ªå­—ç¬¦ã€‚\nLDIR_FstClusLOï¼šå¿…é¡»è¢«ç½®ä¸º 0ã€‚\nLDIR_Name3ï¼šé•¿åçš„ç¬¬ 12 ~ 13 ä¸ªå­—ç¬¦ã€‚\n7.1 Ordinal Number Generation ä¸€ä¸ªçŸ­åç›®å½•é¡¹å¯¹åº”çš„ä¸€ç³»åˆ—é™„å±çš„é•¿åç›®å½•é¡¹åœ¨ LDIR_Ord è¿™ä¸ªå­—æ®µä¸Šåº”å½“æ»¡è¶³å¦‚ä¸‹è¦æ±‚ï¼š\nç¬¬ä¸€ä¸ªé•¿åç›®å½•é¡¹æ»¡è¶³ LDIR_Ord == 1ã€‚ åç»­çš„é•¿åç›®å½•é¡¹çš„ LDIR_Ord ä¿è¯ä¸¥æ ¼å•è°ƒé€’å¢ã€‚ æœ€åä¸€ä¸ªé•¿åç›®å½•é¡¹æ»¡è¶³ LDIR_Ord == (N | LAST_LONG_ENTRY)ã€‚ å¦‚æœä»¥ä¸Šä»»ä½•ä¸€æ¡ä¸æ»¡è¶³ï¼Œæˆ‘ä»¬å°±è®¤ä¸ºè¯¥é•¿åç›®å½•é¡¹é›†åˆè¢«æŸåäº†ã€‚\n7.2 Checksum Generation å½“çŸ­åç›®å½•é¡¹å’Œé•¿åç›®å½•é¡¹è¢«åˆ›å»ºçš„æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦åˆ›å»ºä¸€ä¸ª 8 bit çš„æ ¡éªŒå’Œã€‚è¿™ä¸ªæ ¡éªŒå’Œæ ¹æ®çŸ­åç›®å½•é¡¹çš„ DIR_Name å­—æ®µç”Ÿæˆï¼š\nunsigned char ChkSum (unsigned char *pFcbName) { short FcbNameLen; unsigned char Sum = 0; for (FcbNameLen = 11; FcbNameLen != 0; FcbNameLen--) Sum = ((Sum \u0026amp; 1) ? 0x80 : 0) + (Sum \u0026gt;\u0026gt; 1) + *pFcbName++; return Sum; } å¦‚æœé•¿åç›®å½•é¡¹ä¸­çš„æ ¡éªŒå’Œä¸å…¶å¯¹åº”çš„çŸ­åç›®å½•é¡¹ç®—å‡ºæ¥ä¸ä¸€è‡´ï¼Œæˆ‘ä»¬å°±è®¤ä¸ºè¯¥é•¿åç›®å½•é¡¹é›†åˆè¢«æŸåäº†ã€‚\n7.3 Example illustrating persistence of a long name ä¸‹é¢çš„å›¾ç‰‡ä»¥ \u0026ldquo;The quick brown.fox\u0026rdquo; è¿™ä¸ªåå­—ä¸ºä¾‹å±•ç¤ºäº†é•¿åçš„å­˜å‚¨æ–¹æ³•ï¼š\né•¿æ–‡ä»¶åä¸èƒ½è¶…è¿‡ 255 ä¸ªå­—ç¬¦ (ä¸åŒ…æ‹¬ç»“å°¾çš„ NULL)ã€‚é•¿æ–‡ä»¶åä¸­çš„å­—ç¬¦é™åˆ¶å’ŒçŸ­æ–‡ä»¶ååŸºæœ¬ä¸€æ · (è§ Section 6.1)ï¼Œä¸€äº›é¢å¤–çš„è§„åˆ™ä¸ºï¼š\né•¿æ–‡ä»¶åä¸­å¯ä»¥ä½¿ç”¨ä»»æ„å¤šä¸ª . å­—ç¬¦ã€‚\n+ , ; = [ ] è¿™å…­ä¸ªç‰¹æ®Šå­—ç¬¦ä¸èƒ½åœ¨çŸ­æ–‡ä»¶åä¸­å‡ºç°ï¼Œä½†é•¿æ–‡ä»¶åä¸­ä¹Ÿå¯ä»¥ä½¿ç”¨ã€‚\né•¿æ–‡ä»¶åä¸­é—´å…è®¸æœ‰ç©ºæ ¼ã€‚å¼€å¤´å’Œç»“å°¾çš„ç©ºæ ¼ä¼šè¢«å¿½ç•¥ã€‚\né•¿åç›®å½•é¡¹ä¸­ä½¿ç”¨ unicode æ¥å­˜å‚¨å­—ç¬¦ï¼Œunicode ä¸­æ¯ä¸ªå­—ç¬¦å  16 ä¸ª bit (2 ä¸ªå­—èŠ‚)ï¼Œè¿™æ˜¯ä¸çŸ­åç›®å½•é¡¹ä¸åŒçš„åœ°æ–¹ã€‚å¦ä¸€ä¸ªä¸åŒæ˜¯é•¿åç›®å½•é¡¹å¯ä»¥åŒºåˆ†å¤§å°å†™ã€‚\n7.4 Rules governing name creation and matching ä¸€ä¸ªç›®å½•ä¸‹æ‰€æœ‰çŸ­æ–‡ä»¶åå’Œé•¿æ–‡ä»¶åæ„æˆçš„é›†åˆè¢«ç§°ä¸ºä¸€ä¸ª namespaceã€‚ä¸€ä¸ª namespace ä¸‹çš„æ–‡ä»¶ååº”å½“éµå¾ªå¦‚ä¸‹è§„å®šï¼š\nä¸è®ºæ˜¯çŸ­æ–‡ä»¶åè¿˜æ˜¯é•¿æ–‡ä»¶åï¼Œåœ¨ä¸€ä¸ª namespace ä¸­å¿…é¡»æ˜¯å…¨å±€å”¯ä¸€çš„ã€‚è¿™é‡Œæ¯”è¾ƒå”¯ä¸€æ€§æ—¶å¿½ç•¥å¤§å°å†™ï¼Œå³å¦‚æœä¸¤ä¸ªåå­—å­—ç¬¦ä¸€æ ·ä½†å¤§å°å†™ä¸åŒä¹Ÿè¢«è®¤ä¸ºæ˜¯å†²çªçš„ã€‚ å¦‚æœä¸€ä¸ª OEM æˆ– unicode å­—ç¬¦æ— æ³•è¢«è½¬æ¢æˆç³»ç»Ÿä¸­çš„åˆé€‚å­—ç¬¦ï¼Œæ–‡ä»¶ç³»ç»Ÿåº”å½“å°†å…¶ç¿»è¯‘æˆ _ã€‚ ","date":1655164800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1655164800,"objectID":"e2dd02bac4180b06e8712fdf0f2cb073","permalink":"https://kristoff-starling.github.io/notes/manualnotes/fat/","publishdate":"2022-06-14T00:00:00Z","relpermalink":"/notes/manualnotes/fat/","section":"notes","summary":"è¯¥ç¬”è®°æ˜¯å¯¹ Microsoft Fat Specification çš„ç²¾åéƒ¨åˆ†çš„ç¿»è¯‘å’Œè§£è¯»ã€‚","tags":null,"title":"FAT Specification - Notes","type":"notes"},{"authors":null,"categories":null,"content":" å…³äºè®¡ç®—æœºä¿¡æ¯\nä½¿ç”¨ uname -a å‘½ä»¤å¯ä»¥æŸ¥çœ‹æ“ä½œç³»ç»Ÿï¼Œæ—¶é—´ï¼Œç¡¬ä»¶æ¶æ„ç­‰ã€‚\nWhat is Operating System? Operating system is responsible for makeing it easy to run programs, allowing programs to share memory and interact with devices. - OSTEP\næ“ä½œç³»ç»Ÿï¼šâ€œç®¡ç†è½¯ç¡¬ä»¶èµ„æºï¼Œä¸ºç¨‹åºæä¾›æœåŠ¡â€çš„ä¸œè¥¿ã€‚\nENIAC é€»è¾‘é—¨ï¼šçœŸç©ºç”µå­ç®¡ã€‚\nå­˜å‚¨å™¨ï¼šå»¶è¿Ÿçº¿å†…å­˜ï¼Œç±»ä¼¼äºâ€œå°ä¸‘æ‰”çƒâ€çš„æŠ€å·§ï¼Œå°†æ•°æ®ä¸æ–­åœ°æ‰”è¿›å»¶è¿Ÿçº¿ï¼Œæ‹¿å‡ºæ¥ä»¥åç»è¿‡æ”¾å¤§å™¨å†æ‰”è¿›å»¶è¿Ÿçº¿ã€‚\nè¾“å…¥è¾“å‡ºï¼šæ‰“ä¸€é’ˆ/å°†çº¸å¸¦æŒªåŠ¨ä¸€ä¸‹ã€‚\nä¸éœ€è¦æ“ä½œç³»ç»Ÿã€‚èƒ½è¿è¡Œç¨‹åºå°±ä¸é”™äº†ï¼Œä¸éœ€è¦â€œç®¡ç†ç¨‹åºçš„ç¨‹åºâ€ã€‚\n1950s Computer æ›´å¿«æ›´å°çš„é€»è¾‘é—¨ (æ™¶ä½“ç®¡)ï¼Œæ›´å¤§çš„å†…å­˜ (ç£èŠ¯å†…å­˜)ï¼Œæ›´ä¸°å¯Œçš„ I/O è®¾å¤‡ã€‚å› ä¸º I/O è®¾å¤‡é€Ÿåº¦ä¸¥é‡ä½äºå¤„ç†å™¨é€Ÿåº¦ï¼Œæ‰€ä»¥ä¸­æ–­æœºåˆ¶å‡ºç°ã€‚æ›´å¤šçš„äººä½¿ç”¨é€šç”¨è®¡ç®—æœºï¼Œä»–ä»¬å¸Œæœ›ä½¿ç”¨ APIï¼Œè€Œä¸æ˜¯ç›´æ¥ä½¿ç”¨ç¡¬ä»¶ã€‚å› æ­¤è¯ç”Ÿäº† FORTRAN ç¼–ç¨‹è¯­è¨€ã€‚\n1950s çš„æ“ä½œç³»ç»Ÿï¼šç®¡ç†å¤šä¸ªç¨‹åºä¾æ¬¡æ’é˜Ÿè¿è¡Œçš„åº“å‡½æ•°å’Œè°ƒåº¦å™¨ã€‚\nè®¡ç®—æœºéå¸¸è´µéå¸¸å°‘ï¼Œå¤šä¸ªç”¨æˆ·æ’é˜Ÿä½¿ç”¨è®¡ç®—æœºã€‚ å¾ˆå¤šç¨‹åºå¡ç‰‡ $\\rightarrow$ OS $\\rightarrow$ ç¡¬ä»¶ æ“ä½œ (operate) ä»»åŠ¡ (job) çš„ç³»ç»Ÿ (system) æ‰¹å¤„ç†ç³»ç»Ÿï¼šç¨‹åºè‡ªåŠ¨åˆ‡æ¢ (æ¢å¡) + æä¾›åº“å‡½æ•° API 1960s Computer æ›´å¤§çš„å†…å­˜ï¼Œæ›´å¤šçš„é«˜çº§è¯­è¨€ (COBOL, BASIC etc.) \u0026hellip; æˆ‘ä»¬å¯ä»¥å°†å¤šä¸ªç¨‹åºåŒæ—¶æ”¾åˆ°ç¨‹åºé‡Œã€‚ä½†è®¡ç®—æœºä¸­åªæœ‰ä¸€ä¸ª CPUã€‚\n1960s çš„æ“ä½œç³»ç»Ÿï¼š\nä¼ ç»Ÿçš„æ‰§è¡Œæµï¼šA on CPU (30s) $\\rightarrow$ A on device (5min) $\\rightarrow$ A on CPU (30s) B on CPU (30s)\nç†æƒ³çš„æ‰§è¡Œæµï¼š\nCPU: A on CPU(30s) $\\rightarrow$ OS è°ƒåº¦ $\\rightarrow$ B on CPU (30s) $\\rightarrow$ OS è°ƒåº¦ $\\rightarrow$ A on CPU\nDevice:\t$\\rightarrow$ A on device (5min)\nè¿™å°±æ˜¯å¤šé“ç¨‹åº (multiprogramming)ã€‚ä¸ºäº†é˜²æ­¢æ¶æ„ç¨‹åºå¯¹åˆ«çš„ç¨‹åºå’Œæ“ä½œç³»ç»Ÿæœ¬èº«çš„ç ´åï¼Œæˆ‘ä»¬è¿˜éœ€è¦å¯¹æ¯ä¸ªç¨‹åºçš„è¿è¡Œæœ‰ä¸€ä¸ªå¥½çš„éš”ç¦»æœºåˆ¶ã€‚\nå¤šé“ç¨‹åºåœ¨ç¨‹åºä½¿ç”¨è®¾å¤‡æ—¶å‘ç”Ÿåˆ‡æ¢ã€‚åœ¨å¼•å…¥æ—¶é’Ÿä¸­æ–­åï¼Œæ“ä½œç³»ç»Ÿæˆä¸ºè®¡ç®—æœºçš„éœ¸ä¸»ï¼šæ“ä½œç³»ç»Ÿå†³å®šè°æ¥è¿è¡Œã€‚\n1970s+ Computer è®¡ç®—æœºç©ºå‰å‘å±•ï¼Œä¸ä»Šå¤©å·²æ— å¤§å¼‚ã€‚\nåˆ†æ—¶ç³»ç»Ÿè¶‹äºæˆç†Ÿï¼ŒUNIX è¯ç”Ÿï¼Œå¥ å®šç°ä»£æ“ä½œç³»ç»Ÿçš„å½¢æ€ã€‚\nToday æ“ä½œç³»ç»Ÿï¼šè™šæ‹ŸåŒ–ç¡¬ä»¶èµ„æºï¼Œä¸ºåº”ç”¨ç¨‹åºæä¾›æœåŠ¡ã€‚\né¢å¯¹çš„é—®é¢˜ï¼š\næ›´å¤æ‚çš„å¤„ç†å™¨å’Œå†…å­˜ï¼šéå¯¹ç§°å¤šå¤„ç†å™¨ï¼Œ Non-uniform Memory Access etc.ã€‚ æ›´å¤šçš„è®¾å¤‡å’Œèµ„æºã€‚ â€¦â€¦ ","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"fa96d4008533636bc180a50d7338d605","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec01/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec01/","section":"notes","summary":"å…³äºè®¡ç®—æœºä¿¡æ¯\nä½¿ç”¨ uname -a å‘½ä»¤å¯ä»¥æŸ¥çœ‹æ“ä½œç³»ç»Ÿï¼Œæ—¶é—´ï¼Œç¡¬ä»¶æ¶æ„ç­‰ã€‚\nWhat is Operating System? Operating system is responsible for makeing it easy to run programs, allowing programs to share memory and interact with devices. - OSTEP","tags":null,"title":"Lecture 01: Introduction","type":"docs"},{"authors":null,"categories":null,"content":"Digital Logic æ•°å­—ç”µè·¯ï¼š\nçŠ¶æ€ï¼šå¯„å­˜å™¨ä¸­ä¿å­˜çš„å€¼ï¼› åˆå§‹çŠ¶æ€ï¼šRESETï¼› è¿ç§»ï¼šç»„åˆé€»è¾‘ç”µè·¯ä¸‹è®¡ç®—å¯„å­˜å™¨ä¸‹ä¸€ä¸ªå‘¨æœŸçš„å€¼ã€‚ Example: Seven-seg // logisim.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define REGS_FOREACH(_) _(X) _(Y) #define OUTS_FOREACH(_) _(A) _(B) _(C) _(D) _(E) _(F) _(G) #define RUN_LOGIC X1 = !X \u0026amp;\u0026amp; Y; \\ Y1 = !X \u0026amp;\u0026amp; !Y; \\ A = (!X \u0026amp;\u0026amp; !Y) || (X \u0026amp;\u0026amp; !Y); \\ B = 1; \\ C = (!X \u0026amp;\u0026amp; !Y) || (!X \u0026amp;\u0026amp; Y); \\ D = (!X \u0026amp;\u0026amp; !Y) || (X \u0026amp;\u0026amp; !Y); \\ E = (!X \u0026amp;\u0026amp; !Y) || (X \u0026amp;\u0026amp; !Y); \\ F = (!X \u0026amp;\u0026amp; !Y); \\ G = (X \u0026amp;\u0026amp; !Y); #define DEFINE(X) static int X, X##1; #define UPDATE(X) X = X##1; #define PRINT(X) printf(#X \u0026quot; = %d; \u0026quot;, X); int main() { REGS_FOREACH(DEFINE); OUTS_FOREACH(DEFINE); while (1) { // clock RUN_LOGIC; OUTS_FOREACH(PRINT); REGS_FOREACH(UPDATE); putchar('\\n'); fflush(stdout); sleep(1); } } æ•°å­—ç”µè·¯æ°¸è¿œæ˜¯æ ¹æ®å½“å‰çŠ¶æ€æœºçš„çŠ¶æ€ç¡®å®šæ¬¡æ€ï¼Œå¾ªç¯å¾€å¤ã€‚ä¸Šè¿°ç¨‹åºç”¨ä¸¤ä¸ªå¯„å­˜å™¨ X,Y å®ç°äº†ä¸ƒæ®µæ•°ç ç®¡ 0 $\\rightarrow$ 1 $\\rightarrow$ 2 å¾ªç¯æ›´æ–°çš„åŠŸèƒ½ (æ³¨ï¼šè¿™æ®µä»£ç ä½¿ç”¨äº†ä¸€äº› X-macros æŠ€å·§ï¼Œä½¿å¾—æˆ‘ä»¬æ— éœ€å¯¹æ¯ä¸ªå¯„å­˜å™¨å†™ç›¸åŒçš„ä»£ç ï¼Œå€¼å¾—å­¦ä¹ ã€‚)\næ­é…ä¸Šä¸€ä¸ªç®€å•çš„ python ç¨‹åºï¼Œæˆ‘ä»¬ä¾¿å¯ä»¥åœ¨ç»ˆç«¯ä¸­æ‰“å°è¿™ä¸ªä¸ƒæ®µæ•°ç ç®¡ï¼š\n# seven-seg.py import fileinput TEMPLATE = ''' \\033[2J\\033[1;1f AAAAAAAAA FF BB FF BB FF BB FF BB GGGGGGGGG EE CC EE CC EE CC EE CC DDDDDDDDD ''' BLOCK = { 0: '\\033[37mâ–‘\\033[0m', # STFW: ANSI Escape Code 1: '\\033[31mâ–ˆ\\033[0m', } VARS = 'ABCDEFG' for v in VARS: globals()[v] = 0 stdin = fileinput.input() while True: exec(stdin.readline()) pic = TEMPLATE for v in VARS: pic = pic.replace(v, BLOCK[globals()[v]]) # 'A' -\u0026gt; BLOCK[A], ... print(pic) å…³äºè¯¥ python ç¨‹åºçš„ä¸€äº›æ³¨è§£ï¼š\nexec(stdin.readline()) ç”¨äºå°†è¯»å…¥çš„å†…å®¹ç›´æ¥å½“ä½œ python è¯­å¥æ‰§è¡Œã€‚ç”±äºä¹‹å‰çš„ C ç¨‹åºåœ¨ä¸€è¡Œä¸­ç”¨ ; å°†å¤šä¸ªå˜é‡èµ‹å€¼åˆ†å¼€ï¼Œç¬¦åˆ python è¯­æ³•ï¼Œå› æ­¤å¯ä»¥ç›´æ¥ä½œä¸º python ç¨‹åºä¸­çš„å˜é‡èµ‹å€¼è¯­å¥ã€‚ BLOCK[] æ•°ç»„ä¸­å­˜å‚¨äº†ä¸¤ç§é¢œè‰²ï¼š37 å·æ˜¯ç™½è‰²ï¼Œ31 å·æ˜¯çº¢è‰²ã€‚è¿™é‡Œä½¿ç”¨äº† ANSI Escape Codeï¼Œå…·ä½“æ ¼å¼å¯ä»¥å‚è€ƒ è¿™ç¯‡æ–‡ç« ã€‚ Programs: Code Perspective C ç¨‹åºä¹Ÿæ˜¯çŠ¶æ€æœºï¼š\nçŠ¶æ€ï¼šå †+æ ˆï¼› åˆå§‹çŠ¶æ€ï¼šmain() çš„ç¬¬ä¸€æ¡è¯­å¥ï¼› è¿ç§»ï¼šæ‰§è¡Œä¸€æ¡ç®€å•è¯­å¥ã€‚ ä»æ›´ low-level çš„è§’åº¦è€Œè¨€ï¼ŒC ç¨‹åºçš„çŠ¶æ€æœºæè¿°å¦‚ä¸‹ï¼š\nçŠ¶æ€ï¼šå…¨å±€å˜é‡+æ ˆå¸§çš„åˆ—è¡¨ (æ¯ä¸ªæ ˆå¸§é‡Œæœ‰ä¸€ä¸ª PC è¡¨ç¤ºå½“å‰æ‰§è¡Œåˆ°å“ªé‡Œ)ï¼›\nåˆå§‹çŠ¶æ€ï¼šmain(argc, argv)ï¼›\nè¿ç§»ï¼šæ‰§è¡Œ top stack frame ä¸­ PC å¤„çš„è¯­å¥ï¼ŒPC++ã€‚\nå‡½æ•°çš„è°ƒç”¨æœ¬è´¨ä¸Šå°±æ˜¯æ–°å»ºä¸€ä¸ªæ ˆå¸§æ”¾åœ¨æ ˆå¸§åˆ—è¡¨çš„é¡¶éƒ¨ï¼Œç„¶åè·³è½¬åˆ°è¯¥æ ˆå¸§ä¸­çš„ç¬¬ä¸€æ¡æŒ‡ä»¤ï¼›å‡½æ•°çš„è¿”å›æœ¬è´¨ä¸Šå°±æ˜¯å°†é¡¶éƒ¨çš„æ ˆå¸§ pop æ‰ã€‚\nExample: Hanoi-nr // hanoi-nr.c typedef struct { int pc, n; char from, to, via; } Frame; #define call(...) ({ *(++top) = (Frame) { .pc = 0, __VA_ARGS__ }; }) #define ret() ({ top--; }) #define goto(loc) ({ f-\u0026gt;pc = (loc) - 1; }) void hanoi(int n, char from, char to, char via) { Frame stk[64], *top = stk - 1; call(n, from, to, via); for (Frame *f; (f = top) \u0026gt;= stk; f-\u0026gt;pc++) { switch (f-\u0026gt;pc) { case 0: if (f-\u0026gt;n == 1) { printf(\u0026quot;%c -\u0026gt; %c\\n\u0026quot;, f-\u0026gt;from, f-\u0026gt;to); goto(4); } break; case 1: call(f-\u0026gt;n - 1, f-\u0026gt;from, f-\u0026gt;via, f-\u0026gt;to); break; case 2: call( 1, f-\u0026gt;from, f-\u0026gt;to, f-\u0026gt;via); break; case 3: call(f-\u0026gt;n - 1, f-\u0026gt;via, f-\u0026gt;to, f-\u0026gt;from); break; case 4: ret(); break; default: assert(0); } } } switch-case ç»“æ„ç›¸å½“äºç»™é€’å½’ä»£ç ç¼–ä¸Šäº†â€œè¡Œå·â€ã€‚æ¯ä¸ªæ ˆå¸§ä¸­çš„ PC è¡¨ç¤ºå½“å‰å±‚å‡½æ•°æ‰§è¡Œåˆ°äº†ç¬¬å‡ è¡Œã€‚\nPrograms: Binary Perspective ä»äºŒè¿›åˆ¶çš„è§’åº¦ï¼Œç¨‹åºä»ç„¶æ˜¯çŠ¶æ€æœºã€‚\nçŠ¶æ€ï¼šå¯„å­˜å™¨ï¼Œå†…å­˜â€¦â€¦ è¿ç§»ï¼šæ‰§è¡Œä¸€æ¡æŒ‡ä»¤ å¦‚æœæ•´ä¸ªç¨‹åºçš„è¡Œä¸ºæ˜¯ç¡®å®šçš„ï¼ŒçŠ¶æ€æœºåº”è¯¥é•¿æˆä¸€æ¡ç›´çº¿ï¼š$(M_0,R_0)\\rightarrow (M_1,R_1)\\rightarrow\\cdots$ ã€‚å¦‚æœå¼•å…¥äº†ä¸€äº› non-deterministic çš„å…ƒç´ ï¼Œæ¯”å¦‚ rdrand æŒ‡ä»¤ (è¯»å–ä¸€ä¸ªç¡¬ä»¶éšæœºæ•°åˆ°å¯„å­˜å™¨ä¸­)ï¼Œé‚£ä¹ˆçŠ¶æ€æœºä¼šæœ‰åˆ†å‰ã€‚ä½†æ— è®ºå¦‚ä½•ï¼Œè¿™æ˜¯ä¸€ä¸ªæœ‰é™çŠ¶æ€æœº (å†…å­˜ã€å¯„å­˜å™¨æ•°é‡æ˜¯æœ‰é™çš„)ï¼Œå¦‚æœåªæœ‰è®¡ç®—æŒ‡ä»¤ï¼Œæœ‰é™æ­¥ä¹‹åæˆ‘ä»¬å¿…ç„¶ä¼šå›åˆ°ä¸€ä¸ªç»å†è¿‡çš„çŠ¶æ€ã€‚æˆ‘ä»¬æ— æ³•å®ç°è¾“å…¥è¾“å‡ºï¼Œç”šè‡³æ˜¯åœæ­¢ç¨‹åºã€‚\nå› æ­¤ï¼Œç¨‹åºä¸­æœ‰ä¸€æ¡ç‰¹æ®Šçš„æŒ‡ä»¤ï¼šsyscallã€‚ç¨‹åºå°†è‡ªå·±çš„çŠ¶æ€æœº $(M,R)$ äº¤ç»™æ“ä½œç³»ç»Ÿï¼Œä»»å…¶ä¿®æ”¹ï¼Œæœ€ç»ˆæ“ä½œç³»ç»Ÿè¿”å›ä¸€ä¸ªçŠ¶æ€æœº $(M\u0026rsquo;,R\u0026rsquo;)$ï¼Œç¨‹åºç»§ç»­æ‰§è¡Œã€‚å› æ­¤ç¨‹åº=è®¡ç®—+syscall+è®¡ç®—+syscall+â€¦â€¦\nExample: A smallest \u0026ldquo;Hello, world\u0026rdquo; æˆ‘ä»¬æƒ³è±¡ä¸­çš„æœ€å°å‡½æ•°ï¼š\nvoid _start() { } ç›´æ¥è¿è¡Œä¼šå¾—åˆ° SIGSEGVã€‚ä½¿ç”¨ GDB å¯¹æ±‡ç¼–ä»£ç è¿›è¡Œè°ƒè¯•ï¼š\n0x401000 \u0026lt;_start\u0026gt; endbr64 0x401004 \u0026lt;_start+4\u0026gt; push %rbp 0x401005 \u0026lt;_start+5\u0026gt; mov %rsp,%rbp 0x401008 \u0026lt;_start+8\u0026gt; nop 0x401009 \u0026lt;_start+9\u0026gt; pop %rbp 0x40100a \u0026lt;_start+10\u0026gt; ret æ‰§è¡Œ ret æŒ‡ä»¤æ—¶å‘ç”Ÿé”™è¯¯ï¼Œå› æ­¤ ret çš„æœ¬è´¨æ˜¯å°† %rax çš„å€¼èµ‹ç»™ PCï¼Œè€Œæ­¤æ—¶ %rax çš„å€¼æ˜¯ä¸€ä¸ªéæ³•çš„åœ°å€ã€‚\nç”¨æˆ·ç¨‹åºåªèƒ½è§£å†³â€œè®¡ç®—â€çš„é—®é¢˜ï¼Œå› æ­¤æˆ‘ä»¬ç”šè‡³æ— æ³•ç»“æŸç¨‹åºã€‚æˆ‘ä»¬å¿…é¡»å€ŸåŠ©ç³»ç»Ÿè°ƒç”¨æ‰èƒ½ä½¿ç¨‹åºæ­£å¸¸è¿è¡Œèµ·æ¥ã€‚\n# minimal.S #include \u0026lt;sys/syscall.h\u0026gt; .globl _start _start: movq $SYS_write, %rax # write( movq $1, %rdi # fd=1, movq $st, %rsi # buf=st, movq $(ed - st), %rdx # count=ed-st syscall # ); movq $SYS_exit, %rax # exit( movq $1, %rdi # status=1 syscall # ); st: .ascii \u0026quot;\\033[01;31mHello, OS World\\033[0m\\n\u0026quot; ed: å‰åŠæ®µç¨‹åºè´Ÿè´£æ‰“å°ï¼šå°†ç³»ç»Ÿè°ƒç”¨å· SYS_write å’Œè¾“å‡ºå¯¹è±¡ï¼Œè¾“å‡ºå†…å®¹ç­‰å‚æ•°æ”¾åˆ° x86-64 åˆ¶å®šçš„å¯„å­˜å™¨ä¸­ï¼Œç„¶åä½¿ç”¨ syscall æŒ‡ä»¤ï¼›ååŠæ®µè´Ÿè´£é€€å‡ºã€‚\nä½¿ç”¨ gcc -c minimal.S \u0026amp;\u0026amp; ld minimal.S \u0026amp;\u0026amp; ./a.out å‘½ä»¤ï¼Œå¯ä»¥å¾—åˆ°çº¢è‰²åŠ ç²—çš„ \u0026ldquo;Hello, OS World\u0026rdquo;ã€‚\nSwitching between Perspectives è®°æºä»£ç ä¸º $S$ï¼Œæ±‡ç¼–ä»£ç ä¸º $S$ï¼Œåˆ™ç¼–è¯‘å™¨å°±æ˜¯ä¸€ä¸ªå‡½æ•°ï¼š$S=compile(S)$ã€‚\nä»çŠ¶æ€æœºçš„è§†è§’æ¥çœ‹ï¼Œç¼–è¯‘ (ä¼˜åŒ–) çš„æ­£ç¡®æ€§ (soundness) çš„å«ä¹‰æ˜¯ï¼šä¸¤ä¸ªçŠ¶æ€æœºçš„å¯è§‚æµ‹è¡Œä¸ºå®Œå…¨ä¸€è‡´ã€‚å› æ­¤åœ¨ä¿è¯æ•´ä½“è¯­ä¹‰ä¸å˜çš„å‰æä¸‹ï¼Œç¼–è¯‘å™¨å¯ä»¥è‡ªç”±åœ°è°ƒæ•´è¯­å¥é¡ºåºï¼Œåˆå¹¶è¯­å¥ï¼Œåˆ é™¤æ— ç”¨è¯­å¥ç­‰ã€‚\nExample: Compile Optimization void foo(int g) { g++; g++; } å¼€å¯ -O1 ä¼˜åŒ–åï¼Œå¾—åˆ°çš„æ±‡ç¼–ä»£ç ä¸º\n0000000000000000 \u0026lt;foo\u0026gt;: 0:\tf3 0f 1e fa endbr64 4:\tc3 ret ç¼–è¯‘å™¨ç›´æ¥å°† g++ åˆ é™¤äº†ï¼Œå› ä¸ºæ²¡æœ‰è¿”å›ï¼Œè¿™ä¸¤å¥è¯æ²¡æœ‰ä½œç”¨ã€‚\nextern int g; void foo(int x) { g++; g++; } æ±‡ç¼–ä»£ç ä¸º\n0000000000000000 \u0026lt;foo\u0026gt;: 0:\tf3 0f 1e fa endbr64 4:\t83 05 00 00 00 00 02 addl $0x2,0x0(%rip) # b \u0026lt;foo+0xb\u0026gt; b:\tc3 ret å› ä¸º g æ˜¯å¤–éƒ¨å˜é‡ï¼Œæ‰€ä»¥è¿™é‡Œå¯¹ g çš„æ“ä½œæ˜¯æœ‰æ„ä¹‰çš„ï¼Œä½†è¿ç»­çš„ä¸¤æ¬¡ +1 å¯ä»¥ç”¨ä¸€æ¬¡ +2 æ¥ä»£æ›¿ã€‚\nextern int g; void foo(int x) { g++; asm volatile(\u0026quot;nop\u0026quot; : : \u0026quot;r\u0026quot;(x)); g++; } æ±‡ç¼–ä»£ç ä¸º\n0000000000000000 \u0026lt;foo\u0026gt;: 0:\tf3 0f 1e fa endbr64 4:\t90 nop 5:\t83 05 00 00 00 00 02 addl $0x2,0x0(%rip) # c \u0026lt;foo+0xc\u0026gt; c:\tc3 ret è¿™è¯´æ˜ç¼–è¯‘å™¨å¯ä»¥è°ƒæ•´è¯­å¥çš„é¡ºåºï¼Œç„¶åå°†ä¸¤ä¸ª +1 åˆå¹¶æˆä¸€ä¸ª +2ã€‚\nä½†æˆ‘ä»¬æœ‰æ‰‹æ®µå¯ä»¥è®©ç¼–è¯‘å™¨æ— æ³•è¿›è¡Œè¿™ä¸ªåˆå¹¶ï¼š\nextern int g; void foo(int x) { g++; asm volatile (\u0026quot;nop\u0026quot; : : \u0026quot;r\u0026quot;(x) : \u0026quot;memory\u0026quot;); g++; } æ±‡ç¼–ä»£ç ä¸º\n0000000000000000 \u0026lt;foo\u0026gt;: 0:\tf3 0f 1e fa endbr64 4:\t83 05 00 00 00 00 01 addl $0x1,0x0(%rip) # b \u0026lt;foo+0xb\u0026gt; b:\t90 nop c:\t83 05 00 00 00 00 01 addl $0x1,0x0(%rip) # 13 \u0026lt;foo+0x13\u0026gt; 13:\tc3 ret ä¸­é—´æ’å…¥çš„å†…è”æ±‡ç¼–è¯­å¥ä½¿ç”¨äº† memory clobberï¼Œå…¶æ„æ€æ˜¯å‘Šè¯‰ç¼–è¯‘å™¨è¿™äº›å†…è”æ±‡ç¼–ä»£ç å¯èƒ½ä¼šä»»æ„è¯»å–ã€ä¿®æ”¹å†…å­˜å†…å®¹ï¼Œå› æ­¤ç¼–è¯‘å™¨åœ¨è°ƒæ•´è¯­å¥é¡ºåºæ—¶ï¼Œä¸èƒ½è¶…è¿‡è¿™ä¸ª asm blockã€‚è¿™å¥è¯å°±åƒä¸€å µå¢™ä¸€æ ·æŒ¡åœ¨ä¸­é—´ï¼Œä½¿å¾—ä¸¤å¤„ +1 æ— æ³•è¢«åˆå¹¶ã€‚\nè¯¥æ‰‹æ³•åœ¨æ“ä½œç³»ç»Ÿçš„é”æœºåˆ¶ä¸­æœ‰é‡è¦çš„åº”ç”¨ (é¿å…ç¼–è¯‘å™¨å°† critical section ä¸­çš„è¯­å¥ä¼˜åŒ–åˆ°å¤–é¢ï¼Œå¯¼è‡´ race condition)ã€‚\nPrograms: OS Perspective æ“ä½œç³»ç»Ÿçœ¼ä¸­çš„ç¨‹åºï¼šç¨‹åº=è®¡ç®—+syscall+è®¡ç®—+syscall+â€¦â€¦ ç¨‹åºåªèƒ½é€šè¿‡æ“ä½œç³»ç»Ÿå…è®¸çš„æ–¹å¼æ¥è®¿é—®æ“ä½œç³»ç»ŸæŒæ§çš„èµ„æºï¼Œä»è€Œæ“ä½œç³»ç»ŸæŒæ¡äº†è®¡ç®—æœºçš„â€œéœ¸æƒâ€ã€‚\nExample: Entering a Program ä¸€ä¸ª C ç¨‹åºæ‰§è¡Œçš„ç¬¬ä¸€æ¡æŒ‡ä»¤åœ¨å“ªé‡Œï¼Ÿ\næœ€åˆç†çš„æ–¹æ³•ï¼šç”¨ gdb æ‰“å¼€å¯æ‰§è¡Œæ–‡ä»¶ï¼Œç„¶åç”¨ starti æŒ‡ä»¤å®šä½åˆ°ç¬¬ä¸€æ¡æ±‡ç¼–æŒ‡ä»¤ï¼Œå‘ç°åœ¨ /lib64/ld-linux-x86-64.so.2 ä¸­ã€‚è¿™æ˜¯ä¸€ä¸ªåŠ è½½å™¨ï¼ŒåŠ è½½å™¨è´Ÿè´£è·³è½¬åˆ° __start() æ‰§è¡Œã€‚\nå‡­ä»€ä¹ˆä¸èƒ½æ˜¯ rtfm.so?\nä½¿ç”¨ readelf å·¥å…·ï¼Œå¯ä»¥çœ‹åˆ°åœ¨å¯æ‰§è¡Œæ–‡ä»¶ä¸­è¯´æ˜äº†\n[Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] å¦‚æœæˆ‘ä»¬ç›´æ¥å¯¹ a.out è¿›è¡Œä¿®æ”¹ï¼Œå°† ld-linux-x86-64.so.2 å­—æ®µæ”¹ä¸º rtfm.soï¼Œå†åˆ›å»ºä¸€ä¸ªä» rtfm.so åˆ° ld-linux-x86-64.so.2 çš„é“¾æ¥ï¼Œæˆ‘ä»¬å°±çœŸçš„å¯ä»¥å®ç°ç”¨æˆ‘ä»¬åˆ¶å®šçš„ rtfm.so æ¥åŠ è½½ç¨‹åºã€‚\nè®¡ç®—æœºç³»ç»Ÿä¸å­˜åœ¨ç„å­¦ï¼Œä¸€åˆ‡éƒ½å»ºç«‹åœ¨ç¡®å®šçš„æœºåˆ¶ä¸Šã€‚\nåœ¨æ‰§è¡Œ main() å‡½æ•°ä¹‹å‰ï¼Œç¨‹åºç»å†äº†å¾ˆå¤šçš„è¿‡ç¨‹ï¼Œä½¿ç”¨äº†å¾ˆå¤šçš„ç³»ç»Ÿè°ƒç”¨ï¼Œç”¨ strace å·¥å…·å¯ä»¥æŸ¥çœ‹è¿™äº›ç³»ç»Ÿè°ƒç”¨(æ³¨ï¼šstrace ä¼šè¾“å‡ºåˆ°æ ‡å‡†é”™è¯¯ï¼Œé‡å®šå‘æ—¶è¦æ³¨æ„)ã€‚ C è¯­è¨€è¿˜æ”¯æŒåœ¨è¿›å…¥ main() å‡½æ•°ä¹‹å‰å’Œä¹‹ååšäº‹æƒ…ï¼š\n// hello-goodbye.c #include \u0026lt;stdio.h\u0026gt; __attribute__((constructor)) void hello() { printf(\u0026quot;Hello, World\\n\u0026quot;); } // See also: atexit(3) __attribute__((destructor)) void goodbye() { printf(\u0026quot;Goodbye, Cruel OS World!\\n\u0026quot;); } int main() { } Tip: åˆ©ç”¨ Vim æ¥æ•´ç†ä¸æ˜“é˜…è¯»çš„è¾“å…¥å†…å®¹\nstrace è¾“å‡ºçš„å†…å®¹æ‚ä¹±éš¾è¯»ï¼Œåˆ©ç”¨ vim å¯¹å…¶è¿›è¡Œæ•´ç†å¯ä»¥å¸®åŠ©æˆ‘ä»¬é˜…è¯»ã€‚å¸¸ç”¨çš„æ•´ç†å‘½ä»¤å¯ä»¥æœ‰ï¼š\n:%! grep [-v] word ç­›é€‰å‡ºåŒ…å« word çš„è¡Œ (-v å‚æ•°å¯ä»¥åå‘ç­›é€‰)ã€‚ :%s/, \\r /g å°†æ‰€æœ‰çš„ , æ›¿æ¢ä¸ºæ¢è¡Œç¬¦ã€‚äººç±»å€¾å‘äºé˜…è¯»è¡Œæ•°å¤šä½†æ¯è¡Œéƒ½å¾ˆçŸ­çš„å†…å®¹ã€‚ â€¦â€¦ ","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"9bf7ad50b9d965285481cacbe717977d","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec02/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec02/","section":"notes","summary":"Digital Logic æ•°å­—ç”µè·¯ï¼š\nçŠ¶æ€ï¼šå¯„å­˜å™¨ä¸­ä¿å­˜çš„å€¼ï¼› åˆå§‹çŠ¶æ€ï¼šRESETï¼› è¿ç§»ï¼šç»„åˆé€»è¾‘ç”µè·¯ä¸‹è®¡ç®—å¯„å­˜å™¨ä¸‹ä¸€ä¸ªå‘¨æœŸçš„å€¼ã€‚ Example: Seven-seg // logisim.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define REGS_FOREACH(_) _(X) _(Y) #define OUTS_FOREACH(_) _(A) _(B) _(C) _(D) _(E) _(F) _(G) #define RUN_LOGIC X1 = !","tags":null,"title":"Lecture 02: Programs on Operating Systems","type":"docs"},{"authors":null,"categories":null,"content":"å¹¶å‘ï¼šä¸€ä¸ªè®¡ç®—æœºç¨‹åºè¢«åˆ†æˆäº†è‹¥å¹²ä¸ªéƒ¨åˆ†ï¼Œåœ¨ä¸æ”¹å˜ç¨‹åºæœ€ç»ˆè¿è¡Œç»“æœçš„æƒ…å†µä¸‹ï¼Œè¿™äº›éƒ¨åˆ†è¢«ä¹±åºåœ°æ‰§è¡Œã€‚å¹¶å‘æ‰§è¡Œçš„å¤šä¸ªéƒ¨åˆ†ä¼šå…±äº«èµ„æºã€‚\nState Machine åœ¨å•çº¿ç¨‹è§†è§’ä¸­ï¼ŒC ç¨‹åºçš„çŠ¶æ€æœºåŒ…æ‹¬å…¨å±€å˜é‡ï¼Œå †åŒºï¼Œæ ˆå¸§åˆ—è¡¨ç­‰ã€‚å…¨å±€å˜é‡å’Œå †åŒºçš„å†…å®¹æ˜¯å…¨å±€çš„ï¼Œæ˜¯æ‰€æœ‰å‡½æ•°å…±äº«çš„ï¼Œç†åº”ä½œä¸ºå…±äº«èµ„æºï¼›æ ˆå¸§ä¸­çš„å˜é‡éƒ½æ˜¯å±€éƒ¨å˜é‡ï¼Œæ ˆå¸§ä¸æ ˆå¸§ä¹‹é—´ç‹¬ç«‹æ€§è¾ƒå¼ºï¼Œå¯ä»¥äº¤ç»™å¤šä¸ªçº¿ç¨‹ã€‚\nå¤šçº¿ç¨‹è§†è§’ä¸‹çš„çŠ¶æ€æœºï¼š\nå…¨å±€å˜é‡ï¼Œå †åŒºç­‰å…¨å±€å…±äº«èµ„æºï¼› è‹¥å¹²ä¸ªæ ˆå¸§é“¾ï¼Œæ¯æ¡æ ˆå¸§é“¾å±äºä¸€ä¸ªçº¿ç¨‹ã€‚ åœ¨å¹¶å‘ç¨‹åºä¸­ï¼Œæ¯ä¸€æ­¥çš„ç»“æœéƒ½æ˜¯ non-deterministic çš„ï¼Œå®ƒçš„çŠ¶æ€è½¬ç§»å›¾æ˜¯é•¿æˆè¿™æ ·çš„ï¼š\nstateDiagram state1: (g, T1, T2) state1 --\u0026gt; state2: çº¿ç¨‹T1æ‰§è¡Œ state1 --\u0026gt; state3: çº¿ç¨‹T2æ‰§è¡Œ state2: (g',T1',T2) state3: (g',T1,T2') state2 --\u0026gt; state4: çº¿ç¨‹T1æ‰§è¡Œ state2 --\u0026gt; state5: çº¿ç¨‹T2æ‰§è¡Œ state3 --\u0026gt; state6: çº¿ç¨‹T1æ‰§è¡Œ state3 --\u0026gt; state7: çº¿ç¨‹T2æ‰§è¡Œ state4: â€¦â€¦ state5: â€¦â€¦ state6: â€¦â€¦ state7: â€¦â€¦ Simplified Thread API // thread.h #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdatomic.h\u0026gt; #include \u0026lt;assert.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #define NTHREAD 6400 enum { T_FREE = 0, T_LIVE, T_DEAD, }; struct thread { int id, status; pthread_t thread; void (*entry)(int); }; struct thread tpool[NTHREAD], *tptr = tpool; void *wrapper(void *arg) { struct thread *thread = (struct thread *)arg; thread-\u0026gt;entry(thread-\u0026gt;id); return NULL; } void create(void *fn) { assert(tptr - tpool \u0026lt; NTHREAD); *tptr = (struct thread) { .id = tptr - tpool + 1, .status = T_LIVE, .entry = fn, }; pthread_create(\u0026amp;(tptr-\u0026gt;thread), NULL, wrapper, tptr); ++tptr; } void join() { for (int i = 0; i \u0026lt; NTHREAD; i++) { struct thread *t = \u0026amp;tpool[i]; if (t-\u0026gt;status == T_LIVE) { pthread_join(t-\u0026gt;thread, NULL); t-\u0026gt;status = T_DEAD; } } } __attribute__((destructor)) void cleanup() { join(); } thread.h æ˜¯å¯¹ C åº“ pthreads çš„è¿›ä¸€æ­¥å°è£…ã€‚å…¶ä¸­çš„ä¸€äº›å…³é”®å‡½æ•°å’Œä»£ç è§£è¯»å¦‚ä¸‹ï¼š\ncreate(fn) ï¼šåˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹å¹¶ç«‹å³æ‰§è¡Œï¼Œè¯¥çº¿ç¨‹çš„å…¥å£å‡½æ•°æ˜¯ fnã€‚\nå‡½æ•° fn çš„å®šä¹‰ä¸º void fn(int tid)ï¼Œå…¶ä¸­ tid ä¸ºçº¿ç¨‹å·ï¼Œä» 1 å¼€å§‹ç¼–å·ã€‚\nä»çŠ¶æ€æœºçš„è§’åº¦æ¥çœ‹ï¼Œcreate() çš„è¯­ä¹‰æ˜¯åœ¨çŠ¶æ€æœºä¸­æ–°å¼€äº†ä¸€ä¸ªé“¾è¡¨ï¼Œè¿™ä¸ªé“¾è¡¨åªæœ‰ä¸€ä¸ª fn å‡½æ•°çš„æ ˆå¸§ã€‚\nåŸç†ï¼špthread_create() å‡½æ•°çš„å£°æ˜ä¸º\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg); å…¶ä¸­ start_routine æ˜¯æ–°çº¿ç¨‹ç¬¬ä¸€ä¸ªæ‰§è¡Œçš„å‡½æ•°ï¼Œarg æ˜¯ç»™ start_routine ä¼ å…¥çš„å‚æ•°ï¼Œattr è®¾ç½®ä¸º NULL è¡¨ç¤ºæŒ‰ç…§é»˜è®¤æ–¹å¼åˆ›å»ºçº¿ç¨‹ã€‚thread.h ä¸­ä¼ å…¥çš„ start_routine æ˜¯ wrapperï¼Œwrapper ä¸­çš„è¯­å¥ thread-\u0026gt;entry(thread-\u0026gt;id) ä»¥çº¿ç¨‹å·ä¸ºå‚æ•°ï¼Œè°ƒç”¨äº† fn å‡½æ•°ã€‚\njoin()ï¼šjoin() æ˜¯çº¿ç¨‹ä¸­çš„â€œç­‰å¾…â€ï¼Œå’Œè¿›ç¨‹ä¸­çš„ wait() æœ‰ä¸€ç‚¹ç›¸ä¼¼ã€‚join() çš„è¯­ä¹‰ç›¸å½“äºåœ¨è°ƒç”¨è¯¥å‡½æ•°çš„çº¿ç¨‹ä¸­åŠ å…¥äº†ä¸€æ¡æ­»å¾ªç¯è¯­å¥ï¼š\nwhile (å…¶ä»–çº¿ç¨‹æœªç»“æŸ); å‡è®¾å½“å‰æœ‰ä¸‰ä¸ªçº¿ç¨‹ T1,T2,T3ï¼ŒT1 ä¸­è°ƒç”¨äº† join()ï¼Œåˆ™ä¹‹åçš„çŠ¶æ€æœºå¦‚ä¸‹ï¼š\nstateDiagram state1:(T1(join),T2,T3) state1 --\u0026gt; state1: çº¿ç¨‹ T1 æ‰§è¡Œ state1 --\u0026gt; state2: çº¿ç¨‹ T2 æ‰§è¡Œ state1 --\u0026gt; state3: çº¿ç¨‹ T3 æ‰§è¡Œ state2:(T1(join), T2(end), T3) state3:(T1(join), T2, T3(end)) state2 --\u0026gt; state2: çº¿ç¨‹ T1 æ‰§è¡Œ state2 --\u0026gt; state4: çº¿ç¨‹ T3 æ‰§è¡Œ state3 --\u0026gt; state3: çº¿ç¨‹ T1 æ‰§è¡Œ state3 --\u0026gt; state4: çº¿ç¨‹ T2 æ‰§è¡Œ state4: (T1,T2(end),T3(end)) note right of state4 T2,T3 çº¿ç¨‹å‡ç»“æŸï¼ŒT1 æ­»å¾ªç¯è§£é™¤ end note state4 --\u0026gt; state5 state5: â€¦â€¦ åŸç†ï¼šjoin() ä¸­ä¸»çº¿ç¨‹ä¼šéå†çº¿ç¨‹æ•°ç»„ï¼Œè°ƒç”¨ pthread_join() å‡½æ•°ç­‰å¾…å®ƒä»¬ä¸€ä¸€ç»“æŸï¼Œå°†å…¶çŠ¶æ€è®¾ç½®ä¸º T_DEADï¼Œç„¶åè¿”å›ã€‚pthread_join() å‡½æ•°çš„å£°æ˜ä¸ºï¼š\nint pthread_join(pthread_t thread, void **retval); å½“å‰å‡½æ•°ä¼šç­‰å¾… thread çº¿ç¨‹æ‰§è¡Œç»“æŸ (è‹¥ thread å·²ç»ç»“æŸå°±ç›´æ¥è¿”å›)ï¼Œå¦‚æœ retval æŒ‡é’ˆä¸ä¸ºç©ºï¼Œå°±å°† thread çº¿ç¨‹çš„é€€å‡ºçŠ¶æ€æŒ‡é’ˆå¡«å†™åˆ° retval ä¸­ã€‚\nåœ¨ include äº† threads.h çš„æƒ…å†µä¸‹ï¼Œmain() å‡½æ•°æ‰§è¡Œç»“æŸåï¼Œæ‰€æœ‰æ–°åˆ›å»ºçš„çº¿ç¨‹ä¼šè¢«è‡ªåŠ¨é‡Šæ”¾ã€‚è¯¥åŠŸèƒ½æ˜¯ç”± thread.h ä¸­çš„ clean_up() å‡½æ•°å®ç°çš„ (æ·»åŠ äº† __attribute__((destructor)) çš„å‡½æ•°ä¼šåœ¨ main() å‡½æ•°è¿”å›ä¹‹åè¢«æ‰§è¡Œ)ã€‚clean_up() é¢å¤–è°ƒç”¨äº†ä¸€æ¬¡ join()ï¼Œ\nConcurrent Programming: Introduction å…¨å±€çš„å˜é‡ä¼šè¢«å„ä¸ªçº¿ç¨‹å…±äº«ï¼Œæˆ‘ä»¬å¯ä»¥å†™ä¸€ä¸ªç¨‹åºæ¥è¯æ˜è¿™ä¸€ç‚¹ï¼š\n// shm-test.c #include \u0026quot;thread.h\u0026quot; int x; void Thello(int tid) { usleep(tid * 100000); printf(\u0026quot;Hello world from thread #%c\\n\u0026quot;, \u0026quot;0123456789ABCDEF\u0026quot;[x++]); } int main () { x = 1; for (int i = 0; i \u0026lt; 10 ; i++) create(Thello); return 0; } è¯¥ç¨‹åºçš„è¾“å‡ºç»“æœä¸º\nHello world from thread #1 Hello world from thread #2 Hello world from thread #3 Hello world from thread #4 Hello world from thread #5 Hello world from thread #6 Hello world from thread #7 Hello world from thread #8 Hello world from thread #9 Hello world from thread #A å¯ä»¥çœ‹åˆ°ï¼ŒæŸä¸€ä¸ªçº¿ç¨‹å¯¹å…¨å±€å˜é‡ x çš„ä¿®æ”¹åœ¨åˆ«çš„çº¿ç¨‹æ˜¯å¯è§çš„ã€‚\næˆ‘ä»¬å¯ä»¥å†™ä¸€ä¸ªå°ç¨‹åºæ¥æ¢æµ‹æ¯ä¸ªçº¿ç¨‹çš„æ ˆç©ºé—´å¤§å°ï¼š\n// stack-probe.c #include \u0026quot;thread.h\u0026quot; __thread char *base, *cur; // thread-local variables __thread int id; // objdump to see how thread-local variables are implemented __attribute__((noinline)) void set_cur(void *ptr) { cur = ptr; } __attribute__((noinline)) char *get_cur() { return cur; } void stackoverflow(int n) { set_cur(\u0026amp;n); if (n % 1024 == 0) { int sz = base - get_cur(); printf(\u0026quot;Stack size of T%d \u0026gt;= %d KB\\n\u0026quot;, id, sz / 1024); } stackoverflow(n + 1); } void Tprobe(int tid) { id = tid; base = (void *)\u0026amp;tid; stackoverflow(0); } int main() { setbuf(stdout, NULL); for (int i = 0; i \u0026lt; 4; i++) { create(Tprobe); } } è¯¥ä»£ç ä¸­æœ‰ä¸€äº›å€¼å¾—æ³¨æ„çš„ç»†èŠ‚ï¼š\nç¨‹åºçš„ä¸»è¦æ€æƒ³æ˜¯ä½¿ç”¨ä¸€ä¸ªæ­»é€’å½’ï¼Œç”±äºå‡½æ•°çš„å‚æ•°ä½œä¸ºå±€éƒ¨å˜é‡æ€»æ˜¯æ”¾åœ¨æ ˆä¸Šï¼Œæ‰€ä»¥å¯ä»¥é€šè¿‡æŸ¥çœ‹å‚æ•° n çš„åœ°å€æ¥è·å¾—å¤§è‡´çš„æ ˆé¡¶ä½ç½®ã€‚è§¦å‘æ®µé”™è¯¯ä¹‹åï¼Œæ ¹æ®è¾“å‡ºä¿¡æ¯å¤§è‡´åˆ¤æ–­æ ˆçš„å¤§å°ã€‚\nåŠ å…¥äº† __thread å£°æ˜çš„å˜é‡æ˜¯çº¿ç¨‹å±€éƒ¨å˜é‡ (thread-local variables)ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½å•ç‹¬æ‹¥æœ‰çº¿ç¨‹å±€éƒ¨å˜é‡ï¼Œå¯¹çº¿ç¨‹å±€éƒ¨å˜é‡çš„ä¿®æ”¹æ“ä½œå½¼æ­¤äº’ä¸å½±å“ã€‚\n__attribute__((noinline)) å­—æ®µå¯ä»¥ä½¿å‡½æ•°ä¸ä¼šè¢«å…§è”åˆ°å‡½æ•°å†…éƒ¨ï¼Œè¿™æœ‰åŠ©äºæˆ‘ä»¬ä½¿ç”¨ objdump å·¥å…·åæ±‡ç¼–å¯æ‰§è¡Œæ–‡ä»¶ä»¥è§‚æµ‹çº¿ç¨‹å±€éƒ¨å˜é‡çš„å®ç°æ–¹å¼ã€‚stack-probe.o çš„åæ±‡ç¼–ç»“æœä¸­ set_cur() å‡½æ•°çš„æ±‡ç¼–ä»£ç å¦‚ä¸‹ï¼š\n0000000000000196 \u0026lt;set_cur\u0026gt;: 196: f3 0f 1e fa endbr64 19a: 55 push %rbp\t19b: 48 89 e5 mov %rsp,%rbp # åˆ›å»ºæ–°çš„æ ˆå¸§ 19e: 48 89 7d f8 mov %rdi,-0x8(%rbp)\t1a2: 48 8b 45 f8 mov -0x8(%rbp),%rax # å°†ç¬¬ä¸€ä¸ªå‚æ•°çš„å€¼æ”¾å…¥rax 1a6: 64 48 89 04 25 00 00 mov %rax,%fs:0x0 # å°†raxçš„å€¼èµ‹ç»™cur 1ad: 00 00 1af: 90 nop 1b0: 5d pop %rbp 1b1: c3 ret å¯ä»¥çœ‹åˆ° %fs:0x0 ä»£è¡¨çš„å°±æ˜¯çº¿ç¨‹å±€éƒ¨å˜é‡ cur çš„åœ°å€ã€‚%fs æ˜¯ x86-64 çš„ä¸€ä¸ªæ®µå¯„å­˜å™¨ï¼Œä½¿ç”¨ %fs å°†å¼•ç”¨çº¿ç¨‹çš„ glibc TLS (thread local storage)ã€‚è¿™é‡Œçš„åç§»é‡ä¹‹æ‰€ä»¥æ˜¯ 0 æ˜¯å› ä¸ºè¿˜æ²¡æœ‰é‡å®šä½ï¼Œé‡å®šä½ä¹‹åæ¯ä¸ªå˜é‡éƒ½ä¼šæœ‰ä¸€ä¸ªä¸åŒçš„ offsetã€‚\næ ¹æ®ç¨‹åºçš„è¾“å‡ºç»“æœï¼Œå¯ä»¥çœ‹å‡ºæ¯ä¸ªçº¿ç¨‹æ ˆå¤§å°ä¸º 8192K=8Mã€‚\nTip: Unix Philosophy\nç”±äºæœ‰å¤šä¸ªçº¿ç¨‹å¹¶å‘è¾“å‡ºï¼Œè¯¥ç¨‹åºçš„è¾“å‡ºç»“æœéå¸¸æ‚ä¹±ï¼Œä¸ºå¤„ç†ä¹‹å‰å¤§è‡´å¦‚ä¸‹ï¼š\n... Stack size of T1 \u0026gt;= 8128 KB Stack size of T3 \u0026gt;= 8064 KB Stack size of T4 \u0026gt;= 6208 KB Stack size of T2 \u0026gt;= 7616 KB Stack size of T3 \u0026gt;= 8128 KB [1] 46916 segmentation fault (core dumped) æˆ‘ä»¬å¯ä»¥åˆ©ç”¨å‘½ä»¤è¡Œçš„ sort å·¥å…·æ¥æ•´ç†è¾“å‡ºç»“æœã€‚\n./stack-probe | sort -nk 6 å…¶ä¸­å‚æ•° -n è¡¨ç¤ºæ¯”è¾ƒæ—¶å°†å­—ç¬¦ä¸²è½¬æ¢æˆæ•°å€¼è¿›è¡Œæ¯”è¾ƒ (å¦‚æœä¸åŠ è¿™ä¸ªå‚æ•°ï¼Œé‚£äº›ä¹ç™¾å¤šçš„ä¸‰ä½æ•°ä¼šè¢«æ’åœ¨ä½œå)ï¼Œ-k è¡¨ç¤ºé€‰æ‹©ç¬¬å‡ åˆ—è¿›è¡Œæ¯”è¾ƒï¼Œåé¢çš„æ•°å­— 6 æŒ‡å®šäº†æ•°å€¼çš„é‚£ä¸€åˆ—ã€‚\nå¦‚ä½•ä¿®æ”¹çº¿ç¨‹æ ˆçš„å¤§å°ï¼Ÿ\nåœ¨æ‰§è¡Œç¨‹åºå‰ï¼Œä½¿ç”¨å‘½ä»¤ ulimit -s SIZE æ¥ä¿®æ”¹æ ˆå¤§å°ã€‚SIZE çš„å•ä½æ˜¯ KBã€‚ä¿®æ”¹å®Œä¹‹åï¼Œä½¿ç”¨ stack-probe.c ç¨‹åºè¿›è¡Œæ£€æµ‹å¯ä»¥çœ‹åˆ°çº¿ç¨‹æ ˆå¤§å°æ”¹å˜äº†ã€‚\n(æ³¨ï¼šå…³é—­ç»ˆç«¯åè¯¥æ”¹å˜ä¼šå¤±æ•ˆã€‚)\nConcurrent Programming: Atomicity è€ƒè™‘ä»¥ä¸‹ç¨‹åºï¼š\n// sum.c #include \u0026quot;thread.h\u0026quot; #define N 100000000 long sum = 0; void Tsum() { for (int i = 0; i \u0026lt; N; i++) { sum++; } } int main() { create(Tsum); create(Tsum); join(); printf(\u0026quot;sum = %ld\\n\u0026quot;, sum); } ä¸¤ä¸ªçº¿ç¨‹å„å¯¹å…¨å±€å˜é‡ sum è¿›è¡Œ N æ¬¡ +1 æ“ä½œï¼Œç†è®ºä¸Šåº”è¯¥å¾—åˆ°ç»“æœ 200000000ï¼Œä½†è¿è¡Œè¯¥ç¨‹åºæ¯æ¬¡éƒ½ä¼šå¾—åˆ°è¿œå°äº 200000000 çš„å„ä¸ç›¸åŒçš„ç»“æœã€‚å¯¼è‡´è¿™ä¸ªç»“æœçš„åŸå› æ˜¯åŸå­æ€§çš„ä¸§å¤±ï¼šâ€œç¨‹åº (ç”šè‡³æ˜¯ä¸€æ¡æŒ‡ä»¤) ç‹¬å å¤„ç†å™¨è¿è¡Œâ€œçš„åŸºæœ¬å‡è®¾åœ¨ç°ä»£å¤šå¤„ç†å™¨ç³»ç»Ÿä¸Šä¸å†æˆç«‹ã€‚\nTip: Unix Philosophy\næˆ‘ä»¬æƒ³å¤šè§‚æµ‹å‡ æ¬¡ sum.c ç¨‹åºçš„è¾“å‡ºï¼Œä½†é‡å¤æ‰§è¡Œ ./sum å¤ªä½æ•ˆäº†ã€‚å¥½çš„æ–¹æ³•æ˜¯ç°åœºå†™ä¸€ä¸ª shell è„šæœ¬ï¼š\nwhile true; do ./sum; done æ³¨ï¼šåœ¨ä¸€è¡Œå†…å†™ shell è„šæœ¬éœ€è¦æ³¨æ„ä¸åŒè¯­å¥ä¹‹é—´è¦ç”¨åˆ†å·éš”å¼€ã€‚\nè€ƒå¯Ÿ Tsum() å‡½æ•°çš„æ±‡ç¼–ç»“æœï¼Œå…¶ä¸­ sum++ è¿™æ¡æ ¸å¿ƒè¯­å¥è¢«ç¼–è¯‘æˆäº† 3 æ¡æ±‡ç¼–æŒ‡ä»¤ï¼š\n1a7: 48 8b 05 00 00 00 00 mov 0x0(%rip),%rax # 1ae \u0026lt;Tsum+0x18\u0026gt; 1ae: 48 83 c0 01 add $0x1,%rax 1b2: 48 89 05 00 00 00 00 mov %rax,0x0(%rip) # 1b9 \u0026lt;Tsum+0x23\u0026gt; 0x0(%rip) æ˜¯å˜é‡ sum çš„åœ°å€ï¼Œç”±äºè¿˜æ²¡æœ‰é‡å®šä½ï¼Œæ‰€ä»¥åç§»é‡è¿˜æ²¡æœ‰å¡«å…¥ã€‚sum çš„å€¼ä¼šå…ˆè¢«æ”¾å…¥ %raxï¼Œç„¶å %rax +1ï¼Œç„¶å %rax çš„å€¼è¢«å†™å› sumã€‚å‡è®¾å½“å‰ä¸¤ä¸ªçº¿ç¨‹åœ¨å¹¶å‘åœ°æ‰§è¡Œè¿™æ®µä»£ç ï¼Œè½®æµæ‰§è¡Œï¼Œåˆ™æ‰§è¡Œæƒ…å†µå¦‚ä¸‹è¡¨ (è®¾ sum çš„åˆå€¼ä¸º s) ï¼š\nThread1 Thread2 1 %rax in CPU1 = s %rax in CPU2 = s 2 %rax in CPU1 = s+1 %rax in CPU2 = s+1 3 sum = s+1 sum = s+1 å¯ä»¥çœ‹åˆ° +1 æ“ä½œè¢«åæ‰äº†ä¸€æ¬¡ã€‚ä¸¤ä¸ªçº¿ç¨‹åœ¨å¹¶å‘åœ°å¯¹åŒä¸€ä¸ªå†…å­˜åœ°å€è¿›è¡Œè¯»å†™ï¼Œæ‰“ç ´äº† invariantï¼Œä»è€Œå¯¼è‡´å¹¶å‘ bugã€‚\nè§£å†³è¿™ä¸ªé—®é¢˜çš„æ–¹æ³•æ˜¯ç”¨é”å°†è¿™å‡ å¥ä»£ç åŒ…è£¹èµ·æ¥ï¼Œå¼ºåˆ¶ä¸¤ä¸ªçº¿ç¨‹ä¸²è¡Œåœ°æ‰§è¡Œã€‚\nConcurrent Programming: Order å¦‚æœå¯¹ sum.c è¿›è¡Œ -O1 å’Œ -O2 ä¼˜åŒ–ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ä¸åŒçš„ç»“æœï¼š\nåœ¨ -O1 ä¼˜åŒ–ä¸‹ï¼Œç¼–è¯‘å™¨ä¼šåˆ†æå‡ºå‡½æ•°çš„ç›®çš„æ˜¯ sum+=Nï¼Œå¹¶ä½¿ç”¨ Reg = sum, Reg += N, sum = Reg ä¸‰æ¡æŒ‡ä»¤å®ç°ã€‚å› ä¸º race conditionï¼Œä¸¤æ¬¡ sum = Reg é‡å¤å†™å…¥ï¼Œæ‰€ä»¥ -O1 ä¼˜åŒ–ä¸‹è¾“å‡ºç»“æœä¸º 100000000ã€‚\n-O2 ä¼˜åŒ–æ›´ä¸ºå½»åº•ï¼Œç›´æ¥ä½¿ç”¨ä¸€æ¡æŒ‡ä»¤\n48 81 05 01 2e 00 00 addq $0x5f5e100, 0x0(%rip) æ¥å®Œæˆã€‚è‡³å°‘â€œçœ‹ä¸Šå»â€è·å¾—äº†æ­£ç¡®çš„ç»“æœ 200000000ã€‚(Visibility ä¸€èŠ‚ä¼šå†åˆ†æè¿™ç§æƒ…å†µ)\nå¦å¤–ä¸€ä¸ªä¾‹å­æ˜¯ï¼š\nextern int done; int main () { while (!done); } çš„æ±‡ç¼–ä»£ç æ˜¯ (-O2 ä¼˜åŒ–)\n0000000000000000 \u0026lt;main\u0026gt;: 0: f3 0f 1e fa endbr64 4: 8b 05 00 00 00 00 mov 0x0(%rip),%eax # a \u0026lt;main+0xa\u0026gt; a: 85 c0 test %eax,%eax c: 75 02 jne 10 \u0026lt;main+0x10\u0026gt; e: eb fe jmp e \u0026lt;main+0xe\u0026gt; 10: 31 c0 xor %eax,%eax 12: c3 ret å®ƒå®é™…ä¸Šè¢«ç¿»è¯‘æˆäº†\nif (!done) while(1); ç¼–è¯‘å™¨æ— æ³•è€ƒè™‘åˆ°å¤šçº¿ç¨‹çš„å¯èƒ½ï¼Œå®ƒè®¤ä¸ºåœ¨æ‰§è¡Œ while (!done) çš„è¿‡ç¨‹ä¸­å½“å‰ç¨‹åºæ˜¯ä¸å¯èƒ½è¢«æ‰“æ–­çš„ã€‚ä»çŠ¶æ€åŠçš„è§’åº¦æ¥è€ƒè™‘ï¼Œç¼–è¯‘å™¨åªè¦ä¿è¯æœ€ç»ˆç»“æœçš„ä¸€è‡´æ€§ (è¯­ä¹‰ä¸€è‡´æ€§)ï¼Œæ˜¯å¯ä»¥éšæ„ä¿®æ”¹æŒ‡ä»¤çš„é¡ºåº (ç”šè‡³æ˜¯æŒ‡ä»¤æœ¬èº«) çš„ï¼Œè¿™ç»™å¹¶å‘ç¼–ç¨‹å¸¦æ¥äº†å›°éš¾ã€‚\nä½¿ä¸Šè¿°ä»£ç èƒ½å¤Ÿè¢«æ­£ç¡®åœ°ç¼–è¯‘ï¼Œä¸€ç§æ–¹æ³•æ˜¯åœ¨å¾ªç¯ä¸­åŠ ä¸Š memory barrierï¼š\nwhile (!done) asm volatile(\u0026quot;\u0026quot; ::: \u0026quot;memory\u0026quot;); memory barrier ç›¸å½“äºå‘Šè¯‰ç¼–è¯‘å™¨ï¼šè¿™é‡Œå¯èƒ½å‘ç”Ÿä»»æ„çš„å¯¹å†…å­˜çš„ä¿®æ”¹ï¼Œæ‰€ä»¥ç¼–è¯‘å™¨ä¸å†æœ‰å¯¹ done çš„å€¼ä¿æŒä¸å˜çš„å‡è®¾ã€‚\nå¦ä¸€ç§æ–¹æ³•æ˜¯\nextern int volatile done; å®ƒä¹Ÿå¯ä»¥ä¿è¯ C è¯­ä¹‰å’Œæ±‡ç¼–è¯­ä¹‰çš„ä¸€è‡´æ€§ã€‚\nConcurrent Programming: Visibility // mem-ordering.c #include \u0026quot;thread.h\u0026quot; int x = 0, y = 0; atomic_int flag; #define FLAG atomic_load(\u0026amp;flag) #define FLAG_XOR(val) atomic_fetch_xor(\u0026amp;flag, val) #define WAIT_FOR(cond) while (!(cond)) ; __attribute__((noinline)) void write_x_read_y() { int y_val; asm volatile( \u0026quot;movl $1, %0;\u0026quot; // x = 1 \u0026quot;movl %2, %1;\u0026quot; // y_val = y : \u0026quot;=m\u0026quot;(x), \u0026quot;=r\u0026quot;(y_val) : \u0026quot;m\u0026quot;(y) ); printf(\u0026quot;%d \u0026quot;, y_val); } __attribute__((noinline)) void write_y_read_x() { int x_val; asm volatile( \u0026quot;movl $1, %0;\u0026quot; // y = 1 \u0026quot;movl %2, %1;\u0026quot; // x_val = x : \u0026quot;=m\u0026quot;(y), \u0026quot;=r\u0026quot;(x_val) : \u0026quot;m\u0026quot;(x) ); printf(\u0026quot;%d \u0026quot;, x_val); } void T1(int id) { while (1) { WAIT_FOR((FLAG \u0026amp; 1)); write_x_read_y(); FLAG_XOR(1); } } void T2() { while (1) { WAIT_FOR((FLAG \u0026amp; 2)); write_y_read_x(); FLAG_XOR(2); } } void Tsync() { while (1) { x = y = 0; __sync_synchronize(); // full barrier usleep(1); // + delay assert(FLAG == 0); FLAG_XOR(3); // T1 and T2 clear 0/1-bit, respectively WAIT_FOR(FLAG == 0); printf(\u0026quot;\\n\u0026quot;); fflush(stdout); } } int main() { create(T1); create(T2); create(Tsync); } å¯¹è¯¥ç¨‹åºçš„ä¸€äº›å…³é”®ä»£ç è§£è¯»å¦‚ä¸‹ï¼š\nTsync æ˜¯ä¸€ä¸ªæ§åˆ¶çº¿ç¨‹ã€‚å®ƒè´Ÿè´£å°†ä¸€ä¸ªå¼€å…³å˜é‡ flag çš„ç¬¬ä¸€ä½å’Œç¬¬äºŒä½æ‹‰é«˜ã€‚flag çš„ç¬¬ä¸€ä½ä¾› T1 çº¿ç¨‹ä½¿ç”¨ï¼Œç¬¬äºŒä½ä¾› T2 çº¿ç¨‹ä½¿ç”¨ã€‚ç­‰å¾… T1 å’Œ T2 çº¿ç¨‹å‡å®Œæˆæ“ä½œåï¼ŒTsync ä¼šè¿›è¡Œä¸‹ä¸€æ¬¡å¾ªç¯ï¼ŒTsync çš„è®¾ç½®ä¿è¯äº† T1 å’Œ T2 æ€»æ˜¯èƒ½â€åŒæ—¶â€œå¼€å§‹è¿è¡Œã€‚ T1 å’Œ T2 çº¿ç¨‹ä¼šå†™å…¥ x/y å¹¶è¯»å– y/xï¼Œå®Œæˆæ“ä½œåå°† flag çš„å¯¹åº”ä½æ‹‰ä½ã€‚æˆ‘ä»¬åœ¨å…§è”æ±‡ç¼–ä»£ç ä¸­å·²ç»åŠ å…¥äº† memory fence ä¿è¯ç¼–è¯‘å™¨ä¼šæŒ‰ç…§é¡ºåºç¼–è¯‘æˆ‘ä»¬çš„ä»£ç ã€‚ æŒ‰ç†æ¥è¯´ï¼Œæ ¹æ®æ‰§è¡Œé¡ºåºçš„ä¸åŒï¼Œæˆ‘ä»¬å¯èƒ½ä¼šè·å¾— x=0 y=1ï¼Œx=1 y=0ï¼Œx=1 y=1 ä¸‰ç§ç»“æœï¼Œä½†ä¸å¯èƒ½è·å¾— x=0 y=0ã€‚ä½†äº‹å®ä¸Šè¾“å‡ºç»“æœä¸­ç¡®å®æœ‰ (0,0)ã€‚æˆ‘ä»¬è¿˜å¯ä»¥è¿è¡Œå¾ˆå¤šæ¬¡ï¼Œç„¶åç»Ÿè®¡æ¯ç§è¾“å‡ºå‡ºç°çš„é¢‘æ•°ã€‚è¿™é‡Œå†æ¬¡åˆ©ç”¨äº† Unix Philosophy:\n./mem-ordering | head -n 100000 | sort | uniq -c head å‘½ä»¤ç”¨äºå–å¼€å¤´çš„è‹¥å¹²è¡Œï¼Œç”¨ sort æ’åºåï¼Œuniq -c å¯ä»¥å»é‡å¹¶ç»Ÿè®¡æ¯ç§è¾“å‡ºå‡ºç°çš„æ¬¡æ•°ã€‚å¯ä»¥çœ‹åˆ° (0,0) æ˜¯æœ€å¤šçš„ï¼Œ(0,1) æ¯” (1,0) ç¨å¤šä¸€äº› (è¿™æ˜¯ç”±äºä¸¤ä¸ªçº¿ç¨‹çš„ä¸å¯¹ç§°æ€§)ï¼Œ(1,1) æ²¡æœ‰ã€‚\nç°ä»£å¤„ç†å™¨ä¼šå°†æŒ‡ä»¤åˆ†è§£æˆæ›´å°çš„â€œå¾®æŒ‡ä»¤â€ $\\mu op$ï¼Œè¿™æ„å‘³ç€å¤„ç†å™¨ä¹Ÿæ˜¯ä¸€ä¸ªâ€œç¼–è¯‘å™¨â€ã€‚å¤„ç†å™¨ä¼šç»´æŠ¤ä¸€ä¸ªå¾®æŒ‡ä»¤æ± ï¼Œå…¶ä¸­è®°å½•äº†å¾®æŒ‡ä»¤ä¹‹é—´çš„ä¾èµ–å…³ç³»ä»¥åŠå‡ºç°é¡ºåºå…³ç³»ï¼Œå¹¶åœ¨ä¸å½±å“ eventual memory consistency çš„æƒ…å†µä¸‹è°ƒæ•´å¾®æŒ‡ä»¤çš„æ‰§è¡Œé¡ºåºï¼Œå¤šä¸ªå¤„ç†å™¨ä¹‹é—´çš„å³æ—¶å¯è§æ€§ä¸§å¤±ã€‚\nåœ¨æœ¬ä¾‹ä¸­ï¼Œç”±äºå¯¹ x å˜é‡åœ°å€è¯»å–çš„ cache missï¼Œå¤„ç†å™¨å¯èƒ½ä¼šå…ˆå–å‡ºä¸‹ä¸€æ¡æŒ‡ä»¤çš„ $\\mu op$ æ¥åšï¼š\n# \u0026lt;-----------+ movl $1, (x) # | movl (y), %eax # --+ å› æ­¤ï¼Œè¾“å‡ºç»“æœä¸­å‡ºç°äº† $x=y=0$ çš„æƒ…å†µã€‚\nè§£å†³è¿™ä¸ªé—®é¢˜åªèƒ½ä»ç¡¬ä»¶çš„è§’åº¦å…¥æ‰‹ã€‚æ¯”å¦‚å¯ä»¥ä½¿ç”¨ full barrier __sync_synchronize() ï¼Œ(åœ¨å…§è”æ±‡ç¼–ä¸­ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨ mfence æŒ‡ä»¤)ï¼Œæˆ–è€…ä½¿ç”¨åŸå­æŒ‡ä»¤ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"7a23288844d625945a046b327bd08bbd","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec03/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec03/","section":"notes","summary":"å¹¶å‘ï¼šä¸€ä¸ªè®¡ç®—æœºç¨‹åºè¢«åˆ†æˆäº†è‹¥å¹²ä¸ªéƒ¨åˆ†ï¼Œåœ¨ä¸æ”¹å˜ç¨‹åºæœ€ç»ˆè¿è¡Œç»“æœçš„æƒ…å†µä¸‹ï¼Œè¿™äº›éƒ¨åˆ†è¢«ä¹±åºåœ°æ‰§è¡Œã€‚å¹¶å‘æ‰§è¡Œçš„å¤šä¸ªéƒ¨åˆ†ä¼šå…±äº«èµ„æºã€‚\nState Machine åœ¨å•çº¿ç¨‹è§†è§’ä¸­ï¼ŒC ç¨‹åºçš„çŠ¶æ€æœºåŒ…æ‹¬å…¨å±€å˜é‡ï¼Œå †åŒºï¼Œæ ˆå¸§åˆ—è¡¨ç­‰ã€‚å…¨å±€å˜é‡å’Œå †åŒºçš„å†…å®¹æ˜¯å…¨å±€çš„ï¼Œæ˜¯æ‰€æœ‰å‡½æ•°å…±äº«çš„ï¼Œç†åº”ä½œä¸ºå…±äº«èµ„æºï¼›æ ˆå¸§ä¸­çš„å˜é‡éƒ½æ˜¯å±€éƒ¨å˜é‡ï¼Œæ ˆå¸§ä¸æ ˆå¸§ä¹‹é—´ç‹¬ç«‹æ€§è¾ƒå¼ºï¼Œå¯ä»¥äº¤ç»™å¤šä¸ªçº¿ç¨‹ã€‚\nå¤šçº¿ç¨‹è§†è§’ä¸‹çš„çŠ¶æ€æœºï¼š\nå…¨å±€å˜é‡ï¼Œå †åŒºç­‰å…¨å±€å…±äº«èµ„æºï¼› è‹¥å¹²ä¸ªæ ˆå¸§é“¾ï¼Œæ¯æ¡æ ˆå¸§é“¾å±äºä¸€ä¸ªçº¿ç¨‹ã€‚ åœ¨å¹¶å‘ç¨‹åºä¸­ï¼Œæ¯ä¸€æ­¥çš„ç»“æœéƒ½æ˜¯ non-deterministic çš„ï¼Œå®ƒçš„çŠ¶æ€è½¬ç§»å›¾æ˜¯é•¿æˆè¿™æ ·çš„ï¼š\nstateDiagram state1: (g, T1, T2) state1 --\u0026gt; state2: çº¿ç¨‹T1æ‰§è¡Œ state1 --\u0026gt; state3: çº¿ç¨‹T2æ‰§è¡Œ state2: (g',T1',T2) state3: (g',T1,T2') state2 --\u0026gt; state4: çº¿ç¨‹T1æ‰§è¡Œ state2 --\u0026gt; state5: çº¿ç¨‹T2æ‰§è¡Œ state3 --\u0026gt; state6: çº¿ç¨‹T1æ‰§è¡Œ state3 --\u0026gt; state7: çº¿ç¨‹T2æ‰§è¡Œ state4: â€¦â€¦ state5: â€¦â€¦ state6: â€¦â€¦ state7: â€¦â€¦ Simplified Thread API // thread.","tags":null,"title":"Lecture 03: Multiprocessor Programming","type":"docs"},{"authors":null,"categories":null,"content":"äº’æ–¥ (mutual exclusion)ï¼šä¿è¯ä¸¤ä¸ªçº¿ç¨‹ä¸èƒ½åŒæ—¶ (å¹¶å‘) æ‰§è¡Œä¸€æ®µä»£ç ã€‚\nå¯¹äº sum.c ï¼Œæˆ‘ä»¬å¸Œæœ›æ·»åŠ ä¸¤ä¸ªé­”æ³•å‡½æ•° lock() å’Œ unlock()ï¼Œä½¿å¾—é­”æ³•å‡½æ•°ä¸­é—´çš„ä»£ç å…·æœ‰äº’æ–¥æ€§ï¼š\nvoid Tsum() { for (int i = 0; i \u0026lt; N; i++) { +\tlock(); sum++; +\tunlock(); } } ä¸€ä¸ªå¤±è´¥çš„å°è¯•ï¼š\n#define LOCK 1 #define UNLOCK 0 void critical_section() { retry: if (locked != UNLOCK) //* goto entry; locked = LOCK; //** // critical section locked = UNLOCK; } ä»çŠ¶æ€æœºçš„è§’åº¦ï¼š\nstateDiagram state1: T1-L*, T2-L* state1 --\u0026gt; state2: çº¿ç¨‹T1æ‰§è¡Œ state1 --\u0026gt; state3: çº¿ç¨‹T2æ‰§è¡Œ state3: â€¦â€¦ state2: T1-L**, T2-L* state2 --\u0026gt; state4: çº¿ç¨‹T1æ‰§è¡Œ state2 --\u0026gt; state5: çº¿ç¨‹T2æ‰§è¡Œ state4: â€¦â€¦ state5: T1-L**, T2-L** å¯ä»¥çœ‹åˆ°å­˜åœ¨ä¸€ä¸ªçŠ¶æ€ï¼ŒT1 å’Œ T2 åŒæ—¶è·å¾—äº†é”ã€‚è¯¥æ–¹æ³•å¤±è´¥çš„æ ¹æœ¬åŸå› æ˜¯ï¼šæˆ‘ä»¬è¯»é”çŠ¶æ€çš„æ“ä½œå’Œå†™é”çŠ¶æ€çš„æ“ä½œæ— æ³•åŸå­åœ°æ‰§è¡Œã€‚\nPeterson Algorithm ç†è§£å¹¶å‘çš„æœ€å¥½æ–¹æ³•å°±æ˜¯ç”¨ç‰©ç†ä¸–ç•Œä¸­çš„ä¸œè¥¿ä½œç±»æ¯”ï¼š\nå¯¹å…±äº«å†…å­˜çš„å†™ï¼šå¾€é»‘æ¿ä¸Šè´´ä¾¿ç­¾æ¡ å¯¹å…±äº«å†…å­˜çš„è¯»ï¼šçœ‹é»‘æ¿ (å…¶å®ä¸åŒäºäººç±»ï¼Œè®¡ç®—æœºçš„â€œè¯»â€åªèƒ½çœ‹åˆ°ä¸€ä¸ªâ€œå†å²çŠ¶æ€â€) å‡è®¾ Alice å’Œ Bob æƒ³ä¸Šå•æ‰€ï¼Œä¸ºäº†ä¸ä¸€èµ·è¿›å…¥å•æ‰€ï¼Œä»–ä»¬åˆ¶å®šäº†å¦‚ä¸‹åè®®ï¼š\nAlice æƒ³ä¸Šå•æ‰€ï¼Œäºæ˜¯ä¸¾èµ·äº†è‡ªå·±çš„æ——å­ (step1ï¼Œç›¸å½“äº STORE ä¸€ä¸ªå…±äº«çš„å˜é‡)ï¼Œç„¶åå°† Bob (å¯¹æ–¹) çš„åå­—å†™åœ¨å•æ‰€é—¨ä¸Š (step2ï¼Œä¹Ÿç›¸å½“äº STORE ä¸€ä¸ªå…±äº«å˜é‡)ï¼›å¦‚æœ Bob æƒ³ä¸Šå•æ‰€ä¹Ÿæ˜¯åŒç†ã€‚æ³¨æ„å•æ‰€é—¨ä¸Šçš„åå­—æ˜¯å¯ä»¥è¦†ç›–çš„ã€‚ Alice æ£€æŸ¥é—¨ä¸Šçš„åå­—å’Œå•æ‰€ (step3)ï¼ŒAlice å¯ä»¥è¿›å…¥å•æ‰€å½“ä¸”ä»…å½“ Bob æ²¡æœ‰ä¸¾æ——å­ï¼Œæˆ–è€…é—¨ä¸Šçš„åå­—æ˜¯è‡ªå·±çš„ã€‚ Alice ä¸Šå®Œå•æ‰€åï¼ŒæŠŠè‡ªå·±çš„æ——å­æ”¾ä¸‹æ¥ (step4)ã€‚ æˆ‘ä»¬è®¨è®ºå‡ ç§æƒ…å†µï¼š\nAlice æ£€æŸ¥çš„æ—¶å€™ï¼Œå¦‚æœ Bob æ²¡ä¸¾æ——å­ï¼Œè¯´æ˜ Bob è¿˜ä¸æƒ³ä¸Šå•æ‰€ï¼Œé‚£ Alice å¯ä»¥ä¸Šå•æ‰€ã€‚ å¦‚æœ Bob ä¹Ÿä¸¾æ——å­äº†ï¼Œé‚£ç»“æœæ˜¯ï¼šå…ˆä¸¾æ——å­çš„äººå¯ä»¥å…ˆè¿›å…¥å•æ‰€ï¼Œå› ä¸ºåä¸¾æ——å­çš„äººä¼šæŠŠå…ˆä¸¾æ——å­çš„äººçš„åå­—è´´åœ¨é—¨ä¸Šï¼Œè¦†ç›–äº†å…ˆè´´çš„äººçš„å†…å®¹ã€‚ â€¦â€¦ ä¸€ä¸ªå®Œå¤‡çš„è¯æ˜æ–¹æ³•æ˜¯ç”»çŠ¶æ€æœºã€‚æˆ‘ä»¬è®¾ç½®çŠ¶æ€æœº $(PC_1, PC_2, x, y, turn,status)$ï¼Œå…­ä¸ªçŠ¶æ€åˆ†åˆ«è¡¨ç¤º T1/T2 æ‰§è¡Œåˆ°ç¬¬å‡ è¡Œï¼ŒT1/T2 çš„æ——å­æœ‰æ²¡æœ‰ä¸¾èµ·æ¥ï¼Œå½“å‰å•æ‰€é—¨ä¸Šå†™çš„æ˜¯è°çš„åå­—ï¼Œä»¥åŠå½“å‰å•æ‰€çŠ¶æ€ã€‚\næˆ‘ä»¬è¿˜å¯ä»¥å†™ä¸€ä¸ªå°ç¨‹åºéªŒè¯ Petersonï¼š\n#define BARRIER __sync_synchronize()\tvoid critical_section() { long cnt = atomic_fetch_add(\u0026amp;count, 1); int i = atomic_fetch_add(\u0026amp;nested, 1) + 1; if (i != 1) { printf(\u0026quot;%d threads in the critical section @ count=%ld\\n\u0026quot;, i, cnt); assert(0); } atomic_fetch_add(\u0026amp;nested, -1); } int volatile x = 0, y = 0, turn; void TA() { while (1) { x = 1; BARRIER; turn = B; BARRIER; // \u0026lt;- this is critcal for x86 while (1) { if (!y) break; BARRIER; if (turn != B) break; BARRIER; } critical_section(); x = 0; BARRIER; } } void TB() { while (1) { y = 1; BARRIER; turn = A; BARRIER; while (1) { if (!x) break; BARRIER; if (turn != A) break; BARRIER; } critical_section(); y = 0; BARRIER; } } åœ¨ critical_section() ä¸­ï¼Œä»£ç ä¸»è¦åšçš„äº‹æƒ…æ˜¯æ“ä½œä¸€ä¸ªå…±äº«å˜é‡ï¼Œå¦‚æœæŸä¸ªæ—¶åˆ» nested == 2ï¼Œè¯´æ˜ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶è¿›å…¥äº†ä¸´ç•ŒåŒºåŸŸï¼Œåˆ™æŠ¥é”™ã€‚\nç”±äºç°ä»£ç¼–è¯‘å™¨å’Œå¤šå¤„ç†å™¨ä¼šè°ƒæ•´è¯­å¥é¡ºåº/ä¹±åºæ‰§è¡Œâ€¦â€¦æ‰€ä»¥æˆ‘ä»¬åœ¨æ¯æ¡è¯­å¥åé¢æ·»åŠ ä¸€æ¡ __sync_synchronize() æ¥ä¿è¯ç¼–è¯‘æŒ‰ç…§é¡ºåºè¿›è¡Œï¼Œä¸”å¤šå¤„ç†å™¨ä¹‹é—´å…·æœ‰å¯è§æ€§ã€‚äº‹å®è¯æ˜ï¼Œå¦‚æœå»æ‰ BARRIER ä¼šå‘ç”Ÿé”™è¯¯ã€‚\nModel Checker æˆ‘ä»¬å¸Œæœ›ç”¨ç¨‹åºè‡ªåŠ¨ç”»å‡ºçŠ¶æ€æœºã€‚ model-checker.py å¸®åŠ©æˆ‘ä»¬å®Œæˆäº†è¿™é¡¹å·¥ä½œï¼Œå…¶ä¸­ç”¨åˆ°çš„ python è¯­è¨€æœºåˆ¶è¾ƒå¤šï¼Œæš‚æ—¶ç•™å‘ã€‚æˆ‘ä»¬å¯ä»¥ç”¨ model-checker.py ä¸­ç¼–å†™çš„è£…é¥°å™¨æ¥ç¼–å†™å¤šä¸ªçº¿ç¨‹ï¼Œ peterson-flag.py æ˜¯ä¸€ä¸ªç¤ºä¾‹ã€‚ä½¿ç”¨å‘½ä»¤ python3 model-checker.py xxx.py å¯ä»¥è¾“å‡ºçŠ¶æ€æœºçš„æ‰€æœ‰èŠ‚ç‚¹å’Œè½¬ç§»å…³ç³»ã€‚\nmodel-checker.py ä¸»è¦åˆ©ç”¨äº† python generator çš„æœºåˆ¶æ¥å¿«é€Ÿè·å¾—è¿›ç¨‹çš„çŠ¶æ€æœºã€‚\ndef numbers(init=0, step=1): n = init while True: n += step yield n g = numbers() h = numbers(100, 200) print(g, h) print(g.__next__()) print(g.__next__()) print(h.__next__()) print(g.__next__()) print(h.__next__()) è¯¥ç¨‹åºè¾“å‡ºç»“æœä¸º\n\u0026lt;generator object numbers at 0x7f0a75b4fcf0\u0026gt; \u0026lt;generator object numbers at 0x7f0a759f9ba0\u0026gt; 1 2 300 3 500 è™½ç„¶ numbers() é‡Œé¢æ˜¯ä¸€ä¸ªæ­»å¾ªç¯ï¼Œä½†æ‰§è¡Œ numbers() è¿˜æ˜¯å¯ä»¥é€€å‡ºï¼Œè¿™å¾—ç›Šäº yield è¯­å¥ï¼Œyield çš„åŠŸèƒ½ç±»ä¼¼äºæ“ä½œç³»ç»Ÿçš„è°ƒåº¦ï¼Œå®ƒä¼šä¸»åŠ¨è®©å‡ºæ‰§è¡Œæµã€‚g.__next__() è¯­å¥å¯ä»¥ä»è¢«æ‰“æ–­å¤„é‡æ–°è¿›å…¥ï¼Œç»§ç»­æ‰§è¡Œå‡½æ•°ç›´åˆ°é‡åˆ°ä¸‹ä¸€æ¬¡ yieldã€‚å¦‚æœæˆ‘ä»¬åœ¨æ¯ä¸€æ¡è¯­å¥åé¢éƒ½åŠ ä¸Šä¸€ä¸ª yieldï¼Œè®© yield åé¢è¿”å›æ‰€æœ‰çš„çº¿ç¨‹å±€éƒ¨å˜é‡ï¼Œæˆ‘ä»¬å°±è·å¾—äº†å‡½æ•°æ¯æ‰§è¡Œä¸€æ­¥ä¹‹åçš„çŠ¶æ€æœºã€‚\nModel checker å°†éªŒè¯ç¨‹åºæ­£ç¡®æ€§çš„é—®é¢˜è½¬åŒ–æˆäº†ä¸€ä¸ªå›¾è®ºé—®é¢˜ï¼š\nSafety (çº¿ç¨‹æ˜¯å¦äº’æ–¥)ï¼šä»åˆå§‹çŠ¶æ€å‡ºå‘ï¼Œæ˜¯å¦å­˜åœ¨åˆ°çº¢è‰² (äº’æ–¥å¤±è´¥) èŠ‚ç‚¹çš„è·¯å¾„ï¼Ÿ\nå›¾æœç´¢\nLivenessï¼šæ˜¯å¦ä»ä»»æ„é»‘è‰² (æ²¡æœ‰äººæ‰§è¡Œä¸´ç•ŒåŒºåŸŸä»£ç ) çŠ¶æ€å‡ºå‘ï¼Œæ€»èƒ½åœ¨æœ‰é™æ­¥å†…åˆ°è¾¾è“è‰²/ç»¿è‰² (æœ‰ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œä¸´ç•ŒåŒºåŸŸä»£ç ) èŠ‚ç‚¹ï¼Ÿ\nè¿™ç­‰ä»·äºåªè€ƒè™‘å›¾ä¸­çš„é»‘è‰²èŠ‚ç‚¹ï¼Œæ˜¯å¦å­˜åœ¨ç¯ã€‚åªè¦å¯¹é»‘è‰²èŠ‚ç‚¹çš„å¯¼å‡ºå­å›¾æ±‚ SCC å³å¯ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"e50f771fc8fdd16b707b577f3e419f58","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec04/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec04/","section":"notes","summary":"äº’æ–¥ (mutual exclusion)ï¼šä¿è¯ä¸¤ä¸ªçº¿ç¨‹ä¸èƒ½åŒæ—¶ (å¹¶å‘) æ‰§è¡Œä¸€æ®µä»£ç ã€‚\nå¯¹äº sum.c ï¼Œæˆ‘ä»¬å¸Œæœ›æ·»åŠ ä¸¤ä¸ªé­”æ³•å‡½æ•° lock() å’Œ unlock()ï¼Œä½¿å¾—é­”æ³•å‡½æ•°ä¸­é—´çš„ä»£ç å…·æœ‰äº’æ–¥æ€§ï¼š\nvoid Tsum() { for (int i = 0; i \u0026lt; N; i++) { +\tlock(); sum++; +\tunlock(); } } ä¸€ä¸ªå¤±è´¥çš„å°è¯•ï¼š","tags":null,"title":"Lecture 04: Understanding Concurrent Programs","type":"docs"},{"authors":null,"categories":null,"content":"ä» high level æ¥çœ‹ï¼Œæˆ‘ä»¬å¸Œæœ›å®ç°å¦‚ä¸‹çš„ç»“æ„ä½“å’Œ APIï¼š\ntypdef struct { ... }lock; void lock(lock *lk); void unlock(lock *lk); è‹¥ lock() å‡½æ•°è¿”å›ï¼Œè¯´æ˜è·å¾—äº†è¿™ä¸ªé”ï¼Œåˆ«çš„è¿›ç¨‹ä¼šåœåœ¨ lock() é‡Œç›´åˆ°è·å¾—é”çš„äººè°ƒç”¨äº† unlock()ã€‚\nå®ç°äº’æ–¥çš„æ ¹æœ¬å›°éš¾ï¼šä¸èƒ½åŒæ—¶è¯»å†™å…±äº«å†…å­˜ã€‚\nload çš„æ—¶å€™ä¸èƒ½ storeï¼Œä¸”çœ‹å®Œä¹‹åçœ¼ç›ç«‹åˆ»é—­ä¸Šï¼Œçœ‹åˆ°çš„éƒ½æ˜¯è¿‡å»çš„ä¸œè¥¿ï¼› store çš„æ—¶å€™ä¸èƒ½ loadï¼Œè´´å­—æ¡çš„æ—¶å€™ä¸çŸ¥é“è¦†ç›–äº†ä»€ä¹ˆã€‚ Spin Lock â€œè§£å†³ä¸€ä¸ªé—®é¢˜æœ‰ä¸¤ç§æ–¹æ³•ï¼šä¸€ä¸ªæ˜¯åˆ†æé—®é¢˜ã€æå‡ºç®—æ³•ã€å®ç°è§£å†³ï¼Œä¸€ä¸ªæ˜¯è§£å†³æå‡ºé—®é¢˜çš„äººã€‚â€œ â€”â€” jyy\næˆ‘ä»¬å¸Œæœ›ç¡¬ä»¶æ”¯æŒä¸€æ¡â€œç¬é—´å®Œæˆè¯»å’Œå†™â€çš„æŒ‡ä»¤ï¼šâ€œè¯·æ‰€æœ‰äººé—­çœ¼ï¼Œç„¶åæˆ‘çå¼€çœ¼çœ‹ä¸€çœ¼ï¼Œå¹¶åšä¸€ä¸ªæ“ä½œ\u0026quot;ã€‚\nx86: Lock Prefix ä»¥ lock ä¸ºå‰ç¼€çš„æŒ‡ä»¤æ”¯æŒåŸå­æ“ä½œã€‚\n// sum-atomic.c #include \u0026quot;thread.h\u0026quot; #define N 100000000 long sum = 0; void Tsum() { for (int i = 0; i \u0026lt; N; i++) { asm volatile(\u0026quot;lock addq $1, %0\u0026quot;: \u0026quot;+m\u0026quot;(sum)); } } int main() { create(Tsum); create(Tsum); join(); printf(\u0026quot;sum = %ld\\n\u0026quot;, sum); } ç”±äºè¿™é‡Œçš„ +1 æ“ä½œä½¿ç”¨äº†åŸå­æŒ‡ä»¤ï¼Œæ‰€ä»¥ç¨‹åºæ€»èƒ½å¾—åˆ° 2N çš„è¾“å‡ºã€‚\næ­¤å¤–ï¼Œä¸€æ¡éå¸¸å¥½ç”¨çš„åŸå­æŒ‡ä»¤æ˜¯ xchgï¼Œå®ƒå¯ä»¥åŸå­åœ°å°†ä¸€ä¸ªæ•°å€¼å’Œä¸€ä¸ªå†…å­˜åœ°å€ä¸Šçš„å€¼äº¤æ¢ã€‚ç”¨ C è¯­è¨€å°è£…åçš„å½¢å¼å¯ä»¥æ˜¯ï¼š\nint xchg(volatile int *addr, int newval) { int result; asm volatile (\u0026quot;lock xchg %0, %1\u0026quot; : \u0026quot;+m\u0026quot;(*addr), \u0026quot;=a\u0026quot;(result) : \u0026quot;1\u0026quot;(newval)); //xchgé»˜è®¤åŸå­ï¼Œå³ä½¿ä¸åŠ å‰ç¼€lockä¹Ÿå¯ä»¥ return result; } å€ŸåŠ© xchg æŒ‡ä»¤ï¼Œæˆ‘ä»¬å¯ä»¥è½»æ¾åœ°å®ç°ä¸€ä¸ªè‡ªæ—‹é”ï¼š\nint lock = 0; void lock() {while (xchg(\u0026amp;lock, 1));} void unlock() {xchg(\u0026amp;lock, 0);} åœ¨ç¡¬ä»¶å±‚é¢ï¼Œç¡¬ä»¶å¯ä»¥ä¿è¯æ‰€æœ‰çš„å¸¦ lock çš„æŒ‡ä»¤å¯ä»¥æ’å‡ºä¸€ä¸ªå…¨åºï¼Œä¸”åŸå­æŒ‡ä»¤ç›¸å…³çš„å†…å­˜éƒ½ä¼šè¢«æå‰åšå¥½ (å†…å­˜çš„å¯è§æ€§)ã€‚ä½†è¿™å…¶ä¸­æœ‰å¾ˆå¤šæŠ€æœ¯ç»†èŠ‚ï¼Œæ¯”å¦‚å¤šæ ¸çš„ Cache ä¹‹é—´çš„ä¸€è‡´æ€§æ˜¯ x86 çš„å™©æ¢¦ (ä¸€æ—¦æŸä¸ª CPU è¦è·å¾—æ‰€ï¼Œå…¶ä»–æ‰€æœ‰ CPU æ ¸çš„ L1 Cache éƒ½è¦ä¸Šé”)ã€‚\nRISC-V: LR/SC åŸå­æŒ‡ä»¤å†…éƒ¨çš„æœ¬è´¨æ˜¯ä¸‰ä¸ªæ­¥éª¤ï¼šload(), exec(), store()ã€‚RISC-V æä¾›äº† load-reserved/store-conditional (LR/SC) æœºåˆ¶ï¼š\nLR: åœ¨å…±äº«å†…å­˜ä¸Šæ‰“ä¸€ä¸ªæ ‡è®°ï¼Œå¦‚æœå‡ºç°ä¸­æ–­ã€åˆ«çš„çº¿ç¨‹å†™å…¥ç­‰æƒ…å†µï¼Œè¿™ä¸ªæ ‡è®°ä¼šæ¶ˆå¤±ã€‚ exec()ï¼šåœ¨å¯„å­˜å™¨ä¸Šåšä¸€äº›è‡ªå·±çš„äº‹æƒ… SCï¼šå¦‚æœå…±äº«å†…å­˜ä¸Šçš„æ ‡è®°è¿˜åœ¨ï¼Œåˆ™ storeã€‚ è¿™é‡Œç»™å‡ºä¸€ä¸ªç”¨äºè‡ªæ—‹é”çš„ compare-and-swap (æ—§å€¼ç­‰äºæŸä¸ªå€¼æ‰å°†æ–°å€¼ä¸å…¶äº¤æ¢) å‡½æ•°çš„å®ç°ï¼Œç”¨è¿™ä¸ªå‡½æ•°å®ç°è‡ªæ—‹é”åœ¨è½®è¯¢æ—¶å¯ä»¥æ¯” xchg å°‘ä¸€æ¬¡å†™å…¥æ“ä½œï¼š\n// Cè¯­è¨€è¯­ä¹‰ int cas(int *addr, int cmp_val, int new_val) { int old_val = *addr; if (old_val == cmp_val) {*addr = new_val;return 0;} else return 1; } cas: lr.w t0, (a0)\t# è·å¾—æ—§å€¼ï¼Œå¹¶å¯¹(a0)æ‰“æ ‡è®° bne t0, a1, fail\t# å¦‚æœ old_val != cmp_val åˆ™è·³è½¬åˆ° fail sc.w t0, a2, (a0)\t# å¦‚æœæ ‡è®°è¿˜åœ¨ï¼Œå°†a2å†™å…¥(a0)ï¼Œt0å­˜å‚¨æ ‡è®°å­˜åœ¨æƒ…å†µ bnez t0, cas\t# å¦‚æœæ ‡è®°è¢«å†²åˆ·äº†ï¼Œè¯´æ˜å‡ºç°race conditionï¼Œå›åˆ°casé‡åš jr ra fail li a0, 1 jr ra å¦‚æœæœ‰ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶å¸Œæœ›è·å¾—é”ï¼Œç¬¬ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œå®Œ sc.w åï¼Œç¬¬äºŒä¸ªçº¿ç¨‹çš„æ ‡è®°è¢«å†²åˆ·ï¼Œä»è€Œç¬¬äºŒä¸ªçº¿ç¨‹æ‰§è¡Œ sc.w å t0=1ï¼Œæ— æ³•è·å¾—é”ã€‚\nLR/SC æœºåˆ¶ä¸ä»…å¯ä»¥å®ç°é”ï¼Œè¿˜å¯ä»¥è®©æ¯ä¸ªçº¿ç¨‹çŸ¥é“é”çš„æ‹¥å µæƒ…å†µã€‚\nSleep Lock è‡ªæ—‹é”çš„æ€§èƒ½ç¼ºé™·ï¼š\nå¦‚æœå¤šä¸ªçº¿ç¨‹åŒæ—¶äº‰æŠ¢é”ï¼Œå¹¶è¡Œ/å¹¶å‘çš„ç¨‹åºä¼šå› ä¸ºè‡ªæ—‹é”å˜å¾—ä¸²è¡Œã€‚é™¤äº†è¿›å…¥ä¸´ç•ŒåŒºåŸŸçš„çº¿ç¨‹ï¼Œå…¶ä»–çš„çº¿ç¨‹éƒ½åœ¨ç©ºè½¬ã€‚ å¦‚æœæŒæœ‰è‡ªæ—‹é”çš„çº¿ç¨‹è¢«è°ƒåº¦èµ°äº†ï¼Œé‚£ä¹ˆæ‰€æœ‰çš„çº¿ç¨‹éƒ½è¿›ä¸å»äº†ã€‚ è‡ªæ—‹é”çš„ç†æƒ³ä½¿ç”¨åœºæ™¯ï¼š\nä¸´ç•ŒåŒºå‡ ä¹ä¸æ‹¥å µã€‚ æŒæœ‰è‡ªæ—‹é”æ—¶ç¦æ­¢æ‰§è¡Œæµåˆ‡æ¢ - è¿™ä»¶äº‹å¯¹äºåº”ç”¨ç¨‹åºæ¥è¯´å¤ªå±é™©äº†ï¼Œå› æ­¤è‡ªæ—‹é”ä¸€èˆ¬ç”¨äºæ“ä½œç³»ç»Ÿå†…æ ¸ä¸­çš„å¹¶å‘æ•°æ®ç»“æ„ (ä¸´ç•ŒåŒºå¾ˆçŸ­)ã€‚ å¦‚æœé”è¢«å ç”¨ï¼Œå¾…åœ¨åŸåœ°ç­‰å¾…é”è¢«é‡Šæ”¾æ˜¯ä¸€ä»¶ä¸å¤ªèªæ˜çš„äº‹æƒ… (å°¤å…¶æ˜¯è¦ç­‰å¾ˆé•¿æ—¶é—´çš„æ—¶å€™)ï¼Œæˆ‘ä»¬å¸Œæœ›ä¸€ä¸ªçº¿ç¨‹åœ¨ç­‰å¾…é”çš„æ—¶å€™å¯ä»¥è¢«æš‚æ—¶æŒ‚èµ·ï¼Œè®©å‡º CPUï¼Œç­‰åˆ°é”è¢«é‡Šæ”¾æ—¶å†å”¤é†’ç­‰é”è¿›ç¨‹ã€‚\nC è¯­è¨€ä»£ç æ˜¯åšä¸åˆ° â€è®©å‡º CPU çš„\u0026quot;ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ä¸¤ä¸ªç³»ç»Ÿè°ƒç”¨ï¼š\nsyscall(SYSCALL_lock, \u0026amp;lk);\t// è¯•å›¾è·å¾—lkï¼Œå¦‚æœå¤±è´¥åˆ™å½“å‰è¿›ç¨‹è¢«æŒ‚èµ· syscall(SYSCALL_unlock, \u0026amp;lk);\t// é‡Šæ”¾lkï¼Œå¹¶å”¤é†’æ­£åœ¨ç­‰å¾…lkçš„è¿›ç¨‹ æ“ä½œç³»ç»Ÿçš„å·¥ä½œæ˜¯ç»´æŠ¤è¿™ä¸ªé”å’Œç­‰å¾…é”çš„è¿›ç¨‹\nå¦‚æœæœ‰çº¿ç¨‹å°è¯•è·å¾—é”ï¼Œä¸”é”å¤„äºç©ºé—²çŠ¶æ€ï¼Œå°±æŠŠé”ç»™ä»–ã€‚ å¦‚æœæœ‰çº¿ç¨‹å°è¯•è·å¾—é”ä½†é”å·²ç»è¢«å–èµ°äº†ï¼Œåˆ™å°†å½“å‰çº¿ç¨‹åŠ å…¥ç­‰å¾…é”çš„é˜Ÿåˆ—ï¼Œå¹¶å°†å…¶æŒ‚èµ·ã€‚ å¦‚æœæœ‰çº¿ç¨‹é‡Šæ”¾äº†é”ï¼Œå°±æ£€æŸ¥ç­‰å¾…é”çš„é˜Ÿåˆ—ä¸­æ˜¯å¦æœ‰çº¿ç¨‹ï¼Œå¦‚æœæœ‰åˆ™å°†é”äº¤ç»™ä¸‹ä¸€ä½ (å”¤é†’å®ƒ)ï¼Œå¦‚æœæ²¡æœ‰åˆ™é”çš„çŠ¶æ€ä¸ºç©ºé—²ã€‚ æ“ä½œç³»ç»Ÿä½¿ç”¨è‡ªæ—‹é”ä¿è¯è‡ªå·±å¯¹é˜Ÿåˆ—çš„æ“ä½œæ˜¯åŸå­çš„ã€‚ Tip: GDB Usage\nä½¿ç”¨ GDB è°ƒè¯•å¤šçº¿ç¨‹æ—¶ï¼Œå¦‚æœç›´æ¥ä½¿ç”¨ next å‘½ä»¤ï¼Œæ‰€æœ‰çš„çº¿ç¨‹éƒ½ä¼šå‘åèµ°ä¸€æ­¥ã€‚ä¸ºäº†æ›´å¥½åœ°è§‚æµ‹ç¨‹åºè¡Œä¸ºï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ set scheduler-lock on å‘½ä»¤æ¥æ‰“å¼€çº¿ç¨‹é”ï¼Œä¹‹åå†ä½¿ç”¨ next å‘½ä»¤å°±åªæœ‰å½“å‰çº¿ç¨‹ä¼šå‘å‰èµ°ä¸€æ­¥ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ info threads æ¥æŸ¥çœ‹çº¿ç¨‹ä¿¡æ¯ï¼Œé€šè¿‡ thread id æ¥åˆ‡æ¢å½“å‰è°ƒè¯•çš„çº¿ç¨‹ä¸º idã€‚\nFutex è‡ªæ—‹é”æœ‰æ›´å¿«çš„ fast pathï¼šå¦‚æœè·å¾—é”æˆåŠŸï¼Œå¯ä»¥ç«‹åˆ»è¿›å…¥ä¸´ç•ŒåŒºï¼›ä½†å¦‚æœæ²¡æœ‰è·å¾—é”ï¼Œåˆ™è¦æµªè´¹ CPU æ—¶é’Ÿå‘¨æœŸã€‚ ç¡çœ é”æœ‰æ›´å¿«çš„ slow path: å¦‚æœæ²¡æœ‰è·å¾—é”ï¼Œå¯ä»¥æ‰§è¡Œçº¿ç¨‹åˆ‡æ¢ï¼›ä½†åœ¨èƒ½è·å¾—é”çš„æƒ…å†µä¸‹ï¼Œä¹Ÿéœ€è¦æ‰§è¡Œç³»ç»Ÿè°ƒç”¨é™·å…¥å†…æ ¸ã€‚ æˆ‘ä»¬å¸Œæœ›å‘æ˜ä¸€ç§é”ï¼Œå¯¹äº fast pathï¼Œåªéœ€è¦ä¸€æ¡åŸå­æŒ‡ä»¤å°±å¯ä»¥è·å¾—é”ï¼Œå¯¹äº slow pathï¼Œå¯ä»¥é€šè¿‡ç³»ç»Ÿè°ƒç”¨ yieldã€‚è¿™å°±æ˜¯ Futex = spin + mutexã€‚\næˆ‘ä»¬å¯ä»¥åˆ©ç”¨ model checker æ¥ç¡®è®¤ futex çš„æ­£ç¡®æ€§ï¼š\nclass Futex locked, waits = '', '' def tryacquire(self): if not self.locked: # Test-and-set (cmpxchg) # Same effect, but more efficient than xchg self.locked = 'ğŸ”’' return '' else: return 'ğŸ”’' def release(self): if self.waits: self.waits = self.waits[1:]\t# å°†é˜Ÿé¦–å…ƒç´ è¸¢å‡ºé˜Ÿåˆ— \u0026lt;=\u0026gt; å°†ç¼–å·ä¸ºé˜Ÿé¦–å…ƒç´ çš„çº¿ç¨‹å”¤é†’ else: self.locked = '' @thread def t1(self): while True: if self.tryacquire() == 'ğŸ”’': # User self.waits = self.waits + '1' # Kernel while '1' in self.waits: # Kernel pass cs = True # User del cs # User self.release() # Kernel @thread def t2(self): while True: if self.tryacquire() == 'ğŸ”’': self.waits = self.waits + '2' while '2' in self.waits: pass cs = True del cs self.release() Tip: å¼ºå¤§çš„ model checker\næˆ‘ä»¬çš„ model checker çš„åŸç†æ˜¯ï¼šå¯¹äºæœ‰è£…é¥°å™¨ thread ä¿®é¥°çš„å‡½æ•°ï¼Œåœ¨æ¯æ¡è¯­å¥åæ·»åŠ  yieldã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥è½»æ¾åœ°å®ç°ä¸€ä¸ªåŸå­çš„æ“ä½œï¼šåªè¦å°†æ“ä½œå†™æˆä¸€ä¸ªå‡½æ•°ï¼Œå¹¶åœ¨ä¸€è¡Œå†…è°ƒç”¨è¿™ä¸ªå‡½æ•°å³å¯ã€‚å†ä¾‹å¦‚ï¼Œxchg åŸå­æ“ä½œåœ¨æˆ‘ä»¬çš„ model checker ä¸­å¯ä»¥å¾ˆç®€å•åœ°å†™ä¸º\nx, y = y, x çº¿ç¨‹å‡½æ•°ä¸­çš„è¯­å¥\nwhile '1' in self.waits: pass å¹¶ä¸æ˜¯å†…æ ¸çš„çœŸæ­£è¡Œä¸ºï¼šå†…æ ¸ä¼šåˆ‡æ¢èµ°å»æ‰§è¡Œåˆ«çš„çº¿ç¨‹ã€‚ä½†ä»è¿™ä¸ªæ­£åœ¨ç­‰å¾…çš„çº¿ç¨‹çš„è§†è§’ï¼Œå†…æ ¸åœ¨åšå’Œè‡ªå·±æ— å…³çš„äº‹ç­‰ä»·äºå†…æ ¸åœ¨è‡ªå·±è¿™é‡Œè½®è¯¢ã€‚å› æ­¤æˆ‘ä»¬ç²¾å·§åœ°æ¨¡æ‹Ÿå‡ºäº†å†…æ ¸çš„æ­£ç¡®è¡Œä¸ºã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"41157f258c887520eab10434fd7565d4","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec05/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec05/","section":"notes","summary":"ä» high level æ¥çœ‹ï¼Œæˆ‘ä»¬å¸Œæœ›å®ç°å¦‚ä¸‹çš„ç»“æ„ä½“å’Œ APIï¼š\ntypdef struct { ... }lock; void lock(lock *lk); void unlock(lock *lk); è‹¥ lock() å‡½æ•°è¿”å›ï¼Œè¯´æ˜è·å¾—äº†è¿™ä¸ªé”ï¼Œåˆ«çš„è¿›ç¨‹ä¼šåœåœ¨ lock() é‡Œç›´åˆ°è·å¾—é”çš„äººè°ƒç”¨äº† unlock()ã€‚\nå®ç°äº’æ–¥çš„æ ¹æœ¬å›°éš¾ï¼šä¸èƒ½åŒæ—¶è¯»å†™å…±äº«å†…å­˜ã€‚\nload çš„æ—¶å€™ä¸èƒ½ storeï¼Œä¸”çœ‹å®Œä¹‹åçœ¼ç›ç«‹åˆ»é—­ä¸Šï¼Œçœ‹åˆ°çš„éƒ½æ˜¯è¿‡å»çš„ä¸œè¥¿ï¼› store çš„æ—¶å€™ä¸èƒ½ loadï¼Œè´´å­—æ¡çš„æ—¶å€™ä¸çŸ¥é“è¦†ç›–äº†ä»€ä¹ˆã€‚ Spin Lock â€œè§£å†³ä¸€ä¸ªé—®é¢˜æœ‰ä¸¤ç§æ–¹æ³•ï¼šä¸€ä¸ªæ˜¯åˆ†æé—®é¢˜ã€æå‡ºç®—æ³•ã€å®ç°è§£å†³ï¼Œä¸€ä¸ªæ˜¯è§£å†³æå‡ºé—®é¢˜çš„äººã€‚â€œ â€”â€” jyy","tags":null,"title":"Lecture 05: Concurrent Programming: Mutex","type":"docs"},{"authors":null,"categories":null,"content":"çº¿ç¨‹åŒæ­¥ï¼šåœ¨æŸä¸ªæ—¶é—´ç‚¹å…±åŒè¾¾åˆ°äº’ç›¸å·²çŸ¥çš„çŠ¶æ€ã€‚(æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰å¯èƒ½åšè‡ªå·±çš„æŸä¸ªè€—æ—¶å¾ˆé•¿çš„å·¥ä½œ)\nnnpyï¼šç­‰æˆ‘æ´—å®Œå¤´å°±åƒé¥­/ç­‰æˆ‘æ‰“å®Œæ¸¸æˆå°±åƒé¥­ã€‚ â€œå…ˆåˆ°å…ˆç­‰â€çš„åŒæ­¥æœºåˆ¶ã€‚ Producer-Consumer Problem void Tproducer() {while (1) puts(\u0026quot;(\u0026quot;);} void Tconsmuer() {while (1) puts(\u0026quot;)\u0026quot;);} æˆ‘ä»¬å¸Œæœ›ç”Ÿæˆåˆæ³•çš„æ‹¬å·åºåˆ—ï¼Œä¸”æ‹¬å·åºåˆ—åµŒå¥—æ·±åº¦ä¸è¶…è¿‡ç»™å®šå€¼ $n$ï¼š\nproducer: åºåˆ—æ·±åº¦å°äº $n$ æ‰èƒ½æ‰“å°ï¼› consumer: åºåˆ—æ·±åº¦å¤§äºç­‰äº 1 æ‰èƒ½æ‰“å°ã€‚ æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªé˜Ÿåˆ—æ¥ç»´æŠ¤ä»»åŠ¡æ± ï¼Œproducer å°†ä»»åŠ¡æ”¾åˆ°é˜Ÿå°¾ï¼Œconsumer ä»é˜Ÿå¤´å–ä»»åŠ¡ã€‚å–å’Œæ”¾çš„æ“ä½œéƒ½è¦åœ¨é”çš„ä¿æŠ¤ä¸‹è¿›è¡Œã€‚\n// pc.c #include \u0026quot;thread.h\u0026quot; #include \u0026quot;thread-sync.h\u0026quot; int n, count = 0; mutex_t lk = MUTEX_INIT(); void Tproduce() { while (1) { retry: mutex_lock(\u0026amp;lk); if (count == n) { mutex_unlock(\u0026amp;lk); goto retry; } count++; printf(\u0026quot;(\u0026quot;); mutex_unlock(\u0026amp;lk); } } void Tconsume() { while (1) { retry: mutex_lock(\u0026amp;lk); if (count == 0) { mutex_unlock(\u0026amp;lk); goto retry; } count--; printf(\u0026quot;)\u0026quot;); mutex_unlock(\u0026amp;lk); } } int main(int argc, char *argv[]) { assert(argc == 2); n = atoi(argv[1]); setbuf(stdout, NULL); for (int i = 0; i \u0026lt; 8; i++) { create(Tproduce); create(Tconsume); } } Tip: å¦‚ä½•è¯æ˜è¿™ä¸ªæ¨¡å‹æ˜¯æ­£ç¡®çš„ï¼Ÿ\næˆ‘ä»¬å¯ä»¥ç¼–å†™ä¸€ä¸ªå‹åŠ›æµ‹è¯•ï¼š\nimport sys limit = int(sys.argv[1]) count, n = 0, 100000 while True: for ch in sys.stdin.read(n): if ch == '(': count += 1 if ch == ')': count -= 1 assert 0 \u0026lt;= count \u0026lt;= limit print(f'{n} Ok.') æŒ‡å®šè¾ƒæ·±å±‚æ¬¡çš„æ‹¬å·ï¼Œæ¯æ£€æŸ¥ 100000 ä¸ªæ‹¬å·è¾“å‡ºä¸€ä¸ª OK ä¿¡æ¯ã€‚\næˆ‘ä»¬è¿˜å¯ä»¥ç”¨ model checker è¯æ˜è¯¥æ¨¡å‹çš„æ­£ç¡®æ€§ï¼š\n# pc.py class ProducerConsumer: locked, count, log, = '', 0, '' def tryacquire(self): self.locked, seen = 'ğŸ”’', self.locked return seen == '' def release(self): self.locked = '' @thread def tp(self): while True: while not self.tryacquire(): pass if not self.count == 1: break self.release() self.log, self.count = self.log + '(', self.count + 1 self.release() @thread def tc1(self): while True: while not self.tryacquire(): pass if not self.count == 0: break self.release() self.log, self.count = self.log + ')', self.count - 1 self.release() @thread def tc2(self): while True: while not self.tryacquire(): pass if not self.count == 0: break self.release() self.log, self.count = self.log + ')', self.count - 1 self.release() @marker def mark_negative(self, state): count = 0 for ch in self.log: if ch == '(': count += 1 if ch == ')': count -= 1 if count \u0026lt; 0: return 'red' ä½¿ç”¨å‘½ä»¤ python model-checker.py pc.py | grep red å¯ä»¥å¿«é€Ÿæ£€æŸ¥æ˜¯å¦æœ‰çº¢è‰²èŠ‚ç‚¹ã€‚\nConditional Variable è½®è¯¢åœ°ç­‰å¾…æ¡ä»¶æˆç«‹å¤ªæµªè´¹äº‹ä»¶äº†ã€‚æˆ‘ä»¬å¸Œæœ›åœ¨æ¡ä»¶ä¸æ»¡è¶³çš„æ—¶å€™è¿›å…¥ç¡çœ çŠ¶æ€ï¼Œç„¶åæ¡ä»¶å¯èƒ½æ»¡è¶³çš„æ—¶å€™æŠŠæˆ‘å”¤é†’ï¼Œäºæ˜¯æœ‰äº†æ¡ä»¶å˜é‡ (æ³¨ï¼šè¿™ä¸ªæ€æƒ³å’Œç¡çœ é”ç±»ä¼¼ï¼Œä½†ç­‰å¾…çš„å¯¹è±¡ä¸ä¸€æ ·ã€‚ç¡çœ é”ç­‰å¾…çš„æ˜¯ç©ºé”çš„å‡ºç°ï¼Œè€Œæ¡ä»¶å˜é‡æ˜¯åœ¨è·å¾—é”ä¹‹åï¼Œç­‰å¾…å…³é”®å˜é‡ç›¸å…³çš„æ¡ä»¶å¯èƒ½æˆç«‹çš„æ—¶æœº)ã€‚\næ¡ä»¶å˜é‡æœ€åŸºæœ¬çš„ API æœ‰ï¼š\nint pthread_cond_wait(pthread_cond_t *cv, pthread_mutex_t *lk); int pthread_cond_signal(pthread_cond_t \u0026amp;cv); int pthread_cond_broadcast(ptread_cond_t \u0026amp;cv); wait() å‡½æ•°ä¼ å…¥ä¸€ä¸ªæ¡ä»¶å˜é‡å’Œä¸€ä¸ªäº’æ–¥é”ï¼Œè°ƒç”¨æ—¶è¦æ±‚çº¿ç¨‹æŒæœ‰è¯¥é”ã€‚wait() ä¼šå°†è¿™ä¸ªäº’æ–¥é”é‡Šæ”¾æ‰ï¼Œç„¶åç¡çœ è¯¥çº¿ç¨‹ã€‚ç­‰åˆ°æœ‰åˆ«çš„çº¿ç¨‹è°ƒç”¨ signal() æˆ– broadcast() æ¥å”¤é†’è¿™ä¸ªæ¡ä»¶å˜é‡æœ‰å…³çš„çº¿ç¨‹æ—¶ï¼Œwait() ä¼šé‡æ–°è·å¾—äº’æ–¥é”ï¼Œå¹¶ç»§ç»­æ‰§è¡Œä¸‹å»ã€‚ signal() å’Œ broadcast() çš„ä½œç”¨éƒ½æ˜¯å”¤é†’åœ¨æ¡ä»¶å˜é‡ cv ä¸Šç¡çœ çš„çº¿ç¨‹ã€‚ä¸¤è€…çš„ä¸åŒæ˜¯ signal() åªæŒ‘ä¸€ä¸ªçº¿ç¨‹å”¤é†’ï¼Œbroadcast() ä¼šå”¤é†’æ‰€æœ‰ cv ä¸Šçš„çº¿ç¨‹ã€‚ æ¡ä»¶å˜é‡çš„æ­£ç¡®ä½¿ç”¨æ–¹å¼å¦‚ä¸‹ï¼š\nmutex_lock(\u0026amp;lk); while (!cond) { cond_wait(\u0026amp;cv, \u0026amp;lk); } assert(cond); // do some job. // if job is unrelated to critical variables, mutex lock can be released. /* if other threads' cv may be satisfied */ cond_broadcast(\u0026amp;cv); /* ------------------------------------- */ mutex_unlock(\u0026amp;lk); æœ‰å‡ ç‚¹éœ€è¦è¯´æ˜ï¼š\nwhile (!cond) å†™æˆ if (!cond) æ˜¯ä¸€ä¸ªå¸¸è§çš„é”™è¯¯ã€‚æ¯”å¦‚å½“å‰æœ‰ä¸€ä¸ª Tproducer å’Œä¸¤ä¸ª Tconsumerï¼Œé‚£ä¹ˆå¯èƒ½å‡ºç° Tproducer æ‰“å°å®Œ ( åå”¤é†’äº†ç¬¬ä¸€ä¸ª Tconsumerï¼Œç„¶åç¬¬ä¸€ä¸ª Tconsumer æ‰“å°å®Œ ) (æ­¤æ—¶å·²ç»ä¸èƒ½å†æ‰“å° ) ) åå”¤é†’äº†ç¬¬äºŒä¸ª Tconsumerã€‚å¦‚æœæ˜¯ if (!cond) ï¼Œç¬¬äºŒä¸ª Tconsumer è¢«å”¤é†’äº†ä¹‹åæ— æ³•å†è¿›è¡Œæ¡ä»¶æ£€æŸ¥ï¼Œä»è€Œåˆæ‰“å‡ºä¸€ä¸ª ) å¯¼è‡´é”™è¯¯ã€‚\nä½¿ç”¨ while (!cond) ä¿è¯äº†è·³å‡º while å¾ªç¯å cond ä¸€å®šæ˜¯æˆç«‹çš„ã€‚\nä½¿ç”¨ cond_broadcast(\u0026amp;cv) è€Œä¸æ˜¯ cond_signal(\u0026amp;cv) å¯ä»¥é¿å…ä¸€äº›â€œæ­»é”â€æƒ…å†µï¼Œä¾‹å¦‚åœ¨æ²¡æœ‰å¤šä½™çš„ä»»åŠ¡æ—¶ï¼Œè‹¥å¹²ä¸ª consumer äº’ç›¸ signal å¯¼è‡´ä»»åŠ¡æ— æ³•è¿›è¡Œä¸‹å»ã€‚\nTproducer å®Œæˆä»»åŠ¡åä»å”¤é†’ä¸€ä¸ªç¡åœ¨ comsumer-cv ä¸Šçš„çº¿ç¨‹ï¼ŒTconsumer å®Œæˆä»»åŠ¡åå”¤é†’ä¸€ä¸ªç¡åœ¨ producer-cv ä¸Šçš„çº¿ç¨‹ã€‚ä¸ºä»€ä¹ˆè¿™ä¸ªæ¨¡å‹ä¸å¯¹ï¼Ÿ\nclass ProducerConsumer: locked, count, log, waitp, waitc = '', 0, '', '', '' def tryacquire(self): self.locked, seen = 'ğŸ”’', self.locked return seen == '' def release(self): self.locked = '' @thread def tp(self): for _ in range(2): while not self.tryacquire(): pass # mutex_lock() if self.count == 1: # cond_wait _, self.waitp = self.release(), self.waitp + '1' while '1' in self.waitp: pass while not self.tryacquire(): pass self.log, self.count = self.log + '(', self.count + 1 self.waitc = self.waitc[1:] # cond_signal self.release() # mutex_unlock() @thread def tc1(self): while not self.tryacquire(): pass if self.count == 0: _, self.waitc = self.release(), self.waitc + '2' while '2' in self.waitc: pass while not self.tryacquire(): pass self.log, self.count = self.log + ')', self.count - 1 self.waitp = self.waitp[1:] self.release() @thread def tc2(self): while not self.tryacquire(): pass if self.count == 0: _, self.waitc = self.release(), self.waitc + '3' while '3' in self.waitc: pass while not self.tryacquire(): pass self.log, self.count = self.log + ')', self.count - 1 self.waitp = self.waitp[1:] self.release() ä½¿ç”¨ model checker å¯¹è¯¥ç®—æ³•è¿›è¡Œåˆ†æã€‚ä¸‹é¢çš„è¿™ç§æƒ…å½¢ä¼šå¯¼è‡´é—®é¢˜ï¼š\nTc2 é¦–å…ˆè¿è¡Œï¼Œè·å¾—é”ä¹‹åå‘ç° count == 0 ï¼Œäºæ˜¯é‡Šæ”¾é”å¹¶ç¡çœ åœ¨ consumer-cv ä¸Šã€‚ Tp è¿è¡Œï¼Œè·å¾—é”ä¹‹åæ‰“å°å·¦æ‹¬å·ï¼Œcount += 1 ï¼Œå”¤é†’äº†çº¿ç¨‹ Tc2ï¼Œç„¶åé‡Šæ”¾äº†é”ã€‚ Tc2 è¢«å”¤é†’äº†ä»¥åå¹¶æ²¡æœ‰è·å¾—é”ï¼Œè€Œæ˜¯ Tc1 æŠ¢å…ˆè·å¾—äº†é”ï¼Œæ‰“å°äº†å³æ‹¬å·ï¼Œcount -= 1ï¼Œç„¶åé‡Šæ”¾äº†é”ã€‚ Tc2 è·å¾—äº†é”ã€‚ä½†æ­¤æ—¶ Tp ç”Ÿäº§çš„èµ„æºå·²ç»è¢« Tc1 ç”¨æ‰äº†ï¼ŒTc2 å› ä¸ºæ²¡æœ‰ä½¿ç”¨ while åˆ¤æ–­ countï¼Œæ‰€ä»¥ç›´æ¥æ‰“å°äº†å³æ‹¬å·ï¼Œcount -= 1ï¼Œé”™è¯¯å‘ç”Ÿã€‚ åªè¦æ˜¯å¯ä»¥å¤šçº¿ç¨‹çš„å·¥ä½œï¼Œéƒ½å¯ä»¥ä½¿ç”¨ä¸Šé¢çš„æ¨¡æ¿æ¥è¿›è¡Œå¹¶è¡ŒåŠ é€Ÿã€‚é€šå¸¸æ¥è¯´ï¼Œå¦‚æœä¸€ä¸ªä»»åŠ¡è¦åˆ†æˆè‹¥å¹²ä¸ªâ€œå±‚â€œï¼Œæ¯â€å±‚â€œå†…çš„ä»»åŠ¡ä¹‹é—´äº’ç›¸ç‹¬ç«‹ï¼Œæˆ‘ä»¬å°±å¯ä»¥åˆ©ç”¨å¤šçº¿ç¨‹åŠ é€Ÿæ¯ä¸€å±‚çš„è¿ç®— (ä½†å±‚ä¸å±‚ä¹‹é—´çš„ä¾èµ–å…³ç³»æ˜¯æ— æ³•å¤šçº¿ç¨‹åŠ é€Ÿçš„)ã€‚\nExample: fish ä½¿ç”¨æ‰“å° \u0026lt; \u0026gt; å’Œ _ çš„ä¸‰ä¸ªçº¿ç¨‹è¿ç»­è¾“å‡ºå°é±¼ã€‚é±¼çš„å½¢æ€æœ‰ä¸¤ç§ï¼š\u0026lt;\u0026gt;\u0026lt;_ å’Œ \u0026gt;\u0026lt;\u0026gt;_ã€‚\nä½¿ç”¨ä¸‡èƒ½çš„æ¡ä»¶å˜é‡ã€‚æˆ‘ä»¬è¦ææ¸…æ¥šçš„äº‹æƒ…æ˜¯ï¼šè¿™ä¸‰ä¸ªçº¿ç¨‹åº”è¯¥åœ¨ä»€ä¹ˆæ¡ä»¶ä¸‹å¯ä»¥è¾“å‡ºï¼Ÿæˆ‘ä»¬ç”»å‡ºçŠ¶æ€æœºï¼š\nstateDiagram s1: A('') s1 --\u0026gt; s2: '\u0026lt;' s1 --\u0026gt; s3: '\u0026gt;' s2: B('\u0026lt;') s3: C('\u0026gt;') s2 --\u0026gt; s4: '\u0026gt;' s4: D('\u0026lt;\u0026gt;') s3 --\u0026gt; s5: '\u0026lt;' s5: E('\u0026gt;\u0026lt;') s4 --\u0026gt; s6: '\u0026lt;' s5 --\u0026gt; s6: '\u0026gt;' s6: F('\u0026lt;\u0026gt;\u0026lt;' or '\u0026gt;\u0026lt;\u0026gt;') s6 --\u0026gt; s1: '_' æˆ‘ä»¬åªè¦åœ¨ç¨‹åºä¸­ç»´æŠ¤å½“å‰åˆ°è¾¾çš„çŠ¶æ€æœºé¡¶ç‚¹ï¼Œç„¶åæ ¹æ®çŠ¶æ€æœºçš„å‡ºè¾¹å†³å®šæŸä¸ªçº¿ç¨‹æ˜¯å¦å¯ä»¥æ‰“å°å³å¯ã€‚è¿˜éœ€è¦æ³¨æ„çš„ä¸€ç‚¹æ˜¯ï¼šæ‰“å° \u0026lt; \u0026gt; _ çš„çº¿ç¨‹å¯èƒ½å„æœ‰å¾ˆå¤šä¸ªã€‚ä»çŠ¶æ€æœºå½“å‰èŠ‚ç‚¹å‡ºå‘ï¼Œåªèƒ½æœ‰ä¸€ä¸ªå¯è¡Œå­—ç¬¦çº¿ç¨‹æ‰“å°ã€‚å› æ­¤è¿˜éœ€è¦ä¸€ä¸ªå˜é‡æ§åˆ¶å½“å‰æ˜¯å¦å·²ç»æœ‰çº¿ç¨‹åœ¨æ‰“å°é€”ä¸­ã€‚\n// fish.c #include \u0026quot;thread.h\u0026quot; #include \u0026lt;string.h\u0026gt; #define LENGTH(arr) (sizeof(arr) / sizeof(arr[0])) enum { A = 1, B, C, D, E, F, }; struct rule { int from, ch, to; }; struct rule rules[] = { { A, '\u0026lt;', B }, { B, '\u0026gt;', C }, { C, '\u0026lt;', D }, { A, '\u0026gt;', E }, { E, '\u0026lt;', F }, { F, '\u0026gt;', D }, { D, '_', A }, }; int current = A, quota = 1; pthread_mutex_t lk = PTHREAD_MUTEX_INITIALIZER; pthread_cond_t cond = PTHREAD_COND_INITIALIZER; int next(char ch) { for (int i = 0; i \u0026lt; LENGTH(rules); i++) { struct rule *rule = \u0026amp;rules[i]; if (rule-\u0026gt;from == current \u0026amp;\u0026amp; rule-\u0026gt;ch == ch) { return rule-\u0026gt;to; } } return 0; } void fish_before(char ch) { pthread_mutex_lock(\u0026amp;lk); while (!(next(ch) \u0026amp;\u0026amp; quota)) { // can proceed only if (next(ch) \u0026amp;\u0026amp; quota) pthread_cond_wait(\u0026amp;cond, \u0026amp;lk); } quota--; pthread_mutex_unlock(\u0026amp;lk); } void fish_after(char ch) { pthread_mutex_lock(\u0026amp;lk); quota++; current = next(ch); assert(current); pthread_cond_broadcast(\u0026amp;cond); pthread_mutex_unlock(\u0026amp;lk); } const char roles[] = \u0026quot;.\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;___\u0026quot;; void fish_thread(int id) { char role = roles[id]; while (1) { fish_before(role); putchar(role); // can be long; no lock protection fish_after(role); } } int main() { setbuf(stdout, NULL); for (int i = 0; i \u0026lt; strlen(roles); i++) create(fish_thread); } è¿™ä¸ª fish.c å†™çš„éå¸¸æ¼‚äº®ã€‚å®ƒå®Œå…¨å¤åˆ»äº†çŠ¶æ€æœºçš„æ€æƒ³ï¼Œç»´æŠ¤äº†å¯è¡Œçš„è½¬ç§»æ¡ä»¶ã€‚å˜é‡ quota ä¿è¯äº†åªæœ‰ä¸€ä¸ªçº¿ç¨‹â€œå‡ºæ‰‹â€æ‰“å°ã€‚\nè¿˜å€¼å¾—æ³¨æ„çš„ä¸€ç‚¹æ˜¯ï¼Œputchar(role) è¿™ä¸ªæ“ä½œå’Œæ§åˆ¶çŠ¶æ€æœºè½¬ç§»çš„å…³é”®å˜é‡ current å’Œ quota æ— å…³ã€‚ä¸” I/O æ“ä½œç†è®ºä¸Šé€Ÿåº¦è¾ƒæ…¢ã€‚è¿™æ ·çš„å·¥ä½œæ˜¯å¯ä»¥æ”¾åœ¨é”å¤–é¢è¿›è¡Œçš„ (äº‹å®ä¸Šï¼Œç”±äº quota çš„æ§åˆ¶ï¼Œè¿™ä¸ªæ“ä½œå¹¶æ²¡æœ‰èµ·åˆ°æ˜æ˜¾çš„ä¼˜åŒ–æ•ˆæœ)ã€‚\næˆ‘ä»¬å¯ä»¥å¯¹å…¶è¿›è¡Œå‹åŠ›æµ‹è¯•ï¼š\n# fish-check.py import sys n, count = 100000, 0 while True: animal = str(sys.stdin.read(4)) assert animal == '\u0026lt;\u0026gt;\u0026lt;_' or animal == '\u0026gt;\u0026lt;\u0026gt;_' count += 1 if count == n: print(f'{n} OK.') count = 0 Semaphore åœ¨ä¸Šè¿°çš„æ‹¬å·æ‰“å°é—®é¢˜ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨äº’æ–¥é”æ¥ä¿æŠ¤æˆ‘ä»¬å¯¹ count å˜é‡çš„æ›´æ–°æ“ä½œã€‚ä¸€ä¸ªæƒ³æ³•æ˜¯ï¼šå¯ä¸å¯ä»¥ä¸æ­¢ä¸€ä¸ªé”ï¼Œè€Œæ˜¯æœ‰ $n$ ä¸ªæ‰‹ç¯ã€‚æ‰‹ç¯æ•°é‡ä¸èƒ½è¶…è¿‡ä¸Šé™ï¼Œproducer å¯ä»¥ç”Ÿäº§æ‰‹ç¯ï¼Œconsumer å¿…é¡»é¢†åˆ°æ‰‹ç¯æ‰èƒ½åšäº‹æƒ…ï¼Ÿè¿™ç§ç»´æŠ¤äº†â€œä¸€å †æ‰‹ç¯â€çš„é”å°±æ˜¯ä¿¡å·é‡ã€‚\nä¸‹é¢çš„ python ä»£ç æè¿°äº†ä¿¡å·é‡çš„è¡Œä¸ºå»ºæ¨¡ï¼š\n# sem.py class Semaphore: token, waits = 1, '' def P(self, tid): if self.token \u0026gt; 0: self.token -= 1 return True else: self.waits = self.waits + tid return False def V(self): if self.waits: self.waits = self.waits[1:] else: self.token += 1 @thread def t1(self): self.P('1') while '1' in self.waits: pass cs = True del cs self.V() @thread def t2(self): self.P('2') while '2' in self.waits: pass cs = True del cs self.V() å˜é‡ token ç»´æŠ¤äº†èµ„æº (æ‰‹ç¯) çš„æ•°é‡ã€‚P() ç”¨äºè·å–æ‰‹ç¯ï¼Œå¦‚æœå½“å‰æœ‰å‰©ä½™çš„æ‰‹ç¯å°±é¢†èµ°ï¼Œå¹¶è¿›å…¥ä¸´ç•ŒåŒºåŸŸï¼›å¦‚æœå½“å‰æ²¡æœ‰å‰©ä½™çš„æ‰‹ç¯å°±è¿›å…¥ç­‰å¾…åºåˆ—ã€‚V() ç”¨äºå½’è¿˜æ‰‹ç¯ã€‚å¦‚æœå½“å‰æœ‰æ­£åœ¨ç­‰å¾…çš„äººï¼Œå°±ç›´æ¥å°†æ‰‹ç¯äº¤ç»™å®ƒ (wait list é˜Ÿé¦–å…ƒç´ å¼¹å‡º)ï¼Œå¦‚æœæ²¡æœ‰å°±å½’è¿˜ç»™ kernel (token++)ã€‚\nC è¯­è¨€çš„çº¿ç¨‹åº“ä¸ºæˆ‘ä»¬æä¾›äº†ä¿¡å·é‡çš„ç›¸å…³ API:\nint sem_init(sem_t *sem, int pshared, unsigned int value); int sem_wait(sem_t *sem); int sem_post(sem_t *sem); sem_init() ç”¨äºåˆå§‹åŒ–ä¸€ä¸ªä¿¡å·é‡ï¼Œpshared == 0 è¡¨ç¤ºè¯¥ä¿¡å·é‡åªåœ¨å½“å‰è¿›ç¨‹çš„çº¿ç¨‹ä¹‹é—´å…±äº«ï¼›pshared == 1 è¡¨ç¤ºè¯¥ä¿¡å·é‡å¯ä»¥è·¨è¿›ç¨‹å…±äº«ã€‚value è¡¨ç¤ºä¿¡å·é‡çš„åˆå§‹å€¼ (æ¸¸æ³³é¦†çš„æœ€å¤§æ‰‹ç¯ä¸ªæ•°)ã€‚ sem_wait() å’Œ sem_post() ç­‰ä»·äºä¹‹å‰çš„ P() å’Œ V()ï¼Œç”¨äºé¢†å–æ‰‹ç¯å’Œå½’è¿˜æ‰‹ç¯ã€‚ åˆ©ç”¨è¿™äº› API æˆ‘ä»¬å¯ä»¥éå¸¸è½»å·§åœ°å®ç°ä¹‹å‰çš„æ‹¬å·æ‰“å°ä»»åŠ¡ï¼š\n// pc-sem.c #include \u0026quot;thread.h\u0026quot; #include \u0026quot;thread-sync.h\u0026quot; sem_t fill, empty; void producer() { while (1) { P(\u0026amp;empty); printf(\u0026quot;(\u0026quot;); V(\u0026amp;fill); } } void consumer() { while (1) { P(\u0026amp;fill); printf(\u0026quot;)\u0026quot;); V(\u0026amp;empty); } } int main(int argc, char *argv[]) { assert(argc == 2); SEM_INIT(\u0026amp;fill, 0); SEM_INIT(\u0026amp;empty, atoi(argv[1])); for (int i = 0; i \u0026lt; 8; i++) { create(producer); create(consumer); } } é€šå¸¸æ¥è¯´ï¼Œä¿¡å·é‡åœ¨â€ä¸€å•ä½èµ„æºâ€œæ˜ç¡®çš„æƒ…å†µä¸‹æ¯”è¾ƒå¥½ç”¨ (æ¯”å¦‚è¿™é‡Œçš„â€œä¸€å•ä½èµ„æºâ€å°±æ˜¯æŒ‡ä¸€ä¸ªå°šæœªåŒ¹é…çš„å·¦æ‹¬å·)ï¼Œåœ¨æœ‰äº›åœºæ™¯ä¸‹ä½¿ç”¨ä¿¡å·é‡å¾ˆéš¾å†™å‡ºæ­£ç¡®çš„å¹¶å‘ç¨‹åºã€‚æ­¤å¤–ï¼Œä¿¡å·é‡çš„ V() å‡½æ•°æ˜¯å¯ä»¥åœ¨â€œæ²¡æœ‰é¢†å–æ‰‹ç¯â€çš„æ—¶å€™â€œå‡­ç©ºâ€â€œå˜å‡ºä¸€ä¸ªæ‰‹ç¯â€œä¸Šäº¤çš„ï¼Œå› æ­¤ä½¿ç”¨æ—¶å¿…é¡»æ ¼å¤–å°å¿ƒã€‚\nDining Philosophers Problem äº”ä¸ªå“²å­¦å®¶å›´æˆä¸€æ¡Œåƒé¥­ã€‚æ¯ä¸¤ä¸ªäººä¹‹é—´æœ‰ä¸€æŠŠå‰å­ (ä¸€å…±äº”æŠŠ)ï¼Œå“²å­¦å®¶åªæœ‰åŒæ—¶æ‹¿åˆ°å·¦è¾¹å’Œå³è¾¹çš„å‰å­æ‰èƒ½åƒé¥­ã€‚å¦‚ä½•ç»´æŠ¤è¿™ä»¶äº‹æƒ…ï¼Ÿ\nè¿™ä»¶äº‹æƒ…ä¸æ˜¯å¾ˆå¥½æ˜ç¡®â€œä¸€å•ä½èµ„æºâ€œï¼šä¸€æŠŠå‰å­æ—¢æ˜¯æŸä½å“²å­¦å®¶çš„â€œå³å‰å­â€ï¼Œåˆæ˜¯æŸä½å“²å­¦å®¶çš„â€œå·¦å‰å­â€ï¼Œå¦‚æœæˆ‘ä»¬å¯¹æ¯æŠŠå‰å­ç»´æŠ¤ä¸€ä¸ªä¿¡å·é‡ï¼Œå†™å…¥å¦‚ä¸‹ç¨‹åºï¼š\n// philosopher.c #include \u0026quot;thread.h\u0026quot; #include \u0026quot;thread-sync.h\u0026quot; #define N 5 sem_t locks[N]; void Tphilosopher(int id) { int lhs = (N + id - 1) % N; int rhs = id % N; while (1) { P(\u0026amp;locks[lhs]); printf(\u0026quot;T%d Got %d\\n\u0026quot;, id, lhs + 1); P(\u0026amp;locks[rhs]); printf(\u0026quot;T%d Got %d\\n\u0026quot;, id, rhs + 1); V(\u0026amp;locks[lhs]); V(\u0026amp;locks[rhs]); } } int main(int argc, char *argv[]) { for (int i = 0; i \u0026lt; N; i++) { SEM_INIT(\u0026amp;locks[i], 1); } for (int i = 0; i \u0026lt; N; i++) { create(Tphilosopher); } } è¿è¡Œä¸€å°ä¼šå„¿å°±ä¼šå¡ä½ã€‚æ­¤æ—¶æ¯ä¸ªå“²å­¦å®¶éƒ½æŠ“ç€è‡ªå·±å·¦æ‰‹è¾¹çš„å‰å­ï¼Œå®ƒä»¬éƒ½æƒ³å¾—åˆ°å³å‰å­ï¼Œä½†éƒ½å¾—ä¸åˆ°ã€‚å› ä¸ºéƒ½å¾—ä¸åˆ°ï¼Œä»–ä»¬ä¹Ÿä¸ä¼šæ”¾ä¸‹è‡ªå·±æ‰‹ä¸­çš„å‰å­ã€‚è¿™å°±æ˜¯æ­»é”ã€‚å¦‚æœæŠŠæ¯æŠŠå‰å­æƒ³è±¡æˆå›¾ä¸­çš„èŠ‚ç‚¹ï¼Œå“²å­¦å®¶ä»¬å¯¹å‰å­çš„éœ€æ±‚åºåˆ— (å…ˆè¦å·¦å‰å­ï¼Œå†è¦å³å‰å­) å°±æ„æˆäº†ä¸€ä¸ªç¯ã€‚å¦‚æœé”ä¾èµ–å…³ç³»ä¸­æœ‰ç¯ï¼Œå°±å¯èƒ½å‡ºç°æ­»é”ã€‚\nå½“ç„¶æˆ‘ä»¬å¯ä»¥ç”¨ä¸‡èƒ½çš„æ¡ä»¶å˜é‡æ¥æ­£ç¡®å®ç°ï¼š\nmutex_lock(\u0026amp;mutex); while (!(avail[lhs] \u0026amp;\u0026amp; avail[rhs])) { wait(\u0026amp;cv, \u0026amp;mutex); } avail[lhs] = avail[rhs] = false; mutex_unlock(\u0026amp;mutex); mutex_lock(\u0026amp;mutex); avail[lhs] = avail[rhs] = true; broadcast(\u0026amp;cv); mutex_unlock(\u0026amp;mutex); è¯¥æ®µä»£ç ä¸ä¹‹å‰ç›¸æ¯”çš„åŒºåˆ«åœ¨äºï¼Œå“²å­¦å®¶æ€»æ˜¯çœ‹åˆ°å·¦å³å‰å­éƒ½æœ‰å†åŒæ—¶æ‹¿èµ·ï¼Œåƒå®Œäº†å°±ä¼šæ”¾ä¸‹ã€‚ä¸ä¼šå‡ºç°ä¹‹å‰æ–¹æ³•ä¸­çš„å“²å­¦å®¶æ‹¿åˆ°ä¸€æŠŠå‰å­å†ç­‰å¦ä¸€æŠŠå‰å­ï¼Œè‡ªå·±æ‰‹é‡Œçš„å‰å­ä¹Ÿä¸ç»™åˆ«äººç”¨çš„æƒ…å†µã€‚\nç³»ç»Ÿä¸­å¦ä¸€ç§å¸¸è§çš„å¤„ç†ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹çš„æ–¹æ³•æ˜¯ master-slaveï¼šæˆ‘ä»¬å®‰æ’ä¸€ä¸ªæœåŠ¡å‘˜æ¥ç»´æŠ¤æ‰€æœ‰çš„å‰å­ï¼Œæ‰€æœ‰çš„å“²å­¦å®¶éƒ½é€šè¿‡ä¸æœåŠ¡å‘˜é€šä¿¡çš„æ–¹æ³•æ¥å‘æœåŠ¡å‘˜ç´¢è¦å‰å­/è®©æœåŠ¡å‘˜æŠŠå‰å­å–èµ°ã€‚\nvoid Tphilosopher(int id) { send_request(id, EAT); P(allowed[id]); // waiter ä¼šæŠŠå‰å­é€’ç»™å“²å­¦å®¶ philosopher_eat(); send_request(id, DONE); } void Twaiter() { while (1) { (id, status) = receive_request(); if (status == EAT) { ... } if (status == DONE) { ... } } } ","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"9ce85d4f930bd215850660c5324d03f2","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec06/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec06/","section":"notes","summary":"çº¿ç¨‹åŒæ­¥ï¼šåœ¨æŸä¸ªæ—¶é—´ç‚¹å…±åŒè¾¾åˆ°äº’ç›¸å·²çŸ¥çš„çŠ¶æ€ã€‚(æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰å¯èƒ½åšè‡ªå·±çš„æŸä¸ªè€—æ—¶å¾ˆé•¿çš„å·¥ä½œ)\nnnpyï¼šç­‰æˆ‘æ´—å®Œå¤´å°±åƒé¥­/ç­‰æˆ‘æ‰“å®Œæ¸¸æˆå°±åƒé¥­ã€‚ â€œå…ˆåˆ°å…ˆç­‰â€çš„åŒæ­¥æœºåˆ¶ã€‚ Producer-Consumer Problem void Tproducer() {while (1) puts(\u0026quot;(\u0026quot;);} void Tconsmuer() {while (1) puts(\u0026quot;)\u0026quot;);} æˆ‘ä»¬å¸Œæœ›ç”Ÿæˆåˆæ³•çš„æ‹¬å·åºåˆ—ï¼Œä¸”æ‹¬å·åºåˆ—åµŒå¥—æ·±åº¦ä¸è¶…è¿‡ç»™å®šå€¼ $n$ï¼š\nproducer: åºåˆ—æ·±åº¦å°äº $n$ æ‰èƒ½æ‰“å°ï¼› consumer: åºåˆ—æ·±åº¦å¤§äºç­‰äº 1 æ‰èƒ½æ‰“å°ã€‚ æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªé˜Ÿåˆ—æ¥ç»´æŠ¤ä»»åŠ¡æ± ï¼Œproducer å°†ä»»åŠ¡æ”¾åˆ°é˜Ÿå°¾ï¼Œconsumer ä»é˜Ÿå¤´å–ä»»åŠ¡ã€‚å–å’Œæ”¾çš„æ“ä½œéƒ½è¦åœ¨é”çš„ä¿æŠ¤ä¸‹è¿›è¡Œã€‚\n// pc.c #include \u0026quot;thread.","tags":null,"title":"Lecture 06: Concurrent Programming: Synchronization","type":"docs"},{"authors":null,"categories":null,"content":"High Performance Computing HPC: è§£å†³éœ€è¦ massive computation çš„ä»»åŠ¡ã€‚\nåŸºæœ¬æ€è·¯ï¼šè®¡ç®—å›¾ä¼šåˆ†æˆè‹¥å¹²å±‚ï¼Œæ¯å±‚ä¼šæœ‰å¾ˆå¤šè¦è®¡ç®—çš„èŠ‚ç‚¹ã€‚å°†æ¯å±‚çš„ä»»åŠ¡å…ˆåˆ†é…åˆ°æœºå™¨ï¼Œæœºå™¨é‡Œå†åˆ†é…åˆ°çº¿ç¨‹ (ä¸¤çº§åˆ†è§£)ï¼Œå¹¶è¡Œè®¡ç®—è¿™äº›èŠ‚ç‚¹åï¼Œç”¨ä¸€ä¸ª \u0026ldquo;join()\u0026rdquo; æ±‡æ€»ä¸€ä¸‹ (æ¶‰åŠçº¿ç¨‹ã€æœºå™¨ã€å…±äº«å†…å­˜ä¹‹é—´çš„é€šä¿¡)ã€‚\nHPC å¯ä»¥å®ç°çš„åŸå› ï¼šæ•°æ®çš„å±€éƒ¨æ€§ã€‚ä¾‹å¦‚æˆ‘ä»¬æƒ³åˆ©ç”¨ HPC è¿›è¡Œä¸€å›¢æ°”ä½“çš„è¿åŠ¨æ¨¡æ‹Ÿï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å°†ç«‹æ–¹ä½“å®¹å™¨å†…çš„æ°”ä½“åˆ‡åˆ†æˆå¾ˆå¤šå—ï¼Œæ¯ä¸ªçº¿ç¨‹ç®¡ä¸€å—ã€‚æ¯ä¸ªçº¿ç¨‹ç®¡ç†çš„æ°”ä½“ç»å¤§éƒ¨åˆ†çš„è¿åŠ¨éƒ½æ˜¯æœ¬åœ°çš„ï¼Œæˆ‘ä»¬åªéœ€è¦å¤„ç†å°‘éƒ¨åˆ†çš„ç›¸é‚»å—çš„æ°”ä½“åˆ†å­äº¤æ¢å³å¯ã€‚\nExample: Mandelbrot Set // mandelbrot.c #include \u0026quot;thread.h\u0026quot; #include \u0026lt;math.h\u0026gt; int NT; #define W 6400 #define H 6400 #define IMG_FILE \u0026quot;./mandelbrot.ppm\u0026quot; static inline int belongs(int x, int y, int t) { return x / (W / NT) == t; } int x[W][H]; int volatile done = 0; void display(FILE *fp, int step) { static int rnd = 1; int w = W / step, h = H / step; // STFW: Portable Pixel Map fprintf(fp, \u0026quot;P6\\n %d %d 255\\n\u0026quot;, w, h); for (int j = 0; j \u0026lt; H; j += step) { for (int i = 0; i \u0026lt; W; i += step) { int n = x[i][j]; int r = 255 * pow((n - 80) / 800.0, 3); int g = 255 * pow((n - 80) / 800.0, 0.7); int b = 255 * pow((n - 80) / 800.0, 0.5); fputc(r, fp); fputc(g, fp); fputc(b, fp); } } } void Tworker(int tid) { for (int i = 0; i \u0026lt; W; i++) for (int j = 0; j \u0026lt; H; j++) if (belongs(i, j, tid - 1)) { double a = 0, b = 0, c, d; while ((c = a * a) + (d = b * b) \u0026lt; 4 \u0026amp;\u0026amp; x[i][j]++ \u0026lt; 880) { b = 2 * a * b + j * 1024.0 / H * 8e-9 - 0.645411; a = c - d + i * 1024.0 / W * 8e-9 + 0.356888; } } done++; } void Tdisplay() { float ms = 0; while (1) { FILE *fp = popen(\u0026quot;viu -\u0026quot;, \u0026quot;w\u0026quot;); assert(fp); display(fp, W / 256); pclose(fp); if (done == NT) break; usleep(1000000 / 5); ms += 1000.0 / 5; } printf(\u0026quot;Approximate render time: %.1lfs\\n\u0026quot;, ms / 1000); FILE *fp = fopen(IMG_FILE, \u0026quot;w\u0026quot;); assert(fp); display(fp, 2); fclose(fp); } int main(int argc, char *argv[]) { assert(argc == 2); NT = atoi(argv[1]); for (int i = 0; i \u0026lt; NT; i++) { create(Tworker); } create(Tdisplay); join(); return 0; } è¿™æ®µä»£ç ä½¿ç”¨ä¸€äº›æ•°å­¦æ‰‹æ³•ç”»å‡ºä¸€å¹…æ¸…æ™°åº¦å¾ˆé«˜ï¼Œéå¸¸ç¾è§‚çš„åˆ†å½¢å›¾ã€‚ä»£ç ä¸­æœ‰ä¸€äº›æœ‰æ„æ€çš„å°å·¥å…·ï¼š\nTdisplay çº¿ç¨‹ä¸­ä½¿ç”¨äº† viu å‘½ä»¤è¡Œå·¥å…·ï¼Œå®ƒå¯ä»¥å°†ä¸€å¼ å›¾ç‰‡ä»¥è¾ƒä½çš„åˆ†è¾¨ç‡æ‰“å°åœ¨ç»ˆç«¯ä¸Šï¼Œè¿™å¯ä»¥åœ¨è®©æˆ‘ä»¬çœ‹åˆ°å›¾åƒç”Ÿæˆçš„å¤§è‡´è¿‡ç¨‹ã€‚æˆ‘ä»¬å¯ä»¥çœ‹åˆ°è¯¥ç¨‹åºå°†ç”»é¢åˆ‡åˆ†æˆäº†å¤šä¸ªéƒ¨åˆ†ï¼Œæ¯ä¸ªçº¿ç¨‹æ§åˆ¶ä¸€ä¸ªã€‚\nTdisplay çº¿ç¨‹æœ€ç»ˆå°†åƒç´ ä¿¡æ¯è¾“å‡ºåˆ°äº†ä¸€ä¸ª ppm (portable pixel map) æ–‡ä»¶ä¸­ã€‚å¯¹äº C è¯­è¨€æ¥è¯´ï¼Œè¿™æ˜¯ä¸€ç§éå¸¸æ–¹ä¾¿çš„è¾“å‡ºå›¾åƒçš„æ–¹å¼ï¼šåªéœ€è¦åœ¨æ–‡ä»¶å¼€å¤´è¾“å‡º\nP6 W H COLOR // å®½ï¼Œé«˜ï¼Œé¢œè‰²æ•° ç„¶åä¸€è¡Œä¸€è¡Œåœ°å°†æ¯ä¸ªç‚¹çš„ RGB å€¼è¾“å‡ºå³å¯ã€‚\nData Center å¤šå‰¯æœ¬æƒ…å†µä¸‹çš„ä½å»¶è¿Ÿã€é«˜å¯é æ€§é—®é¢˜ã€‚è¿™å…¶ä¸­å­˜åœ¨ä¸€äº›äº’ç›¸çŸ›ç›¾çš„ç‚¹\nAvailability - æ•°æ®åœ¨ data center åº”è¯¥æœ‰å¤šä¸ªå‰¯æœ¬ï¼Œè¿™æ ·å¦‚æœæŸä¸ªå‰¯æœ¬åäº†ï¼Œæ•°æ®ä¸ä¼šä¸¢å¤±ã€‚æ­¤å¤–ï¼Œä¸ºäº†å„åœ°åœ°äººå¯ä»¥å¿«é€Ÿè¯»å–ï¼ŒæœåŠ¡å™¨ä¼šæŠŠæœ¬åœ°åŸå¸‚ data center çš„æ•°æ®ç›´æ¥è¿”å›ã€‚ Consistency - â€æˆ‘åœ¨å—äº¬å±è”½æˆ‘å¦ˆï¼Œæˆ‘å¦ˆåœ¨å¹¿å·ä¹Ÿè¦å“åº”è¿™ä¸ªå±è”½ã€‚â€ ä¸èƒ½å› ä¸ºå›¾å¿«è€Œä¸åŒæ­¥åœ°ç›´æ¥è¯»å–æœ¬åœ°å‰¯æœ¬ã€‚ Partition Tolerance è¿™é—¨è¯¾çš„é—®é¢˜ï¼šå¦‚ä½•åœ¨ä¸€å°è®¡ç®—æœºä¸Šæ—¢å¯èƒ½é«˜æ•ˆåœ°å¤„ç†å¹¶è¡Œè¯·æ±‚ï¼Ÿ\næˆ‘ä»¬çš„å·¥å…·ï¼šçº¿ç¨‹ã€åç¨‹\nçº¿ç¨‹ï¼šå¯ä»¥åœ¨æ“ä½œç³»ç»Ÿçš„è°ƒåº¦ç®—æ³•ä¸‹è¿›è¡Œåˆ‡æ¢ï¼Œä½†çº¿ç¨‹åˆ‡æ¢å¾ˆâ€œé‡â€ï¼šéœ€è¦ä¿å­˜ä¸Šä¸‹æ–‡ï¼Œéœ€è¦é™·å…¥å†…æ ¸ (privilege level çš„æ”¹å˜)â€¦â€¦ åç¨‹ï¼šæ›´è½»é‡çº§çš„å¹¶å‘ (åªè¦éµå®ˆ calling conventionï¼Œåˆ‡æ¢æ—¶ä¸éœ€è¦ä¿å­˜é‚£ä¹ˆå¤šå¯„å­˜å™¨ï¼Œä¸éœ€è¦è¿›æ“ä½œç³»ç»Ÿ)ï¼Œä½†åªæœ‰æ‰§è¡Œ co_yield() æ‰ä¼šåˆ‡æ¢ï¼Œå¦‚æœæŸä¸ªçº¿ç¨‹æ‰§è¡Œäº†å¾ˆæ…¢çš„ I/O ç³»ç»Ÿè°ƒç”¨ï¼Œå‰©ä¸‹çš„åç¨‹å°±éƒ½åœ¨æ‘¸é±¼ã€‚ Goroutine Go æ˜¯ä¸€é—¨ä¸“é—¨æœåŠ¡ç³»ç»Ÿç¼–ç¨‹çš„è¯­è¨€ã€‚go æ”¯æŒæ‰€è°“çš„ goroutine: åœ¨æ¦‚å¿µä¸Šå®ƒæ˜¯çº¿ç¨‹ï¼Œä½†å®ƒæ˜¯ä½¿ç”¨ç±»ä¼¼äºåç¨‹çš„åŸç†å®ç°çš„ã€‚æ¯ä¸ª CPU ä¸Šåªæœ‰ä¸€ä¸ªçº¿ç¨‹ï¼Œä½†è¿™ä¸ªçº¿ç¨‹ä¸‹æœ‰å¤šä¸ª goroutineï¼Œæ¯ä¸ª CPU ä¸Šæœ‰ä¸€ä¸ª Go worker è´Ÿè´£è°ƒåº¦è¿™äº› goroutineã€‚goroutine åˆ‡æ¢çš„æ–¹å¼å’Œåç¨‹ç›¸ä¼¼ï¼Œå› æ­¤éå¸¸è½»é‡çº§ã€‚å¯¹äºæŸäº›ä¼šå¯¼è‡´é˜»å¡çš„ç³»ç»Ÿè°ƒç”¨ (å¦‚ sleep, rand)ï¼Œgo ä¼šå°†ä»–ä»¬æ”¹æˆ non-blocking çš„ç‰ˆæœ¬ï¼Œå¦‚æœéœ€è¦é™·å…¥å†…æ ¸è¿›è¡Œé•¿æ—¶é—´æ“ä½œï¼Œå®ƒå°±ä¼š yield åˆ°å¦ä¸€ä¸ª goroutine æ‰§è¡Œã€‚è¿™æ ·ï¼Œgoroutine å°†æ“ä½œç³»ç»Ÿå’Œ CPU éƒ½åˆ©ç”¨åˆ°äº†100%ã€‚\n// Example from \u0026quot;The Go Programming Language\u0026quot; package main import ( \u0026quot;fmt\u0026quot; \u0026quot;time\u0026quot; ) func main() { go spinner(100 * time.Millisecond) const n = 45 fibN := fib(n) // slow fmt.Printf(\u0026quot;\\rFibonacci(%d) = %d\\n\u0026quot;, n, fibN) } func spinner(delay time.Duration) { for { for _, r := range `-\\|/` { fmt.Printf(\u0026quot;\\r%c\u0026quot;, r) time.Sleep(delay) } } } func fib(x int) int { if x \u0026lt; 2 { return x } return fib(x - 1) + fib(x - 2) } åœ¨ä¸»å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ go spinner åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„ goroutineã€‚è¯¥ç¨‹åºå¯ä»¥ä¸€è¾¹è®¡ç®— Fibinacci æ•°åˆ—ï¼Œä¸€è¾¹åœ¨ spinner åç¨‹ä¸­æ‰“å°æ—‹è½¬çš„è¿›åº¦æ¡ã€‚\nç»å¤§éƒ¨åˆ†çš„å¹¶å‘é—®é¢˜éƒ½å¯ä»¥é€šè¿‡ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹æ¥è§£å†³ã€‚Go è¯­è¨€å°è£…äº†ç”Ÿäº§è€…-æ¶ˆè´¹è€…é˜Ÿåˆ—ï¼Œæä¾›äº†ç”¨äº goroutines ä¹‹é—´é€šä¿¡çš„ APIï¼š\npackage main import \u0026quot;fmt\u0026quot; var stream = make(chan int, 10) const n = 4 func produce() { for i := 0; ; i++ { fmt.Println(\u0026quot;produce\u0026quot;, i) stream \u0026lt;- i } } func consume() { for { x := \u0026lt;-stream fmt.Println(\u0026quot;consume\u0026quot;, x) } } func main() { for i := 0; i \u0026lt; n; i++ { go produce() } consume() } make(chan int, 10) å®šä¹‰äº†ä¸€ä¸ªé€šé“ï¼Œå¹¶è§„å®šäº†å…¶æœ€å¤§å®¹é‡ (æœ€å¤§å®¹é‡ä¸º 0 çš„ channel å¯ä»¥ç”¨æ¥åŒæ­¥)ã€‚ç”Ÿäº§è€…é€šè¿‡ stream \u0026lt;- i å¾€é˜Ÿåˆ—é‡Œé¢åŠ ä¸œè¥¿ï¼Œæ¶ˆè´¹è€…é€šè¿‡ x := \u0026lt;-stream ä»é˜Ÿåˆ—é‡Œé¢å–ä¸œè¥¿ã€‚å…¶å†…éƒ¨çš„é”ï¼Œç¡çœ ç­‰ç»†èŠ‚é—®é¢˜å…¨éƒ¨å¯¹ç¨‹åºå‘˜é€æ˜ã€‚\nWeb 2.0 åœ¨ç½‘é¡µè¿™ç§è®¡ç®—é‡ã€å¹¶å‘é‡éƒ½ä¸å¤§çš„åœºæ™¯ä¸‹ï¼Œæˆ‘ä»¬ä½¿ç”¨çš„æ¨¡å‹æ˜¯å•çº¿ç¨‹+äº‹ä»¶æ¨¡å‹ã€‚äº‹ä»¶æŒ‰ç…§é¡ºåºæ‰§è¡Œï¼Œå…·æœ‰åŸå­æ€§ (å‡å°‘äº†å‘ç”Ÿå¹¶å‘ bug çš„å¯èƒ½)ï¼Œé‡åˆ°è€—æ—¶çš„ API å°±ç«‹åˆ»è¿”å› (ç»“æŸä¸€ä¸ªäº‹ä»¶)ã€‚\nä¸ºäº†ä»£ç çš„å¯ç»´æŠ¤æ€§ï¼Œæè¿°æµå›¾çš„è¯­è¨€æ­£åœ¨å‘å±•ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"a10ec3eb8ffc0a1b4bd5b84f6b8de638","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec07/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec07/","section":"notes","summary":"High Performance Computing HPC: è§£å†³éœ€è¦ massive computation çš„ä»»åŠ¡ã€‚\nåŸºæœ¬æ€è·¯ï¼šè®¡ç®—å›¾ä¼šåˆ†æˆè‹¥å¹²å±‚ï¼Œæ¯å±‚ä¼šæœ‰å¾ˆå¤šè¦è®¡ç®—çš„èŠ‚ç‚¹ã€‚å°†æ¯å±‚çš„ä»»åŠ¡å…ˆåˆ†é…åˆ°æœºå™¨ï¼Œæœºå™¨é‡Œå†åˆ†é…åˆ°çº¿ç¨‹ (ä¸¤çº§åˆ†è§£)ï¼Œå¹¶è¡Œè®¡ç®—è¿™äº›èŠ‚ç‚¹åï¼Œç”¨ä¸€ä¸ª \u0026ldquo;join()\u0026rdquo; æ±‡æ€»ä¸€ä¸‹ (æ¶‰åŠçº¿ç¨‹ã€æœºå™¨ã€å…±äº«å†…å­˜ä¹‹é—´çš„é€šä¿¡)ã€‚\nHPC å¯ä»¥å®ç°çš„åŸå› ï¼šæ•°æ®çš„å±€éƒ¨æ€§ã€‚ä¾‹å¦‚æˆ‘ä»¬æƒ³åˆ©ç”¨ HPC è¿›è¡Œä¸€å›¢æ°”ä½“çš„è¿åŠ¨æ¨¡æ‹Ÿï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å°†ç«‹æ–¹ä½“å®¹å™¨å†…çš„æ°”ä½“åˆ‡åˆ†æˆå¾ˆå¤šå—ï¼Œæ¯ä¸ªçº¿ç¨‹ç®¡ä¸€å—ã€‚æ¯ä¸ªçº¿ç¨‹ç®¡ç†çš„æ°”ä½“ç»å¤§éƒ¨åˆ†çš„è¿åŠ¨éƒ½æ˜¯æœ¬åœ°çš„ï¼Œæˆ‘ä»¬åªéœ€è¦å¤„ç†å°‘éƒ¨åˆ†çš„ç›¸é‚»å—çš„æ°”ä½“åˆ†å­äº¤æ¢å³å¯ã€‚\nExample: Mandelbrot Set // mandelbrot.c #include \u0026quot;thread.h\u0026quot; #include \u0026lt;math.h\u0026gt; int NT; #define W 6400 #define H 6400 #define IMG_FILE \u0026quot;.","tags":null,"title":"Lecture 07: Concurrent Programming: Real World","type":"docs"},{"authors":null,"categories":null,"content":"Bug å¤šçš„æ ¹æœ¬åŸå› ï¼šè½¯ä»¶æ˜¯éœ€æ±‚åœ¨è®¡ç®—æœºä¸–ç•Œçš„æŠ•å½±ï¼Œäººç±»ä¸–ç•Œçš„å¾ˆå¤šæ€§è´¨åœ¨ç¼–ç¨‹è¯­è¨€ä¸­ä¸§å¤±äº†ã€‚\nDefensive Programming ä¸€ä¸ªå¥½çš„ç­–ç•¥æ˜¯æ·»åŠ å¾ˆå¤šçš„ assert()ï¼Œassert() çš„æ ¸å¿ƒæ„ä¹‰åœ¨äºå°†ç¨‹åºçš„éœ€æ±‚è¡¨è¾¾å‡ºæ¥ã€‚\nassert() è™½ç„¶ä¸ä¸€å®šèƒ½å†™å¾—å¯¹ï¼Œä½†å¦‚æœ assert() å’Œä»£ç å‡ºé”™çš„æ¦‚ç‡æ˜¯ç‹¬ç«‹çš„ï¼Œé‚£ä¹ˆå†™ assert() å°±ä½¿å¾—ç¨‹åºå‡ºé”™çš„æ¦‚ç‡é™ä½äº†ä¸€ä¸ªæ•°é‡çº§ã€‚\nConcurrent Bugs Deadlock ä¸€ä¸ªä¸­æ–­ç›¸å…³çš„æ­»é”\nvoid os_run() { spin_lock(\u0026amp;lk); spin_lock(\u0026amp;xxx); spin_unlock(\u0026amp;xxx); //------+ }\t// | //\t| Interrupt void on_interrupt()\t//\t| {\t//\t| spin_lock(\u0026amp;lk); // \u0026lt;-------+ ... spin_unlock(\u0026amp;lk); } ä¸Šé”çš„æ—¶å€™è¦å…³ä¸­æ–­ï¼Œä¸”é”å‡ºç°åµŒå¥—çš„æ—¶å€™ï¼Œéœ€è¦ä¸€ä¸ªè®¡æ•°å™¨æ¥ç»´æŠ¤åµŒå¥—å±‚æ•°ï¼Œåªæœ‰å®Œå…¨æ— é”çš„æ—¶å€™æ‰èƒ½å¼€ä¸­æ–­ (é‡Šæ”¾é”çš„æ—¶å€™ä¸èƒ½è½å¼€ä¸­æ–­)ã€‚\nAA-deadlockï¼šæŸä¸ªçº¿ç¨‹åœ¨è¯•å›¾è·å¾—è‡ªå·±å·²ç»è·å¾—çš„é”ã€‚è¿™å¾ˆå®¹æ˜“æ£€æµ‹å‡ºæ¥ã€‚åœ¨ç¼–ç¨‹çš„æ—¶å€™ç†åº”å¤šä½¿ç”¨å¦‚ä¸‹çš„é˜²å¾¡æ€§ç¼–ç¨‹ï¼š\nif (holding(lk)) panic(); ABBA-deadlockï¼šè¿›ç¨‹åœ¨äº’ç›¸ç­‰å¾…åˆ«äººçš„é”ã€‚lock-ordering æ˜¯ä¸€ç§å¥½çš„é˜²å¾¡æ–¹æ³•ï¼šç³»ç»Ÿä¸­æ‰€æœ‰çš„é”å¿…é¡»æ’å‡ºä¸€ä¸ªæ— ç¯çš„æ‹“æ‰‘åºã€‚\nmodel checker å¯ä»¥å¯è§†åŒ–åœ°å¸®æˆ‘ä»¬æ£€æŸ¥æ˜¯å¦æœ‰æ­»é”ã€‚å¦‚æœæŸä¸ªèŠ‚ç‚¹æ‰€æœ‰çš„å‡ºè¾¹éƒ½æŒ‡å‘è‡ªå·±ï¼Œè¿™å°±æ˜¯ä¸€ä¸ªé™·å…¥æ­»é”çš„çŠ¶æ€ã€‚\nData Race ä¸¤ä¸ªçº¿ç¨‹åœ¨åŒä¸€æ—¶é—´è®¿é—®åŒä¸€ä¸ªåœ°å€ï¼Œä¸”è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯å†™ã€‚ä¹‹æ‰€ä»¥è¢«ç§°ä¸ºâ€œç«äº‰â€æ˜¯å› ä¸ºè¿è¡Œçš„ç»“æœå–å†³äºâ€œè°è·‘èµ¢äº†â€ã€‚\nAtomicity Violation (AV) \u0026amp; Order Violation (OV) TOCTTOU (time of check to time of use)ï¼šæŸæ®µä»£ç é€šå¸¸ä¼šæ£€æŸ¥æŸä¸ªæ¡ä»¶ (time to check)ï¼Œç„¶ååœ¨è®¤ä¸ºè¿™ä¸ªæ¡ä»¶çš„æˆç«‹æ˜¯ invariant çš„æƒ…å†µä¸‹å¯¹å…¶è¿›è¡ŒæŸç§æ“ä½œ (time of use)ï¼Œä½†å¦‚æœå…¶ä»–ç¨‹åºåœ¨ä¸­é—´æ’å…¥åšäº†æŸä¸ªæ”¹å˜ invariant çš„æ“ä½œï¼Œå°±ä¼šäº§ç”Ÿ bugã€‚\nTIME\t/home/abc/mailbox | a symbolic link? | | | Delete /home/abc/mailbox | | | No | Create symbolic link | | ~/mailbox, pointing to | | /etc/passwd Append the new message | to /home/abc/mailbox | åœ¨ä¸Šè¿°è¿‡ç¨‹ä¸­ï¼Œå¦‚æœæ”»å‡»è€…åˆ©ç”¨ TOC å’Œ TOU ä¹‹é—´çš„çª—å£æœŸå°† /home/abc/mailbox æŒ‡å‘æŸä¸ªéæ³•çš„æ–‡ä»¶ (æ‰“ç ´äº† kernel ä¹‹å‰æ£€æŸ¥çš„æ¡ä»¶)ï¼Œkernel å°±å¯èƒ½ä¼šç»™æ™®é€šç”¨æˆ· root æƒé™ã€‚\nBugs Confrontation Lockdep æˆ‘ä»¬å¯ä»¥ä¸ºæ¯æŠŠé”ä¸€ä¸ªå…¨å±€å”¯ä¸€çš„ allocation siteã€‚åœ¨æ‰€æœ‰è·å¾—é”/é‡Šæ”¾é”çš„æ—¶é—´ç‚¹è®°å½•ä¸€ä»½æ—¥å¿—ï¼Œç„¶åå¯¹æ—¥å¿—è¿›è¡Œåˆ†æ (è§‚å¯Ÿä¸Šé”é¡ºåº)ï¼Œå¦‚æœå¯¹äºæŸä¸¤æŠŠé” $x,y$ï¼Œæˆ‘ä»¬èƒ½è§‚æµ‹åˆ° $x\\rightsquigarrow y\\and y\\rightsquigarrow x$ï¼Œåˆ™æ£€æµ‹å‡ºäº†å¯èƒ½çš„æ­»é”ã€‚\n// lock-site.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; typedef struct lock { int locked; const char *site; } lock_t; #define STRINGIFY(s) #s #define TOSTRING(s) STRINGIFY(s) #define LOCK_INIT() \\ ( (lock_t) { .locked = 0, .site = __FILE__ \u0026quot;:\u0026quot; TOSTRING(__LINE__), } ) lock_t lk1 = LOCK_INIT(); lock_t lk2 = LOCK_INIT(); void lock(lock_t *lk) { printf(\u0026quot;LOCK %s\\n\u0026quot;, lk-\u0026gt;site); } void unlock(lock_t *lk) { printf(\u0026quot;UNLOCK %s\\n\u0026quot;, lk-\u0026gt;site); } struct some_object { lock_t lock; int data; }; void object_init(struct some_object *obj) { obj-\u0026gt;lock = LOCK_INIT(); } int main() { lock(\u0026amp;lk1); lock(\u0026amp;lk2); unlock(\u0026amp;lk1); unlock(\u0026amp;lk2); struct some_object *obj = malloc(sizeof(struct some_object)); assert(obj); object_init(obj); lock(\u0026amp;obj-\u0026gt;lock); lock(\u0026amp;lk2); lock(\u0026amp;lk1); return 0; } ä¸Šé¢çš„ lock-site.c æä¾›äº†ä¸€ç§ç®€å•çš„ä¸ºæ¯ä¸ªé”æä¾›å”¯ä¸€ allocation site çš„æ–¹æ³•ï¼Œå…¶ä¸­çš„ä¸€äº›å®å®šä¹‰å€¼å¾—å­¦ä¹ ã€‚\nSanitizer è¿è¡Œæ—¶çš„åŠ¨æ€æ£€æŸ¥ã€‚AddressSanitizer å¯ä»¥æ£€æŸ¥å†…å­˜è®¿é—®çš„ bug (ç›‘æ§æ‰€æœ‰çš„å†…å­˜è®¿é—®)ï¼ŒThreadSanitizer å¯ä»¥æ£€æŸ¥æ•°æ®ç«äº‰ (å†…å­˜è®¿é—® + lock/unlock)ï¼Œæ­¤å¤–è¿˜æœ‰ UBSanitizer, MemorySanitizer ç­‰ã€‚\n// uaf.c #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int *ptr = malloc(sizeof(int)); *ptr = 1; free(ptr); *ptr = 1; } ä¸Šè¿°ç¨‹åºå­˜åœ¨ use-after-free é—®é¢˜ã€‚åœ¨ç¼–è¯‘æ—¶åŠ å…¥ -fsanitize=addressï¼Œè¿è¡Œç¨‹åºæ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°ä¸°å¯Œçš„æŠ¥é”™ä¿¡æ¯ã€‚\nLightweight Tools Stack Canary åœ¨æ ˆé¡¶å’Œæ ˆåº•è®¾ç½®ä¸€äº›å­˜å‚¨äº†ç‰¹æ®Šå€¼çš„å†…å­˜å•å…ƒ (é‡‘ä¸é›€) å¹¶å®šæœŸæ£€æŸ¥è¿™äº›å•å…ƒã€‚å¦‚æœè¿™äº›å•å…ƒè¢«ä¿®æ”¹äº†ï¼Œè¯´æ˜å‘ç”Ÿäº†æ ˆæº¢å‡ºã€‚æˆ‘ä»¬åªéœ€å¾ˆçŸ­çš„ä»£ç å°±å¯ä»¥å®Œæˆ stack canaryï¼š\n#define MAGIC 0x55555555 #define BOTTOM (STK_SZ / sizeof(u32) - 1) struct stack { char data[STK_SZ]; }; void canary_init(struct stack *s) { u32 *ptr = (u32 *)s; for (int i = 0; i \u0026lt; CANARY_SZ; i++) ptr[BOTTOM - i] = ptr[i] = MAGIC; } void canary_check(struct stack *s) { u32 *ptr = (u32 *)s; for (int i = 0; i \u0026lt; CANARY_SZ; i++) { panic_on(ptr[BOTTOM - i] != MAGIC, \u0026quot;underflow\u0026quot;); panic_on(ptr[i] != MAGIC, \u0026quot;overflow\u0026quot;); } } æˆ‘ä»¬æœ‰æ—¶åœ¨ windows ä¸­ä¼šçœ‹åˆ°çš„ \u0026ldquo;çƒ«çƒ«çƒ«\u0026rdquo; ç­‰å­—ï¼Œå…¶å®æ˜¯ stack canary åœ¨ GB2312 ç¼–ç ä¸‹çš„ç»“æœï¼š\næœªåˆå§‹åŒ–æ ˆ: 0xcccccccc æœªåˆå§‹åŒ–å †: 0xcdcdcdcd å¯¹è±¡å¤´å°¾: 0xfdfdfdfd å·²å›æ”¶å†…å­˜: 0xdddddddd æˆ‘ä»¬å¯ä»¥ç”¨\n(b'\\xcc' * 80).decode('gb2312') æŸ¥çœ‹ä½¿ç”¨æœªåˆå§‹åŒ–æ ˆæ—¶å¾—åˆ°çš„å†…å®¹ (çƒ«çƒ«çƒ«)ã€‚\nLightweight Lockdep å¾ˆå¤šæƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è‡ªæ—‹é”è‡ªæ—‹æ¬¡æ•°è¿‡å¤šçš„æ—¶å€™ç›´æ¥æŠ¥è­¦ï¼Œç„¶ååˆ©ç”¨ GDB çš„ backtrace åŠŸèƒ½è§‚å¯Ÿæ˜¯å¦çœŸçš„å‘ç”Ÿäº†æ­»é”ã€‚\nint spin_cnt = 0; while (xchg(\u0026amp;locked, 1)) { if (spin_cnt++ \u0026gt; SPIN_LIMIT) { printf(\u0026quot;Too many spin @ %s:%d\\n\u0026quot;, __FILE__, __LINE__); } } ","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"12b7c556b2c42c094745e7efec9e35a3","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec08/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec08/","section":"notes","summary":"Bug å¤šçš„æ ¹æœ¬åŸå› ï¼šè½¯ä»¶æ˜¯éœ€æ±‚åœ¨è®¡ç®—æœºä¸–ç•Œçš„æŠ•å½±ï¼Œäººç±»ä¸–ç•Œçš„å¾ˆå¤šæ€§è´¨åœ¨ç¼–ç¨‹è¯­è¨€ä¸­ä¸§å¤±äº†ã€‚\nDefensive Programming ä¸€ä¸ªå¥½çš„ç­–ç•¥æ˜¯æ·»åŠ å¾ˆå¤šçš„ assert()ï¼Œassert() çš„æ ¸å¿ƒæ„ä¹‰åœ¨äºå°†ç¨‹åºçš„éœ€æ±‚è¡¨è¾¾å‡ºæ¥ã€‚\nassert() è™½ç„¶ä¸ä¸€å®šèƒ½å†™å¾—å¯¹ï¼Œä½†å¦‚æœ assert() å’Œä»£ç å‡ºé”™çš„æ¦‚ç‡æ˜¯ç‹¬ç«‹çš„ï¼Œé‚£ä¹ˆå†™ assert() å°±ä½¿å¾—ç¨‹åºå‡ºé”™çš„æ¦‚ç‡é™ä½äº†ä¸€ä¸ªæ•°é‡çº§ã€‚\nConcurrent Bugs Deadlock ä¸€ä¸ªä¸­æ–­ç›¸å…³çš„æ­»é”\nvoid os_run() { spin_lock(\u0026amp;lk); spin_lock(\u0026amp;xxx); spin_unlock(\u0026amp;xxx); //------+ }\t// | //\t| Interrupt void on_interrupt()\t//\t| {\t//\t| spin_lock(\u0026amp;lk); // \u0026lt;-------+ .","tags":null,"title":"Lecture 08: Concurrent Bugs and Confrontation","type":"docs"},{"authors":null,"categories":null,"content":"Bare-metal \u0026amp; Software æ•°å­—ç”µè·¯æœ¬èº«å°±æ˜¯ä¸€ä¸ªå·¨å¤§çš„çŠ¶æ€æœºã€‚ç¡¬ä»¶å‚å•†ä¼šä¿è¯ CPU reset åå¤„ç†å™¨å¤„åœ¨ä¸€ä¸ªç¡®å®šçš„çŠ¶æ€ï¼Œå„ä¸ªå•å…ƒçš„å›ºå®šçš„å€¼ä¼šå†™åœ¨æ‰‹å†Œä¸­ã€‚ä»¥ x86 ä¸ºä¾‹ï¼Œæ‰‹å†Œè§„å®šäº† CPU reset å rip çš„å€¼ä¼šæ˜¯ 0xfff0ï¼ŒEFLAGS çš„å€¼ä¸º 0x2ï¼Œå½“å‰ç¡¬ä»¶è¿è¡Œåœ¨ 16-bit æ¨¡å¼ä¸­ï¼Œä¸å“åº”ä¸­æ–­ã€‚\nCPU åªæ˜¯ä¸€ä¸ªå‘¨è€Œå¤å§‹çš„å–å€¼è¯‘ç æ‰§è¡Œçš„ä¸œè¥¿ï¼Œå› æ­¤å®ƒé©¬ä¸Šä¼šåšçš„äº‹æƒ…å°±æ˜¯å–å‡º 0xfff0 å¤„çš„æŒ‡ä»¤å¹¶æ‰§è¡Œã€‚0xfff0 å¤„é€šå¸¸æ˜¯ä¸€ä¸ªè·³è½¬æŒ‡ä»¤ï¼ŒPC ä¼šè·³è½¬åˆ°å›ºä»¶ä»£ç æ‰§è¡Œã€‚å›ºä»¶ (Firmware) æ˜¯ç¡¬ä»¶å‚å•†å†™æ­»åœ¨ä¸€å— ROM ä¸Šçš„ä»£ç ï¼Œå¸¸è§çš„å›ºä»¶ç¨‹åºæœ‰ BIOS å’Œ UEFI ä¸¤ç§ï¼Œåè€…æ›´åŠ ç°ä»£æœºåˆ¶æ›´åŠ å¤æ‚ï¼Œè¿™é‡Œç®€ä»‹ Legacy BIOS çš„è¿‡ç¨‹ï¼š\nBIOS çš„ä¸»è¦å·¥ä½œæ˜¯æ‰«æå„ä¸ªç¡¬ç›˜/Uç›˜/è½¯ç›˜â€¦â€¦ç„¶åå°†ç¬¬ä¸€ä¸ªå¯å¼•å¯¼çš„è®¾å¤‡çš„ç¬¬ä¸€ä¸ªæ‰‡åŒº (512B) åŠ è½½åˆ°åœ°å€ 0x7c00 å¤„ã€‚å¯å¼•å¯¼çš„è®¾å¤‡çš„ç¬¬ä¸€ä¸ªæ‰‡åŒºä¼šéµå¾ªä¸»å¼•å¯¼è®°å½• (Master Boot Record, MBR) çš„æ ¼å¼ã€‚å¦‚æœæˆ‘ä»¬ä½¿ç”¨å‘½ä»¤\ncat executable-x86_64-qemu | head -c 512 | xxd æŸ¥çœ‹ä¸€ä¸ªé•œåƒæ–‡ä»¶çš„å‰ 512 ä¸ªå­—èŠ‚ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°å…¶æœ«å°¾ä¸€å®šæ˜¯ 0x55aaã€‚è¿™æ˜¯ MBR çš„ç»“æŸæ ‡å¿—ã€‚\næ­¤æ—¶ç¡¬ä»¶ä»ç„¶å·¥ä½œåœ¨ 16-bit æ¨¡å¼ä¸Šã€‚è§„å®š CS:IP=0x7c00 ï¼Œå³ (R[CS]\u0026lt;\u0026lt;4) | R[IP] == 0x7c00 ï¼Œå…¶ä»–æ²¡æœ‰ä»»ä½•çº¦æŸã€‚Firmware æ‰§è¡Œç»“æŸåï¼ŒPC è·³è½¬åˆ° 0x7c00 æ‰§è¡Œï¼ŒåˆšåˆšåŠ è½½è¿‡æ¥çš„æ˜¯ Legacy boot (boot loader)ï¼Œå®ƒè´Ÿè´£å®Œæˆæ“ä½œç³»ç»Ÿçš„åŠ è½½ï¼šåˆå§‹åŒ–æ ˆå’Œå †åŒºï¼Œä¸º main() ä¼ é€’å‚æ•°ç­‰ç­‰ã€‚\nCode: Firmware QEMU æ˜¯ä¸€ä¸ªå…¨ç³»ç»Ÿæ¨¡æ‹Ÿå™¨ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ GDB è¿œç¨‹è¿æ¥çš„æ–¹å¼æ¥è°ƒè¯• QEMUï¼Œä»è€Œè§‚æµ‹å„ä¸ªæ—¶åˆ»çš„ç³»ç»ŸçŠ¶æ€ã€‚\nä¸€ä¸ªå¯åŠ¨ QEMU å¹¶ä½¿ç”¨ GDB ç›‘å¬çš„è„šæœ¬å¦‚ä¸‹ï¼š\n#!/bin/bash qemu-system-x86_64 \\ -smp 1\\ -S -s\\ -drive format=raw,file=amgame-x86_64-qemu \u0026amp; pid=$! gdb -x remote.gdb ; kill -9 $! qemu-system-x86_64 å¯åŠ¨äº†ä¸€ä¸ª x86-64 æ¶æ„çš„ QEMU æ¨¡æ‹Ÿå™¨ï¼Œä¹‹åçš„å„ä¸ªé€‰é¡¹å’Œå‚æ•°çš„æ„ä¹‰å¦‚ä¸‹ï¼š\n-smp 1 æŒ‡å®šäº† QEMU æ¨¡æ‹Ÿå•æ ¸ CPUã€‚ -S é€‰é¡¹è¡¨ç¤ºè®© QEMU åœæ­¢åœ¨ CPU reset åçš„ç¬¬ä¸€æ¡æŒ‡ä»¤ä¸Šã€‚ -s é€‰é¡¹æ˜¯ -gdb tcp::1234 çš„ç®€å†™ï¼Œè¡¨ç¤ºåœ¨ç«¯å£ 1234 æ‰“å¼€ä¸€ä¸ª gdbserverã€‚ -drive format=raw,file=amgame-x86_64-qemu å‘Šè¯‰äº† QEMU ç”¨äºå¼•å¯¼çš„è®¾å¤‡ã€‚è¿™é‡Œç¬”è€…ä½¿ç”¨äº† Lab0 ä¸­ amgame çš„é•œåƒã€‚ gdb çš„ -x é€‰é¡¹åé¢å¯ä»¥è·Ÿä¸€ä¸ªè„šæœ¬ï¼Œè¡¨ç¤ºåœ¨å¯åŠ¨ gdb ä¹‹åè‡ªåŠ¨è¿è¡Œåé¢çš„è„šæœ¬ã€‚ç¬”è€…åœ¨è„šæœ¬ä¸­åªåšäº†ä¸€è¡Œé…ç½®ï¼š\ntarget remote localhost:1234 è¡¨ç¤ºè¿æ¥åˆ° gdbserverã€‚ä¹‹å‰æˆ‘ä»¬ç»™è¿è¡Œ QEMU çš„è¿›ç¨‹åˆ†é…äº†ä¸€ä¸ªè¿›ç¨‹å·ï¼Œç°åœ¨ç”¨ kill -9 $! å¯ä»¥åœ¨é€€å‡º gdb ä¹‹åå¸®æˆ‘ä»¬è‡ªåŠ¨æ€æ­» QEMU çš„è¿›ç¨‹ã€‚\nè¿è¡Œè¿™ä¸ªè„šæœ¬ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ° QEMU åœåœ¨äº† CPU reset åçš„åˆå§‹çŠ¶æ€ã€‚ä½¿ç”¨ i r å‘½ä»¤æ‰“å°å¯„å­˜å™¨ä¿¡æ¯ï¼Œå¯ä»¥çœ‹åˆ° rip = 0xfff0ï¼Œeflags = 0x2 ç­‰ï¼Œç¬¦åˆæ‰‹å†Œçš„çº¦å®šã€‚æ­¤æ—¶å¦‚æœä½¿ç”¨å‘½ä»¤ x/16xb 0x7c00 æŸ¥çœ‹åœ°å€ 0x7c00 é™„è¿‘çš„å†…å­˜å†…å®¹ï¼Œå¯ä»¥çœ‹åˆ°å…¨éƒ¨æ˜¯ 0 (æ³¨ï¼šx æ˜¯æ‰“å°ï¼Œ16 æ˜¯æ‰“å° 16 ä¸ª byteï¼Œx æ˜¯æŒ‰ç…§åå…­è¿›åˆ¶æ‰“å°ï¼Œb æ˜¯å°†å„ä¸ª byte åˆ†å¼€)ã€‚\n0x7c00:\t0x00\t0x00\t0x00\t0x00\t0x00\t0x00\t0x00\t0x00 0x7c08:\t0x00\t0x00\t0x00\t0x00\t0x00\t0x00\t0x00\t0x00 æƒ³è¦ç›‘æ§ BIOS çš„è¡Œä¸ºï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å‘½ä»¤ wa *0x7c00 åœ¨è¿™ä¸ªåœ°å€ä¸Šæ‰“ä¸€ä¸ªæ–­ç‚¹ï¼Œç„¶å continueï¼Œè¯¥åœ°å€çš„å€¼å‡ºç°å˜åŒ–æ—¶ GDB ä¼šåœä¸‹å¹¶é€šçŸ¥æˆ‘ä»¬ã€‚\nå½“å‰ç³»ç»Ÿä»å¤„äº 16 ä½æ¨¡å¼ï¼Œå› æ­¤éœ€è¦ç”¨ cs å’Œ rip ä¸¤ä¸ªå¯„å­˜å™¨æ¥å®šä½æŒ‡ä»¤çš„ä½ç½®ã€‚ä½¿ç”¨ x/i ($cs * 16 + $rip) æŸ¥çœ‹å½“å‰æŒ‡ä»¤ï¼š\n0xfa591:\trep insl (%dx),%es:(%edi) è¿™æ˜¯ä¸€æ¡å†…å­˜æ‹·è´æŒ‡ä»¤ï¼Œåˆšå¼€å§‹å¯ä»¥çœ‹åˆ° %es:(%edi) == 0x7c00 ï¼Œéšç€ repeat çš„æ¨è¿›ï¼Œ(%edi) çš„å€¼é€æ¸å˜å¤§ã€‚å¦‚æœå†æŸ¥çœ‹ 0x7c00 é™„è¿‘çš„å†…å®¹ï¼Œå¯ä»¥çœ‹åˆ° MBR æ­£åœ¨è¢«é€æ¸æ¬å…¥ï¼š\n0x7c00:\t0xfa\t0x31\t0xc0\t0x8e\t0xd8\t0x8e\t0xc0\t0x8e 0x7c08:\t0xd0\t0xb8\t0x01\t0x4f\t0xb9\t0x12\t0x01\t0xbf 0x7c10:\t0x00\t0x40\t0xcd\t0x10\t0x00\t0x00\t0x00\t0x00 0x7c18:\t0x00\t0x00\t0x00\t0x00\t0x00\t0x00\t0x00\t0x00 State Machine of OS Firmware å’Œ boot loader å…±åŒå®Œæˆäº†æ“ä½œç³»ç»Ÿçš„åŠ è½½ã€‚è¿›å…¥ C ä»£ç åï¼Œæ“ä½œç³»ç»Ÿå°†å®Œå…¨éµå¾ª C è¯­è¨€çš„å½¢å¼è¯­ä¹‰ï¼ˆå½“ç„¶ï¼Œè°ƒç”¨ AbstractMachine API çš„éƒ¨åˆ†æ˜¯å¯¹ C è¯­è¨€å½¢å¼è¯­ä¹‰çš„è¡¥å……ï¼‰ã€‚\nAbstractMachine å¯¹ C ç¨‹åºè¯­ä¹‰çš„æ‰©å±•ä¸»è¦æ˜¯ä»¥ä¸‹å‡ ä¸ªéƒ¨åˆ†ï¼š\nTRM + MPE å®Œå…¨ç­‰åŒäºå¤šçº¿ç¨‹ã€‚å°†æ•´ä¸ªç³»ç»Ÿçš„çŠ¶æ€æœºä»ä¸€æ¡é“¾å˜æˆå¤šæ¡é“¾ï¼Œä¹‹åçš„æ‰§è¡Œå°†æ˜¯ non-deterministic çš„ã€‚ IOE API ç›¸å½“äºåº“å‡½æ•°ã€‚ CTE å…è®¸åˆ›å»ºå¤šä¸ªæ‰§è¡Œæµã€‚ yield() ä¼šä¸»åŠ¨åˆ‡æ¢ï¼Œä¸­æ–­ä¼šè¢«åŠ¨åˆ‡æ¢ã€‚ VME åˆ›å»ºä¸€ä¸ªâ€œç»è¿‡åœ°å€ç¿»è¯‘çš„æ‰§è¡Œæ¨¡å¼â€ã€‚ æ•´ä¸ªç³»ç»Ÿçš„çŠ¶æ€æœºå¤§è‡´å¯ä»¥çœ‹æˆå¦‚ä¸‹è¿‡ç¨‹ï¼š\nCode: AbstractMachine Unix Philosophy\nMakefile ä¸­çš„å˜é‡çš„å®šä¹‰å¯èƒ½æ•£è½åœ¨ä¸–ç•Œå„å¤„ï¼Œå› æ­¤é™æ€åœ°è¯» Makefile æ•ˆæœå¯èƒ½ä¸å¥½ã€‚å¥½çš„æ–¹å¼æ˜¯ç›´æ¥è§‚æµ‹ Makefile åšäº†æ€æ ·çš„äº‹æƒ…ã€‚è¿™é‡Œæä¾›ä¸€å¥—å‘½ä»¤ï¼š\nmake mainargs=HelloOS run -nB \\ | grep -ve '^\\(\\#\\|echo\\|mkdir\\|make\\)' \\ | sed \u0026quot;s#$AM_HOME#\\$AM_HOME#g\u0026quot; \\ | sed \u0026quot;s#$PWD#.#g\u0026quot; \\ | vim - make çš„ -n é€‰é¡¹å¯ä»¥åªè¾“å‡ºæ‰§è¡Œçš„å‘½ä»¤è€Œä¸çœŸæ­£æ‰§è¡Œï¼Œ-B é€‰é¡¹å¯ä»¥å¿½ç•¥å·²ç»ç¼–è¯‘å¥½çš„å†…å®¹ä»å¤´ç¼–è¯‘ã€‚ grep ç”¨äºç­›é€‰ï¼Œ-v é€‰é¡¹è¡¨ç¤ºåå‘ç­›é€‰ï¼Œ-e è¡¨ç¤ºä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…ã€‚ sed å¯ä»¥ä½œæ›¿æ¢ï¼Œè¿™é‡Œå°†å†—é•¿çš„è·¯å¾„åæ›¿æ¢æˆäº†çŸ­çš„ã€‚ vim - å‘½ä»¤å¯ä»¥å°†è¾“å‡ºå¯¼å…¥åˆ° vim ä¸­æŸ¥çœ‹ã€‚ åœ¨ vim ä¸­ä½¿ç”¨ :%s/ /\\r /g å¯ä»¥å°†ç©ºæ ¼æ”¹ä¸ºæ¢è¡Œï¼Œä»è€Œæé«˜å¯è¯»æ€§ã€‚\né€šè¿‡è§‚å¯Ÿ Makefile çš„è¾“å‡ºç»“æœï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°å®ƒæ˜¯å¦‚ä½•åˆ›å»ºé•œåƒæ–‡ä»¶ä»¥åŠä¼ è¾“å‘½ä»¤è¡Œå‚æ•°çš„ï¼š\n( cat $AM_HOME/am/src/x86/qemu/boot/bootblock.o; head -c 1024 /dev/zero; cat ./build/threados-x86_64-qemu.elf ) \u0026gt; ./build/threados-x86_64-qemu bootblock.o æ˜¯ä¸»å¼•å¯¼è®°å½•ã€‚head -c 1024 /dev/zero å–å‡ºäº† 1024B çš„ \\0ã€‚threados-x86_64-qemu.elf æ˜¯æˆ‘ä»¬ä¹‹å‰ç¼–è¯‘ã€é“¾æ¥å¾—åˆ°çš„ elf æ–‡ä»¶ã€‚å°†è¿™ä¸‰è€…æ‹¼æ¥èµ·æ¥è¾“å‡ºåˆ°æ–‡ä»¶ threados-x86_64-qemu ä¸­ï¼Œå°±åˆ¶ä½œå¥½äº†é•œåƒæ–‡ä»¶ã€‚\n( echo -n HelloOS; ) | dd if=/dev/stdin of=./build/threados-x86_64-qemu bs=512 count=2 seek=1 conv=notrunc status=none å‚æ•° HelloOS è¢«è¾“å‡ºåï¼Œdd æŒ‡å®š input file ä¸º stdinï¼Œoutput file ä¸ºæˆ‘ä»¬åˆšåˆšåˆ¶ä½œçš„é•œåƒï¼Œå°†å‚æ•°å†™åˆ°äº†ç¬¬äºŒä¸ªæ‰‡åŒºé‡Œ (å³ MBR åé¢ç´§è·Ÿç€çš„æ‰‡åŒº)ã€‚\nä¹‹å‰æˆ‘ä»¬ç”¨ GDB è°ƒè¯•äº†å›ºä»¶å°† MBR åŠ è½½åˆ° 0x7c00 çš„è¿‡ç¨‹ï¼Œç°åœ¨æˆ‘ä»¬å¯ä»¥ç»§ç»­ç”¨ GDB è°ƒè¯• OS booter çš„è¿è¡Œè¿‡ç¨‹ã€‚\næ²¡æœ‰ OS booter çš„ç¬¦å·è¡¨æ€ä¹ˆåŠï¼Ÿ\nä»”ç»†é˜…è¯» AbstractMachine çš„ Makefileï¼Œæˆ‘ä»¬å‘ç° bootblock.o å°±æ˜¯ä¸»å¼•å¯¼è®°å½•ï¼Œå®ƒçš„ç”Ÿæˆè¿‡ç¨‹å¦‚ä¸‹ï¼š\ngcc -static -m32 -fno-pic -g -Os -nostdlib -Ttext 0x7c00 -I$AM_HOME/am/src -o bootblock.o start.S main.cï¼Œè¯¥å‘½ä»¤ç¼–è¯‘ am/src/x86/qemu/boot/ ç›®å½•ä¸‹çš„ main.c å’Œ start.S å¹¶é“¾æ¥æˆä¸€ä¸ª bootblock.oã€‚\nä¸ºäº†ç”Ÿæˆå¸¦æœ‰è°ƒè¯•ä¿¡æ¯çš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œæˆ‘ä»¬åº”å½“åŠ å…¥ -g é€‰é¡¹ã€‚\npython genboot.py bootblock.o å¯¹ bootblock.o åšäº†è¿›ä¸€æ­¥çš„ä¿®æ”¹ï¼Œé˜…è¯» genboot.py ï¼š\nimport os, sys, pathlib, subprocess f = pathlib.Path(sys.argv[1]) try: objcopy = os.getenv('CROSS_COMPILE', '') + 'objcopy' data = subprocess.run( [objcopy, '-S', '-O', 'binary', '-j', '.text', f, '/dev/stdout'], capture_output=True).stdout assert len(data) \u0026lt;= 510 data += b'\\0' * (510 - len(data)) + b'\\x55\\xaa' f.write_bytes(data) except: f.unlink() raise å®ƒçš„ä¸»è¦å·¥ä½œæ˜¯ç”¨ objcopy å·¥å…·å°† bootblock.o ä¸­çš„å…³é”®å†…å®¹æ‹·è´å‡ºæ¥ï¼Œ-S é€‰é¡¹è¡¨ç¤ºä¸¢å¼ƒé‡å®šä½ä¿¡æ¯ï¼Œç¬¦å·ä¿¡æ¯ï¼Œè°ƒè¯•ä¿¡æ¯ç­‰ä¸éœ€è¦çš„å†…å®¹ï¼›-j .text è¡¨ç¤ºåªä¿ç•™ä»£ç èŠ‚ã€‚æ‹·è´å‡ºæ¥ååœ¨å­—èŠ‚æµçš„åé¢è¡¥ä¸Šè‹¥å¹² 0ï¼Œæœ€ååŠ ä¸Š 0x55aaï¼Œä»¥å½¢æˆä¸€ä¸ª MBRã€‚\nä¸ºäº†è·å¾—ç¬¦å·è¡¨ï¼Œç¬”è€…åšäº†å¦‚ä¸‹ä¿®æ”¹ï¼šå°†ç¬¬ä¸€æ­¥ç”Ÿæˆçš„ bootblock.o å¤‡ä»½ä¸€ä»½é‡å‘½åä¸º boot-sym.o ç”¨äºåŠ è½½ç¬¦å·è¡¨ï¼Œå¹¶åœ¨ gdb å¯åŠ¨æ—¶çš„è‡ªåŠ¨åŒ–è„šæœ¬ä¸­æ·»åŠ ï¼š\nsymbol-file /path/to/boot-sym.o åœ¨ GDB ä¸­æ‰“æ–­ç‚¹ wa ($rip != 0x7c00) (æˆ–è€… b _start) å³å¯å®šä½åˆ° OS booterã€‚æ­¤æ—¶æœºå™¨ä»ç„¶å¤„äº 16 ä½æ¨¡å¼ï¼ŒGDB ä¸æ”¯æŒ 16 ä½çš„è°ƒè¯•ï¼Œæ‰“å°å‡ºæ¥çš„æ±‡ç¼–å‘½ä»¤ä¼šå‡ºç°é”™è¯¯ã€‚æˆ‘ä»¬å¯ä»¥åœ¨ $AM_HOME/am/src/x86/qemu/boot/start.S ä¸­æ‰¾åˆ°å¯¹åº”çš„æŒ‡ä»¤ã€‚å¯ä»¥çœ‹åˆ°åœ¨æ‰§è¡Œäº†ä¸å¤šçš„å‡ æ¡æŒ‡ä»¤åï¼ŒPC è·³è½¬åˆ°äº†å‡½æ•° start32ã€‚start32 æ‰§è¡Œäº†å‡ æ¡ç®€å•çš„æŒ‡ä»¤åè·³è½¬åˆ°äº† load_kernel()ã€‚(åœ¨ load_kernel() ä¸­ç»ˆäºå¯ä»¥ç”¨ layout src è°ƒè¯•äº†)\nload_kernel() å’Œ nanos-lite ä¸­çš„ loader() åŠŸèƒ½ç±»ä¼¼ï¼šå°† elf æ–‡ä»¶ä¸­çš„å„ä¸ªæ®µæ‹·è´åˆ°å†…å­˜çš„æŒ‡å®šåœ°å€ 0x8000ï¼Œå¹¶è·³è½¬åˆ°å…¥å£å‡½æ•°å¯åŠ¨å†…æ ¸ã€‚\nElf32_Ehdr *elf32 = (void *)0x8000; Elf64_Ehdr *elf64 = (void *)0x8000; int is_ap = boot_record()-\u0026gt;is_ap; if (!is_ap) { // load argument (string) to memory copy_from_disk((void *)MAINARG_ADDR, 1024, -1024); // load elf header to memory copy_from_disk(elf32, 4096, 0); if (elf32-\u0026gt;e_machine == EM_X86_64) { load_elf64(elf64); } else { load_elf32(elf32); } } è¿™æ®µä»£ç è°ƒç”¨ copy_from_disk() å°† mainargs ä»¥åŠ elf æ–‡ä»¶ä» disk ä¸­æ‹·è´å‡ºæ¥ï¼Œå†è°ƒç”¨ load_elf() å°†å…¶åŠ è½½åˆ° 0x8000 ä½ç½®ã€‚åœ¨æ‰§è¡Œ if ä¹‹å‰é€šè¿‡ p *elf64 æŸ¥çœ‹ 0x8000 é™„è¿‘çš„å†…å®¹ï¼Œå¯ä»¥çœ‹åˆ°å„ä¸ªå­—æ®µå…¨éƒ¨ä¸ºç©ºã€‚\n(gdb) p *elf64 $1 = {e_ident = '\\000' \u0026lt;repeats 15 times\u0026gt;, e_type = 0, e_machine = 0, e_version = 0, e_entry = 0, e_phoff = 0, e_shoff = 0, e_flags = 0, e_ehsize = 0, e_phentsize = 0, e_phnum = 0, e_shentsize = 0, e_shnum = 0, e_shstrndx = 0} static void load_program(uint32_t filesz, uint32_t memsz, uint32_t paddr, uint32_t offset) { copy_from_disk((void *)paddr, filesz, offset); char *bss = (void *)(paddr + filesz); for (uint32_t i = filesz; i != memsz; i++) { *bss++ = 0; } } static void load_elf64(Elf64_Ehdr *elf) { Elf64_Phdr *ph = (Elf64_Phdr *)((char *)elf + elf-\u0026gt;e_phoff); for (int i = 0; i \u0026lt; elf-\u0026gt;e_phnum; i++, ph++) { load_program( (uint32_t)ph-\u0026gt;p_filesz, (uint32_t)ph-\u0026gt;p_memsz, (uint32_t)ph-\u0026gt;p_paddr, (uint32_t)ph-\u0026gt;p_offset ); } } load_elf() æ ¹æ® elf æ–‡ä»¶çš„ program header è°ƒç”¨ load_program() å°†å„ä¸ªæ®µåŠ è½½åˆ°å†…å­˜ä¸­ã€‚load_program() ä¸­çš„ä¸€ä¸ªå°ç»†èŠ‚æ˜¯ï¼šfilesz å’Œ memsz çš„å·®å€¼æ˜¯ elf ä¸º .bss èŠ‚é¢„ç•™çš„ç©ºä½ï¼Œæ ¹æ® C ç¨‹åºçš„çº¦å®šï¼Œæ“ä½œç³»ç»Ÿæœ‰ä¹‰åŠ¡å°†å…¶å¡«å……ä¸º 0ã€‚\næ‰§è¡Œå®Œ load_elf() åï¼Œå†æŸ¥çœ‹ 0x8000 é™„è¿‘çš„å†…å­˜ï¼Œå¯ä»¥çœ‹åˆ°å·²ç»è¢«å¡«ä¸Šäº†å†…å®¹ï¼š\n(gdb) p *elf64 $1 = {e_ident = \u0026quot;\\177ELF\\002\\001\\001\\000\\000\\000\\000\\000\\000\\000\\000\u0026quot;, e_type = 2, e_machine = 62, e_version = 1, e_entry = 1049360, e_phoff = 64, e_shoff = 152256, e_flags = 0, e_ehsize = 64, e_phentsize = 56, e_phnum = 2, e_shentsize = 64, e_shnum = 17, e_shstrndx = 16} if (elf32-\u0026gt;e_machine == EM_X86_64) { ((void(*)())(uint32_t)elf64-\u0026gt;e_entry)(); } else { ((void(*)())(uint32_t)elf32-\u0026gt;e_entry)(); } æœ€åè¿™ä¸¤è¡Œï¼Œæ ¹æ®æ¶æ„è·³è½¬åˆ° elf æ–‡ä»¶ä¸­ e_entry æ‰€ä¿å­˜çš„å…¥å£å‡½æ•°åœ°å€ã€‚è¿™é‡Œä½¿ç”¨äº† C è¯­è¨€çš„æŠ€å·§ï¼Œå°†ä¸€ä¸ªåœ°å€å¼ºåˆ¶è½¬æ¢æˆä¸€ä¸ªå‡½æ•°æŒ‡é’ˆå¹¶è°ƒç”¨ä»è€Œå®ç°è·³è½¬ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"a54c71f9070283793c5b4153a2e6c04c","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec09/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec09/","section":"notes","summary":"Bare-metal \u0026amp; Software æ•°å­—ç”µè·¯æœ¬èº«å°±æ˜¯ä¸€ä¸ªå·¨å¤§çš„çŠ¶æ€æœºã€‚ç¡¬ä»¶å‚å•†ä¼šä¿è¯ CPU reset åå¤„ç†å™¨å¤„åœ¨ä¸€ä¸ªç¡®å®šçš„çŠ¶æ€ï¼Œå„ä¸ªå•å…ƒçš„å›ºå®šçš„å€¼ä¼šå†™åœ¨æ‰‹å†Œä¸­ã€‚ä»¥ x86 ä¸ºä¾‹ï¼Œæ‰‹å†Œè§„å®šäº† CPU reset å rip çš„å€¼ä¼šæ˜¯ 0xfff0ï¼ŒEFLAGS çš„å€¼ä¸º 0x2ï¼Œå½“å‰ç¡¬ä»¶è¿è¡Œåœ¨ 16-bit æ¨¡å¼ä¸­ï¼Œä¸å“åº”ä¸­æ–­ã€‚\nCPU åªæ˜¯ä¸€ä¸ªå‘¨è€Œå¤å§‹çš„å–å€¼è¯‘ç æ‰§è¡Œçš„ä¸œè¥¿ï¼Œå› æ­¤å®ƒé©¬ä¸Šä¼šåšçš„äº‹æƒ…å°±æ˜¯å–å‡º 0xfff0 å¤„çš„æŒ‡ä»¤å¹¶æ‰§è¡Œã€‚0xfff0 å¤„é€šå¸¸æ˜¯ä¸€ä¸ªè·³è½¬æŒ‡ä»¤ï¼ŒPC ä¼šè·³è½¬åˆ°å›ºä»¶ä»£ç æ‰§è¡Œã€‚å›ºä»¶ (Firmware) æ˜¯ç¡¬ä»¶å‚å•†å†™æ­»åœ¨ä¸€å— ROM ä¸Šçš„ä»£ç ï¼Œå¸¸è§çš„å›ºä»¶ç¨‹åºæœ‰ BIOS å’Œ UEFI ä¸¤ç§ï¼Œåè€…æ›´åŠ ç°ä»£æœºåˆ¶æ›´åŠ å¤æ‚ï¼Œè¿™é‡Œç®€ä»‹ Legacy BIOS çš„è¿‡ç¨‹ï¼š","tags":null,"title":"Lecture 09: State Machine of OS","type":"docs"},{"authors":null,"categories":null,"content":"Compilers and Modern CPU ç¼–è¯‘å™¨çš„ä½œç”¨æ˜¯å°†æºä»£ç çŠ¶æ€æœº $S$ è½¬æ¢ä¸ºäºŒè¿›åˆ¶ä»£ç çŠ¶æ€æœº $C$ï¼š$C=Compile(S)$ã€‚åªè¦ä¸¤è€…çš„å¯è§‚æµ‹è¡Œä¸ºä¸¥æ ¼ä¸€è‡´ï¼Œç¼–è¯‘å™¨å¯ä»¥éšæ„ä¿®æ”¹æŒ‡ä»¤æ‰§è¡Œçš„é¡ºåºï¼Œç”šè‡³ä¿®æ”¹æŒ‡ä»¤å†…å®¹ã€‚\nç°ä»£ CPU æœ¬è´¨ä¸Šä¹Ÿæ˜¯â€œç¼–è¯‘å™¨â€ï¼šåªè¦ä¿è¯ç¡¬ä»¶çŠ¶æ€æœºçš„å¯è§‚æµ‹è¡Œä¸ºä¸€è‡´ï¼Œå®ƒå¯ä»¥ä¹±åºæ‰§è¡Œï¼Œå¯ä»¥å¤šå‘å°„ï¼Œè¿˜å¯ä»¥å°†æ²¡æœ‰ä¾èµ–å…³ç³»çš„æŒ‡ä»¤â€œå¹¶è¡Œâ€åœ°æ‰§è¡Œï¼Œè¿™å°±æ˜¯æŒ‡ä»¤çº§å¹¶è¡Œ (instruction level parallelism, ilp)ã€‚æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªä¾‹å­æ„Ÿå—è¶…æ ‡é‡å¤„ç†å™¨ (CPI\u0026lt;1ï¼Œå¹³å‡æ¯æ¡æŒ‡ä»¤æ‰€éœ€çš„æ—¶é’Ÿå‘¨æœŸå°äº 1) çš„å¨åŠ›ï¼š\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define LOOP 1000000000ul __attribute__((noinline)) void loop() { for (long i = 0; i \u0026lt; LOOP; i++) { asm volatile( \u0026quot;mov $1, %%rax;\u0026quot; \u0026quot;mov $1, %%rdi;\u0026quot; \u0026quot;mov $1, %%rsi;\u0026quot; \u0026quot;mov $1, %%rdx;\u0026quot; \u0026quot;mov $1, %%rcx;\u0026quot; \u0026quot;mov $1, %%r10;\u0026quot; \u0026quot;mov $1, %%r8;\u0026quot; \u0026quot;mov $1, %%r9;\u0026quot; :::\u0026quot;rax\u0026quot;, \u0026quot;rdi\u0026quot;, \u0026quot;rsi\u0026quot;, \u0026quot;rdx\u0026quot;, \u0026quot;rcx\u0026quot;, \u0026quot;r10\u0026quot;, \u0026quot;r8\u0026quot;, \u0026quot;r9\u0026quot;); } } int main() { clock_t st = clock(); loop(); clock_t ed = clock(); double inst = LOOP * (8 + 2) / 1000000000; double ips = inst / ((ed - st) * 1.0 / CLOCKS_PER_SEC); printf(\u0026quot;%.2lfG instructions/s\\n\u0026quot;, ips); } è¯¥ä»£ç çš„é€»è¾‘æ˜¯åœ¨ loop() ä¸­æ‰§è¡Œ 8 æ¡äº’ç›¸æ²¡æœ‰ä¾èµ–çš„æŒ‡ä»¤ã€‚å³ä½¿ä½¿ç”¨æœ€æ¿€è¿›çš„ä¼˜åŒ–ï¼Œä¸€æ¬¡å¾ªç¯è‡³å°‘è¿˜æœ‰æ›´æ–°å¾ªç¯å˜é‡å’Œè·³è½¬ä¸¤æ¡æŒ‡ä»¤ï¼Œå› æ­¤ä¸€æ¬¡å¾ªç¯è‡³å°‘ 10 æ¡æŒ‡ä»¤ã€‚é€šè¿‡è®¡ç®—æ‰§è¡Œæ—¶é—´å’ŒæŒ‡ä»¤æ¡æ•°æ¥ä¼°ç®—æ¯ç§’é’Ÿå¯ä»¥æ‰§è¡Œçš„æŒ‡ä»¤æ•°ã€‚\nMaybe a bug in GCC?\nå¦‚ä¸‹ä»£ç ç†è®ºä¸Šä¹Ÿå¯ä»¥è¾¾åˆ°ç›¸åŒçš„æ•ˆæœã€‚å®ƒå°†å˜é‡ i ç»‘å®šåˆ°å¯„å­˜å™¨ %rbx ä¸Šï¼Œä»è€Œç¡®ä¿å’Œä¸‹é¢ 8 æ¡æŒ‡ä»¤äº’ä¸å†²çªã€‚\nregister volatile long i asm(\u0026quot;rbx\u0026quot;); for (long i = 0; i \u0026lt; LOOP; i++) { asm volatile( \u0026quot;mov $1, %rax;\u0026quot; \u0026quot;mov $1, %rdi;\u0026quot; \u0026quot;mov $1, %rsi;\u0026quot; \u0026quot;mov $1, %rdx;\u0026quot; \u0026quot;mov $1, %rcx;\u0026quot; \u0026quot;mov $1, %r10;\u0026quot; \u0026quot;mov $1, %r8;\u0026quot;fang shi | \u0026quot;mov $1, %r9;\u0026quot; ); } ä½†äº‹å®ä¸Šï¼Œç¼–è¯‘å®Œæˆåä½¿ç”¨åæ±‡ç¼–æŸ¥çœ‹ï¼Œå¯ä»¥çœ‹åˆ° $i$ è¢«ç»‘å®šåˆ°äº† %rax ä¸Šã€‚\nç¬”è€…ä½¿ç”¨çš„è®¡ç®—æœº CPU å‹å·å¦‚ä¸‹ï¼š\nIntelÂ® Coreâ„¢ i7-10710U CPU @ 1.10GHz Ã— 12 ä½†è¿è¡Œè¯¥ç¨‹åºå¯ä»¥å¾—åˆ°æ¯ç§’é’Ÿèƒ½æ‰§è¡Œçº¦ 17G æ¡æŒ‡ä»¤ï¼ŒCPI è¿œå°äº 1ã€‚è¿™å°±æ˜¯æŒ‡ä»¤çº§å¹¶è¡Œçš„å¨åŠ›ã€‚\nTracer æˆ‘ä»¬æ€»æ˜¯å¸Œæœ›å¯ä»¥åœ¨çŠ¶æ€æœºæ‰§è¡Œçš„è¿‡ç¨‹ä¸­è§‚æµ‹çŠ¶æ€æœºçš„è¡Œä¸ºï¼Œæ¯”å¦‚äº†è§£æ‰€æœ‰ system call çš„æ‰§è¡Œæ—¶é•¿ï¼Œåœ¨æŸä¸ªçŠ¶æ€åœä¸‹æ¥æŸ¥çœ‹å¯„å­˜å™¨ï¼ŒPC çš„å€¼ç­‰ç­‰ï¼Œäºæ˜¯æˆ‘ä»¬æœ‰äº† strace/gdb ç­‰å·¥å…·ã€‚\nShell å‘½ä»¤ï¼šstrace\nåœ¨ strace ååŠ ä¸Š -T é€‰é¡¹å³å¯çœ‹åˆ°æ‰§è¡ŒæŸä¸ªç¨‹åºè¿‡ç¨‹ä¸­æ‰€æœ‰ç³»ç»Ÿè°ƒç”¨çš„è€—æ—¶ã€‚\næˆ‘ä»¬å¹³æ—¶ä½¿ç”¨ GDB é€šå¸¸æ˜¯ step/next/stepi/watchpointï¼Œä½†åŸºäºçŠ¶æ€æœºæ€æƒ³ï¼Œ GDB å¯ä»¥å®ç°æ›´å¤šç‚«é…·çš„åŠŸèƒ½ã€‚æ¯”å¦‚æˆ‘ä»¬å¯ä»¥ç»™æŸä¸ªçŠ¶æ€æ‰“å¿«ç…§ï¼Œä¸‹æ¬¡å¯ä»¥ç›´æ¥ä»å¿«ç…§çŠ¶æ€å¼€å§‹æ‰§è¡Œã€‚å†æ¯”å¦‚æˆ‘ä»¬å¯ä»¥å®ç°åå‘æ‰§è¡Œã€‚\nTime-Travel Debugging è®© GDB å®ç°å›é€€çš„åŠŸèƒ½ï¼Œæœ€ç›´è§‚çš„æƒ³æ³•æ˜¯ä¿å­˜æ¯ä¸ªæ—¶åˆ»çš„å¿«ç…§ã€‚ä½†è¿è¡Œæ—¶åˆ»å¤ªå¤šï¼Œå¿«ç…§è¦ä¿å­˜çš„å†…å®¹ä¹Ÿå¤ªå¤šï¼Œè¿™æ ·åšä»£ä»·å¤ªå¤§ã€‚\näº‹å®ä¸Šï¼Œä¸€æ¡æŒ‡ä»¤å¯¹çŠ¶æ€æœºçš„å½±å“å¾ˆæœ‰é™ï¼šå®ƒå¯èƒ½åªèƒ½æ”¹å˜å¾ˆå°‘çš„å‡ ä¸ªå¯„å­˜å™¨çš„å€¼æˆ–è€…å‡ ä¸ªå†…å­˜åœ°å€çš„å€¼ã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥è®°å½•ä¸€ä¸ªåˆå§‹çš„çŠ¶æ€æœºï¼Œå’Œæ¯æ¡æŒ‡ä»¤æ‰§è¡Œå‰åçŠ¶æ€æœºçš„ diffã€‚è¿™æ ·ä»£ä»·å°±å°å¾—å¤šã€‚æƒ³è¦å®ç°å›é€€ï¼Œæˆ‘ä»¬åªè¦å°†å¢é‡æ’¤é”€å³å¯ã€‚\nGDB çš„å›é€€å’Œé‡æ”¾åŠŸèƒ½å¯¹ä¸€äº› non-deterministic çš„ç¨‹åºçš„è°ƒè¯•æå…¶æœ‰åŠ›ã€‚æ¯”å¦‚å¦‚ä¸‹çš„ç¨‹åºï¼š\n// rdrand.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; int main() { uint64_t volatile val = 48; asm volatile (\u0026quot;rdrand %0\u0026quot;: \u0026quot;=r\u0026quot;(val)); printf(\u0026quot;rdrand returns %016lx\\n\u0026quot;, val); } rdrand æŒ‡ä»¤ä¼šç”Ÿæˆä¸€ä¸ªéšæœºæ•°ï¼Œä»è€Œä½¿ç¨‹åºæ¯æ¬¡è¿è¡Œçš„ç»“æœæ— æ³•é¢„æµ‹ã€‚æ‰“å¼€ GDB åï¼Œä½¿ç”¨ record full å‘½ä»¤æ‰“å¼€è®°å½•ï¼Œè¿™æ ·å°±å¯ä»¥åœ¨é€‚å½“çš„æ—¶åˆ»ä½¿ç”¨ rsi / rs å‘½ä»¤å€’é€€æ‰§è¡Œï¼Œä¸”ä¸€æ—¦æ‰§è¡Œè¿‡ä¸€æ¬¡ rdrand ä¹‹åï¼Œå¤šæ¬¡å€’é€€å›å»å†æ‰§è¡Œï¼Œå˜é‡ val éšæœºåˆ°çš„å€¼éƒ½ä¸ä¼šæ”¹å˜ã€‚\næ³¨ï¼šGDB çš„åå‘æ‰§è¡Œä¸æ˜¯ä¸‡èƒ½çš„ã€‚å¯¹äºä¸€äº›æ¯”è¾ƒå¤æ‚çš„æŒ‡ä»¤ (ä¾‹å¦‚ä¸€äº›ç³»ç»Ÿè°ƒç”¨)ï¼Œè®°å½•çŠ¶æ€æœºå¢é‡æ¯”è¾ƒå›°éš¾ï¼ŒGDB æ²¡æœ‰å®ç°è¿™éƒ¨åˆ†åŠŸèƒ½ã€‚\nRecord \u0026amp; Replay å¦‚æœæˆ‘ä»¬æƒ³è¦é‡ç°ä¸€ä¸ªç¨‹åºæ‰§è¡Œçš„è¡Œä¸ºï¼Œæˆ‘ä»¬åªéœ€è¦è®°å½• non-deterministic çš„æŒ‡ä»¤æ‰§è¡Œå®Œæˆåçš„çŠ¶æ€æœºçŠ¶æ€â€”â€” deterministic çš„æŒ‡ä»¤æ˜¯æ— éœ€è®°å½•çš„ï¼šå‡è®¾ $s_0$ æ‰§è¡Œ 10000 æ¡ç¡®å®šæŒ‡ä»¤ååˆ°è¾¾ $s_1$ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦è®°ä¸‹ $s_0$ å’Œ 10000 å³å¯é‡æ”¾è¿™æ®µæ‰§è¡Œã€‚\nå¯¹äºä¸€ä¸ªå•çº¿ç¨‹çš„ç¨‹åºï¼Œæˆ‘ä»¬éœ€è¦è®°å½•çš„éç¡®å®šäº‹ä»¶åŒ…æ‹¬ç³»ç»Ÿè°ƒç”¨ï¼Œrdrand ç­‰éç¡®å®šæŒ‡ä»¤ç­‰ã€‚Mozilla çš„ rr å·¥å…·å¯ä»¥å¸®åŠ©æˆ‘ä»¬è®°å½•å¹¶é‡æ”¾ä¸€ä¸ªç¨‹åºçš„æ‰§è¡Œè¿‡ç¨‹ã€‚è¿™å¯¹æˆ‘ä»¬è°ƒè¯•ä¸€äº›éç¡®å®šç¨‹åºçš„æ®µé”™è¯¯æå…¶æœ‰å¸®åŠ©ã€‚\nMozilla çš„ rr å·¥å…·\nä½¿ç”¨å‘½ä»¤ rr record ./exec å³å¯è®°å½•è¿è¡Œç¨‹åº exec çš„æ•´ä¸ªè¿‡ç¨‹ã€‚ä½¿ç”¨ rr replay å‘½ä»¤å³å¯é‡æ”¾æ•´ä¸ªè¿‡ç¨‹ã€‚rr ä¼šæ‰“å¼€ä¸€ä¸ª GDBï¼Œæˆ‘ä»¬å¯ä»¥è‡ªç”±åœ°æ‰“æ–­ç‚¹å¹¶è°ƒè¯•ä¹‹å‰è®°å½•çš„æ‰§è¡Œè¿‡ç¨‹ã€‚\nrr å·¥å…·è¦æ±‚ perf_event_paranoid çš„å€¼å°äºç­‰äº 1ï¼Œå¯ä»¥ä½¿ç”¨å‘½ä»¤\nsudo sysctl kernel.perf_event_paranoid=1 ä¿®æ”¹å½“å‰åœ° perf_event_paranoid çš„å€¼ã€‚\nå¯¹äºä¸€ä¸ªå•å¤„ç†å™¨çš„æ“ä½œç³»ç»Ÿï¼Œæˆ‘ä»¬éœ€è¦è®°å½•çš„éç¡®å®šäº‹ä»¶åŒ…æ‹¬ I/O æ“ä½œï¼Œä¸­æ–­ç­‰ç­‰ã€‚æœ‰äº†è¿™äº›è®°å½•æˆ‘ä»¬ä¾¿å¯ä»¥é‡æ”¾æ“ä½œç³»ç»Ÿå¯åŠ¨å’Œè¿è¡Œçš„å…¨è¿‡ç¨‹ã€‚\nProfiling æƒ³è¦åšå¥½æ€§èƒ½ä¼˜åŒ–ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“æ—¶é—´èŠ±åœ¨äº†å“ªé‡Œï¼Œä»€ä¹ˆå¯¹è±¡å ç”¨äº†ç©ºé—´â€¦â€¦è¿™è¦æ±‚æˆ‘ä»¬å¯¹çŠ¶æ€æœºçš„æ‰§è¡Œè¿›è¡ŒçœŸå®ç›‘æµ‹ã€‚ä½†æˆ‘ä»¬çš„ç›‘æµ‹ä¸èƒ½å¤ªé¢‘ç¹ï¼Œä¸èƒ½å¹²æ‰°åˆ°ç¨‹åºçš„æ­£å¸¸å·¥ä½œã€‚ä¸€ä¸ªå¥½çš„æ€è·¯æ˜¯æ¯éš”ä¸€æ®µäº‹ä»¶æš‚åœç¨‹åºï¼Œè§‚å¯Ÿå¹¶è®°å½•çŠ¶æ€æœºçš„ä¿¡æ¯ï¼Œè¿™æ ·ä¾¿å¯ä»¥å¾—åˆ°ç»Ÿè®¡æ„ä¹‰çš„æ€§èƒ½æ‘˜è¦ã€‚\nLinux perf å·¥å…·å¯ä»¥ä¸ºæˆ‘ä»¬æä¾›ä¸€ä¸ªç¨‹åºè¿è¡Œçš„æ€§èƒ½æŠ¥å‘Šã€‚ä»¥ä¹‹å‰çš„ ilp-demo.c ä¸ºä¾‹ï¼Œè¾“å…¥å‘½ä»¤ perf stat ./ilp-demoï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°å¦‚ä¸‹çš„ç²¾ç®€æŠ¥å‘Šï¼Œå…¶ä¸­åŒ…æ‹¬äº†ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œç¼ºé¡µå¼‚å¸¸åˆ†æ”¯é¢„æµ‹ç­‰å¤šç§ä¿¡æ¯ï¼š\nPerformance counter stats for './ilp-demo': 0.56 msec task-clock # 0.449 CPUs utilized 0 context-switches # 0.000 K/sec 0 cpu-migrations # 0.000 K/sec 55 page-faults # 0.098 M/sec 975,780 cycles # 1.731 GHz 751,657 instructions # 0.77 insn per cycle 146,602 branches # 260.113 M/sec 5,119 branch-misses # 3.49% of all branches 0.001255936 seconds time elapsed 0.001289000 seconds user 0.000000000 seconds sys æˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨ perf recode ./exec å’Œ perf report æŸ¥çœ‹è¯¦ç»†çš„æŠ¥å‘Šã€‚\nå®é™…å·¥ç¨‹ä¸­çš„å¤§éƒ¨åˆ†æƒ…å†µæ»¡è¶³â€œäºŒå…«å®šå¾‹â€ï¼š80%çš„æ—¶é—´æ¶ˆè€—åœ¨éå¸¸é›†ä¸­çš„å‡ å¤„ä»£ç ã€‚å› æ­¤ç”¨å¥½ profiling å·¥å…·ï¼Œæœ‰çš„æ”¾çŸ¢è¿›è¡Œä¼˜åŒ–æ‰æ˜¯ç§‘å­¦çš„æ–¹å¼ã€‚\nModel Checker æˆ‘ä»¬ä¹‹å‰ä½¿ç”¨ model checker æ£€æŸ¥å¹¶å‘ bugã€‚äº‹å®ä¸Š model checker å¯ä»¥æ£€æŸ¥æ›´å¤šæˆ‘ä»¬æƒ³è¦çš„ä¸œè¥¿ã€‚æ¯”å¦‚å¦‚ä¸‹ç¨‹åºï¼š\nu32 x = rdrand(); u32 y = rdrand(); if (x \u0026gt; y) if (x * x + y * y == 65) bug(); æˆ‘ä»¬æƒ³çŸ¥é“ç†è®ºä¸Š bug æ˜¯å¦å¯èƒ½ä¼šè¢«è§¦å‘ã€‚ä¸€ä¸ªæœ´ç´ çš„æƒ³æ³•æ˜¯å¯¹æ¯ç§ x å’Œ y çš„å¯èƒ½å–å€¼å»ºç«‹çŠ¶æ€ï¼Œä½†è¿™æ ·çŠ¶æ€ä¼šå¤ªå¤šï¼Œæ— æ³•æ£€æŸ¥ã€‚æ›´é«˜æ•ˆçš„ model checker ä¼šå°†ç›¸ä¼¼çŠ¶æ€â€œåˆå¹¶â€ï¼Œæˆ–è€…å¼•å…¥ç¬¦å·è®¡ç®—â€”â€”ä¸Šè¿°ä¾‹å­ä¸­ï¼Œå¯¹äº rdrand()ï¼Œæˆ‘ä»¬å¯ä»¥ç»™ xï¼Œy èµ‹å€¼ uint32ï¼Œif è¯­å¥çš„çº¦æŸæ¡ä»¶ä¹Ÿä¸€å¹¶å†™å…¥çŠ¶æ€æœºï¼Œæœ€åè°ƒç”¨çº¦æŸæ±‚è§£å™¨ (SMT Solver) å³å¯æ£€æŸ¥ bug æ˜¯å¦ä¼šè¢«è§¦å‘ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"9711f3e560299d9a889ff97bb016ac32","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec10/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec10/","section":"notes","summary":"Compilers and Modern CPU ç¼–è¯‘å™¨çš„ä½œç”¨æ˜¯å°†æºä»£ç çŠ¶æ€æœº $S$ è½¬æ¢ä¸ºäºŒè¿›åˆ¶ä»£ç çŠ¶æ€æœº $C$ï¼š$C=Compile(S)$ã€‚åªè¦ä¸¤è€…çš„å¯è§‚æµ‹è¡Œä¸ºä¸¥æ ¼ä¸€è‡´ï¼Œç¼–è¯‘å™¨å¯ä»¥éšæ„ä¿®æ”¹æŒ‡ä»¤æ‰§è¡Œçš„é¡ºåºï¼Œç”šè‡³ä¿®æ”¹æŒ‡ä»¤å†…å®¹ã€‚\nç°ä»£ CPU æœ¬è´¨ä¸Šä¹Ÿæ˜¯â€œç¼–è¯‘å™¨â€ï¼šåªè¦ä¿è¯ç¡¬ä»¶çŠ¶æ€æœºçš„å¯è§‚æµ‹è¡Œä¸ºä¸€è‡´ï¼Œå®ƒå¯ä»¥ä¹±åºæ‰§è¡Œï¼Œå¯ä»¥å¤šå‘å°„ï¼Œè¿˜å¯ä»¥å°†æ²¡æœ‰ä¾èµ–å…³ç³»çš„æŒ‡ä»¤â€œå¹¶è¡Œâ€åœ°æ‰§è¡Œï¼Œè¿™å°±æ˜¯æŒ‡ä»¤çº§å¹¶è¡Œ (instruction level parallelism, ilp)ã€‚æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªä¾‹å­æ„Ÿå—è¶…æ ‡é‡å¤„ç†å™¨ (CPI\u0026lt;1ï¼Œå¹³å‡æ¯æ¡æŒ‡ä»¤æ‰€éœ€çš„æ—¶é’Ÿå‘¨æœŸå°äº 1) çš„å¨åŠ›ï¼š\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define LOOP 1000000000ul __attribute__((noinline)) void loop() { for (long i = 0; i \u0026lt; LOOP; i++) { asm volatile( \u0026quot;mov $1, %%rax;\u0026quot; \u0026quot;mov $1, %%rdi;\u0026quot; \u0026quot;mov $1, %%rsi;\u0026quot; \u0026quot;mov $1, %%rdx;\u0026quot; \u0026quot;mov $1, %%rcx;\u0026quot; \u0026quot;mov $1, %%r10;\u0026quot; \u0026quot;mov $1, %%r8;\u0026quot; \u0026quot;mov $1, %%r9;\u0026quot; :::\u0026quot;rax\u0026quot;, \u0026quot;rdi\u0026quot;, \u0026quot;rsi\u0026quot;, \u0026quot;rdx\u0026quot;, \u0026quot;rcx\u0026quot;, \u0026quot;r10\u0026quot;, \u0026quot;r8\u0026quot;, \u0026quot;r9\u0026quot;); } } int main() { clock_t st = clock(); loop(); clock_t ed = clock(); double inst = LOOP * (8 + 2) / 1000000000; double ips = inst / ((ed - st) * 1.","tags":null,"title":"Lecture 10: Application of State Machines","type":"docs"},{"authors":null,"categories":null,"content":"åœ¨ thread-os.c ä¸­ï¼Œæ“ä½œç³»ç»Ÿå¯åŠ¨åä¼šåˆå§‹åŒ–è‹¥å¹²ä¸ªçº¿ç¨‹ (çš„çŠ¶æ€æœº)ï¼Œæˆ–è€…è¯´åŠ è½½è‹¥å¹²ä¸ªç¨‹åºã€‚çœŸæ­£çš„æ“ä½œç³»ç»Ÿå¯åŠ¨åä¼šåˆ›å»ºç¬¬ä¸€ä¸ªè¿›ç¨‹ã€‚å¦‚æœæŸ¥çœ‹ Linux çš„æºç ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼š\nif (!try_to_run_init_process(\u0026quot;/sbin/init\u0026quot;) || !try_to_run_init_process(\u0026quot;/etc/init\u0026quot;) || !try_to_run_init_process(\u0026quot;/bin/init\u0026quot;) || !try_to_run_init_process(\u0026quot;/bin/sh\u0026quot;)) return 0; panic(\u0026quot;No working init found. Try passing init= option to kernel. \u0026quot; \u0026quot;See Linux Documentation/admin-guide/init.rst for guidance.\u0026quot;); å†…æ ¸ä¼šæŒ‰ç…§ä¸€ä¸ªç‰¹å®šçš„é¡ºåºåŠ è½½â€œç¬¬ä¸€ä¸ªç¨‹åºâ€ï¼Œå¦‚æœéƒ½æ— æ³•åŠ è½½ï¼ŒLinux kernel ä¼šç›´æ¥æ‹’ç»å¯åŠ¨ã€‚\nA Minimal Linux æˆ‘ä»¬å¯ä»¥åœ¨ qemu ä¸Šè°ƒè¯• vmlinuz å†…æ ¸ã€‚å¦‚ä¸‹å‘½ä»¤ä¼šå¯åŠ¨ä¸€ä¸ªæ²¡æœ‰å›¾å½¢ç•Œé¢ï¼Œ128M å†…å­˜çš„ linux å†…æ ¸ï¼š\nqemu-system-x86_64 \\ -nographic \\ -serial mon:stdio \\ -m 128 \\ -kernel vmlinuz \\ -initrd build/initramfs.cpio.gz \\ -append \u0026quot;console=ttyS0 quiet acpi=off\u0026quot; å…¶ä¸­ initramfs.cpio.gz æ˜¯å†…æ ¸å¯åŠ¨æ—¶å­˜æ”¾åœ¨å†…å­˜ä¸­çš„ä¸€ä¸ªå¾ˆå°çš„æ–‡ä»¶ç³»ç»Ÿçš„é•œåƒï¼Œå®ƒæ‰“åŒ…äº†å¦‚ä¸‹ç›®å½•ç»“æ„ä¸­åœ° initramfs ä¸­çš„å†…å®¹ã€‚\nâ”œâ”€â”€ initramfs â”‚Â â”œâ”€â”€ bin â”‚Â â”‚Â â””â”€â”€ busybox â”‚Â â””â”€â”€ init â”œâ”€â”€ Makefile â””â”€â”€ vmlinuz å¯åŠ¨å†…æ ¸åæˆ‘ä»¬ä¼šå¾—åˆ°ä¸€ä¸ª shellï¼Œå½“å‰çš„ç¯å¢ƒå¾ˆç®€é™‹ï¼Œä½†æˆ‘ä»¬ä»ç„¶å¯ä»¥ç”¨ /bin/busybox å‘½ä»¤ çš„æ–¹å¼ä½¿ç”¨ä¸€äº› busybox å†…ç½®çš„å‘½ä»¤ï¼Œæ¯”å¦‚ ls å’Œ catã€‚\næ“ä½œç³»ç»Ÿå¯åŠ¨çš„ç¬¬ä¸€ä¸ªè¿›ç¨‹æ˜¯ initã€‚init æ˜¯ä¸€ä¸ªè„šæœ¬ï¼Œæœ‰ä¸€è¡Œå‘½ä»¤ï¼š/bin/busybox shï¼Œå®ƒå¯åŠ¨ä¸€ä¸ª shellã€‚æˆ‘ä»¬å¯ä»¥è¯•è¯•å°† /bin/busybox sh æ¢æˆ /bin/busybox echo helloï¼šå¯ä»¥çœ‹åˆ°æ“ä½œç³»ç»Ÿç¡®å®æ‰“å°äº† helloï¼Œä½†éšå³æŠ¥äº† kernel panicã€‚è¿™æ˜¯å› ä¸ºåˆå§‹è¿›ç¨‹ init è¿”å›äº†ã€‚\nå°½ç®¡ç°åœ¨çš„ç¯å¢ƒå¾ˆç®€é™‹ï¼Œä½†æˆ‘ä»¬æ‰§è¡Œä¸€äº›ç®€å•çš„ä»£ç å°±å¯ä»¥è·å¾—ä¸°å¯Œçš„ä½“éªŒï¼š\nc1=\u0026quot;arch ash base64 cat chattr chgrp chmod chown conspy cp cpio cttyhack date dd df dmesg dnsdomainname dumpkmap echo ed egrep false fatattr fdflush fgrep fsync getopt grep gunzip gzip hostname hush ionice iostat ipcalc kbd_mode kill link linux32 linux64 ln login ls lsattr lzop makemime mkdir mknod mktemp more mount mountpoint mpstat mt mv netstat nice nuke pidof ping ping6 pipe_progress printenv ps pwd reformime resume rev rm rmdir rpm run-parts scriptreplay sed setarch setpriv setserial sh sleep stat stty su sync tar touch true umount uname usleep vi watch zcat\u0026quot; c2=\u0026quot;[ [[ awk basename bc beep blkdiscard bunzip2 bzcat bzip2 cal chpst chrt chvt cksum clear cmp comm crontab cryptpw cut dc deallocvt diff dirname dos2unix dpkg dpkg-deb du dumpleases eject env envdir envuidgid expand expr factor fallocate fgconsole find flock fold free ftpget ftpput fuser groups hd head hexdump hexedit hostid id install ipcrm ipcs killall last less logger logname lpq lpr lsof lspci lsscsi lsusb lzcat lzma man md5sum mesg microcom mkfifo mkpasswd nc nl nmeter nohup nproc nsenter nslookup od openvt passwd paste patch pgrep pkill pmap printf pscan\u0026quot; c3=\u0026quot;pstree pwdx readlink realpath renice reset resize rpm2cpio runsv runsvdir rx script seq setfattr setkeycodes setsid setuidgid sha1sum sha256sum sha3sum sha512sum showkey shred shuf smemcap softlimit sort split ssl_client strings sum sv svc svok tac tail taskset tcpsvd tee telnet test tftp time timeout top tr traceroute traceroute6 truncate ts tty ttysize udhcpc6 udpsvd unexpand uniq unix2dos unlink unlzma unshare unxz unzip uptime users uudecode uuencode vlock volname w wall wc wget which who whoami whois xargs xxd xz xzcat yes\u0026quot; for cmd in $c1 $c2 $c3; do /bin/busybox ln -s /bin/busybox /bin/$cmd done mkdir -p /proc \u0026amp;\u0026amp; mount -t proc none /proc mkdir -p /sys \u0026amp;\u0026amp; mount -t sysfs none /sys export PS1='(linux) ' ç°åœ¨æˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨å‘½ä»¤ä¸å†éœ€è¦åŠ  /bin/busybox çš„å‰ç¼€ (å¾—ç›Šäºä»£ç ä¸­çš„è½¯é“¾æ¥)ï¼Œæˆ‘ä»¬è¿˜æŒ‚è½½äº† procfs å’Œ sysfsã€‚å¯ä»¥ä½¿ç”¨ ps ç­‰å‘½ä»¤æŸ¥çœ‹è¿›ç¨‹ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬å¯ä»¥è¿è¡Œä»»ä½•æ”¾å…¥åˆ°æ–‡ä»¶ç³»ç»Ÿä¸­çš„ç¨‹åºï¼šä¾‹å¦‚ä¹‹å‰çš„ç¤ºä¾‹ä»£ç  minimal.S å’Œ logisim.cï¼Œåªè¦æ˜¯é™æ€é“¾æ¥å¾—åˆ°çš„å¯æ‰§è¡Œæ–‡ä»¶éƒ½å¯ä»¥åœ¨æˆ‘ä»¬çš„ minimal Linux ä¸­ç›´æ¥è¿è¡Œã€‚\nè¿™ä¸€åˆ‡è¯´æ˜æ“ä½œç³»ç»Ÿæ²¡æœ‰ä»€ä¹ˆç¥ç§˜çš„ï¼š**å†…æ ¸åˆ›å»ºäº†ç¬¬ä¸€ä¸ªè¿›ç¨‹ initï¼Œç„¶åè¿™ä¸ªè¿›ç¨‹é€šè¿‡å„ç§å„æ ·çš„ç³»ç»Ÿè°ƒç”¨å°±èƒ½åˆ›é€ å…¨ä¸–ç•Œã€‚**å®Œæˆä¸€åˆ‡ä»¥åæ“ä½œç³»ç»Ÿå°†é€€åˆ°å¹•åæˆä¸ºä¸€ä¸ªâ€œä¸­æ–­å¤„ç†ç¨‹åºâ€ã€‚æ­¤å¤–ï¼Œæ“ä½œç³»ç»Ÿä¸ºåº”ç”¨ç¨‹åºæä¾›å„ç±» APIï¼Œè®©åº”ç”¨ç¨‹åºåˆ›å»º/ç®¡ç†è¿›ç¨‹ï¼Œåœ°å€ç©ºé—´ï¼Œæ–‡ä»¶ç³»ç»Ÿç­‰ã€‚\nfork() fork() çš„å«ä¹‰éå¸¸ç®€å•ï¼šå®ƒä¼šå°†å½“å‰è¿›ç¨‹çš„çŠ¶æ€æœºå®Œå…¨å¤åˆ¶ä¸€éï¼Œä½œä¸ºå½“å‰è¿›ç¨‹çš„å­è¿›ç¨‹ã€‚è¿™ä¸¤ä¸ªè¿›ç¨‹å‡ ä¹å®Œå…¨ä¸€æ ·ï¼šç›¸åŒçš„åœ°å€ç©ºé—´ï¼Œç›¸åŒçš„å¯„å­˜å™¨å€¼â€¦â€¦ (å½“ç„¶ï¼Œè¿›ç¨‹å·æ˜¯ä¸åŒçš„)ï¼Œé™¤äº† fork() çš„è¿”å›å€¼åœ¨ä¸¤ä¸ªè¿›ç¨‹ä¸­ä¸åŒï¼šfork() åœ¨çˆ¶è¿›ç¨‹ä¸­è¿”å›å­è¿›ç¨‹çš„è¿›ç¨‹å·ï¼Œåœ¨å­è¿›ç¨‹ä¸­è¿”å› 0ã€‚\nFork Bomb\nçŠ¶æ€æœºçš„å¤åˆ¶ä¹Ÿéœ€è¦æ¶ˆè€—ä¸€å®šçš„èµ„æºã€‚å¦‚ä¸‹çš„ä¸€æ®µä»£ç å¯ä»¥è®© OS å´©æºƒï¼š\n:() { :|:\u0026amp; };: å°†å…¶æ ¼å¼åŒ–åå¯ä»¥çœ‹å‡ºå®ƒçš„åŸç†ï¼š\n:() { : | : \u0026amp; }; : bash å…è®¸å†’å·ä½œä¸ºæ ‡è¯†ç¬¦ã€‚: è¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯ç”¨ fork åˆ›å»ºä¸¤ä¸ªè‡ªå·±ï¼Œç”¨ç®¡é“è¿æ¥èµ·æ¥ï¼Œç„¶åæ”¾åˆ°åå°æ‰§è¡Œã€‚è¿™æ ·è¿™ä¸ªè„šæœ¬å°±ä¼šåƒé“¾å¼ååº”ä¸€æ ·ä¸æ–­ç”Ÿæˆå¾ˆå¤šå‡½æ•°ï¼Œç›´è‡³ç³»ç»Ÿèµ„æºè€—å°½ã€‚\nExample: fork-demo.c // fork-demo.c #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { pid_t pid1 = fork(); pid_t pid2 = fork(); pid_t pid3 = fork(); printf(\u0026quot;Hello World from (%d, %d, %d)\\n\u0026quot;, pid1, pid2, pid3); } è¿è¡Œè¿™æ®µç¨‹åºï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°æ‰€æœ‰çš„ 8 ç§å¯èƒ½çš„ç»“æœï¼šè¿›ç¨‹å·æ˜¯ 0 / çœŸå®å€¼ã€‚æˆ‘ä»¬å¯ä»¥ç”»å‡ºçŠ¶æ€æœºä¸­çš„ä¸€æ¡è·¯å¾„æ¥ç†è§£è¿™ä¸ªè¾“å‡º (å³ä¸è€ƒè™‘å¤šä¸ªè¿›ç¨‹æ—¶ç¨‹åºçš„ non-deterministic è¡Œä¸ºï¼Œæ€»æ˜¯æŒ‘é€‰å¯ä»¥ç»§ç»­æ‰§è¡Œçš„è¿›ç¨‹å·æœ€å°çš„è¿›ç¨‹èµ°ä¸‹ä¸€æ­¥)ï¼š\nExample: fork-printf.c // fork-printf.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; int main(int argc, char *argv[]) { int n = 2; for (int i = 0; i \u0026lt; n; i++) { fork(); printf(\u0026quot;Hello\\n\u0026quot;); } for (int i = 0; i \u0026lt; n; i++) { wait(NULL); } } ä»æŠ½è±¡çš„çŠ¶æ€æœºçš„è§’åº¦åˆ†æï¼Œåˆšå¼€å§‹åªæœ‰ä¸€ä¸ªè¿›ç¨‹ï¼Œç¬¬ä¸€è½®ä¸€ä¸ªè¿›ç¨‹å˜æˆä¸¤ä¸ªè¿›ç¨‹ï¼Œå¹¶åˆ†åˆ«æ‰“å° helloï¼›ç¬¬äºŒè½®ä¸¤ä¸ªè¿›ç¨‹å˜æˆ 4 ä¸ªè¿›ç¨‹ï¼Œå¹¶åˆ†åˆ«æ‰“å° helloï¼Œæœ€ååº”è¯¥æ€»å…±æœ‰ 6 ä¸ª helloã€‚\nè¿è¡Œè¯¥ç¨‹åºå¯ä»¥çœ‹åˆ°ï¼Œç»ˆç«¯ä¸Šç¡®å®è¾“å‡ºäº† 6 ä¸ª helloï¼Œä½†è¯¡å¼‚çš„äº‹æƒ…æ˜¯ï¼šå¦‚æœæˆ‘ä»¬ç”¨ç®¡é“æˆ–è€…é‡å®šå‘åˆ°æ–‡ä»¶çš„æ–¹å¼ï¼Œéƒ½ä¼šå¾—åˆ° 8 ä¸ª helloã€‚\n./fork-printf | cat # 8ä¸ªhello ./fork-printf \u0026gt; output # 8ä¸ªhello ./fork-printf | wc -l # 8 è¿™ä»¶â€œè¯¡å¼‚â€çš„äº‹æƒ…å’Œ printf çš„ç¼“å†²åŒºæœ‰å…³ã€‚æˆ‘ä»¬è®¤ä¸º printf çš„è¯­ä¹‰æ˜¯ç«‹å³è¾“å‡ºç»™å®šçš„å­—ç¬¦ä¸²ï¼Œä½† printf ä¸ºäº†æ€§èƒ½è€ƒè™‘ (å°½å¯èƒ½å°‘åœ°ä¸ io äº¤äº’)ï¼Œä¼šè®¾ç½® bufferï¼Œå°†è¦è¾“å‡ºçš„å†…å®¹å…ˆé¢„ç•™åœ¨ buffer ä¸­ï¼Œå¾… buffer æ»¡äº† / è¿›ç¨‹ç»“æŸæ—¶å†å°† buffer ä¸­çš„å†…å®¹ä¸€å¹¶è¾“å‡ºã€‚\nprintf æ ¹æ®æ ‡å‡†è¾“å‡ºæŒ‡å‘çš„æ–‡ä»¶ä¸åŒä¼šä½¿ç”¨ä¸åŒçš„ bufferã€‚å½“ stdout æ˜¯ tty æ—¶ï¼Œprintf ä½¿ç”¨ line bufferï¼Œå³é‡åˆ°æ¢è¡Œç¬¦ä¼šæ¸…ç©ºä¸€æ¬¡ bufferï¼Œæ‰€ä»¥å½“æˆ‘ä»¬è¾“å‡ºåˆ°ç»ˆç«¯æ—¶çœ‹åˆ°çš„ç»“æœæ˜¯ 6 ä¸ªï¼›å½“ stdout æ˜¯ç®¡é“æˆ–è€…æ–‡ä»¶æ—¶ï¼Œprintf ä½¿ç”¨ full bufferï¼Œåªæœ‰ buffer æ»¡äº†æ‰ä¼šæ¸…ç©ºã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç¬¬ä¸€è½®çš„ä¸¤ä¸ªè¿›ç¨‹ä¸ä¼šè¾“å‡º helloï¼Œè€Œæ˜¯ä¼šå°† hello ä¿å­˜åœ¨ buffer ä¸­ï¼Œç¬¬äºŒè½®ä¸¤ä¸ªè¿›ç¨‹å˜ 4 ä¸ªè¿›ç¨‹æ—¶ï¼Œfork() å¤åˆ¶çŠ¶æ€æœºï¼Œå½“ç„¶ä¹Ÿä¼šå¤åˆ¶ buffer é‡Œçš„å†…å®¹ï¼Œå› æ­¤æ–°ç”Ÿæˆçš„ä¸¤ä¸ªè¿›ç¨‹çš„ buffer é‡Œè‡ªå¸¦ä¸€ä¸ª helloï¼Œå†æ‰§è¡Œ printf åï¼Œæ¯ä¸ªè¿›ç¨‹çš„ buffer é‡Œéƒ½æœ‰ä¸¤ä¸ª helloã€‚è¿›ç¨‹ç»“æŸæ—¶å†…æ ¸æ¸…ç©º bufferï¼Œäºæ˜¯ 4 ä¸ªè¿›ç¨‹æ¯ä¸ªæ‰“å°ä¸¤ä¸ª helloï¼Œæœ€ç»ˆæœ‰ 8 ä¸ª helloã€‚\nå¦‚æœæˆ‘ä»¬åœ¨ç¨‹åºå¼€å¤´åŠ ä¸€å¥ setbuf(stdout, NULL)ï¼ŒæŒ‡å®š stdout ä¸ä½¿ç”¨ bufferï¼Œæˆ–è€…åœ¨ printf() ä¹‹ååŠ  ffush(stdout) ï¼Œé‚£ä¹ˆå„ç§æƒ…å†µä¸‹æˆ‘ä»¬éƒ½ä¼šå¾—åˆ° 6 ä¸ª helloã€‚\nTip: setbuf()\nsetbuf() å‡½æ•°å¯ä»¥æŒ‡å®šå‘æŸä¸ªæ–‡ä»¶è¾“å‡ºæ—¶ä½¿ç”¨çš„ bufferã€‚ä¸ä¹‹ç›¸å…³çš„è¿˜æœ‰ setvbuf() ï¼ˆå¯ä»¥ç”¨ _IONBF _IOLBF _IOFBF åˆ¶å®šæ— ç¼“å†²ã€è¡Œç¼“å†²ã€å…¨ç¼“å†²ï¼‰ç­‰ã€‚\nä½¿ç”¨ setbuf() æ—¶è¦å°å¿ƒçš„ä¸€ç‚¹æ˜¯æˆ‘ä»¬æ³¨å†Œçš„ buffer ä¸èƒ½åœ¨è¾“å‡ºæµè¢«å…³é—­ä¹‹å‰è¢«é‡Šæ”¾ï¼Œä¾‹å¦‚ä¸‹é¢çš„ç¨‹åºå°±æ˜¯é”™è¯¯çš„ (undefined behavior)ï¼š\nint main () { char buf[64]; setbuf(stdout, buf); printf(\u0026quot;Hello, world\\n\u0026quot;); return 0; } è®¡ç®—æœºç³»ç»Ÿé‡Œæ²¡æœ‰é­”æ³•ã€‚æœºå™¨æ°¸è¿œæ˜¯å¯¹çš„ã€‚\nexecve() execve() çš„ä½œç”¨æ˜¯é‡ç½®ä¸€ä¸ªçŠ¶æ€æœºï¼Œè¿è¡Œ execve() çš„å‚æ•°ä¸­æ‰€å†™çš„ç¨‹åºã€‚å¦‚æœè¯¥ç³»ç»Ÿè°ƒç”¨æ‰§è¡ŒæˆåŠŸï¼Œå®ƒä¸ä¼šè¿”å›ï¼Œå®ƒåé¢çš„æŒ‡ä»¤ä¹Ÿä¸ä¼šè¢«æ‰§è¡Œã€‚ç»“åˆè¿ç”¨ fork() å’Œ execve()ï¼Œæˆ‘ä»¬ä¾¿å¯ä»¥åˆ›å»ºæ–°çš„çŠ¶æ€æœºå¹¶è¿è¡Œæ–°çš„ç¨‹åºã€‚execve() çš„å£°æ˜å¦‚ä¸‹ï¼š\nint execve(const char *filename, char * const argv, char * const envp); å…¶ä¸­ filename ä¸ºæƒ³è¦åŠ è½½çš„ç¨‹åºï¼Œargv ä¸ºä¼ ç»™æ–°ç¨‹åºå…¥å£å‡½æ•°çš„å‚æ•°ï¼Œenvp ä¸ºç¯å¢ƒå˜é‡åˆ—è¡¨ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹ç¨‹åºï¼š\n// execve-demo.c #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { char * const argv[] = { \u0026quot;/bin/bash\u0026quot;, \u0026quot;-c\u0026quot;, \u0026quot;env\u0026quot;, NULL, }; char * const envp[] = { \u0026quot;HELLO=WORLD\u0026quot;, NULL, }; execve(argv[0], argv, envp); printf(\u0026quot;Should not reach here!\\n\u0026quot;); } å®ƒä½¿ç”¨ execve() æ‰§è¡Œäº†å‘½ä»¤ /bin/bash -c env æ¥æ‰“å°ç¯å¢ƒå˜é‡ã€‚è¿è¡Œè¯¥ç¨‹åºï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°æˆ‘ä»¬æŒ‡å®šçš„ç¯å¢ƒå˜é‡ HELLO=WORLD è¢«æ‰“å°ï¼Œä¸” \u0026ldquo;should not reach here\u0026rdquo; æ²¡æœ‰è¢«æ‰“å°ã€‚\nç³»ç»Ÿä¸­æœ‰å¾ˆå¤šæœ‰æ„æ€çš„ç¯å¢ƒå˜é‡ã€‚ä¾‹å¦‚æˆ‘ä»¬å¯ä»¥é…ç½® $AM_HOME æ¥ç®€å†™ç›®å½•ï¼›bash ä¸­çš„ç¯å¢ƒå˜é‡ PS1 å†³å®šäº†å‘½ä»¤è¡Œæç¤ºç¬¦é•¿ä»€ä¹ˆæ ·å­ï¼›execvp()/gcc ç­‰ä¼šæ ¹æ® $PATH ä¸­çš„ç›®å½•ä¸€ä¸ªä¸€ä¸ªå»æ‰¾æœ‰æ²¡æœ‰æˆ‘ä»¬æŒ‡å®šçš„ç¨‹åº etcã€‚æˆ‘ä»¬å¯ä»¥ hack è¿™ä¸ªè¡Œä¸ºï¼š\nPATH= /bin/gcc program.c ä¾¿ä¼šçœ‹åˆ°\ngcc: fatal error: cannot execute â€˜asâ€™: execvp: No such file or directory compilation terminated. _exit() exit() ç”¨äºé”€æ¯ä¸€ä¸ªçŠ¶æ€æœºã€‚_exit(int status) ä¼šé”€æ¯å½“å‰çŠ¶æ€æœºï¼Œå¹¶å…è®¸æœ‰ä¸€ä¸ªè¿”å›å€¼ã€‚å­è¿›ç¨‹è¢«é”€æ¯äº†ä¼šé€šçŸ¥çˆ¶è¿›ç¨‹ã€‚è¿™å…¶ä¸­æœ‰ä¸€äº›å€¼å¾—æ€è€ƒçš„é—®é¢˜ï¼Œä¾‹å¦‚å¦‚æœè¿™æ˜¯ä¸€ä¸ªå¤šçº¿ç¨‹ç¨‹åºï¼Œexit() åº”å½“é”€æ¯å½“å‰çš„çº¿ç¨‹è¿˜æ˜¯å½“å‰çš„è¿›ç¨‹ï¼Ÿ\n// exit-demo.c #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; void func() { printf(\u0026quot;Goodbye, Cruel OS World!\\n\u0026quot;); } int main(int argc, char *argv[]) { atexit(func); setvbuf(stdout, NULL, _IOFBF, 1024); printf(\u0026quot;Unflushed Buffer\\n\u0026quot;); if (argc \u0026lt; 2) return EXIT_FAILURE; if (strcmp(argv[1], \u0026quot;exit\u0026quot;) == 0) exit(0); if (strcmp(argv[1], \u0026quot;_exit\u0026quot;) == 0) _exit(0); if (strcmp(argv[1], \u0026quot;__exit\u0026quot;) == 0) syscall(SYS_exit, 0); } exit-demo.c å±•ç¤ºäº†å„ç§ä¸åŒçš„ exit æ–¹æ³•è¡Œä¸ºçš„ä¸åŒï¼Œå…¶ä¸­ atexit() æ³¨å†Œäº†ä¸€ä¸ªåœ¨ exit() çš„æ—¶å€™ä¼šè°ƒç”¨çš„å‡½æ•°ã€‚å„ç§è¿è¡Œæ–¹å¼çš„ç»“æœå¦‚ä¸‹ï¼š\nå‘½ä»¤ æ‰§è¡Œå†…å®¹ ç³»ç»Ÿè°ƒç”¨ æ˜¯å¦è°ƒç”¨ atexit è¾“å‡ºå†…å®¹ ./exit-demo return EXIT_FAILURE exit_group(1) æ˜¯ func \u0026amp; buffer ./exit-demo exit exit(0) exit_group(0) æ˜¯ func \u0026amp; buffer ./exit-demo _exit _exit(0) exit_group(0) å¦ æ—  ./exit-demo __exit syscall(SYS_exit, 0) exit(0) å¦ æ—  æ³¨ï¼šC ç¨‹åºä¸­çš„ exit(0) æ˜¯ stdlib.h ä¸­çš„ libc å‡½æ•°ã€‚\næ³¨ï¼šexit_group() ç³»ç»Ÿè°ƒç”¨ä¼šç»ˆæ­¢å½“å‰è¿›ç¨‹çš„æ‰€æœ‰çº¿ç¨‹ï¼Œè€Œ exit() ç³»ç»Ÿè°ƒç”¨åªç»ˆæ­¢å½“å‰çº¿ç¨‹ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"0253c6034a3713d7ce44186a85eb3386","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec11/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec11/","section":"notes","summary":"åœ¨ thread-os.c ä¸­ï¼Œæ“ä½œç³»ç»Ÿå¯åŠ¨åä¼šåˆå§‹åŒ–è‹¥å¹²ä¸ªçº¿ç¨‹ (çš„çŠ¶æ€æœº)ï¼Œæˆ–è€…è¯´åŠ è½½è‹¥å¹²ä¸ªç¨‹åºã€‚çœŸæ­£çš„æ“ä½œç³»ç»Ÿå¯åŠ¨åä¼šåˆ›å»ºç¬¬ä¸€ä¸ªè¿›ç¨‹ã€‚å¦‚æœæŸ¥çœ‹ Linux çš„æºç ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼š\nif (!try_to_run_init_process(\u0026quot;/sbin/init\u0026quot;) || !try_to_run_init_process(\u0026quot;/etc/init\u0026quot;) || !try_to_run_init_process(\u0026quot;/bin/init\u0026quot;) || !try_to_run_init_process(\u0026quot;/bin/sh\u0026quot;)) return 0; panic(\u0026quot;No working init found. Try passing init= option to kernel. \u0026quot; \u0026quot;See Linux Documentation/admin-guide/init.rst for guidance.","tags":null,"title":"Lecture 11: Processes in Operating Systems","type":"docs"},{"authors":null,"categories":null,"content":"Address Space åœ¨ C ç¨‹åºä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨æŒ‡é’ˆè®¿é—®ä»»ä½•å¯ä»¥è®¿é—®çš„ä¸œè¥¿ï¼šæ¯”å¦‚ main() å‡½æ•°çš„é¦–åœ°å€ï¼Œè¿™ä¸ªåœ°å€å­˜å‚¨çš„å†…å®¹å°±æ˜¯ main() çš„ç¬¬ä¸€æ¡æŒ‡ä»¤ã€‚å¦‚æœæˆ‘ä»¬éšä¾¿è®¿é—®ä¸€ä¸ªå¥‡æ€ªçš„åœ°å€ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°æ®µé”™è¯¯ï¼›å¦‚æœæˆ‘ä»¬å¾€ main() çš„é¦–åœ°å€å¤„å†™ä¸œè¥¿ï¼Œæˆ‘ä»¬ä¹Ÿä¼šå¾—åˆ°æ®µé”™è¯¯ã€‚\nå‘½ä»¤è¡Œå·¥å…· pmap å¯ä»¥å¸®åŠ©æˆ‘ä»¬è§‚å¯Ÿä¸€ä¸ªè¿›ç¨‹çš„åœ°å€ç©ºé—´ã€‚æˆ‘ä»¬ä»¥æœ€å°çš„ç¨‹åº minimal.S ä¸ºä¾‹ï¼Œåœ¨ GDB ä¸­è°ƒè¯•æ—¶å¯ä»¥ç”¨ info inferiors æŸ¥çœ‹è¿›ç¨‹å·ï¼Œå¹¶ç”¨ pmap pid æ¥æŸ¥çœ‹åœ°å€ç©ºé—´ï¼š\n0000000000400000 4K r---- a.out 0000000000401000 4K r-x-- a.out 00007ffff7ff9000 16K r---- [ anon ] 00007ffff7ffd000 8K r-x-- [ anon ] 00007ffffffde000 132K rw--- [ stack ] ffffffffff600000 4K --x-- [ anon ] total 168K 0x401000 ä¹‹åçš„å†…å®¹æ˜¯ä»£ç æ®µï¼Œè¿™ä¸€æ®µæœ‰å¯æ‰§è¡Œçš„æƒé™ã€‚æ­¤å¤–æˆ‘ä»¬åœ¨æ ˆä¸Šæœ‰ç¯å¢ƒå˜é‡ï¼Œå‘½ä»¤è¡Œå‚æ•°ç­‰ã€‚\næˆ‘ä»¬å¯ä»¥é€šè¿‡ strace pmap pid æ¥è§‚å¯Ÿ pmap æ˜¯å¦‚ä½•å®ç°çš„ã€‚å¯ä»¥çœ‹åˆ° pmap ä½¿ç”¨äº† openat() ç³»ç»Ÿè°ƒç”¨æ¥æ‰“å¼€ procfs ä¸­çš„ /proc/pid/maps æ–‡ä»¶ã€‚æŸ¥çœ‹è¿™ä¸ªæ–‡ä»¶ï¼Œæˆ‘ä»¬èƒ½çœ‹åˆ°æ¯” pmap æ›´ä¸°å¯Œçš„åœ°å€ç©ºé—´ä¿¡æ¯ã€‚\nStatically Link æˆ‘ä»¬å°è¯•æŸ¥çœ‹ä¸€ä¸ªé™æ€é“¾æ¥çš„äºŒè¿›åˆ¶æ–‡ä»¶ (ç©º main() å‡½æ•°ç¼–è¯‘å¾—åˆ°) çš„åœ°å€ç©ºé—´ï¼š\n0000000000400000 4K r---- a.out 0000000000401000 560K r-x-- a.out 000000000048d000 160K r---- a.out 00000000004b5000 16K r---- a.out 00000000004b9000 12K rw--- a.out 00000000004bc000 140K rw--- [ anon ] 00007ffff7ff9000 16K r---- [ anon ] 00007ffff7ffd000 8K r-x-- [ anon ] 00007ffffffde000 132K rw--- [ stack ] ffffffffff600000 4K --x-- [ anon ] total 1052K å¯ä»¥çœ‹åˆ°çš„åœ°å€ç©ºé—´çš„å†…å®¹æ›´åŠ ä¸°å¯Œã€‚ç¬¬ä¸€ä¸ªæ®µæ˜¯ ELF headerï¼Œåé¢çš„å¯è¯»å¯æ‰§è¡Œæ®µæ˜¯ä»£ç æ®µï¼Œå†åé¢æœ‰åªè¯»æ•°æ®æ®µç­‰ç­‰ã€‚æˆ‘ä»¬å¯ä»¥å°†å…¶å’Œ ELF æ–‡ä»¶çš„ program header è¿›è¡Œå¯¹æ¯”ï¼š\nProgram Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flags Align LOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000 0x0000000000000528 0x0000000000000528 R 0x1000 LOAD 0x0000000000001000 0x0000000000401000 0x0000000000401000 0x000000000008bf1d 0x000000000008bf1d R E 0x1000 LOAD 0x000000000008d000 0x000000000048d000 0x000000000048d000 0x0000000000027315 0x0000000000027315 R 0x1000 LOAD 0x00000000000b4908 0x00000000004b5908 0x00000000004b5908 0x00000000000059e8 0x00000000000072b8 RW 0x1000 å¯ä»¥çœ‹åˆ°åœ°å€å’Œæƒé™éƒ½èƒ½å¯¹åº”ä¸Šã€‚è®¡ç®—æœºç³»ç»Ÿçš„ä¸–ç•Œé‡Œæ²¡æœ‰é­”æ³•ã€‚\nDynamically Link åŠ¨æ€é“¾æ¥çš„ç»“æœä¼šæ›´å¤æ‚ä¸€äº›ï¼š\n555555554000-555555555000 r--p 103:0a /home/starling/a.out 555555555000-555555556000 r-xp 103:0a /home/starling/a.out 555555556000-555555557000 r--p 103:0a /home/starling/a.out 555555557000-555555558000 r--p 103:0a /home/starling/a.out 555555558000-555555559000 rw-p 103:0a /home/starling/a.out 7ffff7dbe000-7ffff7dc0000 rw-p 00:00 0 // ??? 7ffff7dc0000-7ffff7de6000 r--p 103:09 /usr/lib/x86_64-linux-gnu/libc-2.33.so 7ffff7de6000-7ffff7f51000 r-xp 103:09 /usr/lib/x86_64-linux-gnu/libc-2.33.so 7ffff7f51000-7ffff7f9d000 r--p 103:09 /usr/lib/x86_64-linux-gnu/libc-2.33.so 7ffff7f9d000-7ffff7fa0000 r--p 103:09 /usr/lib/x86_64-linux-gnu/libc-2.33.so 7ffff7fa0000-7ffff7fa3000 rw-p 103:09 /usr/lib/x86_64-linux-gnu/libc-2.33.so 7ffff7fa3000-7ffff7fae000 rw-p 00:00 0 // ??? 7ffff7fc3000-7ffff7fc7000 r--p 00:00 0 [vvar] 7ffff7fc7000-7ffff7fc9000 r-xp 00:00 0 [vdso] 7ffff7fc9000-7ffff7fca000 r--p 103:09 /usr/lib/x86_64-linux-gnu/ld-2.33.so 7ffff7fca000-7ffff7ff1000 r-xp 103:09 /usr/lib/x86_64-linux-gnu/ld-2.33.so 7ffff7ff1000-7ffff7ffb000 r--p 103:09 /usr/lib/x86_64-linux-gnu/ld-2.33.so 7ffff7ffb000-7ffff7ffd000 r--p 103:09 /usr/lib/x86_64-linux-gnu/ld-2.33.so 7ffff7ffd000-7ffff7fff000 rw-p 103:09 /usr/lib/x86_64-linux-gnu/ld-2.33.so 7ffffffde000-7ffffffff000 rw-p 00:00 0 [stack] ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0 [vsyscall] æˆ‘ä»¬çœ‹åˆ°å¤šäº†å¾ˆå¤šçš„æ®µï¼Œæ¯”å¦‚ libc åº“çš„æ®µå’ŒåŠ è½½å™¨çš„æ®µã€‚å¯ä»¥å¼•èµ·æˆ‘ä»¬å…³æ³¨çš„ä¸€ä¸ªé—®é¢˜æ˜¯ï¼šæœ‰ä¸¤ä¸ªæ²¡æœ‰åå­—çš„ä¸œè¥¿æ˜¯ä»€ä¹ˆï¼Ÿè¿™ä¸¤ä¸ªæ®µå¯è¯»å¯å†™ä¸å¯æ‰§è¡Œï¼Œæ˜¯å¦æœ‰å¯èƒ½æ˜¯ bss æ®µï¼Ÿæˆ‘ä»¬å¯ä»¥åšå®éªŒéªŒè¯è¿™ä¸€ç‚¹ï¼š\nchar ch[1 \u0026lt;\u0026lt; 30]; int main () {} å†æ¬¡è¿è¡Œå¹¶æŸ¥çœ‹ï¼Œå¯ä»¥çœ‹åˆ°æ²¡æœ‰åå­—çš„æ®µå˜å¤§äº†å¾ˆå¤šã€‚å†åšä¸€æ¬¡å®éªŒï¼š\nchar ch[1 \u0026lt;\u0026lt; 30] = {1}; int main () {} å¯ä»¥çœ‹åˆ°è¿™æ¬¡ç¼–è¯‘å˜æ…¢äº†å¾ˆå¤šï¼Œç”Ÿæˆçš„å¯æ‰§è¡Œæ–‡ä»¶éå¸¸å¤§ã€‚æŸ¥çœ‹åœ°å€ç©ºé—´ï¼ŒåŒ¿åæ®µä¸Šæ–¹å¤šäº†ä¸€ä¸ªå¾ˆå¤§çš„æ®µï¼Œæ˜¾ç„¶æ˜¯å¯è¯»å¯å†™æ•°æ®æ®µï¼ŒåŒ¿åæ®µçš„å¤§å°å¾ˆå°ã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥ç¡®å®šæ²¡æœ‰åå­—çš„æ®µå°±æ˜¯ bss æ®µã€‚\nå¦å¤–ä¸€ä¸ªæœ‰æ„æ€çš„é—®é¢˜æ˜¯ï¼švvar æ®µå’Œ vdso æ®µæ˜¯ä»€ä¹ˆï¼Ÿ\næˆ‘ä»¬æœ‰æ—¶å€™æƒ³è¦æ‰§è¡Œç³»ç»Ÿè°ƒç”¨ï¼Œä½†åˆä¸æƒ³é™·å…¥æ“ä½œç³»ç»Ÿå†…æ ¸ (å› ä¸ºè¿™æ ·æ¯”è¾ƒè€—æ—¶)ï¼Œvdso æä¾›äº†è¿™æ ·ä¸€äº›ä¸é™·å…¥å†…æ ¸å°±å¯ä»¥å®Œæˆç³»ç»Ÿè°ƒç”¨åŠŸèƒ½çš„å‡½æ•°ã€‚ä¸€ä¸ªå…¸å‹çš„ä¾‹å­æ˜¯ __vdso_gettimeofday()ã€‚åœ¨ä½¿ç”¨æ—¶ï¼Œæˆ‘ä»¬å¹¶ä¸éœ€è¦åŠ ä¸Š __vdso çš„å‰ç¼€ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨å¸®æˆ‘ä»¬é“¾æ¥åˆ° vdso å‡½æ•°ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š\n// vdso.c #include \u0026lt;sys/time.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;time.h\u0026gt; double gettime() { struct timeval t; gettimeofday(\u0026amp;t, NULL); // trapless system call return t.tv_sec + t.tv_usec / 1000000.0; } int main() { printf(\u0026quot;Time stamp: %ld\\n\u0026quot;, time(NULL)); // trapless system call double st = gettime(); sleep(1); double ed = gettime(); printf(\u0026quot;Time: %.6lfs\\n\u0026quot;, ed - st); } vdso.c ä¸­è°ƒç”¨äº†å‡½æ•° time() å’Œ gettimeofday()ï¼Œå®ƒä»¬éƒ½ä¸ä¼šé™·å…¥å†…æ ¸ã€‚æˆ‘ä»¬å¯ä»¥ç”¨ GDB è°ƒè¯•å®ƒå¹¶æŸ¥çœ‹æ±‡ç¼–ä»£ç ã€‚æˆ‘ä»¬å‘ç° time() å‡½æ•°çš„ä»ä¸€ä¸ªå¥‡æ€ªçš„åœ°æ–¹æ¬äº†ä¸€äº›æ•°è¿‡æ¥ï¼Œè¿™äº›æ•°å°±æ„æˆäº†æ—¶é—´ï¼š\n0x7ffff7fc7c00 \u0026lt;time\u0026gt;: lea -0x4b87(%rip),%rax # 0x7ffff7fc3080 0x7ffff7fc7c07 \u0026lt;time+7\u0026gt;: lea -0x1b8e(%rip),%rdx # 0x7ffff7fc6080 0x7ffff7fc7c0e \u0026lt;time+14\u0026gt;: cmpl $0x7fffffff,-0x4b94(%rip) # 0x7ffff7fc3084 0x7ffff7fc7c18 \u0026lt;time+24\u0026gt;: cmove %rdx,%rax 0x7ffff7fc7c1c \u0026lt;time+28\u0026gt;: mov 0x20(%rax),%rax 0x7ffff7fc7c20 \u0026lt;time+32\u0026gt;: test %rdi,%rdi 0x7ffff7fc7c23 \u0026lt;time+35\u0026gt;: je 0x7ffff7fc7c28 \u0026lt;time+40\u0026gt; 0x7ffff7fc7c25 \u0026lt;time+37\u0026gt;: mov %rax,(%rdi) 0x7ffff7fc7c28 \u0026lt;time+40\u0026gt;: ret å¦‚æœæˆ‘ä»¬åœ¨ GDB ä¸­ç›´æ¥ç”¨ x æŒ‡ä»¤æ‰“å°é‚£ä¸ªåœ°å€ï¼Œä¼šå‘ç°æˆ‘ä»¬æ— æƒè®¿é—® (GDB ä¸å…è®¸æˆ‘ä»¬è®¿é—®å¦ä¸€ä¸ªè¿›ç¨‹çš„åœ°å€ç©ºé—´)ï¼Œä½†å¯¹ç…§ /proc/pid/maps çš„ç»“æœï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ° time() å‡½æ•°åœ¨ vdso æ®µï¼Œå®ƒæ‰€æŠ“å–çš„æ•°æ®åœ¨ vvar æ®µã€‚\n7ffff7fc3000-7ffff7fc7000 r--p 00000000 00:00 0 [vvar] 7ffff7fc7000-7ffff7fc9000 r-xp 00000000 00:00 0 [vdso] è¯¥è™šæ‹Ÿç³»ç»Ÿè°ƒç”¨å®ç°çš„åŸç†ä¸å¤ªå¤æ‚ï¼šæ“ä½œç³»ç»Ÿåœ¨ vvar æ®µç»´æŠ¤ä¸€ä¸ªå¤§è‡´æ—¶é—´çš„å˜é‡ï¼Œæ¯è¿‡ä¸€ä¼šå„¿å»æ›´æ–°ä¸€ä¸‹ï¼Œç³»ç»Ÿä¸­æ‰€æœ‰çš„è¿›ç¨‹éƒ½å¯ä»¥ä½¿ç”¨ vvar æ®µçš„æ•°æ®ã€‚\nManaging Address Space è¿›ç¨‹çš„åœ°å€ç©ºé—´ä¸æ˜¯ä¸€æˆä¸å˜çš„ï¼Œåœ¨è¿›ç¨‹æ‰§è¡Œè¿‡ç¨‹ä¸­å¯ä»¥ä¿®æ”¹ã€‚å¦‚æœæˆ‘ä»¬ç”¨ GDB è°ƒè¯•ä¸€ä¸ªåŠ¨æ€é“¾æ¥çš„ç¨‹åºï¼Œç”¨ starti è®©å…¶æš‚åœåœ¨ç¬¬ä¸€æ¡æ±‡ç¼–æŒ‡ä»¤ (æ­¤æ—¶ PC åœ¨åŠ è½½å™¨ä¸­)ï¼Œå†ç”¨ pmap æŸ¥çœ‹åœ°å€ç©ºé—´ï¼Œå¯ä»¥çœ‹åˆ°æ­¤æ—¶åªæœ‰ .soï¼Œè¿˜æ²¡æœ‰ libc ç›¸å…³çš„æ®µã€‚ä½†æ‰§è¡Œåˆ° main() å‡½æ•°æ—¶ï¼Œåœ°å€ç©ºé—´ä¸­æœ‰äº† libc ç›¸å…³çš„æ®µã€‚\nå¢åŠ /åˆ é™¤/ä¿®æ”¹åœ°å€ç©ºé—´éœ€è¦ç³»ç»Ÿè°ƒç”¨çš„æ”¯æŒã€‚Linux æä¾›äº† mmap() ç³»ç»Ÿè°ƒç”¨æ·»åŠ æ˜ å°„ï¼Œmunmap() ç³»ç»Ÿè°ƒç”¨åˆ é™¤æ˜ å°„ï¼Œmprotect() å‡½æ•°ä¿®æ”¹æ˜ å°„çš„æƒé™ã€‚\nvoid *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); æ‰‹å†Œä¸­æœ‰å¯¹ mmap() çš„è¯¦ç»†æè¿°ï¼Œæ¯”å¦‚ addr æœ¬èº«å¹¶ä¸æŒ‡å®š mmap() æ˜ å°„çš„åœ°å€ï¼Œåªä¼šä½œä¸ºä¸€ä¸ªæ˜ å°„åœ°å€çš„å‚è€ƒï¼›è¯¥å‡½æ•°è¿”å›çš„åœ°å€æ˜¯å®é™…æ˜ å°„çš„åœ°å€ã€‚æœ‰æ„æ€çš„ä¸€ç‚¹æ˜¯ï¼Œmmap() å¯ä»¥ç›´æ¥å°†æ–‡ä»¶ä¸­çš„ä¸€å¤§å—åŒºåŸŸæ˜ å°„åˆ°åœ°å€ç©ºé—´ä¸­ï¼šäº‹å®ä¸Šæ–‡ä»¶å¹¶ä¸ä¼šè¢«ç«‹åˆ»æ¬å…¥å†…å­˜ï¼Œè€Œæ˜¯åœ¨ä½¿ç”¨æ—¶æ‰ä¼šå°†è¦ä½¿ç”¨çš„éƒ¨åˆ†æ¬è¿›æ¥ (ç¼ºé¡µå¼‚å¸¸)ã€‚(æ³¨ï¼šå¦‚æœä¸æƒ³æ˜ å°„åˆ°æ–‡ä»¶ï¼Œè€Œåªæ˜¯å¼€è¾Ÿä¸€æ®µæ˜ å°„ç©ºé—´ï¼Œå¯ä»¥åœ¨ flags å­—æ®µä½¿ç”¨ MAP_ANONYMOUSï¼Œå¹¶å°† fd è®¾ç½®ä¸º -1ï¼Œæ“ä½œç³»ç»Ÿä¼šè‡ªåŠ¨å°†è¿™æ®µå¡«å……ä¸º 0ã€‚)\næœ‰äº† mmap() ç³»ç»Ÿè°ƒç”¨ä»¥åï¼Œæ“ä½œç³»ç»Ÿçš„åŠ è½½å™¨å˜å¾—éå¸¸å¥½å†™ï¼šæˆ‘ä»¬åªéœ€è¦æ ¹æ® ELF æ–‡ä»¶ä¸­æ‰€å†™çš„éœ€è¦åŠ è½½çš„å†…å®¹ä¸€ä¸€è°ƒç”¨ mmap() å³å¯ã€‚æˆ‘ä»¬å¯ä»¥ç”¨ strace è§‚æµ‹ä¸€ä¸ªç¨‹åºåŠ è½½ã€è¿è¡Œæ—¶çš„æ‰€æœ‰ mmap() æ“ä½œã€‚\næœ‰äº†æ–‡ä»¶æ˜ å°„ä¹‹åï¼Œéšä¹‹è€Œæ¥çš„æ˜¯ä¸€ç³»åˆ—ä¸€è‡´æ€§é—®é¢˜ï¼šè¿›ç¨‹å¯¹æ–‡ä»¶çš„ä¿®æ”¹æ˜¯å¦éœ€è¦ç«‹å³ç”Ÿæ•ˆï¼Ÿä¸åŒè¿›ç¨‹æ˜ å°„åˆ°åŒä¸€ä¸ªæ–‡ä»¶åº”å½“å…±äº«å†…å­˜è¿˜æ˜¯å„è‡ªæœ‰æœ¬åœ°å‰¯æœ¬ï¼Ÿæ“ä½œç³»ç»Ÿè¿˜æä¾›äº† msync() ç³»ç»Ÿè°ƒç”¨å¤„ç†åŒæ­¥ç›¸å…³çš„é—®é¢˜ã€‚è¿™æ‰æ˜¯ç³»ç»ŸçœŸæ­£çš„å¤æ‚æ€§ã€‚\nä¸‹é¢æ˜¯ä¸¤ä¸ª mmap() çš„ä¾‹å­ï¼š\n// mmap-alloc.c #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #define GiB * (1024LL * 1024 * 1024) int main() { volatile uint8_t *p = mmap(NULL, 3 GiB, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0); printf(\u0026quot;mmap: %lx\\n\u0026quot;, (uintptr_t)p); if ((intptr_t)p == -1) { perror(\u0026quot;cannot map\u0026quot;); exit(1); } *(int *)(p + 1 GiB) = 114; *(int *)(p + 2 GiB) = 514; printf(\u0026quot;Read get: %d\\n\u0026quot;, *(int *)(p + 1 GiB)); printf(\u0026quot;Read get: %d\\n\u0026quot;, *(int *)(p + 2 GiB)); } æˆ‘ä»¬ç”¨ mmap() æ˜ å°„äº†ä¸€ç‚¹ 3G çš„å†…å­˜ç©ºé—´ï¼Œå¹¶åœ¨å…¶ä¸­æŸä¸ªä½ç½®å†™äº†ä¸œè¥¿ï¼Œå¹¶è®¿é—®è¿™ä¸ªä½ç½®ã€‚æˆ‘ä»¬å¯ä»¥çœ‹åˆ°è™½ç„¶æˆ‘ä»¬æ˜ å°„äº†å¾ˆå¤§çš„ä¸€å—ç©ºé—´ï¼Œä½†è¿™ä¸ªç³»ç»Ÿè°ƒç”¨åªç”¨äº†æçŸ­çš„æ—¶é—´ (ä¸€äº›å»¶è¿Ÿæ˜ å°„ç›¸å…³çš„æŠ€æœ¯)ã€‚\n#!/usr/bin/env python3 # mmap-disk.py import mmap, hexdump with open('/dev/sda', 'rb') as fp: mm = mmap.mmap(fp.fileno(), prot=mmap.PROT_READ, length=128 \u0026lt;\u0026lt; 30) hexdump.hexdump(mm[:512]) æˆ‘ä»¬å¯ä»¥å°†æ•´ä¸ªç£ç›˜æ˜ å°„åˆ°åœ°å€ç©ºé—´ä¸­ï¼Œå¹¶æ‰“å°ç¬¬ä¸€ä¸ªæ‰‡åŒºçš„å†…å®¹ï¼Œå¯ä»¥çœ‹åˆ°ç»“å°¾å¤„æ ‡å¿— MBR çš„ 0x55aaã€‚\nIsolation of Address Space è™šæ‹Ÿå†…å­˜æœºåˆ¶ä¸ºæˆ‘ä»¬æä¾›äº†å†…å­˜éš”ç¦»ï¼šæ¯ä¸ªè¿›ç¨‹åªèƒ½åœ¨è‡ªå·±çš„åœ°å€ç©ºé—´æ˜ å°„ä¸­åšäº‹ï¼Œè®¿é—®åˆ«çš„è¿›ç¨‹çš„åœ°å€ä¼šè§¦å‘æ®µé”™è¯¯ï¼Œæˆ–è€…è¯´ï¼Œåœ¨æœ¬åœ°çš„åœ°å€ç©ºé—´ä¸­æ ¹æœ¬çœ‹ä¸åˆ°åˆ«çš„è¿›ç¨‹çš„åœ°å€ã€‚ï¼ˆçœŸçš„å—ï¼Ÿï¼‰\nJinshan Drifter åœ¨è®¿é—®æ£€æŸ¥ä¸ä¸¥æ ¼çš„ç¨‹åºä¸­ï¼Œå…¶ä»–è¿›ç¨‹æœ‰åŠæ³•å¯ä»¥ä¾µå…¥ï¼Œè¯»å–å’Œä¿®æ”¹æ•°æ®ã€‚è¿™é‡Œå±•ç¤ºä¸€ä¸ªç±»ä¼¼äºâ€œé‡‘å±±æ¸¸ä¾ â€çš„çº¢è­¦å¤–æŒ‚ç¨‹åºï¼š\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #define LENGTH(arr) (sizeof(arr) / sizeof(arr[0])) int n, fd, pid; uint64_t found[4096]; bool reset; void scan(uint16_t val) { uintptr_t start, kb; char perm[16]; FILE *fp = popen(\u0026quot;pmap -x $(pidof dosbox) | tail -n +3\u0026quot;, \u0026quot;r\u0026quot;); assert(fp); if (reset) n = 0; while (fscanf(fp, \u0026quot;%lx\u0026quot;, \u0026amp;start) == 1 \u0026amp;\u0026amp; (intptr_t)start \u0026gt; 0) { assert(fscanf(fp, \u0026quot;%ld%*ld%*ld%s%*[^\\n]s\u0026quot;, \u0026amp;kb, perm) \u0026gt;= 1); if (perm[1] != 'w') continue; uintptr_t size = kb * 1024; char *mem = malloc(size); assert(mem); assert(lseek(fd, start, SEEK_SET) != (off_t)-1); assert(read(fd, mem, size) == size); for (int i = 0; i \u0026lt; size; i += 2) { uint16_t v = *(uint16_t *)(\u0026amp;mem[i]); if (reset) { if (val == v \u0026amp;\u0026amp; n \u0026lt; LENGTH(found)) found[n++] = start + i; } else { for (int j = 0; j \u0026lt; n; j++) { if (found[j] == start + i \u0026amp;\u0026amp; v != val) found[j] = 0; } } } free(mem); } pclose(fp); int s = 0; for (int i = 0; i \u0026lt; n; i++) { if (found[i] != 0) s++; } reset = false; printf(\u0026quot;There are %d match(es).\\n\u0026quot;, s); } void overwrite(uint16_t val) { int s = 0; for (int i = 0; i \u0026lt; n; i++) if (found[i] != 0) { assert(lseek(fd, found[i], SEEK_SET) != (off_t)-1); write(fd, \u0026amp;val, 2); s++; } printf(\u0026quot;%d value(s) written.\\n\u0026quot;, s); } int main() { char buf[32]; setbuf(stdout, NULL); FILE *fp = popen(\u0026quot;pidof dosbox\u0026quot;, \u0026quot;r\u0026quot;); assert(fscanf(fp, \u0026quot;%d\u0026quot;, \u0026amp;pid) == 1); pclose(fp); sprintf(buf, \u0026quot;/proc/%d/mem\u0026quot;, pid); fd = open(buf, O_RDWR); assert(fd \u0026gt; 0); for (reset = true; !feof(stdin); ) { int val; printf(\u0026quot;(DOSBox %d) \u0026quot;, pid); if (scanf(\u0026quot;%s\u0026quot;, buf) \u0026lt;= 0) { close(fd); exit(0); } switch (buf[0]) { case 'q': close(fd); exit(0); break; case 's': scanf(\u0026quot;%d\u0026quot;, \u0026amp;val); scan(val); break; case 'w': scanf(\u0026quot;%d\u0026quot;, \u0026amp;val); overwrite(val); break; case 'r': reset = true; printf(\u0026quot;Search results reset.\\n\u0026quot;); break; } } } popen() å‡½æ•°çš„å£°æ˜å¦‚ä¸‹ï¼š\nFILE *popen(const char *command, const char *type); å®ƒçš„ä½œç”¨æ˜¯åˆ›å»ºä¸€ä¸ªç®¡é“ï¼Œfork å½“å‰è¿›ç¨‹ï¼Œå¹¶æ‰§è¡Œ shell å‘½ä»¤ commandã€‚type å­—æ®µæŒ‡ç¤ºäº†ç®¡é“çš„æ•°æ®æµå‘ï¼Œâ€œr\u0026quot; è¡¨ç¤ºå½“å‰è¿›ç¨‹ä»ç®¡é“è¯»å– command çš„è¾“å‡ºï¼Œ\u0026ldquo;w\u0026rdquo; è¡¨ç¤ºå½“å‰è¿›ç¨‹é€šè¿‡ç®¡é“å‘ command è¾“å‡ºã€‚\nmain() å‡½æ•°çš„ä¸»è¦å·¥ä½œæ˜¯\nåˆ©ç”¨ popen() æ‰§è¡Œå‘½ä»¤ pidof dosboxï¼Œè·å¾—æ­£åœ¨è¿è¡Œçš„ dosbox è¿›ç¨‹çš„è¿›ç¨‹å·ï¼Œå¹¶ç”¨ open() å‡½æ•°æ‰“å¼€è¯¥è¿›ç¨‹ä¸‹çš„ä¸€ä¸ªæ–‡ä»¶ /proc/pid/memï¼Œè·å¾—ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ (open() ä¸­çš„æƒé™è¦è®¾ç½®ä¸ºå¯è¯»å¯å†™ï¼Œå› ä¸ºæˆ‘ä»¬æ—¢è¦è¯»å–æ¸¸æˆä¿¡æ¯ï¼Œåˆè¦ä¿®æ”¹æ•°æ®)ã€‚æ ¹æ® proc çš„æ‰‹å†Œï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è¿™ä¸ªæ–‡ä»¶è®¿é—®è¯¥è¿›ç¨‹çš„åœ°å€ç©ºé—´ä¿¡æ¯ã€‚ ä¸æ–­ä» stdin (æ§åˆ¶å°) è¯»å–ç”¨æˆ·è¾“å…¥ï¼Œå¯¹äº s val å‹è¾“å…¥ï¼Œåœ¨å†…å­˜ä¸­å°è¯•åŒ¹é…æ‰€æœ‰çš„ valã€‚å¯¹äº w val å‹è¾“å…¥ï¼Œå°†ä¹‹å‰åŒ¹é…åˆ°çš„æ‰€æœ‰ä½ç½®æ”¹å†™ä¸º valã€‚å¯¹äº r ï¼Œé‡ç½®ä¹‹å‰çš„åŒ¹é…ç»“æœï¼Œå¯¹äº qï¼Œé€€å‡ºå¤–æŒ‚ç¨‹åºã€‚ scan() å‡½æ•°è´Ÿè´£åœ¨ dosbox çš„åœ°å€ç©ºé—´ä¸­åŒ¹é…æ‰€æœ‰çš„ valï¼Œå…¶å…·ä½“å·¥ä½œæ˜¯ï¼š\nåˆ©ç”¨ popen() æ‰§è¡Œå‘½ä»¤ pmap $(pidof dosbox) | tail -n +3ï¼Œtail -n +3 å¯ä»¥æŒ‡å®šä» pmap è¾“å‡ºç»“æœçš„ç¬¬ 3 è¡Œå¼€å§‹è¯»å–ã€‚pmap è¾“å‡ºçš„ç¬¬ä¸€è¡Œé€šå¸¸æ˜¯è¿›ç¨‹å·ï¼Œç¬¬äºŒè¡Œæ˜¯ ELF æ–‡ä»¶å¤´ï¼Œå› æ­¤ä»ç¬¬ 3 è¡Œå¼€å§‹å¤„ç†ã€‚ while () å¾ªç¯è®¿é—® dosbox åœ°å€ç©ºé—´çš„æ‰€æœ‰å¯è¯»å¯å†™æ®µ (æ¸¸æˆä¸­å€¼å¾—å…³æ³¨çš„æ•°æ®ï¼Œä¾‹å¦‚é‡‘é’±ã€èµ„æºï¼Œä¸€å®šæ˜¯å¯ä»¥ä¿®æ”¹çš„)ï¼Œè®¿é—®è¿™äº›æ®µä¸­çš„æ¯ä¸ªåœ°å€ï¼Œçœ‹å…¶æ˜¯å¦ç­‰äº val å¹¶ä¿®æ”¹ found[] æ•°ç»„ã€‚found[] æ•°ç»„è®°å½•äº†ä¸Šä¸€æ¬¡ reset ä»¥æ¥æ»¡è¶³æ‰€æœ‰åŒ¹é…ç»“æœçš„åœ°å€ã€‚ overwrite() å‡½æ•°è´Ÿè´£ä¿®æ”¹æ•°æ®ã€‚å®ƒåªè¦å°† found[] ä¸­æ‰€æœ‰åœ°å€å¤„çš„æ•°æ®æ”¹æˆæˆ‘ä»¬æƒ³è¦çš„ val å³å¯ã€‚\nè¿™ä¸ªå¤–æŒ‚éœ€è¦åŠ¨æ€ä½¿ç”¨ï¼šå¤–æŒ‚åˆšå¼€å§‹ä¹Ÿä¸çŸ¥é“å­˜å‚¨é‡‘é’±çš„åœ°å€åœ¨å“ªé‡Œï¼Œä½†æˆ‘ä»¬å¯ä»¥ä¸æ–­èŠ±é’±ï¼Œå¹¶æ‹¿æ–°çš„é’±çš„å‰©ä½™é‡å» scanï¼Œåšè‹¥å¹²è½®ä¹‹åæˆ‘ä»¬å°±å¯ä»¥é”å®šé‡‘é’±çš„åœ°å€ã€‚æ­¤æ—¶å†ä¿®æ”¹è¯¥åœ°å€çš„å€¼ï¼Œä¾¿å¯ä»¥æ‹¥æœ‰é’èƒ½åŠ›ã€‚\nPseudo-hardware æœ‰ä¸€äº›ç±»ä¼¼ \u0026ldquo;2ç§’17æª\u0026rdquo; çš„å¤–æŒ‚å¯ä»¥ä»¥äººç±»æ— æ³•è¾¾åˆ°çš„é€Ÿåº¦å¤§é‡é‡å¤æ‰§è¡Œä»»åŠ¡ã€‚è¿™ç±»å¤–æŒ‚å¯ä»¥é€šè¿‡å†™ä¸€ä¸ªé©±åŠ¨æ¨¡ä»¿å‡çš„ç¡¬ä»¶ï¼Œæˆ–è€…åˆ©ç”¨æ“ä½œç³»ç»Ÿ/çª—å£ç®¡ç†å™¨çš„ API å®ç°ã€‚\nVariable Speed Gear å˜é€Ÿé½¿è½®æ˜¯å¦å¤–ä¸€ç±»å¸¸è§çš„å¤–æŒ‚ï¼Œå¯ä»¥è°ƒèŠ‚æ¸¸æˆçš„è¿›åº¦ (æ¯”å¦‚åŠ å¿«åŠ¨ç”»æ’­æ”¾çš„é€Ÿåº¦ï¼Œå‡å°å»¶è¿Ÿç­‰)ã€‚å…¶å®ç°çš„æœºåˆ¶é€šå¸¸å’Œä»£ç æ³¨å…¥æœ‰å…³ï¼šæˆ‘ä»¬éœ€è¦æ‰¾åˆ°ç±»ä¼¼äº gettimeofday() ç­‰æ—¶é—´ç›¸å…³ API çš„å‡½æ•°ä½ç½®ï¼Œç„¶åæ”¹å†™è¿™éƒ¨åˆ†ä»£ç ï¼Œè®©å®ƒè·³è½¬åˆ°æˆ‘ä»¬è‡ªå·±ç¼–å†™çš„å‡½æ•°ï¼Œè¿™æ ·å°±å¯ä»¥ä»»æ„è°ƒèŠ‚æ—¶é—´äº†ã€‚\nHooking æˆ‘ä»¬ä¸ä»…å¯ä»¥ä¿®æ”¹æ•°æ®ï¼Œè¿˜å¯ä»¥ä¿®æ”¹ä»£ç ï¼Œè¿™å°±æ˜¯ä»£ç æ³¨å…¥æŠ€æœ¯ (hooking)ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„ç»™ç¨‹åºæ‰“çƒ­è¡¥ä¸ (dynamic software update) çš„ç¤ºä¾‹ï¼š\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;assert.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void foo() { printf(\u0026quot;In old function %s\\n\u0026quot;, __func__); } void foo_new() { printf(\u0026quot;In new function %s\\n\u0026quot;, __func__); } struct jmp { uint32_t opcode: 8; int32_t offset: 32; } __attribute__((packed)); #define JMP(off) ((struct jmp) { 0xe9, off - sizeof(struct jmp) }) #define PG_SIZE sysconf(_SC_PAGESIZE) static inline bool within_page(void *addr) { return (uintptr_t)addr % PG_SIZE + sizeof(struct jmp) \u0026lt;= PG_SIZE; } void DSU(void *old, void *new) { void *base = (void *)((uintptr_t)old \u0026amp; ~(PG_SIZE - 1)); size_t len = PG_SIZE * (within_page(old) ? 1 : 2); int flags = PROT_WRITE | PROT_READ | PROT_EXEC; printf(\u0026quot;Dynamically updating...\\n\u0026quot;); fflush(stdout); if (mprotect(base, len, flags) == 0) { *(struct jmp *)old = JMP((char *)new - (char *)old); // **PATCH** mprotect(base, len, flags \u0026amp; ~PROT_WRITE); } else { perror(\u0026quot;DSU fail\u0026quot;); } } int main() { foo(); DSU(foo, foo_new); foo(); } è¿è¡Œè¿™ä¸ªç¨‹åºï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°è™½ç„¶ä¸¤æ¬¡è°ƒç”¨çš„éƒ½æ˜¯ foo()ï¼Œä½†åœ¨æ‰§è¡Œè¿‡ DSU() å‡½æ•°æ‰“è¡¥ä¸ä¹‹åï¼Œç¬¬äºŒæ¬¡æ‰§è¡Œ foo() å…¶å®è·³è½¬åˆ°äº† foo_new() æ‰§è¡Œã€‚è¯¥ç¨‹åºçš„åŸç†æ˜¯æ”¹å†™ foo() å‡½æ•°çš„ç¬¬ä¸€æ¡æŒ‡ä»¤ï¼Œåœ¨ foo åœ°å€å¤„å†™ä¸€ä¸ªé—´æ¥è·³è½¬æŒ‡ä»¤è·³åˆ° foo_new()ã€‚ä¸ºäº†å®ç°è¿™ç‚¹ï¼Œä»£ç ä¸­çš„ç»†èŠ‚æœ‰ï¼š\nä½¿ç”¨ mprotect() ç³»ç»Ÿè°ƒç”¨ä¿®æ”¹ foo() å‡½æ•°æ‰€åœ¨åŒºåŸŸçš„æƒé™ã€‚ä»£ç æ®µæœ¬èº«æ˜¯ä¸å¯å†™çš„ï¼Œæˆ‘ä»¬è¦ä¸ºå…¶åŠ ä¸Šä¿®æ”¹æƒé™ã€‚è¿™é‡Œçš„â€åŒºåŸŸâ€œæœ‰ä¸€ç‚¹å¾®å¦™ï¼šå¦‚æœæˆ‘ä»¬è¦æ’å…¥çš„è·³è½¬æŒ‡ä»¤æ­£å¥½æ¨ªè·¨äº†ä¸¤ä¸ªé¡µé¢ï¼Œåˆ™æˆ‘ä»¬éœ€è¦ä¸ºè¿ç»­ä¸¤ä¸ªé¡µé¢å¼€æ”¾ä¿®æ”¹æƒé™ã€‚within_page() å‡½æ•°åˆ¤æ–­äº†è¿™ä¸€ç‚¹ã€‚ *(struct jmp *)old = JMP((char *)new - (char *)old); æ˜¯æ‰“è¡¥ä¸çš„æ ¸å¿ƒè¯­å¥ã€‚JMP å®çš„åŸç†æ˜¯å†™ä¸Šä¸€ä¸ªé—´æ¥è·³è½¬çš„æ“ä½œç ï¼Œç„¶åè®¡ç®—ä¸¤ä¸ªå‡½æ•°åœ°å€çš„ deltaã€‚ Protection é˜²å¤–æŒ‚çš„ä¸»è¦æ–¹æ³•æ˜¯ä¿è¯æ§åˆ¶æµå’Œæ•°æ®æµçš„å®Œæ•´æ€§ã€‚äº‹å®ä¸Šï¼Œå¤§éƒ¨åˆ†å¤–æŒ‚éƒ½åƒæ˜¯æ¸¸æˆç¨‹åºçš„â€œè°ƒè¯•å™¨â€ï¼šå®ƒä»¬ä¸æ–­ç›‘å¬æ¸¸æˆçŠ¶æ€å¹¶ä¿®æ”¹æ¸¸æˆæ•°æ®/ä»£ç ã€‚æˆ‘ä»¬å¯ä»¥å¯¹ç‹¬ç«‹çš„è¿›ç¨‹/é©±åŠ¨åšå®Œæ•´æ€§æ£€éªŒï¼Œè¿˜å¯ä»¥æ‹¦æˆªå‘æœ¬è¿›ç¨‹çš„ ReadProcessMemory å’Œ WriteProcessMemory è¯·æ±‚ï¼Œå‘ç°åç«‹åˆ»æ‹’ç»æ‰§è¡Œå¹¶å°å·ã€‚\nå…¶ä»–çš„ä¸€äº›è§£å†³æ–¹æ³•åŒ…æ‹¬ï¼šä»ç»Ÿè®¡å­¦çš„è§’åº¦æ‰¾å‡ºä¸ç¬¦åˆè§„å¾‹çš„æ“ä½œï¼›è®©ç¨‹åºåœ¨äº‘/æ²™ç›’ä¸­è¿è¡Œ (å³â€œè®¡ç®—ä¸å†ä¿¡ä»»æ“ä½œç³»ç»Ÿ\u0026quot;)ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"501e3f1b58fbd027e1c405caa20776d6","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec12/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec12/","section":"notes","summary":"Address Space åœ¨ C ç¨‹åºä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨æŒ‡é’ˆè®¿é—®ä»»ä½•å¯ä»¥è®¿é—®çš„ä¸œè¥¿ï¼šæ¯”å¦‚ main() å‡½æ•°çš„é¦–åœ°å€ï¼Œè¿™ä¸ªåœ°å€å­˜å‚¨çš„å†…å®¹å°±æ˜¯ main() çš„ç¬¬ä¸€æ¡æŒ‡ä»¤ã€‚å¦‚æœæˆ‘ä»¬éšä¾¿è®¿é—®ä¸€ä¸ªå¥‡æ€ªçš„åœ°å€ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°æ®µé”™è¯¯ï¼›å¦‚æœæˆ‘ä»¬å¾€ main() çš„é¦–åœ°å€å¤„å†™ä¸œè¥¿ï¼Œæˆ‘ä»¬ä¹Ÿä¼šå¾—åˆ°æ®µé”™è¯¯ã€‚\nå‘½ä»¤è¡Œå·¥å…· pmap å¯ä»¥å¸®åŠ©æˆ‘ä»¬è§‚å¯Ÿä¸€ä¸ªè¿›ç¨‹çš„åœ°å€ç©ºé—´ã€‚æˆ‘ä»¬ä»¥æœ€å°çš„ç¨‹åº minimal.S ä¸ºä¾‹ï¼Œåœ¨ GDB ä¸­è°ƒè¯•æ—¶å¯ä»¥ç”¨ info inferiors æŸ¥çœ‹è¿›ç¨‹å·ï¼Œå¹¶ç”¨ pmap pid æ¥æŸ¥çœ‹åœ°å€ç©ºé—´ï¼š\n0000000000400000 4K r---- a.out 0000000000401000 4K r-x-- a.","tags":null,"title":"Lecture 12: Address Space of Processes","type":"docs"},{"authors":null,"categories":null,"content":" æˆ‘ä»¬æ˜¯æ“ä½œç³»ç»Ÿç”¨æˆ·ï¼Œä½†æ“ä½œç³»ç»Ÿ API å¹¶ä¸æ˜¯æˆ‘ä»¬ä½œä¸ºäººç±»ç”¨æˆ·ç›´æ¥ä½¿ç”¨çš„ï¼Œé‚£ä¹ˆâ€œæˆ‘ä»¬â€åˆ°åº•åº”è¯¥æ€ä¹ˆä½¿ç”¨æ“ä½œç³»ç»Ÿï¼Ÿ\nShell æˆ‘ä»¬éœ€è¦ä¸€ä¸ªä¸äººç±»äº¤äº’çš„ç¨‹åºï¼Œè¿™å°±æ˜¯ Shellã€‚ä¹‹æ‰€ä»¥å«åš shellï¼Œæ˜¯å› ä¸ºå®ƒå°±åƒåŒ…è£¹ä½æ“ä½œç³»ç»Ÿå†…æ ¸çš„ä¸€å±‚â€œå£³â€ï¼šå®ƒå‘å†…ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨ä¸å†…æ ¸äº¤äº’ï¼Œå‘å¤–ä¸äººç±»ç”¨æˆ·äº¤äº’ã€‚(Shell ä¸ä¸€å®šæ˜¯å‘½ä»¤è¡Œç»ˆç«¯ï¼ç°åœ¨çš„å›¾å½¢ç•Œé¢ä¹Ÿæ˜¯ä¸€ç§ graphical shellã€‚)\nShell æœ¬è´¨ä¸Šæ˜¯ä¸€é—¨ â€œæŠŠç”¨æˆ·æŒ‡ä»¤ç¿»è¯‘æˆç³»ç»Ÿè°ƒç”¨çš„ç¼–ç¨‹è¯­è¨€â€ã€‚(åœ¨ CLI æ—¶ä»£è¿™ä¸€ç‚¹ä½“ç°å¾—æ›´æ˜æ˜¾)\nXv6 Shell å…³äº -ffreestanding\n-ffreestanding Assert that compilation targets a freestanding environment. This implies -fno-builtin. A freestanding environment is one in which the standard library may not exist, and program startup may not necessarily be at \u0026ldquo;main\u0026rdquo;. The most obvious example is an OS kernel. This is equivalent to -fno-hosted.\nä»¥ä¸Šæ˜¯ man gcc ä¸­å…³äº -ffreestanding é€‰é¡¹çš„è¯´æ˜ã€‚åŠ ä¸Šè¿™ä¸ªé€‰é¡¹åï¼Œç¼–è¯‘ç›®æ ‡æ˜¯ä¸€ä¸ªç±»ä¼¼äºâ€œè£¸æœºâ€çš„ freestanding çš„ç¯å¢ƒã€‚æ²¡æœ‰æ ‡å‡†åº“ï¼Œç¨‹åºçš„å…¥å£ä¸å†æ˜¯ main() è€Œæ˜¯ _start()ã€‚\nsh-xv6.c æ˜¯ä¸€ä¸ªé›¶ä¾èµ–çš„å‚è€ƒ xv6-riscv å®ç°çš„ shellï¼Œå¯ä»¥ä½¿ç”¨ -ffreestanding é€‰é¡¹ç¼–è¯‘åˆ° .o æ–‡ä»¶å¹¶ç›´æ¥ç”¨ ld é“¾æ¥ã€‚ä¸ºäº†å®ç°é›¶ä¾èµ–ï¼Œsh-xv6.c åšå‡ºäº†å¦‚ä¸‹çš„æ”¹åŠ¨ï¼š\nsh-xv6.c å°† xv6 ä¸­çš„ç³»ç»Ÿè°ƒç”¨æ¢æˆäº†å¦‚ä¸‹åˆ©ç”¨ x86-64 syscall æŒ‡ä»¤çš„å…§è”æ±‡ç¼–ä»£ç ï¼š\n// Minimum runtime library long syscall(int num, ...) { va_list ap; va_start(ap, num); register long a0 asm (\u0026quot;rax\u0026quot;) = num; register long a1 asm (\u0026quot;rdi\u0026quot;) = va_arg(ap, long); register long a2 asm (\u0026quot;rsi\u0026quot;) = va_arg(ap, long); register long a3 asm (\u0026quot;rdx\u0026quot;) = va_arg(ap, long); register long a4 asm (\u0026quot;r10\u0026quot;) = va_arg(ap, long); va_end(ap); asm volatile(\u0026quot;syscall\u0026quot; : \u0026quot;+r\u0026quot;(a0) : \u0026quot;r\u0026quot;(a1), \u0026quot;r\u0026quot;(a2), \u0026quot;r\u0026quot;(a3), \u0026quot;r\u0026quot;(a4) : \u0026quot;memory\u0026quot;, \u0026quot;rcx\u0026quot;, \u0026quot;r8\u0026quot;, \u0026quot;r9\u0026quot;, \u0026quot;r11\u0026quot;); return a0; } x86-64 ç³»ç»Ÿè°ƒç”¨çš„å„ä¸ªå‚æ•°çš„å®‰æ”¾ä½ç½®å¯ä»¥é€šè¿‡ man 2 syscall æŸ¥é˜…ã€‚\nsh-xv6.c å°† xv6 ä¸­æ‰€æœ‰çš„ malloc() æ›¿æ¢æˆäº†å¦‚ä¸‹çš„ zalloc()ï¼š\nstatic char mem[4096], *freem = mem; void *zalloc(size_t sz) { assert(freem + sz \u0026lt; mem + sizeof(mem)); void *ret = freem; freem += sz; return ret; } xv6 çš„å†™æ³•ä¸­ malloc() æ²¡æœ‰å¯¹åº”çš„ free()ï¼Œè¿™æ˜¯å› ä¸ºå‘½ä»¤æ€»æ˜¯åœ¨ fork å‡ºçš„å­è¿›ç¨‹ä¸Šå®Œæˆçš„ï¼Œå­è¿›ç¨‹ç»“æŸæ—¶ä¼šè‡ªåŠ¨é‡Šæ”¾åˆ†é…çš„å†…å­˜ã€‚å› æ­¤ zalloc() ä½¿ç”¨äº†ä¸€ä¸ª 4KB çš„æ•°ç»„æ¥æ¨¡æ‹Ÿå †åŒºï¼Œåªç®¡åˆ†é…ä¸ç®¡é‡Šæ”¾ï¼Œè¿™æ · zalloc() çš„è¯­ä¹‰å’Œ malloc() æ˜¯ç›¸åŒçš„ (æ³¨ï¼šfork() çš„æ—¶å€™ï¼Œçˆ¶å­è¿›ç¨‹çš„ mem[] æ•°ç»„æ˜¯äº’ä¸å½±å“çš„ï¼)ã€‚\nå‰©ä½™çš„éƒ¨åˆ†å’Œ xv6 çš„ sh.c åŸºæœ¬æ— å¼‚ï¼Œä»£ä»·è§£è¯»è§ Xv6 æºç è§£è¯»æ‰‹å†Œã€‚\nè¿‘è·ç¦»è§‚æµ‹ sh-xv6.c çš„æ‰§è¡Œè¿‡ç¨‹ï¼Œæˆ‘ä»¬æœ‰ä»¥ä¸‹ä¸¤ç§é€”å¾„ï¼š\nGDBã€‚æ³¨æ„ GDB é»˜è®¤è¿½è¸ªçˆ¶è¿›ç¨‹ï¼Œæˆ‘ä»¬æ›´å¸Œæœ›å…³æ³¨å­è¿›ç¨‹çš„è¡Œä¸ºï¼Œå³æŒ‡ä»¤æ‰§è¡Œçš„è¡Œä¸ºã€‚å¯ä»¥é€šè¿‡ set follow-fork-mode set follow-exec-mode ç­‰æ¥ä¿®æ”¹ GDB çš„è¿½è¸ªè¡Œä¸ºã€‚\nstraceã€‚ä¸ºäº†ä¸å°† shell çš„è¾“å‡ºå’Œ strace çš„è¾“å‡ºæ··èµ·æ¥ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·åšï¼šä½¿ç”¨å‘½ä»¤\nstrace -f -o /tmp/strace.log ./sh å°† strace çš„è¾“å‡ºæ‰“å°åˆ°æ–‡ä»¶ /tmp/strace.log ä¸­ï¼Œ-f é€‰é¡¹å¯ä»¥è¿½è¸ªæ‰€æœ‰å­è¿›ç¨‹çš„ç³»ç»Ÿè°ƒç”¨ã€‚ç„¶åå¦å¼€ä¸€ä¸ªçª—å£æ‰§è¡Œ\ntail -f /tmp/strace.log å…¶ä¸­ -f é€‰é¡¹ä¼š \u0026ldquo;output appended data as the file grows\u0026rdquo; (from man tail)ã€‚é…åˆ Tmuxï¼Œæˆ‘ä»¬å°†è·å¾—è‰¯å¥½çš„ strace è§‚æµ‹ä½“éªŒã€‚\nThe Shell Programming Language ä½¿ç”¨ shell æœ¬è´¨ä¸Šå°±æ˜¯åœ¨ç¼–ç¨‹ã€‚æˆ‘ä»¬ç»„åˆå„ç§æŒ‡ä»¤æ¥å®Œæˆå¤æ‚çš„ä»»åŠ¡ã€‚shell æä¾›åŸºäºæ–‡æœ¬æ›¿æ¢çš„å¿«é€Ÿå·¥ä½œæµçš„æ­å»ºï¼š\né‡å®šå‘ï¼šcmd \u0026gt; /dev/null é¡ºåºç»“æ„ï¼šcmd1 ; cmd2 (ä¸¤è€…éƒ½æ‰§è¡Œ)ï¼Œcmd1 \u0026amp;\u0026amp; cmd2 (å‰è€…è¿”å›å€¼ä¸º 0 æ‰ç»§ç»­æ‰§è¡Œåè€…)ï¼Œcmd1 || cmd2 (å‰è€…è¿”å›å€¼ä¸º 1 æ‰ç»§ç»­æ‰§è¡Œåè€…) etc. ç®¡é“ï¼šcmd1 | cmd2 é¢„å¤„ç†ï¼š$() (å°†ä¸€ä¸ªå‘½ä»¤çš„è¾“å‡ºä½œä¸ºå¦ä¸€ä¸ªå‘½ä»¤çš„å‚æ•°)ï¼Œ\u0026lt;() (å°†ä¸€ä¸ªå‘½ä»¤çš„è¾“å‡ºé‡å®šå‘åˆ°ä¸€ä¸ªæ–‡ä»¶ï¼Œè¿”å›æ–‡ä»¶æè¿°ç¬¦ä½œä¸ºå¦ä¸€ä¸ªå‘½ä»¤çš„å‚æ•°) etc. ç¯å¢ƒå˜é‡ ç°ä»£ GUI èƒ½å®Œæˆçš„äº‹æƒ…ç»å¤§å¤šæ•° CLI ä¹Ÿèƒ½å®Œæˆï¼Œæ¯”å¦‚åœ¨å›¾å½¢ç•Œé¢ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡ç‚¹\u0026quot;å‰\u0026quot; â€œæœ€å°åŒ–â€ æ¥ç®¡ç†å‰åå°ä»»åŠ¡ï¼Œçª—å£ã€‚åœ¨ CLI ä¸­æˆ‘ä»¬ä¹Ÿæœ‰ job controlã€‚åœ¨æ‰§è¡Œå‘½ä»¤æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨åé¢åŠ ä¸Š \u0026amp; ä½¿å…¶åœ¨åå°æ‰§è¡Œï¼›å¯¹äºä¸€ä¸ªæ­£åœ¨å‰å°è¿è¡Œçš„ç¨‹åºï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ ctrl+z å°†å…¶æš‚æ—¶æŒ‚èµ·ï¼Œç”¨ bg %num å°†æŒ‡å®šè¿›ç¨‹æ”¾åˆ°åå°æ‰§è¡Œï¼›å¯¹äºåœ¨åå°è¿è¡Œçš„ç¨‹åºï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ fg %num å°†å…¶æ‹‰åˆ°å‰å°æ‰§è¡Œã€‚\nUNIX shell åœ¨è‡ªç„¶è¯­è¨€ã€æœºå™¨è¯­è¨€å’Œ1970sç®—åŠ›ä¹‹é—´è¾¾åˆ°äº†ä¸€ä¸ªä¼˜é›…çš„å¹³è¡¡ã€‚ä½†å¹³è¡¡æ„å‘³ç€ UNIX shell çš„è®¾è®¡ä¹Ÿä¸æ˜¯å®Œç¾çš„ã€‚ä¾‹å¦‚æ“ä½œçš„ä¼˜å…ˆçº§ï¼š\nls \u0026gt; a.txt | cat é‡å®šå‘å’Œç®¡é“çš„ä¼˜å…ˆçº§è°é«˜ï¼Ÿä½¿ç”¨ä¸åŒçš„ shellä¼šå¾—åˆ°ä¸åŒçš„ç»“æœã€‚(bash ä¸ä¼šæ‰“å°åˆ°ç»ˆç«¯ï¼Œzsh ä¼šæ‰“å°åˆ°ç»ˆç«¯ etc.)\nå†ä¾‹å¦‚æ–‡ä»¶åä¸­çš„ç©ºæ ¼ä¼šå¸¦æ¥å¾ˆå¤§çš„å±é™©ï¼šå¦‚æœä½¿ç”¨å‘½ä»¤ vim \u0026quot;a b.txt\u0026quot;ï¼Œäº‹å®ä¸Šæˆ‘ä»¬è¿ç»­æ‰“å¼€äº† a å’Œ b.txtï¼Œè¿™ä¸æˆ‘ä»¬çš„é¢„æœŸä¸åŒã€‚è¿™æœ¬è´¨ä¸Šæ˜¯å› ä¸ºç©ºæ ¼å…·æœ‰äºŒä¹‰æ€§ï¼šå®ƒæœ‰å¯èƒ½æ˜¯åˆ†éš”æŒ‡ä»¤çš„ç¬¦å·ã€‚(Windows çš„ powershell æœ‰ object stream pipeï¼Œåœ¨ç®¡é“ä¸­ä¼ é€’çš„ä¸œè¥¿ä¸å†æ˜¯æ–‡æœ¬è€Œæ˜¯å¯¹è±¡ï¼Œè¿™ä½¿å¾—æ‰€æœ‰çš„ä¸œè¥¿éƒ½æ˜¯ strongly typed çš„ï¼Œå¯ä»¥é¿å…ä¸Šè¿°é—®é¢˜ã€‚)\nå†æ¯”å¦‚ï¼Œæœ‰äº›è¡Œä¸ºçš„æ„ä¹‰å¯èƒ½æ˜¯éš¾ä»¥ç†è§£çš„ï¼š\necho hello \u0026gt; /etc/a.txt æ— æ³•æ‰§è¡Œï¼Œshell ä¼šè¿”å› permission deniedã€‚è¿™æ—¶æˆ‘ä»¬æœ¬èƒ½åœ°åœ¨å‰é¢åŠ ä¸Š sudoï¼š\nsudo echo hello \u0026gt; /etc/a.txt å´å‘ç°ä»ç„¶æ˜¯ permission deniedã€‚è”æƒ³ xv6-shell ä¸­è§£æå‘½ä»¤çš„æœºåˆ¶ï¼Œæˆ‘ä»¬å°±ä¸éš¾ç†è§£è¿™ä¸ªé—®é¢˜çš„åŸå› ã€‚shell å®Œæˆé‡å®šå‘è¾“å‡ºçš„æ–¹æ³•æ˜¯ï¼šå…³é—­ stdout æ–‡ä»¶ï¼Œæ‰“å¼€ /etc/a.txt æ–‡ä»¶ (å…¶æ–‡ä»¶æè¿°ç¬¦ç»‘å®šä¸º 1)ï¼Œç„¶åæ‰§è¡Œå·¦è¾¹çš„æŒ‡ä»¤ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œsudo åªä¿®é¥°äº†å·¦è¾¹çš„æ‰§è¡Œï¼Œæ‰“å¼€æ–‡ä»¶çš„è¿‡ç¨‹æ²¡æœ‰è·å¾—é«˜æƒé™ï¼Œæ‰€ä»¥æŠ¥é”™ã€‚\nTTY and Job Control æˆ‘ä»¬è¿˜æœ‰ä¸€äº›ç–‘é—®ï¼šä¾‹å¦‚æ²¡æœ‰ä»»ä½•ç¨‹åºåœ¨è¯»é”®ç›˜è¾“å…¥çš„æƒ…å†µä¸‹ä¸ºä»€ä¹ˆ Ctrl+C å¯ä»¥é€€å‡ºç¨‹åºï¼Ÿä¸ºä»€ä¹ˆåœ¨æœ‰äº›åº”ç”¨ (e.g. vim) ä¸­ Ctrl+C ä¸èƒ½é€€å‡ºï¼Ÿå¦‚æœå½“å‰ç¨‹åº fork å‡ºäº†å¤šä¸ªè¿›ç¨‹ï¼ŒCtrl+C ä¼šé€€å‡ºæ‰€æœ‰ç¨‹åºå—ï¼ŸTmux ä¸ºä»€ä¹ˆèƒ½ç®¡ç†å¤šä¸ªçª—å£ï¼Ÿ\nç­”æ¡ˆæ˜¯ç»ˆç«¯ã€‚ç»ˆç«¯æ˜¯ UNIX æ“ä½œç³»ç»Ÿä¸­çš„ä¸€ç±»éå¸¸ç‰¹åˆ«çš„è®¾å¤‡ã€‚å‘½ä»¤è¡Œä¸­æœ‰å·¥å…· tty å¯ä»¥æŸ¥çœ‹è¿æ¥åˆ°æ ‡å‡†è¾“å…¥çš„ç»ˆç«¯æ–‡ä»¶åã€‚å¦‚æœæˆ‘ä»¬åœ¨ Tmux çš„ä¸åŒçª—å£ä¸­ä½¿ç”¨ tty å‘½ä»¤ï¼Œå¯ä»¥çœ‹åˆ°ä¸åŒçš„çª—å£è¿æ¥åˆ°äº†ä¸åŒçš„ç»ˆç«¯è®¾å¤‡ã€‚æˆ‘ä»¬ç”šè‡³å¯ä»¥åšä¸€äº›æœ‰è¶£çš„äº‹æƒ…ï¼šåœ¨ä¸€ä¸ªçª—å£ä¸­ echo hello \u0026gt; /dev/pts/otherï¼Œhello å°†æ˜¾ç¤ºåœ¨å¦ä¸€ä¸ªçª—å£ä¸­ã€‚\nä¸ºä»€ä¹ˆ fork-printf.c å¯ä»¥æ ¹æ®æ ‡å‡†è¾“å‡ºå¯¹è±¡çš„ä¸åŒé€‰æ‹©ä¸åŒçš„ buffer modeï¼Ÿ\né€šè¿‡ strace è§‚å¯Ÿï¼Œå¯ä»¥çœ‹åˆ°ç¨‹åºä½¿ç”¨äº† fstat() ç³»ç»Ÿè°ƒç”¨æŸ¥çœ‹ 1 å·æ–‡ä»¶ (æ ‡å‡†è¾“å‡º) çš„ä¿¡æ¯ã€‚åœ¨æœ‰é‡å®šå‘çš„ç‰ˆæœ¬çš„ç³»ç»Ÿè°ƒç”¨åºåˆ—ä¸­ï¼Œioctl() ç³»ç»Ÿè°ƒç”¨è¿”å›äº† ENOTTYã€‚\nSession, Process Group and Signal Ctrl+C ä¸ºä»€ä¹ˆèƒ½é€€å‡ºï¼Ÿ\nç®€å•æ¥è¯´ï¼Œæˆ‘ä»¬çš„ç»ˆç«¯è´Ÿè´£è¯†åˆ« Ctrl+C çš„æŒ‰é”®ç»„åˆï¼Œå¹¶ç»™å‰å°è¿›ç¨‹å‘é€ä¸€ä¸ª SIGINT ä¿¡å·ã€‚å‰å°ç¨‹åºæœ‰è‡ªç”±å†³å®šå¦‚ä½•å¤„ç†è¿™ä¸ª SIGINT ä¿¡å·ï¼Œç»å¤§éƒ¨åˆ†çš„ç¨‹åºä¼šåœ¨æ¥æ”¶åˆ° SIGINT ä¿¡å·åé€€å‡ºï¼Œä½†æˆ‘ä»¬ä¹Ÿå¯ä»¥è‡ªå·±å†™ä¸€ä¸ª signal handlerï¼š\n// signal-handler.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void handler(int signum) { switch (signum) { case SIGINT: printf(\u0026quot;Received SIGINT!\\n\u0026quot;); break; case SIGQUIT: printf(\u0026quot;Received SIGQUIT!\\n\u0026quot;); exit(0); break; } } void cleanup() { printf(\u0026quot;atexit() cleanup\\n\u0026quot;); } int main() { signal(SIGINT, handler); signal(SIGQUIT, handler); atexit(cleanup); while (1) { char buf[4096]; int nread = read(STDIN_FILENO, buf, sizeof(buf)); buf[nread - 1] = '\\0'; printf(\u0026quot;[%d] Got: %s\\n\u0026quot;, getpid(), buf); if (nread \u0026lt; 0) { perror(\u0026quot;read\u0026quot;); exit(1); } sleep(1); } } ä¸Šé¢çš„ç¨‹åºä¸º SIGINT å’Œ SIGQUIT ä¸¤ä¸ªä¿¡å·æ³¨å†Œäº†å¤„ç†å‡½æ•°ã€‚è¿è¡Œè¯¥ç¨‹åºï¼Œæˆ‘ä»¬å‘ç°æŒ‰ä¸‹ Ctrl+C æ—¶ç¨‹åºä¸ä¼šé€€å‡ºï¼Œè€Œæ˜¯è¾“å‡º Received SIGINT!ã€‚\nè¿™æ—¶æœ‰ä¸€ä¸ªæ›´æœ‰æ„æ€çš„é—®é¢˜ï¼šå¦‚æœæˆ‘ä»¬åœ¨ main() å‡½æ•°å¼€å¤´æ‰§è¡Œä¸€ä¸ª fork()ï¼Œé‚£ä¹ˆçˆ¶å­è¿›ç¨‹çš„æ ‡å‡†è¾“å…¥å’Œè¾“å‡ºä¼šè¿å‘åŒä¸€ä¸ª ttyï¼Œè¿™æ—¶æŒ‰ä¸‹ Ctrl+C ç»ˆç«¯ä¼šå°† SIGINT å‘é€ç»™å“ªä¸ªè¿›ç¨‹å‘¢ï¼Ÿç»è¿‡å®éªŒæˆ‘ä»¬å‘ç°ï¼šfork() ä»¥åçš„ signal-handler.c åœ¨è¾“å…¥å­—ç¬¦æ—¶ï¼Œä¸¤ä¸ªè¿›ç¨‹ä¼šäº‰æŠ¢è¾“å…¥æ•°æ®ï¼Œå‘ˆç°å„æ‰“å°äº†ä¸€éƒ¨åˆ†å†…å®¹çš„ç°è±¡ï¼›å¦‚æœæŒ‰ä¸‹ Ctrl+Cï¼Œä¼šå‡ºç°ä¸¤ä¸ª Received SIGINT!ã€‚è¿™è¯´æ˜ SIGINT ä¿¡å·åŒæ—¶å‘é€ç»™äº†è¿™ä¸¤ä¸ªè¿›ç¨‹ã€‚\né˜…è¯» setpgid() çš„æ‰‹å†Œï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°æ›´ç³»ç»Ÿçš„è§£è¯»ï¼š\nå½“æˆ‘ä»¬æ‰“å¼€ä¸€ä¸ª shell æ—¶ï¼Œæˆ‘ä»¬å°±åˆ›å»ºäº†ä¸€ä¸ªä¼šè¯ (session)ï¼Œè¿™ä¸ªä¼šè¯æœ‰ä¸€ä¸ª controlling terminalã€‚ä¸€ä¸ªä¼šè¯é‡Œé¢å¯ä»¥æœ‰è‹¥å¹²ä¸ªè¿›ç¨‹ç»„ (process group) (æ³¨ï¼šshell æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªè¿›ç¨‹ç»„ï¼Œé€šå¸¸ç§°ä¸º session leader)ï¼Œä¸€ä¸ªè¿›ç¨‹ fork() å¾—åˆ°çš„å­è¿›ç¨‹å’Œçˆ¶è¿›ç¨‹åŒå±ä¸€ä¸ªè¿›ç¨‹ç»„ï¼Œexecve() ä¸ä¼šæ”¹å˜ä¸€ä¸ªè¿›ç¨‹æ‰€å±çš„è¿›ç¨‹ç»„ã€‚åœ¨ä»»ä½•æ—¶åˆ»ï¼Œä¸€ä¸ªä¼šè¯é‡Œæœ‰ä¸”ä»…æœ‰ä¸€ä¸ªå‰å° (foreground) è¿›ç¨‹ç»„ï¼Œå‰©ä½™çš„è¿›ç¨‹ç»„éƒ½æ˜¯åå°è¿›ç¨‹ç»„ã€‚å½“ç»ˆç«¯ç»™ä¼šè¯å‘é€ä¸€ä¸ªä¿¡å·æ—¶ï¼Œå‰å°è¿›ç¨‹ç»„é‡Œçš„æ¯ä¸ªè¿›ç¨‹éƒ½ä¼šæ¥æ”¶åˆ°è¿™ä¸ªä¿¡å·ã€‚åªæœ‰å‰å°è¿›ç¨‹ç»„ä¸­çš„è¿›ç¨‹å¯ä»¥ä»ç»ˆç«¯è¯»å–æ•°æ®ï¼Œå¦‚æœåå°è¿›ç¨‹å°è¯•ä»ç»ˆç«¯è¯»å–æ•°æ®ï¼Œä¼šæ¥æ”¶åˆ°ä¸€ä¸ª SIGTTIN ä¿¡å·ï¼Œè¯¥ä¿¡å·ä¼šå°†åå°è¿›ç¨‹æŒ‚èµ·ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"51f4789da767c900277c2c1efabf126f","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec13/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec13/","section":"notes","summary":"æˆ‘ä»¬æ˜¯æ“ä½œç³»ç»Ÿç”¨æˆ·ï¼Œä½†æ“ä½œç³»ç»Ÿ API å¹¶ä¸æ˜¯æˆ‘ä»¬ä½œä¸ºäººç±»ç”¨æˆ·ç›´æ¥ä½¿ç”¨çš„ï¼Œé‚£ä¹ˆâ€œæˆ‘ä»¬â€åˆ°åº•åº”è¯¥æ€ä¹ˆä½¿ç”¨æ“ä½œç³»ç»Ÿï¼Ÿ\nShell æˆ‘ä»¬éœ€è¦ä¸€ä¸ªä¸äººç±»äº¤äº’çš„ç¨‹åºï¼Œè¿™å°±æ˜¯ Shellã€‚ä¹‹æ‰€ä»¥å«åš shellï¼Œæ˜¯å› ä¸ºå®ƒå°±åƒåŒ…è£¹ä½æ“ä½œç³»ç»Ÿå†…æ ¸çš„ä¸€å±‚â€œå£³â€ï¼šå®ƒå‘å†…ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨ä¸å†…æ ¸äº¤äº’ï¼Œå‘å¤–ä¸äººç±»ç”¨æˆ·äº¤äº’ã€‚(Shell ä¸ä¸€å®šæ˜¯å‘½ä»¤è¡Œç»ˆç«¯ï¼ç°åœ¨çš„å›¾å½¢ç•Œé¢ä¹Ÿæ˜¯ä¸€ç§ graphical shellã€‚)\nShell æœ¬è´¨ä¸Šæ˜¯ä¸€é—¨ â€œæŠŠç”¨æˆ·æŒ‡ä»¤ç¿»è¯‘æˆç³»ç»Ÿè°ƒç”¨çš„ç¼–ç¨‹è¯­è¨€â€ã€‚(åœ¨ CLI æ—¶ä»£è¿™ä¸€ç‚¹ä½“ç°å¾—æ›´æ˜æ˜¾)\nXv6 Shell å…³äº -ffreestanding\n-ffreestanding Assert that compilation targets a freestanding environment. This implies -fno-builtin.","tags":null,"title":"Lecture 13: System Calls and UNIX Shell","type":"docs"},{"authors":null,"categories":null,"content":"sh-xv6.c å¯ä»¥åœ¨ freestanding çš„ç¯å¢ƒä¸‹ç›´æ¥è¿è¡Œï¼šæˆ‘ä»¬æœ€ç»ˆä½¿ç”¨ ld sh-xv6.o -o sh ç”ŸæˆäºŒè¿›åˆ¶æ–‡ä»¶ï¼Œè¿™æ„å‘³ç€äºŒè¿›åˆ¶æ–‡ä»¶ä¸­æœ‰ä¸”ä»…æœ‰ sh-xv6.o ä¸­çš„å‡½æ•°ã€‚\næˆ‘ä»¬å¹³æ—¶åœ¨ç¼–å†™ç¨‹åºçš„æ—¶å€™æ˜¾ç„¶ä¸å¸Œæœ›åœ¨ freestanding çš„ç¯å¢ƒä¸‹ç¼–ç¨‹â€”â€”è”æƒ³æˆ‘ä»¬åœ¨ sh-xv6.c ä¸­ï¼Œè¯»å–å­—ç¬¦ä¸²éƒ½è¦ç”¨å…§è”æ±‡ç¼–çš„ç³»ç»Ÿè°ƒç”¨ï¼Œè¿™å¤ªç³Ÿç³•äº†ã€‚æˆ‘ä»¬è‡ªç„¶è€Œç„¶åœ°å¸Œæœ›æœ‰ä¸€äº›å°è£…å¥½çš„åº“å‡½æ•°å¯ä»¥ä½¿ç”¨ã€‚\nLibc: Overview Portability åœ¨ freestanding ç¯å¢ƒä¸‹æˆ‘ä»¬ä¹Ÿæœ‰ä¸€äº›åº“å¯ä»¥ä½¿ç”¨ã€‚å¦‚æœæˆ‘ä»¬æƒ³å†™å‡ºå¯ç§»æ¤æ€§å¼ºçš„ä»£ç ï¼Œæˆ‘ä»¬åº”è¯¥ä½¿ç”¨ libc ä¸­æä¾›çš„æ•°æ®ç±»å‹ï¼š\næ¯”å¦‚æˆ‘ä»¬è¦ä¿å­˜ä¸€ä¸ªæŒ‡é’ˆçš„å€¼ï¼ŒççŒœä¸€ä¸ª int long ä¸æ˜¯å¥½çš„é€‰æ‹©ï¼Œæˆ‘ä»¬åº”è¯¥ç”¨ intptr_t (è¯¥ç±»å‹åœ¨ stdint.h ä¸­å®šä¹‰)ï¼›æ¯”å¦‚æˆ‘ä»¬æƒ³ä¿å­˜ä¸€ä¸ª 4 å­—èŠ‚çš„æ•°æ®ï¼Œåº”è¯¥ä½¿ç”¨ int32_tã€‚(long çš„é•¿åº¦æ˜¯éšæ¶æ„å˜åŒ–çš„) ç­‰ç­‰ã€‚\nC è¯­è¨€æ”¯æŒè¾¹é•¿å‚æ•°ã€‚ä¾‹å¦‚ printf() çš„å£°æ˜æ˜¯ï¼š\nint printf(const char *format, ...); åœ¨ x86 æ¶æ„ä¸­ï¼Œå‚æ•°æ˜¯ä¸€ä¸ªæ¥ç€ä¸€ä¸ªæ”¾åœ¨æ ˆä¸Šçš„ï¼Œå› æ­¤åœ¨ä¸€äº› i386 çš„ä»£ç ä¸­æˆ‘ä»¬å¯èƒ½ä¼šçœ‹è§ä¸‹é¢çš„è¿™ç§å†™æ³•ï¼š\nvoid **p = (void *)\u0026amp;fmt; // use p[i] to get the address of the ith argument ä½† riscv64, x86-64 ç­‰æ¶æ„æ˜¯ç”¨å¯„å­˜å™¨ä¼ é€’å‚æ•°çš„ã€‚ä¸ºäº†å†™å‡ºå¯ç§»æ¤æ€§æ›´å¥½çš„ä»£ç ï¼Œæˆ‘ä»¬åº”è¯¥ä½¿ç”¨ va_list ç±»å‹ï¼Œç„¶åç”¨ va_start() va_arg() va_end() ç­‰ API å»è®¿é—®å„ä¸ªå‚æ•° (è¯¥ç±»å‹åœ¨ stdarg.h ä¸­å®šä¹‰)ã€‚\nä½¿ç”¨ libc ä¸€å®šé«˜æ•ˆå—?\nä¸ä¸€å®šã€‚GCC çš„é—ç•™é—®é¢˜ä½¿å¾—ä½¿ç”¨ libc ç¼–è¯‘å‡ºçš„æ±‡ç¼–ä»£ç å¯èƒ½ä¼šâ€œå¾ˆç¬¨â€ã€‚ä¾‹å¦‚ sh-xv6.c ä¸­å…³äºç³»ç»Ÿè°ƒç”¨çš„è¿™æ®µä»£ç ï¼š\nlong syscall(int num, ...) { va_list ap; va_start(ap, num); register long a0 asm (\u0026quot;rax\u0026quot;) = num; register long a1 asm (\u0026quot;rdi\u0026quot;) = va_arg(ap, long); register long a2 asm (\u0026quot;rsi\u0026quot;) = va_arg(ap, long); register long a3 asm (\u0026quot;rdx\u0026quot;) = va_arg(ap, long); register long a4 asm (\u0026quot;r10\u0026quot;) = va_arg(ap, long); va_end(ap); asm volatile(\u0026quot;syscall\u0026quot; : \u0026quot;+r\u0026quot;(a0) : \u0026quot;r\u0026quot;(a1), \u0026quot;r\u0026quot;(a2), \u0026quot;r\u0026quot;(a3), \u0026quot;r\u0026quot;(a4) : \u0026quot;memory\u0026quot;, \u0026quot;rcx\u0026quot;, \u0026quot;r8\u0026quot;, \u0026quot;r9\u0026quot;, \u0026quot;r11\u0026quot;); return a0; } å¦‚æœæˆ‘ä»¬åˆ†åˆ«ä¸º 1,2,3,4 ä¸ªå‚æ•°çš„ç³»ç»Ÿè°ƒç”¨å†™ 4 ä¸ªæ¥å£ï¼Œåƒä¸‹é¢è¿™æ ·ï¼š\nlong syscall4(long num, long a1, long a2, long a3, long a4) { long a0 = num; asm volatile(\u0026quot;syscall\u0026quot; : \u0026quot;+r\u0026quot;(a0) : \u0026quot;r\u0026quot;(a1), \u0026quot;r\u0026quot;(a2), \u0026quot;r\u0026quot;(a3), \u0026quot;r\u0026quot;(a4) : \u0026quot;memory\u0026quot;, \u0026quot;rcx\u0026quot;, \u0026quot;r8\u0026quot;, \u0026quot;r9\u0026quot;, \u0026quot;r11\u0026quot;); return a0; } è§‚å¯Ÿä¸¤è€…åœ¨ -O2 ä¼˜åŒ–ä¸‹åæ±‡ç¼–çš„ç»“æœï¼Œå¯ä»¥çœ‹åˆ°å‰è€…åœ¨å¯„å­˜å™¨å’Œæ ˆä¸Šæ¥å›å€’è…¾æ•°æ®ï¼Œè€Œåè€…åªç”¨äº†å¾ˆå°‘çš„ä»£ç å°±å®Œæˆäº†å·¥ä½œã€‚\nprintf() çš„æ¨¡å¼ä¸²ä¸­ä¹Ÿæ¶‰åŠå¯ç§»æ¤æ€§çš„é—®é¢˜ã€‚æ¯”å¦‚æˆ‘ä»¬å¯èƒ½å¸¸å¸¸è¿™ä¹ˆå†™ç¨‹åºï¼š\nint64_t a = 1; printf(\u0026quot;%ld\\n\u0026quot;, a); ä½† %ld æ˜¯ç”¨äºæ‰“å°ä¸€ä¸ª long é•¿åº¦çš„å˜é‡çš„ï¼Œlong çš„é•¿åº¦éšæ¶æ„å˜åŒ–è€Œå˜åŒ–ï¼Œä¸Šè¿°ä»£ç åœ¨ 32 ä½çš„æ¶æ„ä¸Šå°±ä¼šæŠ¥ warningã€‚inttypes.h å…¶å®ä¸ºæ¨¡å¼ä¸²çš„å¯ç§»æ¤æ€§ä¹Ÿè®¾è®¡äº†ä¸€å¥—ç¬¦å· (ä½†å¾ˆå¤æ‚)ã€‚\nConvenience å¹¶ä¸æ˜¯æ‰€æœ‰çš„ç³»ç»Ÿè°ƒç”¨éƒ½åƒ fork() é‚£æ ·ç®€å•æ˜“ç”¨ï¼Œå› æ­¤åº“å‡½æ•°æœ‰ä¹‰åŠ¡å°†ç³»ç»Ÿè°ƒç”¨å°è£…æˆæ›´æ˜“ç”¨çš„æ ·å­ï¼Œæ¯”å¦‚ï¼š\nextern char **environ; char *argv[] = {\u0026quot;echo\u0026quot;, \u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;, NULL, }; if (execve(argv[0], argc, environ) \u0026lt; 0) perror(\u0026quot;exec\u0026quot;); è¿è¡Œä¸Šè¿°ç¨‹åºï¼Œæˆ‘ä»¬ä¼šå¾—åˆ° exec: No such file or directoryã€‚è¿™æ˜¯å› ä¸º execve() è¦æ±‚ç¬¬ä¸€ä¸ªå‚æ•°å¿…é¡»æ˜¯å®Œæ•´çš„ pathnameã€‚ä¸€äº›é«˜æƒ…å•†çš„ API æ˜¯è¿™æ ·å°è£…çš„ï¼š\nexeclp(\u0026quot;echo\u0026quot;, \u0026quot;echo\u0026quot;, \u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;, NULL); system(\u0026quot;echo hello world\u0026quot;); exec() å®¶æ—çš„åº“å‡½æ•°æœ‰å¾ˆå¤šï¼š\nl ç³»åˆ—çš„å‡½æ•°æ”¯æŒå˜é•¿å‚æ•°ï¼Œæˆ‘ä»¬ä¸ç”¨å•ç‹¬å¼€ä¸€ä¸ªå‚æ•°æ•°ç»„ argv[] è€Œå¯ä»¥ç›´æ¥æŠŠè¦ä¼ çš„å‚æ•°æ”¾è¿›å»ã€‚ä¸ä¹‹ç›¸å¯¹åœ°ï¼Œv ç³»åˆ—çš„å‡½æ•°å°†å‚æ•°ä¿å­˜å¥½ä»¥åï¼Œå°† argv[] æ”¾åˆ°å‡½æ•°ä¸­å³å¯ï¼Œè¿™å¯¹äºå¤šæ¬¡ä½¿ç”¨åŒæ ·å‚æ•°å¾ˆæœ‰åˆ©ã€‚ p ç³»åˆ—çš„å‚æ•°åœ¨ç¬¬ä¸€ä¸ª pathname ä¸­æ²¡æœ‰ / çš„æƒ…å†µä¸‹ï¼Œä¼šéå† PATH ç¯å¢ƒå˜é‡ä¸­çš„æ‰€æœ‰è·¯å¾„ï¼Œå°†å…¶æ¥åœ¨æ–‡ä»¶åå‰é¢å¹¶å°è¯• execve()ã€‚ e ç³»åˆ—å¯ä»¥ä¸ä½¿ç”¨ç³»ç»Ÿç¯å¢ƒé»˜è®¤çš„ç¯å¢ƒå˜é‡ï¼Œè€Œæ˜¯ä¼ å…¥ä¸€ä¸ª envp[] æ•°ç»„æŒ‡å®šç¯å¢ƒå˜é‡ (é e ç³»åˆ—çš„å‡½æ•°é»˜è®¤ä»¥ extern char *environ[] çš„å†…å®¹ä½œä¸ºç¯å¢ƒå˜é‡)ã€‚ æ›´å¤šçš„å†…å®¹å¯ä»¥æŸ¥çœ‹æ‰‹å†Œã€‚\nEncapsulation: Calculation çº¯è®¡ç®—çš„å·¥ä½œæ˜¯æˆ‘ä»¬å¤§é‡ä½¿ç”¨å¹¶æƒ³è¦å°è£…çš„ï¼Œæ¯”å¦‚ç»Ÿè®¡å­—ç¬¦ä¸²çš„é•¿åº¦ã€ç»™ä¸€æ®µå†…å­˜èµ‹å€¼ç­‰ç­‰ã€‚è¿™çœ‹ä¸Šå»æ˜¯éå¸¸ç®€å•çš„äº‹æƒ…ï¼Œä½†å¦‚æœè€ƒè™‘åˆ°æ•ˆç‡ï¼Œå®‰å…¨æ€§ç­‰å› ç´ ï¼Œäº‹æƒ…å°±å˜å¾—å¤æ‚äº†ã€‚æ¯”å¦‚å¦‚ä¸‹ä¸€æ®µ memset çš„å®ç°ï¼š\nvodi *memset(void *s, int c, size_t n) { for (size_t i = 0; i \u0026lt; n; i++) ((char *)s)[i] = c; return s; } å¦‚æœæœ‰å¤šä¸ªçº¿ç¨‹è°ƒç”¨è¯¥ç¨‹åºï¼Œå®ƒèƒ½ä¿è¯å®‰å…¨æ€§å—ï¼Ÿæ•°æ®ä¼šäº’ç›¸è¦†ç›–å—ï¼Ÿæˆ‘ä»¬å¯ä»¥å…ˆç”¨ libc æ ‡å‡†çš„ memset() æ¥æµ‹è¯•ä¸€ä¸‹å¤šçº¿ç¨‹ä¸‹çš„è¡¨ç°ï¼š\n// memset-race.c#include \u0026quot;thread.h\u0026quot;char buf[1 \u0026lt;\u0026lt; 30];void foo(int id) { memset(buf, '0' + id, sizeof(buf) - 1);}int main() { for (int i = 0; i \u0026lt; 4; i++) create(foo); join(); puts(buf);} å¤šä¸ªçº¿ç¨‹åŒæ—¶å¯¹ä¸€æ®µå†…å­˜èµ‹å€¼ï¼Œè¿™æ˜¯ä¸€ä¸ªæ ‡å‡†çš„æ•°æ®ç«äº‰ã€‚è¿è¡Œè¿™æ®µç¨‹åºæˆ‘ä»¬å¯ä»¥çœ‹åˆ° 1,2,3,4 éƒ½æœ‰è¢«è¾“å‡ºã€‚æ ¹æ®æ ‡å‡†ï¼Œæ ‡å‡†åº“åªå¯¹â€œæ ‡å‡†åº“å†…éƒ¨æ•°æ®â€çš„çº¿ç¨‹å®‰å…¨æ€§è´Ÿè´£ (æ¯”å¦‚ printf çš„ buffer æ˜¯æœ‰é”ä¿æŠ¤çš„)ï¼Œå¯¹å¤–éƒ¨æ•°æ®åº“å‡½æ•°æ²¡æœ‰ä¹‰åŠ¡å¤„ç†æ•°æ®ç«äº‰ã€‚\né™¤æ­¤ä¹‹å¤–ï¼Œå°è£…çš„â€œå¥½ç”¨â€ä¹Ÿæ˜¯æˆ‘ä»¬çš„ä¸€å¤§ç›®æ ‡ã€‚æˆ‘ä»¬å¯ä»¥å¯¹æ¯” C è¯­è¨€çš„æ’åºå‡½æ•°å’Œ C++ çš„æ’åºå‡½æ•°ï¼š\nvoid qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *)); sort(xs.begin(), xs.end(), [](auto \u0026amp;a, auto *b) {...}); å¯ä»¥çœ‹åˆ° C++ çš„åº“å‡½æ•°æ˜æ˜¾æ›´å¥½ç”¨ï¼šæˆ‘ä»¬å¯ä»¥ç›´æ¥ç”¨è¿­ä»£å™¨çš„ begin å’Œ endï¼Œè¿˜å¯ä»¥ç”¨ lambda è¡¨è¾¾å¼æŠŠæ¯”è¾ƒå‡½æ•°ç›´æ¥å†™åœ¨ sort() é‡Œé¢ã€‚\nEncapsulation: File Descriptors æ“ä½œç³»ç»Ÿæœ‰ä¹‰åŠ¡å°è£…å¯¹è±¡ (æ¯”å¦‚ç»ˆç«¯ï¼Œç®¡é“ï¼Œæ–‡ä»¶ etc.) å¹¶æš´éœ²åˆé€‚çš„ API ç»™åº”ç”¨ç¨‹åºã€‚ç”±äº UNIX ç§‰æŒ everything is a file çš„å“²å­¦ï¼Œæ‰€ä»¥å°è£…å¯¹è±¡çš„æ ¸å¿ƒå°±æ˜¯æ–‡ä»¶æè¿°ç¬¦ã€‚\nè€ƒè™‘å¦‚ä¸‹ç¨‹åºï¼š\nint main () { FILE *fp = fopen(\u0026quot;a.txt\u0026quot;, \u0026quot;w\u0026quot;); fprintf(fp, \u0026quot;Hello, world\\n\u0026quot;); return 0;} å®ƒä¼šå‘ a.txt è¾“å‡º Hello, worldã€‚è¿™é‡Œçš„æ–‡ä»¶æŒ‡é’ˆäº‹å®ä¸ŠæŒ‡å‘çš„å°±æ˜¯æ–‡ä»¶ç»“æ„ä½“ã€‚æˆ‘ä»¬å¯ä»¥å°è¯•ç”¨ GDB è°ƒè¯•è¿™æ®µä»£ç ï¼Œç”¨ p *fp æ‰“å° fp æŒ‡é’ˆæŒ‡å‘çš„å†…å®¹ï¼š\n{_flags = -72539004, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x7ffff7fa15e0 \u0026lt;_IO_2_1_stderr_\u0026gt;, _fileno = 3, _flags2 = 0, _old_offset = 0, _cur_column = 0, _vtable_offset = 0 '\\000', _shortbuf = \u0026quot;\u0026quot;, _lock = 0x555555559380, _offset = -1, _codecvt = 0x0, _wide_data = 0x555555559390, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = '\\000' \u0026lt;repeats 19 times\u0026gt;} å¯ä»¥çœ‹åˆ°è¿™æ˜¯ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ä¸º 3 çš„æ–‡ä»¶ã€‚å¦‚æœæˆ‘ä»¬ç”¨ p *stdin/*stdout/*stderr æ‰“å°ï¼Œä¹Ÿå¯ä»¥çœ‹åˆ°ç±»ä¼¼çš„å†…å®¹ï¼Œæ ‡å‡†è¾“å…¥/è¾“å‡º/é”™è¯¯éƒ½æ˜¯æ–‡ä»¶ã€‚\nå¦ä¸€ä¸ªæœ‰æ„æ€çš„ API æ˜¯ popen()ï¼Œå®ƒå¯ä»¥æ‰“å¼€ä¸€ä¸ªç®¡é“ã€‚è¿™å…¶å®æ˜¯ä¸€ä¸ªè®¾è®¡çš„æœ‰ç¼ºé™·çš„ APIï¼šæ‰‹å†Œä¸­æ˜ç¡®æåˆ° UNIX pipe æ˜¯å•å‘çš„ï¼šå®ƒæœ‰ä¸€ä¸ªè¯»å£å’Œä¸€ä¸ªå†™å£ï¼Œè€Œæ–‡ä»¶æŒ‡é’ˆ FILE * åªèƒ½å°è£…ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼Œæ‰€ä»¥ä½¿ç”¨ popen() å¿…é¡»æŒ‡å®šä»ç®¡é“è¯»è¿˜æ˜¯å†™å‘ç®¡é“ã€‚(ç°ä»£çš„ç¼–ç¨‹è¯­è¨€å¯¹ç®¡é“ API å°è£…çš„æ›´å¥½ã€‚)\nEncapsulation: Utilities err ä¸ºä»€ä¹ˆ cat nonexist.c gcc nonexist.c ç­‰å‘½ä»¤è¾“å‡ºçš„éƒ½æ˜¯ \u0026ldquo;xxx: nonexist.c: No such file or directory\u0026rdquo;?\næˆ‘ä»¬ä¹Ÿå¯ä»¥ç”¨åº“å‡½æ•°å±±å¯¨ä¸€ä¸ªç±»ä¼¼çš„ç‰ˆæœ¬ï¼š\n// err-message.c#include \u0026lt;err.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;int main (){\tconst char *filename = \u0026quot;nonexist.c\u0026quot;;\tFILE *fp = fopen(filename, \u0026quot;r\u0026quot;);\tif (!fp) warn(\u0026quot;%s\u0026quot;, filename);\treturn 0;} err.h errno.h æä¾›è‹¥å¹²è¿™æ ·å°†é”™è¯¯ä¿¡æ¯è¾“å‡ºåˆ°æ ‡å‡†é”™è¯¯çš„å‡½æ•°ï¼Œå¥½ç”¨çš„å‡½æ•°è¿˜æœ‰ perror()ï¼Œerr() ç­‰ã€‚err() å¯ä»¥åœ¨è¾“å‡ºé”™è¯¯ä¿¡æ¯åç›´æ¥é€€å‡ºç¨‹åºï¼Œå¦‚ï¼š\nfd = open(filename, O_RONLY, 0);if (fd == -1) err(EXIT_FAILURE, \u0026quot;%s\u0026quot;, filename); è¿™äº›å‡½æ•°çš„åŸç†æ˜¯æ ¹æ®å…¨å±€å˜é‡ errno çš„æ•°å€¼ï¼Œæ‰“å°ä¸Šä¸€æ¬¡é”™è¯¯çš„åŸå› ã€‚æ‰‹å†Œä¸­å¯¹äº errno çš„è§£é‡Šä¸ºï¼š\nerrno is defined by the ISO C standard to be a modifiable lvalue of type int, and must not be explicitly declared; errno may be a macro. errno is thread-local; setting it in one thread does not affect its value in any other thread.\nå€¼å¾—æ³¨æ„çš„ä¸€ç‚¹æ˜¯ errno æ˜¯çº¿ç¨‹ç‹¬äº«çš„ thread-local å˜é‡ã€‚ä»è¿™é‡Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°åç¨‹ç›¸å¯¹äºçº¿ç¨‹æ›´è½»é‡çº§ä½“ç°åœ¨ä½•å¤„ã€‚\nenviron // env.c#include \u0026lt;stdio.h\u0026gt;int main() { extern char **environ; for (char **env = environ; *env; env++) { printf(\u0026quot;%s\\n\u0026quot;, *env); }} C åº“å‡½æ•°ä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªæŒ‡é’ˆ environï¼Œé€šè¿‡å®ƒæˆ‘ä»¬å¯ä»¥æ‰¾åˆ°ç¯å¢ƒå˜é‡åˆ—è¡¨ã€‚ä¸€ä¸ªè‡ªç„¶çš„é—®é¢˜æ˜¯ï¼šè¿™ä¸ªæŒ‡é’ˆæ˜¯ä»€ä¹ˆæ—¶å€™æŒ‡å‘æ­£ç¡®çš„ä½ç½®çš„ï¼Ÿ\næˆ‘ä»¬å¯èƒ½è®¤ä¸ºåœ¨ CPU reset åˆ° boot å®ŒæˆæœŸé—´ environ å°±è¢«è®¾ç½®å¥½äº†ï¼Œä½†è€ƒè™‘åˆ°ä¸€ä¸ªç¨‹åºçš„ç¯å¢ƒå˜é‡æ˜¯åœ¨ execve() çš„æ—¶å€™ä¼ è¿›å»çš„ï¼Œä¸åŒç¨‹åºå¯ä»¥ä¸ä¸€æ ·ï¼Œè¿™ä¸ªå˜é‡æ˜¾ç„¶åº”è¯¥æ˜¯åœ¨è¿›ç¨‹åŠ è½½å¯åŠ¨æ—¶æ‰è®¾ç½®çš„ã€‚\næˆ‘ä»¬å¯ä»¥ç”¨ GDB è§‚æµ‹è¿™ä¸ªè¡Œä¸ºã€‚åœ¨é™æ€åŠ è½½ä¸‹ï¼Œç”¨ gdb ./env å¯åŠ¨ä¸Šè¿°ç¨‹åºå¹¶ç”¨ starti åœåœ¨ç¬¬ä¸€æ¡æ±‡ç¼–æŒ‡ä»¤ï¼ŒæŸ¥çœ‹ p (char **)environ ï¼Œå‘ç°æ­¤æ—¶ environ è¿˜æ˜¯ç©ºæŒ‡é’ˆã€‚æˆ‘ä»¬å¯ä»¥åœ¨ environ ä¸ŠåŠ ç›‘è§†ç‚¹ wa (char **)environ ï¼Œå³å¯çœ‹åˆ°åœ¨ __libc_start_main() å‡½æ•°ä¸­ä¿®æ”¹äº† environã€‚\nä¸ºä»€ä¹ˆæˆ‘åŠ¨æ€é“¾æ¥æ—¶æ— æ³•æŸ¥çœ‹ environ çš„ä¿¡æ¯ï¼Ÿ\nEncapsulation: Address Space libc ä¸ºæˆ‘ä»¬å°è£…å¥½äº†åœ°å€ç©ºé—´ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ mmaps() ä¿®æ”¹åœ°å€ç©ºé—´æ˜ å°„ï¼Œä¹Ÿå¯ä»¥é€šè¿‡ malloc() å’Œ free() ä»å †åŒºé‡Œç”³è¯·/é‡Šæ”¾ç©ºé—´ã€‚\næƒ³è¦ä¼˜åŒ– malloc()/free() çš„æ€§èƒ½ï¼Œæˆ‘ä»¬è¦å¯¹ workload æœ‰æ­£ç¡®çš„å‡è®¾ã€‚æŒ‡å¯¼æ€æƒ³ï¼š$O(n)$ å¤§å°çš„å¯¹è±¡åˆ†é…åè‡³å°‘æœ‰ $\\Omega(n)$ çš„è¯»å†™æ“ä½œï¼Œå¦åˆ™å°±æ˜¯ performance bugã€‚\nè¶Šå°çš„å¯¹è±¡åˆ›å»º/åˆ†é…è¶Šé¢‘ç¹ (e.g. å­—ç¬¦ä¸²ï¼Œä¸´æ—¶å¯¹è±¡ç­‰ï¼Œç”Ÿå­˜å‘¨æœŸä¸é•¿) è¾ƒä¸ºé¢‘ç¹åœ°åˆ†é…ä¸­ç­‰å¤§å°å¯¹è±¡ (e.g. å¤æ‚çš„å¯¹è±¡ï¼Œè¾ƒå¤§çš„æ•°ç»„) ä½é¢‘ç‡çš„å¤§å¯¹è±¡ (e.g. å·¨å¤§çš„å®¹å™¨ï¼Œåˆ†é…å™¨ï¼›å¾ˆé•¿çš„ç”Ÿå­˜å‘¨æœŸ) æ ¸å¿ƒä¼˜åŒ–æ€æƒ³ï¼šFast path + slow pathï¼Œäº‰å–åœ¨ fast path ä¸Šåšåˆ° $O(1)$ (æ— é”æˆ–æ—  contention)ã€‚è®¡ç®—æœºç³»ç»Ÿçš„ä¸–ç•Œä¸­å¤„å¤„æ˜¯ fast path + slow pathï¼Œæ¯”å¦‚ memory hierarchyã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"f6a8b4fb882c353ae5d94e04c59b1986","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec14/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec14/","section":"notes","summary":"sh-xv6.c å¯ä»¥åœ¨ freestanding çš„ç¯å¢ƒä¸‹ç›´æ¥è¿è¡Œï¼šæˆ‘ä»¬æœ€ç»ˆä½¿ç”¨ ld sh-xv6.o -o sh ç”ŸæˆäºŒè¿›åˆ¶æ–‡ä»¶ï¼Œè¿™æ„å‘³ç€äºŒè¿›åˆ¶æ–‡ä»¶ä¸­æœ‰ä¸”ä»…æœ‰ sh-xv6.o ä¸­çš„å‡½æ•°ã€‚\næˆ‘ä»¬å¹³æ—¶åœ¨ç¼–å†™ç¨‹åºçš„æ—¶å€™æ˜¾ç„¶ä¸å¸Œæœ›åœ¨ freestanding çš„ç¯å¢ƒä¸‹ç¼–ç¨‹â€”â€”è”æƒ³æˆ‘ä»¬åœ¨ sh-xv6.c ä¸­ï¼Œè¯»å–å­—ç¬¦ä¸²éƒ½è¦ç”¨å…§è”æ±‡ç¼–çš„ç³»ç»Ÿè°ƒç”¨ï¼Œè¿™å¤ªç³Ÿç³•äº†ã€‚æˆ‘ä»¬è‡ªç„¶è€Œç„¶åœ°å¸Œæœ›æœ‰ä¸€äº›å°è£…å¥½çš„åº“å‡½æ•°å¯ä»¥ä½¿ç”¨ã€‚\nLibc: Overview Portability åœ¨ freestanding ç¯å¢ƒä¸‹æˆ‘ä»¬ä¹Ÿæœ‰ä¸€äº›åº“å¯ä»¥ä½¿ç”¨ã€‚å¦‚æœæˆ‘ä»¬æƒ³å†™å‡ºå¯ç§»æ¤æ€§å¼ºçš„ä»£ç ï¼Œæˆ‘ä»¬åº”è¯¥ä½¿ç”¨ libc ä¸­æä¾›çš„æ•°æ®ç±»å‹ï¼š\næ¯”å¦‚æˆ‘ä»¬è¦ä¿å­˜ä¸€ä¸ªæŒ‡é’ˆçš„å€¼ï¼ŒççŒœä¸€ä¸ª int long ä¸æ˜¯å¥½çš„é€‰æ‹©ï¼Œæˆ‘ä»¬åº”è¯¥ç”¨ intptr_t (è¯¥ç±»å‹åœ¨ stdint.","tags":null,"title":"Lecture 14: C Library","type":"docs"},{"authors":null,"categories":null,"content":"fork() Semantics fork() çš„è¯­ä¹‰æ˜¯å°†å½“å‰è¿›ç¨‹çš„çŠ¶æ€æœºå®Œæ•´åœ°å¤åˆ¶ä¸€ä»½ï¼Œè¿™ä¸¤ä¸ªè¿›ç¨‹é™¤äº† fork() çš„è¿”å›å€¼ä»¥å¤–å…¨éƒ¨ç›¸åŒã€‚\nFile Descriptors æˆ‘ä»¬è¿™é‡Œå…³æ³¨æ–‡ä»¶æè¿°ç¬¦ï¼šæ ¹æ® fork() çš„è¯­ä¹‰ï¼Œå­è¿›ç¨‹å’Œçˆ¶è¿›ç¨‹ä¼šæ‹¥æœ‰ç›¸åŒçš„æ–‡ä»¶æè¿°ç¬¦ (æ–‡ä»¶æè¿°ç¬¦å¯ä»¥ç†è§£ä¸ºæŒ‡å‘æ“ä½œç³»ç»Ÿå¯¹è±¡çš„æŒ‡é’ˆ)ã€‚execve() ä¼šé‡ç½®çŠ¶æ€æœºï¼Œä½†ä¼šç»§æ‰¿åŸè¿›ç¨‹æŒæœ‰çš„æ‰€æœ‰æ“ä½œç³»ç»Ÿå¯¹è±¡ã€‚è¿™ä¸ªè®¾è®¡ä½¿æˆ‘ä»¬åœ¨ UNIX shell ä¸­å¯ä»¥åˆ©ç”¨ç®¡é“æŠ€æœ¯ï¼Œåœ¨ execve() ä¹‹å‰ä¿®æ”¹ stdin, stdout ä»¥å®Œæˆè¿›ç¨‹ä¹‹é—´æ•°æ®çš„ä¼ è¾“ã€‚\nexecve() ä¼šæ— æ¡ä»¶ç»§æ‰¿æ‰€æœ‰çš„å¯¹è±¡å—ï¼Ÿ\nåœ¨ open() çš„æ‰‹å†Œä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°æ‰“å¼€æ–‡ä»¶æ—¶æœ‰ä¸€ä¸ªæ ‡å¿—æ˜¯ O_CLOEXECï¼Œè¿™æ ·æ‰“å¼€çš„æ–‡ä»¶åœ¨ execve() çš„æ—¶å€™ä¸ä¼šè¢«ç»§æ‰¿ã€‚\næ–‡ä»¶æè¿°ç¬¦å…¶å®ä¸ä»…ä»…æ˜¯æŒ‡å‘å¯¹è±¡çš„æŒ‡é’ˆã€‚æˆ‘ä»¬åœ¨ä¸€ä¸ªç¨‹åºä¸­å†™ä¸¤å¥è¯\nwrite(fd, \u0026quot;Hello\u0026quot;, 5); write(fd, \u0026quot;World\u0026quot;, 5); æˆ‘ä»¬å¾—åˆ°çš„ä¼šæ˜¯ \u0026ldquo;HelloWorld\u0026rdquo; è€Œä¸æ˜¯ \u0026ldquo;World\u0026rdquo;ï¼Œè¿™è¯´æ˜æ–‡ä»¶æè¿°ç¬¦ä¸­è¿˜ä¿å­˜äº†ä¸€ä¸ªå¯¹è±¡å½“å‰çš„ offsetã€‚é‚£ä¹ˆä¸€ä¸ªè‡ªç„¶çš„é—®é¢˜æ˜¯ï¼šå¦‚æœæˆ‘ä»¬ fork å‡ºä¸€ä¸ªå­çº¿ç¨‹ï¼Œç„¶åçˆ¶å­çº¿ç¨‹åˆ†åˆ«æ‰“å° Hello å’Œ Worldï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ä¸¤ä¸ªå­—ç¬¦ä¸²è¿˜æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²å‘¢ï¼Ÿæˆ‘ä»¬å¯ä»¥å†™ä¸€ä¸ªç¨‹åºéªŒè¯ä¸€ä¸‹ï¼š\n// fork-fd.c #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;wait.h\u0026gt; int main () { int fd = open(\u0026quot;a.txt\u0026quot;, O_RDWR | O_CREAT | O_TRUNC); int rt = fork(); if (rt == 0) write(fd, \u0026quot;World\u0026quot;, 5); else write(fd, \u0026quot;Hello\u0026quot;, 5); wait(NULL); if (rt == 0) write(fd, \u0026quot;\\n\u0026quot;, 1); return 0; } è¯¥ç¨‹åºä¼šè¾“å‡º \u0026ldquo;HelloWorld\u0026rdquo; (æˆ–è€… \u0026ldquo;WorldHello\u0026rdquo;)ï¼Œè€Œä¸æ˜¯åªæœ‰äº”ä¸ªå­—ç¬¦ã€‚è¿™è¯´æ˜ fork ä¹‹åçš„ä¸¤ä¸ªè¿›ç¨‹åç»­ä»ç„¶æ˜¯å…±äº«æ–‡ä»¶åç§»çš„ã€‚è¿™æ ·çš„è®¾è®¡æ˜¾ç„¶ç¬¦åˆä¸€ä¸ªâ€œæ­£å¸¸â€œçš„ç¨‹åºå‘˜çš„éœ€æ±‚ã€‚æŸ¥é˜… dup() ç³»ç»Ÿè°ƒç”¨çš„æ‰‹å†Œï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ° dup() è·å¾—çš„æ–°æ–‡ä»¶æè¿°ç¬¦å’Œè¢«å¤åˆ¶çš„æ–‡ä»¶æè¿°ç¬¦ä¹Ÿæ˜¯å…±äº«æ–‡ä»¶åç§»çš„ã€‚\nå…±äº«åç§»å¯¹æ“ä½œç³»ç»Ÿå†…æ ¸æå‡ºäº†è¾ƒå¼ºçš„æŒ‘æˆ˜ã€‚å†…æ ¸å¿…é¡»éå¸¸å°å¿ƒï¼Œä¿è¯å¯¹æ–‡ä»¶æè¿°ç¬¦çš„æ“ä½œæ˜¯åŸå­çš„ (åœ¨ man 2 write ä¸­å¯ä»¥çœ‹åˆ° Linux å†…æ ¸å…³äº file offset çš„ bug åœ¨å†…æ ¸ 3.14 ç‰ˆæœ¬ä¸­æ‰å¾—åˆ°ä¿®å¤)ã€‚\nCopy-on-write Fork fork() çš„è¯­ä¹‰æ˜¯å®Œæ•´å¤åˆ¶äº†çŠ¶æ€æœºï¼Œä½†åœ¨å®ç°å±‚é¢ï¼Œç°ä»£å†…æ ¸å¹¶ä¸æ˜¯ç«‹å³å¤åˆ¶æ‰€æœ‰çš„æ•°æ®ã€‚fork() æœ‰å¤§é‡çš„åœºæ™¯éƒ½æ˜¯ä¸ºäº†å¯åŠ¨ä¸€ä¸ªæ–°ç¨‹åºï¼Œå³ fork() + execve() çš„ç»„åˆï¼Œè¿™ç§æƒ…å†µä¸‹æˆ‘ä»¬å¤åˆ¶å®Œçš„åœ°å€ç©ºé—´ä¼šç«‹åˆ»è¢«æ–°çš„ç¨‹åºé•œåƒè¦†ç›–ï¼Œå¤åˆ¶å·¥ä½œå°±å¾ˆæµªè´¹ã€‚\nç°ä»£å†…æ ¸æ™®éä½¿ç”¨ copy-on-write fork (å†™æ—¶æ‹·è´) æŠ€æœ¯ï¼Œå³ fork() æ—¶å­è¿›ç¨‹å®Œæ•´å¤åˆ¶çˆ¶è¿›ç¨‹çš„é¡µè¡¨ï¼Œä¸¤è€…æŒ‡å‘ç›¸åŒçš„é¡µé¢ï¼Œå¹¶æš‚æ—¶å°†é¡µé¢çš„å†™æƒé™å»æ‰ã€‚è¿™æ ·ä¹‹åå¦‚æœçˆ¶å­è¿›ç¨‹è¯»å–æ•°æ®ï¼Œä¸¤è€…å¯ä»¥å¹¶è¡Œä¸æ‚–ã€‚å¦‚æœæŸä¸ªè¿›ç¨‹éœ€è¦å†™æ•°æ®ï¼Œä¼šå› ä¸ºæ²¡æœ‰å†™æƒé™è§¦å‘ page faultï¼Œå†…æ ¸çš„ page fault handler å‘ç°è¿™æ˜¯ä¸€ä¸ª cow é¡µé¢ï¼Œä¾¿ä¼šç°åœºå¤åˆ¶ä¸€ä¸ªæ–°çš„é¡µé¢ï¼Œè®©çˆ¶å­è¿›ç¨‹æŒ‡å‘ä¸åŒçš„é¡µé¢ï¼Œå¹¶æŠŠå†™æƒé™æ¢å¤ã€‚\ncow fork åœ¨å®ç°å±‚é¢è¿˜æœ‰ä¸€äº›ç»†èŠ‚ï¼Œæ¯”å¦‚æ¯ä¸ªé¡µé¢éœ€è¦ç»´æŠ¤ä¸€ä¸ª reference countï¼Œä¹‹åå¯¹ä¸€ä¸ªé¡µé¢ malloc() å’Œ free() çš„è¯­ä¹‰è¦åšå‡ºä¸€äº›ä¿®æ”¹ï¼Œä»¥åŠæ ¹æ® ISA ç¡®å®šå¦‚ä½•åœ¨é¡µè¡¨é¡¹ä¸­æ·»åŠ  cow é¡µé¢æ ‡å¿—ä½ç­‰ç­‰ã€‚\næˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸€ä¸ªå°ç¨‹åºæ„Ÿå— Linux å†…æ ¸çš„ copy-on-write forkï¼š\n// cow-test.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;assert.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define NPROC 1000 #define MB 128 #define SIZE (MB * (1 \u0026lt;\u0026lt; 20)) #define xstr(s) str(s) #define str(s) #s int main() { char *data = malloc(SIZE); // 128MB shared memory memset(data, '_', SIZE); for (int i = 0; i \u0026lt; NPROC - 1; i++) { if (fork() == 0) break; } // NPROC processes go here asm volatile(\u0026quot;.fill 1048576 * \u0026quot; xstr(MB) \u0026quot;, 1, 0x90\u0026quot;); // 128MB shared code unsigned int idx = 0; int fd = open(\u0026quot;/dev/urandom\u0026quot;, O_RDONLY); assert(fd \u0026gt; 0); read(fd, \u0026amp;idx, sizeof(idx)); close(fd); idx %= 1048576 * MB; data[idx] = '.'; printf(\u0026quot;pid = %d, write data[%u]\\n\u0026quot;, getpid(), idx); while (1) { sleep(1); // not terminate } } åœ¨ cow-test.c ä¸­ï¼Œæˆ‘ä»¬ç”¨ fork() åˆ›å»ºäº† 1000 ä¸ªå­è¿›ç¨‹ï¼Œæ¯ä¸ªè¿›ç¨‹éƒ½æœ‰ä¸€ä¸ªå¤§å°ä¸º 128M çš„ä»£ç åŒº (éƒ½æ˜¯ nop æŒ‡ä»¤)ï¼Œæ¯ä¸ªè¿›ç¨‹è¿˜ä¼šéšæœºæŒ‘é€‰ä¸€ä¸ªä½ç½®è¿›è¡Œä¿®æ”¹ã€‚ç¼–è¯‘åï¼Œæˆ‘ä»¬çš„å¯æ‰§è¡Œæ–‡ä»¶å¤§å°å°±åœ¨ 128M å·¦å³ã€‚å¦‚æœå†…æ ¸ä½¿ç”¨æ™®é€šçš„ forkï¼Œè¿™ä¸ªç¨‹åºè¿è¡Œåˆ°ä¸€åŠå°±ä¼šå› å†…å­˜ä¸è¶³è€Œå´©æºƒã€‚ä½†äº‹å®ä¸Š Linux è¿è¡Œçš„å¾ˆå¥½ã€‚è¿™è¯æ˜äº† Linux ä¸­ä½¿ç”¨äº† cow fork ç­–ç•¥ã€‚\ncow fork ç­–ç•¥çš„ä¸€ä¸ªæ¨è®ºä¾¿æ˜¯ï¼šæƒ³è¦ç»Ÿè®¡ä¸€ä¸ªç¨‹åºè¿è¡Œæ—¶å ç”¨çš„å†…å­˜ç©ºé—´æ˜¯ä¸€ä¸ªä¼ªå‘½é¢˜ (æ¯”å¦‚æ“ä½œç³»ç»Ÿé‡Œçš„ libc ä»£ç åªæœ‰ä¸€ä»½ï¼Œä¸çŸ¥é“æœ‰å¤šå°‘ç¨‹åºçš„é¡µè¡¨æŒ‡å‘äº†å®ƒ)ã€‚\nState Machine, fork() and Magic fork() å¯ä»¥å®Œæ•´å¤åˆ¶çŠ¶æ€æœºï¼Œè¿™å¯ä»¥å¸®åŠ©æˆ‘ä»¬å®Œæˆå¾ˆå¤šç‚«é…·çš„äº‹æƒ…ï¼Œæ¯”å¦‚å¼€å¹³è¡Œå®‡å®™åš non-deterministic çš„äº‹æƒ…ã€‚\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;assert.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; #define DEST '+' #define EMPTY '.' struct move { int x, y, ch; } moves[] = { { 0, 1, '\u0026gt;' }, { 1, 0, 'v' }, { 0, -1, '\u0026lt;' }, { -1, 0, '^' }, }; char map[][512] = { \u0026quot;#######\u0026quot;, \u0026quot;#.#.#+#\u0026quot;, \u0026quot;#.....#\u0026quot;, \u0026quot;#.....#\u0026quot;, \u0026quot;#...#.#\u0026quot;, \u0026quot;#######\u0026quot;, \u0026quot;\u0026quot;, }; void display(); void dfs(int x, int y) { if (map[x][y] == DEST) { display(); } else { int nfork = 0; for (struct move *m = moves; m \u0026lt; moves + 4; m++) { int x1 = x + m-\u0026gt;x, y1 = y + m-\u0026gt;y; if (map[x1][y1] == DEST || map[x1][y1] == EMPTY) { int pid = fork(); assert(pid \u0026gt;= 0); if (pid == 0) { // map[][] copied map[x][y] = m-\u0026gt;ch; dfs(x1, y1); exit(0); // clobbered map[][] discarded } else { nfork++; waitpid(pid, NULL, 0); // wait here to serialize the search } } } while (nfork--) wait(NULL); } } int main() { dfs(1, 1); } void display() { for (int i = 0; ; i++) { for (const char *s = map[i]; *s; s++) { switch (*s) { case EMPTY: printf(\u0026quot; \u0026quot;); break; case DEST : printf(\u0026quot; â—‹ \u0026quot;); break; case '\u0026gt;' : printf(\u0026quot; â†’ \u0026quot;); break; case '\u0026lt;' : printf(\u0026quot; â† \u0026quot;); break; case '^' : printf(\u0026quot; â†‘ \u0026quot;); break; case 'v' : printf(\u0026quot; â†“ \u0026quot;); break; default : printf(\u0026quot;â–‡â–‡â–‡\u0026quot;); break; } } printf(\u0026quot;\\n\u0026quot;); if (strlen(map[i]) == 0) break; } fflush(stdout); sleep(1); // to see the effect of parallel search } dfs-fork.c æ˜¯ä¸€ä¸ªèµ°è¿·å®«ç¨‹åºï¼Œä¸åŒäºåŸºæœ¬çš„ dfs èµ°è¿·å®«ï¼Œå®ƒçš„ dfs() å‡½æ•°ä¸­æ¯å‘ç°ä¸€ä¸ªæ–°çš„è·¯ï¼Œä¾¿ä¼š fork ä¸€ä¸ªæ–°çš„è¿›ç¨‹å»åšå®ƒï¼Œç»“å°¾å¤„çš„ sleep(1) ç”¨äºæ¨¡æ‹Ÿä¸€ä¸ªè€—æ—¶å¾ˆé•¿çš„ä»»åŠ¡ã€‚ç°åœ¨çš„ dfs-fork.c è¿˜ä¸èƒ½åšåˆ°å¹¶è¡Œï¼Œå› ä¸º dfs å‡½æ•°ä¸­å½“å‰è¿›ç¨‹ä¼š wait ä¸€ä¸ªåˆ†æ”¯çš„å­è¿›ç¨‹ç»“æŸæ‰ä¼šæ¢ç´¢ä¸‹ä¸€ä¸ªåˆ†æ”¯ã€‚ä½†æˆ‘ä»¬å¦‚æœæŠŠ dfs å¾ªç¯å†…çš„ wait å»æ‰ï¼Œå°±å¯ä»¥è§‚æµ‹åˆ°ç¨‹åºâ€œç§’â€å®Œæˆä»»åŠ¡ã€‚\nfork() ç›¸è¾ƒäºæœç´¢-å›æº¯è¿˜æœ‰ä¸€ä¸ªå¥½å¤„ï¼šå½“æˆ‘ä»¬æ¢ç´¢ä¸€ä¸ªåˆ†æ”¯å¤±è´¥æ—¶ï¼Œæˆ‘ä»¬ä¸ç”¨ä¸€æ­¥ä¸€æ­¥æ’¤å›å»ï¼Œè€Œæ˜¯å¯ä»¥ç›´æ¥é”€æ¯å½“å‰è¿›ç¨‹ï¼Œç„¶åä»ä¹‹å‰ä¿å­˜çš„å‰¯æœ¬å‡ºå‘æœç´¢æ–°çš„åˆ†æ”¯ã€‚\nParallel Universe: Skipping Initialization ä»¥ NEMU ä¸¾ä¾‹ï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦è¿è¡Œå¾ˆå¤šä¸ª benchmarkï¼Œä½† NEMU çš„åˆå§‹åŒ–è¿‡ç¨‹å¾ˆé•¿ï¼Œæˆ‘ä»¬èƒ½ä¸èƒ½åªè¿›è¡Œä¸€æ¬¡åˆå§‹åŒ–ï¼Œç„¶åè®©å¤šä¸ª benchmark å…±äº«è¿™ä¸€æ¬¡åˆå§‹åŒ–å‘¢ï¼Ÿ\nint main() { nemu_init(); while (1) { file = get_start_request(); if ((pid = fork()) == 0) { load_file(); ... } } } ä¸Šé¢ä¸€æ®µ C ä»£ç å¤§è‡´å®ç°äº†æˆ‘ä»¬çš„æƒ³æ³•ã€‚æˆ‘ä»¬åœ¨ init() ç»“æŸåï¼Œæ¯æ¬¡ fork ä¸€ä¸ªå­è¿›ç¨‹åšä¸€ä¸ª benchmarkï¼Œå°±å¯ä»¥è®©å¤šä¸ª benchmark å…±äº«åˆå§‹åŒ–åˆšç»“æŸæ—¶çš„çŠ¶æ€æœºäº†ã€‚\nç±»ä¼¼çš„æ€æƒ³åœ¨å®é™…ä¸­ä¹Ÿæœ‰å¹¿æ³›åº”ç”¨ï¼š\nZygote Processï¼šzygote æ˜¯å—ç²¾åµçš„æ„æ€ï¼Œè¿™æ˜¯ Android é‡Œçš„ä¸€ä¸ªæœºåˆ¶ã€‚Java ç¨‹åºå¯åŠ¨éœ€è¦åŠ è½½å¾ˆå¤šçš„ class nodeï¼Œè¿™ä¸ªè¿‡ç¨‹å¾ˆæ…¢ï¼Œä½†äº‹å®ä¸Šç°åœ¨çš„ Android app åŸºæœ¬éƒ½æ˜¯ç§’èµ·çš„ã€‚è¿™æ˜¯å› ä¸º Android çš„ä¸€ä¸ª zygote process å®Œæˆæ‰€æœ‰çš„åˆå§‹åŒ–å·¥ä½œï¼Œç„¶åæ¯å¼€ä¸€ä¸ª app ç›´æ¥åœ¨ zygote process çš„åŸºç¡€ä¸Š forkï¼Œè®¾ç½®ä¸€äº›æƒé™ã€ç”¨æˆ· id ä¹‹åå¾ˆå¿«å°±å¯ä»¥å¼€å§‹æ‰§è¡Œ app ä»£ç ã€‚ Chrome site isolationï¼šChrome çš„æ¯ä¸ªæ ‡ç­¾é¡µéƒ½æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„è¿›ç¨‹ï¼Œè¿™å…¶ä¸­ä¹Ÿæœ‰å…±äº«åˆå§‹åŒ–èµ„æºçš„æŠ€æœ¯ï¼Œè¿™è®© chrome çš„é€Ÿåº¦å˜å¾—å¾ˆå¿«ã€‚ â€¦â€¦ Parallel Universe: Backup and Fault-tolerence æœ‰äº†å¹³è¡Œå®‡å®™ï¼Œæˆ‘ä»¬å°±æœ‰äº†çŠ¯é”™çš„åº•æ°”ï¼šæˆ‘ä»¬å¯ä»¥æ—¶ä¸æ—¶åœ°å¯¹çŠ¶æ€æœº forkï¼Œå¦‚æœæŸä¸ªæ—¶åˆ»ç¨‹åº crash äº†ï¼Œæˆ‘ä»¬å°±æ¢å¤æœ€è¿‘ä¸€æ¬¡ä¿å­˜çš„çŠ¶æ€æœºå‰¯æœ¬ï¼›å¦‚æœåˆ°äº†ä¸‹ä¸€ä¸ªå­˜æ¡£ç‚¹ä»ç„¶æ²¡æœ‰ crashï¼Œæˆ‘ä»¬åœ¨ fork å‡ºæ–°çš„å­˜æ¡£çš„åŒæ—¶å¯ä»¥æŠŠä¸Šä¸€ä»½å­˜æ¡£é”€æ¯ã€‚\nå¹³è¡Œå®‡å®™è¿˜å¯ä»¥ä¸ºæˆ‘ä»¬æä¾›å®¹é”™æœºåˆ¶ï¼šæ¯”å¦‚æœ‰ä¸€äº›å¹¶å‘ bug è§¦å‘çš„æ¦‚ç‡å¾ˆå°ã€‚é‚£ä¹ˆå¦‚æœæŸä¸€æ¬¡ä¸å¹¸åœ°è§¦å‘äº†å¹¶å‘ bugï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨å­˜æ¡£ç‚¹å›åˆ°è¿‡å»ï¼Œç„¶åå†è·‘ä¸€éï¼Œè¯´ä¸å®šå°±ç»•è¿‡äº† bug å¯ä»¥ç»§ç»­æ‰§è¡Œäº†ã€‚\nA fork() in the Road å°†çŠ¶æ€æœºå®Œæ•´åœ°å¤åˆ¶ä¸€éåœ¨æ—©æœŸæ˜¯ä¸€ä»¶è½»é‡çº§çš„äº‹æƒ…ï¼Œä½†ç°åœ¨éšç€ç³»ç»Ÿä¸­çš„æœºåˆ¶è¶Šæ¥è¶Šä¸°å¯Œï¼Œfork() è¦åšçš„äº‹æƒ…è¶Šæ¥è¶Šç¹é‡ï¼šä¿¡å·ã€çº¿ç¨‹ã€ptrace ç­‰ç­‰ã€‚fork() çš„è¯­ä¹‰ä¹Ÿå˜å¾—è¶Šæ¥è¶Šå¤æ‚ã€‚æ¯”å¦‚ï¼š\næœ‰äº†ä¿¡å·æœºåˆ¶åï¼Œå½“æ“ä½œç³»ç»Ÿç»™è¿›ç¨‹å‘é€ä¿¡å·æ—¶ï¼Œå­è¿›ç¨‹æ˜¯å¦ä¹Ÿæ¥æ”¶åˆ°è¿™ä¸ªä¿¡å·ï¼Ÿç­”æ¡ˆæ˜¯å­è¿›ç¨‹ä¹Ÿä¼šæ¥æ”¶åˆ°ä¿¡å·ï¼Œè¿™å°±è®¾è®¡äº† process group ç­‰ä¸€ç³»åˆ—æ¦‚å¿µã€‚ å½“çº¿ç¨‹åŠ å…¥åï¼Œfork æ˜¯æŠŠå½“å‰è¿›ç¨‹çš„æ‰€æœ‰çº¿ç¨‹å¤åˆ¶ï¼Œè¿˜æ˜¯åªå¤åˆ¶æ‰§è¡Œ fork çš„çº¿ç¨‹ï¼Ÿç­”æ¡ˆæ˜¯åè€…ã€‚ â€¦â€¦ POSIX ç»™å‡ºçš„ä¸€ä¸ªæ›´å®‰å…¨çš„åˆ›å»ºå­è¿›ç¨‹çš„ API æ˜¯ posix_spawn()ï¼š\nint posix_spawn(pid_t *pid, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]); å®ƒæœ‰ç›¸å½“å¤æ‚çš„å‚æ•°ã€‚è¿™æ˜¯ä¸€ä¸ªéå¸¸æ˜æ˜¾çš„ fork åæ—¶ä»£è®¾è®¡çš„ APIï¼Œå®ƒæ‰“åŒ…æ‰§è¡Œ fork å’Œ execveï¼Œå°†æ‰§è¡Œè¿‡ç¨‹åˆ†ä¸º fork, pre-exec å’Œ exec ä¸‰ä¸ªé˜¶æ®µï¼Œå¹¶åœ¨ pre-exec é˜¶æ®µå¯¹ signal handler, file action ç­‰ä¸œè¥¿åšä¸€ç³»åˆ—è®¾ç½®ã€‚\nA fork() in the Road ä¸€æ–‡ä¸­æå‡ºäº† fork() çš„ä¸ƒå®—ç½ªï¼š\nFork is no longer simple - è¦è€ƒè™‘çš„æœºåˆ¶è¶Šæ¥è¶Šå¤šï¼› Fork doesnâ€™t compose - æ¯”å¦‚ fork-printf.cï¼Œå°†æ ‡å‡†åº“ä¸­ buffer çš„å†…å®¹å¤åˆ¶å¾ˆå¯èƒ½ä¸æ˜¯ç¨‹åºå‘˜çš„åˆè¡·ï¼› Fork isnâ€™t thread-safe Fork is insecure - fork() å‡ºçš„å­è¿›ç¨‹å’Œçˆ¶è¿›ç¨‹åœ°å€ç©ºé—´å®Œå…¨ç›¸åŒï¼Œæ‰“ç ´äº† ASLRï¼› Fork is slow Fork doesnâ€™t scale Fork encourages memory overcommit ","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"7c67e5e45d68e6bc544a903cc48be8be","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec15/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec15/","section":"notes","summary":"fork() Semantics fork() çš„è¯­ä¹‰æ˜¯å°†å½“å‰è¿›ç¨‹çš„çŠ¶æ€æœºå®Œæ•´åœ°å¤åˆ¶ä¸€ä»½ï¼Œè¿™ä¸¤ä¸ªè¿›ç¨‹é™¤äº† fork() çš„è¿”å›å€¼ä»¥å¤–å…¨éƒ¨ç›¸åŒã€‚\nFile Descriptors æˆ‘ä»¬è¿™é‡Œå…³æ³¨æ–‡ä»¶æè¿°ç¬¦ï¼šæ ¹æ® fork() çš„è¯­ä¹‰ï¼Œå­è¿›ç¨‹å’Œçˆ¶è¿›ç¨‹ä¼šæ‹¥æœ‰ç›¸åŒçš„æ–‡ä»¶æè¿°ç¬¦ (æ–‡ä»¶æè¿°ç¬¦å¯ä»¥ç†è§£ä¸ºæŒ‡å‘æ“ä½œç³»ç»Ÿå¯¹è±¡çš„æŒ‡é’ˆ)ã€‚execve() ä¼šé‡ç½®çŠ¶æ€æœºï¼Œä½†ä¼šç»§æ‰¿åŸè¿›ç¨‹æŒæœ‰çš„æ‰€æœ‰æ“ä½œç³»ç»Ÿå¯¹è±¡ã€‚è¿™ä¸ªè®¾è®¡ä½¿æˆ‘ä»¬åœ¨ UNIX shell ä¸­å¯ä»¥åˆ©ç”¨ç®¡é“æŠ€æœ¯ï¼Œåœ¨ execve() ä¹‹å‰ä¿®æ”¹ stdin, stdout ä»¥å®Œæˆè¿›ç¨‹ä¹‹é—´æ•°æ®çš„ä¼ è¾“ã€‚\nexecve() ä¼šæ— æ¡ä»¶ç»§æ‰¿æ‰€æœ‰çš„å¯¹è±¡å—ï¼Ÿ\nåœ¨ open() çš„æ‰‹å†Œä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°æ‰“å¼€æ–‡ä»¶æ—¶æœ‰ä¸€ä¸ªæ ‡å¿—æ˜¯ O_CLOEXECï¼Œè¿™æ ·æ‰“å¼€çš„æ–‡ä»¶åœ¨ execve() çš„æ—¶å€™ä¸ä¼šè¢«ç»§æ‰¿ã€‚\næ–‡ä»¶æè¿°ç¬¦å…¶å®ä¸ä»…ä»…æ˜¯æŒ‡å‘å¯¹è±¡çš„æŒ‡é’ˆã€‚æˆ‘ä»¬åœ¨ä¸€ä¸ªç¨‹åºä¸­å†™ä¸¤å¥è¯","tags":null,"title":"Lecture 15: More about fork()","type":"docs"},{"authors":null,"categories":null,"content":" æœ¬èŠ‚è¯¾é»˜è®¤åªæœ‰é™æ€é“¾æ¥ã€‚\nOverview å¯æ‰§è¡Œæ–‡ä»¶çš„æœ¬è´¨æè¿°çŠ¶æ€æœºåˆå§‹çŠ¶æ€ (æ•°æ®) å’Œè¿ç§» (æŒ‡ä»¤) çš„æ•°æ®ç»“æ„ï¼šå¯æ‰§è¡Œæ–‡ä»¶åœ¨ execve() çš„æ—¶å€™ä½¿ç”¨ï¼Œæ“ä½œç³»ç»Ÿæ ¹æ®å¯æ‰§è¡Œæ–‡ä»¶çš„æè¿°è®¾ç½®çŠ¶æ€æœºå¹¶å¼€å§‹æ‰§è¡Œã€‚\næ›´å…·ä½“åœ°è¯´ï¼Œå¯æ‰§è¡Œæ–‡ä»¶æ˜¯ä¸€ä¸ªæè¿°äº†çŠ¶æ€æœºåˆå§‹çŠ¶æ€çš„æ•°æ®ç»“æ„ã€‚çŠ¶æ€æœºçš„åˆå§‹çŠ¶æ€ä¸€èˆ¬åŒ…æ‹¬ä»¥ä¸‹å‡ ä¸ªæ–¹é¢ï¼š\nå¯„å­˜å™¨ï¼šå¤§éƒ¨åˆ†å¯„å­˜å™¨çš„å€¼ç”± ABI è§„å®š (æ¯”å¦‚å“ªäº›å¯„å­˜å™¨åº”è¯¥æ¸…é›¶)ï¼Œç”±æ“ä½œç³»ç»Ÿè´Ÿè´£è®¾ç½®ã€‚ä½†ä¹Ÿæœ‰ä¸€äº›é‡è¦çš„å¯„å­˜å™¨çš„å€¼æ˜¯å¯æ‰§è¡Œæ–‡ä»¶æŒ‡å®šçš„ï¼Œæ¯”å¦‚ PC çš„å€¼ã€‚ åœ°å€ç©ºé—´ (å†…å­˜)ï¼šç”±äºŒè¿›åˆ¶æ–‡ä»¶å’Œ ABI å…±åŒå†³å®šï¼Œæ¯”å¦‚æŸä¸€æ®µæ•°æ®åº”è¯¥æ”¾åˆ°å†…å­˜ä¸­çš„å“ªé‡Œï¼Œä»¥åŠ argv, envp çš„å†…å®¹ã€‚ å…¶ä»–æœ‰ç”¨çš„ä¿¡æ¯ (æ¯”å¦‚è°ƒè¯•ä¿¡æ¯) ä»€ä¹ˆæ ·çš„æ–‡ä»¶å¯ä»¥è¢«æ‰§è¡Œï¼Ÿ\nä¸€ä¸ªæ–‡ä»¶éœ€è¦æ»¡è¶³è‹¥å¹²æ¡ä»¶æ‰èƒ½è¢«æ‰§è¡Œã€‚å‡è®¾æˆ‘ä»¬æœ‰æºä»£ç  a.cï¼Œç›´æ¥æ‰§è¡Œå®ƒ (./a.c) ä¼šè·å¾— Permission denied (bash)ï¼Œå³ä½¿æˆ‘ä»¬ç”¨ chmod +x a.c ç»™å…¶åŠ ä¸Šäº†æ‰§è¡Œæƒé™ï¼Œä»ç„¶ä¸èƒ½æ­£å¸¸æ‰§è¡Œã€‚\nå†³å®šä¸€ä¸ªæ–‡ä»¶æ˜¯å¦èƒ½æ‰§è¡Œçš„æ˜¯ execve() ç³»ç»Ÿè°ƒç”¨ã€‚æˆ‘ä»¬å¯ä»¥ç”¨ strace è¿½è¸ªåŠ è½½ a.c çš„è¿‡ç¨‹ã€‚å¦‚æœ a.c æ²¡æœ‰è¢«èµ‹äºˆå¯æ‰§è¡Œæƒé™ï¼Œæˆ‘ä»¬å¾—åˆ°çš„æ˜¯ EACCES (Permission denied)\nexecve(\u0026quot;./a.c\u0026quot;, [\u0026quot;./a.c\u0026quot;], 0x7fff24451760 /* 66 vars */) = -1 EACCES (Permission denied) strace: exec: Permission denied +++ exited with 1 +++ å¦‚æœæˆ‘ä»¬ç»™ a.c èµ‹äºˆæ‰§è¡Œæƒé™ï¼Œå¾—åˆ°çš„åˆ™æ˜¯ ENOEXEC (ç›®æ ‡æ–‡ä»¶çš„æ ¼å¼ä¸æ˜¯å¯è¯†åˆ«çš„å¯æ‰§è¡Œæ–‡ä»¶æ ¼å¼)ã€‚\nexecve(\u0026quot;./a.c\u0026quot;, [\u0026quot;./a.c\u0026quot;], 0x7ffe24eca680 /* 66 vars */) = -1 ENOEXEC (Exec format error) strace: exec: Exec format error +++ exited with 1 +++ è¿™æ—¶æˆ‘ä»¬å†é˜…è¯» execve() çš„æ‰‹å†Œçš„ ERROR éƒ¨åˆ†ï¼Œå°±ä¼šæœ‰æ›´å¥½çš„ç†è§£ã€‚æ‰‹å†Œå‘Šè¯‰æˆ‘ä»¬ EACCES ç±»å‹çš„é”™è¯¯ä¸åªæ˜¯å› ä¸ºç¼ºå°‘æ‰§è¡Œæƒé™ï¼Œä¹Ÿå¯èƒ½æ˜¯å› ä¸ºå¯¹è±¡ä¸æ˜¯æ­£å¸¸çš„æ–‡ä»¶ç±»å‹ï¼Œæ¯”å¦‚ strace /dev/null ä¹Ÿä¼šå¾—åˆ° EACCESã€‚é™¤äº† EACCES å’Œ ENOEXEC è¿˜æœ‰æ›´å¤šçš„é”™è¯¯ç±»å‹ï¼Œæ¯”å¦‚ E2BIG è¡¨ç¤ºå‚æ•°/ç¯å¢ƒå˜é‡åˆ—è¡¨å¤ªé•¿ï¼ŒENOMEM è¡¨ç¤ºå†…æ ¸çš„å†…å­˜ç©ºé—´ä¸è¶³ç­‰ã€‚\nCommon Executable File Formats Executable file å°±æ˜¯æ“ä½œç³»ç»Ÿä¸­çš„ä¸€ä¸ªæ™®é€šçš„å¯¹è±¡ã€‚\nWindows ä¸­ä½¿ç”¨çš„æ˜¯ PE æ ¼å¼ (Portable Executable)ã€‚\nUNIX/Linux é»˜è®¤çš„å¯æ‰§è¡Œæ–‡ä»¶æ ¼å¼æ˜¯ ELF (Executable Linkable Format)ï¼Œä½† UNIX/Linux è¿˜æ”¯æŒ She-bang æ ¼å¼çš„æ–‡ä»¶ (å³æ–‡ä»¶å¼€å¤´æœ‰ #! çš„æ–‡ä»¶)ã€‚æ¯”å¦‚æˆ‘ä»¬å¯ä»¥åœ¨ä¸€ä¸ª .c æ–‡ä»¶ä¸­ä¹¦å†™\n#!/bin/python3 print('Hello') ç»™å®ƒåŠ ä¸Šæ‰§è¡Œæƒé™åå®ƒä¾¿å¯ä»¥ç”¨ python è§£é‡Šå™¨è¿è¡Œä¸‹é¢çš„ä»£ç å¹¶è¾“å‡º Helloã€‚æ›´ç¥å¥‡çš„æ˜¯ She-bang åé¢è¿˜å¯ä»¥è·Ÿæˆ‘ä»¬è‡ªå·±å†™çš„ç¨‹åºï¼Œä¾‹å¦‚æˆ‘ä»¬ä¹¦å†™ä¸‹é¢çš„ä¸¤ä¸ªç¨‹åºï¼š\n// args.c int main (int argc, char *argv[]) { for (int i = 0; i \u0026lt; argc; i++) { printf(\u0026quot;argv[%d] = %s\\n\u0026quot;, i, argv[i]); } return 0; } #!./args ç¬¬äºŒä¸ªç¨‹åºéšä¾¿æ˜¯ä»€ä¹ˆç±»å‹ (ä¸å¦¨ç»™å…¶å‘½å she-bang)ã€‚å°†ç¬¬ä¸€ä¸ª C ç¨‹åºç¼–è¯‘å‡ºå¯æ‰§è¡Œæ–‡ä»¶ args åï¼Œç»™ç¬¬äºŒä¸ªæ–‡ä»¶åŠ ä¸Šå¯æ‰§è¡Œæƒé™åï¼Œè¾“å…¥ ./she-bang ï¼Œä¾¿å¯å¾—åˆ°\nargv[0] = ./args argv[1] = ./she-bang å…¶å® she-bang çš„åŸç†å¯ä»¥ç†è§£ä¸ºä¸€ä¸ªå·æ¢å‚æ•°çš„ execve()ï¼šæˆ‘ä»¬åœ¨è¾“å…¥å‘½ä»¤ ./file çš„æ—¶å€™ï¼Œæœ¬æ¥ä¼ ç»™ execve() çš„å‚æ•°æ˜¯ \u0026ldquo;./file\u0026rdquo;ï¼Œä½†å¦‚æœ file æ–‡ä»¶çš„å¼€å¤´æ˜¯ she-bangï¼š\n#!intepreter [optional-args] é‚£ä¹ˆç›¸å½“äºç»™ execve() ä¼ å…¥äº†å‚æ•° \u0026ldquo;intepreter\u0026rdquo;, \u0026ldquo;[optional-args]\u0026rdquo;, \u0026ldquo;file\u0026rdquo;ã€‚è¿™éƒ¨åˆ†åœ¨ execve() çš„æ‰‹å†Œä¸­ä¹Ÿæœ‰å™è¿°ã€‚\nå…³äº optional args çš„æœ‰è¶£ç°è±¡\næˆ‘ä»¬å³ä½¿åœ¨ she-bang åè·Ÿå¤šä¸ªç©ºæ ¼åˆ†å¼€çš„å•è¯ï¼Œä¹Ÿåªèƒ½ä¼ ä¸€ä¸ªå‚æ•°ã€‚è¿™æ˜¯ä¸€ä¸ª UNIX çš„å†å²é—ç•™é—®é¢˜ã€‚æ¯”å¦‚æˆ‘ä»¬å°†åˆšæ‰çš„ she-bang ä¿®æ”¹ä¸º\n#!./args Hello OS World åˆ™è¾“å‡ºç»“æœä¸º\nargv[0] = ./args argv[1] = Hello OS World argv[2] = ./she-bang ä¸ºä»€ä¹ˆæˆ‘ä½¿ç”¨ strace ./she-bang è§‚æµ‹ï¼Œä½†æ²¡æœ‰çœ‹åˆ°æ˜¾å¼çš„ â€œå·æ¢æ¢æŸ±â€ ç°è±¡ï¼Ÿ\nåœ¨ linux kernel çš„æºç ä¸­ï¼Œexecve() ä¼šè°ƒç”¨ do_open_execat(\u0026quot;./she-bang\u0026quot;)ï¼Œé‡Œé¢æœ‰ä¸€ä¸ªå‡½æ•°æ˜¯ loadelfï¼Œæœ‰ä¸€ä¸ªå‡½æ•°æ˜¯ loadscriptï¼Œåœ¨ load_script() ä¸­ï¼Œå†…æ ¸æœ‰æƒé™æ‰“å¼€ä¸€ä¸ªæ–‡ä»¶å¹¶æ£€æŸ¥å™¨å¼€å¤´æ˜¯ä¸æ˜¯ #!ï¼Œå¦‚æœæ˜¯å°±ä¼šæŠŠåé¢çš„è§£é‡Šå™¨è·¯å¾„è¯»å‡ºæ¥ï¼Œç„¶åé€’å½’åœ°è°ƒç”¨ do_open_execat(\u0026quot;./args\u0026quot;)ã€‚å› æ­¤è¿™ä¸ªâ€œå·æ¢æ¢æŸ±â€çš„è¿‡ç¨‹æ˜¯åœ¨ execve() å†…éƒ¨å®Œæˆçš„ã€‚\nParsing Executable File GNU binutils æä¾›äº†ä¸€ç³»åˆ—ä¸äºŒè¿›åˆ¶æ–‡ä»¶æ‰“äº¤é“çš„å·¥å…·ã€‚è¿™äº›å·¥å…·çš„æœ¬è´¨éƒ½æ˜¯æŸ¥çœ‹/ä¿®æ”¹æ•°æ®ç»“æ„ä¸­çš„å†…å®¹ã€‚\nDebugging Information // segfault.c #include \u0026lt;stddef.h\u0026gt; void bar() { *(int *)NULL = 1; } void foo() { bar(); } int main() { foo(); } ä¸Šè¿°ç¨‹åºå¯¹ä¸€ä¸ªç©ºæŒ‡é’ˆè§£å¼•ç”¨ï¼Œæ˜¾ç„¶ä¼šå‘ç”Ÿæ®µé”™è¯¯ã€‚å¦‚æœæˆ‘ä»¬ç”¨ GDB è°ƒè¯•ï¼Œæˆ‘ä»¬å¯ä»¥æŠ“åˆ°å‡ºé”™çš„è¡Œã€‚ä½¿ç”¨ backtrace / where è¿˜å¯ä»¥æ‰“å°å‡ºå®Œæ•´çš„å‡½æ•°è°ƒç”¨åºåˆ—ï¼Œä»¥åŠæ¯ä¸ªå‡½æ•°å¯¹åº”åˆ°æºä»£ç çš„è¡Œæ•°ï¼š\n(gdb) where #0 bar () at segfault.c:4 #1 0x0000555555555151 in foo () at segfault.c:8 #2 0x0000555555555166 in main () at segfault.c:12 æˆ‘ä»¬è¿˜å¯ä»¥æ„Ÿå— addr2line å·¥å…·çš„å¨åŠ›ï¼šåœ¨å¯æ‰§è¡Œæ–‡ä»¶ segfault ä¸­æ‰¾åˆ° foo() å‡½æ•°å¯¹åº”çš„åœ°å€ ADDRï¼Œç„¶åè¾“å…¥\naddr2line ADDR segfault ä¾¿å¯ä»¥å¾—åˆ°è¯¥åœ°å€å¯¹åº”åˆ°æºä»£ç  segfault.c ä¸­çš„è¡Œå·ï¼š\n~/os-demo/Lecture16/segfault.c:7 æˆ‘ä»¬é’ˆå¯¹äºŒè¿›åˆ¶æ–‡ä»¶æ“ä½œï¼Œå´å¯ä»¥å¾—åˆ°æºä»£ç ç›¸å…³çš„ä¿¡æ¯ï¼Œè¿™æ˜¯å› ä¸ºæˆ‘ä»¬çš„äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ä¿ç•™äº†è°ƒè¯•ä¿¡æ¯ (å½“ç„¶ï¼Œå¦‚æœæˆ‘ä»¬ç¼–è¯‘çš„æ—¶å€™ä¸å¸¦ -g é€‰é¡¹ï¼Œä½¿ç”¨ GDB backtrace çš„æ—¶å€™å°±æ— æ³•å®šä½åˆ°æºæ–‡ä»¶è¡Œå·)ã€‚å¦‚æœæˆ‘ä»¬ç”¨ readelf -S file æŸ¥çœ‹å¯æ‰§è¡Œæ–‡ä»¶ file çš„ section header tableï¼Œå¯ä»¥çœ‹åˆ°æœ‰ debug info ç­‰èŠ‚ï¼Œè¿™å°±æ˜¯è°ƒè¯•ä¿¡æ¯ã€‚\nç°åœ¨è°ƒè¯•ä¿¡æ¯é‡‡ç”¨çš„æ ‡å‡†æ˜¯ DWARF debugging standardã€‚è°ƒè¯•ä¿¡æ¯å¯ä»¥ç†è§£ä¸ºå°† assembly (æœºå™¨çŠ¶æ€) æ˜ å°„åˆ° \u0026ldquo;Cè¯­è¨€ä¸–ç•Œ\u0026rdquo; çŠ¶æ€çš„å‡½æ•°ã€‚æˆ‘ä»¬ C è¯­è¨€çš„å½¢å¼è¯­ä¹‰æ˜¯çŠ¶æ€æœºä¹‹é—´çš„è½¬ç§» (high level çš„çŠ¶æ€æœºï¼Œæ¯”å¦‚æ ˆå¸§ï¼Œè¡Œå·ç­‰)ï¼Œç¼–è¯‘å™¨çš„å·¥ä½œæ˜¯å°†å…¶ç¿»è¯‘æˆæ±‡ç¼–æŒ‡ä»¤ï¼Œæ±‡ç¼–æŒ‡ä»¤æè¿°äº†æ›´åº•å±‚çš„çŠ¶æ€æœºçš„è½¬ç§» (memory, register etc.)ï¼Œè°ƒè¯•ä¿¡æ¯çš„ä½œç”¨å°±æ˜¯å°†ä¸€ä¸ªåº•å±‚çš„çŠ¶æ€æœºçŠ¶æ€æ˜ å°„åˆ° C è¯­è¨€ä¸–ç•Œçš„ä¸€ä¸ªçŠ¶æ€æœºçŠ¶æ€ã€‚\nç¼–è¯‘å™¨çš„â€œæ‘†çƒ‚â€\nå°†æœºå™¨çŠ¶æ€æ˜ å°„åˆ° C è¯­è¨€çŠ¶æ€æ˜¯ä¸€ä»¶å¾ˆå›°éš¾çš„äº‹æƒ…ã€‚æ¯”å¦‚æˆ‘ä»¬å¯èƒ½æœ‰å‡½æ•°å…§è”ï¼Œè¿™è®© backtrace å˜å¾—å›°éš¾ï¼›å†æ¯”å¦‚æ¯”è¾ƒæ¿€è¿›çš„ç¼–è¯‘ä¼˜åŒ–ä¼šåœ¨è¯­ä¹‰ä¸å˜çš„å‰æä¸‹æ”¹å†™æ±‡ç¼–ç¨‹åºè€Œä¸æ˜¯é€å¥ç¿»è¯‘ï¼Œè¿™ä½¿å¾—æœ‰äº›æ±‡ç¼–çŠ¶æ€å…¶å®æ ¹æœ¬æ‰¾ä¸åˆ°å¯¹åº”çš„ C è¯­è¨€çŠ¶æ€ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åœ¨è°ƒè¯•æ—¶ç»å¸¸ç¢°åˆ°å„ç§å„æ ·ä¸æ­£ç¡®çš„è°ƒè¯•ä¿¡æ¯ï¼Œä»¥åŠä¸€äº›æ˜æ˜å¯ä»¥æ‰“å°ï¼Œå´è¢«æ‘†çƒ‚çš„ \u0026lt;optimized out\u0026gt;ã€‚\n// popcount.c #include \u0026lt;stdio.h\u0026gt; __attribute__((noinline)) int popcount(int x) { int s = 0; int b0 = (x \u0026gt;\u0026gt; 0) \u0026amp; 1; s += b0; int b1 = (x \u0026gt;\u0026gt; 1) \u0026amp; 1; s += b1; int b2 = (x \u0026gt;\u0026gt; 2) \u0026amp; 1; s += b2; int b3 = (x \u0026gt;\u0026gt; 3) \u0026amp; 1; s += b3; return s; } int main() { printf(\u0026quot;%d\\n\u0026quot;, popcount(0b1101)); } popcount.c å¯ä»¥æ­£ç¡®åœ°æ‰“å°å‡ºä¸€ä¸ªæ•°äºŒè¿›åˆ¶è¡¨ç¤ºä¸­æœ‰å¤šå°‘ä¸ª 1ã€‚ä½†å¦‚æœæˆ‘ä»¬ç”¨ GDB è°ƒè¯•ï¼Œåœ¨ä¸å¼€ O2 çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬åˆšè¿›å…¥ popcount() æ—¶ p x ä¼šå‘ç° GDB è¾“å‡ºäº†ä¸æ­£ç¡®çš„å€¼ 0ã€‚åœ¨å¼€ O2 çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬è¿è¡Œåˆ° popcount() çš„ ret æ—¶ï¼Œä¼šå‘ç°å˜é‡ s è¢« optimized out äº†ï¼Œä½† %eax çš„å€¼ 3 æ˜¯æ­£ç¡®çš„â€¦â€¦è¿™éƒ½æ˜¯é”™è¯¯æˆ–ä¸å¾—å½“çš„è°ƒè¯•ä¿¡æ¯ã€‚\nExample: Stack Unwinding è¿™äº›åŠŸèƒ½å…¶å®å¹¶ä¸ç¥ç§˜ï¼Œåˆ©ç”¨ x86 æ¶æ„çš„æ ˆå¸§ç»“æ„ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å®ç°ä¸€ä¸ªç®€æ˜“çš„ stack unwindingï¼š\n// unwind.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; const char *binary; struct frame { struct frame *next; // push %rbp void *addr; // call f (pushed retaddr) }; void backtrace() { struct frame *f; char cmd[1024]; extern char end; asm volatile (\u0026quot;movq %%rbp, %0\u0026quot; : \u0026quot;=g\u0026quot;(f)); for (; f-\u0026gt;addr \u0026lt; (void *)\u0026amp;end; f = f-\u0026gt;next) { printf(\u0026quot;%016lx \u0026quot;, (long)f-\u0026gt;addr); fflush(stdout); sprintf(cmd, \u0026quot;addr2line -e %s %p\u0026quot;, binary, f-\u0026gt;addr); system(cmd); } } void bar() { backtrace(); } void foo() { bar(); } int main(int argc, char *argv[]) { binary = argv[0]; foo(); } è¿è¡Œä»£ç  (ä¸å¼€ä¼˜åŒ–)ï¼Œæˆ‘ä»¬ç¡®å®å¯ä»¥å¾—åˆ°ä¸€ä¸ªå®Œæ•´çš„å‡½æ•°è°ƒç”¨é“¾ï¼š\n000000000040199e /home/starling/os-demo/Lecture16/unwind.c:26 00000000004019b3 /home/starling/os-demo/Lecture16/unwind.c:30 00000000004019e1 /home/starling/os-demo/Lecture16/unwind.c:34 00000000004039b2 ??:? backtrace() å‡½æ•°çš„å®ç°åŸç†å¾ˆç®€å•ï¼šæˆ‘ä»¬é»˜è®¤è¯¥ç¨‹åºè¿è¡Œåœ¨ x86 æ¶æ„ä¸Šï¼Œx86 æ¶æ„åœ¨è°ƒç”¨ä¸€ä¸ªå‡½æ•°æ—¶æ€»æ˜¯ä½¿ç”¨ call æŒ‡ä»¤ï¼Œcall æŒ‡ä»¤ä¼šå‘æ ˆä¸­å†™å…¥è¿”å›åœ°å€ï¼Œç„¶å PC è·³è½¬åˆ°ç›®æ ‡å‡½æ•°çš„ç¬¬ä¸€æ¡æŒ‡ä»¤ã€‚ç›®æ ‡å‡½æ•°çš„å‰ä¸¤æ¡æŒ‡ä»¤ä¸€å®šæ˜¯\npush %rbp mov %rsp, %rbp æ‰§è¡Œå®Œäº†ä»¥åï¼Œæ ˆä¸Šçš„å†…å®¹ä¸ºè¿”å›åœ°å€å’Œæ—§ rbp å€¼ï¼Œç°åœ¨çš„ rbp å¯„å­˜å™¨æŒ‡å‘å­˜å‚¨æ—§ rbp å€¼çš„åœ°å€ã€‚å› æ­¤æˆ‘ä»¬åªè¦ä¸æ–­å‘å‰å¯»æ‰¾ rbp å€¼ï¼Œå°±å¯ä»¥å®ç°æ ˆå¸§çš„å›æº¯ï¼Œæ¯æ¬¡æ‰¾ rbp å€¼ä¸Šä¸€ä¸ª 8 å­—èŠ‚åŒºåŸŸçš„å†…å®¹ï¼Œå°±èƒ½æ‰¾åˆ°è¿”å›åœ°å€ï¼Œåˆ©ç”¨ addr2line å¯¹è¿™ä¸ªè¿”å›åœ°å€å®šä½ï¼Œå°±èƒ½æ‰¾åˆ°è°ƒç”¨å½“å‰å‡½æ•°çš„ callerã€‚\nä¸Šè¿°ç¤ºä¾‹ä»£ç ä½¿ç”¨ä¸€ä¸ª struct frame ç»“æ„æ¯”è¾ƒç²¾å·§åœ°å®Œæˆäº†è¿™ä»¶äº‹ï¼Œå®ƒåˆšå¼€å§‹ç”¨ä¸€å¥å…§è”æ±‡ç¼–æŠŠ %rbp çš„å€¼æ”¾åˆ°äº† f ä¸­ï¼Œf çš„ç»“æ„ä¸º\nstruct frame { struct frame *next; void *addr; } è¿™æ · next å­˜å‚¨çš„æ­£å¥½æ˜¯æ—§ rbpï¼Œaddr å­˜å‚¨çš„æ­£å¥½æ˜¯å½“å‰å‡½æ•°çš„è¿”å›åœ°å€ (æ ˆæ˜¯ä»ä¸Šå¾€ä¸‹ç”Ÿé•¿çš„)ã€‚end å˜é‡è®°å½•äº†ä»£ç æ®µçš„ç»“æŸä½ç½®ï¼Œå›æº¯åˆ° end ä¹‹ä¸Šå°±å¯ä»¥ç»“æŸäº†ã€‚\nGDB çš„å¼ºå¤§\nå¦‚æœæˆ‘ä»¬ä½¿ç”¨ O2 ä¼˜åŒ–ï¼Œç¤ºä¾‹ä»£ç å°†ä¸èƒ½æ­£å¸¸å·¥ä½œï¼Œå› ä¸ºè¿™äº›å‡½æ•°éƒ½è¢«å…§è”äº†ï¼Œæˆ‘ä»¬åªèƒ½çœ‹åˆ°ä¸€å±‚è°ƒç”¨ã€‚ä½†å¦‚æœç”¨ GDB çš„ backtraceï¼Œæˆ‘ä»¬ä»ç„¶å¯ä»¥çœ‹åˆ°å®Œæ•´çš„å‡½æ•°è°ƒç”¨é“¾â€”â€”è¿™ä¸ªè°ƒç”¨è¿‡ç¨‹æ˜¯ GDB è™šæ„å‡ºæ¥çš„æ­£ç¡®ä¿¡æ¯ã€‚\nLinking and Relocation // hello.c void hello() {} // main.c void hello(); int f(int a, int b) {return a + b;} int main () { hello(); } ä¸Šè¿°ä¸¤ä¸ªæ–‡ä»¶åˆ†åˆ«ç¼–è¯‘æˆå¯é‡å®šä½æ–‡ä»¶åï¼Œæœ€åé“¾æ¥åœ¨ä¸€èµ·å°±å¯ä»¥æ‰§è¡Œã€‚æˆ‘ä»¬å…³å¿ƒ main.c åˆ°åº•æ˜¯å¦‚ä½•æ‰¾åˆ°å¤–éƒ¨çš„ hello() å‡½æ•°çš„åœ°å€çš„ã€‚å¦‚æœæˆ‘ä»¬æŸ¥çœ‹ main.o çš„ä»£ç æ®µä¿¡æ¯ï¼š\n0000000000000000 \u0026lt;f\u0026gt;: 0: f3 0f 1e fa endbr64 4: 8d 04 37 lea (%rdi,%rsi,1),%eax 7: c3 ret 0000000000000000 \u0026lt;main\u0026gt;: 0: f3 0f 1e fa endbr64 4: 48 83 ec 08 sub $0x8,%rsp 8: 31 c0 xor %eax,%eax a: e8 00 00 00 00 call f \u0026lt;main+0xf\u0026gt; f: 31 c0 xor %eax,%eax 11: 48 83 c4 08 add $0x8,%rsp 15: c3 ret ä¼šçœ‹åˆ°åƒ f() è¿™æ ·å®Œå…¨ç¡®å®šçš„å‡½æ•°ç¼–è¯‘å™¨å·²ç»å®Œå…¨ç”Ÿæˆå¥½äº†ä»£ç ï¼Œç¼–è¯‘å™¨è¿˜æ²¡æœ‰å¡«çš„æ˜¯ call åé¢çš„åœ°å€åç§»ï¼Œå› ä¸ºé“¾æ¥ä¹‹å‰å®ƒä¸çŸ¥é“ hello() åœ¨å“ªé‡Œï¼Œå› æ­¤åªèƒ½æš‚æ—¶å¡« 0 æ‘†çƒ‚ã€‚\né“¾æ¥ç»“æŸå main() åœ¨ 0xb å¤„å¡«å†™çš„ offset åº”è¯¥æ»¡è¶³ä¸‹é¢çš„ assertionï¼š\n// hello.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;assert.h\u0026gt; void main(); void hello() { void *p = (void *)main + 0xa + 1; int32_t offset = *((int32_t *)p); assert((char *)main + 0xf + offset == (char *)hello); } (æ³¨ï¼šå¼€å§‹è·³è½¬çš„åœ°å€æ˜¯ main +0xf æ˜¯å› ä¸º x86 çš„ call æŒ‡ä»¤æ˜¯ä»ä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€å¼€å§‹è·³è½¬çš„ã€‚)\nä¸ºäº†æ»¡è¶³è¿™ä¸ª assertionï¼Œæˆ‘ä»¬å®¹æ˜“è®¡ç®—å‡ºè¦å¡«å†™çš„ offset åº”è¯¥æ»¡è¶³ $S+A-P$ çš„æ ¼å¼ï¼Œå…¶ä¸­ $S$ æ˜¯ç›®æ ‡å‡½æ•°çš„åœ°å€ (åœ¨è¿™é‡Œæ˜¯ (void *)hello)ï¼Œ$A$ æ˜¯ä¸€ä¸ªåç§»é‡ï¼Œ(åœ¨è¿™é‡Œæ˜¯ $-4$)ï¼Œ$P$ æ˜¯ä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€ (åœ¨è¿™é‡Œæ˜¯ (void *)main + 0xb)ã€‚å¦‚æœæˆ‘ä»¬ç”¨ readelf æŸ¥çœ‹ main.o çš„é‡å®šä½è¡¨ï¼Œå¯ä»¥çœ‹åˆ°\nOffset Info Type Sym. Value Sym. Name + Addend 00000000000b 000c00000004 R_X86_64_PLT32 0000000000000000 hello - 4 è¿™é‡Œçš„ \u0026ldquo;Offset\u0026rdquo; å°±æ˜¯ $P$ï¼Œ\u0026ldquo;Addend\u0026rdquo; å°±æ˜¯ $A$ï¼Œ\u0026ldquo;Sym\u0026rdquo; å°±æ˜¯ $S$ã€‚\nå› æ­¤ï¼Œé€šä¿—æ¥è¯´ï¼Œ\nç¼–è¯‘å™¨ (gcc) å°±æ˜¯å°† high-level semantics (C è¯­è¨€) è½¬æ¢æˆ low-level semantics (æ±‡ç¼–)ã€‚ æ±‡ç¼–å™¨ (as) å°±æ˜¯å°† low-level semantics è½¬æ¢æˆ binary semantics (çŠ¶æ€æœºå®¹å™¨)ï¼Œè¿™ä¸ªéƒ¨åˆ†å‡ ä¹æ˜¯ä¸€ä¸€å¯¹åº”åœ°ç¿»è¯‘ï¼Œå¯¹äºæš‚æ—¶æ²¡æ³•å¡«çš„è¦ç•™ä¸‹é‡å®šä½ä¿¡æ¯ï¼Œé‡å®šä½ä¿¡æ¯æœ¬è´¨ä¸Šå°±æ˜¯å¯¹å¡«å†™å†…å®¹çš„ assertionã€‚ é“¾æ¥å™¨ (ld) è´Ÿè´£åˆå¹¶æ‰€æœ‰å®¹å™¨ï¼Œå¾—åˆ°ä¸€ä¸ªå®Œæ•´çš„çŠ¶æ€æœºï¼Œé™¤äº†æˆ‘ä»¬æŒ‡å®šçš„ .o æ–‡ä»¶å¤–ï¼Œé“¾æ¥å™¨è¿˜ä¼šå°†ä¸€äº› C Runtime Objects é“¾æ¥è¿›æ¥ã€‚æ‰¾ä¸åˆ°ç¬¦å·/é‡å¤å¼ºç¬¦å·çš„é”™è¯¯ä¹Ÿæ˜¯åœ¨é“¾æ¥é˜¶æ®µæŠ¥å‡ºã€‚ åœ¨è¿™ç§ç†è§£ä¸‹ï¼Œæˆ‘ä»¬å¾ˆå®¹æ˜“è®¾è®¡ä¸€ä¸ªè‡ªå·±çš„â€œç®€æ˜“äºŒè¿›åˆ¶æ–‡ä»¶æ ¼å¼â€œï¼š\nstruct executable { uint32_t entry; struct segment *segments; struct reloc *relocs; struct symbol *symbols; }; struct segment {uint32_t flags, size; char data[0];} struct reloc {uint32_t S, A, P; const char *name;} struct symbol {uint32_t offset, const char *name;} éšç€å„ç§éœ€æ±‚çš„åŠ å…¥ï¼Œæˆ‘ä»¬å°±ä¼šæ…¢æ…¢ç†è§£ ELF ä¸­å„ç§ä¿¡æ¯è®¾ç½®çš„å«ä¹‰ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"aedffb6d8a985102aeafceef65c7cb72","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec16/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec16/","section":"notes","summary":"æœ¬èŠ‚è¯¾é»˜è®¤åªæœ‰é™æ€é“¾æ¥ã€‚\nOverview å¯æ‰§è¡Œæ–‡ä»¶çš„æœ¬è´¨æè¿°çŠ¶æ€æœºåˆå§‹çŠ¶æ€ (æ•°æ®) å’Œè¿ç§» (æŒ‡ä»¤) çš„æ•°æ®ç»“æ„ï¼šå¯æ‰§è¡Œæ–‡ä»¶åœ¨ execve() çš„æ—¶å€™ä½¿ç”¨ï¼Œæ“ä½œç³»ç»Ÿæ ¹æ®å¯æ‰§è¡Œæ–‡ä»¶çš„æè¿°è®¾ç½®çŠ¶æ€æœºå¹¶å¼€å§‹æ‰§è¡Œã€‚\næ›´å…·ä½“åœ°è¯´ï¼Œå¯æ‰§è¡Œæ–‡ä»¶æ˜¯ä¸€ä¸ªæè¿°äº†çŠ¶æ€æœºåˆå§‹çŠ¶æ€çš„æ•°æ®ç»“æ„ã€‚çŠ¶æ€æœºçš„åˆå§‹çŠ¶æ€ä¸€èˆ¬åŒ…æ‹¬ä»¥ä¸‹å‡ ä¸ªæ–¹é¢ï¼š\nå¯„å­˜å™¨ï¼šå¤§éƒ¨åˆ†å¯„å­˜å™¨çš„å€¼ç”± ABI è§„å®š (æ¯”å¦‚å“ªäº›å¯„å­˜å™¨åº”è¯¥æ¸…é›¶)ï¼Œç”±æ“ä½œç³»ç»Ÿè´Ÿè´£è®¾ç½®ã€‚ä½†ä¹Ÿæœ‰ä¸€äº›é‡è¦çš„å¯„å­˜å™¨çš„å€¼æ˜¯å¯æ‰§è¡Œæ–‡ä»¶æŒ‡å®šçš„ï¼Œæ¯”å¦‚ PC çš„å€¼ã€‚ åœ°å€ç©ºé—´ (å†…å­˜)ï¼šç”±äºŒè¿›åˆ¶æ–‡ä»¶å’Œ ABI å…±åŒå†³å®šï¼Œæ¯”å¦‚æŸä¸€æ®µæ•°æ®åº”è¯¥æ”¾åˆ°å†…å­˜ä¸­çš„å“ªé‡Œï¼Œä»¥åŠ argv, envp çš„å†…å®¹ã€‚ å…¶ä»–æœ‰ç”¨çš„ä¿¡æ¯ (æ¯”å¦‚è°ƒè¯•ä¿¡æ¯) ä»€ä¹ˆæ ·çš„æ–‡ä»¶å¯ä»¥è¢«æ‰§è¡Œï¼Ÿ\nä¸€ä¸ªæ–‡ä»¶éœ€è¦æ»¡è¶³è‹¥å¹²æ¡ä»¶æ‰èƒ½è¢«æ‰§è¡Œã€‚å‡è®¾æˆ‘ä»¬æœ‰æºä»£ç  a.cï¼Œç›´æ¥æ‰§è¡Œå®ƒ (./a.c) ä¼šè·å¾— Permission denied (bash)ï¼Œå³ä½¿æˆ‘ä»¬ç”¨ chmod +x a.","tags":null,"title":"Lecture 16: Executable Files","type":"docs"},{"authors":null,"categories":null,"content":"Static Loader Loader on OS å¯æ‰§è¡Œæ–‡ä»¶æ˜¯ä¸€ä¸ªæè¿°äº†çŠ¶æ€æœºçš„åˆå§‹çŠ¶æ€çš„æ•°æ®ç»“æ„ã€‚åŠ è½½å™¨æ ¹æ®å¯æ‰§è¡Œæ–‡ä»¶çš„æè¿°è®¾ç½®å¥½åˆå§‹çŠ¶æ€æœºã€‚æˆ‘ä»¬å¾ˆå®¹æ˜“å†™ä¸€ä¸ªé™æ€åŠ è½½å™¨ï¼š\n// loader-static.c #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;assert.h\u0026gt; #include \u0026lt;elf.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #define STK_SZ (1 \u0026lt;\u0026lt; 20) #define ROUND(x, align) (void *)(((uintptr_t)x) \u0026amp; ~(align - 1)) #define MOD(x, align) (((uintptr_t)x) \u0026amp; (align - 1)) #define push(sp, T, ...) ({ *((T*)sp) = (T)__VA_ARGS__; sp = (void *)((uintptr_t)(sp) + sizeof(T)); }) void execve_(const char *file, char *argv[], char *envp[]) { // WARNING: This execve_ does not free process resources. int fd = open(file, O_RDONLY); assert(fd \u0026gt; 0); Elf64_Ehdr *h = mmap(NULL, 4096, PROT_READ, MAP_PRIVATE, fd, 0); assert(h != (void *)-1); assert(h-\u0026gt;e_type == ET_EXEC \u0026amp;\u0026amp; h-\u0026gt;e_machine == EM_X86_64); Elf64_Phdr *pht = (Elf64_Phdr *)((char *)h + h-\u0026gt;e_phoff); for (int i = 0; i \u0026lt; h-\u0026gt;e_phnum; i++) { Elf64_Phdr *p = \u0026amp;pht[i]; if (p-\u0026gt;p_type == PT_LOAD) { int prot = 0; if (p-\u0026gt;p_flags \u0026amp; PF_R) prot |= PROT_READ; if (p-\u0026gt;p_flags \u0026amp; PF_W) prot |= PROT_WRITE; if (p-\u0026gt;p_flags \u0026amp; PF_X) prot |= PROT_EXEC; void *ret = mmap( ROUND(p-\u0026gt;p_vaddr, p-\u0026gt;p_align), // addr, rounded to ALIGN p-\u0026gt;p_memsz + MOD(p-\u0026gt;p_vaddr, p-\u0026gt;p_align), // length prot, // protection MAP_PRIVATE | MAP_FIXED, // flags, private \u0026amp; strict fd, // file descriptor (uintptr_t)ROUND(p-\u0026gt;p_offset, p-\u0026gt;p_align)); // offset assert(ret != (void *)-1); memset((void *)(p-\u0026gt;p_vaddr + p-\u0026gt;p_filesz), 0, p-\u0026gt;p_memsz - p-\u0026gt;p_filesz); } } close(fd); static char stack[STK_SZ], rnd[16]; void *sp = ROUND(stack + sizeof(stack) - 4096, 16); void *sp_exec = sp; int argc = 0; // argc while (argv[argc]) argc++; push(sp, intptr_t, argc); // argv[], NULL-terminate for (int i = 0; i \u0026lt;= argc; i++) push(sp, intptr_t, argv[i]); // envp[], NULL-terminate for (; *envp; envp++) { if (!strchr(*envp, '_')) // remove some verbose ones push(sp, intptr_t, *envp); } // auxv[], AT_NULL-terminate push(sp, intptr_t, 0); push(sp, Elf64_auxv_t, { .a_type = AT_RANDOM, .a_un.a_val = (uintptr_t)rnd } ); push(sp, Elf64_auxv_t, { .a_type = AT_NULL } ); asm volatile( \u0026quot;mov $0, %%rdx;\u0026quot; // required by ABI \u0026quot;mov %0, %%rsp;\u0026quot; \u0026quot;jmp *%1\u0026quot; : : \u0026quot;a\u0026quot;(sp_exec), \u0026quot;b\u0026quot;(h-\u0026gt;e_entry)); } int main(int argc, char *argv[], char *envp[]) { if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Usage: %s file [args...]\\n\u0026quot;, argv[0]); exit(1); } execve_(argv[1], argv + 1, envp); } ç¼–è¯‘å¥½ loader-static.c åï¼Œä½¿ç”¨å‘½ä»¤ ./loader ELFæ–‡ä»¶å å¯ä»¥æ­£ç¡®åœ°åŠ è½½å¹¶æ‰§è¡Œä¸€ä¸ªé™æ€é“¾æ¥çš„ ELF æ–‡ä»¶ã€‚æˆ‘ä»¬å¯ä»¥ç”¨ strace è¯æ˜æˆ‘ä»¬å¹¶æ²¡æœ‰åœ¨ loader ä¸­ä½¿ç”¨ execve() ç³»ç»Ÿè°ƒç”¨ï¼Œä½†æˆ‘ä»¬å®ç°äº† execve() çš„åŠŸèƒ½ã€‚\næˆ‘ä»¬æ¥ä»”ç»†é˜…è¯»è¿™ä»½ä»£ç ï¼šmain() å‡½æ•°çš„ execve_() å®ç°äº† execve() ç³»ç»Ÿè°ƒç”¨çš„åŠŸèƒ½ã€‚ä¸è¿‡è¿™ä¸ª execve_() æ˜¯æˆ‘ä»¬è‡ªå·±å®ç°çš„ã€‚execve_() ä¸»è¦åšäº†ä»¥ä¸‹è¿™äº›äº‹ï¼š\nexecve_() è·å¾—çš„å‚æ•°ï¼Œfile æ˜¯è¦æ‰“å¼€çš„æ–‡ä»¶åï¼Œargv[] å’Œ envp[] æ˜¯å‚æ•°åˆ—è¡¨å’Œç¯å¢ƒå˜é‡åˆ—è¡¨ã€‚æˆ‘ä»¬æ‰“å¼€æ–‡ä»¶å¹¶è¯»å‡º ELF æ–‡ä»¶å¤´ï¼Œå¯¹å…¶è¿›è¡Œä¸€ç³»åˆ—æ£€æŸ¥ (æ¯”å¦‚æ¶æ„æ˜¯å¦æ­£ç¡®ï¼Œç±»å‹æ˜¯å¦æ˜¯ EXEC ç­‰)ã€‚\nå°†è¦åŠ è½½çš„æ®µåŠ è½½åˆ°å†…å­˜ä¸­ã€‚æˆ‘ä»¬éå† ELF æ–‡ä»¶çš„ç¨‹åºå¤´è¡¨ï¼Œå°†é‚£äº›æ ‡æœ‰ PT_LOAD çš„æ®µåŠ è½½åˆ°æŒ‡å®šä½ç½® (å³ p-\u0026gt;p_vaddr)ã€‚æˆ‘ä»¬ä½¿ç”¨ mmap() æ¥å®Œæˆâ€œåŠ è½½â€ï¼Œå®ƒçš„æœ¬è´¨æ˜¯å°†åœ°å€ç©ºé—´ä¸­çš„ä¸€æ®µåŒºåŸŸæ˜ å°„åˆ°æ–‡ä»¶ä¸­ã€‚è¿™é‡Œæœ‰ä¸€äº›æ¯”è¾ƒçç¢çš„ç»†èŠ‚ï¼Œæ¯”å¦‚åœ¨ä½¿ç”¨äº† MAP_FIXED æ ‡å¿—åï¼Œæˆ‘ä»¬å¿…é¡»ä¿è¯ä¼ ç»™ mmap çš„åœ°å€æ˜¯å¯¹é½çš„ï¼Œå› æ­¤éœ€è¦ ROUND()ï¼Œå¯¹é½åæˆ‘ä»¬åŠ è½½çš„é•¿åº¦ä¹Ÿç›¸åº”è¦å¢åŠ ï¼Œå› æ­¤æœ‰äº†ç¬¬äºŒè¡Œçš„ MOD()ã€‚\nå…³äº MAP_FIXED\né€šå¸¸æƒ…å†µä¸‹ï¼Œä¼ ç»™ mmap() çš„ç¬¬ä¸€ä¸ªå‚æ•° addr å†…æ ¸åªæ˜¯å°†å…¶å½“ä½œä¸€ä¸ª hintï¼Œå†…æ ¸ä¼šå°½é‡å°†è¦åŠ è½½çš„å†…å®¹æ”¾åˆ° addr é™„è¿‘ï¼Œä½†ä¸ç»™å‡ºä»»ä½•ä¿è¯ã€‚ä½†å¦‚æœä½¿ç”¨äº† MAP_FIXED æ ‡å¿—ï¼Œå†…æ ¸ä¼šå°†è¦åŠ è½½çš„å†…å®¹ç¡®å®šåœ°æ”¾åˆ° addr ä½ç½®ï¼Œè¿™ç§æƒ…å†µä¸‹ï¼Œaddr è¦ä¿è¯å¯¹é½ã€‚\nMAP_FIXED æ ‡å¿—ä¸€å®šè¦éå¸¸å°å¿ƒåœ°ä½¿ç”¨ï¼Œåœ¨ä¸åŒçš„æ“ä½œç³»ç»Ÿï¼Œå†…æ ¸ç‰ˆæœ¬ï¼Œlibc ç‰ˆæœ¬ä¸‹è¿›ç¨‹çš„åœ°å€ç©ºé—´å¸ƒå±€å¯èƒ½æœ‰å¾ˆå¤§çš„å·®å¼‚ï¼ŒMAP_FIXED ä¼šä½¿ç¨‹åºçš„å¯ç§»æ¤æ€§ä¸‹é™ã€‚\nè¿˜æœ‰ä¸€ä¸ªå°ç»†èŠ‚æ˜¯ï¼šæˆ‘ä»¬è¦å°† [p-\u0026gt;p_filesz, p-\u0026gt;p_memsz) .bss èŠ‚çš„éƒ¨åˆ†æ¸…é›¶ã€‚\nä¸ºç¨‹åºå‡†å¤‡ä¸€ä¸ªè¿è¡Œæ—¶æ ˆï¼Œè¿™é‡Œæˆ‘ä»¬ç›´æ¥å¼€äº† 1 MiB çš„æ•°ç»„ä½œä¸ºæ ˆï¼Œå¹¶ä¿å­˜äº† argc çš„åœ°å€å¾…ä¼šä¼ ç»™ stack pointer (æˆ‘ä»¬ä¸ºå„ç§å‚æ•°å‡†å¤‡äº† 4KiB çš„ç©ºé—´)ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬è¦å°† argv[]ï¼Œenvp[]ï¼Œaux[] ç­‰æ”¾åˆ°æ ˆä¸Šï¼Œè¿™äº›å†…å®¹éƒ½å¯ä»¥åœ¨ System V ABI Figure 3.9 çš„ Initial Process Stack ä¸­æ‰¾åˆ°ã€‚è¿™é‡Œç¤ºä¾‹ä»£ç å®šä¹‰äº†ä¸€ä¸ªéå¸¸ä¼˜é›…çš„å® push()\n#define push(sp, T, ...) ({ *((T*)sp) = (T)__VA_ARGS__; sp = (void *)((uintptr_t)(sp) + sizeof(T)); }) å®ƒçš„ä½œç”¨æ˜¯å°†å½“å‰å‚æ•°æ”¾åœ¨ sp çš„ä½ç½®ï¼Œå¹¶æŠŠ sp åŠ ä¸Š sizeof(T) ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªç©ºç™½ä½ç½®ã€‚æˆ‘ä»¬è¿™é‡Œåšå‡ºçš„ä¸€ä¸ªå°ä¿®æ”¹æ˜¯ä¸å°†å¸¦ä¸‹åˆ’çº¿çš„ç¯å¢ƒå˜é‡ä¸Šæ ˆï¼Œè¿™å¯ä»¥å¸®åŠ©æˆ‘ä»¬ç¡®ä¿¡æˆ‘ä»¬çš„ç¨‹åºå¯¹å„ç§å†…å®¹çš„æŒæ§ã€‚\næœ€åæ˜¯å‡ ä¸ªå…§è”æ±‡ç¼–è¯­å¥ï¼Œå®Œæˆçš„å·¥ä½œæ˜¯æ ¹æ® ABI è§„å®šå°† %rdx è®¾ç½®ä¸º 0ï¼Œå°†æ ˆæŒ‡é’ˆ %rsp è®¾ç½®ä¸º argc çš„åœ°å€ï¼Œæœ€åæ ¹æ® ELF çš„å…¥å£åœ°å€å°† PC è·³è½¬è¿‡å» (æ­¤å¤„å¸¦ * è¡¨ç¤ºç»å¯¹è·³è½¬)ã€‚\nè¿™ä¸ª loader å­˜åœ¨ä¸€ä¸ªå°é—®é¢˜ï¼šloader æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ª ELFï¼Œå®ƒè¿è¡Œèµ·æ¥çš„æ—¶å€™åœ°å€ç©ºé—´ä¸­æœ¬èº«å°±æœ‰è‡ªå·±çš„æ˜ å°„ã€‚æˆ‘ä»¬è¿›è¡Œæ–°çŠ¶æ€æœºçš„æ˜ å°„æ—¶å¯èƒ½ä¼šå‡ºç°æ˜ å°„å†²çªçš„æƒ…å†µï¼Œå¦‚æœå¼ºè¡Œæ˜ å°„å¯èƒ½ä¼šä½¿ loader å´©æºƒã€‚è¿™æ—¶æˆ‘ä»¬åº”è¯¥å°† loader çš„æ˜ å°„æŒªä¸€ä¸ªåœ°æ–¹ï¼Œä½†è¿™ä¼šä½¿ loader çš„å¤æ‚åº¦å¤§å¹…ä¸Šå‡ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬é‡‡ç”¨çš„æ–¹æ³•æ˜¯è®© loader åŠ¨æ€é“¾æ¥ï¼ŒåŠ¨æ€é“¾æ¥å’Œé™æ€é“¾æ¥çš„åœ°å€ç©ºé—´é€šå¸¸å·®å¼‚å¾ˆå¤§ï¼Œä¸ä¼šé‡å ã€‚\nLoader on OS ä¸æ“ä½œç³»ç»Ÿè®¾è®¡\nè¿™æ˜¯ä¸€ä¸ªå®Œå…¨å¤„åœ¨ç”¨æˆ·æ€çš„ loaderâ€”â€”æˆ‘ä»¬å‘ç°æ“ä½œç³»ç»Ÿçš„ execve() ç³»ç»Ÿè°ƒç”¨å…¶å®æ˜¯å¤šä½™çš„ã€‚æˆ‘ä»¬åœ¨ç”¨æˆ·æ€é€šè¿‡ open(), mmap() ç­‰ç³»ç»Ÿè°ƒç”¨å¯ä»¥å®ç° execve() çš„åŠŸèƒ½ã€‚è¿™ä¸ç¦è®©æˆ‘ä»¬æ€è€ƒï¼šæ“ä½œç³»ç»Ÿæ˜¯ä¸æ˜¯åº”è¯¥æŠŠåŠ è½½çš„è¿‡ç¨‹ä»å†…æ ¸ç§»å‡ºæ¥ï¼Œè®©ç”¨æˆ·å¯¹åŠ è½½è¿‡ç¨‹æœ‰æ›´å¼ºçš„å¯å®šåˆ¶æ€§ï¼Ÿâ€¦â€¦\nBoot Loader // bootmain.c #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;elf.h\u0026gt; #include \u0026lt;x86/x86.h\u0026gt; #define SECTSIZE 512 #define ARGSIZE 1024 static inline void wait_disk(void) { while ((inb(0x1f7) \u0026amp; 0xc0) != 0x40); } static inline void read_disk(void *buf, int sect) { wait_disk(); outb(0x1f2, 1); outb(0x1f3, sect); outb(0x1f4, sect \u0026gt;\u0026gt; 8); outb(0x1f5, sect \u0026gt;\u0026gt; 16); outb(0x1f6, (sect \u0026gt;\u0026gt; 24) | 0xE0); outb(0x1f7, 0x20); wait_disk(); for (int i = 0; i \u0026lt; SECTSIZE / 4; i ++) { ((uint32_t *)buf)[i] = inl(0x1f0); } } static inline void copy_from_disk(void *buf, int nbytes, int disk_offset) { uint32_t cur = (uint32_t)buf \u0026amp; ~(SECTSIZE - 1); uint32_t ed = (uint32_t)buf + nbytes; uint32_t sect = (disk_offset / SECTSIZE) + (ARGSIZE / SECTSIZE) + 1; for(; cur \u0026lt; ed; cur += SECTSIZE, sect ++) read_disk((void *)cur, sect); } static void load_program(uint32_t filesz, uint32_t memsz, uint32_t paddr, uint32_t offset) { copy_from_disk((void *)paddr, filesz, offset); char *bss = (void *)(paddr + filesz); for (uint32_t i = filesz; i != memsz; i++) { *bss++ = 0; } } static void load_elf64(Elf64_Ehdr *elf) { Elf64_Phdr *ph = (Elf64_Phdr *)((char *)elf + elf-\u0026gt;e_phoff); for (int i = 0; i \u0026lt; elf-\u0026gt;e_phnum; i++, ph++) { load_program( (uint32_t)ph-\u0026gt;p_filesz, (uint32_t)ph-\u0026gt;p_memsz, (uint32_t)ph-\u0026gt;p_paddr, (uint32_t)ph-\u0026gt;p_offset ); } } static void load_elf32(Elf32_Ehdr *elf) { Elf32_Phdr *ph = (Elf32_Phdr *)((char *)elf + elf-\u0026gt;e_phoff); for (int i = 0; i \u0026lt; elf-\u0026gt;e_phnum; i++, ph++) { load_program( (uint32_t)ph-\u0026gt;p_filesz, (uint32_t)ph-\u0026gt;p_memsz, (uint32_t)ph-\u0026gt;p_paddr, (uint32_t)ph-\u0026gt;p_offset ); } } void load_kernel(void) { Elf32_Ehdr *elf32 = (void *)0x8000; Elf64_Ehdr *elf64 = (void *)0x8000; int is_ap = boot_record()-\u0026gt;is_ap; if (!is_ap) { // load argument (string) to memory copy_from_disk((void *)MAINARG_ADDR, 1024, -1024); // load elf header to memory copy_from_disk(elf32, 4096, 0); if (elf32-\u0026gt;e_machine == EM_X86_64) { load_elf64(elf64); } else { load_elf32(elf32); } } else { // everything should be loaded } if (elf32-\u0026gt;e_machine == EM_X86_64) { ((void(*)())(uint32_t)elf64-\u0026gt;e_entry)(); } else { ((void(*)())(uint32_t)elf32-\u0026gt;e_entry)(); } } bootmain.c æ˜¯ AbstractMachine ä¸­åŠ è½½å†…æ ¸çš„ä»£ç ã€‚æˆ‘ä»¬å·²ç»çŸ¥é“å›ºä»¶ä¸­çš„ä»£ç ä¼šå¸®æˆ‘ä»¬æŠŠå¯åŠ¨ç£ç›˜çš„ç¬¬ä¸€ä¸ªæ‰‡åŒº (512B) çš„ MBR æ¬åˆ°ä¸€ä¸ªæŒ‡å®šçš„ä½ç½®å¹¶å¼€å§‹æ‰§è¡Œï¼Œä¸Šè¿°ä»£ç å°±æ˜¯ä¸»å¼•å¯¼æ‰‡åŒºçš„ä»£ç ã€‚æˆ‘ä»¬çš„å†…æ ¸é•œåƒç¬¬ä¸€ä¸ªæ‰‡åŒºæ˜¯ MBRï¼Œç¬¬äºŒã€ä¸‰ä¸ªæ‰‡åŒºå­˜å‚¨äº†ä¼ ç»™ main() å‡½æ•°çš„å‚æ•°ï¼Œåé¢çš„éƒ¨åˆ†æ˜¯å†…æ ¸çš„ ELFï¼ŒMBR ä»£ç çš„å·¥ä½œå’Œä¹‹å‰çš„ loader on OS ä¸€æ ·ï¼Œå°†å†…æ ¸ ELF ä¸­è¯¥åŠ è½½çš„ä¸œè¥¿æ”¾åˆ°æŒ‡å®šçš„åœ°æ–¹ã€‚\nè¯¥ä»£ç å’Œ loader on OS ä¸ä¸€æ ·çš„åœ°æ–¹åœ¨äºï¼šæ“ä½œç³»ç»Ÿä¸­æˆ‘ä»¬æœ‰ mmap() ç³»ç»Ÿè°ƒç”¨ï¼Œå¯ä»¥å°†ä¸€æ®µåœ°å€ç©ºé—´ç›´æ¥æ˜ å°„åˆ°æ–‡ä»¶ä¸­çš„å†…å®¹ï¼Œä½†åœ¨ boot loader ä¸­æˆ‘ä»¬æ²¡æœ‰æ“ä½œç³»ç»Ÿã€‚å¹¸è¿çš„æ˜¯æˆ‘ä»¬æœ‰å¯¹äºå…¨éƒ¨ç¡¬ä»¶èµ„æºçš„æŒæ§ï¼šç°åœ¨è¿˜æ²¡æœ‰è™šæ‹Ÿåœ°å€ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥æŒ‡å®šç‰©ç†åœ°å€ï¼ŒæŒ‡å“ªæ‰“å“ªã€‚bootmain.c ä¸­çš„ read_disk() å‡½æ•°è´Ÿè´£å°†ä¸€ä¸ªæ‰‡åŒºçš„å†…å®¹æ‹·è´åˆ° buf æ•°ç»„ä¸­ï¼Œä»ç¡¬ç›˜ä¸­è¯»å–æ•°æ®çš„ä»£ç éå¸¸çç¢ï¼Œéœ€è¦å‚è€ƒç¡¬ä»¶ I/O ç›¸å…³çš„æ‰‹å†Œã€‚copy_from_disk() æ˜¯å¯¹ read_disk() çš„è¿›ä¸€æ­¥å°è£…ï¼Œå‰©ä½™çš„ load_program()ï¼Œload_elf32/64() çš„ä»£ç å’Œ loader on OS æ²¡æœ‰æœ¬è´¨åŒºåˆ«ã€‚\nLinux Kernel Loader Linux å†…æ ¸æ²¡ä»€ä¹ˆå¯æ€•çš„ï¼Œåªæ˜¯æˆ‘ä»¬ä¹‹å‰å†™çš„ loader çš„æ”¾å¤§ç‰ˆæœ¬ã€‚\nå­¦ä¼šä½¿ç”¨æ­£ç¡®çš„å·¥å…·\nä½¿ç”¨ vscode è°ƒè¯•ä»£ç ï¼Œå¯ä»¥å……åˆ†å¯è§†åŒ–ï¼›å‡½æ•°è·³è½¬ï¼ŒæŸ¥æ‰¾ç­‰ä¼šéå¸¸æ–¹ä¾¿ã€‚\nDynamic Linking éšç€åº“å‡½æ•°è¶Šæ¥è¶Šå¤§ï¼Œæˆ‘ä»¬å¸Œæœ›é¡¹ç›®èƒ½å¤Ÿåœ¨è¿è¡Œæ—¶å†é“¾æ¥ï¼Œè¿™æ ·æˆ‘ä»¬ä¸éœ€è¦æ¯ä¸ªæ–‡ä»¶éƒ½é“¾æ¥ libc åº“å‡½æ•°ï¼ŒèŠ‚çœå†…å­˜ç©ºé—´ã€‚æ­¤å¤–ï¼Œå¦‚æœæˆ‘ä»¬çš„åº“å‡½æ•°è¦æ‰“ä¸€ä¸ªå®‰å…¨è¡¥ä¸ï¼Œåœ¨æ²¡æœ‰åŠ¨æ€é“¾æ¥çš„æƒ…å†µä¸‹ï¼Œç³»ç»Ÿä¸­æ‰€æœ‰é“¾æ¥åº“çš„æ–‡ä»¶éƒ½è¦é‡æ–°ç¼–è¯‘ä¸€é (éå¸¸å¯æ€•)ï¼Œæœ‰äº†åŠ¨æ€é“¾æ¥æˆ‘ä»¬å°±å¯ä»¥å…é™¤è¿™ä¸ªéº»çƒ¦ã€‚\nå‡è®¾æˆ‘ä»¬è¦å®ç°ä¸€ä¸ªè‡ªå·±çš„äºŒè¿›åˆ¶æ–‡ä»¶æ ¼å¼ï¼Œæ”¯æŒåŠ¨æ€åŠ è½½ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦æœ‰ä»¥ä¸‹å­—æ®µï¼š\nDL_HEAD LOAD(\u0026quot;libc.dl\u0026quot;) // åŠ è½½åŠ¨æ€åº“ IMPORT(putchar) // åŠ è½½å¤–éƒ¨ç¬¦å· EXPORT(hello) // ä¸ºåŠ¨æ€åº“å¯¼å‡ºæœ¬åœ°ç¬¦å· DL_CODE hello: ... CALL DSYM(putchar) // DSYM(func) è¡¨ç¤º func æ˜¯å¤–éƒ¨çš„å‡½æ•° DL_END å‡è®¾æˆ‘ä»¬æœ‰é…å¥—çš„ç¼–è¯‘å™¨å¯ä»¥ç”Ÿæˆè¿™ç§æ ¼å¼çš„ä½ç½®æ— å…³ä»£ç ã€‚æˆ‘ä»¬å¯ä»¥å®ç°è¿™ç§æ ¼å¼ä¸Šçš„â€œå…¨å®¶æ¡¶â€å·¥å…·é›†ï¼šgcc å¯¹æ ‡ ld ï¼Œreaddl å¯¹æ ‡ readelfï¼Œobjdump å¯¹æ ‡ objdumpï¼Œinterp ç”¨äºæ‰§è¡Œï¼š\n// main.S #include \u0026quot;dl.h\u0026quot; DL_HEAD LOAD(\u0026quot;libc.dl\u0026quot;) LOAD(\u0026quot;libhello.dl\u0026quot;) IMPORT(hello) EXPORT(main) DL_CODE main: call DSYM(hello) call DSYM(hello) call DSYM(hello) call DSYM(hello) movq $0, %rax ret DL_END main.S åŠ è½½äº† libc åº“å’Œ libhello åº“ï¼Œå¼•å…¥äº† hello ç¬¦å·ï¼Œç„¶ååœ¨ main() å‡½æ•°ä¸­è°ƒç”¨äº† 4 æ¬¡ hello()ã€‚\n// libhello.S #include \u0026quot;dl.h\u0026quot; DL_HEAD LOAD(\u0026quot;libc.dl\u0026quot;) IMPORT(putchar) EXPORT(hello) DL_CODE hello: lea str(%rip), %rdi mov count(%rip), %eax push %rbx mov %rdi, %rbx inc %eax mov %eax, count(%rip) add $0x30, %eax movb %al, 0x6(%rdi) loop: movsbl (%rbx),%edi test %dil,%dil je out call DSYM(putchar) inc %rbx jmp loop out: pop %rbx ret str: .asciz \u0026quot;Hello X\\n\u0026quot; count: .int 0 DL_END libhello.S åŠ è½½äº† libc åº“ï¼Œå¼•å…¥äº† putchar ç¬¦å·ï¼Œå¹¶ä¸ºåŠ¨æ€åº“æä¾›äº† hello() å‡½æ•°ã€‚hello() å‡½æ•°çš„åŠŸèƒ½å¾ˆç®€å•ï¼šæ¯æ¬¡è°ƒç”¨ putchar() è¾“å‡ºå­—ç¬¦ä¸² \u0026ldquo;Hello X\\n\u0026rdquo;ï¼Œå…¶ä¸­ X ä¼šæ¯è½® +1ã€‚\n// libc.S #include \u0026quot;dl.h\u0026quot; #include \u0026lt;sys/syscall.h\u0026gt; DL_HEAD EXPORT(putchar) EXPORT(exit) DL_CODE putchar: mov %dil, buf(%rip) mov $SYS_write, %rax mov $1, %rdi lea buf(%rip), %rsi mov $1, %rdx syscall ret buf: .byte 0 exit: movq $SYS_exit, %rax syscall DL_END libc.S ä¸ºåŠ¨æ€åº“æä¾›äº† putchar() å‡½æ•°å’Œ exit() å‡½æ•°ï¼Œputchar() å‡½æ•°é€šè¿‡ write ç³»ç»Ÿè°ƒç”¨è¾“å‡ºå­—ç¬¦ï¼Œexit() å‡½æ•°é€šè¿‡ exit ç³»ç»Ÿè°ƒç”¨é€€å‡ºã€‚\nåˆ©ç”¨å…¨å®¶æ¡¶å·¥å…· dlbox.cï¼Œæˆ‘ä»¬å¯ä»¥åˆ†åˆ«é“¾æ¥ä¸‰ä¸ªæ±‡ç¼–æ–‡ä»¶ï¼Œç”Ÿæˆå¯¹åº”çš„ .dl æ–‡ä»¶ï¼š\n./dlbox gcc main.S ./dlbox gcc libc.S ./dlbox gcc libhello.S æˆ‘ä»¬å¯ä»¥ç”¨ readdl å·¥å…·æŸ¥çœ‹ dl æ–‡ä»¶çš„å†…å®¹ï¼š\n\u0026gt; ./dlbox readdl main.dl DLIB file main.dl: LOAD libc.dl LOAD libhello.dl EXTERN hello 000000c0 main å¯ä»¥çœ‹åˆ° main.S åŠ è½½äº† libc å’Œ libhelloï¼Œå¯¼å…¥äº†å¤–éƒ¨ç¬¦å· helloï¼Œæœ¬åœ°æœ‰ä¸€ä¸ªç¬¦å· mainã€‚\næˆ‘ä»¬å¯ä»¥ç”¨ objdump å·¥å…·æŸ¥çœ‹åæ±‡ç¼–ä»£ç ï¼š\n\u0026gt; ./dlbox objdump libc.dl Disassembly of binary libc.dl: 0000000000000000 \u0026lt;putchar\u0026gt;: 00000000 40883D1F000000 mov [rel 0x26],dil 00000007 48C7C001000000 mov rax,0x1 0000000E 48C7C701000000 mov rdi,0x1 00000015 488D350A000000 lea rsi,[rel 0x26] 0000001C 48C7C201000000 mov rdx,0x1 00000023 0F05 syscall 00000025 C3 ret 00000026 00 db 0x00 0000000000000027 \u0026lt;exit\u0026gt;: 00000027 48C7C03C000000 mov rax,0x3c 0000002E 0F05 syscall (æ³¨ï¼šéœ€è¦åœ¨æœ¬åœ°å®‰è£… nasm å·¥å…·é›†ã€‚)\næœ€åï¼Œæˆ‘ä»¬ä¸éœ€è¦å°†è¿™äº› dl æ–‡ä»¶æ±‡é›†åœ¨ä¸€èµ·é“¾æ¥ï¼Œå°±å¯ä»¥ç›´æ¥è¿è¡Œ main.dlï¼š\n\u0026gt; ./dlbox interp main.dl Hello 1 Hello 2 Hello 3 Hello 4 æˆ‘ä»¬ç°åœ¨å…³æ³¨è¿™ä¸ªåŠ¨æ€åŠ è½½å™¨æ˜¯å¦‚ä½•å®ç°çš„ã€‚é¦–å…ˆçœ‹ dl.hã€‚\n// dl.h #define REC_SZ 32 #define DL_MAGIC \u0026quot;\\x01\\x14\\x05\\x14\u0026quot; #ifdef __ASSEMBLER__ #define DL_HEAD __hdr: \\ /* magic */ .ascii DL_MAGIC; \\ /* file_sz */ .4byte (__end - __hdr); \\ /* code_off */ .4byte (__code - __hdr) #define DL_CODE .fill REC_SZ - 1, 1, 0; \\ .align REC_SZ, 0; \\ __code: #define DL_END __end: #define RECORD(sym, off, name) \\ .align REC_SZ, 0; \\ sym .8byte (off); .ascii name #define IMPORT(sym) RECORD(sym:, 0, \u0026quot;?\u0026quot; #sym \u0026quot;\\0\u0026quot;) #define EXPORT(sym) RECORD( , sym - __hdr, \u0026quot;#\u0026quot; #sym \u0026quot;\\0\u0026quot;) #define LOAD(lib) RECORD( , 0, \u0026quot;+\u0026quot; lib \u0026quot;\\0\u0026quot;) #define DSYM(sym) *sym(%rip) #else #include \u0026lt;stdint.h\u0026gt; struct dl_hdr { char magic[4]; uint32_t file_sz, code_off; }; struct symbol { int64_t offset; char type, name[REC_SZ - sizeof(int64_t) - 1]; }; #endif ä¸ŠåŠéƒ¨åˆ†æ˜¯ç»™æ±‡ç¼–çœ‹çš„ï¼ŒååŠéƒ¨åˆ†æ˜¯ç»™ C è¯­è¨€çœ‹çš„ (å³ dlbox.h)ã€‚dl.h æ˜¯å¯¹æˆ‘ä»¬çš„ DIY äºŒè¿›åˆ¶æ–‡ä»¶æ ¼å¼çš„ä¸€ä¸ª specificationã€‚æˆ‘ä»¬çš„äºŒè¿›åˆ¶æ–‡ä»¶æ ¼å¼å¦‚ä¸‹ï¼š\nheader symbol1 symbol2 \u0026hellip; symboln 00\u0026hellip;0 code å…¶ä¸­æ¯ä¸ªéƒ¨åˆ†éƒ½æ˜¯ 32 å­—èŠ‚å¯¹é½çš„ã€‚header çš„ç»“æ„å¦‚ C è¯­è¨€ä»£ç éƒ¨åˆ†æ‰€ç¤ºã€‚header ä¸­æœ‰ä¸€ä¸ª 4B çš„é­”æ•°ç”¨äºæ£€æŸ¥æ–‡ä»¶æ ¼å¼ï¼Œä¸€ä¸ªå˜é‡ file_sz è®°å½•æ•´ä¸ªæ–‡ä»¶çš„å¤§å°ï¼Œä¸€ä¸ªå˜é‡ code_off è®°å½•ä»£ç æ®µè·ç¦»æ–‡ä»¶å¼€å¤´çš„ offsetã€‚é€šè¿‡æ±‡ç¼–éƒ¨åˆ†çš„å®å¯ä»¥çœ‹åˆ°ï¼Œåœ¨æ±‡ç¼–ä»£ç ä¸­æ·»åŠ äº†ä¸€äº›ç¬¦å·åè¿™äº›å€¼éƒ½æ˜¯å¾ˆå®¹æ˜“ç®—å‡ºçš„ã€‚\næ¯”è¾ƒå…³é”®çš„å®æ˜¯ IMPORT()ï¼ŒEXPORT() å’Œ LOAD()ã€‚å¯ä»¥çœ‹åˆ°å®ƒä»¬çš„æœ¬è´¨æ˜¯åœ¨ç¬¦å·è¡¨ä¸­æ·»åŠ ä¸€ä¸ªè¡¨é¡¹ã€‚ç¬¦å·è¡¨çš„ç»“æ„å¦‚ C è¯­è¨€ä»£ç éƒ¨åˆ†æ‰€ç¤ºï¼Œå‰ 8 ä¸ªå­—èŠ‚æ˜¯è¿™ä¸ªç¬¦å·æ‰€åœ¨ä½ç½®ä¸æ–‡ä»¶å¼€å¤´çš„ offset (å¦‚æœè¿™æ˜¯ä¸€ä¸ªå¤–éƒ¨ç¬¦å·åˆ™æš‚æ—¶å¡« 0ï¼ŒåŠ è½½çš„æ—¶å€™ç”±åŠ¨æ€åŠ è½½å™¨è¡¥å…¨)ï¼Œtype è¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªå†…éƒ¨å¯¼å‡ºçš„ç¬¦å·ï¼Œå¤–éƒ¨å¯¼å…¥çš„ç¬¦å·è¿˜æ˜¯è¦åŠ è½½ä¸€ä¸ªåŠ¨æ€åº“ã€‚æœ€åçš„ name[] æ•°ç»„è®°å½•äº†åå­—ã€‚å°†è¿™ä¸ªç»“æ„ä½“å’Œå®å®šä¹‰å¯¹æ¯”èµ·æ¥çœ‹ä¹Ÿå¾ˆå®¹æ˜“æ‡‚ï¼Œè¿™é‡Œå€¼å¾—æ³¨æ„çš„ä¸€ä¸ªå°ç»†èŠ‚æ˜¯ï¼šIMPORT(sym) ä¸­ï¼Œç›´æ¥ä½¿ç”¨ sym è¡¨ç¤ºçš„æ˜¯æ±‡ç¼–æ–‡ä»¶ä¸­å®šä¹‰çš„ sym ç¬¦å·ï¼Œåœ¨å‰é¢åŠ ä¸Š # æ‰è¡¨ç¤º sym æœ¬èº«è¿™ä¸ªå­—ç¬¦ä¸²ã€‚\nå¦å¤–å¯ä»¥çœ‹åˆ°ï¼ŒDSYM() å®æ˜¯ä¸€ä¸ª PC ç›¸å¯¹è·³è½¬ã€‚DSYM(sym) ä¼šè¢«ç¿»è¯‘ä¸º call *sym(%rip)ã€‚è¯¥æŒ‡ä»¤çš„è¯­ä¹‰æ˜¯ PC = mem[next-pc + offset]ã€‚å› æ­¤åœ¨æ±‡ç¼–é˜¶æ®µ PC å’Œæœ¬æ–‡ä»¶ç¬¦å·è¡¨ä¸­çš„ sym çš„å·®å€¼ offset å°±èƒ½ç¡®å®šã€‚åœ¨åŠ è½½æ—¶ï¼Œéšç€ç¬¦å·è¡¨ sym é‡Œé¢å¡«å†™çš„åœ°å€è¢«ç¡®å®šï¼Œcall å°±èƒ½å®Œæˆæ­£ç¡®çš„è·³è½¬ã€‚\n// dlbox.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;assert.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026quot;dl.h\u0026quot; #define SIZE 4096 #define LENGTH(arr) (sizeof(arr) / sizeof(arr[0])) struct dlib { struct dl_hdr hdr; struct symbol *symtab; // borrowed spaces from header const char *path; }; static struct dlib *dlopen(const char *path); struct dlib *dlopen_chk(const char *path) { struct dlib *lib = dlopen(path); if (!lib) { fprintf(stderr, \u0026quot;Not a valid dlib file: %s.\\n\u0026quot;, path); exit(1); } return lib; } // Implementation of binutils void dl_gcc(const char *path) { char buf[256], *dot = strrchr(path, '.'); if (dot) { *dot = '\\0'; sprintf(buf, \u0026quot;gcc -m64 -fPIC -c %s.S \u0026amp;\u0026amp; \u0026quot; \u0026quot;objcopy -S -j .text -O binary %s.o %s.dl\u0026quot;, path, path, path); system(buf); } } void dl_readdl(const char *path) { struct dlib *h = dlopen_chk(path); printf(\u0026quot;DLIB file %s:\\n\\n\u0026quot;, h-\u0026gt;path); for (struct symbol *sym = h-\u0026gt;symtab; sym-\u0026gt;type; sym++) { switch (sym-\u0026gt;type) { case '+': printf(\u0026quot; LOAD %s\\n\u0026quot;, sym-\u0026gt;name); break; case '?': printf(\u0026quot; EXTERN %s\\n\u0026quot;, sym-\u0026gt;name); break; case '#': printf( \u0026quot;%08lx %s\\n\u0026quot;, sym-\u0026gt;offset, sym-\u0026gt;name); break; } } } void dl_objdump(const char *path) { struct dlib *h = dlopen_chk(path); char *hc = (char *)h, cmd[64]; FILE *fp = NULL; printf(\u0026quot;Disassembly of binary %s:\\n\u0026quot;, h-\u0026gt;path); for (char *code = hc + h-\u0026gt;hdr.code_off; code \u0026lt; hc + h-\u0026gt;hdr.file_sz; code++) { for (struct symbol *sym = h-\u0026gt;symtab; sym-\u0026gt;type; sym++) { if (hc + sym-\u0026gt;offset == code) { int off = code - hc - h-\u0026gt;hdr.code_off; if (fp) pclose(fp); sprintf(cmd, \u0026quot;ndisasm - -b 64 -o 0x%08x\\n\u0026quot;, off); fp = popen(cmd, \u0026quot;w\u0026quot;); printf(\u0026quot;\\n%016x \u0026lt;%s\u0026gt;:\\n\u0026quot;, off, sym-\u0026gt;name); fflush(stdout); } } if (fp) fputc(*code, fp); } if (fp) pclose(fp); } // binutils: interpreter void dl_interp(const char *path) { struct dlib *h = dlopen_chk(path); int (*entry)() = NULL; for (struct symbol *sym = h-\u0026gt;symtab; sym-\u0026gt;type; sym++) if (strcmp(sym-\u0026gt;name, \u0026quot;main\u0026quot;) == 0) entry = (void *)((char *)h + sym-\u0026gt;offset); if (entry) { exit(entry()); } } struct cmd { const char *cmd; void (*handler)(const char *path); } commands[] = { { \u0026quot;gcc\u0026quot;, dl_gcc }, { \u0026quot;readdl\u0026quot;, dl_readdl }, { \u0026quot;objdump\u0026quot;, dl_objdump }, { \u0026quot;interp\u0026quot;, dl_interp }, { \u0026quot;\u0026quot;, NULL }, }; int main(int argc, char *argv[]) { if (argc \u0026lt; 3) { fprintf(stderr, \u0026quot;Usage: %s {gcc|readdl|objdump|interp} FILE...\\n\u0026quot;, argv[0]); return 1; } for (struct cmd *cmd = \u0026amp;commands[0]; cmd-\u0026gt;handler; cmd++) { for (char **path = \u0026amp;argv[2]; *path \u0026amp;\u0026amp; strcmp(argv[1], cmd-\u0026gt;cmd) == 0; path++) { if (path != argv + 2) printf(\u0026quot;\\n\u0026quot;); cmd-\u0026gt;handler(*path); } } } // Implementation of dlopen() static struct symbol *libs[16], syms[128]; static void *dlsym(const char *name); static void dlexport(const char *name, void *addr); static void dlload(struct symbol *sym); static struct dlib *dlopen(const char *path) { struct dl_hdr hdr; struct dlib *h; int fd = open(path, O_RDONLY); if (fd \u0026lt; 0) goto bad; if (read(fd, \u0026amp;hdr, sizeof(hdr)) \u0026lt; sizeof(hdr)) goto bad; if (strncmp(hdr.magic, DL_MAGIC, strlen(DL_MAGIC)) != 0) goto bad; h = mmap(NULL, hdr.file_sz, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE, fd, 0); if (h == (void *)-1) goto bad; h-\u0026gt;symtab = (struct symbol *)((char *)h + REC_SZ); h-\u0026gt;path = path; for (struct symbol *sym = h-\u0026gt;symtab; sym-\u0026gt;type; sym++) { switch (sym-\u0026gt;type) { case '+': dlload(sym); break; // (recursively) load case '?': sym-\u0026gt;offset = (uintptr_t)dlsym(sym-\u0026gt;name); break; // resolve case '#': dlexport(sym-\u0026gt;name, (char *)h + sym-\u0026gt;offset); break; // export } } return h; bad: if (fd \u0026gt; 0) close(fd); return NULL; } static void *dlsym(const char *name) { for (int i = 0; i \u0026lt; LENGTH(syms); i++) if (strcmp(syms[i].name, name) == 0) return (void *)syms[i].offset; assert(0); } static void dlexport(const char *name, void *addr) { for (int i = 0; i \u0026lt; LENGTH(syms); i++) if (!syms[i].name[0]) { syms[i].offset = (uintptr_t)addr; // load-time offset strcpy(syms[i].name, name); return; } assert(0); } static void dlload(struct symbol *sym) { for (int i = 0; i \u0026lt; LENGTH(libs); i++) { if (libs[i] \u0026amp;\u0026amp; strcmp(libs[i]-\u0026gt;name, sym-\u0026gt;name) == 0) return; // already loaded if (!libs[i]) { libs[i] = sym; dlopen(sym-\u0026gt;name); // load recursively return; } } assert(0); } dlbox.c å®ç°äº† dl æ ¼å¼çš„å·¥å…·å…¨å®¶æ¡¶ã€‚å®ƒæœ‰å¾ˆå¤šçš„åŠŸèƒ½éƒ½æ˜¯å€Ÿç”¨äº† GNU å·¥å…·é“¾å®ç°çš„ã€‚è¿™å…¶ä¸­æœ€é‡è¦çš„å‡½æ•°æ˜¯ dlopen()ï¼Œå®ƒå¯ä»¥æ‰“å¼€ä¸€ä¸ª .dl æ–‡ä»¶ï¼Œå°†å…¶ä¸­çš„å†…å®¹è§£æå‡ºæ¥ï¼Œå¹¶è¿”å›ä¸€ä¸ª dlib ç»“æ„ä½“ï¼Œdlib ç»“æ„ä½“çš„å†…å®¹å’Œä¹‹å‰ç»˜åˆ¶çš„äºŒè¿›åˆ¶æ–‡ä»¶ç»“æ„ç›¸åŒã€‚\ndlopen() åšäº†å¦‚ä¸‹çš„äº‹æƒ…ï¼š\nè°ƒç”¨ open() æ‰“å¼€ç›®æ ‡æ–‡ä»¶ï¼Œä»ä¸­è¯»å–äº† sizeof(dl_hdr) çš„æ•°æ®ï¼Œå³æŠŠæ–‡ä»¶å¤´è¯»äº†å‡ºæ¥ï¼Œè¿›è¡Œé­”æ•°æ£€æŸ¥ï¼Œå¹¶è·å¾—äº†æ•´ä¸ªæ–‡ä»¶çš„å¤§å°ã€‚ åˆ©ç”¨ mmap() ç³»ç»Ÿè°ƒç”¨å°†æ•´ä¸ªç›®æ ‡æ–‡ä»¶åŠ è½½åˆ°å†…å­˜ä¸­ (å…¶æœ¬è´¨æ˜¯ copy-on-write çš„ï¼Œå› æ­¤å³ä½¿æ–‡ä»¶å¾ˆå¤§é€Ÿåº¦ä¹Ÿå¾ˆå¿«)ï¼Œå°†ç¬¦å·è¡¨é¦–åœ°å€è®¾ç½®ä¸º header ä¸‹é¢ä¸€ä¸ªï¼Œè®¾ç½®å¥½ h-\u0026gt;pathã€‚ éå†ç¬¦å·è¡¨ï¼Œå¯¹äº EXPORT ç±»å‹è°ƒç”¨ dlexport() å°†å½“å‰ç¬¦å·åŠ è½½æ—¶åœ¨å†…å­˜ä¸­çš„ç»å¯¹åœ°å€å¡«å†™åˆ°æ•°æ®ç»“æ„ä¸­ï¼›å¯¹äº IMPORT ç±»å‹è°ƒç”¨ dlsym() åœ¨æ•°æ®ç»“æ„ä¸­æŸ¥æ‰¾åœ°å€å¹¶å°†æœ¬æ–‡ä»¶ç¬¦å·è¡¨ä¸­çš„ offset å¡«ä¸Šæ­£ç¡®çš„å€¼ï¼›å¯¹äº LOAD å‹è°ƒç”¨ dlload() åŠ è½½ä¸€ä¸ªæ–°çš„æ–‡ä»¶ï¼Œdlload() çš„æœ¬è´¨æ˜¯é€’å½’åœ°è°ƒç”¨ dlopen()ï¼Œä¸è¿‡å®ƒä¼šè®°å½•å½“å‰å·²ç»æ‰“å¼€è¿‡çš„æ–‡ä»¶ï¼Œä¿è¯ä¸ä¼šé‡å¤åŠ è½½åŒä¸€ä¸ªåŠ¨æ€åº“ã€‚ åœ¨ dlopen() çš„åŸºç¡€ä¸Šï¼Œ gcc readdl objdump interp å››ä¸ªå·¥å…·çš„å®ç°æ˜¯ç®€å•çš„ï¼š\ngcc å·¥å…·å®é™…ä¸Šä½¿ç”¨çš„æ˜¯å¤–éƒ¨ gcc ä¸­çš„æ±‡ç¼–å™¨ï¼Œæˆ‘ä»¬è¦æ±‚æ±‡ç¼–å™¨ç”Ÿæˆ 64 ä½æ¶æ„çš„ä½ç½®æ— å…³ä»£ç ï¼Œç„¶åç”¨ objcopy å·¥å…·æŠŠäºŒè¿›åˆ¶æ–‡ä»¶çš„ä»£ç èŠ‚å¤åˆ¶å‡ºæ¥ï¼Œè¾“å‡ºåˆ°ä¸€ä¸ª dl æ–‡ä»¶ä¸­ã€‚ readdl å·¥å…·é¦–å…ˆè°ƒç”¨ dlopen() æ‰“å¼€å¯¹åº”çš„æ–‡ä»¶ï¼Œç„¶åéå†æ•´ä¸ªç¬¦å·è¡¨ï¼Œæ ¹æ® type æ‰“å°ç›¸åº”çš„ä¿¡æ¯ã€‚ objdump å·¥å…·é¦–å…ˆè°ƒç”¨ dlopen() æ‰“å¼€å¯¹åº”æ–‡ä»¶ï¼Œç„¶åæŠŠåæ±‡ç¼–çš„å·¥ä½œäº¤ç»™ ndisasm å·¥å…·ï¼Œobjdump ä¸»è¦è´Ÿè´£æ‰«æç¬¦å·è¡¨ï¼Œçœ‹å½“å‰åœ°å€æ˜¯ä¸æ˜¯ä¸€ä¸ªæ–°å‡½æ•°ï¼Œå¹¶æŠŠå‡½æ•°åæ‰“å°å‡ºæ¥ã€‚ interp å·¥å…·é¦–å…ˆè°ƒç”¨ dlopen() æ‰“å¼€å¯¹åº”æ–‡ä»¶ï¼Œç„¶ååœ¨ç¬¦å·è¡¨ä¸­å¯»æ‰¾æ˜¯ main çš„ç¬¦å·ï¼Œè·³è½¬åˆ° main çš„é¦–åœ°å€å¼€å§‹æ‰§è¡Œï¼Œå¹¶å°† main() çš„è¿”å›å€¼å–‚ç»™ exit() é€€å‡º dlboxã€‚ æˆ‘ä»¬å¾ˆå¿«ä¼šå‘ç°æˆ‘ä»¬è®¾è®¡çš„äºŒè¿›åˆ¶æ–‡ä»¶æ ¼å¼æœ‰å¾ˆå¤šå¯æ”¹è¿›çš„åœ°æ–¹ï¼š\næˆ‘ä»¬çš„å­—ç¬¦ä¸²åæ—¶å¸¸è¾¾ä¸åˆ°ä¸Šé™ï¼Œè¿™ä½¿å¾—äºŒè¿›åˆ¶æ–‡ä»¶ä¸­æœ‰å¤§é‡çš„ 0ã€‚æˆ‘ä»¬åº”è¯¥å°†æ‰€æœ‰çš„åå­—æ”¾åœ¨ä¸€ä¸ªå­—ç¬¦ä¸²å¸¸é‡æ± ä¸­ï¼Œç„¶åå…¶ä»–åœ°æ–¹ä¿å­˜æŒ‡å‘å­—ç¬¦ä¸²çš„æŒ‡é’ˆã€‚\næˆ‘ä»¬æ¯ä¸ª .dl æ–‡ä»¶ä¸­åªæœ‰ä¸€ä¸ªä»£ç æ®µï¼Œè¿™ä¸ªä»£ç æ®µæ˜¯å¯è¯»å¯å†™å¯æ‰§è¡Œçš„ã€‚æˆ‘ä»¬å¸Œæœ›æœ‰æ›´å¤šçš„ä»£ç æ®µï¼Œä¸åŒçš„æ®µæœ‰ä¸åŒçš„æƒé™ï¼Œè¿™å°±æœ‰äº† program header tableã€‚\nåœ¨æˆ‘ä»¬è‡ªå·±çš„äºŒè¿›åˆ¶æ–‡ä»¶æ ¼å¼ä¸­ï¼Œæ¥è‡ªå¤–éƒ¨åº“çš„å‡½æ•°éœ€è¦åœ¨å‰é¢åŠ ä¸Š DSYM() ä»¥ç¡®ä¿è¢«ç¼–è¯‘æˆä¸€ä¸ª call *sym(%rip) æŒ‡ä»¤ã€‚ä½†å®é™…æƒ…å†µä¸‹æˆ‘ä»¬å†™ä»£ç æ—¶å¹¶ä¸ä¼šæ ‡æ³¨ä¸€ä¸ªå‡½æ•°ç©¶ç«Ÿæ—¶æ¥è‡ªå¤–éƒ¨åº“çš„å‡½æ•°è¿˜æ˜¯æ¥è‡ªå¤–éƒ¨ç¼–è¯‘å•å…ƒçš„å‡½æ•°â€”â€”å‰è€…å¿…é¡»è¦åˆ°åŠ è½½çš„æ—¶å€™æ‰èƒ½ç¡®å®šä½ç½®ï¼Œåè€…åœ¨é“¾æ¥çš„æ—¶å€™å°±èƒ½ç¡®å®šã€‚å› æ­¤æˆ‘ä»¬ä¸å¾—ä¸å°†æ‰€æœ‰çš„å‡½æ•°éƒ½ç¼–è¯‘æˆ DSYM() çš„å½¢å¼ã€‚è¿™æ˜¯ä¸€ä¸ªä¸‡èƒ½çš„å½¢å¼ï¼Œä½†è¿™ç§è·³è½¬ç›¸è¾ƒäºç›´æ¥ç›¸å¯¹äº PC çš„è·³è½¬å¤šäº†ä¸€æ¬¡è®¿å­˜ï¼Œæ•ˆç‡ä½ã€‚\næˆ‘ä»¬å¯ä»¥è€ƒè™‘è¿™æ ·ä¸€ç§å¤„ç†æ–¹å¼ï¼šæˆ‘ä»¬å‡†å¤‡ä¸€ä¸ªå« PLT çš„ä¸œè¥¿å­˜å‚¨åœ¨å¯æ‰§è¡Œæ–‡ä»¶é‡Œï¼Œå‘å‡½æ•° f çš„è·³è½¬ç»Ÿä¸€ç¼–è¯‘ä¸ºé™æ€çš„è·³è½¬åˆ°æœ¬æ–‡ä»¶çš„ f@plt() å‡½æ•°çš„ç®€å•è·³è½¬ã€‚è¿™æ ·é“¾æ¥çš„æ—¶å€™å¦‚æœå‘ç° f() å…¶å®æ˜¯æ¥è‡ªå¤–éƒ¨ç¼–è¯‘å•å…ƒçš„å‡½æ•°ï¼Œå°±ä¿®æ”¹ä¸€ä¸‹è·³è½¬çš„ç›®æ ‡å‡½æ•°ï¼›å¦‚æœ f() æ˜¯å¤–éƒ¨åº“çš„å‡½æ•°ï¼Œå°±åœ¨ f@plt() ä¸­åŠ ä¸€æ¡ jmp *off(%rip) æŒ‡ä»¤ã€‚è¿™æ ·æˆ‘ä»¬ç¼–è¯‘æ—¶å¯ä»¥ç»Ÿä¸€ä½¿ç”¨é™æ€çš„è·³è½¬æŒ‡ä»¤ã€‚åŠ è½½æ—¶å¡«å†™å¥½å„ä¸ª symbol çš„åŠ è½½æ—¶åœ°å€åï¼Œjmp æŒ‡ä»¤å°±å¯ä»¥æ­£å¸¸å·¥ä½œäº†ã€‚\nè¿™é‡Œå­˜å‚¨å„ä¸ª symbol åœ°å€ï¼Œåœ¨åŠ è½½æ—¶å¡«å†™çš„ä¸œè¥¿å°±å« global offset table (GOT)ï¼Œç”¨äºé—´æ¥è·³è½¬çš„ä¸œè¥¿å°±å« procedure linkage table (PLT)ã€‚æˆ‘ä»¬ç‹¬ç«‹å‘æ˜äº† PLT å’Œ GOT çš„æ¦‚å¿µï¼\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"15f73bc32392647b171cc09dcf1318f2","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec17/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec17/","section":"notes","summary":"Static Loader Loader on OS å¯æ‰§è¡Œæ–‡ä»¶æ˜¯ä¸€ä¸ªæè¿°äº†çŠ¶æ€æœºçš„åˆå§‹çŠ¶æ€çš„æ•°æ®ç»“æ„ã€‚åŠ è½½å™¨æ ¹æ®å¯æ‰§è¡Œæ–‡ä»¶çš„æè¿°è®¾ç½®å¥½åˆå§‹çŠ¶æ€æœºã€‚æˆ‘ä»¬å¾ˆå®¹æ˜“å†™ä¸€ä¸ªé™æ€åŠ è½½å™¨ï¼š\n// loader-static.c #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;assert.h\u0026gt; #include \u0026lt;elf.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #define STK_SZ (1 \u0026lt;\u0026lt; 20) #define ROUND(x, align) (void *)(((uintptr_t)x) \u0026amp; ~(align - 1)) #define MOD(x, align) (((uintptr_t)x) \u0026amp; (align - 1)) #define push(sp, T, .","tags":null,"title":"Lecture 17: Linking and Loading","type":"docs"},{"authors":null,"categories":null,"content":" Xv6 ä¸­çš„ .d .sym .asm æ–‡ä»¶æ˜¯ä»€ä¹ˆï¼Ÿ\n.d æ–‡ä»¶æè¿°äº† Makefile ä¸­æ–‡ä»¶æ‰€éœ€çš„ä¾èµ–å…³ç³»ã€‚æˆ‘ä»¬è€ƒè™‘å¦‚ä¸‹ç¨‹åºï¼š\na.o: a.c gcc -c a.c // a.c #include \u0026quot;a.h\u0026quot; // a.h // Cannot compile Makefile çš„é€»è¾‘æ˜¯ï¼ša.o ä¾èµ–æ–‡ä»¶ a.cï¼Œåœ¨æ‰§è¡Œ make æ—¶ï¼Œå¦‚æœ a.c ç›¸è¾ƒäºä¸Šä¸€æ¬¡ make å‘ç”Ÿè¿‡æ”¹åŠ¨ï¼Œåˆ™ä¼šå†æ¬¡æ‰§è¡Œç¼–è¯‘æŒ‡ä»¤ï¼Œå¦‚æœæ²¡æœ‰æ”¹åŠ¨åˆ™ä¸æ‰§è¡Œã€‚ä½†å½“æˆ‘ä»¬çš„ a.c include äº† a.h ä¹‹åï¼Œå®é™…ä¸Š a.o å¤šäº†ä¸€ä¸ªé—´æ¥çš„ä¾èµ–å…³ç³»ï¼šå½“ a.h å‘ç”Ÿæ”¹åŠ¨æ—¶ï¼Œæˆ‘ä»¬ä¹Ÿåº”è¯¥é‡æ–°æ‰§è¡Œç¼–è¯‘æŒ‡ä»¤ã€‚ä½†å¾ˆé—æ†¾ï¼Œé™¤éåœ¨ Makefile ä¸­æ·»åŠ  a.h ä¾èµ–ï¼Œå¦åˆ™ Makefile ä¸ä¼šè‡ªå·±åšåˆ°è¿™ä¸€ç‚¹ã€‚\nå¤§å‹é¡¹ç›®ä¸­ä¸€ä¸ª C ç¨‹åºå¯èƒ½æœ‰å¾ˆå¤šå¾ˆå¤šçš„ includeã€‚å¦‚æœå°†è¿™äº› include å…¨éƒ¨å¡«åˆ° Makefile ä¸­ï¼ŒMakefile å°†å˜å¾—éš¾ä»¥ç»´æŠ¤ã€‚å› æ­¤æˆ‘ä»¬åˆ©ç”¨ç¼–è¯‘å™¨ç”Ÿæˆäº† .d æ–‡ä»¶ï¼Œ.d æ–‡ä»¶ä¸­åŒ…å«äº†ä¸€ä¸ªç¨‹åºä¾èµ–çš„å¤´æ–‡ä»¶åˆ—è¡¨ï¼Œä¸”è¿™ä¸ªåˆ—è¡¨æ˜¯ Makefile å¯ä»¥ç›´æ¥è§£æçš„ï¼Œè¿™æ ·æˆ‘ä»¬è§£å†³äº†ä¾èµ–é—®é¢˜ã€‚\nXv6 Framework /kernel æ˜¯å†…æ ¸ä»£ç ï¼ŒMakefile ä¼šå°†æ‰€æœ‰çš„æºä»£ç æ–‡ä»¶ç¼–è¯‘åæ ¹æ® /kernel/kernel.ld çš„é“¾æ¥è„šæœ¬é“¾æ¥ç”Ÿæˆä¸€ä¸ª kernel å¯æ‰§è¡Œæ–‡ä»¶ã€‚/user æ˜¯ç”¨æˆ·ç¨‹åºä»£ç ï¼ŒMakefile ä¼šç»™å°†æ¯ä¸ªå½¢å¦‚ name.c çš„ç”¨æˆ·ç¨‹åºç¼–è¯‘ç”Ÿæˆä¸€ä¸ª _name å¯æ‰§è¡Œæ–‡ä»¶ã€‚/mkfs æ˜¯ç”Ÿæˆæ–‡ä»¶ç³»ç»Ÿçš„ä»£ç ï¼Œ/user ä¸­æ‰€æœ‰ä¸‹åˆ’çº¿å¼€å¤´çš„å¯æ‰§è¡Œæ–‡ä»¶ä¼šè¢«æ”¾å…¥æ–‡ä»¶ç³»ç»Ÿã€‚\nå·¥å…·çš„é…ç½®\nå¥½çš„å·¥å…·ä¼šæå‡é˜…è¯»ä»£ç çš„ä½“éªŒï¼Œä½¿ç”¨ vscode æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„é€‰æ‹©ã€‚ä¸º vscode æ·»åŠ æ­£ç¡®çš„ compile_command.json å¯ä»¥ä½¿ vscode æ­£ç¡®åœ°è·³è½¬ã€‚compile_command.json çš„åŸç†æ˜¯æä¾›æ¯ä¸ªæ–‡ä»¶ä¾èµ–çš„ include pathã€‚æˆ‘ä»¬å¯ä»¥ç”¨ bear å·¥å…·ç›´æ¥çˆ¬ make qemu çš„ä¿¡æ¯ï¼Œå®ƒä¼šè‡ªåŠ¨ç”Ÿæˆ .json æ–‡ä»¶ã€‚\nCode: xv6 System Call å› ä¸ºå¯åŠ¨ç¬¬ä¸€ä¸ªè¿›ç¨‹çš„æ—¶å€™ xv6 è¿˜æ²¡æœ‰åˆå§‹åŒ–æ–‡ä»¶ç³»ç»Ÿï¼Œæ— æ³•é€šè¿‡ exec() ç³»ç»Ÿè°ƒç”¨æ¥åŠ è½½ imageï¼Œæ‰€ä»¥ xv6 çš„ç¬¬ä¸€ä¸ªè¿›ç¨‹ initcode æ˜¯å†™æ­»çš„ä¸€æ®µæ±‡ç¼–ä»£ç  (åœ¨ forkret() ä¸­æœ‰åˆå§‹åŒ–æ–‡ä»¶ç³»ç»Ÿçš„ç›¸å…³ä»£ç )ï¼Œå…·ä½“çš„ä¿¡æ¯å¯ä»¥è§ MIT 6.S081 Lecture 03ã€‚\né€šè¿‡ ecall æŒ‡ä»¤èµ° trampoline ç„¶åè¿›å…¥ usertrap() çš„æµç¨‹å¯ä»¥è§ MIT 6.S081 Lecture 6ã€‚\nä¸ºä»€ä¹ˆæˆ‘åœ¨ GDB ä¸­åŠ æ–­ç‚¹ b *0x0 ä¼šæŠ¥é”™ï¼š\u0026ldquo;cannnot access memory?\u0026rdquo;\n2020ç‰ˆä¹‹å‰çš„ xv6 éœ€è¦åœ¨ .gdbinit.tmpl-riscv ä¸­æ·»åŠ ä¸€æ¡é…ç½®ï¼š\nset riscv use-compressed-breakpoints yes ","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"6ed449169a1e18a27701adbed36f3307","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec18/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec18/","section":"notes","summary":"Xv6 ä¸­çš„ .d .sym .asm æ–‡ä»¶æ˜¯ä»€ä¹ˆï¼Ÿ\n.d æ–‡ä»¶æè¿°äº† Makefile ä¸­æ–‡ä»¶æ‰€éœ€çš„ä¾èµ–å…³ç³»ã€‚æˆ‘ä»¬è€ƒè™‘å¦‚ä¸‹ç¨‹åºï¼š\na.o: a.c gcc -c a.c // a.c #include \u0026quot;a.h\u0026quot; // a.h // Cannot compile Makefile çš„é€»è¾‘æ˜¯ï¼ša.o ä¾èµ–æ–‡ä»¶ a.cï¼Œåœ¨æ‰§è¡Œ make æ—¶ï¼Œå¦‚æœ a.","tags":null,"title":"Lecture 18: Xv6 Code Guide","type":"docs"},{"authors":null,"categories":null,"content":"å¦‚æœæˆ‘ä»¬çš„ç”¨æˆ·ç¨‹åºæœ‰æ­»å¾ªç¯ï¼Œè®¡ç®—æœºå¹¶ä¸ä¼šè¢«å¡æ­»â€”â€”å› ä¸ºæ“ä½œç³»ç»Ÿæœ‰è¿›ç¨‹è°ƒåº¦ï¼›ä½†æ“ä½œç³»ç»Ÿæœ‰å¯¹æ•´ä¸ªè®¡ç®—æœºå®Œå…¨çš„æŒæ§æƒï¼Œå¦‚æœåœ¨æ“ä½œç³»ç»Ÿä»£ç ä¸­åŠ ä¸€ä¸ªæ­»å¾ªç¯ï¼Œé‚£è®¡ç®—æœºå°±çœŸçš„å¡æ­»äº†ã€‚\nVirtualization of CPUs æ¯ä¸€ä¸ªè¿›ç¨‹éƒ½æ˜¯ä¸€ä¸ªçŠ¶æ€æœºï¼Œå…¶ä¸­æœ‰å¯„å­˜å™¨ã€å†…å­˜ï¼Œçœ‹å†…å­˜çš„ \u0026ldquo;VR çœ¼é•œ\u0026rdquo; (é¡µè¡¨) ç­‰ç­‰ã€‚æ“ä½œç³»ç»Ÿæ˜¯ä¸€ä¸ªçŠ¶æ€æœºçš„ç®¡ç†è€…ï¼šå®ƒè¦ç»´æŠ¤å„ä¸ªè¿›ç¨‹çš„çŠ¶æ€æœºï¼Œæ­¤å¤–å†…æ ¸å¯¹åº”çš„çŠ¶æ€æœºä¹Ÿå½’ OS ç®¡ç†ã€‚æ­£åœ¨è¿è¡Œçš„çŠ¶æ€æœºçš„çŠ¶æ€ä¿å­˜åœ¨ç¡¬ä»¶ä¸Š (CPU, DRAM)ï¼Œå…¶ä»–æœªè¿è¡Œçš„è¿›ç¨‹çš„çŠ¶æ€æœºä»¥æŸç§æ–¹å¼è¢«æš‚å­˜èµ·æ¥ã€‚\nç°ä»£æ“ä½œç³»ç»Ÿé€šå¸¸å€ŸåŠ©æ—¶é’Ÿä¸­æ–­ï¼Œä½¿ç”¨æŠ¢å å¼å¤šä»»åŠ¡çš„æ–¹å¼æ¥åœ¨çŠ¶æ€æœºä¹‹é—´åˆ‡æ¢ã€‚ä¸­æ–­ç›¸å½“äºä¸€ä¸ªå¼ºè¡Œæ’å…¥çš„ ecallï¼Œæ‰“æ–­æ­£åœ¨è¿è¡Œçš„æ‰§è¡Œæµã€‚æ“ä½œç³»ç»Ÿè´Ÿè´£å°†è¿™ä¸ªè¿›ç¨‹å½“å‰çš„çŠ¶æ€æœºä»ç¡¬ä»¶ä¸Šå¤åˆ¶ä¸‹æ¥ï¼ŒæŒ‘é€‰ä¸‹ä¸€ä¸ªå‡†å¤‡æ‰§è¡Œçš„è¿›ç¨‹ï¼Œç„¶åå°†å…¶çŠ¶æ€æœºæ¬ä¸Šç¡¬ä»¶ã€‚\nCode: Xv6 trapframe \u0026amp; Thread Switching è¯¥éƒ¨åˆ†å†…å®¹å¯ä»¥å‚è€ƒ MIT 6.S081 Lecture 6 å’Œ Lecture 11ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"a0c977dcb0559d34c7377f4c89d7bf43","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec19/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec19/","section":"notes","summary":"å¦‚æœæˆ‘ä»¬çš„ç”¨æˆ·ç¨‹åºæœ‰æ­»å¾ªç¯ï¼Œè®¡ç®—æœºå¹¶ä¸ä¼šè¢«å¡æ­»â€”â€”å› ä¸ºæ“ä½œç³»ç»Ÿæœ‰è¿›ç¨‹è°ƒåº¦ï¼›ä½†æ“ä½œç³»ç»Ÿæœ‰å¯¹æ•´ä¸ªè®¡ç®—æœºå®Œå…¨çš„æŒæ§æƒï¼Œå¦‚æœåœ¨æ“ä½œç³»ç»Ÿä»£ç ä¸­åŠ ä¸€ä¸ªæ­»å¾ªç¯ï¼Œé‚£è®¡ç®—æœºå°±çœŸçš„å¡æ­»äº†ã€‚\nVirtualization of CPUs æ¯ä¸€ä¸ªè¿›ç¨‹éƒ½æ˜¯ä¸€ä¸ªçŠ¶æ€æœºï¼Œå…¶ä¸­æœ‰å¯„å­˜å™¨ã€å†…å­˜ï¼Œçœ‹å†…å­˜çš„ \u0026ldquo;VR çœ¼é•œ\u0026rdquo; (é¡µè¡¨) ç­‰ç­‰ã€‚æ“ä½œç³»ç»Ÿæ˜¯ä¸€ä¸ªçŠ¶æ€æœºçš„ç®¡ç†è€…ï¼šå®ƒè¦ç»´æŠ¤å„ä¸ªè¿›ç¨‹çš„çŠ¶æ€æœºï¼Œæ­¤å¤–å†…æ ¸å¯¹åº”çš„çŠ¶æ€æœºä¹Ÿå½’ OS ç®¡ç†ã€‚æ­£åœ¨è¿è¡Œçš„çŠ¶æ€æœºçš„çŠ¶æ€ä¿å­˜åœ¨ç¡¬ä»¶ä¸Š (CPU, DRAM)ï¼Œå…¶ä»–æœªè¿è¡Œçš„è¿›ç¨‹çš„çŠ¶æ€æœºä»¥æŸç§æ–¹å¼è¢«æš‚å­˜èµ·æ¥ã€‚\nç°ä»£æ“ä½œç³»ç»Ÿé€šå¸¸å€ŸåŠ©æ—¶é’Ÿä¸­æ–­ï¼Œä½¿ç”¨æŠ¢å å¼å¤šä»»åŠ¡çš„æ–¹å¼æ¥åœ¨çŠ¶æ€æœºä¹‹é—´åˆ‡æ¢ã€‚ä¸­æ–­ç›¸å½“äºä¸€ä¸ªå¼ºè¡Œæ’å…¥çš„ ecallï¼Œæ‰“æ–­æ­£åœ¨è¿è¡Œçš„æ‰§è¡Œæµã€‚æ“ä½œç³»ç»Ÿè´Ÿè´£å°†è¿™ä¸ªè¿›ç¨‹å½“å‰çš„çŠ¶æ€æœºä»ç¡¬ä»¶ä¸Šå¤åˆ¶ä¸‹æ¥ï¼ŒæŒ‘é€‰ä¸‹ä¸€ä¸ªå‡†å¤‡æ‰§è¡Œçš„è¿›ç¨‹ï¼Œç„¶åå°†å…¶çŠ¶æ€æœºæ¬ä¸Šç¡¬ä»¶ã€‚\nCode: Xv6 trapframe \u0026amp; Thread Switching è¯¥éƒ¨åˆ†å†…å®¹å¯ä»¥å‚è€ƒ MIT 6.S081 Lecture 6 å’Œ Lecture 11ã€‚","tags":null,"title":"Lecture 19: Context Switching","type":"docs"},{"authors":null,"categories":null,"content":"å¤„ç†å™¨è°ƒåº¦é—®é¢˜çš„ç®€å•å‡è®¾ (1960s)ï¼š\nç³»ç»Ÿä¸­æœ‰ä¸€ä¸ªå¤„ç†å™¨ ç³»ç»Ÿä¸­æœ‰å¤šä¸ªè¿›ç¨‹/çº¿ç¨‹å…±äº« CPU åŒ…æ‹¬ç³»ç»Ÿè°ƒç”¨ (è¿›ç¨‹/çº¿ç¨‹çš„ä¸€éƒ¨åˆ†åœ¨å†…æ ¸ä»£ç ä¸­) å¶å°”ä¼šç­‰å¾… I/O è¿”å›ï¼Œä¸ä½¿ç”¨ CPUã€‚ Policy Round-Robin æŒ‰ç…§æ—¶é—´ç‰‡è½®è½¬ï¼Œè½®æµè¿è¡Œæ‰€æœ‰çš„è¿›ç¨‹/çº¿ç¨‹ã€‚\né—®é¢˜ï¼šå‡è®¾å½“å‰æœ‰ä¸€ä¸ªå‰å°çš„ vim è¿›ç¨‹å’Œå¾ˆå¤šè®¡ç®—å‹çš„åå°è¿›ç¨‹ï¼Œå¦‚æœä½¿ç”¨ round robinï¼Œå¾ˆå®¹æ˜“å‡ºç°å‰å° vim è¿›ç¨‹å¾ˆå¡çš„ç°è±¡ (vim è¿›ç¨‹ä¸€æ—¦è¢«åˆ‡å‡ºå»äº†ï¼Œå°±è¦ç­‰ä¸€æ•´è½®æ‰èƒ½è·å¾—ä¸€ä¸ªæ—¶é—´ç‰‡)ã€‚\næˆ‘ä»¬å¸Œæœ›å¼•å…¥æŸç§â€œä¼˜å…ˆçº§â€ï¼Œä½¿å¾—å’Œç”¨æˆ·äº¤äº’æ¯”è¾ƒé¢‘ç¹çš„å‰å°è¿›ç¨‹å¯ä»¥è·å¾—æ›´é«˜çš„è°ƒåº¦ä¼˜å…ˆçº§ï¼Œä¼˜åŒ–ç”¨æˆ·çš„ä½¿ç”¨ä½“éªŒã€‚\nUNIX Niceness UNIX çš„ niceness æ˜¯ä¸€ä¸ª -20 ... 19 çš„æ•´æ•°ï¼Œnice å€¼è¶Šé«˜çš„è¿›ç¨‹è¶Šâ€å’Œå–„â€œï¼Œè¶Šå®¹æ˜“è®©å‡º CPUã€‚\nåŸºäºä¼˜å…ˆçº§çš„è°ƒåº¦ç­–ç•¥ï¼š\nåœ¨ä¸€äº›å®æ—¶çš„æ“ä½œç³»ç»Ÿä¸­ (å°¤å…¶æ˜¯ç‰©ç†ç›¸å…³ï¼Œæ¯”å¦‚ç«ç®­/æœºæ¢°æ‰‹ etc.)ï¼ŒCPU ä¼šå®Œå…¨æ ¹æ®ä¼˜å…ˆçº§ï¼Œæ¯æ¬¡é€‰æ‹© niceness æœ€ä½çš„è¿›ç¨‹æ‰§è¡Œã€‚è¿™æ ·çš„åšæ³•æ˜¯æœ‰é“ç†çš„ï¼šæ¯”å¦‚ç«ç®­è¦è¿è¡Œåº”æ€¥ç¨‹åºï¼Œæˆ‘ä»¬è‡ªç„¶ä¸å¸Œæœ›æ—¶é’Ÿä¸­æ–­åæ”¶é›†ç«ç®­è¿è¡Œæ•°æ®çš„è¿›ç¨‹æ’å…¥è¿›æ¥æ‰§è¡Œã€‚\nåœ¨æ¡Œé¢æ“ä½œç³»ç»Ÿä¸­ï¼Œè®©â€œåäººâ€éœ¸å  CPU çš„åšæ³•ä¸å¤ªå¯å–ã€‚åœ¨ Linux ä¸­ï¼Œniceness ç›¸å·® 10ï¼ŒCPU èµ„æºè·å¾—ç‡ç›¸å·®å¤§çº¦ 10 å€ã€‚\næˆ‘ä»¬å¯ä»¥åšä¸€ä¸ªå®éªŒæ¥éªŒè¯è¿™ä¸€ç‚¹ï¼š\ntaskset -c 0 nice -n 19 yes \u0026gt; /dev/null \u0026amp; taskset -c 0 nice -n 9 yes \u0026gt; /dev/null \u0026amp; å…¶ä¸­ taskset å‘½ä»¤å¯ä»¥æŒ‡å®šè®©ä¸€ä¸ªè¿›ç¨‹åœ¨æŸä¸ª CPU æ ¸ä¸Šæ‰§è¡Œã€‚åˆ›å»ºè¿™ä¸¤ä¸ªåå°è¿›ç¨‹åï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ top æ¥è§‚æµ‹å®ƒä»¬çš„ CPU å ç”¨æƒ…å†µã€‚\n// office hour: ä¸ºä»€ä¹ˆæˆ‘ä½¿ç”¨è¿™ä¸¤ä¸ªæŒ‡ä»¤åˆ›å»ºå‡ºçš„è¿›ç¨‹ nice å€¼æ˜¯ 14 å’Œ 19ï¼Ÿ\u0026hellip;\nMLFQ (Multi-level Feedback Queue) ä»ç„¶è€ƒè™‘ round-robin åœ¨é‡åˆ°ä¸€å †è®¡ç®—å¯†é›†å‹çº¿ç¨‹å’Œä¸€ä¸ªäº¤äº’å‹çº¿ç¨‹æ—¶çš„é—®é¢˜ã€‚æˆ‘ä»¬ç°åœ¨è€ƒè™‘ï¼šèƒ½å¦è®©æ“ä½œç³»ç»Ÿè§‚æµ‹è¿›ç¨‹çš„è¡Œä¸ºï¼Œç„¶ååŠ¨æ€åœ°è°ƒæ•´è¿›ç¨‹çš„ä¼˜å…ˆçº§ï¼Ÿè¿™å°±æ˜¯ MLFQ çš„åŸºæœ¬æ€æƒ³ã€‚\næ“ä½œç³»ç»Ÿè§‚æµ‹æ¯ä¸ªè¿›ç¨‹å¯¹æ—¶é—´ç‰‡çš„ä½¿ç”¨æƒ…å†µï¼šå¦‚æœä¸€ä¸ªè¿›ç¨‹æ¯æ¬¡éƒ½ç”¨æ»¡æ•´ä¸ªæ—¶é—´ç‰‡ï¼Œé‚£ä¹ˆå®ƒæ˜¯ä¸€ä¸ªâ€œåè¿›ç¨‹â€ï¼Œæˆ‘ä»¬å°±é€‚å½“é™ä½å®ƒçš„ä¼˜å…ˆçº§ï¼›å¦‚æœä¸€ä¸ªè¿›ç¨‹ç»å¸¸ sleep()ï¼Œç­‰å¾… I/O etc. CPU å ç”¨æ¯”è¾ƒå°ï¼Œé‚£ä¹ˆå®ƒæ˜¯ä¸€ä¸ªâ€œå¥½è¿›ç¨‹â€ï¼Œæˆ‘ä»¬å°±é€‚å½“å¢åŠ å®ƒçš„ä¼˜å…ˆçº§ã€‚æˆ‘ä»¬åŠ¨æ€è°ƒæ•´è¿›ç¨‹çš„ä¼˜å…ˆçº§ï¼Œä¸ºæ¯ç§ä¼˜å…ˆçº§åˆ›å»ºä¸€ä¸ª round robin çš„é˜Ÿåˆ—ã€‚\nå½“ç„¶ï¼Œä¸€ä¸ªçº¯ç²¹çš„â€åè¿›ç¨‹â€å¯ä»¥é€šè¿‡å¦‚ä¸‹çš„æ–¹å¼æ¥æ¬ºéª—è¿™æ ·çš„ç­–ç•¥ï¼š\nwhile (1) { compute(); if (æ—¶é—´ç‰‡å¿«ç”¨å®Œäº†) usleep(1);\t} æ­¤å¤–ï¼Œå¦‚æœåƒ Vim è¿™æ ·çš„é«˜ä¼˜å…ˆçº§è¿›ç¨‹è¿‡å¤šï¼Œåå°çš„è®¡ç®—è¿›ç¨‹å¯èƒ½å°±ä¼šå‡ ä¹å¡æ­»ï¼›è¿›ç¨‹çš„â€œå¥½åâ€å…¶å®æ˜¯åŠ¨æ€å˜åŒ–çš„ï¼Œä¸èƒ½â€œä¸€æ£å­æ‰“æ­»â€ç­‰ç­‰ã€‚æ“ä½œç³»ç»Ÿçš„è®¾è®¡è€…ä¼šè¯•å›¾è¡¥æ•‘è¿™äº›é—®é¢˜ï¼Œæ¯”å¦‚ priority boost ç­–ç•¥ä¼šæ¯éš”ä¸€æ®µæ—¶é—´æŠŠæ‰€æœ‰è¿›ç¨‹çš„ä¼˜å…ˆçº§æ‹‰å¹³ï¼Œä½¿å¾—è¿›ç¨‹æœ‰â€œé‡æ–°åšäººâ€çš„æœºä¼šã€‚\nå¦‚æœæˆ‘ä»¬è€ƒè™‘è¿›ç¨‹ä¹‹é—´çš„é€šä¿¡ï¼Œè¿™ä¸ªé—®é¢˜å°±ä¼šå˜å¾—æ›´åŠ å¤æ‚ï¼šå‡è®¾è¿›ç¨‹ä¸­æœ‰ producer/consumerï¼Œä»¥åŠå…¶ä»–çš„ while(1) çº¿ç¨‹ï¼Œåœ¨ round-robin ä¸­ producer/consumer ä¼šé¢‘ç¹è®©å‡º CPUï¼Œè¿™å¯¼è‡´ while(1) è·å¾—äº†è¿‡å¤šçš„è¿è¡Œæ—¶é—´ï¼›åœ¨ MLFQ ä¸­ï¼Œproducer/consumer å› ä¸ºé¢‘ç¹è®©å‡º CPU ä¼šè·å¾—é«˜ä¼˜å…ˆçº§ï¼Œä½†è¿™ç§è®©å‡ºå¹¶ä¸æ˜¯å‡ºäºäººæœºäº¤äº’çš„ç›®çš„â€”â€”producer/consumer ç»„åˆèµ·æ¥ä»ç„¶æ˜¯ä¸€ä¸ªçº¯è®¡ç®—ä»»åŠ¡ï¼Œå› æ­¤å®ƒè·å¾—é«˜ä¼˜å…ˆçº§ä¹Ÿæ˜¯ä¸åˆç†çš„ã€‚\nCFS (Complete Fair Scheduling) å®Œå…¨å…¬å¹³è°ƒåº¦çš„æŒ‡å¯¼æ€æƒ³å¾ˆç®€å•ï¼šè®©æ¯ä¸ªè¿›ç¨‹å…¬å¹³åœ°äº«ç”¨ CPUã€‚å› æ­¤æ“ä½œç³»ç»Ÿå†…æ ¸ä¼šè®°å½•æ¯ä¸ªè¿›ç¨‹è¿è¡Œçš„æ—¶é—´ï¼Œæ¯æ¬¡è°ƒåº¦å™¨é€‰æ‹©å½“å‰æ‰§è¡Œæ—¶é—´æœ€å°‘çš„è¿›ç¨‹æ‰§è¡Œã€‚\nä¸ºäº†é¿å…è½å…¥ round robin çš„ç»“å±€ï¼ŒCFS é€šè¿‡ç±»ä¼¼äºâ€œå˜é€Ÿé½¿è½®â€çš„æ–¹æ³•å®ç°ä¼˜å…ˆçº§ï¼šæ¯ä¸ªè¿›ç¨‹å®é™…ä¸Šäº«ç”¨çš„æ˜¯ç›¸åŒçš„è™šæ‹Ÿè¿è¡Œæ—¶é—´ (vruntime)ï¼Œä½†ä¸åŒè¿›ç¨‹çš„è™šæ‹Ÿè¿è¡Œæ—¶é—´å’Œç‰©ç†è¿è¡Œæ—¶é—´çš„æ¯”ä¾‹ä¸åŒï¼šä¼˜å…ˆçº§é«˜çš„è¿›ç¨‹ä¸€ä¸ªå•ä½çš„ vruntime å¯¹åº”æ›´é•¿çš„ç‰©ç†æ—¶é—´ï¼Œåä¹‹äº¦ç„¶ã€‚è¿™ç§æ–¹å¼ç±»ä¼¼äºå˜é€Ÿé½¿è½®æ˜¯å› ä¸ºå®ƒå®é™…ä¸Šâ€œæ¬ºéª—â€äº†è¿›ç¨‹ï¼šè¿›ç¨‹èƒ½ç›´æ¥æ„Ÿå—åˆ°çš„ç‰©ç†æ—¶é—´æ˜¯è™šæ‹Ÿçš„ã€‚è¿›ç¨‹å…¶å®å¯ä»¥é€šè¿‡å…¶ä»–æ–¹å¼æ„ŸçŸ¥åˆ°â€œä¸å¯¹åŠ²â€ï¼šæ¯”å¦‚ \u0026ldquo;æˆ‘ 1s æ€ä¹ˆåªæ‰§è¡Œäº† 1M çš„æŒ‡ä»¤ï¼Ÿ\u0026rdquo; ä½†ç°åœ¨çš„è¿›ç¨‹è¿˜æ²¡æœ‰è¿™æ ·çš„èƒ½åŠ›ã€‚\nCFS Complexity: New Process/Thread è€ƒè™‘å¦‚ä¸‹ä¸€æ®µä»£ç ï¼š\n#include \u0026lt;stdio.h\u0026gt; int main () { setbuf(stdout, NULL); int pid = fork(); if (pid \u0026lt; 0) perror(\u0026quot;fork\u0026quot;); else if (pid == 0) for (const char *s = \u0026quot;child\u0026quot;; *s; s++) putchar(*s); else for (const char *s = \u0026quot;parent\u0026quot;; *s; s++) putchar(*s); return 0; } åœ¨è¾ƒæ–°ç‰ˆæœ¬çš„ linux å†…æ ¸ä¸­ï¼Œå¤šæ¬¡è¿è¡Œä¸Šè¿°ç¨‹åºä¼šçœ‹åˆ°å‡ ä¹æ€»æ˜¯ parent å…ˆè¢«æ‰“å°ã€‚è¿™æ˜¯å› ä¸ºç°åœ¨çš„å†…æ ¸æ˜¯ parent first çš„ï¼Œæ›¾ç»çš„å†…æ ¸ç‰ˆæœ¬æ˜¯ child firstï¼Œè¿™å…¶ä¸­å­˜åœ¨ä¸€ä¸ªæƒè¡¡é—®é¢˜ï¼šç»å¤§éƒ¨åˆ†æƒ…å†µä¸‹ fork() æ‰§è¡Œå®Œä¼šç´§æ¥ç€æ‰§è¡Œ execve()ï¼Œæˆ‘ä»¬çš„ fork() æ˜¯ copy-on-write çš„ï¼Œå¦‚æœå…ˆæ‰§è¡Œå­è¿›ç¨‹ï¼Œæœ‰å¾ˆå¤§æ¦‚ç‡ execve() ä¼šé”€æ¯åŸå…ˆçš„é¡µè¡¨ï¼Œè¿™æ ·çˆ¶è¿›ç¨‹æ‰§è¡Œæ—¶å°±ä¸éœ€è¦é¢å¤–çš„å¤åˆ¶æ“ä½œï¼›ä½†å…ˆæ‰§è¡Œå­è¿›ç¨‹æ„å‘³ç€å½“å‰ CPU çš„ cache, TLB ç­‰éœ€è¦è¢«å…¨éƒ¨åˆ·æ–°ï¼Œè¿™åˆä¼šæœ‰ä¸€ä¸ªç«‹å³å¯è§çš„é¢å¤–ä»£ä»·ã€‚\né™¤äº† parent/child first é—®é¢˜ï¼Œå¦ä¸€ä¸ªé—®é¢˜æ˜¯ï¼šæˆ‘ä»¬çš„ CFS åº”è¯¥ä¸ºè¿™ä¸ªæ–°è¿›ç¨‹åˆ›å»ºæ€æ ·çš„ vruntime? æ—©æœŸçš„ç‰ˆæœ¬ä¼šç»™å­è¿›ç¨‹è¾ƒå°‘çš„ vruntimeï¼Œä¹Ÿå°±æ˜¯è®©å®ƒæœ‰æœºä¼šç¨å¾®å¤šæ‰§è¡Œä¸€ç‚¹ã€‚ä½†è¿™ä¸ªç­–ç•¥å¯¼è‡´æ¶æ„ç¨‹åºå¯ä»¥ç–¯ç‹‚ fork å­è¿›ç¨‹æ¥å æ® CPUï¼Œå› æ­¤ç°åœ¨çš„å†…æ ¸ä»£ç ä¸­å­è¿›ç¨‹ç»§æ‰¿çˆ¶è¿›ç¨‹çš„ vruntimeã€‚\n// linux kernel static void task_fork_fair(struct task_struct *p) { ... if (curr) { update_curr(cfs_rq); se-\u0026gt;vruntime = curr-\u0026gt;vruntime; // \u0026lt;------------ here } } CFS Complexity: I/O è€ƒè™‘å¦‚ä¸‹åœºæ™¯ï¼šæœ‰ä¸€ä¸ªè¿›ç¨‹ç­‰å¾…äº† 1min çš„ I/O æ“ä½œï¼Œè¿™æ®µæ—¶é—´å†…å®ƒä¸€ç›´å¤„äº blocked çš„çŠ¶æ€ï¼Œä¸ä¼šè¢«è°ƒåº¦ä¸Š CPUã€‚é‚£ä¹ˆ I/O æ“ä½œç»“æŸåï¼Œè¯¥è¿›ç¨‹çš„ vruntime ä¼šæ˜¾è‘—ä½äºåˆ«çš„è¿›ç¨‹ã€‚ä»è€Œæœªæ¥çš„ç›¸å½“é•¿æ—¶é—´å†… CPU ä¼šè¢«è¿™ä¸ª I/O è¿›ç¨‹ç‹¬å ï¼Œè¿™æ˜¾ç„¶ä¸æ˜¯æˆ‘ä»¬æƒ³çœ‹åˆ°çš„æƒ…å†µã€‚\næ“ä½œç³»ç»Ÿç†åº”åœ¨ I/O è¿›ç¨‹ç»“æŸç­‰å¾…åå°†å…¶ vruntime è¡¥é½åˆ°ä¸€ä¸ªåŸºå‡†ç‚¹ï¼Œè¿™ä¸ªåŸºå‡†ç‚¹åˆ°åœ°è®¾ç½®åœ¨å“ªé‡Œåˆæ˜¯å¾ˆæœ‰è®²ç©¶çš„äº‹ã€‚\nCFS Complexity: Integer Overflow åœ¨ä¸€ä¸ªéœ€è¦é•¿æ—¶é—´è¿è¡Œçš„ç³»ç»Ÿä¸­ï¼Œæˆ‘ä»¬å³ä½¿ç”¨ uint64_t æ¥å­˜å‚¨ vruntime ä¹Ÿè¦é¢ä¸´æº¢å‡ºçš„é—®é¢˜ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬ä¸èƒ½ç”¨ vruntime çš„ç»å¯¹å¤§å°æ¥æ¯”è¾ƒä¸¤ä¸ªè¿›ç¨‹çš„ä¼˜å…ˆçº§ã€‚\nLinux ä¸­é‡‡å–çš„è§£å†³æ–¹æ¡ˆæ˜¯ï¼šä¿è¯ä»»æ„æ—¶åˆ»ç³»ç»Ÿä¸­æœ€å¤§çš„ vruntime å’Œ æœ€å°çš„ vruntime ä¹‹å·®ä¸è¶…è¿‡æ•°è½´çš„ä¸€åŠ (i.e. UINT64_MAX / 2 )ã€‚è¿™æ ·æˆ‘ä»¬å¯ä»¥ç”¨æ¯”è¾ƒç›¸å¯¹å¤§å°çš„æ–¹å¼æ¥è§£å†³é—®é¢˜ï¼š\n// linux kernel bool less(uint64_t a, uint64_t b) { return (int64_t)(a - b) \u0026lt; 0; } æˆ‘ä»¬å¯ä»¥è€ƒè™‘ä¸€ä¸‹ a æ˜¯å¾ˆå°çš„æ­£æ•° (æº¢å‡ºäº†ä¸€è½®)ï¼Œb æ˜¯å¾ˆå¤§çš„æ­£æ•° (è¿˜æ²¡æº¢å‡º) çš„æƒ…å†µï¼Œæ­¤æ—¶åº”æœ‰ $a\u0026gt;b$ã€‚$a-b$ çš„ç»“æœæ˜¯å°äº 0 çš„ï¼Œä½†ç”±äºè¿™ä¸ªå€¼å¤§äº INT64_MAXï¼Œæ‰€ä»¥å¼ºåˆ¶è½¬æ¢æˆ int64_t åä¼šä¸‹æº¢å‡ºå˜æˆæ­£çš„ï¼Œä»è€Œæ­£ç¡®å®ç°åŠŸèƒ½ (éå¸¸ tricky çš„ä»£ç )ã€‚\nCFS Complexity: Implementation æˆ‘ä»¬è¦å®ç°ä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œæ”¯æŒé«˜æ•ˆçš„æ’å…¥ã€åˆ é™¤ã€æ‰¾æœ€å°å€¼ç­‰ã€‚Linux é‡‡å–äº†ä¸»æµçš„çº¢é»‘æ ‘è®¾è®¡ï¼Œä½†æˆ‘ä»¬çš„æ•°æ®ç»“æ„è¦ä¿è¯å¹¶è¡ŒçŠ¶æ€ä¸‹çš„æ­£ç¡®æ€§ï¼Œä¸ºäº†æ•ˆç‡è¿˜ä¸èƒ½ä¸Šå¤§é”â€¦â€¦\nThe First Bug on Mars åœ¨å®æ—¶æ“ä½œç³»ç»Ÿä¸­ï¼Œé«˜ä¼˜å…ˆçº§æ„å‘³ç€å¿…é¡»å…ˆè¢«è°ƒåº¦ã€‚ç®€å•çš„è°ƒåº¦å¤„ç†å¯èƒ½ä¼šå‡ºç°ä¼˜å…ˆçº§åè½¬çš„æƒ…å†µï¼š\nvoid high() {sleep(1); mutex_lock();} void medium() {while (1);} void low() {mutex_lock();} å‡è®¾ä½ä¼˜å…ˆçº§è¿›ç¨‹å…ˆæ‰§è¡Œï¼Œè·å¾—äº†é”ï¼›ç„¶å medium() åˆ°æ¥ï¼Œå°† low() è¸¢å‡º CPUï¼Œlow() å¸¦ç€é”è¿›å…¥äº†ç¡çœ ï¼›è¿™æ—¶ high() æ¥äº†ä½†å‘ç°æ— æ³•è·å¾—é”â€”â€”å› ä¸ºé”åœ¨ low() æ‰‹é‡Œã€‚high() å› ä¸ºé”çš„è¯­ä¹‰ç­‰å¾… low() æ˜¯å¯ä»¥æ¥å—çš„ (é”å¯èƒ½å¾ˆå¿«å°±è¢«é‡Šæ”¾)ï¼Œä½† low() åœ¨ç­‰å¾… medium()ï¼Œè¿™å¯¼è‡´ high() é—´æ¥ç­‰å¾…äº†ä¸€ä¸ªä¸è‡ªå·±æ¯«æ— å…³ç³»çš„è¿›ç¨‹ medium()ï¼Œè¿™æ˜¯ä¸å¯æ¥å—çš„ã€‚\nè¿™ä¸ª bug åœ¨ç¬¬ä¸€è¾†ç«æ˜Ÿè½¦ä¸ŠçœŸå®åœ°å‘ç”Ÿè¿‡ï¼Œè¿™å¯¼è‡´äº†ç«æ˜Ÿè½¦ç³»ç»Ÿçš„é‡å¯ã€‚è§£å†³ä¼˜å…ˆçº§åè½¬åœ°æ–¹æ³•é€šå¸¸æœ‰ä¼˜å…ˆçº§ç»§æ‰¿ (priority inheritance)/ä¼˜å…ˆçº§æå‡ (priority ceiling)ï¼Œç®€å•æ¥è¯´ï¼Œå½“ high() å› ä¸ºé”èµ„æºç­‰å¾…æ—¶ï¼Œlow() çš„ä¼˜å…ˆçº§å¯ä»¥æš‚æ—¶æå‡åˆ°å’Œ high() ä¸€æ ·é«˜ï¼Œè¿™æ ·å¾ˆå¿« low() å°±å¯ä»¥æŠŠ medium() è¸¢ä¸‹ CPU è¿è¡Œï¼Œé‡Šæ”¾äº†é” high() å°±å¯ä»¥æ­£å¸¸æ‰§è¡Œäº†ï¼Œlow() çš„ä¼˜å…ˆçº§ä¹Ÿæ¢å¤æœ€ä½ã€‚\nMulti-core Scheduling å¤šæ ¸å¤„ç†å™¨ä¸Šçš„è°ƒåº¦å¤„äºä¸€ä¸ªä¸¤éš¾çš„å¢ƒåœ°ï¼š\nå¦‚æœç®€å•åœ°å°†çº¿ç¨‹åˆ†é…åˆ°å¤„ç†å™¨ï¼Œé‚£ä¹ˆå®¹æ˜“å‡ºç°â€œä¸€æ ¸æœ‰éš¾ä»–æ ¸å›´è§‚â€çš„å±€é¢ã€‚ å¦‚æœç®€å•åœ°å°†çº¿ç¨‹å®‰æ’åˆ°ä¸€ä¸ªç©ºé—²å¤„ç†å™¨ä¸Šï¼Œé‚£ä¹ˆä¹‹å‰çš„ cache/TLB å°±å…¨éƒ¨ç™½ç»™äº†ã€‚ Complexity: Multi-user å‡è®¾ç”¨æˆ· A å’Œ B å…±ç”¨ä¸€å°æœåŠ¡å™¨ï¼ŒA çš„ç¨‹åºåªèƒ½å•çº¿ç¨‹ï¼Œè€Œ B çš„ç¨‹åºå¯ä»¥ 1000 ä¸ªçº¿ç¨‹ï¼Œé‚£å°±ä¼šå‡ºç° A åªè·å¾—äº†å¾ˆå°‘çš„èµ„æºçš„æƒ…å†µã€‚ç³Ÿç³•çš„æ˜¯ï¼ŒA ä¸èƒ½é€šè¿‡æé«˜è‡ªå·±çº¿ç¨‹çš„ä¼˜å…ˆçº§çš„æ–¹æ³•æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼šåœ¨ Linux ä¸­ï¼Œéç‰¹æƒç”¨æˆ·åªèƒ½æå‡è‡ªå·±çš„ nice å€¼ï¼Œä¸èƒ½é™ä½ã€‚\nLinux é‡‡ç”¨çš„è§£å†³æ–¹æ¡ˆæ˜¯ namespaces control groupsï¼Œå¤§è‡´æ€æƒ³æ˜¯åˆ›å»ºäº†â€œæ“ä½œç³»ç»Ÿä¸­çš„æ“ä½œç³»ç»Ÿâ€ï¼Œå°†å±äºä¸€ä¸ªç”¨æˆ·çš„è¿›ç¨‹å½’æˆä¸€ç»„ç®¡ç†ã€‚\nComplexity: Big.LITTLE and Energy Consumption ç°åœ¨çš„ CPU æœ‰å¤§å°æ ¸çš„æ¦‚å¿µï¼šå¤§æ ¸é¢‘ç‡é«˜ï¼Œå°æ ¸é¢‘ç‡å°ï¼Œæˆ‘ä»¬åœ¨è°ƒåº¦çš„æ—¶å€™ä¸å¾—ä¸å°†è¿™äº›å› ç´ è€ƒè™‘è¿›æ¥ã€‚æ­¤å¤–ï¼Œç°åœ¨çš„è½¯ä»¶å¯ä»¥é…ç½® CPU çš„å·¥ä½œæ¨¡å¼ï¼šCPU çš„é¢‘ç‡è¶Šä½ï¼Œå®ƒçš„å»¶è¿Ÿè¶Šé«˜ï¼Œä½†èƒ½è€—è¶Šå°ï¼Œååé‡è¶Šé«˜ã€‚é‚£ä¹ˆå¦‚ä½•æ ¹æ®ä¸åŒç±»å‹çš„ä»»åŠ¡è°ƒæ•´ CPU å·¥ä½œæ¨¡å¼ä»¥åŠè°ƒåº¦ä¹Ÿæ˜¯éå¸¸å¤æ‚çš„é—®é¢˜ã€‚\nComplexity: Non-Uniform Memory Access å…±äº«å†…å­˜åœ¨æŸç§ç¨‹åº¦ä¸Šåªæ˜¯ä¸€ä¸ªå‡è±¡ã€‚L1 Cache èŠ±äº†å·¨å¤§çš„ä»£ä»·æ‰è®©å„ä¸ª CPU çœ‹åˆ°äº†å…±äº«çš„å†…å­˜ã€‚å¤šä¸ªçº¿ç¨‹åœ¨åŒä¸€ä¸ª/ä¸åŒçš„æ ¸ä¸Šè·‘ï¼Œæ•ˆç‡å¯èƒ½æœ‰å¾ˆå¤§çš„åŒºåˆ«ã€‚\nåœ¨å®é™…æƒ…å†µä¸‹ï¼Œè¿â€æ ¸å¿ƒè¶Šå¤šï¼Œé€Ÿåº¦è¶Šå¿«â€çš„å‡è®¾éƒ½å¯èƒ½æ˜¯é”™çš„ã€‚ä»¥ sum-atomic.c ä¸ºä¾‹ï¼Œå¦‚æœæˆ‘ä»¬ç”¨å‘½ä»¤\ntastset -c 0 ./sum-atomic æ¥è®© sum-atomic.c çš„æ‰€æœ‰çº¿ç¨‹åªå·¥ä½œåœ¨ä¸€ä¸ªæ ¸ä¸Šï¼Œä¼šå‘ç°è¿è¡Œæ—¶é—´ç«Ÿå°äºå¤šä¸ªæ ¸ï¼è°ƒåº¦å™¨æŠŠç¨‹åºå½“ä½œé»‘ç›’çš„å‡è®¾å¯èƒ½æ˜¯ä¸å¯¹çš„ã€‚\nComplexity: CPU Hot-plug ç°åœ¨çš„ CPU æ”¯æŒçƒ­æ’æ‹”ï¼Œå¯èƒ½è¿è¡Œä¸€ä¼šå„¿ä¼šå‘ç°å¤šäº†ä¸€ä¸ªæˆ–è€…å°‘äº†ä¸€ä¸ªâ€¦â€¦\nè°ƒåº¦æ˜¯ä¸€ä¸ªéå¸¸å¤æ‚çš„é—®é¢˜ï¼Œå°†è¿™ä¸ªä»»åŠ¡å®Œå…¨ä¸¢ç»™æ“ä½œç³»ç»Ÿçš„è°ƒåº¦å™¨æ˜¯ä¸åˆç†çš„ã€‚ä¸€ç§å¯èƒ½çš„æƒ³æ³•æ˜¯ï¼šè®©ç¨‹åºæä¾›ä¸€äº› scheduling hints æ¥æŒ‡å¯¼è°ƒåº¦è¡Œä¸ºã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"358a5a40daafd9fff68e94e9f523ec03","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec20/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec20/","section":"notes","summary":"å¤„ç†å™¨è°ƒåº¦é—®é¢˜çš„ç®€å•å‡è®¾ (1960s)ï¼š\nç³»ç»Ÿä¸­æœ‰ä¸€ä¸ªå¤„ç†å™¨ ç³»ç»Ÿä¸­æœ‰å¤šä¸ªè¿›ç¨‹/çº¿ç¨‹å…±äº« CPU åŒ…æ‹¬ç³»ç»Ÿè°ƒç”¨ (è¿›ç¨‹/çº¿ç¨‹çš„ä¸€éƒ¨åˆ†åœ¨å†…æ ¸ä»£ç ä¸­) å¶å°”ä¼šç­‰å¾… I/O è¿”å›ï¼Œä¸ä½¿ç”¨ CPUã€‚ Policy Round-Robin æŒ‰ç…§æ—¶é—´ç‰‡è½®è½¬ï¼Œè½®æµè¿è¡Œæ‰€æœ‰çš„è¿›ç¨‹/çº¿ç¨‹ã€‚\né—®é¢˜ï¼šå‡è®¾å½“å‰æœ‰ä¸€ä¸ªå‰å°çš„ vim è¿›ç¨‹å’Œå¾ˆå¤šè®¡ç®—å‹çš„åå°è¿›ç¨‹ï¼Œå¦‚æœä½¿ç”¨ round robinï¼Œå¾ˆå®¹æ˜“å‡ºç°å‰å° vim è¿›ç¨‹å¾ˆå¡çš„ç°è±¡ (vim è¿›ç¨‹ä¸€æ—¦è¢«åˆ‡å‡ºå»äº†ï¼Œå°±è¦ç­‰ä¸€æ•´è½®æ‰èƒ½è·å¾—ä¸€ä¸ªæ—¶é—´ç‰‡)ã€‚\næˆ‘ä»¬å¸Œæœ›å¼•å…¥æŸç§â€œä¼˜å…ˆçº§â€ï¼Œä½¿å¾—å’Œç”¨æˆ·äº¤äº’æ¯”è¾ƒé¢‘ç¹çš„å‰å°è¿›ç¨‹å¯ä»¥è·å¾—æ›´é«˜çš„è°ƒåº¦ä¼˜å…ˆçº§ï¼Œä¼˜åŒ–ç”¨æˆ·çš„ä½¿ç”¨ä½“éªŒã€‚\nUNIX Niceness UNIX çš„ niceness æ˜¯ä¸€ä¸ª -20 .","tags":null,"title":"Lecture 20: Scheduling","type":"docs"},{"authors":null,"categories":null,"content":"æ“ä½œç³»ç»Ÿçš„è®¾è®¡ï¼šä¸€ç»„å¯¹è±¡+è®¿é—®å¯¹è±¡çš„ APIï¼›æ“ä½œç³»ç»Ÿçš„å®ç°ï¼šä¸€ä¸ª C ç¨‹åºå®Œæˆä¸Šé¢çš„è®¾è®¡\næˆ‘ä»¬å…³å¿ƒçš„é—®é¢˜æ˜¯ï¼šæ“ä½œç³»ç»Ÿåˆ°åº•åº”è¯¥æä¾›ä»€ä¹ˆæ ·çš„å¯¹è±¡å’Œ APIï¼Ÿ\nMonolithic Kernel Unix ç³»åˆ—ï¼š The Open Group Base Specifications Issue 7 (2018 Ed.)\nWindows ç³»åˆ—ï¼š Windows API Index\nä¸åŒçš„ API ç³»åˆ—å¯ä»¥äº’ç›¸æ¨¡æ‹Ÿï¼Œäºæ˜¯æœ‰äº† WSL å’Œ WINEã€‚\nReal Operating Systems\nçœŸæ­£çš„æ“ä½œç³»ç»Ÿè¦è€ƒè™‘çš„äº‹æƒ…æ€»æ˜¯æ¯”æƒ³è±¡ä¸­çš„å¤æ‚ã€‚æ¯”å¦‚æˆ‘ä»¬å†™ä¸€ä¸ªç®€å•çš„é‡å‘½åå‡½æ•°ï¼š\nvoid rename_file(char *oldname, char *newname) { char buf[SIZE]; int fd = open(oldname, O_RONLY); fread(fd, buf); close(fd); delete(oldname); // \u0026lt;------------------ fd = open(newname, O_CREAT | O_TRUNC | O_WONLY); write(fd, buf, sizeof(buf)); } å¦‚æœåœ¨ç®­å¤´æŒ‡å‘çš„æ—¶åˆ»æ“ä½œç³»ç»Ÿçªç„¶æ‰ç”µäº†ï¼Œé‚£ä¹ˆæ–‡ä»¶å†…å®¹å°±å…¨éƒ¨ä¸¢å¤±äº†ï¼è¿™æ˜¾ç„¶æ˜¯ä¸åˆç†çš„ç°è±¡ã€‚é˜…è¯» rename() ç³»ç»Ÿè°ƒç”¨çš„æ‰‹å†Œï¼Œå¯ä»¥çœ‹åˆ°æ‰‹å†Œä¿è¯äº†åˆ é™¤æ—§æ–‡ä»¶ï¼Œåˆ›å»ºæ–°æ–‡ä»¶æ“ä½œçš„åŸå­æ€§ã€‚\nMicrokernel å¤æ‚ç³»ç»Ÿçš„æ­£ç¡®æ€§éš¾ä»¥ä¿è¯ã€‚åƒ Linux è¿™æ ·ä»¥ C ä¸ºä¸»è¦è¯­è¨€çš„æ“ä½œç³»ç»Ÿï¼ŒC çš„ undefined behavior ä¼šç»™ç³»ç»Ÿå¸¦æ¥æ— ç©·çš„ç¾éš¾ï¼šæ¯”å¦‚æ–‡ä»¶ç³»ç»Ÿä¸€æ—¦å‡ºé”™ï¼Œæ•´ä¸ªå†…æ ¸ä¸­çš„ä»»ä½•æ¨¡å—éƒ½å¯èƒ½å—åˆ°æŸåã€‚\nå¾®å†…æ ¸çš„æƒ³æ³•æ˜¯ï¼šå°†å°½å¯èƒ½å¤šçš„åŠŸèƒ½ç”¨æ™®é€šè¿›ç¨‹å®ç°ï¼Œå°†é—®é¢˜éš”ç¦»åœ¨è¿›ç¨‹çº§ã€‚æ¯”å¦‚æ–‡ä»¶æ“ä½œï¼ŒUNIX çš„ write() ä¼šé™·å…¥å†…æ ¸ï¼Œä½†å¦ä¸€ç§æƒ³æ³•æ˜¯ï¼šè°ƒç”¨ä¸€ä¸ª remote_write() å’Œä¸€ä¸ª File server äº¤äº’ï¼ŒFSè¿›ç¨‹æœ‰è®¿é—®ç£ç›˜çš„æƒé™å³å¯ã€‚\nä¸€äº›å¥½çš„æƒ³æ³•ï¼š\nä¸€äº›å’ŒçŠ¶æ€æœºç®¡ç†å¯†åˆ‡ç›¸å…³çš„ç³»ç»Ÿè°ƒç”¨æ²¡æ³•è¢«æ¬å‡ºå†…æ ¸ï¼šæ¯”å¦‚ fork(), mmap()ã€‚ å¦‚æœæ“ä½œç³»ç»Ÿæä¾›ä¸€ä¸ª mmio() ç³»ç»Ÿè°ƒç”¨ï¼Œè®©è¿›ç¨‹é€šè¿‡è®¿é—®å†…å­˜çš„æ–¹å¼æ¥æ§åˆ¶è®¾å¤‡å¯„å­˜å™¨ã€ç£ç›˜ etcï¼Œé‚£ä¹ˆè®¾å¤‡é©±åŠ¨ä»£ç ï¼Œæ–‡ä»¶ç³»ç»Ÿä»£ç éƒ½å¯ä»¥æ”¾åœ¨ç”¨æˆ·æ€ã€‚ èµ‹äºˆè¿›ç¨‹æœ€å°‘çš„æƒé™ï¼Œå°±èƒ½é™ä½é”™è¯¯å¸¦æ¥çš„å½±å“ã€‚\nMinix Minix æ˜¯ä¸€ä¸ªå…·æœ‰è·¨æ—¶ä»£æ„ä¹‰çš„æ•™å­¦æ“ä½œç³»ç»Ÿï¼Œå®ƒé‡‡å–çš„æ˜¯å¾®å†…æ ¸è®¾è®¡ã€‚åœ¨ Minix 2.0 ä¸­ï¼Œå†…æ ¸åªæä¾›äº†ä¸¤ä¸ª APIï¼šsend å’Œ receiveã€‚åŸºäºè¿™ä¸¤ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œæˆ‘ä»¬å®ç°ä¸€äº› RPC (remote procedure call) æ¥å®ç°è¿›ç¨‹ä¹‹é—´çš„é€šä¿¡ã€‚Kernel é‡Œåªæœ‰å¾ˆå°‘çš„çŠ¶æ€æœºç›¸å…³çš„æœºåˆ¶ï¼šæ¯”å¦‚ä¸­æ–­ï¼Œå¼‚å¸¸ï¼Œæ—¶é’Ÿé©±åŠ¨ï¼Œå†…å­˜æ˜ å°„ etc. å…¶ä»–çš„åŠŸèƒ½ï¼Œæ¯”å¦‚æ–‡ä»¶ç³»ç»Ÿï¼Œè®¾å¤‡é©±åŠ¨ï¼Œç½‘ç»œ etc. éƒ½åœ¨ç”¨æˆ·æ€ã€‚è·¨æ¨¡å—çš„è°ƒç”¨ä¼šè·¨è¶Šè¿›ç¨‹è¾¹ç•Œ i.e. åœ°å€ç©ºé—´çš„åˆ‡æ¢ç­‰ï¼Œè¿™æ ·ä¸€ä¸ªæ¨¡å—çš„é”™è¯¯å°±å¯ä»¥è¢«éš”ç¦»åœ¨æœ¬åœ°ï¼ŒUB ä¸ä¼šæ³¢åŠåˆ°æ¨¡å—å¤–éƒ¨ã€‚\nseL4 seL4 æ˜¯ç¬¬ä¸€ä¸ªå®Œæˆäº†æ­£ç¡®æ€§è¯æ˜ã€è¿è¡Œæ—¶é—´ä¸Šç•Œè¯æ˜çš„å¾®å†…æ ¸ã€‚\nseL4 çš„è¯æ˜æ€è·¯å¤§è‡´å¦‚ä¸‹ï¼šä»¥ thread-os.c çš„ round-robin è°ƒåº¦å™¨ä¸ºä¾‹ï¼Œé¦–å…ˆæˆ‘ä»¬ç”¨é€‚åˆæè¿°è¡Œä¸ºçš„è¯­è¨€å»ºç«‹ä¸€ä¸ªæ¨¡å‹ (è¿™é‡Œä»¥ python ä¸ºä¾‹, seL4 åœ¨è¿™é‡Œå®é™…ä¸Šæœ‰ä¸¤å±‚å»ºæ¨¡)ï¼š\ndef rr_sched(cpu): cpu.threads = cpu.threads[1:] + cpu.threads[:1] assert anything_you_need return cpu.threads[0] æˆ‘ä»¬å¯ä»¥ç”¨ model checker ç¡®è®¤è¿™ä¸ª high level è¯­è¨€ç¼–å†™çš„ç¨‹åºçš„æ­£ç¡®æ€§ï¼Œç„¶åæˆ‘ä»¬å¸Œæœ›è¯æ˜ thread-os.c å’Œ python ä»£ç çš„è¡Œä¸ºç­‰ä»·æ€§ã€‚é™¤å»è®¿é—®ç¡¬ä»¶çš„éƒ¨åˆ† (AbstractMachine)ï¼Œæ“ä½œç³»ç»Ÿæœ¬è´¨ä¸Šæ˜¯çº¯è®¡ç®—çš„ç¨‹åº (æ•°å­¦æ¨¡å‹)ï¼Œå› æ­¤æˆ‘ä»¬åªéœ€è¦è§‚æµ‹æ‰€æœ‰çš„ AM call è¡Œä¸ºæ˜¯å¦ç­‰ä»·å³å¯ã€‚å¦‚æœæˆ‘ä»¬ä½¿ç”¨è¢« verified çš„ç¼–è¯‘å™¨ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥è¿›ä¸€æ­¥è¯æ˜ C ç¨‹åºå’Œæ±‡ç¼–æŒ‡ä»¤çš„ç­‰ä»·æ€§ã€‚\nUniKernel å¾ˆæ—©çš„æ—¶å€™å°±æœ‰äº† exokernel (å¤–æ ¸) çš„æ¦‚å¿µï¼Œå³æ“ä½œç³»ç»Ÿä¸åº”è¯¥æœ‰ä»»ä½•çš„ç­–ç•¥ï¼Œåªéœ€è¦æä¾›æœ€å°çš„ç¡¬ä»¶æŠ½è±¡ã€‚åœ¨æœ‰äº†è™šæ‹Ÿæœºçš„æ—¶ä»£ï¼Œè¿™å‚¬ç”Ÿäº† unikernelï¼šå°†æ“ä½œç³»ç»Ÿçš„å†…æ ¸ä»£ç å’Œåº”ç”¨ç¨‹åºç›´æ¥é“¾æ¥èµ·æ¥è·‘ï¼Œå› ä¸ºç¡¬ä»¶éƒ½æ˜¯è™šæ‹ŸæœºæŠ½è±¡å‡ºæ¥çš„ï¼Œæ‰€ä»¥æ²¡æœ‰å®‰å…¨é—®é¢˜ã€‚è¿™æ—¶çš„ OS ç±»ä¼¼äºä¸€ä¸ª libOS çš„åŠŸèƒ½ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"ddcc9b19f3068105b2a2134ec8c32e06","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec21/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec21/","section":"notes","summary":"æ“ä½œç³»ç»Ÿçš„è®¾è®¡ï¼šä¸€ç»„å¯¹è±¡+è®¿é—®å¯¹è±¡çš„ APIï¼›æ“ä½œç³»ç»Ÿçš„å®ç°ï¼šä¸€ä¸ª C ç¨‹åºå®Œæˆä¸Šé¢çš„è®¾è®¡\næˆ‘ä»¬å…³å¿ƒçš„é—®é¢˜æ˜¯ï¼šæ“ä½œç³»ç»Ÿåˆ°åº•åº”è¯¥æä¾›ä»€ä¹ˆæ ·çš„å¯¹è±¡å’Œ APIï¼Ÿ\nMonolithic Kernel Unix ç³»åˆ—ï¼š The Open Group Base Specifications Issue 7 (2018 Ed.)\nWindows ç³»åˆ—ï¼š Windows API Index\nä¸åŒçš„ API ç³»åˆ—å¯ä»¥äº’ç›¸æ¨¡æ‹Ÿï¼Œäºæ˜¯æœ‰äº† WSL å’Œ WINEã€‚","tags":null,"title":"Lecture 21: OS Design","type":"docs"},{"authors":null,"categories":null,"content":"L1 ä¸€æŠŠå¤§é”ä¿å¹³å®‰ç­–ç•¥ï¼šå…¨å±€ç”¨ä¸€æŠŠé”ï¼ŒæŠŠæ‰€æœ‰éœ€è¦ä¿æŠ¤çš„ä»£ç éƒ½ç”¨ atomic {} æ¡†èµ·æ¥ã€‚\n#define atomic \\ for (int __i = (lock(), 0); i \u0026lt; 1; unlock(), __i++) è¿™ä¸ª for å¾ªç¯çš„è¯­ä¹‰å¦‚ä¸‹ï¼š\nlock(); __i = 0;\t// Cè¯­è¨€é€—å·è¡¨è¾¾å¼æ€»æ˜¯å–åé¢çš„å€¼ check i \u0026lt; 1 =\u0026gt; yes body __i++; unlock(); check i \u0026lt; 1 =\u0026gt; no, break ä½¿ç”¨è¿™ä¸ª atomic {} æˆ‘ä»¬è¦ä¿è¯ç¨‹åºä¸èƒ½åœ¨ atomic å†…éƒ¨ break æˆ– returnã€‚\nProgramming Philosophy\nåœ¨ä¹¦å†™ä¸æ˜¯ performance bottle neck çš„ä»£ç æ—¶ï¼Œæˆ‘ä»¬åº”è¯¥å°½å¯èƒ½å°†ä»£ç å†™å¾—ç®€å•ï¼Œå°½é‡ä¸è¦å†™å¥‡æŠ€æ·«å·§ï¼Œä»¥ç‰ºç‰²å¯è¯»æ€§ã€å¯ç»´æŠ¤æ€§ä¸ºä»£ä»·æ¢å–å¾®ä¸è¶³é“çš„æ€§èƒ½ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬åº”è¯¥åœ¨ç¨‹åºä¸­æ·»åŠ è¶³å¤Ÿçš„ assertion æ¥å°½æ—©æŠ“å–åˆ° bugã€‚\nL2 ä¸€ä¸ªå…è®¸åµŒå¥—çš„å¤§é”ï¼š\nint locked; void lock() { int c = cpu_current(); bool i = ienabled(); iset(false); nest[c]++; if (nest[c] == 1) { intena[c] = i; while (atomic_xchg(\u0026amp;locked, 1)); } } void unlock() { int c = cpu_current(); nest[c]--; if (nest[c] == 0) { atomic_xchg(\u0026amp;locked, 0); if (intena[c]) iset(true); } } Programming Philosophy\nåœ¨å†™ä»£ç çš„è¿‡ç¨‹ä¸­ï¼Œåœ¨ä¸€è¡Œé‡Œå†™å¾ˆå¤šè¡¨è¾¾å¼ï¼Œè®©ä¸€è¡Œå˜å¾—å¾ˆé•¿æ˜¯ä¸€ç§ bad practiceã€‚æˆ‘ä»¬å¯ä»¥é€‚æ—¶åœ°ç”¨ä¸€äº›ä¸´æ—¶å˜é‡ä¿å­˜ä¸€äº›å€¼ï¼Œè¿™æ ·å¯ä»¥å¤§å¹…æé«˜ä»£ç çš„å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚\nçº¿ç¨‹åˆ›å»ºï¼š\nstruct task { Context ctx[4]; int nc; int stk[STK_SZ]; }; struct percpu { struct task *avail[NPROC]; int n, c; }percpu[MAX_CPU]; struct task *kcreate(void *entry, void *arg, int cpu) { struct task *t = kalloc(sizeof(struct task)); atomic { t-\u0026gt;ctx[0] = *kcontext((Area){\u0026amp;t-\u0026gt;stk, \u0026amp;t-\u0026gt;stk + STK_SZ}, entry, arg); t-\u0026gt;nc = 1; percpu[cpu].avail[percpu[cpu].n++] = t; } return t; } ä¸€ä¸ªæœ€ç®€å•çš„ round-robin è°ƒåº¦å™¨ï¼šä¿å­˜å½“å‰çº¿ç¨‹çš„ä¸Šä¸‹æ–‡ï¼Œåˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªçº¿ç¨‹ï¼Œè¿”å›ç›®æ ‡çº¿ç¨‹çš„ä¸Šä¸‹æ–‡ã€‚\n#define CPU (\u0026amp;percpu[cpu_current()]) #define current (CPU-\u0026gt;avail[CPU-\u0026gt;c]) Context *trap(Event ev, Context *ctx) { current-\u0026gt;ctx[current-\u0026gt;nc++] = *ctx; atomic { CPU-\u0026gt;c = (CPU-\u0026gt;c + 1) % (CPU -\u0026gt; n); } assert(!ienabled()); return \u0026amp;(current-\u0026gt;ctx[--current.nc]); } ä¿¡å·é‡æœ€ç®€å•çš„è¯­ä¹‰å°±æ˜¯ï¼šåœ¨æ²¡æœ‰èµ„æºçš„æ—¶å€™ yield()ã€‚\nstruct semaphore { int count; } void sem_wait(sem_t *sem) { bool succ = false; while (!succ) { atomic { if (sem-\u0026gt;count \u0026gt; 0) { sem-\u0026gt;count--; succ = true; } } if (!succ) yield(); } } void sem_post(sem_t *sem) { atomic { sem-\u0026gt;count++; } } Programming Philosophy\nä¸Šè¿°çš„ä¿¡å·é‡å®ç°æ˜¯ä¸€ä¸ªæ¯”è¾ƒåŸºç¡€çš„å®ç°ã€‚ä¸€ä¸ªæ€§èƒ½æ›´å¥½çš„å®ç°æ˜¯è°ƒç”¨ sleep()ï¼Œå½“å‰æ¡ä»¶ä¸æ»¡è¶³çš„è¯å°±é‡Šæ”¾è‡ªæ—‹é”å¹¶å°†è‡ªå·±åŠ å…¥ä¸€ä¸ªç­‰å¾…é˜Ÿåˆ—ï¼Œä½†è¿™ç§å®ç°å°±ä¼šå¼•å…¥æ›´å¤šå¯èƒ½é”™è¯¯çš„ç‚¹ã€‚äº‹å®ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥ä¸ºå„ä¸ªæ¨¡å—éƒ½å‡†å¤‡ä¸€ä»½ functional çš„ä»£ç  (éå¸¸ç®€å•ï¼Œä¿è¯æ­£ç¡®ï¼Œç±»ä¼¼äºæ¨¡å‹) å’Œä¸€ä»½æ³¨é‡æ€§èƒ½çš„ä»£ç ã€‚å½“é¡¹ç›®å‡ºç° bug çš„æ—¶å€™ï¼Œæˆ‘ä»¬å°±å°†ä¸€ä¸ªä¸€ä¸ªæ¨¡å—æ¢å› dummy çš„å®ç°ï¼Œä»è€Œå¿«é€Ÿå®šä½é—®é¢˜ã€‚\nL3 ucreate å’Œ kcreate ç»“æ„å·®ä¸å¤šï¼Œè¿™æ¬¡æˆ‘ä»¬ä½¿ç”¨ ucontext åˆ›å»ºåˆå§‹ä¸Šä¸‹æ–‡ã€‚æˆ‘ä»¬å‡è®¾ä»£ç æ®µæ€»æ˜¯è¢«åŠ è½½åˆ°åœ°å€ç©ºé—´çš„å¼€å¤´ã€‚æ­¤å¤–ï¼Œç°åœ¨ task ç»“æ„ä½“ä¸­è¿˜éœ€è¦åŠ å…¥ä¸€ä¸ªåœ°å€ç©ºé—´ AddrSpace asã€‚\ntask_t *ucreate(int cpu) { task_t *t = kalloc(sizeof(task_t)); atomic { protect(\u0026amp;t-\u0026gt;as); t-\u0026gt;ctx[0] = *ucontext(\u0026amp;t-\u0026gt;as, (Area){\u0026amp;(t-\u0026gt;stk), \u0026amp;(t-\u0026gt;stk)+STK_SIZE}, \u0026amp;t-\u0026gt;as); t-\u0026gt;nc = 1; percpu[cpu].avail[percpu[cpu].n++] = t; } return t; } åœ¨ os_trap ä¸­ï¼Œæˆ‘ä»¬è¦æ£€æŸ¥æ›´å¤šçš„äº‹ä»¶ï¼Œä¾‹å¦‚ page faultï¼Œsyscall ç­‰ï¼š\nswitch (ev.event) { case EVENT_PAGEFAULT: { pagefault(ev, ctx); break; } case EVENT_SYSCALL: { assert(current-\u0026gt;nc == 1); current-\u0026gt;ctx[0].GPRx = syscall(ctx); break; } case EVENT_ERROR: { panic(); break; } default: break; } ç¼ºé¡µå¼‚å¸¸æˆ‘ä»¬çš„å¤„ç†æ˜¯åœ¨è™šæ‹Ÿåœ°å€ç©ºé—´ä¸­ä¸ºå½“å‰è™šæ‹Ÿåœ°å€æ˜ å°„ä¸€ä¸ªç‰©ç†é¡µé¢ã€‚æ­¤å¤–å¦‚æœç¼ºå°‘çš„æ˜¯ç¬¬ä¸€ä¸ªé¡µé¢ (å³ init è¿›ç¨‹çš„ä»£ç æ®µ) æˆ‘ä»¬è¦æŠŠä»£ç æ®µæ‹·è´è¿›æ¥ã€‚\nvoid pgmap(task_t *t, void *va, void *pa) { t-\u0026gt;va[t-\u0026gt;np] = va; t-\u0026gt;pa[t-\u0026gt;np] = pa; t-\u0026gt;np++; map(\u0026amp;t-\u0026gt;as, va, pa, MMAP_READ | MMAP_WRITE); } void pagefault(Event e, Context *c) { atomic { AddrSpace *as = \u0026amp;(current-\u0026gt;as); void *pa = kalloc(as-\u0026gt;pgsize); void *va = (void *)(e.ref \u0026amp; ~(as-\u0026gt;pgsize - 1L)); if (va == as-\u0026gt;area.start) memcpy(pa, _init, _init_len); pgmap(current, va, pa); } } å¤„ç†å„ç§ç³»ç»Ÿè°ƒç”¨ï¼š\nint syscall(Context *c) { int ret = 0; ise(true); switch (c-\u0026gt;GPRx) { case SYS_kputc: { putch(c-\u0026gt;GPR1); break; } case SYS_sleep: { uint64_t wakeup = io_read(AM_TIMER_UPTIME).us + 1000000L * c-\u0026gt;GPR1; while (io_read(AM_TIMER_UPTIME).us \u0026lt; wakeup) yield(); } case SYS_fork: { atomic { struct task *t = ucreate(cpu_current()); uintptr_t rsp0 = t-\u0026gt;ctx[0].rsp0; void *cr3 = t-\u0026gt;ctx[0].cr3; t-\u0026gt;ctx[0] = *c; t-\u0026gt;ctx[0].rsp0 = rsp0; t-\u0026gt;ctx[0].cr3 = cr3;\t// å­è¿›ç¨‹çš„é¡µè¡¨å’Œå†…æ ¸æ ˆä¸èƒ½å¤åˆ¶çˆ¶è¿›ç¨‹ t-\u0026gt;ctx[0].GPRx = 0;\t// å­è¿›ç¨‹çš„è¿”å›å€¼åº”è¯¥æ˜¯0 for (int i = 0; i \u0026lt; current-\u0026gt;np; i++) { int sz = current-\u0026gt;as.pgsize; void *va = current-\u0026gt;va[i]; void *pa = current-\u0026gt;pa[i]; void *npa = kalloc(sz); memcpy(npa, pa, sz); pgmap(t, va, npa); } } } } iset(false); } ","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"adb680e2242ace1af1c89d623ee0d140","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec22/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec22/","section":"notes","summary":"L1 ä¸€æŠŠå¤§é”ä¿å¹³å®‰ç­–ç•¥ï¼šå…¨å±€ç”¨ä¸€æŠŠé”ï¼ŒæŠŠæ‰€æœ‰éœ€è¦ä¿æŠ¤çš„ä»£ç éƒ½ç”¨ atomic {} æ¡†èµ·æ¥ã€‚\n#define atomic \\ for (int __i = (lock(), 0); i \u0026lt; 1; unlock(), __i++) è¿™ä¸ª for å¾ªç¯çš„è¯­ä¹‰å¦‚ä¸‹ï¼š\nlock(); __i = 0;\t// Cè¯­è¨€é€—å·è¡¨è¾¾å¼æ€»æ˜¯å–åé¢çš„å€¼ check i \u0026lt; 1 =\u0026gt; yes body __i++; unlock(); check i \u0026lt; 1 =\u0026gt; no, break ä½¿ç”¨è¿™ä¸ª atomic {} æˆ‘ä»¬è¦ä¿è¯ç¨‹åºä¸èƒ½åœ¨ atomic å†…éƒ¨ break æˆ– returnã€‚","tags":null,"title":"Lecture 22: OSLab Speedrun","type":"docs"},{"authors":null,"categories":null,"content":"æœºå™¨æŒ‡ä»¤æ¨¡å‹åªæœ‰ä¸¤ç§å½“å‰çŠ¶æ€ï¼šå¯„å­˜å™¨å’Œç‰©ç†å†…å­˜ã€‚è¿™äº›çŠ¶æ€åœ¨ç‰©ç†ä¸–ç•Œä¸­åº”å½“æœ‰çœŸå®çš„å¯¹åº”ã€‚æˆ‘ä»¬çš„éœ€æ±‚æ˜¯ï¼š\nå¯ä»¥å¯»å€ï¼šæ¯”å¦‚å¯ä»¥æ ¹æ®ç¼–å·è®¿é—®æŸä¸ªå•å…ƒæ ¼ã€‚ è®¿é—®é€Ÿåº¦å°½å¯èƒ½å¿« (ç”šè‡³ä¸æƒœæ‰ç”µåä¸¢å¤±çŠ¶æ€)ã€‚ â€œå½“å‰çŠ¶æ€â€çš„å­˜å‚¨\nå»¶è¿Ÿçº¿ (delay line)ï¼šåƒä¸€æ ¹å­˜å‚¨äº†æ•°æ®çš„ç»³å­ä¸æ–­åœ°è½¬ï¼Œä¿¡å·ä¼šéšç€æ—¶é—´è¡°å‡ï¼Œå› æ­¤æ•°æ®ä¼šä¸æ–­é€šè¿‡æ”¾å¤§å™¨æ¥ä¿æŒä¸ä¸¢å¤±ã€‚\nç£èŠ¯å†…å­˜ (Magnetic core)ï¼šç±»ä¼¼äºä¸€ä¸ªäºŒç»´çš„å°ç£é“é˜µåˆ—ï¼Œå½“ç»™ç¬¬ $i$ è¡Œç¬¬ $j$ åˆ—åŠ ç”µæ—¶ï¼Œåæ ‡åœ¨ $(i,j)$ å¤„çš„å°ç£é“å°±æœ‰è¶³å¤Ÿå¤§çš„ç”µæµå¯ä»¥æ—‹è½¬ã€‚ç£èŠ¯å†…å­˜æ˜¯ non volatile memory - æ‰ç”µå core çš„ä¿¡æ¯æ˜¯ä¸ä¼šä¸¢å¤±çš„ã€‚ä½†ä¿¡æ¯çš„æ”¹å˜ä¾èµ–å°ç£é“è½¬åŠ¨è¿™ä¸€ç‰©ç†åŠ¨ä½œï¼Œå› æ­¤é€Ÿåº¦ä¸å¤Ÿé«˜ã€‚\n\u0026ldquo;Segmentation fault (core dumped)\u0026rdquo;\nè¿™é‡Œçš„â€œæ ¸å¿ƒå·²è½¬å‚¨â€çš„è¯´æ³•å°±æ˜¯æºè‡ªäºç£èŠ¯å†…å­˜ã€‚Linux ç³»ç»Ÿä¸­é»˜è®¤çš„ core file size æ˜¯ 0 (å¯ä»¥é€šè¿‡å‘½ä»¤ ulimit -a æŸ¥çœ‹)ï¼Œå¯ä»¥é€šè¿‡ ulimit -c size æ¥ä¿®æ”¹ã€‚\næ­¤å¤–ï¼Œåœ¨ Ubuntu ç³»ç»Ÿä¸­ï¼Œæˆ‘ä»¬è¿˜éœ€è¦åœ¨ root æƒé™ä¸‹é€šè¿‡\necho core \u0026gt; /proc/sys/kernel/core_pattern ä¿®æ”¹å¯¹åº”æ–‡ä»¶ã€‚è¿™æ ·å‘ç”Ÿæ®µé”™è¯¯åï¼Œç³»ç»Ÿå°†åœ¨ç¨‹åºå½“å‰ç›®å½•ä¸‹ç”Ÿæˆä¸€ä¸ª core æ–‡ä»¶ã€‚æˆ‘ä»¬å¯ä»¥ç”¨ segfault.c åšä¸€ä¸ªå®éªŒã€‚æ®µé”™è¯¯åï¼Œä½¿ç”¨ gdb segfault core å†æ¬¡è¿è¡Œï¼Œå°±å¯ä»¥æ¢å¤ crash çš„ç°åœºã€‚\nSRAM/DRAMï¼šflip-flop\nMagnetism ç”¨å°ç£é“çš„æ–¹å‘æ¥è¡¨ç¤º 0 å’Œ 1ï¼Œä¸åŒæ–¹å‘çš„å°ç£é“ä¼šæœ‰ä¸åŒæ–¹å‘çš„ç£åœºï¼Œä»è€Œå¯ä»¥æ„Ÿåº”å‡ºä¸åŒæ–¹å‘çš„ç”µæµã€‚æ­¤å¤–ï¼Œç”µæµäº§ç”Ÿçš„ç£åœºä¹Ÿå¯ä»¥ç”¨æ¥ä¿®æ”¹å°ç£é“çš„æ–¹å‘ã€‚\nMagnetic Tape (1928) ç£å¸¦æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ª 1D çš„å­˜å‚¨è®¾å¤‡ï¼Œä½†æˆ‘ä»¬å¯ä»¥é€šè¿‡æŠŠç£å¸¦å·èµ·æ¥ä½¿å…¶å˜æˆä¸€ä¸ªè¿‘ä¼¼ 2D çš„å­˜å‚¨è®¾å¤‡ã€‚å› æ­¤å¯ä»¥åœ¨å°ç©ºé—´å†…å­˜æ”¾å¤§é‡çš„ bitã€‚åœ¨ä¸­é—´ä½ç½®æ”¾ä¸€ä¸ªè¯»å†™å¤´ï¼Œç„¶åé€šè¿‡æœºæ¢°è½¬è½®æ¥å®šä½å½“å‰è¯»å†™çš„ä½ç½®ã€‚\nä¼˜ç‚¹ï¼šä¾¿å®œï¼Œå®¹é‡å¤§ï¼Œå­˜å‚¨æ—¶é—´ç›¸å¯¹è¾ƒé•¿ ç¼ºç‚¹ï¼šå®Œå…¨æ— æ³•éšæœºè¯»å– (åªèƒ½é æœºæ¢°è½¬è½®ç§»åŠ¨) å› æ­¤ç£å¸¦ä¸»è¦ç”¨äºå¤§é‡å†·æ•°æ®çš„é•¿æ—¶é—´å­˜å‚¨ã€‚\nMagnetic Drum (1932) ç£é¼“ä¸€å®šç¨‹åº¦è§£å†³äº†ç£å¸¦æ— æ³•éšæœºè¯»å–çš„é—®é¢˜ï¼šå°†ç£å¸¦ä¸€åœˆä¸€åœˆç»•åœ¨ä¸€ä¸ªé‡‘å±æ£’ä¸Šï¼Œç„¶ååœ¨æ£’å­çš„ä¾§é¢æ”¾å¾ˆå¤šè¯»å†™å¤´ï¼Œè¿™æ ·è¯»å–ä¸€ä¸ª bit çš„æ—¶é—´æ§åˆ¶åœ¨æ£’å­è½¬ä¸€åœˆçš„æ—¶é—´ä¹‹å†…ã€‚ç£é¼“çš„ç¼ºç‚¹æ˜¯ï¼šå ç”¨çš„ç©ºé—´å¤ªå¤§äº†\nHard Disk (1956) å°†ç£å¸¦å†…å·åœ¨ä¸€ä¸ªäºŒç»´å¹³é¢ä¸Šï¼Œä¸­é—´æ˜¯è½¬è½´ã€‚ç£ç›˜ä¸­åªæœ‰ä¸€ä¸ªè¯»å†™å¤´ï¼Œä½†è¯»å†™å¤´ä¸Šæœ‰ä¸€ä¸ªç”µåŠ¨æœºï¼Œè¯»å†™å¤´çš„ç§»åŠ¨å¯ä»¥ä½¿å…¶å¿«é€Ÿå®šä½ç£å¸¦çš„æŸä¸ªåœˆï¼Œç£å¸¦çš„æ—‹è½¬å¯ä»¥ä½¿åœˆä¸ŠæŸä¸ªä½ç½®çš„ä¿¡æ¯åˆ°è¾¾è¯»å†™å¤´çš„ä½ç½®ã€‚è¿™æ ·ä¸ä»…é€Ÿåº¦å¿«ï¼Œè€Œä¸”å ç”¨ä½“ç§¯å¤§å¹…ä¸‹é™ã€‚\nå·¥ç¨‹ä¸Šå¯¹ç£ç›˜è¿˜æœ‰ä¸€äº›ä¼˜åŒ–ï¼Œæ¯”å¦‚åœ¨ z è½´ä¸Šæ’åˆ—è‹¥å¹²ä¸ªåœ†ç›˜ï¼Œæ”¾ç½®å¤šä¸ªè¯»å†™å¤´ç­‰ç­‰ã€‚æ­¤å¤–ç£ç›˜ä¸­çš„æ¯ä¸ªç›˜å®é™…ä¸Šä¸æ˜¯ç”¨ç£å¸¦ç»•å‡ºæ¥çš„ï¼Œè€Œæ˜¯ä½¿ç”¨äº†æ›´å…ˆè¿›çš„ç”Ÿäº§å·¥è‰ºã€‚\nä¼˜ç‚¹ï¼šä¾¿å®œï¼Œå®¹é‡å¤§ï¼Œæœ‰å‹‰å¼ºå¯ç”¨çš„éšæœºè¯»å–èƒ½åŠ› ç¼ºç‚¹ï¼šå¯é æ€§ä½ï¼Œå­˜åœ¨æœºæ¢°éƒ¨ä»¶ï¼Œç£å¤´åˆ’ä¼¤ç›˜ç‰‡å¯èƒ½å¯¼è‡´æ•°æ®ä¸¢å¤±ã€‚ ç£ç›˜æ˜¯å½“ä»Šè®¡ç®—æœºç³»ç»Ÿçš„ä¸»åŠ›æ•°æ®å­˜å‚¨ã€‚\nç£ç›˜å½“ä¸­æœ‰å¾ˆå¤šäº‹æƒ…æ˜¯å¯ä»¥è°ƒåº¦çš„ï¼Œä»å‰è¿™ä¸ªè°ƒåº¦ç”±æ“ä½œç³»ç»Ÿè´Ÿè´£ï¼Œä½†ç°åœ¨çš„ç£ç›˜è¶Šåšè¶Šå¤æ‚ï¼Œå¾ˆå¤šå†…éƒ¨å‚æ•°å·²ç»è¶…å‡ºäº†æ“ä½œç³»ç»Ÿçš„æ§åˆ¶ï¼Œå› æ­¤ç°ä»£çš„ç£ç›˜é€šå¸¸ä¼šæœ‰ä¸€ä¸ªç‰‡ä¸Šç³»ç»Ÿ (system on chip, SoC)ï¼Œè¿™ç§å†™æ­»çš„å›ºä»¶è´Ÿè´£ç£ç›˜ä¸­çš„è°ƒåº¦ç®—æ³•ã€‚\nFloppy Disk (1971) èƒ½ä¸èƒ½å°†ç›˜ç‰‡å’Œè¯»å†™å¤´åˆ†å¼€ï¼Œä»è€Œå®ç°æ•°æ®ç§»åŠ¨ï¼Ÿè¿™å°±æœ‰äº†è½¯ç›˜ã€‚åˆšå¼€å§‹è½¯ç›˜çœŸçš„æ˜¯è½¯çš„ï¼Œåæ¥çš„ 3.5 è‹±å¯¸è½¯ç›˜ä¸ºäº†å¯é æ€§å·²ç»æ˜¯ç¡¬çš„äº†ã€‚\nä¼˜ç‚¹ï¼šä»·æ ¼ä½ï¼Œæ•°æ®å¯ç§»åŠ¨ ç¼ºç‚¹ï¼šç”±äºæ˜¯æš´éœ²çš„å­˜å‚¨ä»‹è´¨ï¼Œæ‰€ä»¥å¯é æ€§ä½ï¼Œä¸”æ•°æ®å¯†åº¦ä¸èƒ½å¤ªå¤§ã€‚ Pits åœ¨ä¸€ä¸ªå¹³æ•´çš„å¹³é¢ä¸ŠæŒ–ä¸€äº›å‘ï¼Œè¿™æ ·å…‰ç…§åœ¨å¹³æ•´çš„åœ°æ–¹å¯ä»¥å¾ˆå¥½åœ°åå°„ï¼Œç…§åœ¨å‘ä¸Šå°±ä¸èƒ½å¾ˆå¥½åœ°åå°„ï¼Œä»è€Œå®ç° 0 å’Œ 1ã€‚\nCompact Disk (CD, 1980) åœ¨åå°„å¹³é¢ (1) ä¸ŠæŒ–ä¸Šç²—ç³™çš„å‘ (0)ï¼Œæ¿€å…‰æ‰«è¿‡è¡¨é¢ï¼Œå°±å¯ä»¥è¯»å‡ºä¿¡æ¯ã€‚CD çš„ä¸€å¤§é—®é¢˜åœ¨äºåªè¯»æ€§â€”â€”æŒ–å‘å®¹æ˜“å¡«å‘éš¾ã€‚æœ‰ä¸€äº›ä¾‹å¦‚ PCM (phase-change material) çš„ææ–™å¯ä»¥åšå‡º rewritable diskã€‚\nä¼˜ç‚¹ï¼šä»·æ ¼ä½ï¼Œå®¹é‡å¤§ï¼Œå¯é æ€§å¾ˆé«˜\nå…‰ç›˜çš„ä¸€ä¸ªå¾ˆæœ‰æ„æ€çš„ä¼˜ç‚¹æ˜¯å®ƒå¾ˆå®¹æ˜“é€šè¿‡â€œå‹ç›˜â€æ¥å¤åˆ¶ï¼šæˆ‘ä»¬å¯ä»¥åˆ¶ä½œä¸€ä¸ªæ¯ç›˜ï¼Œåœ¨è¯¥æŒ–å‘çš„åœ°æ–¹å‡¸èµ·ï¼Œç„¶åä¸€å¼ å¹³æ•´ç›˜å¾€ä¸Šä¸€å‹å°±æ˜¯ä¸€å¼ ç›˜ã€‚\nç¼ºç‚¹ï¼šéšæœºè¯»å–èƒ½åŠ›ä¸é«˜ï¼Œæ”¹å†™å›°éš¾ã€‚\nElectricity ä¹‹å‰çš„æŒä¹…å­˜å‚¨ä»‹è´¨éƒ½æœ‰ä¸€ä¸ªè‡´å‘½çš„ç¼ºé™·ï¼šå­˜åœ¨ä¸€äº›æœºæ¢°éƒ¨ä»¶ï¼Œæœºæ¢°éƒ¨ä»¶å¯é æ€§ä¸é«˜ä¸”é€Ÿåº¦è·Ÿä¸ä¸Šï¼Œè¦è·Ÿä¸Šç”µè·¯çš„é€Ÿåº¦ï¼Œæˆ‘ä»¬å¿…é¡»ç”¨ç”µæ¥åšå­˜å‚¨ä»‹è´¨ã€‚\nSolid State Drive (SSD, 1991) Flash memory çš„ floating gate çš„å……ç”µæ”¾ç”µå®ç°äº† 0-1ã€‚\nä¼˜ç‚¹ï¼šå¤§è§„æ¨¡é›†æˆç”µè·¯ä»·æ ¼ä½ï¼Œå®¹é‡å¾ˆå¤§ï¼›flash memory çš„æœ€å¤§ä¼˜åŠ¿åœ¨äºè¯»å†™é€Ÿåº¦ï¼Œè€Œä¸”å®ƒæœ‰ä¸€ä¸ªä¸è®²é“ç†çš„ç‰¹æ€§ï¼šå®¹é‡è¶Šå¤§é€Ÿåº¦è¶Šå¿« (ç”µè·¯çº§å¹¶è¡Œ)ï¼›å¯é æ€§éå¸¸é«˜ï¼šæ²¡æœ‰æœºæ¢°éƒ¨ä»¶ï¼Œæ‰€ä»¥å¯ä»¥éšä¾¿æ‘”ã€‚\nç¼ºç‚¹ï¼šå‡ ä¹æ— ã€‚\nUSB Flash Disk (1999) è¿…é€Ÿå‡»è´¥è½¯ç›˜ï¼Œæˆä¸ºäººæ‰‹ $n$ ä¸ªçš„ç§»åŠ¨å­˜å‚¨è®¾å¤‡ã€‚\nFlash memory æœ‰ä¸€ä¸ªå…³é”®çš„é—®é¢˜ï¼šæ”¾ç”µä¼šæ”¾ä¸å¹²å‡€ï¼Œä¸€ä¸ª cell ç»è¿‡äº†æˆåƒä¸Šä¸‡æ¬¡è¯»å†™æ“ä½œåï¼Œå‰©ä½™çš„ç”µå­å°±ä¼šå¤šåˆ°å¥½åƒæ˜¯ 1 çš„çŠ¶æ€ï¼Œè¿™ä¸ª cell æˆä¸ºäº†ä¸€ä¸ª dead cellã€‚\nè¯¥é—®é¢˜çš„è§£å†³æ–¹æ³•ç±»ä¼¼äºè™šæ‹Ÿå†…å­˜ï¼šåœ¨ OS çœ¼ä¸­ä¸è®ºæ˜¯ SSD è¿˜æ˜¯ HDD éƒ½ç±»ä¼¼äºä¸€ä¸ªå¤§æ•°ç»„ï¼Œä½†äº‹å®ä¸Š SSD é‡Œé¢æœ‰ä¸€ä¸ªå°å‹çš„è®¡ç®—æœºç³»ç»Ÿï¼šç³»ç»Ÿä¼šæ ¹æ®æ¯ä¸ª cell çš„è¯»å†™æ¬¡æ•°ï¼Œå°†æ‰€è°“çš„ â€œ100å·cell\u0026quot; æ˜ å°„åˆ°ä¸€ä¸ªå…¶ä»–çš„ cellï¼Œå°±åƒä¸€ä¸ª MMU ä¸€æ ·ã€‚è¿™æ ·å¯ä»¥ä¿è¯æ¯ä¸ª cell ä½¿ç”¨æ¬¡æ•°å·®ä¸å¤šï¼Œä¹Ÿå¯ä»¥ç»•å¼€ä¸€äº› dead cellã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"711c8d42cbaadd7729a5b67df5817e84","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec23/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec23/","section":"notes","summary":"æœºå™¨æŒ‡ä»¤æ¨¡å‹åªæœ‰ä¸¤ç§å½“å‰çŠ¶æ€ï¼šå¯„å­˜å™¨å’Œç‰©ç†å†…å­˜ã€‚è¿™äº›çŠ¶æ€åœ¨ç‰©ç†ä¸–ç•Œä¸­åº”å½“æœ‰çœŸå®çš„å¯¹åº”ã€‚æˆ‘ä»¬çš„éœ€æ±‚æ˜¯ï¼š\nå¯ä»¥å¯»å€ï¼šæ¯”å¦‚å¯ä»¥æ ¹æ®ç¼–å·è®¿é—®æŸä¸ªå•å…ƒæ ¼ã€‚ è®¿é—®é€Ÿåº¦å°½å¯èƒ½å¿« (ç”šè‡³ä¸æƒœæ‰ç”µåä¸¢å¤±çŠ¶æ€)ã€‚ â€œå½“å‰çŠ¶æ€â€çš„å­˜å‚¨\nå»¶è¿Ÿçº¿ (delay line)ï¼šåƒä¸€æ ¹å­˜å‚¨äº†æ•°æ®çš„ç»³å­ä¸æ–­åœ°è½¬ï¼Œä¿¡å·ä¼šéšç€æ—¶é—´è¡°å‡ï¼Œå› æ­¤æ•°æ®ä¼šä¸æ–­é€šè¿‡æ”¾å¤§å™¨æ¥ä¿æŒä¸ä¸¢å¤±ã€‚\nç£èŠ¯å†…å­˜ (Magnetic core)ï¼šç±»ä¼¼äºä¸€ä¸ªäºŒç»´çš„å°ç£é“é˜µåˆ—ï¼Œå½“ç»™ç¬¬ $i$ è¡Œç¬¬ $j$ åˆ—åŠ ç”µæ—¶ï¼Œåæ ‡åœ¨ $(i,j)$ å¤„çš„å°ç£é“å°±æœ‰è¶³å¤Ÿå¤§çš„ç”µæµå¯ä»¥æ—‹è½¬ã€‚ç£èŠ¯å†…å­˜æ˜¯ non volatile memory - æ‰ç”µå core çš„ä¿¡æ¯æ˜¯ä¸ä¼šä¸¢å¤±çš„ã€‚ä½†ä¿¡æ¯çš„æ”¹å˜ä¾èµ–å°ç£é“è½¬åŠ¨è¿™ä¸€ç‰©ç†åŠ¨ä½œï¼Œå› æ­¤é€Ÿåº¦ä¸å¤Ÿé«˜ã€‚\n\u0026ldquo;Segmentation fault (core dumped)\u0026rdquo;\nè¿™é‡Œçš„â€œæ ¸å¿ƒå·²è½¬å‚¨â€çš„è¯´æ³•å°±æ˜¯æºè‡ªäºç£èŠ¯å†…å­˜ã€‚Linux ç³»ç»Ÿä¸­é»˜è®¤çš„ core file size æ˜¯ 0 (å¯ä»¥é€šè¿‡å‘½ä»¤ ulimit -a æŸ¥çœ‹)ï¼Œå¯ä»¥é€šè¿‡ ulimit -c size æ¥ä¿®æ”¹ã€‚","tags":null,"title":"Lecture 23: 1Bit Storage","type":"docs"},{"authors":null,"categories":null,"content":"Overview ç”¨æˆ·ç›´æ¥ä½¿ç”¨çš„å…¶å®å¹¶ä¸æ˜¯è®¡ç®—è®¾å¤‡ï¼Œè€Œæ˜¯ I/O è®¾å¤‡ã€‚CPU åªæ˜¯ä¸€ä¸ªæ— æƒ…çš„æŒ‡ä»¤æ‰§è¡Œå™¨ï¼Œæˆ‘ä»¬å¸Œæœ›è®¡ç®—æœºå¯ä»¥æ„ŸçŸ¥å¤–éƒ¨ä¸–ç•Œçš„çŠ¶æ€ï¼Œå¹¶å¯¹å¤–å®æ–½åŠ¨ä½œã€‚\nI/O è®¾å¤‡å°±æ˜¯ä¸ CPU äº¤æ¢æ•°æ®çš„ä¸€ç»„æ¥å£ã€‚I/O è®¾å¤‡ä¼šæä¾›â€œå‡ æ¡çº¦å®šå¥½åŠŸèƒ½çš„çº¿â€ï¼ŒCPU ä¸è®¾å¤‡é€šè¿‡æ¡æ‰‹ä¿¡å·å¯ä»¥ä»çº¿ä¸Šè¯»å‡ºæˆ–å†™å…¥æ•°æ®ã€‚é€šå¸¸æ¥è¯´ï¼ŒCPU å’Œ I/O è®¾å¤‡äº¤äº’çš„æ•°æ®ä¸»è¦æœ‰çŠ¶æ€ (æ¯”å¦‚ CPU æŸ¥çœ‹æ‰“å°æœºæ˜¯å¦ç©ºé—²)ï¼ŒæŒ‡ä»¤ (æ¯”å¦‚ CPU è®©æ˜¾ç¤ºå±å‘å…‰) å’Œæ•°æ® (æ¯”å¦‚ CPU å‘Šè¯‰æ‰“å°æœºåº”è¯¥æ‰“å°ä»€ä¹ˆ)ã€‚\nä»æŠ½è±¡å±‚çš„è§’åº¦æ¥è¯´ï¼ŒCPU å®Œå…¨ä¸éœ€è¦ç®¡ I/O è®¾å¤‡å†…éƒ¨æ˜¯æ€ä¹ˆå®ç°çš„ï¼ŒCPU å¯ä»¥ç›´æ¥ä½¿ç”¨æŒ‡ä»¤ (in/out/mmio) å’Œè®¾å¤‡äº¤æ¢æ•°æ®ã€‚ä½†å„ç§è®¾å¤‡çš„å¤æ‚æ€§è¿˜æ˜¯ä½¿å¾—é©±åŠ¨ä»£ç æˆä¸ºæ“ä½œç³»ç»Ÿå†…æ ¸ä¸­éå¸¸åºå¤§ã€bugéå¸¸å¤šçš„ä¸€éƒ¨åˆ†ä»£ç ã€‚\nExample: UART #define COM1 0x3f8 static int uart_init() { outb(COM1 + 2, 0); // æ§åˆ¶å™¨ç›¸å…³ç»†èŠ‚ outb(COM1 + 3, 0x80); outb(COM1 + 0, 115200 / 9600); ... } static void uart_tx(AM_UART_TX_T *send) { outb(COM1, send-\u0026gt;data); } static void uart_rx(AM_UART_RX_T *recv) { recv-\u0026gt;data = (inb(COM1 + 5) \u0026amp; 0x1) ? inb(COM1) : -1; } è¿™æ˜¯ AbstractMachine ä¸­å…³äºä¸²å£çš„ä¸€éƒ¨åˆ†å®ç°ã€‚å¯ä»¥çœ‹åˆ° CPU å’Œ IO è®¾å¤‡äº¤äº’çš„åŸºæœ¬æ–¹å¼æ˜¯ï¼šCPU é€šè¿‡ in/out æŒ‡ä»¤ä»è®¾å¤‡å¯„å­˜å™¨ä¸­è¯»å–ä¿¡æ¯ (è¿™é‡Œä½¿ç”¨äº† memory mapped ioï¼Œè®¾å¤‡å¯„å­˜å™¨æ˜¯åœ°å€ COM1 å¼€å§‹çš„è‹¥å¹²å†…å­˜å•å…ƒ)ã€‚\nExample: Keyboard é”®ç›˜ç›¸è¾ƒäºä¸²å£æ›´åŠ å¤æ‚ï¼Œç°åœ¨çš„å¾ˆå¤šé”®ç›˜æ˜¯å¯ç¼–ç¨‹çš„ï¼Œæ¯”å¦‚æˆ‘ä»¬å¯ä»¥è½¯ä»¶æ§åˆ¶ ScrollLock, CapsLock, NumLock ç­‰ç¯çš„äº®æš—ï¼Œå¯ä»¥è®¾ç½®æŒ‰ä¸‹æŒ‰é”®æ—¶äº§ç”Ÿå­—ç¬¦çš„é‡å¤é€Ÿåº¦ç­‰ç­‰ã€‚äº‹å®ä¸Š AM é‡‡ç”¨çš„é”®ç›˜æ¥å£åªæä¾›äº†ä¸¤ä¸ªè®¾å¤‡å¯„å­˜å™¨ï¼Œä¸€ä¸ªæ˜¯æ•°æ® data (0x60)ï¼Œä¸€ä¸ªæ˜¯ status/command å¤ç”¨çš„å¯„å­˜å™¨ (0x64)ï¼Œå„ç§ä¸°å¯Œçš„åŠŸèƒ½éƒ½é è¿™ä¸¤ä¸ªå¯„å­˜å™¨çš„å€¼çš„ç»„åˆæ¥å®ç°ï¼Œå› æ­¤è¿™å…¶ä¸­æœ‰å¤§é‡çš„çº¦å®š/åè®®ã€‚æˆ‘ä»¬çš„é©±åŠ¨ç¨‹åºç›¸å½“äºè¦å®Œæˆè¿™æ ·ä¸€ä¸ª APIï¼š\nint keyboard_handler(int *rega, int *regb); åªæœ‰ä¸¤ä¸ªå‚æ•°ï¼Œä½†è¦è¯†åˆ«å‡ºå„ç§åŠŸèƒ½ï¼Œæ‰€ä»¥ä»£ç ç›¸å½“éš¾å†™ã€‚\nExample: Disk Controller void readsect(void *dst, int sect) { waitdisk(); out_byte(0x1f2, 1); // sector count (1) out_byte(0x1f3, sect); // sector out_byte(0x1f4, sect \u0026gt;\u0026gt; 8); // cylinder (low) out_byte(0x1f5, sect \u0026gt;\u0026gt; 16); // cylinder (high) out_byte(0x1f6, (sect \u0026gt;\u0026gt; 24) | 0xe0); // drive out_byte(0x1f7, 0x20); // command (write) waitdisk(); for (int i = 0; i \u0026lt; SECTSIZE / 4; i ++) ((uint32_t *)dst)[i] = in_long(0x1f0); // data } è¿™æ®µä»£ç æ˜¯ AbstractMachine ä¸­çš„ readsect()ã€‚å®ƒçš„é€»è¾‘è¦æ¯”ä¸²å£æ›´åŠ å¤æ‚ä¸€äº›ï¼Œé¦–å…ˆè°ƒç”¨ waitdisk() ç­‰å¾…è®¾å¤‡å‡†å¤‡å°±ç»ªï¼Œç„¶åå‘è®¾å¤‡æ§åˆ¶å¯„å­˜å™¨å†™å…¥ä¸€äº›æ•°æ®æ§åˆ¶ç£ç›˜å‘æˆ‘ä»¬è¿”å›æˆ‘ä»¬éœ€è¦çš„æ•°æ® (è¿™äº›å†…å®¹æ˜¯æ‰‹å†Œè§„å®šçš„)ï¼Œå†™å®Œ command åæˆ‘ä»¬å†è°ƒç”¨ waitdisk() ç­‰å¾…è®¾å¤‡å‡†å¤‡å°±ç»ªï¼Œæœ€ç»ˆæŠŠæ•°æ®ç»™è¯»å‡ºæ¥ã€‚\nExample: Printer å¦‚æœè¦è®¾è®¡ä¸€ä¸ªæ‰“å°æœºå¯¹å¤–æ¥å£ï¼Œæœ€ç®€å•çš„å®ç°å°±æ˜¯ä¸€ä¸ªè¡¨ç¤ºçŠ¶æ€çš„å¯„å­˜å™¨ status å’Œä¸€ä¸ªä¼ è¾“æ‰“å°æ•°æ®æµçš„å¯„å­˜å™¨ dataã€‚åœ¨è¿™ä¸ªç®€å•çš„æ¨¡å‹ä¸‹ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥åšåˆ°ä¸€äº›å¾ˆä¼˜é›…çš„äº‹æƒ…ã€‚\nPostScript æ˜¯ä¸€ç§æè¿°é¡µé¢å¸ƒå±€çš„æ¯”è¾ƒåº•å±‚çš„ç¼–ç¨‹è¯­è¨€ã€‚ä¸€ä¸ªå°ä¾‹å­å¦‚ä¸‹ï¼š\n%! % http://www.cs.cmu.edu/afs/andrew/scs/cs/15-463/98/pub/www/assts/ps.html 72 72 scale\t% scale coordinate system so units are inches, not points 2 2 translate\t% put origin 2 inches from lower left of page /Courier findfont .6 scalefont setfont % current font is now Courier about .6 inches high gsave\t% save graphics state (coordinate system \u0026amp; stuff) .5 setgray 60 rotate 0 0 moveto (Read the friendly manual) show grestore\t% restore previous graphics state /Helvetica-Bold findfont .2 scalefont setfont % current font is now slanted Helvetica about .2 inches high 0 4 moveto (Read the friendly source code) show /Times-Italic findfont .5 scalefont setfont % current font is now italic Times about .5 inches high 1 0 0 setrgbcolor 0 6 moveto (Search the friendly Web) show showpage å®ƒå¯ä»¥æŒ‡å®šç”»ç¬”çš„ä½ç½®ã€é¢œè‰²ã€è§’åº¦ï¼ŒæŒ‡å®šå­—ä½“ã€å¤§å°ç­‰ç­‰ã€‚ç”±äºå®ƒæ˜¯çŸ¢é‡ç»˜å›¾ï¼Œæ‰€ä»¥æ¸…æ™°åº¦å¾ˆé«˜ã€‚\næˆ‘ä»¬å®Œå…¨å¯ä»¥ä»¥ PostScript ä½œä¸ºæ ‡å‡†åšä¸€å¥—å®Œæ•´çš„å·¥å…·é“¾ï¼šæ¯”å¦‚ä»¥ Latex ä¸ºå‰ç«¯ï¼Œå†™ä¸€ä¸ªç¼–è¯‘å™¨å°† Latex ç¼–è¯‘æˆ PostScriptï¼Œç„¶åæˆ‘ä»¬ç»™è®¾å¤‡ä¼ è¾“çš„å­—èŠ‚æµå°±æ˜¯ PostScript æ ¼å¼çš„æ•°æ®ã€‚ç¡¬ä»¶è®¾å¤‡é‡Œå†™ä¸€ä¸ª PostScript çš„è§£é‡Šå™¨å°† PostScript ç¿»è¯‘æˆæ‰“å°æœºç‰©ç†ç¡¬ä»¶çš„åŠ¨ä½œã€‚\nå½“ç„¶ï¼Œåƒæ‰“å°æœºè¿™ç§æœ‰åˆ‡å®ç‰©ç†æœºæ¢°éƒ¨ä»¶çš„è®¾å¤‡ï¼Œä¼šæœ‰å¾ˆå¤šæƒ…å†µéœ€è¦å¤„ç†ï¼Œæ¯”å¦‚å¡çº¸ï¼Œç¼ºå¢¨ç­‰ç­‰ï¼Œå› æ­¤æ‰“å°æœºçš„æ‰‹å†Œç›¸å½“ç›¸å½“é•¿ã€‚\nBus, Interrupt Controller and DMA Bus å¦‚æœæˆ‘ä»¬çš„ä¸–ç•Œé‡Œåªæœ‰é¼ æ ‡ï¼Œé”®ç›˜ï¼Œæ˜¾ç¤ºå±å‡ ä¸ªå›ºå®šçš„ I/O è®¾å¤‡ï¼Œé‚£ä¹ˆå°†å®ƒä»¬å’Œ CPU è¿èµ·æ¥çš„æœ€ç®€å•çš„æ–¹å¼å°±æ˜¯åœ¨ CPU ä¸Šç•™å‡ ä¸ªå¯¹åº”çš„æ¥å£â€”â€”æ¯ä¸ªè®¾å¤‡æ’ä¸€ä¸ªã€‚ä½† I/O è®¾å¤‡ä¼šè¶Šæ¥è¶Šå¤šï¼Œå¦‚æœè¦è®© CPU æ”¯æŒæœªæ¥å¯èƒ½å‡ºç°çš„æ›´å¤šçš„ I/O è®¾å¤‡ï¼Œæˆ‘ä»¬å°±éœ€è¦ä¸€ä¸ªæ›´èªæ˜çš„å®ç°æ–¹æ¡ˆã€‚\næˆ‘ä»¬å¯ä»¥å‡è®¾æœ‰è¿™æ ·ä¸€ä¸ªç‰¹æ®Šçš„ I/O è®¾å¤‡ï¼Œå®ƒä¸Šé¢æœ‰è‹¥å¹²ä¸ªæ’æ§½ï¼Œæˆ‘ä»¬å¯ä»¥å°†å„å¼å„æ ·çš„ I/O è®¾å¤‡æ’åœ¨ä¸Šé¢ã€‚è¿™ä¸ª I/O è®¾å¤‡è´Ÿè´£ç®¡ç†æ’åœ¨å®ƒä¸Šé¢çš„å…¶ä»– I/O è®¾å¤‡ã€‚CPU åªéœ€è¦å’Œè¿™ä¸ª I/O è®¾å¤‡é€šä¿¡ï¼Œå½“ CPU éœ€è¦æŸä¸ªè®¾å¤‡çš„æŸä¸ªå¯„å­˜å™¨çš„å€¼æ—¶ï¼Œè¿™ä¸ª I/O è®¾å¤‡å°±ä¼šåˆ°å¯¹åº”çš„æ’æ§½çš„å¯¹åº”çš„å¯„å­˜å™¨å»æ‰¾æ•°æ®ã€‚è¿™æ ·ä¸€ä¸ªæä¾›è®¾å¤‡çš„æ³¨å†Œå’Œåœ°å€åˆ°è®¾å¤‡çš„è½¬å‘çš„ç‰¹æ®Š I/O è®¾å¤‡å°±æ˜¯æ€»çº¿ (bus)ã€‚\næˆ‘ä»¬å¯ä»¥åšçš„æ›´å½»åº•ä¸€ç‚¹ï¼šæˆ‘ä»¬æŠŠå†…å­˜ DRAM ä¹Ÿè¿åˆ°æ€»çº¿ä¸Šé¢ï¼Œè¿™æ · CPU å°±çœŸçš„åªéœ€è¦å’Œæ€»çº¿äº¤äº’äº†ã€‚å†…å­˜å•å…ƒæœ‰å¯¹åº”çš„åœ°å€ï¼Œæˆ‘ä»¬å¯ä»¥ç»™è®¾å¤‡å¯„å­˜å™¨ä¹Ÿç¼–ä¸Šåœ°å€ï¼Œè¿™æ · CPU å’Œæ€»çº¿ä¹‹é—´åªéœ€è¦ä¸€æ ¹åœ°å€çº¿å’Œä¸€æ ¹æ•°æ®çº¿ (å½“ç„¶ï¼Œå…¶å®è¿˜éœ€è¦ä¸€æ ¹ç”¨äºæ¡æ‰‹çš„æ§åˆ¶çº¿)ï¼ŒCPU å°±å¯ä»¥é€šè¿‡ä¸€ä¸ªç®€å•çš„åœ°å€æ¥ä»»æ„è¯»å†™å†…å­˜å’Œ I/O è®¾å¤‡ä¸Šçš„æ•°æ®ã€‚\nè¿™é‡Œæœ‰ä¸€æ®µç¤ºä¾‹ä»£ç ï¼š\n// pci-probe.c #include \u0026lt;am.h\u0026gt; #include \u0026lt;klib.h\u0026gt; static inline uint32_t inl(int port) { uint32_t data; asm volatile (\u0026quot;inl %1, %0\u0026quot; : \u0026quot;=a\u0026quot;(data) : \u0026quot;d\u0026quot;((uint16_t)port)); return data; } static inline void outl(int port, uint32_t data) { asm volatile (\u0026quot;outl %%eax, %%dx\u0026quot; : : \u0026quot;a\u0026quot;(data), \u0026quot;d\u0026quot;((uint16_t)port)); } uint32_t pciconf_read(uint32_t bus, uint32_t slot, uint32_t func, uint32_t offset) { uint32_t reg = (bus \u0026lt;\u0026lt; 16) | (slot \u0026lt;\u0026lt; 11) | (func \u0026lt;\u0026lt; 8) | (offset) | 0x80000000; outl(0xcf8, reg); return inl(0xcfc); } int main() { ioe_init(); for (int bus = 0; bus \u0026lt; 256; bus ++) { for (int slot = 0; slot \u0026lt; 32; slot ++) { uint32_t info = pciconf_read(bus, slot, 0, 0); uint16_t id = info \u0026gt;\u0026gt; 16, vendor = info \u0026amp; 0xffff; if (vendor != 0xffff) { printf(\u0026quot;%02d:%02d device %x by vendor %x\u0026quot;, bus, slot, id, vendor); if (id == 0x100e \u0026amp;\u0026amp; vendor == 0x8086) { printf(\u0026quot; \u0026lt;-- This is an Intel e1000 NIC card!\u0026quot;); } printf(\u0026quot;\\n\u0026quot;); } } } } è¯¥ä»£ç æ‰«æ PCI æ€»çº¿ä¸Šçš„æ¯ä¸ªæ’æ§½å¹¶æ£€æŸ¥ä¸Šé¢æ˜¯å¦æœ‰è®¾å¤‡ï¼Œæ­¤å¤–å®ƒä¼šé¢å¤–æŒ‡å‡ºä»¥å¤ªç½‘å¡ã€‚è¿è¡Œè¯¥ç¨‹åºå¯ä»¥çœ‹åˆ°ç»“æœ\n0: 0 device 1237 by vendor 8086 0: 1 device 7000 by vendor 8086 0: 2 device 1111 by vendor 1234 0: 3 device 100e by vendor 8086 \u0026lt;-- This is an Intel e1000 NIC card! æˆ‘ä»¬è¿˜å¯ä»¥é€šè¿‡ qemu çš„é€‰é¡¹æ¥æ¨¡æ‹Ÿå‡ºä¸€äº›æ–°çš„è®¾å¤‡ï¼š-device AC97 é€‰é¡¹å¯ä»¥æ¨¡æ‹Ÿå‡ºä¸€ä¸ªå£°å¡ã€‚æˆ‘ä»¬æ·»åŠ è¿™ä¸ªé€‰é¡¹è¿è¡Œåï¼Œå¾—åˆ°çš„ç»“æœç¡®å®å¤šäº†ä¸€ä¸ªè®¾å¤‡ï¼š\n0: 0 device 1237 by vendor 8086 0: 1 device 7000 by vendor 8086 0: 2 device 1111 by vendor 1234 0: 3 device 100e by vendor 8086 \u0026lt;-- This is an Intel e1000 NIC card! 0: 4 device 2415 by vendor 8086 Interrupt Controller CPU æ˜¯æ— æƒ…çš„æ‰§è¡ŒæŒ‡ä»¤å’Œå“åº”å¤–éƒ¨ä¸­æ–­çš„æœºå™¨ã€‚CPU ä¸Šæœ‰ä¸€ä¸ªä¸“é—¨çš„ IRQ å¼•è„šç”¨æ¥æ¥æ”¶ä¸­æ–­ä¿¡å·ï¼Œæ¥æ”¶åˆ°ä»£è¡¨ä¸­æ–­çš„ç”µä¿¡å·ä»¥åï¼ŒCPU ä¼šä¿å­˜ä¸€äº›å¯„å­˜å™¨ï¼Œç„¶åæ ¹æ®ä¸­æ–­å‘é‡è¡¨å¯¹åº”é¡¹è·³è½¬æ‰§è¡Œä¸­æ–­å¤„ç†ç¨‹åºã€‚ä»¥å‰ IRQ å¼•è„šå¼•å‡ºçš„çº¿ä¼šæ¥åˆ°ä¸€ä¸ª Intel 8259 PIC ä¸Š (programmable interrupt controller)ï¼Œè¿™ä¸ªå¯ç¼–ç¨‹çš„ä¸­æ–­æ§åˆ¶å™¨å¯ä»¥è®¾ç½®å„ç§ä¸­æ–­å±è”½ï¼Œä¸­æ–­ä¼˜å…ˆçº§ç­‰ç­‰ã€‚ç°åœ¨æœ‰äº†æ€»çº¿ä¹‹åï¼ŒIRQ è¿åˆ°äº†æ€»çº¿ä¸Šã€‚ç°åœ¨çš„ CPU ä¸­æœ‰ä¸€ä¸ª APIC æ¨¡å— (Advanced PIC)ï¼Œå…¶ä¸­ local APIC æ¯ä¸ª CPU ä¸€ä¸ªï¼Œè´Ÿè´£å¤„ç†æ—¶é’Ÿä¸­æ–­ï¼ŒIPI ç­‰ï¼›I/O APIC å…¨å±€ä¸€ä¸ªï¼Œè´Ÿè´£å¤„ç†è®¾å¤‡ä¸­æ–­ã€‚\nInter Processor Interrupt (IPI)\nåœ¨å¤šæ ¸å¤„ç†å™¨ä¸­ï¼Œä¸€ä¸ª CPU æ ¸å¯ä»¥ç»™å¦ä¸€ä¸ª CPU æ ¸å‘é€ä¸­æ–­ã€‚æ¯”å¦‚åœ¨å¼€æœºçš„æ—¶å€™ï¼Œåˆšå¼€å§‹åªæœ‰ä¸€ä¸ª CPU æ ¸è¢«å”¤é†’ï¼Œå®ƒæ‰§è¡Œå®Œä¸€äº›åˆå§‹åŒ–æ“ä½œåï¼Œå°±éœ€è¦é€šè¿‡ IPI æ¥å”¤é†’å…¶ä»–çš„ CPU æ ¸å¼€å§‹å¹¶å‘æ‰§è¡Œã€‚\nIPI è¿˜æœ‰æ›´å¤šé‡è¦çš„ç”¨é€”ã€‚å‡è®¾å½“å‰æœ‰ä¸¤ä¸ª CPU æ ¸ï¼Œè¿™ä¸¤ä¸ªæ ¸è¿è¡Œäº†ä¸¤ä¸ªçº¿ç¨‹ï¼Œæœ‰ç‹¬ç«‹çš„ cache å’Œ TLBï¼Œä½†å…±äº«å†…å­˜ã€‚ç¬¬ä¸€ä¸ªæ ¸æ‰§è¡Œäº†ä¸€ä¸ª mmap æ“ä½œï¼Œå°†å†…å­˜ä¸­çš„æŸä¸€æ®µåšäº†æ˜ å°„ã€‚ä½†è¿™æœŸé—´å¦‚æœç¬¬äºŒä¸ªæ ¸æ²¡æœ‰ä»»ä½•ç³»ç»Ÿè°ƒç”¨/ä¸­æ–­ï¼Œé‚£ä¹ˆç¬¬äºŒä¸ªæ ¸çš„ TLB å°±æ²¡æœ‰æ›´æ–°ï¼å¤šæ ¸ä¹‹é—´çš„å†…å­˜å¯è§æ€§å°±æ¶ˆå¤±äº†ã€‚å› æ­¤ç¬¬ä¸€ä¸ªæ ¸éœ€è¦å‘é€ä¸€ä¸ª IPI ç»™ç¬¬äºŒä¸ªæ ¸æ¥åšä¸€äº›æ›´æ–°ï¼Œè¿™ä¸ªæ“ä½œå«åš TLB shotdownã€‚\nDirect Memory Access (DMA) ä¸­æ–­ I/O ç›¸è¾ƒäºè½®è¯¢ I/O è§£å†³äº†ä¸€ä¸ªé—®é¢˜ï¼šæˆ‘ä»¬çš„ CPU ä¸ç”¨æµªè´¹æ—¶é’Ÿå‘¨æœŸè½®è¯¢ç­‰å¾… I/O è®¾å¤‡å‡†å¤‡å°±ç»ªï¼Œè€Œæ˜¯å¯ä»¥åœ¨è®¾å¤‡å‡†å¤‡å¥½çš„æ—¶å€™ç»™ CPU å‘é€ä¸€ä¸ªä¸­æ–­ä¿¡å·ã€‚ä½†æˆ‘ä»¬è¿˜æœ‰ä¸€ä¸ªé—®é¢˜æ²¡æœ‰è§£å†³ï¼šå‘è®¾å¤‡ä¼ è¾“æ•°æ®è¿™ä»¶äº‹æœ¬èº«ä¹Ÿæ˜¯å¾ˆæ…¢çš„ï¼Œæ¯”å¦‚æˆ‘ç°åœ¨è¦å°† 1GiB çš„æ•°æ®å†™å…¥ç£ç›˜ï¼Œå¦‚æœæˆ‘çš„ä»£ç æ˜¯è¿™ä¹ˆå†™çš„ï¼š\nfor (int i = 0; i \u0026lt; 1 GB / 4; i++) outl(PORT, ((uint32 *)buf)[i]); é‚£è¿™ä¸ªæ‹·è´è¿‡ç¨‹è¦èŠ±ç›¸å½“é•¿æ—¶é—´ã€‚äº‹å®ä¸Šï¼Œç”±äºç”µæ°”ç‰¹æ€§çš„é™åˆ¶ï¼ŒCPU å’Œæ€»çº¿ä¹‹é—´å­˜åœ¨æ€§èƒ½ gapï¼šæ€»çº¿ä¸Šçš„è®¾å¤‡æ— æ³•åšåˆ° CPU é‚£ä¹ˆå¿«ï¼Œè¿™æ— ç–‘æµªè´¹äº† CPU çš„æ—¶é—´ã€‚\næˆ‘ä»¬è‡ªç„¶çš„æƒ³æ³•æ˜¯ï¼šå¦‚æœæˆ‘ä»¬æœ‰ä¸€ä¸ªå° CPU ä¸“é—¨å¸®æˆ‘ä»¬åšæ•°æ®æ‹·è´å°±å¥½äº†ã€‚å®ƒä¸éœ€è¦é€šç”¨ CPU é‚£ä¹ˆå¤æ‚ï¼Œå®ƒåªè¦èƒ½åš memcpy() å°±è¡Œäº†ï¼Œè¿™æ ·å¤§ CPU å°±å¯ä»¥è¢«è§£æ”¾å‡ºæ¥å¹²åˆ«çš„äº‹æƒ…ã€‚è¿™å°±æ˜¯ DMAï¼ŒDMA çš„æœ¬è´¨å°±æ˜¯ä¸€ä¸ªä¸“èŒ memcpy() çš„å° CPUã€‚DMA æ”¯æŒä» memory åˆ° memoryï¼Œä» memory åˆ° device(register)ï¼Œä» device(register) åˆ° memory ç­‰è‹¥å¹²ç§ memcpy()ï¼Œç°åœ¨çš„ DMA æ§åˆ¶å™¨ç›´æ¥è¿åœ¨æ€»çº¿å’Œå†…å­˜ä¸Šã€‚\nGPU and Heterogeneous Computing DMA ç›¸å½“äºä¸€ä¸ªä¸“é—¨æ‰§è¡Œ memcpy çš„å° CPUã€‚I/O è®¾å¤‡å’Œè®¡ç®—æœºä¹‹é—´çš„è¾¹ç•Œé€æ¸æ¨¡ç³Šã€‚æˆ‘ä»¬èƒ½ä¸èƒ½å°†ä¸€äº›å…¶ä»–ä»»åŠ¡äº¤ç»™å° cpu åšå‘¢ï¼Ÿæ˜¾å¡å°±æ˜¯ä¸“é—¨ç»˜å›¾çš„ I/O è®¾å¤‡ã€‚\nè®© CPU ç»˜å›¾ä¼šé‡åˆ°ä¸€äº›æ€§èƒ½ç“¶é¢ˆï¼šä»¥ NES ä¸ºä¾‹ï¼Œå¦‚æœæˆ‘ä»¬è¦å®ç° 60fpsï¼Œå°±è¦åœ¨ 10K æŒ‡ä»¤å†…å®Œæˆä¸€å¸§çš„ç»˜åˆ¶ï¼Œè€Œä¸€å¸§çš„åƒç´ æœ‰ 60Kï¼Œè¿™æ˜¯ä¸å¯èƒ½å®Œæˆçš„ä»»åŠ¡ã€‚NES çš„åšæ³•æ˜¯ï¼šç”»é¢å…¶å®æ˜¯ç”¨è‹¥å¹²æ–¹å—æ‹¼å‡ºæ¥çš„ï¼ŒCPU åªéœ€è¦æè¿°å°†å“ªäº›æ–¹å—æ”¾åœ¨ä»€ä¹ˆä½ç½®ï¼Œå°†è¿™æ ·ä¸€ä¸ªè„šæœ¬ (æœ¬è´¨ä¸Šå’Œ PostScript) ä¸€æ ·å‘é€ç»™ NES Picture Processing Unit (PPU)ï¼Œè®© PPU æ¥å®Œæˆå›¾å½¢æ˜¾ç¤ºã€‚ç”±äº PPU åªè´Ÿè´£ç»˜åˆ¶å›¾å½¢ï¼ŒåŠŸèƒ½å•ä¸€ä½†ç®—åŠ›å¼ºå¤§ï¼Œæ‰€ä»¥å¯ä»¥æ”¯æŒ 60fpsã€‚\nç°ä»£çš„ GPU æ˜¯ä¸€ä¸ªé€šç”¨çš„è®¡ç®—è®¾å¤‡ï¼šå®ƒæ˜¯ä¸€ä¸ªå®Œæ•´çš„ä¼—æ ¸å¤šå¤„ç†å™¨ç³»ç»Ÿï¼Œæœ‰å¾ˆå¤šå¾ˆå¤š (è¿œå¤šäº CPU core) çš„æ ¸å¿ƒæ•°é‡å’Œä¸€ä¸ªå¾ˆå¤§çš„ memory (æ˜¾å­˜)ï¼ŒGPU ä» DMA æ‹‰æ•°æ®å’Œè¦æ‰§è¡Œçš„ä»£ç æ”¾åˆ° memory é‡Œï¼Œç„¶åå®Œæˆè®¡ç®—åå†å°†ç»“æœæ¨å‡ºå»ã€‚\nDark Silicon Age çš„åˆ°æ¥æ„å‘³ç€åŠŸè€—æˆä¸ºé™åˆ¶ CPU æ€§èƒ½ä¼˜åŒ–çš„ç“¶é¢ˆï¼ŒCPU çš„é¢‘ç‡å¾ˆéš¾å†å¾€ä¸Šæï¼ŒCPU core çš„æ•°é‡ä¹Ÿè¦å—åˆ° cache coherence ç­‰å› ç´ çš„åˆ¶çº¦ã€‚å› æ­¤ç°åœ¨å¾ˆå¤šçš„éœ€æ±‚éƒ½æ˜¯é€šè¿‡å¼€å‘æ–°çš„ system on chip (SoC) æ¥å®ç°ï¼Œæ¯”å¦‚ç¥ç»ç½‘ç»œç›¸å…³çš„ NPU ç­‰ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"8b6cdb4675034ebe1a2085689caf93e4","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec24/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec24/","section":"notes","summary":"Overview ç”¨æˆ·ç›´æ¥ä½¿ç”¨çš„å…¶å®å¹¶ä¸æ˜¯è®¡ç®—è®¾å¤‡ï¼Œè€Œæ˜¯ I/O è®¾å¤‡ã€‚CPU åªæ˜¯ä¸€ä¸ªæ— æƒ…çš„æŒ‡ä»¤æ‰§è¡Œå™¨ï¼Œæˆ‘ä»¬å¸Œæœ›è®¡ç®—æœºå¯ä»¥æ„ŸçŸ¥å¤–éƒ¨ä¸–ç•Œçš„çŠ¶æ€ï¼Œå¹¶å¯¹å¤–å®æ–½åŠ¨ä½œã€‚\nI/O è®¾å¤‡å°±æ˜¯ä¸ CPU äº¤æ¢æ•°æ®çš„ä¸€ç»„æ¥å£ã€‚I/O è®¾å¤‡ä¼šæä¾›â€œå‡ æ¡çº¦å®šå¥½åŠŸèƒ½çš„çº¿â€ï¼ŒCPU ä¸è®¾å¤‡é€šè¿‡æ¡æ‰‹ä¿¡å·å¯ä»¥ä»çº¿ä¸Šè¯»å‡ºæˆ–å†™å…¥æ•°æ®ã€‚é€šå¸¸æ¥è¯´ï¼ŒCPU å’Œ I/O è®¾å¤‡äº¤äº’çš„æ•°æ®ä¸»è¦æœ‰çŠ¶æ€ (æ¯”å¦‚ CPU æŸ¥çœ‹æ‰“å°æœºæ˜¯å¦ç©ºé—²)ï¼ŒæŒ‡ä»¤ (æ¯”å¦‚ CPU è®©æ˜¾ç¤ºå±å‘å…‰) å’Œæ•°æ® (æ¯”å¦‚ CPU å‘Šè¯‰æ‰“å°æœºåº”è¯¥æ‰“å°ä»€ä¹ˆ)ã€‚\nä»æŠ½è±¡å±‚çš„è§’åº¦æ¥è¯´ï¼ŒCPU å®Œå…¨ä¸éœ€è¦ç®¡ I/O è®¾å¤‡å†…éƒ¨æ˜¯æ€ä¹ˆå®ç°çš„ï¼ŒCPU å¯ä»¥ç›´æ¥ä½¿ç”¨æŒ‡ä»¤ (in/out/mmio) å’Œè®¾å¤‡äº¤æ¢æ•°æ®ã€‚ä½†å„ç§è®¾å¤‡çš„å¤æ‚æ€§è¿˜æ˜¯ä½¿å¾—é©±åŠ¨ä»£ç æˆä¸ºæ“ä½œç³»ç»Ÿå†…æ ¸ä¸­éå¸¸åºå¤§ã€bugéå¸¸å¤šçš„ä¸€éƒ¨åˆ†ä»£ç ã€‚","tags":null,"title":"Lecture 24: I/O Devices","type":"docs"},{"authors":null,"categories":null,"content":"åœ¨æ“ä½œç³»ç»Ÿçœ¼é‡Œï¼ŒI/O è®¾å¤‡ = ä¸€ç»„å¯„å­˜å™¨ + ä¸€ä¸ªæ§åˆ¶åè®®ã€‚ä¸åŒè®¾å¤‡çš„æ§åˆ¶åè®®åƒå·®ä¸‡åˆ«ï¼Œå¦‚æœè®©è½¯ä»¶ç›´æ¥å’Œè¿™äº›è®¾å¤‡å¯„å­˜å™¨æ‰“äº¤é“ï¼Œå³ä½¿æ“ä½œç³»ç»Ÿä»”ç»†åœ°ç®¡ç†å¥½è®¿é—®æƒé™ï¼Œåº”ç”¨ç¨‹åºä¹Ÿå¾ˆå®¹æ˜“å‡ºé”™ã€‚æ‰€ä»¥æˆ‘ä»¬çš„æƒ³æ³•æ˜¯ï¼šå¯¹ä¸åŒçš„è®¾å¤‡åšä¸€ä¸ªæŠ½è±¡ï¼Œä½¿å¾—ä¸Šå±‚åº”ç”¨å¯ä»¥é€šè¿‡å°½å¯èƒ½ç»Ÿä¸€çš„æ¥å£æ¥è®¿é—®è®¾å¤‡ã€‚\nOverview I/O è®¾å¤‡æœ€åŸºæœ¬çš„éœ€æ±‚å°±æ˜¯ read å’Œ writeã€‚UNIX ä¸–ç•Œé‡Œçš„è®¾å¤‡é€šå¸¸åˆ†ä¸ºä¸¤ç§ï¼š\nå­—ç¬¦è®¾å¤‡ (character device)ï¼Œè®¾å¤‡ä¸ OS ä¹‹é—´ä¼ é€çš„æ˜¯å­—èŠ‚æµã€‚æˆ‘ä»¬å¯ä»¥æŠŠè¿™ç§è®¾å¤‡æƒ³è±¡æˆä¸€ä¸ªç®¡é“ã€‚ç»ˆç«¯ã€æ‰“å°æœºç­‰éƒ½æ˜¯å…¸å‹çš„å­—ç¬¦è®¾å¤‡ã€‚\nå—è®¾å¤‡ (block device)ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠè¿™ç§è®¾å¤‡æƒ³è±¡æˆä¸€ä¸ªå­—ç¬¦æ•°ç»„ï¼Œè¿™æ ·çš„è®¾å¤‡é€šå¸¸æœ‰ persistence çš„éœ€æ±‚ï¼Œæ¯”å¦‚ç£ç›˜ã€‚\næ˜¾å¡æ˜¯ä¸€ç§ä»€ä¹ˆæ ·çš„è®¾å¤‡ï¼Ÿ\næ˜¾å¡ä¸­å…¶å®æ—¢æœ‰å­—èŠ‚æµ (æ¯”å¦‚æ§åˆ¶ä¿¡å·ä¿®æ”¹æ˜¾å¡çš„å‚æ•°)ï¼Œåˆæœ‰å­—èŠ‚æ•°ç»„ (æ˜¾å¡é‡Œé¢æœ‰æ˜¾å­˜)ã€‚(ä¸è¿‡æ˜¾å­˜ä¸æ˜¯æŒ‰ç…§å—è®¾å¤‡çš„æ–¹å¼æ¥æŠ½è±¡çš„)\næ“ä½œ I/O è®¾å¤‡ï¼Œæˆ‘ä»¬è‡³å°‘éœ€è¦å¦‚ä¸‹çš„ä¸‰ä¸ª APIï¼š\nreadï¼šä»è®¾å¤‡çš„æŸä¸ªæŒ‡å®šçš„ä½ç½®è¯»å‡ºæ•°æ® (å¦‚æœæ˜¯å­—ç¬¦è®¾å¤‡ï¼Œåˆ™æ˜¯ä»å½“å‰çš„æœ€æ–°ä½ç½®)ã€‚ writeï¼šå‘è®¾å¤‡çš„æŸä¸ªæŒ‡å®šçš„ä½ç½®å†™å…¥æ•°æ®ã€‚ ioctlï¼šè¯»å–/è®¾ç½®è®¾å¤‡çš„çŠ¶æ€ (æ¯”å¦‚å¯¹äº GPU æ¥è¯´ï¼Œè®¾ç½®åˆ†è¾¨ç‡ï¼Œå¯¹äºæ‰“å°æœºæ¥è¯´ï¼Œæ£€æŸ¥çº¸å¼ ç­‰)ã€‚ è®¾å¤‡é©±åŠ¨ç¨‹åºçš„ä½œç”¨ä¹‹ä¸€å°±æ˜¯å°†è¿™äº›ç»Ÿä¸€çš„ç³»ç»Ÿè°ƒç”¨ API ç¿»è¯‘æˆå¯¹åº”åˆ°å…·ä½“è®¾å¤‡çš„å¯„å­˜å™¨çš„æ“ä½œã€‚åœ¨è®¡ç®—æœºç³»ç»Ÿçš„ä¸–ç•Œä¸­è¿™æ ·çš„æŠ½è±¡å±‚å¾ˆå¤šï¼š\nShell è´Ÿè´£å°†äººç±»å‘å‡ºçš„å‘½ä»¤è¡ŒæŒ‡ä»¤ç¿»è¯‘æˆåº•å±‚çš„ç³»ç»Ÿè°ƒç”¨ï¼›\nDriver è´Ÿè´£å°†ç³»ç»Ÿè°ƒç”¨ç¿»è¯‘æˆè®¾å¤‡ç›¸å…³çš„å¯„å­˜å™¨æ“ä½œï¼›\nâ€¦â€¦\nè®¡ç®—æœºç³»ç»Ÿä¸–ç•Œå°±æ˜¯è¿™æ ·ä¸€å±‚ä¸€å±‚æŠ½è±¡å’èµ·æ¥çš„ã€‚\nè™šæ‹Ÿè®¾å¤‡\nåœ¨æ“ä½œç³»ç»Ÿçœ¼é‡Œï¼Œè®¾å¤‡å°±æ˜¯åœ¨æ‰§è¡Œç³»ç»Ÿè°ƒç”¨çš„æ—¶å€™è¿è¡Œå¯¹åº”çš„é©±åŠ¨ç¨‹åºï¼Œæ“ä½œç³»ç»Ÿä¸å…³å¿ƒé©±åŠ¨ç¨‹åºç©¶ç«Ÿå¹²äº†ä»€ä¹ˆï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥æœ‰è™šæ‹Ÿè®¾å¤‡çš„æ¦‚å¿µï¼šé©±åŠ¨ç¨‹åºå¯ä»¥çœŸçš„å’Œä¸€ä¸ªç‰©ç†è®¾å¤‡è¿›è¡Œäº†äº¤äº’ï¼Œä¹Ÿå¯ä»¥åªæ˜¯æ¨¡æ‹Ÿäº†ä¸€äº›è¡Œä¸ºã€‚\n/dev/null å°±æ˜¯ä¸€ä¸ªå…¸å‹çš„è™šæ‹Ÿè®¾å¤‡ã€‚å®ƒåƒä¸€ä¸ªé»‘æ´ä¸€æ ·ï¼Œå¯ä»¥åƒæ‰æ‰€æœ‰å‘å®ƒè¾“å‡ºçš„å†…å®¹ã€‚å®ƒçš„è®¾å¤‡é©±åŠ¨ç¨‹åºéå¸¸ç®€å•ï¼šå¯¹äº writeï¼Œä¸è®ºå†™å…¥çš„å†…å®¹æ˜¯ä»€ä¹ˆï¼Œå®ƒç›´æ¥è¿”å›ä¸€ä¸ªå†™å…¥æˆåŠŸå³å¯ã€‚å¯¹äº readï¼Œä¸è®ºè¦è¯»å…¥ä»€ä¹ˆï¼Œä¹Ÿéƒ½ç›´æ¥è¿”å›ã€‚\nè®¾å¤‡çš„å¤æ‚æ€§\nè™½ç„¶è®¾å¤‡çš„æ•°æ®ä¼ è¾“æ˜¯å…¶â€œä¸»è¦â€çš„åŠŸèƒ½ï¼Œä½†å‰©ä¸‹çš„æ§åˆ¶åŠŸèƒ½ç§ç±»ç¹å¤šï¼šæ¯”å¦‚ç°ä»£çš„é”®ç›˜å¯ä»¥æ”¯æŒå‘¼å¸ç¯ã€è·‘é©¬ç¯ã€æŒ‰é”®ç¼–ç¨‹ï¼Œç°ä»£æ‰“å°æœºå¯ä»¥æ§åˆ¶æ‰“å°è´¨é‡ã€å¡çº¸ã€æ¸…æ´ã€è‡ªåŠ¨è£…è®¢ç­‰ç­‰ã€‚è¿™äº›æ§åˆ¶åŠŸèƒ½å…¨éƒ¨ä¾èµ– ioctl ç³»ç»Ÿè°ƒç”¨ï¼Œå¯¼è‡´å…¶ä¸­æœ‰æ— æ¯”å¤æ‚çš„ hidden specificationã€‚\nLinux Device Drivers è¿™é‡Œæœ‰ä¸€ä¸ªéå¸¸ç®€å•çš„ï¼Œç”¨äºâ€œå¼•çˆ†æ ¸å¼¹â€çš„è®¾å¤‡é©±åŠ¨ï¼š\n// launcher.c #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/kernel.h\u0026gt; #include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/cdev.h\u0026gt; #include \u0026lt;linux/device.h\u0026gt; #include \u0026lt;linux/fs.h\u0026gt; #include \u0026lt;linux/uaccess.h\u0026gt; #define MAX_DEV 2 static int dev_major = 0; static struct class *lx_class = NULL; static struct cdev cdev; static ssize_t lx_read(struct file *, char __user *, size_t, loff_t *); static ssize_t lx_write(struct file *, const char __user *, size_t, loff_t *); static struct file_operations fops = { .owner = THIS_MODULE, .read = lx_read, .write = lx_write, }; static struct nuke { struct cdev cdev; } devs[MAX_DEV]; static int __init lx_init(void) { dev_t dev; int i; // allocate device range alloc_chrdev_region(\u0026amp;dev, 0, 1, \u0026quot;nuke\u0026quot;); // create device major number dev_major = MAJOR(dev); // create class lx_class = class_create(THIS_MODULE, \u0026quot;nuke\u0026quot;); for (i = 0; i \u0026lt; MAX_DEV; i++) { // register device cdev_init(\u0026amp;devs[i].cdev, \u0026amp;fops); cdev.owner = THIS_MODULE; cdev_add(\u0026amp;devs[i].cdev, MKDEV(dev_major, i), 1); device_create(lx_class, NULL, MKDEV(dev_major, i), NULL, \u0026quot;nuke%d\u0026quot;, i); } return 0; } static void __exit lx_exit(void) { device_destroy(lx_class, MKDEV(dev_major, 0)); class_unregister(lx_class); class_destroy(lx_class); unregister_chrdev_region(MKDEV(dev_major, 0), MINORMASK); } static ssize_t lx_read(struct file *file, char __user *buf, size_t count, loff_t *offset) { if (*offset != 0) { return 0; } else { uint8_t *data = \u0026quot;This is dangerous!\\n\u0026quot;; size_t datalen = strlen(data); if (count \u0026gt; datalen) { count = datalen; } if (copy_to_user(buf, data, count)) { return -EFAULT; } *offset += count; return count; } } static ssize_t lx_write(struct file *file, const char __user *buf, size_t count, loff_t *offset) { char databuf[4] = \u0026quot;\\0\\0\\0\\0\u0026quot;; if (count \u0026gt; 4) { count = 4; } copy_from_user(databuf, buf, count); if (strncmp(buf, \u0026quot;\\x01\\x14\\x05\\x14\u0026quot;, 4) == 0) { const char *EXPLODE[] = { \u0026quot; â €â €â €â €â €â €â €â €â£€â£ â£€â£€â €â €â£€â£¤â£¤â£„â¡€â €â €â €â €â €â €â €â €â €â €â €\u0026quot;, \u0026quot; â €â €â €â£€â£ â£¤â£¤â£¾â£¿â£¿â£¿â£¿â£·â£¾â£¿â£¿â£¿â£¿â£¿â£¶â£¿â£¿â£¿â£¶â£¤â¡€â €â €â €â €\u0026quot;, \u0026quot; â €â¢ â£¾â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£·â €â €â €â €\u0026quot;, \u0026quot; â €â¢¸â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¶â¡€â €\u0026quot;, \u0026quot; â €â¢€â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡‡â €\u0026quot;, \u0026quot; â €â¢¸â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡¿â¢¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â ¿â Ÿâ â €\u0026quot;, \u0026quot; â €â €â »â¢¿â¡¿â¢¿â£¿â£¿â£¿â£¿â Ÿâ ›â ›â ‹â£€â£€â ™â »â ¿â ¿â ‹â »â¢¿â£¿â£¿â Ÿâ €â €â €â €\u0026quot;, \u0026quot; â €â €â €â €â €â €â ˆâ ‰â£‰â£ â£´â£·â£¶â£¿â£¿â£¿â£¿â£¶â£¶â£¶â£¾â£¶â €â €â €â €â €â €â €â €\u0026quot;, \u0026quot; â €â €â €â €â €â €â €â €â ‰â ›â ‹â ˆâ ›â ¿â Ÿâ ‰â »â ¿â ‹â ‰â ›â â €â €â €â €â €â €â €â €\u0026quot;, \u0026quot; â €â €â €â €â €â €â €â €â €â €â €â €â €â €â£¶â£·â¡†â €â €â €â €â €â €â €â €â €â €â €â €â €\u0026quot;, \u0026quot; â €â €â €â €â €â €â¢€â£€â£ â£¤â£¤â£¤â£¤â£¶â£¿â£¿â£·â£¦â£¤â£¤â£¤â£¤â£€â£€â €â €â €â €â €â €\u0026quot;, \u0026quot; â €â €â €â €â¢°â£¿â ›â ‰â ‰â â €â €â €â¢¸â£¿â£¿â£§â €â €â €â €â ‰â ‰â ™â¢»â£·â €â €â €â €\u0026quot;, \u0026quot; â €â €â €â €â €â ™â »â ·â ¶â£¶â£¤â£¤â£¤â£¿â£¿â£¿â£¿â£¦â£¤â£¤â£´â¡¶â ¶â Ÿâ ›â â €â €â €â €\u0026quot;, \u0026quot; â €â €â €â €â €â €â €â €â €â €â¢€â£´â£¿â£¿â£¿â£¿â£¿â£¿â£·â£„â €â €â €â €â €â €â €â €â €â €\u0026quot;, \u0026quot; â €â €â €â €â €â €â €â €â €â ’â ›â ›â ›â ›â ›â ›â ›â ›â ›â ›â “â €â €â €â €â €â €â €â €â €\u0026quot;, }; int i; for (i = 0; i \u0026lt; sizeof(EXPLODE) / sizeof(EXPLODE[0]); i++) { printk(\u0026quot;\\033[01;31m%s\\033[0m\\n\u0026quot;, EXPLODE[i]); } } else { printk(\u0026quot;nuke: incorrect secret, cannot lanuch.\\n\u0026quot;); } return count; } module_init(lx_init); module_exit(lx_exit); MODULE_LICENSE(\u0026quot;GPL\u0026quot;); MODULE_AUTHOR(\u0026quot;jyy\u0026quot;); è¯¥é©±åŠ¨åœ¨ linux ç³»ç»Ÿå¯åŠ¨åè¢«ç¼–è¯‘æˆä¸€ä¸ª .ko æ–‡ä»¶åâ€œåŠ¨æ€åŠ è½½â€ï¼Œå…¶ä¸­ lx_init() å’Œ lx_exit() çš„å†…å®¹éå¸¸çç¢ (æ‰€ä»¥é©±åŠ¨æ˜¯ bug é‡ç¾åŒºï¼)ï¼Œlx_read() å’Œ lx_write() æ˜¯ read()/write() ç³»ç»Ÿè°ƒç”¨ä¼šä½¿ç”¨çš„é©±åŠ¨å‡½æ•°ã€‚å¦‚æœæˆ‘ä»¬è¯» /dev/nuke0 è¿™ä¸ªè®¾å¤‡ï¼Œä¼šå¾—åˆ° â€œThis is dangerous!\u0026quot;ï¼Œå¦‚æœæˆ‘ä»¬å‘è¿™ä¸ªè®¾å¤‡å†™å…¥æ•°æ®ï¼Œlx_write() ä¼šæ£€æŸ¥å†™å…¥çš„æ•°æ®æ˜¯å¦æ˜¯ SECRETï¼Œå¦‚æœæ˜¯å°±ä¼šæ‰“å°æ ¸å¼¹çˆ†ç‚¸çš„å›¾æ¡ˆã€‚\nä¸ºä»€ä¹ˆ Linux ä¸­æœ‰ä¸¤ç§ ioctl?\nåœ¨å•å¤„ç†å™¨æ—¶ä»£ Linux ä¸­åªæœ‰ ioctlï¼Œåæ¥å¤šå¤„ç†å™¨æ—¶ä»£ Linux å†…æ ¸åŠ è£…äº† big kernel lock (BKL)ï¼Œioctl æ‰§è¡Œæ—¶é»˜è®¤æŒæœ‰ BKLï¼Œä»è€Œé©±åŠ¨çš„æ‰§è¡Œ (æœ¬èº«è¾ƒæ…¢) ä¼šä½¿å¾—å¾ˆå¤šçº¿ç¨‹è¢«é˜»å¡ã€‚åæ¥ Linux æ¨å‡ºäº† unlocked_ioctlï¼Œé«˜æ€§èƒ½çš„é©±åŠ¨å¯ä»¥ä½¿ç”¨è¯¥ ioctl æ¥é¿å…ä¸Šé”ï¼Œå†åæ¥ ioctl è¢«åˆ é™¤ï¼Œåªå‰©ä¸‹ unlocked_ioctlã€‚\ncompact_ioctl æ˜¯åœ¨ 64-bit æœºå™¨çš„å…¼å®¹æ¨¡å¼ä¸‹è¿è¡Œ 32-bit ç¨‹åºæ—¶ä½¿ç”¨çš„ ioctlã€‚\nProgramming for GPU GPU ä½¿ç”¨çš„æ˜¯ä¸€ç§ SIMT (single instruction multiple thread) çš„æ¶æ„ï¼šç›¸å½“äº GPU é‡Œæœ‰å¾ˆå¤šçš„ CPU coreï¼Œæ¯ä¸ª CPU core æœ‰è‡ªå·±çš„å¯„å­˜å™¨ï¼Œcore ä¹‹é—´å…±äº«å†…å­˜ (æ˜¾å­˜)ï¼Œä½†ä½¿ç”¨åŒä¸€ä¸ª \u0026ldquo;PCæŒ‡é’ˆ\u0026rdquo;ã€‚å› æ­¤ GPU é€‚åˆå¤„ç†å¤§é‡è®¡ç®—çš„ç®€å•ä»»åŠ¡ï¼Œä¼—æ ¸çš„ä¼˜åŠ¿å¯ä»¥ä½¿å¾—é‡å¤è®¡ç®—è¢«å¹¶è¡Œåˆ†è§£ã€‚\n// mandelbrot.cu #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #define MAX_ITER 100 #define DIM 12800 static uint32_t colors[MAX_ITER + 1]; static uint32_t data[DIM * DIM]; __device__ uint32_t mandelbrot(double x, double y) { double zr = 0, zi = 0, zrsqr = 0, zisqr = 0; int i; for (i = 0; i \u0026lt; MAX_ITER; i++) { zi = zr * zi * 2 + y; zr = zrsqr - zisqr + x; zrsqr = zr * zr; zisqr = zi * zi; if (zrsqr + zisqr \u0026gt; 4.0) break; } return i; } __global__ void mandelbrot_kernel(uint32_t *data, double xmin, double ymin, double step, uint32_t *colors) { int pix_per_thread = DIM * DIM / (gridDim.x * blockDim.x); int tId = blockDim.x * blockIdx.x + threadIdx.x; int offset = pix_per_thread * tId; for (int i = offset; i \u0026lt; offset + pix_per_thread; i++) { int x = i % DIM; int y = i / DIM; double cr = xmin + x * step; double ci = ymin + y * step; data[y * DIM + x] = colors[mandelbrot(cr, ci)]; } if (gridDim.x * blockDim.x * pix_per_thread \u0026lt; DIM * DIM \u0026amp;\u0026amp; tId \u0026lt; (DIM * DIM) - (blockDim.x * gridDim.x)) { int i = blockDim.x * gridDim.x * pix_per_thread + tId; int x = i % DIM; int y = i / DIM; double cr = xmin + x * step; double ci = ymin + y * step; data[y * DIM + x] = colors[mandelbrot(cr, ci)]; } } int main() { float freq = 6.3 / MAX_ITER; for (int i = 0; i \u0026lt; MAX_ITER; i++) { char r = sin(freq * i + 3) * 127 + 128; char g = sin(freq * i + 5) * 127 + 128; char b = sin(freq * i + 1) * 127 + 128; colors[i] = b + 256 * g + 256 * 256 * r; } colors[MAX_ITER] = 0; uint32_t *dev_colors, *dev_data; cudaMalloc((void**)\u0026amp;dev_colors, sizeof(colors)); cudaMalloc(\u0026amp;dev_data, sizeof(data)); cudaMemcpy(dev_colors, colors, sizeof(colors), cudaMemcpyHostToDevice); double xcen = -0.5, ycen = 0, scale = 3; mandelbrot_kernel\u0026lt;\u0026lt;\u0026lt;512, 512\u0026gt;\u0026gt;\u0026gt;(dev_data, xcen - (scale / 2), ycen - (scale / 2), scale / DIM, dev_colors); cudaMemcpy(data, dev_data, sizeof(data), cudaMemcpyDeviceToHost); cudaFree(dev_data); cudaFree(dev_colors); FILE *fp = fopen(\u0026quot;mandelbrot.ppm\u0026quot;, \u0026quot;w\u0026quot;); fprintf(fp, \u0026quot;P6\\n%d %d 255\\n\u0026quot;, DIM, DIM); for (int i = 0; i \u0026lt; DIM * DIM; i++) { fputc((data[i] \u0026gt;\u0026gt; 16) \u0026amp; 0xff, fp); fputc((data[i] \u0026gt;\u0026gt; 8) \u0026amp; 0xff, fp); fputc((data[i] \u0026gt;\u0026gt; 0) \u0026amp; 0xff, fp); } return 0; } mandelbrot.cu ç»˜åˆ¶äº†ä¸€ä¸ª $12800\\times 12800$ (16äº¿åƒç´ ) çš„å›¾ç‰‡ï¼Œæ¯ä¸ªåƒç´ è¿­ä»£ 100 æ¬¡ã€‚ç¨‹åºä¸­çš„ __device__ ä½¿å¾—ä»£ç å¯ä»¥è¢«ç¼–è¯‘æˆ GPU å¯ä»¥è¿è¡Œçš„è¯­è¨€ã€‚main() å‡½æ•°ä¸­ä½¿ç”¨äº†å‡ ä¸ª cuda çš„ APIï¼šcudaMalloc() åœ¨æ˜¾å­˜ä¸­ç”³è¯·äº†ä¸€äº›ç©ºé—´ï¼ŒcudaMemcpy() æŠŠè®¡ç®—æ‰€éœ€çš„æ•°æ®æ‹·è´äº†è¿‡å» (å½“ç„¶æ˜¯é€šè¿‡ DMA)ï¼ŒcudaFree() é‡Šæ”¾æ˜¾å­˜ç©ºé—´ã€‚è¿™æ ·åºå¤§çš„è®¡ç®—é‡ GPU åªéœ€è¦ 1.7s å·¦å³å°±å¯ä»¥å®Œæˆã€‚\nGPU ä¸Šæœ‰ä¸€å¥—å®Œæ•´çš„å·¥å…·é“¾ï¼šæ¯”å¦‚ gcc \u0026ndash;\u0026gt; nvccï¼Œobjdump \u0026ndash;\u0026gt; cuobjdumpï¼Œgdb \u0026ndash;\u0026gt; cuda-gdbï¼Œperf \u0026ndash;\u0026gt; nvprof ç­‰ç­‰ã€‚å…¨å¥—å·¥å…·é“¾çš„å®ç°éƒ½åœ¨é©±åŠ¨é‡Œï¼Œå› æ­¤ NVIDIA çš„é©±åŠ¨éå¸¸å¤æ‚ã€‚\nAbstraction of Storage Devices å­˜å‚¨è®¾å¤‡å±äºå—è®¾å¤‡ï¼Œæ•°æ®å— (block) æ˜¯è®¿é—®çš„æœ€å°å•å…ƒï¼Œä¸”ä¸æ”¯æŒä»»æ„çš„éšæœºè®¿é—®ã€‚åº”ç”¨ç¨‹åºé€šå¸¸é€šè¿‡æ–‡ä»¶ç³»ç»Ÿæ¥è¯»å†™å­˜å‚¨è®¾å¤‡ã€‚\nLinux çš„ bio (Block I/O) layer æ˜¯æ–‡ä»¶ç³»ç»Ÿå’Œç£ç›˜è®¾å¤‡ä¹‹é—´çš„æ¥å£ã€‚é€šå¸¸ä¸€æ¬¡ç£ç›˜è®¿é—®ä¼šåŒ…æ‹¬å¤šä¸ªå—çš„è¯»/å†™ï¼Œå› æ­¤ bio layer ä¸­å¯ä»¥æœ‰ä¸€äº›è°ƒåº¦ç­–ç•¥ï¼Œæ¯”å¦‚ Linux æ€»æ˜¯ä¼˜å…ˆæ»¡è¶³ read æ“ä½œ (å› ä¸ºæ‰§è¡Œ read çš„ç¨‹åºä¸€èˆ¬æ€»æ˜¯ä¾èµ–æ•°æ®ç»§ç»­æ‰§è¡Œ)ï¼Œå»¶ç¼“ write æ“ä½œ (åªè¦æ²¡æœ‰è¶…è¿‡ ddl)ã€‚\nç®€å•æ¥è¯´ï¼Œblock I/O layer çš„ API æ˜¯ bread()ï¼Œbwrite() å’Œ bflush()ï¼Œå…¶ä¸­æœ€åä¸€ä¸ªç”¨äºå¤„ç†ä¸€äº›åŒæ­¥é—®é¢˜ã€‚æˆ‘ä»¬çš„æ–‡ä»¶ç³»ç»Ÿå°±æ˜¯åœ¨ bio API çš„åŸºç¡€ä¸Šæ„å»ºä¸€ä¸ªæŒä¹…æ•°æ®ç»“æ„ï¼Œå¹¶å‘ä¸Šå±‚åº”ç”¨æä¾›æ›´ç®€å•æ˜“ç”¨çš„æ¥å£ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"509635abc2a3ad8d0b31b0525156b323","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec25/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec25/","section":"notes","summary":"åœ¨æ“ä½œç³»ç»Ÿçœ¼é‡Œï¼ŒI/O è®¾å¤‡ = ä¸€ç»„å¯„å­˜å™¨ + ä¸€ä¸ªæ§åˆ¶åè®®ã€‚ä¸åŒè®¾å¤‡çš„æ§åˆ¶åè®®åƒå·®ä¸‡åˆ«ï¼Œå¦‚æœè®©è½¯ä»¶ç›´æ¥å’Œè¿™äº›è®¾å¤‡å¯„å­˜å™¨æ‰“äº¤é“ï¼Œå³ä½¿æ“ä½œç³»ç»Ÿä»”ç»†åœ°ç®¡ç†å¥½è®¿é—®æƒé™ï¼Œåº”ç”¨ç¨‹åºä¹Ÿå¾ˆå®¹æ˜“å‡ºé”™ã€‚æ‰€ä»¥æˆ‘ä»¬çš„æƒ³æ³•æ˜¯ï¼šå¯¹ä¸åŒçš„è®¾å¤‡åšä¸€ä¸ªæŠ½è±¡ï¼Œä½¿å¾—ä¸Šå±‚åº”ç”¨å¯ä»¥é€šè¿‡å°½å¯èƒ½ç»Ÿä¸€çš„æ¥å£æ¥è®¿é—®è®¾å¤‡ã€‚\nOverview I/O è®¾å¤‡æœ€åŸºæœ¬çš„éœ€æ±‚å°±æ˜¯ read å’Œ writeã€‚UNIX ä¸–ç•Œé‡Œçš„è®¾å¤‡é€šå¸¸åˆ†ä¸ºä¸¤ç§ï¼š\nå­—ç¬¦è®¾å¤‡ (character device)ï¼Œè®¾å¤‡ä¸ OS ä¹‹é—´ä¼ é€çš„æ˜¯å­—èŠ‚æµã€‚æˆ‘ä»¬å¯ä»¥æŠŠè¿™ç§è®¾å¤‡æƒ³è±¡æˆä¸€ä¸ªç®¡é“ã€‚ç»ˆç«¯ã€æ‰“å°æœºç­‰éƒ½æ˜¯å…¸å‹çš„å­—ç¬¦è®¾å¤‡ã€‚\nå—è®¾å¤‡ (block device)ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠè¿™ç§è®¾å¤‡æƒ³è±¡æˆä¸€ä¸ªå­—ç¬¦æ•°ç»„ï¼Œè¿™æ ·çš„è®¾å¤‡é€šå¸¸æœ‰ persistence çš„éœ€æ±‚ï¼Œæ¯”å¦‚ç£ç›˜ã€‚\næ˜¾å¡æ˜¯ä¸€ç§ä»€ä¹ˆæ ·çš„è®¾å¤‡ï¼Ÿ\næ˜¾å¡ä¸­å…¶å®æ—¢æœ‰å­—èŠ‚æµ (æ¯”å¦‚æ§åˆ¶ä¿¡å·ä¿®æ”¹æ˜¾å¡çš„å‚æ•°)ï¼Œåˆæœ‰å­—èŠ‚æ•°ç»„ (æ˜¾å¡é‡Œé¢æœ‰æ˜¾å­˜)ã€‚(ä¸è¿‡æ˜¾å­˜ä¸æ˜¯æŒ‰ç…§å—è®¾å¤‡çš„æ–¹å¼æ¥æŠ½è±¡çš„)\næ“ä½œ I/O è®¾å¤‡ï¼Œæˆ‘ä»¬è‡³å°‘éœ€è¦å¦‚ä¸‹çš„ä¸‰ä¸ª APIï¼š","tags":null,"title":"Lecture 25: Device Drivers","type":"docs"},{"authors":null,"categories":null,"content":"Why File System? å¦‚æœè®¾å¤‡ç›´æ¥å°†è¯»/å†™/æ§åˆ¶çš„æ¥å£æš´éœ²ç»™åº”ç”¨ç¨‹åºï¼Œé‚£ä¹ˆå¤šä¸ªåº”ç”¨ç¨‹åºåœ¨å¹¶å‘åœ°ä½¿ç”¨è®¾å¤‡æ—¶å¾ˆå®¹æ˜“å‘ç”Ÿç«äº‰ã€‚æˆ‘ä»¬è€ƒè™‘ä¸‹é¢çš„ä¾‹å­ï¼š\n// printf-race.c #include \u0026lt;stdio.h\u0026gt; #include \u0026quot;thread.h\u0026quot; void use_printf(const char *s) { printf(\u0026quot;%s\u0026quot;, s); } void use_putchar(const char *s) { for (; *s; s++) { putchar(*s); } } void (*print)(const char *) = use_printf; void Tworker() { char buf[128]; int c = gettid() % 4 + 1; sprintf(buf, \u0026quot;\\033[3%dm%d\\033[0m\u0026quot;, c, c); while (1) { print(buf); } } int main(int argc, char *argv[]) { if (argc \u0026gt; 1) { print = use_putchar; } setbuf(stdout, NULL); for (int i = 0; i \u0026lt; 4; i++) { create(Tworker); } } åœ¨ printf-race.c ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº† 4 ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªçº¿ç¨‹é€šè¿‡ ANSI Escape Code ç”¨æŸç§é¢œè‰²æ‰“å°è‡ªå·±çš„çº¿ç¨‹å·ã€‚å¦‚æœæˆ‘ä»¬ç›´æ¥è¿è¡Œ ./printf-raceï¼Œçº¿ç¨‹ä¼šä½¿ç”¨ use_printf() è°ƒç”¨åº“å‡½æ•° printf() è¾“å‡ºï¼Œè¿™æ—¶æˆ‘ä»¬èƒ½çœ‹åˆ°æ­£ç¡®çš„ç»“æœã€‚ä½†å¦‚æœæˆ‘ä»¬è¿è¡Œæ—¶æ·»ä¸Šä¸€ä¸ªå‚æ•°ï¼Œæ¯”å¦‚ ./printf-race xxxï¼Œé‚£ä¹ˆçº¿ç¨‹ä¼šä½¿ç”¨ use_putchar() è¾“å‡ºï¼Œè¿™æ—¶æˆ‘ä»¬å°±ä¼šçœ‹åˆ°å¤§é‡çš„é”™è¯¯è¾“å‡ºã€‚äº§ç”Ÿé”™è¯¯çš„åŸå› æ˜¯ï¼šå½“ 4 ä¸ªçº¿ç¨‹å¹¶å‘/å¹¶è¡Œåœ°ä½¿ç”¨ putchar() è¾“å‡ºæ—¶ï¼Œå®ƒä»¬çš„è¾“å‡ºå†…å®¹æ˜¯äº¤ç»‡åœ¨ä¸€èµ·çš„ï¼Œè¿™å°±ä¼šå¯¼è‡´ Escape Code è¢«éš”æ–­ï¼Œä»è€Œäº§ç”Ÿé¢„æœŸä¹‹å¤–çš„ç»“æœã€‚printf() å‡½æ•°ä½¿ç”¨ write ç³»ç»Ÿè°ƒç”¨æ¥è¾“å‡ºç»™å®šå†…å®¹ï¼Œwrite ç³»ç»Ÿè°ƒç”¨ä¿è¯äº†å®ƒè¾“å‡ºæ‰€æœ‰å†…å®¹è¿™ä¸ªåŠ¨ä½œæ˜¯åŸå­çš„ã€‚\nå³ä½¿æˆ‘ä»¬åœ¨è®¾å¤‡ä¸Šé¢å°è£…ä¸€å±‚æœ‰åŸå­æ€§çš„ APIï¼Œå¯¹äºå—è®¾å¤‡æˆ‘ä»¬ä»ç„¶æœ‰éš¾ä»¥è§£å†³çš„é—®é¢˜ï¼šå¤šä¸ªåº”ç”¨ç¨‹åºéƒ½éœ€è¦ä»ç£ç›˜ä¸­è¯»å†™æ•°æ®ï¼Œè¿™å°±åƒå…¨ç­äººè¦åœ¨ä¸€å¼ å¾ˆå¤§çš„çº¸ä¸Šå„è‡ªå†™ä½œä¸šï¼Œé‚£ä¹ˆå¦‚ä½•ä¿è¯å¤§å®¶å†™çš„å†…å®¹ä¸ä¼šäº’ç›¸è¦†ç›–ï¼Ÿå¯¹äºç³»ç»Ÿæ¥è¯´ï¼Œå¦‚æœä¸€ä¸ªç¨‹åºå‡ºäº† bug ä¼šæŠŠæ•´ä¸ªç£ç›˜å…¨éƒ¨å†™ä¸Šåƒåœ¾ï¼Œé‚£å°±æ²¡å¾—ç©äº†ã€‚\nå¤šä¸ªè¿›ç¨‹å¹¶å‘åœ°ä½¿ç”¨å†…å­˜ä¼šå¯¼è‡´éš”ç¦»è¢«æ‰“ç ´ï¼Œæˆ‘ä»¬å¼•å…¥äº†è™šæ‹Ÿå†…å­˜ï¼Œç»™æ¯ä¸ªè¿›ç¨‹ä¸€ä¸ªè™šæ‹Ÿåœ°å€ç©ºé—´ã€‚åœ¨è¿™é‡Œæˆ‘ä»¬çš„æ€æƒ³æ˜¯ç›¸ä¼¼çš„ï¼šæ–‡ä»¶ç³»ç»Ÿå‘ä¸‹å’Œç‰©ç†è®¾å¤‡ (ç£ç›˜) æ‰“äº¤é“ï¼Œå‘ä¸Šä¸ºæ¯ä¸ªç¨‹åºæä¾›ä¸€ä¸ªè™šæ‹Ÿç£ç›˜ã€‚è™šæ‹Ÿç£ç›˜å°±æ˜¯ä¸€ä¸ªå¯ä»¥è¯»å†™çš„åŠ¨æ€å­—èŠ‚åºåˆ—ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥æŠŠå®ƒæƒ³è±¡æˆä¸€ä¸ª vector\u0026lt;char\u0026gt;ã€‚æ–‡ä»¶ç³»ç»Ÿä¸ä»…éœ€è¦ç»´æŠ¤è¿™äº› vectorï¼Œè¿˜è¦è´Ÿè´£ç®¡ç†è™šæ‹Ÿç£ç›˜çš„åç§°ï¼Œè´Ÿè´£æ£€ç´¢å’Œéå†ã€‚\nVirtual Disk: Naming and Management ç»´æŠ¤è™šæ‹Ÿç£ç›˜æœ€ç®€å•çš„æ–¹æ³•å°±æ˜¯å­˜å‚¨ä¸€å † åå­—-vector\u0026lt;char\u0026gt; çš„é”®å€¼å¯¹ã€‚ä½†è¿™æ ·çš„å½¢å¼éå¸¸ä¸åˆ©äºå¿«é€Ÿæ£€ç´¢ã€‚å› æ­¤æ–‡ä»¶ç³»ç»Ÿé‡‡å–äº†æ ‘å½¢ç»“æ„ã€‚\nWindows çš„æ–‡ä»¶ç³»ç»Ÿä¸­ï¼Œæ¯ä¸ªè®¾å¤‡é©±åŠ¨å™¨æ˜¯ä¸€æ£µæ ‘ï¼Œä¾‹å¦‚ C ç›˜ï¼ŒD ç›˜ç­‰ã€‚æ‰€è°“çš„ â€œC ç›˜æ ¹ç›®å½•â€ å°±æ˜¯ C:\\ï¼Œæ ¹ç›®å½•ä¸‹é¢å¯ä»¥æ„å»ºä¸€ä¸ªé”™ç»¼å¤æ‚çš„æ–‡ä»¶æ ‘ã€‚å¦‚æœæ’å…¥äº† U ç›˜ç­‰å¤–è®¾ï¼Œç³»ç»Ÿä¼šä¸ºå®ƒåˆ†é…ä¸€ä¸ªæ–°çš„ç›˜ç¬¦ã€‚\nä¸ºä»€ä¹ˆæ²¡æœ‰ A:\\ å’Œ B:\\ï¼Ÿ\nA ç›˜å’Œ B ç›˜æ˜¯æ›¾ç»çš„è½¯ç›˜ã€‚\nUNIX/Linux çš„æ–‡ä»¶æ ‘å’Œ Windows ä¸åŒã€‚Linux ä¸­åªæœ‰ä¸€ä¸ªæ ¹ /ï¼Œæ›´å¤šçš„è®¾å¤‡ä¾é  Linux çš„æŒ‚è½½æœºåˆ¶è®¿é—®ã€‚Linux çš„æŒ‚è½½ç±»ä¼¼äºâ€œç›®å½•æ ‘çš„æ‹¼æ¥â€ï¼Œå¯ä»¥æŒ‡å®šä¸€ä¸ªç›®å½•ï¼Œå°†ä¸€ä¸ªè®¾å¤‡çš„ç›®å½•æ ‘æŒ‚åˆ°è¯¥ç›®å½•ä¸‹é¢ã€‚æ¯”å¦‚å½“å‰æˆ‘ä»¬æœ‰ä¸€ä¸ª disk.img æ–‡ä»¶ï¼Œåˆ™æˆ‘ä»¬ä½¿ç”¨\nsudo mount disk.img /mnt ä¹‹åï¼Œä½¿ç”¨ tree /mnt å°±å¯ä»¥çœ‹åˆ°ç£ç›˜é•œåƒ disk.img å†…çš„ç›®å½•æ ‘ç»“æ„ã€‚\nLinux çš„ mount å‘½ä»¤åŸºäº mount ç³»ç»Ÿè°ƒç”¨å®ç°ï¼š\nint mount(const char *source, const char *target, const char *filesystemtype, unsigned long mountflags, const void *data); mount ç³»ç»Ÿè°ƒç”¨çš„æ¥å£æ›´åŠ å¤æ‚ï¼Œé™¤äº†è¦æŒ‡å®š source å’Œ target å¤–ï¼Œè¿˜è¦æŒ‡å®šæ–‡ä»¶ç³»ç»Ÿçš„ç±»å‹ï¼ŒæŒ‚è½½æ ‡å¿—ä½ç­‰ç­‰ã€‚Linux çš„ mount å‘½ä»¤ä½¿ç”¨èµ·æ¥å®¹æ˜“ä¸€äº›ï¼Œå› ä¸ºå®ƒå¯ä»¥è‡ªåŠ¨ç›‘æµ‹æ–‡ä»¶ç³»ç»Ÿ (busybox çš„ mount æ²¡æœ‰è¿™ä¸ªåŠŸèƒ½)ã€‚\näº‹å®ä¸Šï¼ŒçœŸæ­£çš„ Linux å¯åŠ¨çš„è¿‡ç¨‹ä¸­ä¹Ÿæ˜¯é€šè¿‡æŒ‚è½½å®Œæˆäº†æ–‡ä»¶ç³»ç»Ÿçš„åˆå§‹åŒ–ã€‚æˆ‘ä»¬åœ¨ Linux-minimal é‡Œé¢æ¨¡æ‹Ÿäº†è¿™ä¸ªè¿‡ç¨‹ï¼šæˆ‘ä»¬ç”¨ qemu å¯åŠ¨çš„ Linux å†…æ ¸åªåŒ…å«ä¸€ä¸ªéå¸¸å°çš„â€œæ–‡ä»¶ç³»ç»Ÿ\u0026quot; initramfsï¼Œè¿™ä¸ªæ–‡ä»¶ç³»ç»Ÿåªæœ‰éå¸¸å°‘çš„ä¸€äº›æ–‡ä»¶ï¼Œè€Œä¸”æ˜¯å­˜æ”¾åœ¨å†…å­˜ä¸­çš„ã€‚æˆ‘ä»¬çš„ Linux-minimal åšäº†è¿™æ ·ä¸€ä¸ªæµç¨‹ï¼š\nexport PATH=/bin busybox mknod /dev/sda b 8 0 busybox mkdir -p /newroot busybox mount -t ext2 /dev/sda /newroot exec busybox switch_root /newroot/ /etc/init å…¶ä¸­ç¬¬äºŒè¡Œçš„å‘½ä»¤ä½¿ç”¨ mknod åˆ›å»ºäº†ä¸€ä¸ªè®¾å¤‡æ–‡ä»¶ /dev/sdaï¼Œä¹Ÿå°±æ˜¯çœŸæ­£çš„ç£ç›˜ã€‚ç¬¬ä¸‰ä¸ªå‘½ä»¤åˆ›å»ºäº†ä¸€ä¸ªç›®å½• /newroot (åœ¨ initramfs ä¸­)ï¼Œç„¶åæˆ‘ä»¬ç”¨ mount å‘½ä»¤å°†ç£ç›˜æŒ‚è½½åˆ°äº† /newroot ä¸Šï¼Œè¿™æ—¶å€™æˆ‘ä»¬çš„ /newroot å…¶å®å°±æ˜¯çœŸæ­£æ„ä¹‰ä¸Šçš„æ ¹ç›®å½•äº†ã€‚æœ€åæˆ‘ä»¬é€šè¿‡ switch_root å‘½ä»¤æŠŠ / åˆ‡æ¢åˆ° /newroot ä¸Šï¼Œå¹¶åˆ é™¤ initramfs ä¸­çš„å‰©ä¸‹é‚£äº›å¤šä½™çš„ä¸œè¥¿ã€‚\nä¸€ä¸ªæ¯”è¾ƒå¾®å¦™çš„é—®é¢˜æ˜¯ï¼šæˆ‘ä»¬å¯¹æ–‡ä»¶çš„æŠ½è±¡æ˜¯ç£ç›˜ä¸Šçš„ä¸€ä¸ªè™šæ‹Ÿç£ç›˜ï¼Œè¿™ä¸ªè™šæ‹Ÿç£ç›˜æ˜¯åœ¨çœŸå®ç‰©ç†ç£ç›˜ä¸Šè™šæ‹Ÿå‡ºæ¥çš„ã€‚ä½†å¦‚æœæˆ‘ä»¬åšæŒ‚è½½ï¼Œé‚£ä¹ˆè¢«æŒ‚è½½ç›®å½•çš„è™šæ‹Ÿç£ç›˜å°±ä¸æ˜¯åœ¨çœŸå®ç‰©ç†ç£ç›˜ä¸Šè™šæ‹Ÿå‡ºæ¥çš„ï¼Œè€Œæ˜¯åœ¨ä¸€ä¸ªè™šæ‹Ÿç£ç›˜ (æ¯”å¦‚ disk.img) ä¸Šè™šæ‹Ÿå‡ºçš„è™šæ‹Ÿç£ç›˜ï¼ŒåµŒå¥—äº†ä¸¤å±‚ã€‚ç‰©ç†ç£ç›˜ä¸Šçš„è™šæ‹Ÿç£ç›˜å’Œè™šæ‹Ÿç£ç›˜ä¸Šçš„è™šæ‹Ÿç£ç›˜æ˜¾ç„¶åº”è¯¥æœ‰ä¸€äº›åŒºåˆ«ã€‚Linux çš„å¤„ç†æ–¹å¼æ˜¯åˆ›å»ºä¸€ä¸ª loopback (å›ç¯) è®¾å¤‡ã€‚å›ç¯è®¾å¤‡çš„é©±åŠ¨ä¼šæŠŠå¯¹è®¾å¤‡çš„ read/write æ“ä½œè½¬åŒ–ä¸ºå¯¹æ–‡ä»¶çš„ read/write æ“ä½œã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ strace æ¥è¿‘è·ç¦»è§‚å¯Ÿ mount çš„è¿‡ç¨‹ï¼š\nopenat(AT_FDCWD, \u0026quot;/dev/loop-control\u0026quot;, O_RDWR | O_CLOEXEC) = 3 ioctl(3, LOOP_CTL_GET_FREE) = 1 close(3) å½“ Linux æƒ³è¦åˆ›å»ºä¸€ä¸ªå›ç¯è®¾å¤‡æ—¶ï¼Œå®ƒä¼šå…ˆæ‰“å¼€è®¾å¤‡ /dev/loop-controlï¼Œç„¶åé€šè¿‡ ioctl è·å–ä¸€ä¸ªå½“å‰ç©ºé—²çš„å›ç¯è®¾å¤‡å·ã€‚è¿™é‡Œçš„è¿”å›å€¼æ˜¯ 1ï¼Œæ‰€ä»¥å¾…ä¼šå„¿åˆ›å»ºçš„å›ç¯è®¾å¤‡å°±æ˜¯ /dev/loop1ã€‚\nopenat(AT_FDCWD, \u0026quot;/tmp/demo/disk.img\u0026quot;, O_RDWR | O_CLOEXEC) = 3 openat(AT_FDCWD, \u0026quot;/dev/loop1\u0026quot;, O_RDWR | O_CLOEXEC) = 4 ioctl(4, LOOP_SED_FD, 3) å¯ä»¥çœ‹åˆ°ï¼Œå›ç¯è®¾å¤‡æŒæœ‰æ–‡ä»¶æè¿°ç¬¦ 4ï¼ŒLinux é€šè¿‡ä¸€ä¸ª ioctl ç³»ç»Ÿè°ƒç”¨å°†å…¶æŒ‡å‘äº† disk.img å¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦ã€‚è¿™æ ·åç»­å¯¹å›ç¯è®¾å¤‡çš„è¯»å†™æ“ä½œä¼šç¿»è¯‘æˆå¯¹ disk.img æ–‡ä»¶çš„è¯»å†™æ“ä½œã€‚\nDirectory API (System Calls) åˆ›å»ºä¸€ä¸ªç›®å½•ï¼šmkdir ç³»ç»Ÿè°ƒç”¨ï¼ŒåŒæ—¶å¯ä»¥è®¾ç½®è®¿é—®æƒé™ åˆ é™¤ä¸€ä¸ªç›®å½•ï¼šrmdir ç³»ç»Ÿè°ƒç”¨ã€‚æ³¨æ„ UNIX ä¸­æ²¡æœ‰â€œé€’å½’åˆ é™¤â€çš„ç³»ç»Ÿè°ƒç”¨ã€‚æ¯•ç«Ÿå¯ä»¥äº¤ç»™è½¯ä»¶åšçš„äº‹æƒ…å°±ä¸éœ€è¦äº¤ç»™æ“ä½œç³»ç»Ÿäº†ã€‚rm -rf ä¼šéå†ç›®å½•é€’å½’åˆ é™¤ã€‚ éå†ä¸€ä¸ªç›®å½•ï¼šgetdents ç³»ç»Ÿè°ƒç”¨ã€‚getdents åœ¨ glibc ä¸­æ²¡æœ‰å°è£…å¥½çš„åŒååº“å‡½æ•°ã€‚ä½†æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ readdir() å‡½æ•°ã€‚ Linux ä¸­çš„ä¸€ä¸ªæœ‰è¶£çš„æœºåˆ¶æ˜¯é“¾æ¥ã€‚Linux ä¸­çš„é“¾æ¥åˆ†ç¡¬é“¾æ¥å’Œè½¯é“¾æ¥ä¸¤ç§ã€‚\nå¦‚æœæˆ‘ä»¬å¯¹ä¸€ä¸ªæ–‡ä»¶åˆ›å»ºä¸€ä¸ªç¡¬é“¾æ¥ï¼Œé‚£ä¹ˆè¿™ç›¸å½“äºåˆ›å»ºäº†ä¸¤ä¸ªâ€œæŒ‡é’ˆâ€ (æ–‡ä»¶å)ï¼Œå®ƒä»¬æŒ‡å‘åŒä¸€ä¸ªæ–‡ä»¶å®ä½“ã€‚å¦‚æœä¿®æ”¹äº†ä¸€ä¸ªå¦ä¸€ä¸ªå‘ˆç°çš„å†…å®¹ä¹Ÿä¼šå˜ã€‚å¦‚æœæˆ‘ä»¬ç”¨ ls -i æŸ¥çœ‹ä¸¤ä¸ªæ–‡ä»¶çš„ inode å·ï¼Œæˆ‘ä»¬ä¼šå‘ç°ç¡¬é“¾æ¥çš„ inode å·å’ŒåŸæ–‡ä»¶æ˜¯ä¸€æ ·çš„ã€‚äº‹å®ä¸Šï¼Œåœ¨ç¡¬é“¾æ¥åˆ›å»ºåï¼Œæˆ‘ä»¬æ— æ³•åŒºåˆ†å‡ºå“ªä¸ªæ˜¯åŸä½“é‚£ä¸ªæ˜¯åå¤åˆ¶çš„ã€‚æˆ‘ä»¬å¯ä»¥åœ¨ Linux ä¸­é€šè¿‡ ln a b åˆ›å»ºç¡¬é“¾æ¥ã€‚\nè½¯é“¾æ¥ç›¸å½“äºä¸€ä¸ªâ€œå¿«æ·æ–¹å¼â€ï¼Œå½“æˆ‘ä»¬è®¿é—®è¿™ä¸ªæ–‡ä»¶æ—¶ï¼Œå…¶å®ä¼šè·³è½¬å»è®¿é—®å¦ä¸€ä¸ªæ–‡ä»¶ã€‚è½¯é“¾æ¥çš„ä½¿ç”¨éå¸¸çµæ´»ï¼Œå®ƒå¯ä»¥é“¾æ¥åˆ°ä¸€ä¸ªç›®å½• (ç¡¬é“¾æ¥åªèƒ½é“¾æ¥æ–‡ä»¶)ï¼Œå¯ä»¥è·¨æ–‡ä»¶ç³»ç»Ÿï¼Œç”šè‡³å¯ä»¥é“¾æ¥åˆ°ä¸€ä¸ªå½“å‰ä¸å­˜åœ¨çš„ç›®å½•ã€‚æˆ‘ä»¬å¯ä»¥åœ¨ Linux ä¸­é€šè¿‡ ln -s a b åˆ›å»ºè½¯é“¾æ¥ã€‚\nè½¯é“¾æ¥çš„ä»»æ„æ€§å’Œçµæ´»æ€§ä½¿å¾—æˆ‘ä»¬çš„æ–‡ä»¶æ ‘å˜æˆäº†ä¸€ä¸ªæ–‡ä»¶å›¾ï¼Œå®ƒç”šè‡³å¯ä»¥æˆç¯ï¼š\n#!/bin/bash # fish-dir.sh # Create directories mkdir -p A B C D E F # Create automaton ln -s ../B 'A/\u0026lt;' ln -s ../C 'B/\u0026gt;' ln -s ../D 'C/\u0026lt;' ln -s ../E 'A/\u0026gt;' ln -s ../F 'E/\u0026lt;' ln -s ../D 'F/\u0026gt;' ln -s ../A 'D/_' æˆ‘ä»¬å¯ä»¥åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­é€šè¿‡è½¯é“¾æ¥åˆ›å»ºä¸€ä¸ªä¹‹å‰ fish.c ä¸­çš„è‡ªåŠ¨æœºã€‚é€šè¿‡è®¿é—®ç›®å½•æ¥æ¨¡æ‹Ÿè½¬ç§»ã€‚\næ¯ä¸ªè¿›ç¨‹éƒ½æœ‰ä¸€ä¸ªå½“å‰çš„å·¥ä½œç›®å½•ï¼Œå¯ä»¥ç”¨ pwd å‘½ä»¤æŸ¥çœ‹ã€‚å¦‚æœæƒ³è¦ä¿®æ”¹å½“å‰å·¥ä½œç›®å½•ï¼Œåˆ™è¦ä½¿ç”¨ chdir ç³»ç»Ÿè°ƒç”¨ã€‚ä¸€ä¸ªæœ‰è¶£çš„äº‹æƒ…æ˜¯ï¼šåƒ cat, ls ç­‰å‘½ä»¤åœ¨ /bin ä¸‹éƒ½æœ‰å¯¹åº”çš„å¯æ‰§è¡Œæ–‡ä»¶ï¼Œä½† cd æ˜¯æ²¡æœ‰çš„ï¼Œè¿™æ˜¯å› ä¸º cd æ˜¯ä¸€ä¸ª shell å†…ç½®çš„å‘½ä»¤â€”â€”åŸºæœ¬ä¸Šæ‰€æœ‰çš„å‘½ä»¤éƒ½æ˜¯å…ˆ fork å‡ºä¸€ä¸ªå­è¿›ç¨‹å†æ‰§è¡Œå‘½ä»¤å¯¹åº”çš„å¯æ‰§è¡Œæ–‡ä»¶ï¼Œä½† cd å‘½ä»¤è¦ä¿®æ”¹çš„æ˜¯å½“å‰è¿›ç¨‹çš„å·¥ä½œç›®å½•ï¼Œæ˜¾ç„¶ä¸èƒ½ç”¨è¿™ç§ fork çš„æ–¹å¼ã€‚\nä¸€ä¸ªè¿›ç¨‹ä¸‹çš„å¤šä¸ªçº¿ç¨‹æ˜¯å…±äº« working directoryï¼Œè¿˜æ˜¯çº¿ç¨‹ä¹‹é—´ç‹¬ç«‹ï¼Ÿ\nworking directory æ˜¯ä¸€ä¸ªç¯å¢ƒå˜é‡ $PWDï¼Œç¯å¢ƒå˜é‡æ˜¯æ¯ä¸ªè¿›ç¨‹ä¸€ä»½ï¼Œå› æ­¤çº¿ç¨‹ä¹‹é—´å…±äº« working directoryã€‚\nFile API (System Calls) æˆ‘ä»¬é€šè¿‡ open/pipe ç­‰ç³»ç»Ÿè°ƒç”¨å¯ä»¥è·å¾—æ–‡ä»¶æè¿°ç¬¦ã€‚æ–‡ä»¶æè¿°ç¬¦å¯ä»¥ç†è§£ä¸ºæŒ‡å‘æ–‡ä»¶çš„æŒ‡é’ˆï¼Œä¾›è¿›ç¨‹è®¿é—®ã€‚äº‹å®ä¸Šï¼Œæ–‡ä»¶æè¿°ç¬¦é‡Œè¿˜ä¿å­˜äº†å½“å‰è®¿é—®æ–‡ä»¶çš„åç§»é‡ï¼Œæ¯”å¦‚\nint fd = open(\u0026quot;a.txt\u0026quot;, O_RDWR | O_TRUNC); read(fd, buf, 512); read(fd, buf, 512) ç¬¬ä¸€æ¬¡ read è¯»åˆ°çš„æ˜¯å‰ 512 å­—èŠ‚ï¼Œç¬¬äºŒæ¬¡ read è¯»åˆ°çš„å°±æ˜¯å 512 å­—èŠ‚ã€‚lseek ç³»ç»Ÿè°ƒç”¨å¯ä»¥ä¿®æ”¹å½“å‰çš„æ–‡ä»¶åç§»é‡ã€‚\nåç§»é‡çš„ç®¡ç†å…¶å®æœ‰å¾ˆå¤šçš„å¤æ‚æ€§ï¼šæ¯”å¦‚æˆ‘ä»¬çŸ¥é“ fork æ—¶å­è¿›ç¨‹ä¼šç»§æ‰¿çˆ¶è¿›ç¨‹çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œé‚£ä¹ˆå¦‚æœ fork ä¹‹åçˆ¶è¿›ç¨‹å‘æ–‡ä»¶å†™å…¥ parentï¼Œå­è¿›ç¨‹å‘æ–‡ä»¶å†™å…¥ childï¼Œæˆ‘ä»¬æ˜¾ç„¶ä¸å¸Œæœ›è·å¾— \u0026ldquo;childt\u0026rdquo;ï¼Œå› æ­¤åœ¨ fork çš„è®¾è®¡ä¸­ï¼Œçˆ¶å­è¿›ç¨‹çš„æ–‡ä»¶æè¿°ç¬¦å…±äº«åç§»é‡ã€‚æ­¤å¤–ï¼Œæ“ä½œç³»ç»Ÿçš„æ¯ä¸ª API éƒ½å¯èƒ½å’Œå…¶ä»– API äº¤äº’ï¼Œopen, execve, dup ç­‰ç³»ç»Ÿå—²ç”¨ä¸­åç§»é‡çš„è¡Œä¸ºå„ä¸ç›¸åŒï¼Œopen ç”šè‡³æä¾›äº†ä¸€å¤§å † flag è®¾ç½®åç§»é‡çš„è¡Œä¸ºã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"493ef6496cb0af17dbc31e14628ea367","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec26/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec26/","section":"notes","summary":"Why File System? å¦‚æœè®¾å¤‡ç›´æ¥å°†è¯»/å†™/æ§åˆ¶çš„æ¥å£æš´éœ²ç»™åº”ç”¨ç¨‹åºï¼Œé‚£ä¹ˆå¤šä¸ªåº”ç”¨ç¨‹åºåœ¨å¹¶å‘åœ°ä½¿ç”¨è®¾å¤‡æ—¶å¾ˆå®¹æ˜“å‘ç”Ÿç«äº‰ã€‚æˆ‘ä»¬è€ƒè™‘ä¸‹é¢çš„ä¾‹å­ï¼š\n// printf-race.c #include \u0026lt;stdio.h\u0026gt; #include \u0026quot;thread.h\u0026quot; void use_printf(const char *s) { printf(\u0026quot;%s\u0026quot;, s); } void use_putchar(const char *s) { for (; *s; s++) { putchar(*s); } } void (*print)(const char *) = use_printf; void Tworker() { char buf[128]; int c = gettid() % 4 + 1; sprintf(buf, \u0026quot;\\033[3%dm%d\\033[0m\u0026quot;, c, c); while (1) { print(buf); } } int main(int argc, char *argv[]) { if (argc \u0026gt; 1) { print = use_putchar; } setbuf(stdout, NULL); for (int i = 0; i \u0026lt; 4; i++) { create(Tworker); } } åœ¨ printf-race.","tags":null,"title":"Lecture 26: File System API","type":"docs"},{"authors":null,"categories":null,"content":"æ•°æ®ç»“æ„è¯¾çš„ä¸€äº›æ½œè—çš„å‡è®¾ï¼š\nrandom access memoryï¼Œword addressing (ä¸åŒäºç£ç›˜ï¼Œç£ç›˜æ˜¯ä»¥å—ä¸ºå•ä½è®¿é—®çš„) load/store æŒ‡ä»¤å’Œè®¡ç®—æŒ‡ä»¤æ‰§è¡Œçš„ä»£ä»·éƒ½æ˜¯ $O(1)$ã€‚ åœ¨å—è®¾å¤‡ä¸­ï¼Œå³ä½¿è®¿é—®ä¸€ä¸ª byte ä¹Ÿéœ€è¦å°†å®ƒæ‰€åœ¨çš„ä¸€æ•´ä¸ª block æ‹¿å‡ºæ¥ï¼Œå› æ­¤å†…å­˜ä¸­çš„æ•°æ®ç»“æ„ç”¨åœ¨ç£ç›˜ä¸Šä¼šé€ æˆæå¤§çš„æ€§èƒ½é—®é¢˜ã€‚\nå—è®¾å¤‡æä¾›çš„è®¾å¤‡æŠ½è±¡ï¼š\nstruct block blocks[NBLK]; // ç£ç›˜ void bread(int id, struct block *buf) { memcpy(buf, \u0026amp;blocks[id], sizeof(struct block)); } void bwrite(int id, const struct block *buf) { memcpy(\u0026amp;blocks[id], buf, sizeof(struct block)); } bread() å°†ç£ç›˜ä¸­çš„ä¸€ä¸ªå—æ‹‰åˆ°å†…å­˜é‡Œï¼Œbwrite() å°†å†…å­˜ä¸­çš„ä¸€ä¸ªå—å†™å…¥ç£ç›˜ã€‚\næˆ‘ä»¬çš„æ–‡ä»¶ç³»ç»Ÿåœ¨ bread()/bwrite() ä¸Šä¸€å±‚å±‚æŠ½è±¡å‡ºæ¥ï¼š\næˆ‘ä»¬å¯ä»¥åœ¨ read/write ä¸Šå®ç°ä¸¤ä¸ª APIï¼šballoc() å’Œ bfree()ï¼Œè¿™æ ·æˆ‘ä»¬å°±æŠŠæ•´ä¸ªç£ç›˜ä¸­æ‰€æœ‰çš„å—ç®¡ç†äº†èµ·æ¥ã€‚ åœ¨æ­¤åŸºç¡€ä¸Šæˆ‘ä»¬å¯ä»¥å®ç°ä¸€ä¸ªæ–‡ä»¶æ•°æ®ç»“æ„ï¼Œå®ƒå‘ä¸Šå‘ˆç°ä¸€ä¸ªå¯ä»¥éšæœºè®¿é—®ã€ä¿®æ”¹ä»¥åŠå˜é•¿çš„ byte array (C++ä¸­çš„ vector å®¹å™¨)ï¼Œå‘ä¸‹ä½¿ç”¨ balloc()/bfree() ç”³è¯· block å¹¶æŠŠå®ƒä»¬ä¸²èµ·æ¥ã€‚ æˆ‘ä»¬å¯ä»¥åœ¨æ–‡ä»¶çš„åŸºç¡€ä¸Šå®ç°ç›®å½•ï¼šç›®å½•æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªç‰¹æ®Šçš„æ–‡ä»¶ (å­—èŠ‚åºåˆ—)ï¼Œç›®å½•æ–‡ä»¶ä¸­å­˜æ”¾äº†å®ƒé‡Œé¢æœ‰å“ªäº›æ–‡ä»¶ä»¥åŠå®ƒä»¬çš„ä½ç½®ç´¢å¼• (å°† vector\u0026lt;char\u0026gt; å½“ä½œ vector\u0026lt;dir_entry\u0026gt; æ¥è§£è¯»)ã€‚ File Allocation Table (FAT) åœ¨è®¡ç®—æœºä½¿ç”¨è½¯ç›˜ä½œä¸ºå­˜å‚¨è®¾å¤‡çš„å¹´ä»£ï¼Œæˆ‘ä»¬è¦åœ¨å¾ˆå°‘çš„å­˜å‚¨ç©ºé—´ä¸Šå®ç°æ–‡ä»¶ç³»ç»Ÿï¼Œå› æ­¤é“¾è¡¨æ˜¯ä¸äºŒä¹‹é€‰ã€‚å…³äºé“¾è¡¨ï¼Œæˆ‘ä»¬æœ‰ä»¥ä¸‹ä¸¤ç§è®¾è®¡ï¼š\næ•°æ®ç»“æ„è¯¾ä¸Šçš„ç»å…¸è®¾è®¡ï¼šè®©æ¯ä¸ªå—æœ‰æ•°æ®å’Œ next æŒ‡é’ˆä¸¤éƒ¨åˆ†ï¼š\nstruct block { char data[NBLOCK]; void *next; } è¿™æ˜¯ä¸€ä¸ªå¾ˆè‡ªç„¶çš„æƒ³æ³•ï¼Œä½†æœ‰ä¸€äº›ç¼ºé™·ï¼šæ¯”å¦‚æ¯ä¸ª block éƒ½æœ‰ä¸€ç‚¹ç©ºé—´è¦ç”¨æ¥å­˜å‚¨æŒ‡é’ˆï¼Œæ‰€ä»¥æ•°æ®çš„å¯¹é½ä¼šä¸å¤ªå¥½ã€‚ä¸€ä¸ªæ›´è‡´å‘½çš„ç¼ºé™·æ˜¯ï¼šæˆ‘ä»¬åœ¨å—è®¾å¤‡ä¸Šå¹¶ä¸èƒ½ $O(1)$ åœ°å»è®¿é—® next æŒ‡é’ˆï¼Œæƒ³è¦è¯»å– next æˆ‘ä»¬è¦æŠŠæ•´ä¸ª block è¯»å‡ºæ¥ã€‚å¦‚æœæˆ‘ä»¬è¦æ‰§è¡Œä¸€ä¸ª lseek(SEEK_END)ï¼Œæˆ‘ä»¬å¾—æŠŠæ•´ä¸ªæ–‡ä»¶è¯»ä¸€éï¼Œè¿™éå¸¸ç³Ÿç³•ï¼Œè€Œä¸”æ— æ³•å…‹æœã€‚\næˆ‘ä»¬èŠ±è´¹å¼€å¤´çš„å‡ ä¸ª blockï¼ŒæŠŠæ‰€æœ‰çš„ next æŒ‡é’ˆå…¨éƒ¨å­˜å‚¨åœ¨è¿™äº› block ä¸­ï¼Œåé¢çš„ block ä¸“é—¨å­˜å‚¨æ•°æ®ã€‚è¿™ä¸ªè®¾è®¡å°±éå¸¸å¥½åœ°åˆ©ç”¨äº†æ•°æ®è®¿é—®çš„å±€éƒ¨æ€§ï¼šå½“æˆ‘ä»¬åœ¨éšæœºè®¿é—®ä¸€ä¸ªæ–‡ä»¶æ˜¯ï¼Œæˆ‘ä»¬éœ€è¦å¿«é€Ÿé€šè¿‡ next æŒ‡é’ˆè·³è½¬ï¼Œè¿™ç§è®¾è®¡å°† next æŒ‡é’ˆé›†ä¸­å­˜æ”¾åœ¨ä¸€èµ·ï¼Œæœ‰åˆ©äºæé«˜è®¿é—®æ•ˆç‡ã€‚\nä½†è¿™ä¸ªè®¾è®¡åœ¨æ•°æ®å¯é æ€§æ–¹é¢æœ‰æ¯”è¾ƒå¤§çš„é—®é¢˜ï¼šä¸€æ–¹é¢ï¼Œæ‰€æœ‰çš„ next æŒ‡é’ˆéƒ½å­˜æ”¾åœ¨å¼€å¤´çš„å‡ ä¸ª block å†…ï¼Œä¸€æ—¦è¿™äº› block æŸåï¼Œæ•´ä¸ªæ–‡ä»¶ç³»ç»Ÿå°±å®Œå…¨æŸåäº† (æ¯ä¸ªæ–‡ä»¶çš„ block é“¾è¡¨éƒ½å®Œå…¨æ–­å¼€)ï¼Œå•ä¸ª block æŸåå¯¹å…¨å±€çš„å½±å“è¿‡å¤§ï¼šå¦ä¸€æ–¹é¢ï¼Œç”±äºæˆ‘ä»¬ç»å¸¸è¦ lseekï¼Œæ‰€ä»¥å­˜æ”¾ next æŒ‡é’ˆçš„ block åˆæ°æ°æ˜¯æˆ‘ä»¬è¯»å†™æœ€é¢‘ç¹çš„åŒºåŸŸï¼Œä¹Ÿå°±æ˜¯è¯´å®ƒä»¬æŸåçš„å‡ ç‡è¦è¿œé«˜äºå…¶ä»– blockã€‚ä¸è¿‡è¿™ä¸ªé—®é¢˜ä¸æ˜¯å®Œå…¨ä¸å¯è§£å†³çš„ï¼šæˆ‘ä»¬å¯ä»¥å¤‡ä»½ä¸€äº› next æŒ‡é’ˆæ•°ç»„åœ¨ç£ç›˜çš„å…¶ä»–åœ°æ–¹ï¼Œå¹¶å‡†å¤‡ä¸€äº›åº”æ€¥é¢„æ¡ˆã€‚\nè¿™ä¸ªç£ç›˜å¼€å¤´é›†ä¸­å­˜æ”¾ next æŒ‡é’ˆçš„ blockï¼Œå°±å«åš file allocation table (FAT)ã€‚\nè‹¥è¦äº†è§£ FAT æ–‡ä»¶ç³»ç»Ÿçš„ç»†èŠ‚ï¼Œæœ€å¥½çš„æ–¹æ³•ä¾¿æ˜¯ RTFMã€‚ è¿™é‡Œæœ‰ FAT çš„æ‰‹å†Œã€‚\next2/Unix File System FAT ä½¿ç”¨æœ€ç®€å•çš„é“¾è¡¨æ¥ç®¡ç†æ¯ä¸ªæ–‡ä»¶çš„ data blockï¼Œè¿™ä½¿å¾—å¤§æ–‡ä»¶çš„éšæœºè®¿é—®æ¯”è¾ƒæ…¢ã€‚ext2 çš„è®¾è®¡ä¸€éƒ¨åˆ†è§£å†³äº†è¿™ä¸ªé—®é¢˜ï¼šext2 ä¸­çš„æ¯ä¸ªæ–‡ä»¶éƒ½æœ‰ä¸€ä¸ª inodeï¼šinode å­˜å‚¨äº†æ¯ä¸ªæ–‡ä»¶çš„ metadataï¼Œæ¯”å¦‚æ–‡ä»¶çš„å¤§å°ã€åç§°ç­‰ï¼Œinode ä¼šæœ‰ä¸€ä¸ªåŒºåŸŸå«åš direct blockï¼Œè¿™æ ·å¯¹äºå°æ–‡ä»¶ï¼Œå…¶ data block å¯ä»¥ç›´æ¥æ”¾åœ¨ direct block é‡Œï¼Œå¯¹äºå¤§æ–‡ä»¶ï¼Œå…¶ data block å¯ä»¥ç”¨ç±»ä¼¼é¡µè¡¨çš„æ–¹å¼ç»„ç»‡èµ·æ¥ï¼Œè¿™æ ·éšæœºè®¿é—®æ•ˆç‡éå¸¸é«˜ã€‚\næ‰€æœ‰æ–‡ä»¶çš„ inode åœ¨ç£ç›˜ä¸Šç»Ÿä¸€è¿ç»­å­˜å‚¨ï¼Œè¿™ä½¿å¾— inode çš„ç´¢å¼•éå¸¸æ–¹ä¾¿ï¼Œå› æ­¤æˆ‘ä»¬çš„ç›®å½•æ–‡ä»¶åªéœ€è¦å­˜å‚¨æ–‡ä»¶ååˆ° inode ç¼–å·çš„ key-value mapping å³å¯ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"4426ffe65af6171db54960827f954d9e","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec27/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec27/","section":"notes","summary":"æ•°æ®ç»“æ„è¯¾çš„ä¸€äº›æ½œè—çš„å‡è®¾ï¼š\nrandom access memoryï¼Œword addressing (ä¸åŒäºç£ç›˜ï¼Œç£ç›˜æ˜¯ä»¥å—ä¸ºå•ä½è®¿é—®çš„) load/store æŒ‡ä»¤å’Œè®¡ç®—æŒ‡ä»¤æ‰§è¡Œçš„ä»£ä»·éƒ½æ˜¯ $O(1)$ã€‚ åœ¨å—è®¾å¤‡ä¸­ï¼Œå³ä½¿è®¿é—®ä¸€ä¸ª byte ä¹Ÿéœ€è¦å°†å®ƒæ‰€åœ¨çš„ä¸€æ•´ä¸ª block æ‹¿å‡ºæ¥ï¼Œå› æ­¤å†…å­˜ä¸­çš„æ•°æ®ç»“æ„ç”¨åœ¨ç£ç›˜ä¸Šä¼šé€ æˆæå¤§çš„æ€§èƒ½é—®é¢˜ã€‚\nå—è®¾å¤‡æä¾›çš„è®¾å¤‡æŠ½è±¡ï¼š\nstruct block blocks[NBLK]; // ç£ç›˜ void bread(int id, struct block *buf) { memcpy(buf, \u0026amp;blocks[id], sizeof(struct block)); } void bwrite(int id, const struct block *buf) { memcpy(\u0026amp;blocks[id], buf, sizeof(struct block)); } bread() å°†ç£ç›˜ä¸­çš„ä¸€ä¸ªå—æ‹‰åˆ°å†…å­˜é‡Œï¼Œbwrite() å°†å†…å­˜ä¸­çš„ä¸€ä¸ªå—å†™å…¥ç£ç›˜ã€‚","tags":null,"title":"Lecture 27: FAT and UNIX File System","type":"docs"},{"authors":null,"categories":null,"content":"å†…å­˜åœ¨æ‰ç”µåä¸¢å¤±æ•°æ®æ˜¯å¯ä»¥è¢«æ¥å—çš„ï¼Œä½†åœ¨æŒä¹…åŒ–å­˜å‚¨è®¾å¤‡ä¸Šæˆ‘ä»¬å¿…é¡»ä¿è¯æ•°æ®çš„å¯é æ€§ã€‚ç¡¬ç›˜æŸåè™½ç„¶æ˜¯å°æ¦‚ç‡äº‹ä»¶ï¼Œä½†åªè¦æœ‰å¤§é‡çš„é‡å¤ (æ¯”å¦‚æ•°æ®ä¸­å¿ƒ)ï¼Œè¿™ç±»äº‹æƒ…è¿˜æ˜¯ç»å¸¸å‘ç”Ÿçš„ã€‚æˆ‘ä»¬å¸Œæœ›å³ä½¿å‘ç”Ÿè¿™æ ·çš„äº‹æƒ…ï¼Œç³»ç»Ÿä»ç„¶èƒ½ç…§å¸¸è¿è½¬ã€‚\nRAID Redundant Array of Inexpensive Disks çš„æ ¸å¿ƒæ€æƒ³æ˜¯ï¼šæŠŠå¤šä¸ª (ä¸å¯é çš„) è™šæ‹Ÿç£ç›˜è™šæ‹Ÿæˆä¸€å—éå¸¸å¯é ä¸”æ€§èƒ½æé«˜çš„è™šæ‹Ÿç£ç›˜ã€‚RAID çš„è™šæ‹ŸåŒ–æ˜¯ä¸€ç§â€œåå‘â€çš„è™šæ‹ŸåŒ–ï¼šæˆ‘ä»¬ä¹‹å‰æ¥è§¦çš„è™šæ‹ŸåŒ–ï¼Œæ¯”å¦‚è¿›ç¨‹æŠŠä¸€ä¸ª CPU åˆ†æ—¶è™šæ‹Ÿæˆå¤šä¸ª virtual CPUï¼Œè™šæ‹Ÿå†…å­˜æŠŠä¸€ä»½å†…å­˜é€šè¿‡ MMU è™šæ‹Ÿæˆå¤šä¸ª virtual address spaceï¼Œæ–‡ä»¶æŠŠä¸€ä¸ªç‰©ç†è®¾å¤‡è™šæ‹Ÿæˆå¤šä¸ª virtual diskâ€¦â€¦è€Œ RAID æ˜¯ $å¤š\\to 1$ çš„è™šæ‹ŸåŒ–ã€‚\nRAID çš„ Fault Model ä¸ºï¼šä»»ä½•ä¸€å—ç£ç›˜éƒ½å¯èƒ½çªç„¶åæ‰ï¼Œå°±å¥½åƒâ€œçªç„¶æ¶ˆå¤±äº†â€ã€‚\nRAID-1 æœ€ç®€å•çš„æƒ³æ³•ï¼šå‡†å¤‡ä¸¤å—ç£ç›˜ $A$ å’Œ $B$ï¼Œå®ƒä»¬å­˜å‚¨äº†åŒä¸€ä»½è™šæ‹Ÿç£ç›˜çš„é•œåƒï¼Œè¿™æ ·æŸåçš„æ¦‚ç‡å°±ä» $p$ å˜æˆäº† $p^2$ã€‚è¯¥åšæ³•è¿˜èƒ½æå‡è¯»å–çš„æ•ˆç‡ï¼šæ¯”å¦‚æˆ‘è¦ä»è™šæ‹Ÿç£ç›˜ä¸­è¯»å– 10000 ä¸ª blockï¼Œé‚£ä¹ˆæˆ‘å¯ä»¥ä» $A$ ä¸­è¯»å–å‰ 5000 å—ï¼Œ$B$ ä¸­è¯»å–å 5000 å—ï¼Œåªè¦ CPU core ä¸ªæ•°è¶³å¤Ÿï¼Œå†…å­˜å¸¦å®½è¶³å¤Ÿï¼Œè¿™ä»¶äº‹æ˜¯å¯ä»¥åšåˆ°çš„ (ä¸è¿‡è¯¥åšæ³•ç‰ºç‰²äº†ä¸€äº›å­˜å‚¨ç©ºé—´)ã€‚\nRAID-0 å¦‚æœæˆ‘ä»¬ä¸è€ƒè™‘å®¹é”™ï¼Œä¸“æ³¨äºæå‡æ€§èƒ½ï¼šå‡è®¾ä¸¤å—ç£ç›˜ $A$ å’Œ $B$ï¼Œæœ‰ $A_1,A_2$ï¼Œ$B_1,B_2$ å››å—ã€‚è™šæ‹Ÿç£ç›˜æœ‰ $V_1,V_2,V_3,V_4$ å››å—ã€‚å¦‚æœæˆ‘ä»¬çš„æ˜ å°„æ˜¯ $A_1\\to V_1,A_2\\to V_2,B_1\\to A_3,B_2\\to V_4$ï¼Œé‚£ä¹ˆå¦‚æœæˆ‘ä»¬è¯»å†™å‰ä¸¤ä¸ªå—ï¼Œå°±åªæœ‰ $A$ åœ¨å·¥ä½œï¼Œ$B$ åœ¨æ‘¸é±¼ï¼›å¦‚æœæˆ‘ä»¬é‡‡å–äº¤é”™æ˜ å°„ï¼š$A_1\\to V_1,B_1\\to V_2,A_2\\to V_3,B_2\\to V_4$ï¼Œé‚£ä¹ˆæˆ‘ä»¬è¯»å–ä»»æ„è¿ç»­çš„ä¸¤å—éƒ½èƒ½è®© $A,B$ å¹¶è¡Œåœ°å·¥ä½œï¼Œæ€§èƒ½ç¿»å€ã€‚\n(RAID-1)-0 å½“æˆ‘ä»¬æœ‰å¤šå—ç›˜çš„æ—¶å€™ï¼Œä»¤ $f(i,j)$ è¡¨ç¤ºç¬¬ $i$ å—ç‰©ç†ç›˜çš„ç¬¬ $j$ ä¸ªåŒºåŸŸå¯¹åº”åˆ°è™šæ‹Ÿç£ç›˜çš„å“ªä¸€ä¸ªåŒºåŸŸï¼Œè¿™é‡Œçš„å‡½æ•° $f$ æœ‰å¾ˆå¤§çš„è®¾è®¡ç©ºé—´ã€‚æ¯”å¦‚å½“æˆ‘ä»¬æœ‰ 4 å—ç›˜çš„æ—¶å€™ï¼Œæˆ‘ä¹ˆå¯ä»¥å°†ä¹‹å‰çš„ä¸¤ç§è®¾è®¡æ–¹æ³•ç»¼åˆèµ·æ¥ï¼Œç»„åˆæˆä¸€ä¸ª (RAID-1)-0ã€‚è¿™ä¸ªå†™æ³•æœ‰ç‚¹åƒå‡½æ•°çš„å¤åˆï¼Œæˆ‘ä»¬æ¯ä¸¤å—ç›˜åšä¸€ä¸ª RAID-1ï¼Œè¿™æ ·æœ‰ä¸¤ç»„ RAID-1ï¼Œå†æŠŠå®ƒä»¬ç”¨ RAID-0 è¿èµ·æ¥ï¼Œè¿™æ ·æˆ‘ä»¬å°±å…¼é¡¾äº†å®¹é‡ã€å®¹é”™å’Œæ€§èƒ½ã€‚\nè¿™ä¸ªåšæ³•æœ‰ä¸€ä¸ªå¾ˆæœ‰æ„æ€çš„ç‚¹ï¼šæˆ‘ä»¬å¯ä»¥ä¿è¯ä»»æ„ä¸€å—ç‰©ç†ç›˜å‡ºé”™éƒ½ä¸ä¼šä¸¢å¤±ä¿¡æ¯ï¼Œä½†æˆ‘ä»¬ä¸èƒ½ä¿è¯ä¸¤å—ç›˜å‡ºé”™æ—¶ä¸ä¼šä¸¢å¤±ä¿¡æ¯â€”â€”å¦‚æœæˆ‘ä»¬åœ¨ä¸¤ä¸ª RAID-1 ä¸­å„ä¸¢äº†ä¸€å—ç›˜ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä»ç„¶èƒ½æ¢å¤ä¿¡æ¯ï¼›ä½†å¦‚æœæˆ‘ä»¬ä¸¢å¤±äº†ç¬¬ä¸€ä¸ª RAID-1 ä¸­çš„æ‰€æœ‰ä¸¤å—ç›˜ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±çœŸçš„ä¸¢å¤±äº†æ•°æ®ã€‚å¦‚æœæˆ‘ä»¬è®¤ä¸ºåŒæ—¶ä¸¢å¤±äº†ä¸¤å—ç›˜å±äºå‡ ä¹ä¸å¯èƒ½å‘ç”Ÿçš„å°æ¦‚ç‡äº‹ä»¶ï¼Œé‚£ä¹ˆè¿™ä¸ª (RAID-1)-0 çš„åšæ³•ä¼¼ä¹åœ¨å®¹é”™æ–¹é¢å°±æœ‰ä¸€äº›â€œæ€§èƒ½è¿‡å‰©â€ï¼Œæœ‰æ²¡æœ‰ä»€ä¹ˆéå¸¸ç»æµå®æƒ çš„åšæ³•å‘¢ï¼Ÿ\nRAID-4 ä¸€ä¸ªå—çš„ä¿¡æ¯å¯ä»¥æŠ½è±¡æˆä¸€ä¸ª bitï¼Œäºæ˜¯è¿™ä¸ªé—®é¢˜ç­‰ä»·äºæˆ‘ä»¬å¦‚ä½•ç”¨æœ€å°‘çš„å†—ä½™ä¿¡æ¯æ¥ä¿è¯ä¸€ä¸ª bit çš„é”™è¯¯å’Œçº æ­£ã€‚æˆ‘ä»¬å®¹æ˜“è”æƒ³åˆ°å¯ä»¥ç”¨æ ¡éªŒç æ¥å®Œæˆè¿™ä»¶äº‹ã€‚è¦ä¿è¯å¯ä»¥çº ä¸€ä½é”™ï¼Œæˆ‘ä»¬åªéœ€è¦ä½¿ç”¨å¥‡å¶æ£€éªŒç å³å¯ã€‚\nå‡è®¾æˆ‘ä»¬ç°åœ¨ç”¨ $A,B,C,D$ å››å—ç›˜ç»„åˆå‡ºä¸€ä¸ªè™šæ‹Ÿç£ç›˜ï¼Œåˆ™æˆ‘ä»¬çš„æ˜ å°„ä¸º $V_1\\to A_1,V_2\\to B_1,V_3\\to C_1$ï¼Œ$D_1=V_1\\oplus V_2\\oplus V_3$ã€‚ä¹‹å $V_4,V_5,V_6$ ä¾æ¬¡ç±»æ¨ã€‚è¿™æ ·å¦‚æœ $A,B,C$ ä¸‰å—ç›˜ä¸­çš„æŸä¸ªæŸåï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ $D$ æ¥æ¢å¤ï¼›å¦‚æœ $D$ æŸåï¼Œæˆ‘ä»¬æ²¡æœ‰ä¸¢å¤±ä»»ä½•å®é™…ä¿¡æ¯ï¼Œå†æ’ä¸€å—æ–°ç›˜ç®—ä¸€éå¼‚æˆ–å³å¯ã€‚\nRAID-4 åœ¨ä¿è¯åä¸€å—ç›˜ä¸ä¼šä¸¢å¤±æ•°æ®çš„æƒ…å†µä¸‹å°†å†—ä½™æ•°æ®é‡åšåˆ°äº†æœ€å°ï¼Œä½¿å¾—æˆ‘ä»¬çš„è™šæ‹Ÿç£ç›˜å®¹é‡å¤§ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬å°† $V_1,V_2,\\cdots$ äº¤é”™æ˜ å°„åœ¨å¤šä¸ªç›˜ä¸Šï¼Œè¿™æ ·æˆ‘ä»¬åœ¨è¿ç»­è¯»å–/å†™å…¥æ—¶ï¼Œå¯ä»¥åŒæ—¶æŠŠä¸‰å—ç›˜çš„æ€§èƒ½æ‹‰æ»¡ï¼Œå¹¶è¡Œåº¦é«˜ã€‚\nä½†è¿™ä¸ªè®¾è®¡æœ‰ä¸€ä¸ªå¾®å¦™çš„ç¼ºé™·ï¼šå®ƒåº”å¯¹éšæœºè¯»å†™çš„æ•ˆæœè¾ƒå·®ã€‚å‡è®¾æˆ‘ä»¬æœ‰å¤šæ¬¡éšæœºçš„å†™æ“ä½œï¼Œæˆ‘ä»¬ä¼šå‘ç°æ¯æ¬¡å†™æ“ä½œéƒ½è¦å¥‡å¶æ ¡éªŒç›˜ $D$ ä¸­çš„æ•°æ®è¿›è¡Œä¿®æ”¹ã€‚æ­¤å¤–å› ä¸º $D_i=A_i\\oplus B_i\\oplus C_i$ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿˜æ²¡æ³•ç›´æ¥å»ä¿®æ”¹ $D_i$ï¼Œå‡è®¾æˆ‘ä»¬ç°åœ¨è¦ä¿®æ”¹ $A_1$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¿…é¡»å…ˆ bread(A1, D1)ï¼Œç„¶å D1^=A1ï¼Œå°† A1 ä¿®æ”¹ä¸º A1' åï¼ŒD1'=D1^A1'ï¼Œæœ€å bwrite(A1, D1)ã€‚æ¯æ¬¡éšæœºå†™ (ä¸è®ºæ˜¯ $A,B,C$ ä¸­çš„å“ªä¸€ä¸ªç›˜)ï¼Œæˆ‘ä»¬éƒ½è¦å¯¹ $D$ ä¸€è¯»ä¸€å†™ï¼Œå¥‡å¶æ ¡éªŒç›˜æˆä¸ºäº†æ€§èƒ½ç“¶é¢ˆã€‚\nRAID-5 RAID-5 çš„è®¾è®¡éå¸¸èªæ˜ï¼šæˆ‘ä»¬ä¸ç”¨å•ç‹¬å®‰æ’ä¸€å—ç›˜ä½œä¸ºå¥‡å¶æ ¡éªŒç›˜ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠå¥‡å¶æ£€éªŒçš„ä¿¡æ¯åˆ†æ•£åˆ°å„å„ç›˜ä¸Šå»ï¼Œæ¯å—ç›˜ä¸Šæ—¢æœ‰æ•°æ®ä¹Ÿæœ‰æ ¡éªŒï¼š\nåœ¨è¿ç»­è¯»å†™ä¸Šï¼Œ$n$ å—ç›˜å¯ä»¥è¾¾åˆ° $n-1$ å—çš„å¸¦å®½ (æ¯ $n$ ä¸ª block å°±æœ‰ä¸€ä¸ªæ˜¯å†—ä½™çš„æ ¡éªŒ block)ï¼Œåœ¨éšæœºè¯»ä¸Šï¼Œç”±äºæ¯ä¸ªç›˜éƒ½å­˜å‚¨äº†æ•°æ®ï¼Œå› æ­¤å¸¦å®½æ¥è¿‘ 100%ã€‚åœ¨éšæœºå†™ä¸Šï¼Œæ ¡éªŒä¿¡æ¯çš„è¯»å†™ä»ç„¶æ˜¯ç“¶é¢ˆï¼Œä½†ç”±äºæ ¡éªŒä¿¡æ¯çš„ä¿®æ”¹è¢«å¹³æ‘Šåˆ°äº†æ‰€æœ‰ç›˜çš„å¤´ä¸Šï¼Œæ‰€ä»¥åŸºæœ¬å¯ä»¥ä¿è¯éšç€ç›˜æ•°é‡çš„å¢å¤šæ•ˆç‡æé«˜ï¼Œæœ‰ scalabilityã€‚\nCrash Consistency å¦ä¸€ç§ Fault modelï¼šç£ç›˜å¹¶æ²¡æœ‰æ•…éšœï¼Œä½†æ“ä½œç³»ç»Ÿå¯èƒ½ä¼š crash (æ¯”å¦‚æ‰ç”µ)ã€‚å³ä½¿æ˜¯æ–‡ä»¶ç³»ç»Ÿä¸­çš„ç®€å•æ“ä½œä¹Ÿå¯èƒ½æ¶‰åŠè‹¥å¹²ä¸ª blockï¼Œå¦‚æœæˆ‘ä»¬åœ¨ä¸€è½®æ“ä½œçš„ä¸­é€”æ‰ç”µï¼Œé‚£ä¹ˆæ–‡ä»¶ç³»ç»Ÿå°±ä¼šè¿›å…¥ä¸€ä¸ª inconsistent çš„çŠ¶æ€ï¼Œè¿™æ ·çš„çŠ¶æ€å¯èƒ½å¯¼è‡´ä¸¥é‡çš„é”™è¯¯æˆ–å®‰å…¨é—®é¢˜ã€‚ç£ç›˜æœ¬èº«æ— æ³•ç›´æ¥æ”¯æŒåŸå­æ“ä½œ (all or nothing)ï¼Œç”šè‡³ä¸ºäº†æ•ˆç‡å®ƒä¸ä¼šä¿è¯ bwrite æ“ä½œæ˜¯æŒ‰é¡ºåºè¿›è¡Œçš„ (å› æ­¤ block layer è¿˜é¢å¤–æä¾›äº† bflush æ“ä½œæ¥ä¿è¯æ•°æ®è½ç›˜ (å’Œå¹¶å‘ä¸­çš„ barrier(mfence) æ˜¯ç±»ä¼¼çš„) )ã€‚\nFile System Checking (FSCK) FSCK çš„æ ¸å¿ƒåŸç†æ˜¯å½“ç£ç›˜ä¸Šå‡ºç° inconsistent çš„ç°è±¡æ—¶ï¼Œæ ¹æ®ç£ç›˜ä¸Šå·²æœ‰çš„ä¿¡æ¯æ¢å¤å‡ºâ€œæœ€å¯èƒ½â€çš„æ•°æ®ç»“æ„ã€‚ä½†è¿™å¥—æ–¹æ¡ˆä¸æ˜¯å®Œç¾çš„ï¼šæœ‰ä¸€äº›æ— æ³•æ¢å¤çš„æ–‡ä»¶å¯èƒ½ä¼šè¢«æ”¾å…¥ lost\u0026amp;found ä¸­ï¼Œé€ æˆä¸€äº›éº»çƒ¦ï¼›æ­¤å¤–ï¼Œå¦‚æœ fsck æ‰§è¡Œè¿‡ç¨‹ä¸­åˆå‘ç”Ÿæ‰ç”µï¼Œå¯èƒ½ä¼šäº§ç”Ÿæ„æƒ³ä¸åˆ°çš„åæœã€‚å› æ­¤ FSCK ä¸æ˜¯ä¸€ä¸ªæ ¹æœ¬çš„è§£å†³æ–¹æ³•ã€‚\nJournaling æˆ‘ä»¬é€šå¸¸çœ‹æ–‡ä»¶ç³»ç»Ÿçš„è§†è§’ï¼Œæ¯”å¦‚ç›®å½•æ ‘ï¼Œæ˜¯æ–‡ä»¶ç³»ç»Ÿçš„ç›´è§‚è¡¨ç¤ºï¼Œå®ƒæ˜¯ crash unsafe çš„ã€‚ä½†å¦‚æœæˆ‘ä»¬ä»çŠ¶æ€æœºè§†è§’å»çœ‹æ–‡ä»¶ç³»ç»Ÿï¼Œæˆ‘ä»¬å¯ä»¥æŠŠæ–‡ä»¶ç³»ç»Ÿçœ‹ä½œä¸€ç³»åˆ—ä¿®æ”¹æ“ä½œçš„åºåˆ—ã€‚å¦‚æœæˆ‘ä»¬å¯ä»¥æŠŠè¿™ä¸ª append-only çš„åºåˆ—å­˜å‚¨ä¸‹æ¥ï¼Œæˆ‘ä»¬å°±å¯ä»¥åœ¨ crash ä¹‹åæ¢å¤å‡ºæ–‡ä»¶ç³»ç»Ÿã€‚\nå› æ­¤æˆ‘ä»¬çš„æƒ³æ³•æ˜¯ï¼šåœ¨æ•°æ®ç»“æ„ä¿®æ”¹æ“ä½œå‘ç”Ÿæ—¶ï¼Œå…ˆä¸å»åšå®é™…çš„ä¿®æ”¹ï¼Œè€Œæ˜¯è®°å½•ä¸‹ä¸€æ¡ä¿®æ”¹æ—¥å¿—ã€‚å½“æ—¥å¿—è½ç›˜åï¼Œæ ¹æ®æ—¥å¿—å†…å®¹ä¿®æ”¹å®é™…çš„æ•°æ®ç»“æ„ã€‚è¿™æ ·å¦‚æœå‘ç”Ÿ crashï¼Œæˆ‘ä»¬å¯ä»¥é‡æ”¾æ—¥å¿— (redo log) æ¥æ¢å¤æ–‡ä»¶ç³»ç»Ÿã€‚\nåœ¨ bread(), bwrite() å’Œ bflush() ä¸‰ä¸ª API çš„åŸºç¡€ä¸Šæˆ‘ä»¬å¯ä»¥å†™å‡ºä¸€ä¸ª journal.append() çš„ä¼ªä»£ç ï¼š\nJournal_append(operations) using bread() to find the end of current journal bwrite(Transaction_begin) for operation in operation: bwrite(operation) bflush() # ç¡®ä¿æ‰€æœ‰ operation è½ç›˜ bwrite(Transaction_end) bflush() # ç¡®ä¿ TxEnd æ ‡è®°è½ç›˜ å†ä¹‹åæˆ‘ä»¬å°±å¯ä»¥å°†æ—¥å¿—çš„å†…å®¹ä»˜è¯¸å®æ–½ï¼Œå®æ–½ç»“æŸååˆ æ‰æ—¥å¿—ã€‚å¦‚æœå®æ–½çš„è¿‡ç¨‹ä¸­æ‰ç”µï¼Œé‡å¯å TxEnd æ ‡ç­¾å°†æˆä¸ºæˆ‘ä»¬ç¡®è®¤æ—¥è‡³æ˜¯å¦å®Œæ•´çš„å”¯ä¸€æ ‡å¿—ï¼šå› ä¸ºæˆ‘ä»¬æœ‰ bflush() ä¿è¯åŒæ­¥æ€§ï¼Œå› æ­¤å¦‚æœ TxEnd æ ‡å¿—å­˜åœ¨ï¼Œé‚£ä¹ˆä¹‹å‰æ‰€æœ‰æ“ä½œçš„ä¿¡æ¯ä¸€å®šå·²ç»å†™å…¥äº†ï¼Œæˆ‘ä»¬å¯ä»¥å®‰å…¨åœ°é‡æ”¾æ—¥å¿—ï¼›å¦‚æœ TxEnd æ ‡å¿—ä¸å­˜åœ¨ï¼Œé‚£æˆ‘ä»¬å°±å¿½ç•¥è¿™æ¬¡æ—¥å¿—ï¼Œä¸”è¿™æ—¶æ—¥å¿—ä¸­çš„æ“ä½œå°šæœªå¯¹æ•°æ®ç»“æ„äº§ç”ŸçœŸæ­£å½±å“ã€‚è¿™æ ·å°±åšåˆ°äº† all or nothingã€‚\nOSLAB ä¸­çš„å°å½©è›‹\nä¸ºäº†æé«˜ journaling çš„æ•ˆç‡ï¼Œå¾ˆå¤šç³»ç»Ÿåšå‡ºäº†å¾ˆå¤šçš„ä¼˜åŒ–ã€‚æ¯”å¦‚ git é‡‡ç”¨ metadata journalingï¼Œæå‡æ•ˆç‡çš„åŒæ—¶é™ä½äº†ä¸€è‡´æ€§ï¼Œè¿™å¯¼è‡´æœ‰æ—¶å¼ºè¡Œå…³é—­è™šæ‹Ÿæœºä¼šå¯¼è‡´ git repo å¤„äºä¸€ä¸ªä¸ä¸€è‡´çš„çŠ¶æ€ï¼Œå› æ­¤ OSLAB çš„ Makefile.lab ä¸­æ·»åŠ äº†ä¸€æ¡å‘½ä»¤ï¼š\ngit: @git add $(shell find . -name \u0026quot;*.c\u0026quot;) $(shell find . -name \u0026quot;*.h\u0026quot;) -A --ignore-errors @while (test -e .git/index.lock); do sleep 0.1; done @(uname -a \u0026amp;\u0026amp; uptime) | git commit -F - -q --author='tracer-nju \u0026lt;tracer@nju.edu.cn\u0026gt;' --no-verify --allow-empty + @sync sync çš„ä½œç”¨æ˜¯ \u0026ldquo;synchronize cached writes to persistent storage\u0026rdquo;ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"2a12466027b147c44534498ea3e1f1ac","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec28/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec28/","section":"notes","summary":"å†…å­˜åœ¨æ‰ç”µåä¸¢å¤±æ•°æ®æ˜¯å¯ä»¥è¢«æ¥å—çš„ï¼Œä½†åœ¨æŒä¹…åŒ–å­˜å‚¨è®¾å¤‡ä¸Šæˆ‘ä»¬å¿…é¡»ä¿è¯æ•°æ®çš„å¯é æ€§ã€‚ç¡¬ç›˜æŸåè™½ç„¶æ˜¯å°æ¦‚ç‡äº‹ä»¶ï¼Œä½†åªè¦æœ‰å¤§é‡çš„é‡å¤ (æ¯”å¦‚æ•°æ®ä¸­å¿ƒ)ï¼Œè¿™ç±»äº‹æƒ…è¿˜æ˜¯ç»å¸¸å‘ç”Ÿçš„ã€‚æˆ‘ä»¬å¸Œæœ›å³ä½¿å‘ç”Ÿè¿™æ ·çš„äº‹æƒ…ï¼Œç³»ç»Ÿä»ç„¶èƒ½ç…§å¸¸è¿è½¬ã€‚\nRAID Redundant Array of Inexpensive Disks çš„æ ¸å¿ƒæ€æƒ³æ˜¯ï¼šæŠŠå¤šä¸ª (ä¸å¯é çš„) è™šæ‹Ÿç£ç›˜è™šæ‹Ÿæˆä¸€å—éå¸¸å¯é ä¸”æ€§èƒ½æé«˜çš„è™šæ‹Ÿç£ç›˜ã€‚RAID çš„è™šæ‹ŸåŒ–æ˜¯ä¸€ç§â€œåå‘â€çš„è™šæ‹ŸåŒ–ï¼šæˆ‘ä»¬ä¹‹å‰æ¥è§¦çš„è™šæ‹ŸåŒ–ï¼Œæ¯”å¦‚è¿›ç¨‹æŠŠä¸€ä¸ª CPU åˆ†æ—¶è™šæ‹Ÿæˆå¤šä¸ª virtual CPUï¼Œè™šæ‹Ÿå†…å­˜æŠŠä¸€ä»½å†…å­˜é€šè¿‡ MMU è™šæ‹Ÿæˆå¤šä¸ª virtual address spaceï¼Œæ–‡ä»¶æŠŠä¸€ä¸ªç‰©ç†è®¾å¤‡è™šæ‹Ÿæˆå¤šä¸ª virtual diskâ€¦â€¦è€Œ RAID æ˜¯ $å¤š\\to 1$ çš„è™šæ‹ŸåŒ–ã€‚\nRAID çš„ Fault Model ä¸ºï¼šä»»ä½•ä¸€å—ç£ç›˜éƒ½å¯èƒ½çªç„¶åæ‰ï¼Œå°±å¥½åƒâ€œçªç„¶æ¶ˆå¤±äº†â€ã€‚","tags":null,"title":"Lecture 28: Reliability of Persistent Storage","type":"docs"},{"authors":null,"categories":null,"content":"Review æ–‡ä»¶ç³»ç»Ÿ = å›¾ä¹¦é¦†\nç›®å½•ï¼šå›¾ä¹¦é¦†æ“ä½œï¼Œmkdir, rmdir, link, unlink etc. æ–‡ä»¶ï¼šå›¾ä¹¦ï¼Œread, write, mmap etc. æ–‡ä»¶æè¿°ç¬¦ (offset)ï¼šä¹¦ç­¾ï¼Œlseek etc. FATï¼š\nmetadata FAT FAT data clusters FAT åŒºåŸŸå­˜æ”¾æ–‡ä»¶é“¾è¡¨çš„ next æŒ‡é’ˆã€‚FAT çš„ä¸€ä¸ªç¼ºç‚¹åœ¨äºä¸€ä¸ªæ–‡ä»¶çš„ä¿¡æ¯æ•£è½åœ¨ç£ç›˜çš„å„ä¸ªåœ°æ–¹ã€‚\nUNIXï¼š\nç£ç›˜ä¸­çš„ä¸€ä¸ªåŒºåŸŸå­˜æ”¾æ‰€æœ‰æ–‡ä»¶çš„ inodeã€‚inode é‡ŒåŒ…æ‹¬æ–‡ä»¶çš„å‡ ä¹æ‰€æœ‰ä¿¡æ¯ (é™¤äº†æ‰€æœ‰çš„ data block ä»¥ä¸€ä¸ªç±»é¡µè¡¨çš„æ–¹å¼å­˜å‚¨ï¼Œinode é‡Œå­˜æ”¾äº†â€œé¡µè¡¨â€çš„æ ¹)ï¼Œæ›´å¥½åœ°åˆ©ç”¨äº†æ•°æ®çš„ localityã€‚\n/mkfs/mkfs.c mkfs çš„ä»£ç å†™çš„éå¸¸çç¢ã€‚RTFSC çš„ä¼˜é›…å§¿åŠ¿ä¸ºï¼šè¯»ä»£ç çš„æ‰§è¡Œæ¯”è¯»ä»£ç å®¹æ˜“ã€‚\n# trace.py TRACED = 'bwrite balloc ialloc iappend rinode winode rsect wsect'.split() IGNORE = 'ip xp buf'.split() class trace(gdb.Breakpoint): def stop(self): f, bt = gdb.selected_frame(), [] while f and f.is_valid(): if (name := f.name()) in TRACED: lvars = [f'{sym.name}={sym.value(f)}' for sym in f.block() if sym.is_argument and sym.name not in IGNORE] bt.append(f'\\033[32m{name}\\033[0m({\u0026quot;, \u0026quot;.join(lvars)})') f = f.older() print(' ' * (len(bt) - 1) + bt[0]) return False # won't stop at this breakpoint gdb.execute('set prompt off') gdb.execute('set pagination off') for fn in TRACED: trace(fn) gdb.execute('run fs.img README user/_ls') gdb.execute('quit') ä¸Šé¢çš„ä¸€æ®µä»£ç å¯ä»¥å¸®æˆ‘ä»¬è‡ªåŠ¨åœ¨ mkfs.c ä¸­æ¯”è¾ƒé‡è¦çš„ API å‡½æ•°ä¸Šæ‰“æ–­ç‚¹ï¼Œå¹¶è¿½è¸ªæ ˆå¸§æ‰“å°å‡½æ•°è°ƒç”¨é“¾å’Œå…³é”®å‚æ•°ã€‚é€šè¿‡é˜…è¯» mfks.c çš„æ‰§è¡Œè¿‡ç¨‹ï¼Œæˆ‘ä»¬å¯ä»¥æ›´å¿«åœ°äº†è§£ mfks å¤§è‡´åšäº†å“ªäº›äº‹æƒ…ã€‚\nBuffer Cache å†…å­˜ä¸­çš„ buffer cache æ˜¯ç£ç›˜çš„ cacheï¼Œæ‰€æœ‰çš„è¯»å†™æ“ä½œéƒ½ä¼šç»è¿‡ buffer cacheï¼Œbuffer cache æä¾›äº†å’Œç£ç›˜ä¸€æ ·çš„æ¥å£ bread/bwriteï¼Œè¿™æ ·åå¤çš„è¯»å–/åå¤çš„å†™å…¥ä¸ç”¨æ¯æ¬¡éƒ½ä¸ç£ç›˜äº¤äº’ï¼Œæé«˜äº†æ•ˆç‡ã€‚\nå…·ä½“çš„ä»£ç ç»†èŠ‚è§ Xv6 æºç è§£è¯»æ‰‹å†Œã€‚\nLog Xv6 çš„ logging layer ä¿è¯äº†å´©æºƒä¸€è‡´æ€§ã€‚å…·ä½“çš„ä»£ç ç»†èŠ‚å¯ä»¥è§ Xv6 æºç è§£è¯»æ‰‹å†Œã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"3c9dabd7b4dd349270687ff92ebd2b1e","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec29/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec29/","section":"notes","summary":"Review æ–‡ä»¶ç³»ç»Ÿ = å›¾ä¹¦é¦†\nç›®å½•ï¼šå›¾ä¹¦é¦†æ“ä½œï¼Œmkdir, rmdir, link, unlink etc. æ–‡ä»¶ï¼šå›¾ä¹¦ï¼Œread, write, mmap etc. æ–‡ä»¶æè¿°ç¬¦ (offset)ï¼šä¹¦ç­¾ï¼Œlseek etc. FATï¼š\nmetadata FAT FAT data clusters FAT åŒºåŸŸå­˜æ”¾æ–‡ä»¶é“¾è¡¨çš„ next æŒ‡é’ˆã€‚FAT çš„ä¸€ä¸ªç¼ºç‚¹åœ¨äºä¸€ä¸ªæ–‡ä»¶çš„ä¿¡æ¯æ•£è½åœ¨ç£ç›˜çš„å„ä¸ªåœ°æ–¹ã€‚\nUNIXï¼š\nç£ç›˜ä¸­çš„ä¸€ä¸ªåŒºåŸŸå­˜æ”¾æ‰€æœ‰æ–‡ä»¶çš„ inodeã€‚inode é‡ŒåŒ…æ‹¬æ–‡ä»¶çš„å‡ ä¹æ‰€æœ‰ä¿¡æ¯ (é™¤äº†æ‰€æœ‰çš„ data block ä»¥ä¸€ä¸ªç±»é¡µè¡¨çš„æ–¹å¼å­˜å‚¨ï¼Œinode é‡Œå­˜æ”¾äº†â€œé¡µè¡¨â€çš„æ ¹)ï¼Œæ›´å¥½åœ°åˆ©ç”¨äº†æ•°æ®çš„ localityã€‚","tags":null,"title":"Lecture 29: Xv6 File System Implementation","type":"docs"},{"authors":null,"categories":null,"content":"Abilities and Limitations of FS OJ æœ€ç®€å•çš„å®ç°æ–¹å¼å¯ä»¥å°±æ˜¯ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿã€‚æ¯”å¦‚ OS2022 è¯¾ç¨‹çš„å­¦ç”Ÿåå•å­˜æ”¾åœ¨ /OS2022/students.csv ä¸­ï¼Œå‘ Lab1 æäº¤çš„ä»£ç ä»¥ä¸€ä¸ªå‹ç¼©åŒ…çš„å½¢å¼å­˜æ”¾åœ¨ /OS2022/L1/studentid/xxxxxxxx.tar.bz2 ä¸­ã€‚OJ çš„å‰ç«¯å’Œåç«¯éƒ¨ç½²åœ¨ä¸åŒçš„æœºå™¨ä¸Šï¼Œåç«¯æœºå™¨é€šè¿‡ ssh è¿æ¥å‰ç«¯ï¼Œæ‰«ææ–‡ä»¶ç³»ç»Ÿå¯»æ‰¾ç¬¦åˆæ ¼å¼çš„æäº¤æ‹‰å›åå°ï¼Œè¯„æµ‹ä»¥åå‘é€ä¸€ä¸ª .tar.bz2.result æ–‡ä»¶ç»™å‰ç«¯ï¼Œå‰ç«¯å°±å¯ä»¥å°†è¯„æµ‹ç»“æœæ˜¾ç¤ºå‡ºæ¥ã€‚\nä½¿ç”¨æ–‡ä»¶ç³»ç»Ÿçš„æœ€å¤§å¥½å¤„æ˜¯ç®€å•ï¼šæˆ‘ä»¬æœ‰æµ·é‡çš„ UNIX å·¥å…·/æ ‡å‡†åº“å¯ä»¥å¤„ç†æ–‡ä»¶ã€‚æ¯”å¦‚æŸ¥è¯¢æŸä¸ªåŒå­¦çš„æäº¤å¯ä»¥ä½¿ç”¨å¦‚ä¸‹ python ä»£ç ï¼š\nfor f in wiki.UPLOAD_PATH.glob( f'{course}/{module}/{stuid}/{file_pattern}'): if not f.name.endswith('.result'): # fæ˜¯ä¸€ä¸ªæäº¤, do something å†æ¯”å¦‚æ·»åŠ äº†æµ‹è¯•æ•°æ®/æ›´æ–°äº†æµ‹è¯•ä»£ç åæˆ‘ä»¬åªéœ€è¦ä¸€è¡Œ UNIX å‘½ä»¤å°±å¯ä»¥å¼€å¯ rejudgeï¼š\nfind OS2022/L1 -name \u0026quot;*.result\u0026quot; | xargs rm åˆ é™¤æ‰€æœ‰çš„ .result ç»“å°¾çš„æ–‡ä»¶åï¼Œåç«¯ä¾¿ä¼šè‡ªåŠ¨æŠ“å–æ²¡æœ‰å¯¹åº” .result æ–‡ä»¶çš„æäº¤å‹ç¼©åŒ…è¯„æµ‹ï¼Œä»è€Œå®ç°é‡æµ‹ã€‚\næ–‡ä»¶ç³»ç»Ÿçš„å±€é™åœ¨äºï¼š\nscalability ä¸å¥½ï¼šä»»ä½•ä¸€ä¸ªé¡µé¢çš„æ¸²æŸ“éƒ½è¦éå†æ‰€æœ‰ç›®å½•ï¼Œå¯¹äºåºå¤§ç³»ç»Ÿæ¥è¯´æ•ˆç‡å¤ªä½ï¼› å¯é æ€§ä½ï¼šå‡ ä¹æ— æ³•æŠµæŠ—å´©æºƒã€‚æ¯”å¦‚åç«¯å®Œæˆè¯„æµ‹åä¼šé€šè¿‡ scp å‘½ä»¤å°† .result æ–‡ä»¶ä¼ é€åˆ°å‰ç«¯æœåŠ¡å™¨ï¼Œä½†å¦‚æœä¼ é€çš„è¿‡ç¨‹ä¸­ç½‘æ–­äº†ï¼Œé‚£ä¹ˆæ–‡ä»¶ç³»ç»Ÿæ— æ³•åšåˆ° all or nothingï¼Œä»è€Œå‰ç«¯å¯èƒ½ä¼šå¤„äºä¸€ä¸ª inconsistent çš„çŠ¶æ€ï¼Œ æ¯”å¦‚å·²ç»åˆ›å»ºäº† .result æ–‡ä»¶ä½†ç”±äºå¤åˆ¶æ²¡æœ‰å®Œæˆï¼Œæ–‡ä»¶æ˜¯ç©ºçš„ã€‚è¿™ä¾¿æ˜¯è¯„æµ‹ç»“æœä¸­ \u0026ldquo;server error\u0026rdquo; çš„ä¸€ç§æ¥æºã€‚ Relational Database æ‰€æœ‰çš„æ•°æ®éƒ½å¯ä»¥ä»¥äºŒç»´è¡¨çš„å½¢å¼å­˜å‚¨åœ¨æ•°æ®åº“å†…ã€‚Structured Query Language (SQL) ç”¨äºæè¿°éœ€æ±‚ï¼Œæ•°æ®åº“å¼•æ“è´Ÿè´£å°†éœ€æ±‚ç¿»è¯‘æˆå…·ä½“çš„å®ç°ã€‚æ¯”å¦‚å¦‚ä¸‹çš„ SQL è¯­å¥ï¼š\nSELECT * FROM students, submissions WHERE students.sid == submissions.sid AND submissions.course == 'OS2022' AND submissions.module == 'L1' å®ƒåœ¨åŠŸèƒ½ä¸Šç­‰ä»·äº\nfor student in students: for submission in submissions: if students.sid == submissions.sid and submission.course == 'OS2022' and submissions.module == 'L1': yield student, submission ä½†è¦æ³¨æ„çš„æ˜¯ï¼šSQL åªæ˜¯ä¸€ç§ high level çš„æè¿°éœ€æ±‚çš„è¯­è¨€ï¼Œå®ƒåº•å±‚çš„å®ç°å¹¶ä¸ä¸€å®šåƒè¿™æ®µ python ä»£ç ä¸€æ ·ã€‚æ¯”å¦‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œç”¨åŒé‡å¾ªç¯åœ¨ä¸¤ä¸ªè¡¨å•ä¸­ join æ˜¯éå¸¸ä½æ•ˆçš„ï¼Œæ•°æ®åº“ä¼šä½¿ç”¨æ•°æ®ç»“æ„ (hash, B tree etc.) æ¥ä¼˜åŒ–å®ç°ã€‚SQL å°†ä¸Šå±‚éœ€æ±‚å’Œåº•å±‚å®ç°è§£è€¦ï¼Œè¿™æ ·çš„è®¾è®¡æœ‰è¯¸å¤šå¥½å¤„ï¼Œæ¯”å¦‚æ¯”è¾ƒå®¹æ˜“å®ç°åŸå­æ€§ï¼š\nBEGIN WORK; -- all or nothing INSERT INTO students VALUES(...); INSERT INTO students VALUES(...); INSERT INTO students VALUES(...); COMMIT; ç›´åˆ° commit å‰ï¼Œæ•°æ®éƒ½ä¸ä¼šçœŸæ­£è½å®ã€‚\nä¾‹å­ï¼šç¨å¤§å‹çš„ Online Judge\næ•°æ®åº“éœ€è¦ä¿è¯ ACID - Atomicity, Consistency, Isolation, Durabilityã€‚å¯¹äºæ•°åƒä¸ªè¿æ¥çš„å¹¶å‘äº‹åŠ¡ï¼Œæ•°æ®åº“è¦åœ¨ä¿è¯å¹¶å‘æ­£ç¡®æ€§çš„åŸºç¡€ä¸Šæå‡æŸ¥è¯¢æ•ˆç‡ã€‚ä¸€ä¸ªå…¸å‹çš„ç®€å•åº”ç”¨åœºæ™¯æ˜¯ Online Judgeï¼š\næ¯”èµ›ä¸­ Online Judge è¯„æµ‹ç»“æœçš„å³æ—¶æ€§è¦æ±‚å¾ˆé«˜ï¼Œå› æ­¤æˆ‘ä»¬è¦ç»„å»ºä¸€ä¸ªå°çš„åˆ†å¸ƒå¼ç³»ç»Ÿæ¥å¹¶è¡Œåœ°è¯„æµ‹å¤šç»„æ•°æ®ã€‚ä¸Šå›¾æ‰€ç¤ºç³»ç»Ÿçš„å·¥ä½œåŸç†æ˜¯ï¼š100 ä¸ª worker è´Ÿè´£è¯„æµ‹ï¼Œsupervisor è´Ÿè´£ç»™ worker åˆ†é…ä»»åŠ¡ (supervisor ä¼šä¸æ–­ ping å„ä¸ª worker ä»¥äº†è§£æœºå™¨å®æ—¶çš„çŠ¶æ€)ï¼Œæ‰€æœ‰çš„æ•°æ®éƒ½å­˜å‚¨åœ¨ database ä¸­ã€‚supervisor å’Œæ‰€æœ‰çš„ worker ä¸æ•°æ®åº“ç›¸è¿ã€‚å½“ Online Judge å‰ç«¯æ¥æ”¶åˆ°ä¸€ä¸ªæ–°çš„æäº¤åï¼Œä»–ä¼šæŠŠæ–‡ä»¶å­˜å‚¨åˆ°æ•°æ®åº“ä¸­ï¼Œsupervisor ä¼šæŒ‡æŒ¥ä¸€ä¸ª worker æŠŠæºä»£ç ä»æ•°æ®åº“æ‹‰åˆ°æœ¬åœ°ç¼–è¯‘ï¼Œå¹¶å°†å¯æ‰§è¡Œæ–‡ä»¶ä¼ å›æ•°æ®åº“ã€‚æ¥ç€ supervisor æŒ‡æŒ¥ä¸€éƒ¨åˆ† worker ä»æ•°æ®åº“ä¸­è·å–å¯æ‰§è¡Œæ–‡ä»¶ (è¿™ä¸€ç¬é—´ä¼šäº§ç”Ÿä¸€ä¸ªå¾ˆå¤§çš„å¸¦å®½)ï¼Œç„¶åæ‰§è¡Œå¯¹åº”çš„æµ‹è¯•æ•°æ®ï¼Œworker å°†æ‰§è¡Œç»“æœå‘é€ç»™æ•°æ®åº“ä¿å­˜ã€‚æœ€åå‰ç«¯ä»æ•°æ®åº“ä¸­æŸ¥è¯¢æ‰€æœ‰æµ‹è¯•ç‚¹çš„è¿è¡Œç»“æœå¹¶æ˜¾ç¤ºåœ¨ç½‘é¡µä¸Šã€‚\nä»è¿™ä¸ªä¾‹å­ä¸­æˆ‘ä»¬å¯ä»¥çœ‹åˆ°æ•°æ®åº“ä½œä¸ºæ•´ä¸ªç³»ç»Ÿçš„å­˜å‚¨æ¢çº½ï¼Œå…¶å¯é æ€§ï¼Œå¤„ç†å¤§é‡å¹¶å‘äº‹åŠ¡çš„æ•ˆç‡ç­‰æ˜¯æ•´ä¸ªç³»ç»Ÿèƒ½åŠ›çš„å…³é”®ã€‚\nDistributed System åœ¨æ–°æ—¶ä»£ï¼Œå­˜å‚¨ç³»ç»Ÿéœ€è¦åº”å¯¹æµ·é‡çš„å®æ—¶æ•°æ®ã€‚æ„é€ ä¸€ä¸ª planet-scale çš„æ•°æ®åº“é­é‡äº†å‰æ‰€æœªæœ‰çš„æŒ‘æˆ˜ã€‚æˆ‘ä»¬é€šå¸¸ç”¨ CAP Theorem æ¥è¡¡é‡ä¸€ä¸ªæ•°æ®åº“çš„æ€§èƒ½ï¼š\nAvailability (A)ï¼šç”¨æˆ·èƒ½å¦åœ¨çŸ­æ—¶é—´å†…è¿…é€Ÿè·å–éœ€è¦çš„æ•°æ® Consistency (C)ï¼šç³»ç»Ÿæ˜¯å¦å¤„äºä¸€ä¸ªä¸€è‡´çš„çŠ¶æ€ï¼ŒåŒæ­¥æ˜¯å¦æ­£ç¡® (æ¯”å¦‚å…ˆâ€œå–å…³â€å†â€œå‘é€pyqâ€çš„æ“ä½œé¡ºåºå¦‚æœåœ¨åœ°ç†ä¸Šçš„å¦ä¸€ä¸ªæ•°æ®ä¸­å¿ƒååºä¼šé€ æˆä¸¥é‡çš„åæœ)ã€‚ Partition Tolerance (P)ï¼šç³»ç»Ÿå¯ä»¥å¿å—æ€æ ·è§„æ¨¡çš„å»¶è¿Ÿã€‚ åˆ†å¸ƒå¼ç³»ç»Ÿè¦é¢å¯¹çš„é—®é¢˜æ¯”â€œå¹¶å‘ç¼–ç¨‹â€è¦æ›´åŠ ä¸¥å³»ï¼šå¤šä¸ªçº¿ç¨‹è‡³å°‘æœ‰ä¸€ä¸ªå…±äº«çš„å†…å­˜å¯ä»¥äº¤æ¢æ•°æ®ã€å®ç°åŒæ­¥ï¼Œè€Œåˆ†å¸ƒå¼ç³»ç»Ÿå„ä¸ªèŠ‚ç‚¹ä¹‹é—´æ²¡æœ‰è¿™æ ·çš„å…±äº«èµ„æºï¼›æ­¤å¤–ï¼Œåˆ†å¸ƒå¼ç³»ç»Ÿçš„å‡è®¾æ˜¯ä»»ä½•ä¸€ä¸ªèŠ‚ç‚¹éƒ½å¯ä»¥åœ¨ä»»ä½•ä¸€ä¸ªæ—¶åˆ»â€œçªç„¶æ¶ˆå¤±â€ã€‚\nå¯¹åˆ†å¸ƒå¼ç³»ç»Ÿæ›´å‹å¥½çš„æ•°æ®æ¨¡å‹æ˜¯ key-value (å¯ä»¥ç†è§£ä¸º C++ çš„ std::map\u0026lt;\u0026gt;)ã€‚LevelDB æ˜¯ Google å¼€å‘çš„å®ç° key-value storage çš„åº“ã€‚æˆ‘ä»¬æœ€åŸºæœ¬çš„éœ€æ±‚æ˜¯å¢åŠ /åˆ é™¤ key-value å¯¹ï¼Œä»¥åŠå¯¹å½“å‰çš„çŠ¶æ€æ‰“å¿«ç…§ã€‚LevelDB ä½¿ç”¨ç±»ä¼¼äºæ—¥å¿—çš„æƒ³æ³•ï¼Œå¹¶ä¸æ˜¯ç»´æŠ¤ä¸€ä¸ªâ€œå¹³è¡¡æ ‘â€œï¼Œè€Œæ˜¯è®°å½•æ‰€æœ‰æ“ä½œçš„å†…å®¹ã€‚ä¸ºäº†è§£å†³è¯»æ”¾å¤§çš„é—®é¢˜ï¼ŒLevelDB æ„å»ºäº†ä¸€ä¸ªå¤šçº§çš„ç±»ä¼¼äº memory hierarchy çš„æ—¥å¿—ï¼Œè¯»æ“ä½œä¼˜å…ˆåˆ° Level 0 çš„ tree é‡Œå¯»æ‰¾ä¿¡æ¯ï¼Œæ‰¾ä¸åˆ°å»ä¸‹ä¸€å±‚ï¼Œä»¥æ­¤ç±»æ¨ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"b42896d5ed23dc5f1de9d71f31a0884f","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/lectures/lec30/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/lectures/lec30/","section":"notes","summary":"Abilities and Limitations of FS OJ æœ€ç®€å•çš„å®ç°æ–¹å¼å¯ä»¥å°±æ˜¯ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿã€‚æ¯”å¦‚ OS2022 è¯¾ç¨‹çš„å­¦ç”Ÿåå•å­˜æ”¾åœ¨ /OS2022/students.csv ä¸­ï¼Œå‘ Lab1 æäº¤çš„ä»£ç ä»¥ä¸€ä¸ªå‹ç¼©åŒ…çš„å½¢å¼å­˜æ”¾åœ¨ /OS2022/L1/studentid/xxxxxxxx.tar.bz2 ä¸­ã€‚OJ çš„å‰ç«¯å’Œåç«¯éƒ¨ç½²åœ¨ä¸åŒçš„æœºå™¨ä¸Šï¼Œåç«¯æœºå™¨é€šè¿‡ ssh è¿æ¥å‰ç«¯ï¼Œæ‰«ææ–‡ä»¶ç³»ç»Ÿå¯»æ‰¾ç¬¦åˆæ ¼å¼çš„æäº¤æ‹‰å›åå°ï¼Œè¯„æµ‹ä»¥åå‘é€ä¸€ä¸ª .tar.bz2.result æ–‡ä»¶ç»™å‰ç«¯ï¼Œå‰ç«¯å°±å¯ä»¥å°†è¯„æµ‹ç»“æœæ˜¾ç¤ºå‡ºæ¥ã€‚\nä½¿ç”¨æ–‡ä»¶ç³»ç»Ÿçš„æœ€å¤§å¥½å¤„æ˜¯ç®€å•ï¼šæˆ‘ä»¬æœ‰æµ·é‡çš„ UNIX å·¥å…·/æ ‡å‡†åº“å¯ä»¥å¤„ç†æ–‡ä»¶ã€‚æ¯”å¦‚æŸ¥è¯¢æŸä¸ªåŒå­¦çš„æäº¤å¯ä»¥ä½¿ç”¨å¦‚ä¸‹ python ä»£ç ï¼š\nfor f in wiki.UPLOAD_PATH.glob( f'{course}/{module}/{stuid}/{file_pattern}'): if not f.","tags":null,"title":"Lecture 30: Modern Storage System","type":"docs"},{"authors":null,"categories":null,"content":"æ“ä½œç³»ç»Ÿï¼šä¸ºä¸Šå±‚å¤šä¸ªåº”ç”¨ç¨‹åºçš„æ­£å¸¸è¿è¡Œæä¾›æ”¯æŒã€‚æ“ä½œç³»ç»Ÿå®ç°è¿™ä¸€ç›®çš„çš„é‡è¦æ–¹æ³•æ˜¯è™šæ‹ŸåŒ–ï¼šå°†ç¡¬ä»¶èµ„æºæŠ½è±¡æˆç®€å•æ˜“ç”¨çš„è™šæ‹Ÿèµ„æºã€‚ä¸ºäº†æ–¹ä¾¿ä¸Šå±‚åº”ç”¨ç¨‹åºä½¿ç”¨è¿™äº›èµ„æºï¼Œæ“ä½œç³»ç»Ÿä¼šæä¾›æ•°ç™¾ä¸ªç³»ç»Ÿè°ƒç”¨ã€‚ä»è¿™ä¸ªè§’åº¦æ¥çœ‹ï¼Œæ“ä½œç³»ç»Ÿä¹Ÿå¾ˆåƒä¸€ä¸ªæ ‡å‡†åº“ã€‚\n2.1 Virtualizing The CPU cpu.c çš„ä½œç”¨æ˜¯æ¯è¿‡ä¸€ç§’é’Ÿè¾“å‡ºä¸€æ¬¡å­—ç¬¦ä¸²ã€‚Spin(1) è¡¨ç¤ºç­‰å¾…ä¸€ç§’ï¼Œå…¶å®ç°åœ¨ common.h ä¸­ï¼Œå…¶ä¸­ GetTime() æ˜¯å¯¹ç³»ç»Ÿè°ƒç”¨ gettimeofday() çš„è¿›ä¸€æ­¥å°è£…ï¼Œè¿”å›ç³»ç»Ÿå¯åŠ¨ä»¥æ¥çš„ç§’æ•°ã€‚Spin() ä¼šä¸æ–­è°ƒç”¨ GetTime()ï¼Œç›´åˆ°é—´éš”æ—¶é—´è¾¾åˆ°è¾“å…¥å€¼ howlongã€‚\né”®å…¥å‘½ä»¤ ./cpu A \u0026amp; ; ./cpu B \u0026amp; ; ./cpu C \u0026amp; ; ./cpu D \u0026amp;ï¼Œå¯ä»¥çœ‹åˆ°A,B,C,D äº¤æ›¿è¾“å‡ºï¼Œä»¿ä½›å„è‡ªç‹¬å äº† CPUã€‚æ“ä½œç³»ç»Ÿé€šè¿‡è™šæ‹ŸåŒ– CPU çš„æ–¹å¼ï¼Œç»™ä¸Šå±‚åº”ç”¨ç¨‹åºä¸€ç§ç³»ç»Ÿä¸­æœ‰å¾ˆå¤šå¾ˆå¤šä¸ª CPU çš„å‡è±¡ã€‚è‡³äºå¤šä¸ªè¿›ç¨‹è°åœ¨çœŸæ­£çš„ç‰©ç† CPU ä¸Šè¿è¡Œï¼Œè¿™å–å†³äºæ“ä½œç³»ç»Ÿçš„è°ƒåº¦ç­–ç•¥ã€‚\nä¸ºä»€ä¹ˆç¨‹åºä¼šä¸åœè¾“å‡ºï¼ŒæŒ‰ Ctrl+C ä¹Ÿæ— æ³•åœæ­¢ï¼Ÿ\nä¸Šæ–‡ä¸­ï¼Œç”¨åˆ†å·éš”å¼€å„ä¸ªå‘½ä»¤è¡¨ç¤ºè¿™äº›å‘½ä»¤éƒ½è¦æ‰§è¡Œã€‚å®ƒå’Œ \u0026amp;\u0026amp; çš„åŒºåˆ«åœ¨äºï¼š\u0026amp;\u0026amp; è¦æ±‚ç¬¬ä¸€ä¸ªå‘½ä»¤æ‰§è¡ŒæˆåŠŸæ‰ä¼šæ‰§è¡Œç¬¬äºŒä¸ªå‘½ä»¤ï¼Œè€Œ ; ä¸è®ºç¬¬ä¸€ä¸ªå‘½ä»¤æ˜¯å¦æˆåŠŸéƒ½ä¼šæ‰§è¡Œç¬¬äºŒä¸ªå‘½ä»¤ (å¯ä»¥ç”¨ gcc notexist.c ; ls å’Œ gcc notexist.c \u0026amp;\u0026amp; ls åšå®éªŒéªŒè¯)ã€‚\nåœ¨å‘½ä»¤æœ€ååŠ ä¸Š \u0026amp; è¡¨ç¤ºå°†è¿™ä¸ªè¿›ç¨‹æ”¾åˆ°åå°æ‰§è¡Œï¼Œ Ctrl+C çš„æ„ä¹‰æ˜¯ä¸­æ–­æ‰€æœ‰æ­£åœ¨è¿è¡Œçš„å‰å°è¿›ç¨‹ï¼Œå› æ­¤è¯¥ç»„åˆé”®æ— æ³•ç»ˆæ­¢åå°è¿è¡Œçš„è¿›ç¨‹ã€‚å¦‚æœæŸä¸ªå‘½ä»¤æ‰€éœ€è¦çš„æ‰§è¡Œæ—¶é—´å¾ˆé•¿ï¼Œå¯ä»¥ç”¨ \u0026amp; å°†å…¶æ”¾åœ¨åå°æ‰§è¡Œï¼Œä»è€Œç»ˆç«¯ç•Œé¢ä»ç„¶å¯ä»¥ç»§ç»­æ“ä½œã€‚åœ¨ä½¿ç”¨ \u0026amp; æ—¶ï¼Œbash ä¼šæç¤ºåˆ†é…ç»™è¯¥ä»»åŠ¡çš„è¿›ç¨‹å·ã€‚å¦‚æœæƒ³è¦ç»“æŸåå°ä»»åŠ¡ï¼Œå¯ä»¥ä½¿ç”¨å‘½ä»¤ kill pid ã€‚\nè¿™é‡Œæˆ‘ä»¬ä½¿ç”¨ \u0026amp; çš„åŸå› åœ¨äºï¼šç”¨ ; åˆ†éš”çš„è‹¥å¹²å‘½ä»¤æ€»æ˜¯ä¼šä¾æ¬¡æ‰§è¡Œï¼Œå³ç¬¬ä¸€ä¸ªæ‰§è¡Œç»“æŸæ‰ä¼šæ‰§è¡Œç¬¬äºŒä¸ªã€‚è€Œ cpu ç¨‹åºä¸­æœ‰ä¸€ä¸ªæ­»å¾ªç¯ï¼Œä¸ºäº†è§‚æµ‹â€œå¹¶å‘â€ï¼Œæˆ‘ä»¬å¿…é¡»è®©å››ä¸ªä»»åŠ¡åŒæ—¶è¿è¡Œèµ·æ¥ã€‚\n2.2 Virtualizing Memory ç‰©ç†å†…å­˜æœ¬èº«æ²¡æœ‰ä»»ä½•ç‰¹æ®Šä¹‹å¤„ï¼Œå°±æ˜¯ä¸€ä¸ªå¤§æ•°ç»„ï¼Œæ¯ä¸ªä½ç½®æœ‰ä¸€ä¸ªç‰©ç†åœ°å€ã€‚\nmem.c ä¼šè°ƒç”¨ malloc() åˆ†é…ä¸€ä¸ªåœ°å€ï¼Œå¹¶ä¸æ–­å‘è¯¥åœ°å€å†™å…¥å†…å®¹ã€‚å¦‚æœæˆ‘ä»¬ä½¿ç”¨ ./mem 1 \u0026amp; ; ./mem 1 \u0026amp; å‘½ä»¤ï¼Œæˆ‘ä»¬ä¼šå‘ç°ä¸¤ä¸ªè¿›ç¨‹åˆ†é…çš„åœ°å€æ˜¯ä¸€æ ·çš„ï¼Œç„¶è€Œä¸¤ä¸ªè¿›ç¨‹éƒ½åœ¨å®Œå¥½åœ°è¿è¡Œã€‚è¿™æ˜¯å› ä¸ºæ¯ä¸ªè¿›ç¨‹éƒ½æœ‰è‡ªå·±çš„è™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œè¾“å‡ºçš„åœ°å€æ˜¯è¿›ç¨‹çš„è™šæ‹Ÿåœ°å€ï¼Œä¸åŒè¿›ç¨‹çš„ç›¸åŒè™šæ‹Ÿåœ°å€ä¼šæŒ‡å‘ä¸åŒçš„ç‰©ç†åœ°å€ã€‚æ“ä½œç³»ç»Ÿè´Ÿè´£è™šæ‹ŸåŒ–å†…å­˜ï¼Œä¿è¯æ¯ä¸ªè¿›ç¨‹åªèƒ½è®¿é—®è‡ªå·±çš„åœ°å€ç©ºé—´ã€‚\nä¸ºä»€ä¹ˆæˆ‘ä½¿ç”¨ä¸Šè¿°å‘½ä»¤æ— æ³•å¤ç°ï¼Œä¸¤ä¸ªåœ°å€ä¸ä¸€æ ·ï¼Ÿ\nLinux é»˜è®¤ä½¿ç”¨äº†åœ°å€ç©ºé—´éšæœºåŒ– (Address Space Layout Randomization, ASLR) æŠ€æœ¯ã€‚ASLR æ˜¯ä¸€ç§é’ˆå¯¹ç¼“å†²åŒºæº¢å‡ºæ”»å‡»çš„å®‰å…¨ä¿æŠ¤æŠ€æœ¯ï¼Œé€šè¿‡å¯¹å †ã€æ ˆã€å…±äº«åº“æ˜ å°„ç­‰å¸ƒå±€çš„éšæœºåŒ–å¢åŠ æ”»å‡»è€…é¢„æµ‹ç›®çš„åœ°å€çš„éš¾åº¦ï¼Œå…³äºåˆ©ç”¨å›ºå®šåœ°å€è¿›è¡Œæ”»å‡»çš„æ–¹æ³•å¯ä»¥è§ è¿™ç¯‡æ–‡ç« ã€‚åœ¨ /proc/sys/kernel/randomize_va_space æ–‡ä»¶ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥æŸ¥çœ‹å½“å‰ ASLR æ˜¯å¦æ‰“å¼€ï¼š0 è¡¨ç¤ºå…³é—­ï¼Œ1 è¡¨ç¤ºå¯¹äºéƒ¨åˆ†å‡½æ•°æ‰“å¼€ï¼Œ2 è¡¨ç¤ºå®Œå…¨æ‰“å¼€ã€‚\nä¸ºäº†æš‚æ—¶å…³é—­ ASLR ä»¥å¤ç°ä¸Šè¿°æƒ…å¢ƒï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å‘½ä»¤ï¼š\nsetarch `uname -m` -R /bin/zsh å…¶ä¸­ uname -m å‘½ä»¤ä¼šè¾“å‡ºæœºå™¨æ¶æ„ï¼Œè¯¥å‚æ•°å¯ä»¥çœç•¥ï¼›-R å‚æ•° (å¯¹åº”é•¿å‚æ•° --addr-no-randomize) è¡¨ç¤ºå…³é—­ ASLRã€‚æ‰§è¡Œè¯¥å‘½ä»¤ä¼šæš‚æ—¶æ‰“å¼€ä¸€ä¸ªæ–°çš„ shell (é»˜è®¤ /bin/shï¼Œå¯ä»¥é€šè¿‡æœ€åä¸€ä¸ªå‚æ•°æŒ‡å®šå…¶ä»– shell)ï¼Œè¯¥ shell å’Œå…¶å­è¿›ç¨‹ä¼šåœ¨å…³é—­ ASLR çš„æƒ…å†µä¸‹æ‰§è¡Œå‘½ä»¤ (é€€å‡ºè¯¥ shell åï¼Œä¸€åˆ‡æ¢å¤)ã€‚\nå¦å¤–ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨å‘½ä»¤\nsysctl -w kernel.randomize_va_space=0 æœºå™¨é‡å¯åè¯¥æ”¹å˜ä¼šæ¶ˆå¤±ã€‚å¦‚æœæƒ³è¦æ°¸ä¹…æ€§çš„å…³é—­ ASLRï¼Œå¯ä»¥å°† kernel.randomize_va_space=0 å†™åˆ° /etc/sysctl.conf ä¸­ã€‚\nå¦‚æœä½¿ç”¨ GDB è°ƒè¯•ï¼Œå¯ä»¥é€šè¿‡å‘½ä»¤ set disable-randomization off å…³é—­ ASLRã€‚\n2.3 Concurrency threads.c åˆ›å»ºäº†ä¸¤ä¸ªçº¿ç¨‹ï¼Œåˆ›å»ºçº¿ç¨‹è°ƒç”¨çš„å‡½æ•°æ˜¯ Pthread_create()ï¼Œå®ƒåœ¨ common_threads.h ä¸­å®šä¹‰ï¼Œæ˜¯å¯¹ POSIX çº¿ç¨‹åº“çš„ç®€å•å°è£…ï¼š\n#define Pthread_create(thread, attr, start_routine, arg) assert(pthread_create(thread, attr, start_routine, arg) == 0); #define Pthread_join(thread, value_ptr) assert(pthread_join(thread, value_ptr) == 0); è®©ä¸¤ä¸ªçº¿ç¨‹å„æ‰§è¡Œ N æ¬¡ +1 æ“ä½œï¼Œå¯ä»¥è§‚æµ‹åˆ°ç»“æœä¸æ˜¯ 2Nã€‚è¿™ä¸»è¦æ˜¯å› ä¸ºæ ¸å¿ƒè¯­å¥ counter++ ä¼šè¢«ç¼–è¯‘æˆä¸‰æ¡æ±‡ç¼–è¯­å¥ï¼š\nmov \u0026amp;counter, register add $1, register mov register, \u0026amp;counter ç”±äºåŸå­æ€§çš„ä¸§å¤±ï¼Œå¯èƒ½å‡ºç° race conditionã€‚\n2.4 Persistence æ•°æ®çš„æŒä¹…æ€§æ˜¯ä¸€ä¸ªé‡è¦çš„è¯é¢˜ã€‚å†…å­˜ä¸­å­˜å‚¨çš„æ•°æ®æ˜¯ä¸ç¨³å®šçš„â€”â€”æœºå™¨ä¸€æ—¦æ–­ç‚¹ï¼ŒDRAM ä¸­çš„ä¿¡æ¯å°±ä¼šä¸¢å¤±ã€‚æˆ‘ä»¬éœ€è¦ç¡¬ç›˜æ¥å­˜å‚¨é•¿æœŸæ•°æ®ï¼Œç¡¬ç›˜åœ¨ç°ä»£ç³»ç»Ÿä¸­è¢«çœ‹ä½œ I/O è®¾å¤‡çš„ä¸€éƒ¨åˆ†ï¼Œç®¡ç†ç¡¬ç›˜ä¿¡æ¯çš„è½¯ä»¶ç§°ä¸ºæ–‡ä»¶ç³»ç»Ÿã€‚\næ“ä½œç³»ç»Ÿå¯¹äºç¡¬ç›˜çš„æŠ½è±¡å’Œ CPUï¼Œå†…å­˜ä¸åŒã€‚æˆ‘ä»¬é’ˆå¯¹ CPU æŠ½è±¡å‡ºäº†è¿›ç¨‹ï¼Œå¯¹äºå†…å­˜æŠ½è±¡å‡ºäº†è™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œå…¶ç›®çš„éƒ½æ˜¯ä¸ºäº†è®©æŸä¸€ä¸ªç¨‹åºâ€œç‹¬å â€æ•´ä¸ªè®¡ç®—æœºèµ„æºã€‚è€Œç¡¬ç›˜ä¸Šçš„æ•°æ®ç†åº”è®©å„ä¸ªç¨‹åºå…±äº«ï¼Œæ¯”å¦‚ç¼–è¾‘å™¨åˆ›å»ºäº†ä¸€ä¸ªæ–‡ä»¶ï¼Œç„¶åç¼–è¯‘å™¨è´Ÿè´£ç¼–è¯‘å®ƒï¼Œæ¥ç€åŠ è½½å™¨è´Ÿè´£åŠ è½½ã€è¿è¡Œè¿™ä¸ªç¨‹åºã€‚æ“ä½œç³»ç»Ÿé€šè¿‡ç³»ç»Ÿè°ƒç”¨æ¥æŠ½è±¡ç¡¬ç›˜ï¼šå°†å¤æ‚çš„ç¡¬ä»¶è¯»å†™æ“ä½œå°è£…æˆç®€å•çš„æ¥å£ã€‚\nåœ¨ io.c ä¸­æˆ‘ä»¬ä½¿ç”¨äº† open() å’Œ write() ç³»ç»Ÿè°ƒç”¨æ¥åˆ›å»ºï¼Œå†™å…¥æ–‡ä»¶ã€‚è¿™äº›ç³»ç»Ÿè°ƒç”¨åº•å±‚çš„å®ç°éå¸¸å¤æ‚ (æ¯”å¦‚ä¸ºäº†æ€§èƒ½çš„æå‡ï¼Œè¯»å†™éƒ½æœ‰ç¼“å†²åŒº)ï¼Œä½†ä¸Šå±‚ä½¿ç”¨è¿™äº› API éå¸¸ç®€ä¾¿ã€‚OS åœ¨è¿™é‡Œå……å½“äº†æ ‡å‡†åº“çš„è§’è‰²ã€‚\n2.5 Design Goals æ“ä½œç³»ç»Ÿåº”å½“åŠªåŠ›è¿½æ±‚çš„ç›®æ ‡ï¼š\né«˜æ€§èƒ½ï¼› ä¿æŠ¤/éš”ç¦»ï¼šåº”ç”¨ç¨‹åºä¹‹é—´ä¸èƒ½äº’ç›¸â€œä¼¤å®³â€œï¼› å¯é ï¼šæ“ä½œç³»ç»Ÿä¸€æ—¦å´©æºƒï¼Œåœ¨å…¶ä¸Šè¿è¡Œçš„æ‰€æœ‰åº”ç”¨ç¨‹åºéƒ½æ— æ³•ä½¿ç”¨ï¼Œå› æ­¤æ“ä½œç³»ç»Ÿå¿…é¡»æ˜¯éå¸¸å¯é çš„è½¯ä»¶ã€‚ â€¦â€¦ ","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"d6f5abd56e37fe44c65ccd703d1a8af9","permalink":"https://kristoff-starling.github.io/notes/booknotes/ostep/ch02/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/booknotes/ostep/ch02/","section":"notes","summary":"æ“ä½œç³»ç»Ÿï¼šä¸ºä¸Šå±‚å¤šä¸ªåº”ç”¨ç¨‹åºçš„æ­£å¸¸è¿è¡Œæä¾›æ”¯æŒã€‚æ“ä½œç³»ç»Ÿå®ç°è¿™ä¸€ç›®çš„çš„é‡è¦æ–¹æ³•æ˜¯è™šæ‹ŸåŒ–ï¼šå°†ç¡¬ä»¶èµ„æºæŠ½è±¡æˆç®€å•æ˜“ç”¨çš„è™šæ‹Ÿèµ„æºã€‚ä¸ºäº†æ–¹ä¾¿ä¸Šå±‚åº”ç”¨ç¨‹åºä½¿ç”¨è¿™äº›èµ„æºï¼Œæ“ä½œç³»ç»Ÿä¼šæä¾›æ•°ç™¾ä¸ªç³»ç»Ÿè°ƒç”¨ã€‚ä»è¿™ä¸ªè§’åº¦æ¥çœ‹ï¼Œæ“ä½œç³»ç»Ÿä¹Ÿå¾ˆåƒä¸€ä¸ªæ ‡å‡†åº“ã€‚\n2.1 Virtualizing The CPU cpu.c çš„ä½œç”¨æ˜¯æ¯è¿‡ä¸€ç§’é’Ÿè¾“å‡ºä¸€æ¬¡å­—ç¬¦ä¸²ã€‚Spin(1) è¡¨ç¤ºç­‰å¾…ä¸€ç§’ï¼Œå…¶å®ç°åœ¨ common.h ä¸­ï¼Œå…¶ä¸­ GetTime() æ˜¯å¯¹ç³»ç»Ÿè°ƒç”¨ gettimeofday() çš„è¿›ä¸€æ­¥å°è£…ï¼Œè¿”å›ç³»ç»Ÿå¯åŠ¨ä»¥æ¥çš„ç§’æ•°ã€‚Spin() ä¼šä¸æ–­è°ƒç”¨ GetTime()ï¼Œç›´åˆ°é—´éš”æ—¶é—´è¾¾åˆ°è¾“å…¥å€¼ howlongã€‚\né”®å…¥å‘½ä»¤ ./cpu A \u0026amp; ; ./cpu B \u0026amp; ; ./cpu C \u0026amp; ; .","tags":null,"title":"Chapter 02: Introduction to Operating Systems","type":"docs"},{"authors":null,"categories":null,"content":"è¿›ç¨‹å°±æ˜¯æ­£åœ¨è¿è¡Œçš„ç¨‹åºã€‚ç¨‹åºæœ¬èº«åªæ˜¯å­˜å‚¨åœ¨ç¡¬ç›˜ä¸Šçš„æŒ‡ä»¤å’Œæ•°æ®çš„é›†åˆï¼Œåªæœ‰ OS å°†å…¶åŠ è½½åˆ°å†…å­˜ä¸­è¿è¡Œèµ·æ¥æ—¶ç¨‹åºæ‰ä¼šå‘æŒ¥ä½œç”¨ã€‚\né€šå¸¸æ“ä½œç³»ç»Ÿä¸Šä¼šè¿è¡Œå¤šä¸ªç¨‹åº - æ¯” CPU æ ¸ä¸ªæ•°æ›´å¤šçš„ç¨‹åºã€‚ä½†æ¯ä¸ªç¨‹åºå¹¶ä¸éœ€è¦å…³å¿ƒ CPU å½“å‰æ˜¯å¦å¯ç”¨ï¼Œè¿™æ˜¯å› ä¸º OS ä¸ºè¿›ç¨‹è™šæ‹ŸåŒ–äº† CPUã€‚OS çš„åŸºæœ¬æ“ä½œæ˜¯è¿è¡Œä¸€ä¸ªè¿›ç¨‹ï¼Œç„¶åæš‚åœå®ƒå»è¿è¡Œä¸€ä¼šå„¿å¦å¤–ä¸€ä¸ªè¿›ç¨‹ï¼Œè¿™æ˜¯åˆ†æ˜¯è¿è¡Œçš„åŸºæœ¬æ€æƒ³ã€‚\nä¸ºäº†å®ç° CPU çš„è™šæ‹ŸåŒ–ï¼ŒOS æ—¢éœ€è¦åº•å±‚çš„æœºåˆ¶ï¼Œä¹Ÿéœ€è¦ä¸Šå±‚çš„æ™ºæ…§ã€‚æ‰€è°“æœºåˆ¶ (mechanism) æŒ‡çš„æ˜¯å®ç°æŸä¸ªåŠŸèƒ½æ‰€éœ€è¦çš„ä¸€äº›åº•å±‚çš„æ–¹æ³•æˆ–åè®®ã€‚æ¯”å¦‚æ“ä½œç³»ç»Ÿä¸ºäº†å®ç°è¿›ç¨‹çš„åˆ‡æ¢ï¼Œå¿…é¡»è¦æœ‰ä¸Šä¸‹æ–‡åˆ‡æ¢çš„æœºåˆ¶ã€‚åˆ†æ—¶è¿è¡Œä¹Ÿæ˜¯ä¸€ç§æœºåˆ¶ï¼Œè¢«æ‰€æœ‰çš„ç°ä»£æ“ä½œç³»ç»Ÿé‡‡ç”¨ã€‚\nTime Sharing å’Œ Space Sharing\nTime Sharing æ˜¯ OS å…±äº«èµ„æºçš„ä¸€ç§åŸºæœ¬æ–¹å¼ï¼Œå³æ¯ä¸ªäººç”¨ä¸€ä¼šå„¿ï¼Œç„¶åæŠŠèµ„æºäº¤ç»™ä¸‹ä¸€ä¸ªäººã€‚Time sharing ä¸ä»…ä»…ç”¨åœ¨å¤šä¸ªè¿›ç¨‹/çº¿ç¨‹å…±äº« CPU ä¸Šï¼Œå…±äº«çš„èµ„æºéƒ½å¯ä»¥ä½¿ç”¨è¿™ç§æœºåˆ¶ï¼Œæ¯”å¦‚ç½‘ç»œè¿æ¥ã€‚\nä¸ time sharing äº’ä¸ºè¡¥å……çš„æ˜¯ space sharingã€‚ç£ç›˜å°±æ˜¯ä¸€ç§ space sharing çš„æ¨¡å‹ã€‚\nåœ¨æœºåˆ¶ä¹‹ä¸Šæ˜¯ç­–ç•¥ã€‚ç­–ç•¥ (policy) æ˜¯æ“ä½œç³»ç»Ÿåšå‡ºå†³å®šçš„ä¸€äº›ç®—æ³•ï¼Œæ¯”å¦‚å¦‚ä½•è°ƒåº¦å„ä¸ªè¿›ç¨‹å°±éœ€è¦ä¸€ä¸ª scheduling policyï¼Œè¿™é‡Œæœ‰å¤šç§å¯èƒ½æ€§ï¼Œæ¯”å¦‚æ ¹æ®ä¼˜å…ˆçº§ï¼Œæ ¹æ®å†å²è¿è¡Œæ—¶é•¿ç­‰ç­‰ (å¦‚æœè¯´æœºåˆ¶æ˜¯ OS å¿…é¡»çš„ä¸œè¥¿ï¼Œé‚£ä¹ˆç­–ç•¥å½±å“çš„å…¶å®åªæ˜¯æ•ˆç‡)ã€‚\nåŒºåˆ†æœºåˆ¶å’Œç­–ç•¥\næˆ‘ä»¬å¯ä»¥è¿™æ ·åŒºåˆ†æœºåˆ¶å’Œç­–ç•¥ï¼šæœºåˆ¶å›ç­”çš„æ˜¯ä¸€ä¸ª how questionï¼Œæ¯”å¦‚â€œå¦‚ä½•å®ç°ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Ÿâ€ è€Œç­–ç•¥å›ç­”çš„æ˜¯ä¸€ä¸ª which questionï¼Œæ¯”å¦‚â€œä¸‹ä¸€ä¸ªç”¨ CPU çš„åº”è¯¥æ˜¯å“ªä¸ªè¿›ç¨‹ï¼Ÿâ€\nåŒºåˆ†å¥½æœºåˆ¶å’Œç­–ç•¥ï¼Œæˆ‘ä»¬åœ¨ä¿®æ”¹ç­–ç•¥æ—¶å°±ä¸å¿…å…³æ³¨åº•å±‚çš„æœºåˆ¶ï¼Œæ›´åˆ©äºæ¨¡å—åŒ–ç¼–ç¨‹ã€‚\n4.1 The Abstraction: A Process OS ä¸ºæ­£åœ¨è¿è¡Œçš„ç¨‹åºæä¾›çš„æŠ½è±¡æ˜¯è¿›ç¨‹ã€‚è¿›ç¨‹ä¸­åŒ…æ‹¬çš„å†…å®¹å½“ç„¶æ˜¯ä¸€ä¸ªæ­£åœ¨è¿è¡Œçš„ç¨‹åºæ‰€æ‹¥æœ‰çš„æœºå™¨çŠ¶æ€ï¼š\nMemoryï¼šæ¯ä¸€ä¸ªç¨‹åºéƒ½æœ‰è‡ªå·±å¯ä»¥è¯»å†™çš„å†…å­˜åŒºåŸŸï¼Œç§°ä¸ºåœ°å€ç©ºé—´ (address space)ã€‚ Regitstersï¼šè¿›ç¨‹ä¸­åº”è¯¥æœ‰å„ä¸ªå¯„å­˜å™¨çš„ä¿¡æ¯ï¼Œå°¤å…¶æ˜¯å‡ ä¸ªæ¯”è¾ƒé‡è¦çš„å¯„å­˜å™¨ï¼šPCï¼Œstack pointerï¼Œframe pointer ç­‰ã€‚ I/O Informationï¼šç¨‹åºè¦å’Œå¯æŒä¹…åŒ–å­˜å‚¨è®¾å¤‡æ‰“äº¤é“ï¼Œå› æ­¤è¿›ç¨‹ä¼šå­˜å‚¨ä¸€äº› I/O ç›¸å…³ä¿¡æ¯ï¼Œæ¯”å¦‚å½“å‰æ‰“å¼€äº†å“ªäº›æ–‡ä»¶ã€‚ 4.2 Process API ä»æŠ½è±¡æ¨¡å‹çš„è§’åº¦ï¼Œæˆ‘ä»¬å¯ä»¥æå‡ºå¦‚ä¸‹å‡ ç±»è¿›ç¨‹ç›¸å…³çš„ APIï¼š\ncreateï¼šåˆ›å»ºä¸€ä¸ªæ–°çš„è¿›ç¨‹ã€‚ destroyï¼šè™½ç„¶ä¸€ä¸ªè¿è¡Œçš„ç¨‹åºç»“æŸæ—¶ä¼šè‡ªåŠ¨é€€å‡ºï¼Œä½†æˆ‘ä»¬ä»ç„¶åº”è¯¥æœ‰ API å¯ä»¥å¼ºåˆ¶æ€æ­»ä¸€ä¸ªè¿›ç¨‹ã€‚ waitï¼šç­‰å¾…ä¸€ä¸ªè¿›ç¨‹ç»“æŸã€‚ Miscellaneous Controlï¼šæ¯”å¦‚æš‚æ—¶æŒ‚èµ·ä¸€ä¸ªè¿›ç¨‹ï¼Œæˆ–è®©ä¸€ä¸ªè¿›ç¨‹ç»§ç»­è¿è¡Œã€‚ Statusï¼šè®¿é—®ä¸€ä¸ªè¿›ç¨‹çš„ä¿¡æ¯ï¼Œæ¯”å¦‚æ€»è¿è¡Œæ—¶é•¿ï¼Œç°åœ¨å¤„äºä»€ä¹ˆçŠ¶æ€ (running, suspended etc.) ç­‰ã€‚ 4.3 Process Creation: A Little More Detail åˆ›å»ºä¸€ä¸ªè¿›ç¨‹ (è®©ä¸€ä¸ªç¨‹åºè·‘èµ·æ¥) é€šå¸¸è¦ç»è¿‡ä»¥ä¸‹æ­¥éª¤ï¼š\nå°†ç¨‹åºçš„ä»£ç å’Œé™æ€æ•°æ® (æ¯”å¦‚åˆå§‹åŒ–è¿‡çš„å…¨å±€å˜é‡) åŠ è½½åˆ°å†…å­˜ä¸­ã€‚ç¨‹åºæœ¬èº«æ˜¯ä»¥æŸç§å¯æ‰§è¡Œæ–‡ä»¶çš„æ ¼å¼å­˜æ”¾åœ¨ç¡¬ç›˜ä¸Šçš„ (æ¯”å¦‚ Linux ä¸­é»˜è®¤ä½¿ç”¨ ELF)ï¼Œæ–‡ä»¶ä¼šå‘Šè¯‰ OS åº”è¯¥æŠŠå“ªäº›ä»£ç åŠ è½½åˆ°å†…å­˜çš„å“ªäº›ä½ç½®ã€‚\næ—©æœŸçš„æ“ä½œç³»ç»Ÿä¼š eagerly åœ°å®ŒæˆåŠ è½½è¿™ä¸ªåŠ¨ä½œã€‚ä½†ç°ä»£æ“ä½œç³»ç»Ÿé€šå¸¸ä½¿ç”¨å»¶è¿ŸåŠ è½½ï¼šå½“ç¨‹åºçœŸæ­£è¦ç”¨åˆ°æŸä¸€éƒ¨åˆ†çš„ä»£ç /æ•°æ®æ—¶å†å°†æ•°æ®ä»äº¤æ¢åˆ†åŒºå¤åˆ¶è¿›æ¥ã€‚\nä¸ºè¯¥ç¨‹åºå‡†å¤‡ä¸€ä¸ª run-time stackã€‚ä»¥ C ç¨‹åºä¸ºä¾‹ï¼Œç¨‹åºé€šå¸¸åœ¨æ ˆä¸Šå­˜å‚¨å±€éƒ¨å˜é‡ï¼Œæ­¤å¤–ä¼ ç»™ main() çš„å‚æ•°ä¹Ÿä¿å­˜åœ¨æ ˆä¸Šã€‚\nOS å‡†å¤‡ä¸€äº›ç©ºé—´ç”¨ä½œè¯¥ç¨‹åºçš„å †åŒºã€‚å †åŒºè´Ÿè´£ä¸ºç¨‹åºä¸­çš„åŠ¨æ€å†…å­˜ç”³è¯·æä¾›æ”¯æŒï¼Œå³ malloc()/free()ã€‚\nåšä¸€äº›å’Œ I/O ç›¸å…³çš„å‡†å¤‡å·¥ä½œï¼Œæ¯”å¦‚ UNIX ç³»ç»Ÿä¸­é»˜è®¤ä¸ºç¨‹åºæ‰“å¼€ stdin, stdout, stderr ä¸‰ä¸ªæ–‡ä»¶ã€‚\nè®© PC è·³è½¬åˆ°è¯¥ç¨‹åºçš„å…¥å£åœ°å€ï¼Œå¼€å§‹è¿è¡Œã€‚\n4.4 Process State è¿›ç¨‹çš„çŠ¶æ€é€šå¸¸åŒ…æ‹¬ä»¥ä¸‹å‡ ç§ï¼š\nRunningï¼šè¿›ç¨‹æ­£åœ¨ CPU ä¸Šè¿è¡Œã€‚ Readyï¼šç¨‹åºå¯ä»¥è¿è¡Œï¼Œä½†å½“å‰ä¸åœ¨ CPU ä¸Šã€‚ Blockedï¼šç¨‹åºå› ä¸ºåšäº†æŸç§æ“ä½œä½¿å¾—å½“å‰è¿˜ä¸èƒ½è¿è¡Œ (æ¯”å¦‚æ‰§è¡Œ I/Oï¼Œæ­£åœ¨ç­‰å¾…æ•°æ®è¿”å›)ã€‚ ä¸‹é¢çš„å›¾å¾ˆå¥½åœ°åæ˜ äº†ä¸‰ç§çŠ¶æ€çš„åˆ‡æ¢ï¼š\nstateDiagram Running --\u0026gt; Ready: Descheduled Ready --\u0026gt; Running: Scheduled Running --\u0026gt; Blocked: I/O Initiate Blocked --\u0026gt; Ready: I/O Done OS çš„è°ƒåº¦å™¨æœ‰å¾ˆå¤šäº‹æƒ…è¦å†³å®šï¼šæ¯”å¦‚ process 1 å› ä¸º I/O æ“ä½œè¢«é˜»å¡æ—¶ï¼Œæ˜¯å¦éœ€è¦å°†å…¶ä»–è¿›ç¨‹ process 2åˆ‡æ¢ä¸Šæ¥ï¼Ÿå¦‚æœ process 2 è¿è¡Œæ—¶ I/O æ“ä½œå®Œæˆï¼Œprocess 1 ä» blocked å˜æˆ readyï¼Œé‚£ä¹ˆ OS æ˜¯å°† process 1 ç«‹åˆ»è¯·å›æ¥è¿˜æ˜¯å…ˆåš process 2ï¼Ÿâ€¦â€¦\n4.5 Data Structure OS ä¸­æœ‰å¾ˆå¤šç»´æŠ¤ä¿¡æ¯çš„æ•°æ®ç»“æ„ï¼Œæ¯”å¦‚å¯¹äºè¿›ç¨‹æˆ‘ä»¬åº”è¯¥æœ‰ä¸€ä¸ª process listï¼Œé“¾è¡¨ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨ä¸€ä¸ªè¿›ç¨‹çš„ç›¸å…³ä¿¡æ¯ï¼Œé€šå¸¸è¢«ç§°ä¸º process control block (PCB)ï¼Œå†æ¯”å¦‚æˆ‘ä»¬åº”è¯¥æœ‰ä¸Šä¸‹æ–‡ç»“æ„ä½“ç”¨äº context switchingã€‚\n// the registers xv6 will save and restore // to stop and subsequently restart a process struct context { int eip; int esp; int ebx; int ecx; int edx; int esi; int edi; int ebp; }; // the different states a process can be in enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE }; // the information xv6 tracks about each process // including its register context and state struct proc { char *mem; // Start of process memory uint sz; // Size of process memory char *kstack; // Bottom of kernel stack for this process enum proc_state state; // Process state int pid; // Process ID struct proc *parent; // Parent process void *chan; // If non-zero, sleeping on chan int killed; // If non-zero, have been killed struct file *ofile[NOFILE]; // Open files struct inode *cwd; // Current directory struct context context; // Switch here to run process struct trapframe *tf; // Trap frame for the current interrupt }; è¿™æ˜¯ xv6-x86 ä¸­çš„ä¸Šä¸‹æ–‡ç»“æ„ä½“å’Œ PCBã€‚å¯ä»¥çœ‹åˆ°å®ƒå­˜å‚¨äº†æ¯”ä¹‹å‰æåˆ°çš„æ›´å¤šçš„ä¸€äº›ä¿¡æ¯ï¼Œæ¯”å¦‚æ¯ä¸ªè¿›ç¨‹çš„å†…æ ¸æ ˆåœ°å€ï¼Œçˆ¶è¿›ç¨‹ï¼Œå¦‚æœç¡çœ ç¡åœ¨äº†å“ªä¸ªåœ°å€ä¸Šï¼Œkernel trap çš„é¡µé¢åœ°å€ç­‰ã€‚\nè¿›ç¨‹çš„çŠ¶æ€ä¹Ÿæ¯”ä¹‹é—´æåˆ°çš„ ready, running, blocked è¦å¤šã€‚ä¸€äº›å¾ˆæœ‰ç”¨çš„çŠ¶æ€åŒ…æ‹¬ zombieï¼Œå®ƒè¡¨ç¤ºä¸€ä¸ªç¨‹åºå·²ç»è¿è¡Œç»“æŸï¼Œä½†ç›¸å…³çš„ä¿¡æ¯è¿˜æ²¡æœ‰è¢«æ¸…ç©ºã€‚è¿™ç§çŠ¶æ€å¯ä»¥è®©è°ƒç”¨ wait() çš„çˆ¶è¿›ç¨‹å»æ£€æŸ¥å­è¿›ç¨‹çš„è¿”å›å€¼æ˜¯å¦ç¬¦åˆè¦æ±‚ã€‚\n4.6 Summary ç•¥ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"a3a6bfb2f4aa3641cb5026afbf10de2a","permalink":"https://kristoff-starling.github.io/notes/booknotes/ostep/ch04/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/booknotes/ostep/ch04/","section":"notes","summary":"è¿›ç¨‹å°±æ˜¯æ­£åœ¨è¿è¡Œçš„ç¨‹åºã€‚ç¨‹åºæœ¬èº«åªæ˜¯å­˜å‚¨åœ¨ç¡¬ç›˜ä¸Šçš„æŒ‡ä»¤å’Œæ•°æ®çš„é›†åˆï¼Œåªæœ‰ OS å°†å…¶åŠ è½½åˆ°å†…å­˜ä¸­è¿è¡Œèµ·æ¥æ—¶ç¨‹åºæ‰ä¼šå‘æŒ¥ä½œç”¨ã€‚\né€šå¸¸æ“ä½œç³»ç»Ÿä¸Šä¼šè¿è¡Œå¤šä¸ªç¨‹åº - æ¯” CPU æ ¸ä¸ªæ•°æ›´å¤šçš„ç¨‹åºã€‚ä½†æ¯ä¸ªç¨‹åºå¹¶ä¸éœ€è¦å…³å¿ƒ CPU å½“å‰æ˜¯å¦å¯ç”¨ï¼Œè¿™æ˜¯å› ä¸º OS ä¸ºè¿›ç¨‹è™šæ‹ŸåŒ–äº† CPUã€‚OS çš„åŸºæœ¬æ“ä½œæ˜¯è¿è¡Œä¸€ä¸ªè¿›ç¨‹ï¼Œç„¶åæš‚åœå®ƒå»è¿è¡Œä¸€ä¼šå„¿å¦å¤–ä¸€ä¸ªè¿›ç¨‹ï¼Œè¿™æ˜¯åˆ†æ˜¯è¿è¡Œçš„åŸºæœ¬æ€æƒ³ã€‚\nä¸ºäº†å®ç° CPU çš„è™šæ‹ŸåŒ–ï¼ŒOS æ—¢éœ€è¦åº•å±‚çš„æœºåˆ¶ï¼Œä¹Ÿéœ€è¦ä¸Šå±‚çš„æ™ºæ…§ã€‚æ‰€è°“æœºåˆ¶ (mechanism) æŒ‡çš„æ˜¯å®ç°æŸä¸ªåŠŸèƒ½æ‰€éœ€è¦çš„ä¸€äº›åº•å±‚çš„æ–¹æ³•æˆ–åè®®ã€‚æ¯”å¦‚æ“ä½œç³»ç»Ÿä¸ºäº†å®ç°è¿›ç¨‹çš„åˆ‡æ¢ï¼Œå¿…é¡»è¦æœ‰ä¸Šä¸‹æ–‡åˆ‡æ¢çš„æœºåˆ¶ã€‚åˆ†æ—¶è¿è¡Œä¹Ÿæ˜¯ä¸€ç§æœºåˆ¶ï¼Œè¢«æ‰€æœ‰çš„ç°ä»£æ“ä½œç³»ç»Ÿé‡‡ç”¨ã€‚\nTime Sharing å’Œ Space Sharing\nTime Sharing æ˜¯ OS å…±äº«èµ„æºçš„ä¸€ç§åŸºæœ¬æ–¹å¼ï¼Œå³æ¯ä¸ªäººç”¨ä¸€ä¼šå„¿ï¼Œç„¶åæŠŠèµ„æºäº¤ç»™ä¸‹ä¸€ä¸ªäººã€‚Time sharing ä¸ä»…ä»…ç”¨åœ¨å¤šä¸ªè¿›ç¨‹/çº¿ç¨‹å…±äº« CPU ä¸Šï¼Œå…±äº«çš„èµ„æºéƒ½å¯ä»¥ä½¿ç”¨è¿™ç§æœºåˆ¶ï¼Œæ¯”å¦‚ç½‘ç»œè¿æ¥ã€‚","tags":null,"title":"Chapter 04: The Abstraction: The Process","type":"docs"},{"authors":null,"categories":null,"content":"5.1 The fork() System Call fork() ç³»ç»Ÿè°ƒç”¨ä¼šåˆ›å»ºä¸€ä¸ªå’Œå½“å‰è¿›ç¨‹å®Œå…¨ç›¸åŒçš„å­è¿›ç¨‹ï¼Œè¿™ä¸¤ä¸ªè¿›ç¨‹é™¤äº† fork() çš„è¿”å›å€¼ä¸åŒï¼Œå…¶ä»–å®Œå…¨ç›¸åŒã€‚fork() åœ¨çˆ¶è¿›ç¨‹ä¸­è¿”å›å­è¿›ç¨‹çš„è¿›ç¨‹å·ï¼Œåœ¨å­è¿›ç¨‹ä¸­è¿”å› 0ï¼Œè¿™å¯ä»¥ç”¨äºåŒºåˆ†ä¸¤ä¸ªè¿›ç¨‹ã€‚\np1.c å±•ç¤ºäº†ä¸€ä¸ªä½¿ç”¨ fork() çš„ä¾‹å­ï¼Œå…¶ä¸­ getpid() å‡½æ•°å¯ä»¥è·å¾—å½“å‰è¿›ç¨‹çš„è¿›ç¨‹å·ã€‚æ³¨æ„è¿™ä¸ªç¨‹åºçš„è¿è¡Œç»“æœæ˜¯ non-deterministic çš„ï¼šçˆ¶è¿›ç¨‹å’Œå­è¿›ç¨‹è°ä¼šå…ˆè¾“å‡ºï¼Œè¿™å–å†³äº OS çš„è°ƒåº¦å™¨ã€‚ç°ä»£æ“ä½œç³»ç»Ÿçš„è°ƒåº¦ç­–ç•¥æå…¶å¤æ‚ï¼Œå¯ä»¥çœ‹ è¿™ç¯‡æ–‡ç«  æœ‰ä¸€ä¸ªå¤§æ¦‚çš„äº†è§£ã€‚\n5.2 The wait() System Call p2.c å±•ç¤ºäº†ä¸€ä¸ªä½¿ç”¨ wait() çš„ä¾‹å­ï¼Œwait() æä¾›ä¸€ç§åŒæ­¥æœºåˆ¶ï¼Œä¿è¯äº†çˆ¶è¿›ç¨‹åœ¨å­è¿›ç¨‹ç»“æŸä¹‹åå†æ‰§è¡Œã€‚å¦‚æœçˆ¶è¿›ç¨‹å…ˆè¢«è°ƒåº¦å™¨é€‰ä¸­ï¼Œé‚£ä¹ˆå®ƒæ‰§è¡Œ wait() ä¼šè¢«é˜»å¡ï¼Œç›´åˆ°å­è¿›ç¨‹ç»“æŸï¼›å¦‚æœå­è¿›ç¨‹å…ˆè¢«è°ƒåº¦å™¨é€‰ä¸­ï¼Œé‚£ä¹ˆçˆ¶è¿›ç¨‹æ‰§è¡Œ wait() æ—¶çœ‹åˆ°å­è¿›ç¨‹å·²ç»é€€å‡ºåˆ™ä¼šç«‹åˆ»è¿”å›ã€‚\nZombie Process\nä¸€ä¸ªå­è¿›ç¨‹å¦‚æœå·²ç»é€€å‡ºä½†è¿˜æ²¡æœ‰è¢«å®ƒçš„çˆ¶è¿›ç¨‹ wait()ï¼Œé‚£å®ƒå°±æ˜¯ä¸€ä¸ªåƒµå°¸è¿›ç¨‹ã€‚å†…æ ¸ä¿å­˜äº†åƒµå°¸è¿›ç¨‹çš„ä¸€ä»½ minimal çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬è¿›ç¨‹å·ã€é€€å‡ºçŠ¶æ€ç­‰ï¼Œè¿™æ ·ä»¥åå¦‚æœçˆ¶è¿›ç¨‹ wait() äº†ï¼Œçˆ¶è¿›ç¨‹å°±å¯ä»¥è·å–å­è¿›ç¨‹çš„ä¿¡æ¯ã€‚\nè¢« wait() è¿‡çš„åƒµå°¸è¿›ç¨‹ä¼šè¢«ä» process table ä¸­ç§»é™¤ã€‚ä¸€ä¸ª zombie process å¦‚æœä¸è¢« waitï¼Œå°±ä¼šä¸€ç›´å¾…åœ¨ process table ä¸­ï¼Œä¸€æ—¦å†…æ ¸çš„ process table æ»¡äº†ï¼Œå°±ä¸èƒ½å†åˆ›å»ºæ–°çš„è¿›ç¨‹ã€‚å› æ­¤çˆ¶è¿›ç¨‹åº”è¯¥åŠæ—¶æ¸…ç†è‡ªå·±çš„åƒµå°¸å­è¿›ç¨‹ã€‚å¦‚æœçˆ¶è¿›ç¨‹é€€å‡ºäº†ï¼Œé‚£ä¹ˆå®ƒçš„åƒµå°¸å­è¿›ç¨‹ä¼šè¢« init è¿›ç¨‹ (æˆ–å…¶ä»–æŸä¸ªæŒ‡å®šçš„è¿›ç¨‹) wait æ‰ã€‚\n5.3 Finally, The exec() System Call p3.c å±•ç¤ºäº†ä¸€ä¸ªä½¿ç”¨ exec() çš„ä¾‹å­ã€‚exec() ä¼ å…¥ä¸€ä¸ªå¯æ‰§è¡Œç¨‹åºçš„æ–‡ä»¶åï¼Œå®ƒä¼šå°†è¯¥æ–‡ä»¶çš„ä»£ç å’Œæ•°æ®åŠ è½½åˆ°å†…å­˜ä¸­è¦†ç›–å½“å‰çš„ä»£ç å’Œæ•°æ®ï¼Œé‡æ–°åˆå§‹åŒ–å †åŒºå’Œæ ˆï¼Œå¹¶è·³è½¬åˆ°æ–°ç¨‹åºçš„å…¥å£å¼€å§‹æ‰§è¡Œã€‚exec() ä¸åˆ›å»ºæ–°çš„è¿›ç¨‹ï¼Œå®ƒåªæ˜¯é‡å¯å½“å‰çš„çŠ¶æ€æœºã€‚exec() å¦‚æœæ‰§è¡ŒæˆåŠŸå°±ä¸ä¼šè¿”å›ã€‚\n5.4 Why? Motivating the API å°† fork() å’Œ exec() åˆ†å¼€çš„è®¾è®¡ä¼¼ä¹æœ‰ä¸€äº›åäººç±»ï¼šæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªæ–°è¿›ç¨‹è¿è¡Œæ–°ç¨‹åºéœ€è¦ä¸¤ä¸ªç³»ç»Ÿè°ƒç”¨ã€‚è¿™æ ·è®¾è®¡çš„çœŸæ­£ç›®çš„æ˜¯è®©æˆ‘ä»¬æœ‰æœºä¼šåœ¨ fork() å’Œ exec() ä¹‹é—´åšä¸€äº›æœ‰æ„æ€çš„äº‹æƒ…ã€‚\np4.c å±•ç¤ºäº†ä¸€ä¸ªé‡å®šå‘çš„ä¾‹å­ã€‚æˆ‘ä»¬åœ¨ fork() ä¹‹å exec() ä¹‹å‰å…³é—­ stdoutï¼Œå†æ‰“å¼€ä¸€ä¸ªæ–°çš„æ–‡ä»¶ï¼Œè¿™æ ·æ–°æ‰“å¼€çš„æ–‡ä»¶çš„æè¿°ç¬¦å°±æ˜¯ 1 (stdout)ï¼Œè¿™æ˜¯å† exec()ï¼Œæˆ‘ä»¬å°±å®ç°äº†å°†æ ‡å‡†è¾“å‡ºé‡å®šå‘åˆ°æ–‡ä»¶ã€‚é™¤äº†é‡å®šå‘ï¼ŒUNIX çš„ç®¡é“æœºåˆ¶ä¹Ÿæ˜¯é€šè¿‡åœ¨ fork() å’Œ exec() ä¸­é—´æ“ä½œå®ç°çš„ã€‚\n5.5 Process Control And Users é™¤äº† fork(), wait() å’Œ exec()ï¼ŒUNIX ç³»ç»Ÿä¸­è¿˜æœ‰å¾ˆå¤šå…¶ä»–æ§åˆ¶è¿›ç¨‹çš„ APIï¼Œæ¯”å¦‚ kill() ç”¨äºç»™è¿›ç¨‹å‘é€ä¿¡å·ã€‚ä¿¡å·æœºåˆ¶å¯ä»¥å‘è¿›ç¨‹é€šçŸ¥å¤–éƒ¨äº‹ä»¶çš„å‘ç”Ÿï¼Œå¸¸è§çš„ä¿¡å·æœ‰ SIGINT (interruptï¼Œé€šå¸¸ç”¨äºç»“æŸç¨‹åº)ï¼ŒSIGTSTP (æš‚æ—¶æŒ‚èµ·ç¨‹åº)ï¼ŒSIGSEGV (æ®µé”™è¯¯) ç­‰ã€‚\næ—¢ç„¶ä¿¡å·çš„èƒ½åŠ›è¿™ä¹ˆå¼ºï¼Œé‚£ä¹ˆè‚¯å®šä¸èƒ½è®©ä»»æ„ç”¨æˆ·éšä¾¿ç»™åˆ«äººçš„è¿›ç¨‹å‘é€ SIGINTã€‚ä½ éœ€è¦é€šè¿‡å¯†ç ç™»å½•è·å–ç®¡ç†å‘˜æƒé™ï¼Œæˆ–è€…ä½ æœ¬èº«æ˜¯ root ç”¨æˆ·ï¼Œæ‰èƒ½æ‰§è¡Œè¿™äº›ç³»ç»Ÿèµ„æºç›¸å…³çš„æ“ä½œã€‚åœ¨ç”¨æˆ·æ€ï¼Œä½ åªèƒ½ç®¡ç†ä½ è‡ªå·±çš„è¿›ç¨‹ã€‚\n5.6 Useful Tools ps å‘½ä»¤å¯ä»¥æŸ¥çœ‹å½“å‰æ´»è·ƒçš„è¿›ç¨‹ã€‚top å‘½ä»¤å¯ä»¥æŸ¥çœ‹æ‰€æœ‰è¿›ç¨‹çš„è¯¦ç»†ä¿¡æ¯ã€‚\n5.7 Summary ç•¥ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"c3f256f949d066bbdd30648e722a1aa5","permalink":"https://kristoff-starling.github.io/notes/booknotes/ostep/ch05/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/booknotes/ostep/ch05/","section":"notes","summary":"5.1 The fork() System Call fork() ç³»ç»Ÿè°ƒç”¨ä¼šåˆ›å»ºä¸€ä¸ªå’Œå½“å‰è¿›ç¨‹å®Œå…¨ç›¸åŒçš„å­è¿›ç¨‹ï¼Œè¿™ä¸¤ä¸ªè¿›ç¨‹é™¤äº† fork() çš„è¿”å›å€¼ä¸åŒï¼Œå…¶ä»–å®Œå…¨ç›¸åŒã€‚fork() åœ¨çˆ¶è¿›ç¨‹ä¸­è¿”å›å­è¿›ç¨‹çš„è¿›ç¨‹å·ï¼Œåœ¨å­è¿›ç¨‹ä¸­è¿”å› 0ï¼Œè¿™å¯ä»¥ç”¨äºåŒºåˆ†ä¸¤ä¸ªè¿›ç¨‹ã€‚\np1.c å±•ç¤ºäº†ä¸€ä¸ªä½¿ç”¨ fork() çš„ä¾‹å­ï¼Œå…¶ä¸­ getpid() å‡½æ•°å¯ä»¥è·å¾—å½“å‰è¿›ç¨‹çš„è¿›ç¨‹å·ã€‚æ³¨æ„è¿™ä¸ªç¨‹åºçš„è¿è¡Œç»“æœæ˜¯ non-deterministic çš„ï¼šçˆ¶è¿›ç¨‹å’Œå­è¿›ç¨‹è°ä¼šå…ˆè¾“å‡ºï¼Œè¿™å–å†³äº OS çš„è°ƒåº¦å™¨ã€‚ç°ä»£æ“ä½œç³»ç»Ÿçš„è°ƒåº¦ç­–ç•¥æå…¶å¤æ‚ï¼Œå¯ä»¥çœ‹ è¿™ç¯‡æ–‡ç«  æœ‰ä¸€ä¸ªå¤§æ¦‚çš„äº†è§£ã€‚\n5.2 The wait() System Call p2.c å±•ç¤ºäº†ä¸€ä¸ªä½¿ç”¨ wait() çš„ä¾‹å­ï¼Œwait() æä¾›ä¸€ç§åŒæ­¥æœºåˆ¶ï¼Œä¿è¯äº†çˆ¶è¿›ç¨‹åœ¨å­è¿›ç¨‹ç»“æŸä¹‹åå†æ‰§è¡Œã€‚å¦‚æœçˆ¶è¿›ç¨‹å…ˆè¢«è°ƒåº¦å™¨é€‰ä¸­ï¼Œé‚£ä¹ˆå®ƒæ‰§è¡Œ wait() ä¼šè¢«é˜»å¡ï¼Œç›´åˆ°å­è¿›ç¨‹ç»“æŸï¼›å¦‚æœå­è¿›ç¨‹å…ˆè¢«è°ƒåº¦å™¨é€‰ä¸­ï¼Œé‚£ä¹ˆçˆ¶è¿›ç¨‹æ‰§è¡Œ wait() æ—¶çœ‹åˆ°å­è¿›ç¨‹å·²ç»é€€å‡ºåˆ™ä¼šç«‹åˆ»è¿”å›ã€‚","tags":null,"title":"Chapter 05: Interlude: Process API","type":"docs"},{"authors":null,"categories":null,"content":"13.1 Early Systems æ—©æœŸçš„ç³»ç»Ÿéå¸¸ç®€å•ï¼Œæ“ä½œç³»ç»Ÿæ²¡æœ‰ä¸ºç¨‹åºæä¾›ä»»ä½•çš„æŠ½è±¡ï¼Œæ•´ä¸ªè®¡ç®—æœºä¸­åªæœ‰ä¸€ä¸ªç‰©ç†åœ°å€ç©ºé—´ï¼Œæ“ä½œç³»ç»Ÿä»£ç ä»¥åŠæ“ä½œç³»ç»Ÿä¸ºç¨‹åºæä¾›çš„ä¸€äº›åº“å‡½æ•°å­˜æ”¾åœ¨å†…å­˜ä¸­ï¼Œæ­¤å¤–è¿˜æœ‰ä¸€ä¸ªè¿è¡Œçš„ç¨‹åºï¼Œå®ƒå¯ä»¥ä½¿ç”¨å‰©ä¸‹çš„å†…å­˜ã€‚\n13.2 Multiprogramming and Time Sharing éšç€æ—¶ä»£å‘å±•ï¼Œäººä»¬å¯¹è®¡ç®—æœºçš„éœ€æ±‚æ¿€å¢ï¼Œäºæ˜¯ä¸€ä¸ªè®¡ç®—æœºä¸Šéœ€è¦è¿è¡Œå¤šä¸ªç¨‹åºï¼Œç”±æ“ä½œç³»ç»Ÿè´Ÿè´£è°ƒåº¦ç¨‹åºçš„è¿è¡Œï¼Œtime sharing çš„æ¦‚å¿µä¹Ÿè¢«æäº†å‡ºæ¥ã€‚ä¸€ä¸ªæœ€ç®€å•çš„æƒ³æ³•æ˜¯ï¼šå…ˆå°†ç¬¬ä¸€ä¸ªç¨‹åºåŠ è½½åˆ°å†…å­˜ä¸­ï¼Œè®©å®ƒæ‹¥æœ‰å…¨éƒ¨çš„åœ°å€ç©ºé—´ï¼Œå®ƒçš„æ—¶é—´ç‰‡ç”¨å®Œä¹‹åï¼Œå°†æ•´ä¸ªå†…å­˜çŠ¶æ€ä¿å­˜åˆ°ç£ç›˜ä¸Šï¼Œç„¶ååŠ è½½ä¸‹ä¸€ä¸ªç¨‹åºã€‚è¿™ä¸ªåšæ³•å› ä¸ºæ•ˆç‡å¤ªä½è€Œè¢«æ·˜æ±°ã€‚\näººä»¬å¸Œæœ›åœ¨è¿›ç¨‹åˆ‡æ¢çš„æ—¶å€™ï¼Œè¢«åˆ‡çš„ç¨‹åºçš„çŠ¶æ€å¯ä»¥ä»ç„¶ä¿ç•™åœ¨å†…å­˜ä¸­ï¼Œç­‰å¾…ä¸‹æ¬¡è¢«åˆ‡å›æ¥çš„æ—¶å€™ç»§ç»­ä½¿ç”¨ã€‚è¿™æ · OS è°ƒåº¦å°±ä¼šæ›´æœ‰æ•ˆç‡ã€‚å°†å„ä¸ªè¿›ç¨‹çš„çŠ¶æ€åŒæ—¶ä¿å­˜åœ¨å†…å­˜ä¸­å°±å¿…ç„¶æ¶‰åŠåˆ°ä¿æŠ¤é—®é¢˜ï¼Œæˆ‘ä»¬ä¸å¸Œæœ›ä¸€ä¸ªè¿›ç¨‹å¯ä»¥å¹²æ‰°å¦ä¸€ä¸ªè¿›ç¨‹çš„çŠ¶æ€ã€‚\n13.3 The Address Space åœ°å€ç©ºé—´æ˜¯æ“ä½œç³»ç»Ÿæä¾›ç»™è¿è¡Œä¸­çš„ç¨‹åºçš„å†…å­˜çš„æ¨¡æ ·ã€‚è¿è¡Œä¸­çš„ç¨‹åºçœ‹åˆ°çš„å†…å­˜åŒ…æ‹¬ä¸‰ä¸ªéƒ¨åˆ†ï¼šä»£ç åŒºï¼Œæ ˆåŒºå’Œå †åŒºã€‚ä»£ç åŒºçš„å†…å®¹æ˜¯å›ºå®šä¸å˜çš„ï¼Œé€šå¸¸æ”¾åœ¨åœ°å€ç©ºé—´åº•éƒ¨ã€‚æ ˆåŒºå’Œå †åŒºçš„å¤§å°éƒ½æ˜¯ä¼šåŠ¨æ€å˜åŒ–çš„ï¼Œå› æ­¤ä»–ä»¬é€šå¸¸ä¸€ä¸ªåœ¨åº•éƒ¨ä¸€ä¸ªåœ¨é¡¶éƒ¨ï¼Œä¸¤è€…å¾€ç›¸åçš„æ–¹å‘ç”Ÿé•¿ã€‚\néœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè™½ç„¶åœ¨è¿›ç¨‹çœ¼ä¸­åœ°å€ç©ºé—´æ˜¯è¿™ç§ç®€æ´çš„ç»“æ„ï¼Œä½†è¿™æ˜¯æ“ä½œç³»ç»Ÿæä¾›ç»™è¿›ç¨‹çš„ illusionï¼Œåœ¨å®é™…çš„ç‰©ç†å†…å­˜ä¸­ï¼Œä¸€ä¸ªè¿›ç¨‹çš„åœ°å€ç©ºé—´å¯èƒ½ä¼šè¢«å­˜æ”¾åœ¨ä»»æ„ä½ç½®ã€‚æ“ä½œç³»ç»Ÿé€šè¿‡è™šæ‹ŸåŒ–å†…å­˜çš„æ–¹å¼æ¥ä¸ºè¿›ç¨‹æä¾›è¿™ç§ illusionï¼šè¿›ç¨‹çœ¼ä¸­çš„åœ°å€éƒ½æ˜¯è™šæ‹Ÿåœ°å€ï¼Œæ“ä½œç³»ç»Ÿ/MMUç¡¬ä»¶è´Ÿè´£å°†è™šæ‹Ÿåœ°å€æ˜ å°„åˆ°æ­£ç¡®çš„ç‰©ç†åœ°å€ã€‚\nThe Principle Of Isolation\néš”ç¦»æ˜¯æ„å»ºä¸€ä¸ªå¯é ç³»ç»Ÿçš„å¿…è¦æ¡ä»¶ã€‚åœ¨æœ‰æ•ˆéš”ç¦»çš„æƒ…å†µä¸‹ï¼Œä¸€ä¸ªç¨‹åºçš„å´©æºƒä¸ä¼šå½±å“åˆ«çš„ç¨‹åºçš„è¿è¡Œã€‚æ“ä½œç³»ç»Ÿé€šè¿‡è™šæ‹Ÿå†…å­˜ç­‰å„ç§æ‰‹æ®µä¿è¯éš”ç¦»ï¼Œä¸€äº›ç°ä»£çš„å†…æ ¸é€šè¿‡å°†å†…æ ¸å„ä¸ªæ¨¡å—æ‹†å¼€çš„æ–¹å¼åšåˆ°äº†æ›´å¼ºçš„éš”ç¦»ï¼Œè¿™ç§å¾®å†…æ ¸è®¾è®¡æ¯”ä¼ ç»Ÿçš„å®å†…æ ¸æ›´å®‰å…¨ã€‚\n13.4 Goals è™šæ‹Ÿå†…å­˜çš„ç›®æ ‡å¦‚ä¸‹ï¼š\né€æ˜ (transparency)ï¼šç¨‹åºä¸åº”è¯¥æ„Ÿå—åˆ°å®ƒä»¬è·å¾—çš„å†…å­˜æ˜¯è™šæ‹Ÿçš„ï¼Œæ¯ä¸ªç¨‹åºéƒ½åº”è¯¥è§‰å¾—è‡ªå·±åœ¨ç‹¬å æ•´ä¸ªç‰©ç†å†…å­˜ã€‚ æ•ˆç‡ (efficiency)ï¼šä¸€æ–¹é¢è™šæ‹Ÿå†…å­˜æœºåˆ¶ä¸èƒ½å¤ªæ…¢ï¼Œå¦ä¸€æ–¹é¢å­˜å‚¨æ˜ å°„è¡¨ä¸èƒ½è€—è´¹å¤ªå¤šç©ºé—´ã€‚ä¸ºäº†è¾¾åˆ°è¿™ä¸€ç‚¹ï¼Œä¸€æ–¹é¢æ“ä½œç³»ç»Ÿéœ€è¦è®¾è®¡ç²¾å·§çš„æ•°æ®ç»“æ„ (é¡µè¡¨)ï¼Œä¸€æ–¹é¢ä¹Ÿéœ€è¦ç¡¬ä»¶çš„å¸®åŠ© (æ¯”å¦‚ TLB ä½œä¸ºé¡µè¡¨çš„ cache)ã€‚ ä¿æŠ¤ (protection)ï¼šä»»ä½•ç¨‹åºçš„è¡Œä¸ºéƒ½ä¸èƒ½å½±å“åˆ«çš„ç¨‹åºã€‚ä¸åŒçš„ç¨‹åºä¹‹é—´åº”å½“å½¢æˆéš”ç¦»ã€‚ Every Address You See Is Virtual\næˆ‘ä»¬ç¨‹åºå‘˜åœ¨ç”¨æˆ·æ€èƒ½çœ‹åˆ°çš„æ‰€æœ‰åœ°å€éƒ½æ˜¯è™šæ‹Ÿåœ°å€ã€‚ä¸è®ºæ˜¯ä»£ç æ®µçš„åœ°å€ï¼Œmalloc() è·å¾—çš„å †åŒºåœ°å€ï¼Œè¿˜æ˜¯ä»»æ„ä¸€ä¸ªæŒ‡é’ˆçš„å€¼ï¼Œéƒ½æ˜¯è™šæ‹Ÿåœ°å€ã€‚åªæœ‰æ“ä½œç³»ç»Ÿ (å’Œç¡¬ä»¶) çŸ¥é“çœŸæ­£çš„ç‰©ç†åœ°å€ã€‚\nä¸‹é¢çš„ç¨‹åº va.c æ‰“å°äº†ä¸€ä¸ªä»£ç åœ°å€ã€ä¸€ä¸ªå †åŒºåœ°å€å’Œä¸€ä¸ªæ ˆä¸Šçš„åœ°å€ã€‚\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(int argc, char *argv[]) { printf(\u0026quot;location of code : %p\\n\u0026quot;, (void *) main); printf(\u0026quot;location of heap : %p\\n\u0026quot;, (void *) malloc(1)); int x = 3; printf(\u0026quot;location of stack : %p\\n\u0026quot;, (void *) \u0026amp;x); return x; } åœ¨ Linux ä¸‹ï¼Œè¯¥ç¨‹åºè¾“å‡ºç»“æœä¸º\nlocation of code : 0x55aa61491189 location of heap : 0x55aa62a0b6b0 location of stack : 0x7ffd13ff4374 å¯ä»¥çœ‹åˆ°è™šæ‹Ÿåœ°å€ç©ºé—´ä¸­ï¼Œä»£ç æ®µåœ¨åº•éƒ¨ï¼Œå †åŒºåœ¨ä»£ç æ®µä¹‹ä¸Šï¼Œæ ˆåœ¨åœ°å€ç©ºé—´çš„å¦ä¸€å¤´ã€‚ä¸è¿‡è¿™æ•´ä¸ªç»“æ„éƒ½æ˜¯æ“ä½œç³»ç»Ÿä¸ºæˆ‘ä»¬è™šæ‹Ÿå‡ºæ¥çš„ã€‚\n13.5 Summary è™šæ‹Ÿå†…å­˜ç³»ç»Ÿçš„ä»»åŠ¡æ˜¯ä¸ºæ¯ä¸ªè¿›ç¨‹æä¾›ä¸€ä¸ªå¤§çš„ï¼Œç§æœ‰çš„åœ°å€ç©ºé—´ï¼Œè®©ç¨‹åºå­˜å‚¨å…¶æ‰€æœ‰çš„ä»£ç å’Œç›¸å…³æ•°æ®ã€‚æ“ä½œç³»ç»Ÿå’Œç›¸å…³çš„ç¡¬ä»¶ä¼šåœ¨èƒŒåè´Ÿè´£è™šæ‹Ÿåœ°å€åˆ°ç‰©ç†åœ°å€çš„ç¿»è¯‘ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"34718d25f26a364d35e6614c8ea42fad","permalink":"https://kristoff-starling.github.io/notes/booknotes/ostep/ch13/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/booknotes/ostep/ch13/","section":"notes","summary":"13.1 Early Systems æ—©æœŸçš„ç³»ç»Ÿéå¸¸ç®€å•ï¼Œæ“ä½œç³»ç»Ÿæ²¡æœ‰ä¸ºç¨‹åºæä¾›ä»»ä½•çš„æŠ½è±¡ï¼Œæ•´ä¸ªè®¡ç®—æœºä¸­åªæœ‰ä¸€ä¸ªç‰©ç†åœ°å€ç©ºé—´ï¼Œæ“ä½œç³»ç»Ÿä»£ç ä»¥åŠæ“ä½œç³»ç»Ÿä¸ºç¨‹åºæä¾›çš„ä¸€äº›åº“å‡½æ•°å­˜æ”¾åœ¨å†…å­˜ä¸­ï¼Œæ­¤å¤–è¿˜æœ‰ä¸€ä¸ªè¿è¡Œçš„ç¨‹åºï¼Œå®ƒå¯ä»¥ä½¿ç”¨å‰©ä¸‹çš„å†…å­˜ã€‚\n13.2 Multiprogramming and Time Sharing éšç€æ—¶ä»£å‘å±•ï¼Œäººä»¬å¯¹è®¡ç®—æœºçš„éœ€æ±‚æ¿€å¢ï¼Œäºæ˜¯ä¸€ä¸ªè®¡ç®—æœºä¸Šéœ€è¦è¿è¡Œå¤šä¸ªç¨‹åºï¼Œç”±æ“ä½œç³»ç»Ÿè´Ÿè´£è°ƒåº¦ç¨‹åºçš„è¿è¡Œï¼Œtime sharing çš„æ¦‚å¿µä¹Ÿè¢«æäº†å‡ºæ¥ã€‚ä¸€ä¸ªæœ€ç®€å•çš„æƒ³æ³•æ˜¯ï¼šå…ˆå°†ç¬¬ä¸€ä¸ªç¨‹åºåŠ è½½åˆ°å†…å­˜ä¸­ï¼Œè®©å®ƒæ‹¥æœ‰å…¨éƒ¨çš„åœ°å€ç©ºé—´ï¼Œå®ƒçš„æ—¶é—´ç‰‡ç”¨å®Œä¹‹åï¼Œå°†æ•´ä¸ªå†…å­˜çŠ¶æ€ä¿å­˜åˆ°ç£ç›˜ä¸Šï¼Œç„¶ååŠ è½½ä¸‹ä¸€ä¸ªç¨‹åºã€‚è¿™ä¸ªåšæ³•å› ä¸ºæ•ˆç‡å¤ªä½è€Œè¢«æ·˜æ±°ã€‚\näººä»¬å¸Œæœ›åœ¨è¿›ç¨‹åˆ‡æ¢çš„æ—¶å€™ï¼Œè¢«åˆ‡çš„ç¨‹åºçš„çŠ¶æ€å¯ä»¥ä»ç„¶ä¿ç•™åœ¨å†…å­˜ä¸­ï¼Œç­‰å¾…ä¸‹æ¬¡è¢«åˆ‡å›æ¥çš„æ—¶å€™ç»§ç»­ä½¿ç”¨ã€‚è¿™æ · OS è°ƒåº¦å°±ä¼šæ›´æœ‰æ•ˆç‡ã€‚å°†å„ä¸ªè¿›ç¨‹çš„çŠ¶æ€åŒæ—¶ä¿å­˜åœ¨å†…å­˜ä¸­å°±å¿…ç„¶æ¶‰åŠåˆ°ä¿æŠ¤é—®é¢˜ï¼Œæˆ‘ä»¬ä¸å¸Œæœ›ä¸€ä¸ªè¿›ç¨‹å¯ä»¥å¹²æ‰°å¦ä¸€ä¸ªè¿›ç¨‹çš„çŠ¶æ€ã€‚\n13.3 The Address Space åœ°å€ç©ºé—´æ˜¯æ“ä½œç³»ç»Ÿæä¾›ç»™è¿è¡Œä¸­çš„ç¨‹åºçš„å†…å­˜çš„æ¨¡æ ·ã€‚è¿è¡Œä¸­çš„ç¨‹åºçœ‹åˆ°çš„å†…å­˜åŒ…æ‹¬ä¸‰ä¸ªéƒ¨åˆ†ï¼šä»£ç åŒºï¼Œæ ˆåŒºå’Œå †åŒºã€‚ä»£ç åŒºçš„å†…å®¹æ˜¯å›ºå®šä¸å˜çš„ï¼Œé€šå¸¸æ”¾åœ¨åœ°å€ç©ºé—´åº•éƒ¨ã€‚æ ˆåŒºå’Œå †åŒºçš„å¤§å°éƒ½æ˜¯ä¼šåŠ¨æ€å˜åŒ–çš„ï¼Œå› æ­¤ä»–ä»¬é€šå¸¸ä¸€ä¸ªåœ¨åº•éƒ¨ä¸€ä¸ªåœ¨é¡¶éƒ¨ï¼Œä¸¤è€…å¾€ç›¸åçš„æ–¹å‘ç”Ÿé•¿ã€‚\néœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè™½ç„¶åœ¨è¿›ç¨‹çœ¼ä¸­åœ°å€ç©ºé—´æ˜¯è¿™ç§ç®€æ´çš„ç»“æ„ï¼Œä½†è¿™æ˜¯æ“ä½œç³»ç»Ÿæä¾›ç»™è¿›ç¨‹çš„ illusionï¼Œåœ¨å®é™…çš„ç‰©ç†å†…å­˜ä¸­ï¼Œä¸€ä¸ªè¿›ç¨‹çš„åœ°å€ç©ºé—´å¯èƒ½ä¼šè¢«å­˜æ”¾åœ¨ä»»æ„ä½ç½®ã€‚æ“ä½œç³»ç»Ÿé€šè¿‡è™šæ‹ŸåŒ–å†…å­˜çš„æ–¹å¼æ¥ä¸ºè¿›ç¨‹æä¾›è¿™ç§ illusionï¼šè¿›ç¨‹çœ¼ä¸­çš„åœ°å€éƒ½æ˜¯è™šæ‹Ÿåœ°å€ï¼Œæ“ä½œç³»ç»Ÿ/MMUç¡¬ä»¶è´Ÿè´£å°†è™šæ‹Ÿåœ°å€æ˜ å°„åˆ°æ­£ç¡®çš„ç‰©ç†åœ°å€ã€‚\nThe Principle Of Isolation\néš”ç¦»æ˜¯æ„å»ºä¸€ä¸ªå¯é ç³»ç»Ÿçš„å¿…è¦æ¡ä»¶ã€‚åœ¨æœ‰æ•ˆéš”ç¦»çš„æƒ…å†µä¸‹ï¼Œä¸€ä¸ªç¨‹åºçš„å´©æºƒä¸ä¼šå½±å“åˆ«çš„ç¨‹åºçš„è¿è¡Œã€‚æ“ä½œç³»ç»Ÿé€šè¿‡è™šæ‹Ÿå†…å­˜ç­‰å„ç§æ‰‹æ®µä¿è¯éš”ç¦»ï¼Œä¸€äº›ç°ä»£çš„å†…æ ¸é€šè¿‡å°†å†…æ ¸å„ä¸ªæ¨¡å—æ‹†å¼€çš„æ–¹å¼åšåˆ°äº†æ›´å¼ºçš„éš”ç¦»ï¼Œè¿™ç§å¾®å†…æ ¸è®¾è®¡æ¯”ä¼ ç»Ÿçš„å®å†…æ ¸æ›´å®‰å…¨ã€‚\n13.4 Goals è™šæ‹Ÿå†…å­˜çš„ç›®æ ‡å¦‚ä¸‹ï¼š","tags":null,"title":"Chapter 13: The Abstraction: The Address Space","type":"docs"},{"authors":null,"categories":null,"content":"14.1 Types of Memory åœ¨ä¸€ä¸ª C ç¨‹åºä¸­ï¼Œç¨‹åºä½¿ç”¨çš„å†…å­˜æœ‰ä¸¤ç§ï¼š\næ ˆå†…å­˜ï¼Œè¿™éƒ¨åˆ†å†…å­˜çš„åˆ†é…å’Œå›æ”¶ç”±ç¼–è¯‘å™¨éšå¼åœ°å®Œæˆï¼Œå› æ­¤ä¹Ÿè¢«ç§°ä¸ºâ€œè‡ªåŠ¨å†…å­˜â€ã€‚åœ¨ C ç¨‹åºä¸­å£°æ˜ä½¿ç”¨æ ˆå†…å­˜æ˜¯éå¸¸ç®€å•çš„ï¼Œæ¯”å¦‚ void func() { int x; // declares an integer on the stack ... } ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨åœ¨æ ˆä¸Šä¸ºå˜é‡ x åˆ†é…ç©ºé—´ï¼Œä¸”å‡½æ•° func() ç»“æŸæ—¶ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨å›æ”¶è¿™éƒ¨åˆ†å†…å­˜ã€‚\nå †å†…å­˜ï¼šå¦‚æœæˆ‘ä»¬æƒ³è¦ä¸€äº›é•¿ç”Ÿå­˜å‘¨æœŸ (ä¸åªå­˜æ´»åœ¨å‡½æ•°å†…éƒ¨) çš„å†…å­˜ï¼Œæˆ‘ä»¬å°±è¦ä½¿ç”¨å †å†…å­˜ã€‚å †å†…å­˜æ˜¯ç”±ç¨‹åºå‘˜åœ¨ç¨‹åºä¸­æ˜¾å¼ç”³è¯·çš„ï¼Œåˆ†é…å’Œé‡Šæ”¾éƒ½ç”±ç¨‹åºå‘˜è´Ÿè´£ã€‚ä¸€ä¸ªä¾‹å­å¦‚ä¸‹ï¼š\nvoid func() { int *x = (int *)malloc(sizeof(int)); ... } malloc() å‡½æ•°è´Ÿè´£åœ¨å †åŒºç”³è¯·äº†ä¸€ä¸ª int å¤§å°çš„å†…å­˜ï¼Œè€Œè¿™ä¸ªå†…å­˜çš„åœ°å€è¢«ä¿å­˜åœ¨äº†æŒ‡é’ˆå˜é‡ x ä¸­ï¼Œè¿™ä¸ªåœ°å€æ˜¯å­˜å‚¨åœ¨æ ˆä¸Šçš„ã€‚\n14.2 The malloc() Call malloc() çš„å£°æ˜å¦‚ä¸‹ï¼š\n#include \u0026lt;stdlib.h\u0026gt; void *malloc(size_t size); ä¼ å…¥éœ€è¦åˆ†é…çš„å¤§å°ï¼Œmalloc() è¦ä¹ˆè¿”å› NULL è¡¨ç¤ºåˆ†é…å¤±è´¥ï¼Œè¦ä¹ˆè¿”å›ä¸€ä¸ªåœ°å€è¡¨ç¤ºåˆ†é…åŒºåŸŸçš„èµ·å§‹ä½ç½®ã€‚\nå°å¿ƒ sizeof() çš„è¡Œä¸ºï¼\nä¸‹é¢ä¸¤æ®µä»£ç çš„è¾“å‡ºè¡Œä¸ºæ˜¯ä¸åŒçš„ï¼\nint x[10]; printf(\u0026quot;%d\\n\u0026quot;, sizeof(x)); è¿™é‡Œ sizeof() ä¼šè¿”å›æ•´ä¸ªæ•°ç»„çš„å¤§å° 40ã€‚\nint *x = malloc(10 * sizeof(int)); printf(\u0026quot;%d\\n\u0026quot;, sizeof(x)); è¿™é‡Œ sizeof() ä¼šè®¤ä¸ºä½ åªæ˜¯æƒ³çŸ¥é“ int æŒ‡é’ˆçš„å¤§å°ï¼Œå› æ­¤ä¼šè¿”å› 4 (32/64bit machine)ã€‚\n14.3 The free() Call free() API çš„å‚æ•°åªæœ‰ä¸€ä¸ªï¼Œåªéœ€è¦ç»™ä»–ä¼ æŸä¸ª malloc() è¿”å›çš„é¦–åœ°å€æŒ‡é’ˆå³å¯ã€‚åˆ†é…åŒºåŸŸçš„å¤§å°æ˜¯ç”±å†…å­˜åˆ†é…åº“è‡ªå·±è®°å½•çš„ã€‚\n14.4 Common Errors ç¨‹åºå‘˜è‡ªå·±ç®¡ç† malloc() å’Œ free() æ€»æ˜¯ä¼šå‡ºç°å„ç§ç»†å¾®çš„é”™è¯¯ï¼Œå› æ­¤å¾ˆå¤šç°ä»£çš„ç¼–ç¨‹è¯­è¨€æ”¯æŒè‡ªåŠ¨å†…å­˜åˆ†é…ï¼Œå³æŸäº›åœºæ™¯ä¸‹å³ä½¿ç¨‹åºå‘˜åªç®¡åˆ†é…ä¸ç®¡å›æ”¶ï¼Œåƒåœ¾æ”¶é›†å™¨ (garbage collector) ä¹Ÿä¼šå¸®ä½ æŠŠå›æ”¶çš„è„æ´»å¹²å®Œã€‚\nForgetting To Allocate Memory é”™è¯¯çš„ä¾‹å­ï¼š\nchar *src = \u0026quot;Hello\u0026quot;; char *dst; strcpy(dst, src); æ­£ç¡®çš„ä¾‹å­ï¼š\nchar *src = \u0026quot;Hello\u0026quot;; char *dst = (char *)malloc(strlen(src) + 1); // å°å¿ƒï¼åˆ«å¿˜äº†+1,'\\0'ä¹Ÿè¦è¢«å¤åˆ¶è¿‡æ¥ strcpy(dst, src); äº‹å®ä¸Š glibc è¿˜æä¾›äº† strdup() å‡½æ•°ï¼Œæˆ‘ä»¬åªéœ€è¦æŒ‡å®šéœ€è¦å¤åˆ¶çš„å‡½æ•°ï¼Œå®ƒå°±ä¼šè‡ªåŠ¨å¸®æˆ‘ä»¬ malloc() ç©ºé—´ï¼Œå¤åˆ¶å­—ç¬¦ä¸²ï¼Œå¹¶è¿”å›æŒ‡å‘å¤åˆ¶å­—ç¬¦ä¸²çš„æŒ‡é’ˆã€‚\nNot Allocating Enough Memory åˆ†é…çš„å†…å­˜ä¸å¤Ÿä¸ä¸€å®šä¼šæš´éœ²é—®é¢˜ï¼Œä½†ä¸€æ—¦æœ‰åˆ«çš„å˜é‡è¢«è¦†ç›–å°±ä¼šå¯¼è‡´ä¸¥é‡çš„åæœã€‚\nForgetting to Initialize Allocated Memory å¯¹ malloc() å¾—åˆ°çš„å†…å­˜ä¸­çš„åˆå§‹å€¼ä½œå‡ºä»»ä½•å‡è®¾éƒ½å±äº undefined behaviorã€‚\nForgetting to Free Memory å†…å­˜æ³„æ¼æ˜¯ä¸€ç§å¸¸è§çš„é”™è¯¯ã€‚å¦‚æœç¨‹åºå‘˜æ€»æ˜¯å¿˜äº†é‡Šæ”¾å†…å­˜ï¼Œé‚£ä¹ˆé•¿æ—¶é—´è¿è¡Œçš„è½¯ä»¶å°±æœ‰å¯èƒ½å°†å †åŒºæ¶ˆè€—æ®†å°½ï¼Œæœ€ç»ˆåªèƒ½é‡å¯æœºå™¨ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå³ä½¿ä½ ä½¿ç”¨çš„æ˜¯å¸¦æœ‰ garbage collector çš„è¯­è¨€ï¼Œä½ ä»ç„¶å¯èƒ½æ— æ³•é¿å…è¿™ç§é”™è¯¯ï¼šå¦‚æœä½ è¿˜æœ‰ä»»ä½•ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘æŸæ®µå†…å­˜ï¼Œå³ä½¿ä½ å°†æ¥ä¸å†ç”¨è¿™æ®µå†…å­˜ï¼Œgarbage collector ä¹Ÿä¸ä¼šå°†å…¶å›æ”¶ã€‚\nåœ¨æŸäº›æƒ…å†µä¸‹ä¸ä½¿ç”¨ free() å¯èƒ½æ˜¯æ— å®³çš„ï¼Œæ¯”å¦‚ä½ å†™ä¸€ä¸ªçŸ­ç”Ÿå‘½å‘¨æœŸçš„ç¨‹åº (OJç¨‹åº)ï¼Œé‚£ä¹ˆè¿›ç¨‹é€€å‡ºçš„æ—¶å€™æ“ä½œç³»ç»Ÿä¼šæŠŠè¯¥è¿›ç¨‹ä½¿ç”¨çš„æ‰€æœ‰èµ„æºé‡Šæ”¾ã€‚ä½†åªåˆ†é…ä¸é‡Šæ”¾æ˜¯å¾ˆåçš„ç¼–ç¨‹ä¹ æƒ¯ã€‚\nFreeing Memory Before You Are Done With It åœ¨é‡Šæ”¾äº†ä¸€æ®µå†…å­˜åä»ç„¶ä½¿ç”¨å…¶ä¸­çš„å†…å®¹æ˜¯å±é™©çš„ï¼Œè¿™ç§æŒ‡é’ˆè¢«ç§°ä¸º dangling pointerã€‚use-after-free å±äº undefined behaviorï¼Œå¯èƒ½å¯¼è‡´ä¸¥é‡åæœï¼šæ¯”å¦‚å¦‚æœå†…å­˜åˆ†é…å™¨å°†è¿™æ®µå†…å­˜åˆåˆ†é…ç»™äº†åˆ«äººï¼Œå°±ä¼šå‡ºç°ä¸¤äººåŒæ—¶ä½¿ç”¨ä¸€æ®µå†…å­˜çš„æƒ…å†µã€‚\nFreeing Memory Repeatly double free ä¹Ÿæ˜¯ undefined behaviorï¼Œå¯èƒ½å¯¼è‡´å†…å­˜åˆ†é…å™¨å´©æºƒã€‚\nCalling free() Incorrectly ç»™ free() ä¼ é€’é”™è¯¯çš„æŒ‡é’ˆ (ä¸æ˜¯ä¹‹å‰æŸä¸ª malloc() çš„è¿”å›å€¼) ä¹Ÿå¯èƒ½é€ æˆä¸¥é‡çš„åæœã€‚\n14.5 Underlying OS Support æ“ä½œç³»ç»Ÿæä¾› brk() å’Œ sbrk() ä¸¤ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œç”¨äºä¿®æ”¹è¿›ç¨‹çš„ breakï¼šbreak æŒ‡å‘è¿›ç¨‹å †åŒºçš„é¡¶éƒ¨ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ malloc() å’Œ free() è¿™ä¸¤ä¸ªåº“å‡½æ•°ä¼šä½¿ç”¨ OS çš„ç³»ç»Ÿè°ƒç”¨ï¼Œåœ¨ç¨‹åºå‘˜å±‚é¢æˆ‘ä»¬ä¸è¦è·¨çº§å»ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨ï¼Œå¦åˆ™å¯èƒ½å¯¼è‡´æ„æƒ³ä¸åˆ°çš„ç»“æœï¼Œåœ¨ç”¨æˆ·å±‚é¢æˆ‘ä»¬åªè¦ä½¿ç”¨åº“å‡½æ•°å³å¯ã€‚\nå¦å¤–ä¸€ä¸ªå¯ä»¥è·å¾—å†…å­˜çš„ç³»ç»Ÿè°ƒç”¨æ˜¯ mmap()ï¼Œä¼ å…¥æ­£ç¡®çš„å‚æ•°åï¼Œmmap() å¯ä»¥è¿”å›ä¸€æ®µåŒ¿åçš„å†…å­˜åŒºåŸŸï¼Œè¿™ä¸ªåŒºåŸŸå¹¶ä¸å±äºä»»ä½•ä¸€ä¸ªæ–‡ä»¶ï¼Œè€Œæ˜¯ç£ç›˜ä¸Šäº¤æ¢ç©ºé—´ (swap space) çš„ä¸€éƒ¨åˆ†ã€‚å¯¹äºåº”ç”¨ç¨‹åºæ¥è¯´ï¼Œè¿™æ ·ä¸€æ®µå†…å­˜å¯ä»¥è¢«å½“ä½œå †åŒºå†…å­˜ä½¿ç”¨ã€‚\n14.6 Other Calls ä¸€äº›å…¶ä»–æœ‰ç”¨çš„åº“å‡½æ•°åŒ…æ‹¬ä½†ä¸é™äºï¼š\ncalloc()ï¼šå…ˆ malloc() å†å°†åˆ†é…çš„å†…å­˜æ¸…é›¶ã€‚ realloc()ï¼šå½“ä½ è°ƒç”¨ malloc() åˆ†é…äº†ä¸€æ®µå†…å­˜ï¼Œä½†å‘ç°å¤§å°ä¸è¶³æ—¶ï¼Œå¯ä»¥è°ƒç”¨ realloc()ï¼Œå®ƒä¼šåˆ†é…ä¸€æ®µæ›´å¤§çš„å†…å­˜ï¼Œå°†æ—§å†…å­˜ä¸­çš„å†…å®¹å¤åˆ¶åˆ°æ–°å†…å­˜åŒºåŸŸä¸­ï¼Œå¹¶è¿”å›æ–°å†…å­˜çš„æŒ‡é’ˆã€‚ 14.7 Summary ç•¥ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"5afef218a131830fa7d3bda3843029df","permalink":"https://kristoff-starling.github.io/notes/booknotes/ostep/ch14/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/booknotes/ostep/ch14/","section":"notes","summary":"14.1 Types of Memory åœ¨ä¸€ä¸ª C ç¨‹åºä¸­ï¼Œç¨‹åºä½¿ç”¨çš„å†…å­˜æœ‰ä¸¤ç§ï¼š\næ ˆå†…å­˜ï¼Œè¿™éƒ¨åˆ†å†…å­˜çš„åˆ†é…å’Œå›æ”¶ç”±ç¼–è¯‘å™¨éšå¼åœ°å®Œæˆï¼Œå› æ­¤ä¹Ÿè¢«ç§°ä¸ºâ€œè‡ªåŠ¨å†…å­˜â€ã€‚åœ¨ C ç¨‹åºä¸­å£°æ˜ä½¿ç”¨æ ˆå†…å­˜æ˜¯éå¸¸ç®€å•çš„ï¼Œæ¯”å¦‚ void func() { int x; // declares an integer on the stack ... } ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨åœ¨æ ˆä¸Šä¸ºå˜é‡ x åˆ†é…ç©ºé—´ï¼Œä¸”å‡½æ•° func() ç»“æŸæ—¶ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨å›æ”¶è¿™éƒ¨åˆ†å†…å­˜ã€‚\nå †å†…å­˜ï¼šå¦‚æœæˆ‘ä»¬æƒ³è¦ä¸€äº›é•¿ç”Ÿå­˜å‘¨æœŸ (ä¸åªå­˜æ´»åœ¨å‡½æ•°å†…éƒ¨) çš„å†…å­˜ï¼Œæˆ‘ä»¬å°±è¦ä½¿ç”¨å †å†…å­˜ã€‚å †å†…å­˜æ˜¯ç”±ç¨‹åºå‘˜åœ¨ç¨‹åºä¸­æ˜¾å¼ç”³è¯·çš„ï¼Œåˆ†é…å’Œé‡Šæ”¾éƒ½ç”±ç¨‹åºå‘˜è´Ÿè´£ã€‚ä¸€ä¸ªä¾‹å­å¦‚ä¸‹ï¼š","tags":null,"title":"Chapter 14: Interlude: Memory API","type":"docs"},{"authors":null,"categories":null,"content":"åŠ¨æ€å¤§å°çš„å†…å­˜åˆ†é…æ˜¯æ¯”è¾ƒå›°éš¾çš„ï¼šéšç€åå¤çš„åˆ†é…å’Œé‡Šæ”¾ï¼Œç©ºé—²å†…å­˜ä¼šè¢«åˆ‡åˆ†æˆå¾ˆå¤šç¢ç‰‡ï¼Œæ­¤æ—¶å³ä½¿ç©ºé—²ç©ºé—´çš„æ€»é‡å¤§äºæŸä¸ªåˆ†é…éœ€æ±‚ï¼Œåˆ†é…ä¹Ÿå¯èƒ½å› ä¸ºå‰©ä½™ç©ºé—´è¿‡äºç¢ç‰‡åŒ–è€Œå¤±è´¥ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åœ¨ç®¡ç†ç©ºé—²ç©ºé—´æ—¶è¦å…¼é¡¾æ•ˆç‡ã€ç©ºé—²ç©ºé—´è¿ç»­æ€§ã€å†…å­˜æ¶ˆè€—ç­‰å¤šæ–¹é¢å› ç´ ã€‚\n17.1 Assumptions è¿™é‡Œæˆ‘ä»¬å‡è®¾å†…å­˜ç”³è¯·å’Œé‡Šæ”¾çš„æ¥å£å’Œ C åº“ä¸­çš„ malloc()/free() ç›¸åŒï¼š\nvoid *malloc(size_t size); void free(void *ptr); æ³¨æ„ï¼šé‡Šæ”¾ç©ºé—´æ—¶ï¼Œè°ƒç”¨è€…åªä¼ å…¥èµ·å§‹åœ°å€ï¼Œä¸ä¼ å…¥ç©ºé—´çš„ sizeï¼Œå› æ­¤æˆ‘ä»¬åœ¨åˆ†é…æ—¶å°±è¦æƒ³åŠæ³•è®°å½•æ¯å—åˆ†é…å‡ºå»çš„ç©ºé—´çš„å¤§å°ã€‚\nåˆ†é…ç©ºé—´çš„è¿‡ç¨‹ä¸­ä¸¥ç¦å‡ºç° double-alloc çš„æƒ…å†µã€‚\n17.2 Low-level Mechanisms Splitting and Coalescing æˆ‘ä»¬ç”¨ä¸€ä¸ªé“¾è¡¨ç»´æŠ¤æ‰€æœ‰çš„ç©ºé—²å†…å­˜åŒºé—´ï¼Œé“¾è¡¨çš„æ¯ä¸ªèŠ‚ç‚¹ä»£è¡¨ä¸€æ®µè¿ç»­çš„ç©ºé—²å†…å­˜ï¼Œæœ‰èµ·å§‹åœ°å€ï¼Œå—å¤§å°ç­‰å­—æ®µã€‚å½“æˆ‘ä»¬è¦åˆ†é…ä¸€æ®µå†…å­˜å‡ºå»ï¼Œä¸”åˆ†é…å¤§å°å°äºå½“å‰é“¾è¡¨èŠ‚ç‚¹å¤§å°æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å°†é“¾è¡¨èŠ‚ç‚¹çš„å‰åŠéƒ¨åˆ†åˆ‡å‡ºå»ç»™è°ƒç”¨è€…ï¼ŒååŠéƒ¨åˆ†ä¿ç•™åœ¨é“¾è¡¨ä¸­ã€‚è¿™å°±æ˜¯ splittingã€‚\nå½“ free() å°†ä¸€æ®µå†…å­˜ç©ºé—´é‡Šæ”¾æ—¶ï¼Œå¦‚æœæˆ‘ä»¬ä¸åŠ ä»»ä½•æ“ä½œåœ°å°†å…¶æ”¾åˆ°é“¾è¡¨å¤´ï¼Œæ—¶é—´ä¹…äº†å°±ä¼šå‡ºç°å®Œæ•´çš„ç©ºé—²å†…å­˜è¢«æˆ‘ä»¬äººä¸ºåœ°åˆ‡æˆäº†è‹¥å¹²ä¸ªé¦–å°¾ç›¸æ¥çš„æ®µçš„æƒ…å†µã€‚ä¸€ä¸ªå¥½çš„ç»´æŠ¤æ–¹æ³•æ˜¯ï¼šé“¾è¡¨ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹æŒ‰ç…§é¡ºåºæ’åˆ—ï¼Œæ¯å½“æ–°æ’å…¥èŠ‚ç‚¹æ—¶ï¼Œå°†å…¶ä¸å‰åç›¸é‚»çš„èŠ‚ç‚¹æ¯”è¾ƒï¼Œå¦‚æœåœ°å€è¿åœ¨äº†ä¸€èµ·å°±åˆå¹¶èŠ‚ç‚¹ã€‚è¿™å°±æ˜¯ coalescingã€‚\nTracking The Size Of Allocated Regions free() å‡½æ•°ä¼ å…¥çš„åªæœ‰å¾…é‡Šæ”¾å†…å­˜ç©ºé—´çš„èµ·å§‹åœ°å€ï¼Œæˆ‘ä»¬å¿…é¡»åœ¨åˆ†é…çš„æ—¶å€™æƒ³åŠæ³•è®°å½•åˆ†é…å‡ºå»çš„ç©ºé—´å¤§å°ã€‚ä¸€ç§æ–¹æ³•æ˜¯åœ¨åˆ†é…åŒºåŸŸé¦–åœ°å€çš„å‰é¢è®°å½•ä¸€ä¸ª headerï¼š\ntypedef struct __header_t { int size; int magic; }header_t; å½“ free(void *ptr) æ¥åˆ°æ—¶ï¼Œæˆ‘ä»¬é¦–å…ˆåœ¨ ptr å‰æ–¹çš„ header å¤„æ£€æŸ¥é­”æ•°æ˜¯å¦æ­£ç¡®ä»¥åˆ¤å®šè¿™æ˜¯å¦æ˜¯ä¸€ä¸ªåˆæ³•çš„å¯é‡Šæ”¾åœ°å€ã€‚å¦‚æœé­”æ•°æ£€æŸ¥é€šè¿‡ï¼Œæˆ‘ä»¬ä¾¿å¯ä»¥å–å‡º sizeã€‚æ³¨æ„æœ€ååŠ å…¥ç©ºé—²ç©ºé—´é“¾è¡¨çš„æ€»å¤§å°åº”ä¸º size + sizeof(header_t)ã€‚\nEmbedding A Free List æˆ‘ä»¬éœ€è¦ç©ºé—´æ¥ä¿å­˜é“¾è¡¨ï¼Œä½†æˆ‘ä»¬ä½œä¸º memory allocator æœ¬èº«ï¼Œå½“ç„¶ä¸èƒ½è°ƒç”¨ malloc() å»ç”³è¯·å†…å­˜ã€‚æˆ‘ä»¬åº”å½“å°†é“¾è¡¨èŠ‚ç‚¹ç›´æ¥ä¿å­˜åœ¨ç©ºé—²çš„å†…å­˜ç©ºé—´é‡Œã€‚\nå½“ä¸€ä¸ª alloc() éœ€æ±‚æ¥ä¸´æ—¶ï¼Œé€‰æ‹©ä¸€ä¸ªåˆæ³•çš„èŠ‚ç‚¹ split å‡ºéœ€è¦çš„ç©ºé—´ã€‚å½“ä¸€ä¸ª free() æ¥ä¸´æ—¶ï¼Œå°†æ–°çš„ç©ºé—²ç©ºé—´èŠ‚ç‚¹åŠ å…¥é“¾è¡¨ï¼Œå¹¶åœ¨å¯ä»¥æ—¶ä¸ç›¸é‚»èŠ‚ç‚¹åˆå¹¶ã€‚\nGrowing The Heap å½“æ‰«æå®Œæ•´ä¸ªç©ºé—²ç©ºé—´é“¾è¡¨ä½†ä»ç„¶æ— æ³•åˆ†é…å‡ºæ‰€éœ€å¤§å°çš„ç©ºé—´æ—¶ï¼Œè¿”å› NULL è¡¨ç¤ºæ— æ³•åˆ†é…æ˜¯å®Œå…¨åˆæƒ…åˆç†çš„ã€‚å¯¹äºåº”ç”¨å±‚çš„ memory allocator æ¥è¯´ï¼Œå¦‚æœå†…å­˜è€—å°½ï¼Œå®ƒä¼šç”¨ç³»ç»Ÿè°ƒç”¨ (å¦‚ sbrk()) å‘æ“ä½œç³»ç»Ÿç”³è¯·æ›´å¤šçš„å†…å­˜å¹¶å°†å…¶åŠ å…¥åˆ°ç©ºé—²ç©ºé—´é“¾è¡¨ä¸­ã€‚\n17.3 Basic Strategies ç”±äºç”³è¯·å†…å­˜å’Œé‡Šæ”¾å†…å­˜çš„è¡Œä¸ºæ˜¯å®Œå…¨ç”±ä¸Šå±‚ç¨‹åºå†³å®šçš„ï¼Œæ‰€ä»¥ä»»ä½•ç­–ç•¥éƒ½ä¼šåœ¨é’ˆå¯¹æ€§çš„ input ä¸‹æŠŠå†…å­˜æå¾—å¾ˆç ´ç¢ã€‚æˆ‘ä»¬æ— æ³•ç»™å‡ºå®Œç¾çš„è§£å†³æ–¹æ¡ˆï¼Œä½†è‡³å°‘å¯ä»¥æå‡ºä¸€äº›æ¯”è¾ƒæœ‰å¯èƒ½è¾ƒä¼˜çš„è§£å†³æ–¹æ¡ˆã€‚\nBest Fit (Smallest Fit) Best fit ç­–ç•¥æ˜¯ï¼šalloc() éœ€æ±‚æ¥ä¸´æ—¶ï¼Œæ ¹æ®å¤§å°ä»é“¾è¡¨ä¸­æ‰¾å‡ºå¯ä»¥æ»¡è¶³è¦æ±‚ä¸”å¤§å°æœ€å°çš„é“¾è¡¨èŠ‚ç‚¹ split å‡ºä¸€å—ã€‚è¯¥ç­–ç•¥å¯ä»¥æ¯”è¾ƒå¥½åœ°å‡å°‘ç ´ç¢çš„å†…å­˜å—ï¼Œä½†æ¯æ¬¡ alloc() éƒ½å®Œæ•´åœ°éå†é“¾è¡¨ä»£ä»·å¤ªå¤§ã€‚\nWorst Fit Worst Fit æ¯æ¬¡æŒ‘æœ€å¤§çš„å†…å­˜å—åˆ‡å‰²ï¼Œè¿™æ ·å¯ä»¥é¿å…å‡ºç°å¾ˆå¤šç ´ç¢çš„å°å†…å­˜å—ï¼Œä½†å®ƒä¹Ÿè¦éå†æ•´ä¸ªé“¾è¡¨ï¼Œè€Œä¸”å®é™…æƒ…å†µä¸‹æ•ˆæœä¸å¥½ã€‚\nFirst Fit First Fit æ€»æ˜¯å¯»æ‰¾ç¬¬ä¸€ä¸ªè¶³å¤Ÿåˆ‡å‰²çš„å†…å­˜å— alloc()ï¼Œè¿™æ ·ä¸éœ€è¦éå†æ•´ä¸ªé“¾è¡¨ã€‚ä½†åšä¹…äº†ä»¥åé“¾è¡¨çš„å¤´éƒ¨ä¼šå……æ–¥æ¯”è¾ƒå¤šçš„å†…å­˜ç¢ç‰‡ã€‚\nNext Fit Next Fit çš„åšæ³•æ˜¯ä¿å­˜ä¸Šä¸€æ¬¡åˆ†é…çš„ä½ç½®ï¼Œä¸‹ä¸€æ¬¡è¦åˆ†é…æ—¶ä»ä¸Šä¸€æ¬¡çš„ä½ç½®å¼€å§‹ First Fitã€‚å®è·µä¸­è¿™ç§æ–¹æ³•çš„è¡¨ç°å’Œ First Fit å·®ä¸å¤šã€‚\n17.4 Other Approaches Segregated List slab çš„åŸºæœ¬æ€è·¯æ—¶ï¼šå¯¹äºä¸€äº›æ¯”è¾ƒå¸¸è§çš„åˆ†é…å¤§å° (æ¯”å¦‚ 4B, 2B, page size) ç­‰ï¼Œå¯ä»¥å‡†å¤‡ä¸€ä¸ªé“¾è¡¨ä¸“é—¨å­˜å‚¨è¿™ç§å¤§å°çš„å—å—ï¼Œè¿™æ ·åˆ†é…çš„æ—¶å€™ç›´æ¥ä»é“¾è¡¨ä¸­å–ä¸€ä¸ªèŠ‚ç‚¹å³å¯ï¼Œä¸éœ€è¦ä¹‹å‰æ‰€è¯´çš„ç¹ççš„åˆ‡åˆ†ã€åˆå¹¶ç­‰æ­¥éª¤ã€‚slab æœ‰ç‚¹åƒå…¨å±€ memory manager çš„ä¸€ä¸ª cacheï¼Œå¦‚æœæŸä¸ªæ—¶åˆ» slab é‡Œçš„èŠ‚ç‚¹ç”¨å®Œäº†ï¼Œå®ƒä¼šä»å…¨å±€çš„å¤§é“¾è¡¨ä¸­å†æ‰¹å‘ä¸€äº›èŠ‚ç‚¹ã€‚\nBuddy Allocation Buddy Allocation æ¯”è¾ƒåƒâ€œçº¿æ®µæ ‘â€ï¼šå®ƒæŠŠä¸€ä¸ªé•¿åº¦ä¸º $2^N$ çš„åŒºé—´åˆ†æˆå·¦å³å„ $2^{N-1}$ çš„ï¼Œæ¯ä¸ªèŠ‚ç‚¹å†ä¸€åˆ†ä¸ºäºŒï¼Œä¾æ¬¡ç±»æ¨ã€‚è¿™æ ·æˆ‘ä»¬ä¸éœ€è¦ä»”ç»†åœ°ç»´æŠ¤æ‹†åˆ†ã€åˆå¹¶ç›¸å…³çš„é—®é¢˜ã€‚Buddy Allocation çš„å¼±ç‚¹åœ¨äºï¼šä¸ºäº†å¯¹é½æˆ‘ä»¬åªèƒ½åˆ†é… 2 çš„å¹‚æ¬¡å¤§å°çš„å—ï¼Œä¼šé€ æˆä¸€äº› internal fragmentationã€‚\n17.5 Summary ç•¥ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"79db30a695a4fda92e37de43ac02ee50","permalink":"https://kristoff-starling.github.io/notes/booknotes/ostep/ch17/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/booknotes/ostep/ch17/","section":"notes","summary":"åŠ¨æ€å¤§å°çš„å†…å­˜åˆ†é…æ˜¯æ¯”è¾ƒå›°éš¾çš„ï¼šéšç€åå¤çš„åˆ†é…å’Œé‡Šæ”¾ï¼Œç©ºé—²å†…å­˜ä¼šè¢«åˆ‡åˆ†æˆå¾ˆå¤šç¢ç‰‡ï¼Œæ­¤æ—¶å³ä½¿ç©ºé—²ç©ºé—´çš„æ€»é‡å¤§äºæŸä¸ªåˆ†é…éœ€æ±‚ï¼Œåˆ†é…ä¹Ÿå¯èƒ½å› ä¸ºå‰©ä½™ç©ºé—´è¿‡äºç¢ç‰‡åŒ–è€Œå¤±è´¥ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åœ¨ç®¡ç†ç©ºé—²ç©ºé—´æ—¶è¦å…¼é¡¾æ•ˆç‡ã€ç©ºé—²ç©ºé—´è¿ç»­æ€§ã€å†…å­˜æ¶ˆè€—ç­‰å¤šæ–¹é¢å› ç´ ã€‚\n17.1 Assumptions è¿™é‡Œæˆ‘ä»¬å‡è®¾å†…å­˜ç”³è¯·å’Œé‡Šæ”¾çš„æ¥å£å’Œ C åº“ä¸­çš„ malloc()/free() ç›¸åŒï¼š\nvoid *malloc(size_t size); void free(void *ptr); æ³¨æ„ï¼šé‡Šæ”¾ç©ºé—´æ—¶ï¼Œè°ƒç”¨è€…åªä¼ å…¥èµ·å§‹åœ°å€ï¼Œä¸ä¼ å…¥ç©ºé—´çš„ sizeï¼Œå› æ­¤æˆ‘ä»¬åœ¨åˆ†é…æ—¶å°±è¦æƒ³åŠæ³•è®°å½•æ¯å—åˆ†é…å‡ºå»çš„ç©ºé—´çš„å¤§å°ã€‚\nåˆ†é…ç©ºé—´çš„è¿‡ç¨‹ä¸­ä¸¥ç¦å‡ºç° double-alloc çš„æƒ…å†µã€‚\n17.2 Low-level Mechanisms Splitting and Coalescing æˆ‘ä»¬ç”¨ä¸€ä¸ªé“¾è¡¨ç»´æŠ¤æ‰€æœ‰çš„ç©ºé—²å†…å­˜åŒºé—´ï¼Œé“¾è¡¨çš„æ¯ä¸ªèŠ‚ç‚¹ä»£è¡¨ä¸€æ®µè¿ç»­çš„ç©ºé—²å†…å­˜ï¼Œæœ‰èµ·å§‹åœ°å€ï¼Œå—å¤§å°ç­‰å­—æ®µã€‚å½“æˆ‘ä»¬è¦åˆ†é…ä¸€æ®µå†…å­˜å‡ºå»ï¼Œä¸”åˆ†é…å¤§å°å°äºå½“å‰é“¾è¡¨èŠ‚ç‚¹å¤§å°æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å°†é“¾è¡¨èŠ‚ç‚¹çš„å‰åŠéƒ¨åˆ†åˆ‡å‡ºå»ç»™è°ƒç”¨è€…ï¼ŒååŠéƒ¨åˆ†ä¿ç•™åœ¨é“¾è¡¨ä¸­ã€‚è¿™å°±æ˜¯ splittingã€‚\nå½“ free() å°†ä¸€æ®µå†…å­˜ç©ºé—´é‡Šæ”¾æ—¶ï¼Œå¦‚æœæˆ‘ä»¬ä¸åŠ ä»»ä½•æ“ä½œåœ°å°†å…¶æ”¾åˆ°é“¾è¡¨å¤´ï¼Œæ—¶é—´ä¹…äº†å°±ä¼šå‡ºç°å®Œæ•´çš„ç©ºé—²å†…å­˜è¢«æˆ‘ä»¬äººä¸ºåœ°åˆ‡æˆäº†è‹¥å¹²ä¸ªé¦–å°¾ç›¸æ¥çš„æ®µçš„æƒ…å†µã€‚ä¸€ä¸ªå¥½çš„ç»´æŠ¤æ–¹æ³•æ˜¯ï¼šé“¾è¡¨ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹æŒ‰ç…§é¡ºåºæ’åˆ—ï¼Œæ¯å½“æ–°æ’å…¥èŠ‚ç‚¹æ—¶ï¼Œå°†å…¶ä¸å‰åç›¸é‚»çš„èŠ‚ç‚¹æ¯”è¾ƒï¼Œå¦‚æœåœ°å€è¿åœ¨äº†ä¸€èµ·å°±åˆå¹¶èŠ‚ç‚¹ã€‚è¿™å°±æ˜¯ coalescingã€‚","tags":null,"title":"Chapter 17: Free Space Management","type":"docs"},{"authors":null,"categories":null,"content":"ä¸€ä¸ªå¤šçº¿ç¨‹ç¨‹åºä¼šæœ‰å¤šä¸ªæ‰§è¡Œæµï¼Œå³æœ‰å¥½å‡ ä¸ª PC å¹¶å‘/å¹¶è¡Œåœ°å–æŒ‡æ‰§è¡Œï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶ç†è§£ä¸ºå¤šä¸ªè¿›ç¨‹ï¼Œä¸è¿‡å®ƒä»¬å…±äº«åŒä¸€ä¸ªåœ°å€ç©ºé—´ã€‚æ¯ä¸ªçº¿ç¨‹æœ‰è‡ªå·±çš„ PC å’Œä¸€å¥—å¯„å­˜å™¨ï¼Œå› æ­¤ç±»ä¼¼äºè¿›ç¨‹åˆ‡æ¢ï¼Œæˆ‘ä»¬ä¹Ÿéœ€è¦çº¿ç¨‹åˆ‡æ¢ã€‚ä¸è¿‡ç”±äºçº¿ç¨‹å…±äº«åœ°å€ç©ºé—´ï¼Œæ‰€ä»¥çº¿ç¨‹åˆ‡æ¢æ—¶æ— éœ€åˆ‡æ¢é¡µè¡¨ã€‚\nè™½ç„¶çº¿ç¨‹å¯ä»¥å…±äº«åœ°å€ç©ºé—´ï¼Œä½†æ¯ä¸ªçº¿ç¨‹è¦æœ‰è‡ªå·±ç‹¬ç«‹çš„æ ˆã€‚ä¸åŒäºå•çº¿ç¨‹åœ°å€ç©ºé—´ï¼Œå¤šçº¿ç¨‹ç¨‹åºçš„åœ°å€ç©ºé—´ä¸­æœ‰å¤šä¸ªæ ˆï¼Œæ¯ä¸ªçº¿ç¨‹ä¸€ä¸ªï¼Œè¿™ä¸ªçº¿ç¨‹æ ˆä¹Ÿè¢«ç§°ä¸º thread-local storageã€‚\n26.1 Why Use Threads? ä½¿ç”¨çº¿ç¨‹è‡³å°‘æœ‰ä»¥ä¸‹ä¸¤ç‚¹å¥½å¤„ï¼š\næé«˜å¹¶è¡Œåº¦ã€‚åœ¨ä¸€ä¸ªå¤šæ ¸å¤„ç†å™¨ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥è®©å¤šä¸ªçº¿ç¨‹æ¯ä¸ªå æ®ä¸€ä¸ª CPU æ ¸ï¼Œåˆ†æ‘Šä¸€éƒ¨åˆ†å·¥ä½œï¼Œä»è€Œè¾¾åˆ°å¹¶è¡Œæé€Ÿçš„æ•ˆæœã€‚ é¿å… I/O æ“ä½œé˜»å¡ç¨‹åºã€‚å¦‚æœä¸€ä¸ªçº¿ç¨‹åœ¨ç­‰å¾… I/O æ“ä½œï¼ŒCPU å¯ä»¥é€šè¿‡çº¿ç¨‹åˆ‡æ¢è®©åˆ«çš„çº¿ç¨‹ä¸Š CPU å·¥ä½œï¼Œè¿™æ ·å°±å®ç°äº†ç­‰ I/O å’Œåšå…¶ä»–äº‹æƒ…åŒæ—¶è¿›è¡Œã€‚ 26.2 An Example: Thread Creation t0.c ä¸­åˆ›å»ºäº†ä¸¤ä¸ªè¿›ç¨‹å¹¶è®©å®ƒä»¬æ‰“å°ä¸åŒçš„å†…å®¹ã€‚åœ¨å¤šçº¿ç¨‹ç¨‹åºä¸­ï¼Œå„ä¸ªçº¿ç¨‹æ‰§è¡Œçš„é¡ºåºæ˜¯ä¸ç¡®å®šçš„ï¼šå…ˆè¢«åˆ›å»ºçš„è¿›ç¨‹å¯èƒ½ä¼šåæ‰§è¡Œï¼›ä¸€ä¸ªçº¿ç¨‹è¢«åˆ›å»ºäº†ä¹‹åå¯èƒ½åœ¨ wait å®ƒæ—¶æ‰æ‰§è¡Œï¼Œä¹Ÿå¯èƒ½ä¼šç«‹å³æ‰§è¡Œï¼Œç„¶å wait æ—¶ç«‹å³è¿”å› etc.\n26.3 Why It Gets Worse: Shared Data t1.c ä¸­åˆ›å»ºäº†ä¸¤ä¸ªçº¿ç¨‹ï¼Œä¸¤ä¸ªçº¿ç¨‹éƒ½å¯¹å…±äº«å˜é‡è¿›è¡Œ N æ¬¡ +1ï¼Œåœ¨ N è¾ƒå¤§æ—¶å¯ä»¥è§‚æµ‹åˆ°å…±äº«å˜é‡çš„ç»“æœå°äº 2Nã€‚\nThread-local Variables\nåœ¨çº¿ç¨‹è°ƒç”¨çš„å‡½æ•°é‡Œå®šä¹‰çš„å˜é‡éƒ½ä¼šæ˜¯ thread local çš„å˜é‡ã€‚t1.c ä¸­æ‰“å°äº†å±€éƒ¨å˜é‡ i çš„åœ°å€ï¼Œå¯ä»¥çœ‹åˆ°ä¸åŒçš„çº¿ç¨‹æ‰“å°å‡ºçš„åœ°å€ä¸ä¸€æ · (åœ¨å„è‡ªçš„çº¿ç¨‹æ ˆä¸Š)ã€‚\nåœ¨å‡½æ•°ä½“å¤–ï¼Œç”¨ __thread ä¿®é¥°çš„å˜é‡ä¹Ÿæ˜¯ thread local çš„ã€‚\nValgrind\nValgrind ä¸­çš„ memchecker æ˜¯å¼ºå¤§çš„å†…å­˜æ£€æµ‹å·¥å…·ã€‚ç¼–è¯‘å¥½ä¸€ä¸ªæ–‡ä»¶ proc.c åç”¨ valgrind ./proc æ‰§è¡Œï¼Œå¯ä»¥æ£€æµ‹ memory leak, use after free ç­‰é—®é¢˜ã€‚\n26.4 The Heart Of The Problem: Uncontrolled Scheduling counter ++ è¿™æ¡è¯­å¥åœ¨æ±‡ç¼–å±‚é¢æ˜¯ä¸‰æ¡æŒ‡ä»¤ï¼š\nmov (addr), %eax add $0x1, %eax mov %eax, (addr) å…¶ä¸­ addr æ˜¯ counter å˜é‡çš„å†…å­˜åœ°å€ã€‚å¦‚æœä¸¤ä¸ªçº¿ç¨‹è½®æµæ‰§è¡Œæ±‡ç¼–è¯­å¥ï¼Œé‚£ä¹ˆå®ƒä»¬å„æ‰§è¡Œä¸€æ¬¡ +1 åï¼Œäº‹å®ä¸Š counter åªåŠ äº† 1,å¹¶æ²¡æœ‰ +2ã€‚\næˆ‘ä»¬ç§°è¿™ä¸¤ä¸ªçº¿ç¨‹è§¦å‘äº†ç«äº‰æ¡ä»¶ (race condition)ï¼Œå‡†ç¡®è¯´æ˜¯ä¸€æ¬¡æ•°æ®ç«äº‰ã€‚å¯¼è‡´è¿™ä¸€ç«äº‰çš„ä»£ç ç§°ä¸ºä¸´ç•ŒåŒºåŸŸ (critical section)ã€‚æˆ‘ä»¬å¸Œæœ›å®ç°ä¸€ç§äº’æ–¥æœºåˆ¶ï¼Œä½¿å¾—ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œä¸´ç•ŒåŒºåŸŸä»£ç æ—¶ä¸ä¼šè¢«å¦ä¸€ä¸ªçº¿ç¨‹æ‰“æ–­ã€‚\n26.5 The Wish For Atomicity æˆ‘ä»¬å¸Œæœ›æœ‰è¿™æ ·çš„ä¸€æ¡åŸå­æŒ‡ä»¤ï¼š\nmomory-add (addr), 0x1 å¯ä»¥ä¸€ä¸‹å­å¸®æˆ‘ä»¬å®Œæˆ +1 æ“ä½œã€‚è¿™é‡Œçš„åŸå­æ€§æŒ‡çš„æ˜¯ï¼šæ“ä½œåœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­ä¸ä¼šè¢«ä¸­é€”æ‰“æ–­ã€‚è¿™ä¸ªæ“ä½œæ˜¯ä¸€ä¸ªæœ€å°çš„å•å…ƒï¼Œå®ƒè¦ä¹ˆè¢«å®Œå…¨æ‰§è¡Œäº†ï¼Œè¦ä¹ˆæ²¡æœ‰è¢«æ‰§è¡Œ (all or none)ï¼Œä¸ä¼šåœ¨æŸæ—¶åˆ»å¤„äºæ‰§è¡Œäº†ä¸€åŠçš„çŠ¶æ€ã€‚\nå°†è‹¥å¹²ä¸ªæ“ä½œæ‰“åŒ…æˆä¸€ä¸ªåŸå­æŒ‡ä»¤çš„è¿‡ç¨‹æˆ‘ä»¬ç§°ä¸ºä¸€ä¸ªäº¤æ˜“ (transaction)ã€‚ä½†ç¡¬ä»¶ä¸èƒ½å…è®¸æˆ‘ä»¬æ— é™åˆ¶åœ°æ·»åŠ åŸå­æŒ‡ä»¤ã€‚æˆ‘ä»¬è¦å®ç°çš„æ˜¯ä¸€ç§åŒæ­¥æœºåˆ¶ï¼Œå®ƒå¯ä»¥ä¿è¯å¤šä¸ªçº¿ç¨‹ä»¥ä¸€ç§å¯æ§çš„æ–¹å¼è¿›å…¥ä¸´ç•ŒåŒºåŸŸï¼Œä»è€Œä½¿å¾—æ‰§è¡Œæ­£ç¡®ã€‚\n26.6 One More Problem: Waiting For Another åœ¨æŸäº›æƒ…å¢ƒä¸‹ï¼Œä¸€ä¸ªçº¿ç¨‹éœ€è¦ç­‰å¾…æŸä»¶äº‹æƒ…åšå¥½äº†æ‰èƒ½ç»§ç»­è¿›è¡Œï¼Œæ¯”å¦‚ç­‰å¾… I/O æ“ä½œå®Œæˆã€‚æ“ä½œç³»ç»Ÿä¸ä»…è¦æ”¯æŒçº¿ç¨‹ä¹‹é—´çš„åŒæ­¥ï¼Œè¿˜è¦æ”¯æŒåœ¨æŸäº›æ¡ä»¶ä¸‹æŒ‚èµ·/å”¤é†’çº¿ç¨‹ï¼Œè¿™ä¼šé€šè¿‡æ¡ä»¶å˜é‡ (condition variables) æ¥å®ç°ã€‚\n26.7 Summary: Why in OS Class? æ“ä½œç³»ç»Ÿæœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªå¹¶å‘ç¨‹åºã€‚å¦‚æœæœ‰å¤šä¸ªç¨‹åºä½¿ç”¨ write() ç³»ç»Ÿè°ƒç”¨ï¼Œé‚£ä¹ˆæ“ä½œç³»ç»Ÿå°±å¿…é¡»éå¸¸å°å¿ƒåœ°å¤„ç†å†…æ ¸ä¸­å’Œ write() æœ‰å…³çš„å¹¶å‘æ•°æ®ç»“æ„ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"efc1e3ba2d9457f87831e3f1758ae303","permalink":"https://kristoff-starling.github.io/notes/booknotes/ostep/ch26/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/booknotes/ostep/ch26/","section":"notes","summary":"ä¸€ä¸ªå¤šçº¿ç¨‹ç¨‹åºä¼šæœ‰å¤šä¸ªæ‰§è¡Œæµï¼Œå³æœ‰å¥½å‡ ä¸ª PC å¹¶å‘/å¹¶è¡Œåœ°å–æŒ‡æ‰§è¡Œï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶ç†è§£ä¸ºå¤šä¸ªè¿›ç¨‹ï¼Œä¸è¿‡å®ƒä»¬å…±äº«åŒä¸€ä¸ªåœ°å€ç©ºé—´ã€‚æ¯ä¸ªçº¿ç¨‹æœ‰è‡ªå·±çš„ PC å’Œä¸€å¥—å¯„å­˜å™¨ï¼Œå› æ­¤ç±»ä¼¼äºè¿›ç¨‹åˆ‡æ¢ï¼Œæˆ‘ä»¬ä¹Ÿéœ€è¦çº¿ç¨‹åˆ‡æ¢ã€‚ä¸è¿‡ç”±äºçº¿ç¨‹å…±äº«åœ°å€ç©ºé—´ï¼Œæ‰€ä»¥çº¿ç¨‹åˆ‡æ¢æ—¶æ— éœ€åˆ‡æ¢é¡µè¡¨ã€‚\nè™½ç„¶çº¿ç¨‹å¯ä»¥å…±äº«åœ°å€ç©ºé—´ï¼Œä½†æ¯ä¸ªçº¿ç¨‹è¦æœ‰è‡ªå·±ç‹¬ç«‹çš„æ ˆã€‚ä¸åŒäºå•çº¿ç¨‹åœ°å€ç©ºé—´ï¼Œå¤šçº¿ç¨‹ç¨‹åºçš„åœ°å€ç©ºé—´ä¸­æœ‰å¤šä¸ªæ ˆï¼Œæ¯ä¸ªçº¿ç¨‹ä¸€ä¸ªï¼Œè¿™ä¸ªçº¿ç¨‹æ ˆä¹Ÿè¢«ç§°ä¸º thread-local storageã€‚\n26.1 Why Use Threads? ä½¿ç”¨çº¿ç¨‹è‡³å°‘æœ‰ä»¥ä¸‹ä¸¤ç‚¹å¥½å¤„ï¼š\næé«˜å¹¶è¡Œåº¦ã€‚åœ¨ä¸€ä¸ªå¤šæ ¸å¤„ç†å™¨ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥è®©å¤šä¸ªçº¿ç¨‹æ¯ä¸ªå æ®ä¸€ä¸ª CPU æ ¸ï¼Œåˆ†æ‘Šä¸€éƒ¨åˆ†å·¥ä½œï¼Œä»è€Œè¾¾åˆ°å¹¶è¡Œæé€Ÿçš„æ•ˆæœã€‚ é¿å… I/O æ“ä½œé˜»å¡ç¨‹åºã€‚å¦‚æœä¸€ä¸ªçº¿ç¨‹åœ¨ç­‰å¾… I/O æ“ä½œï¼ŒCPU å¯ä»¥é€šè¿‡çº¿ç¨‹åˆ‡æ¢è®©åˆ«çš„çº¿ç¨‹ä¸Š CPU å·¥ä½œï¼Œè¿™æ ·å°±å®ç°äº†ç­‰ I/O å’Œåšå…¶ä»–äº‹æƒ…åŒæ—¶è¿›è¡Œã€‚ 26.2 An Example: Thread Creation t0.","tags":null,"title":"Chapter 26: Concurrency: An Introduction","type":"docs"},{"authors":null,"categories":null,"content":"27.1 Thread Creation åˆ›å»ºçº¿ç¨‹çš„ API ä¸º\nint pthread_create( pthread_t *thread, const pthread_attr_t *attr, void * (*start_routine)(void*), void * arg); thread æ˜¯æŒ‡å‘ pthread_t ç±»å‹å˜é‡çš„æŒ‡é’ˆï¼Œæˆ‘ä»¬å°†æ¥è¦é€šè¿‡è¿™ä¸ªç»“æ„ä½“æ¥æ§åˆ¶è¿™ä¸ªçº¿ç¨‹ï¼Œæ‰€ä»¥ç°åœ¨éœ€è¦å¯¹å…¶è¿›è¡Œåˆå§‹åŒ–ã€‚ attr è¡¨æ˜äº†å¸Œæœ›è¯¥çº¿ç¨‹æ‹¥æœ‰çš„å±æ€§ï¼Œå¤§å¤šæ•°æƒ…å†µä¸‹å¯ä»¥ä¼  NULLï¼Œè¡¨ç¤ºæŒ‰ç…§é»˜è®¤å±æ€§åˆ›å»ºã€‚ start_routine æ˜¯ä¸€ä¸ªæŒ‡å‘å‡½æ•°çš„æŒ‡é’ˆï¼Œæ–°åˆ›å»ºçš„çº¿ç¨‹ä¼šä»è¿™ä¸ªå‡½æ•°å¼€å§‹æ‰§è¡Œã€‚ arg æ˜¯ä¼ ç»™ start_routine() çš„å‚æ•°ã€‚ è¿™é‡Œå‚æ•°çš„ç±»å‹å’Œè¿”å›å€¼ç±»å‹éƒ½æ˜¯ void * ç±»å‹çš„æŒ‡é’ˆ (ç›¸å½“äºåªè¦æ±‚åœ°å€ï¼Œä¸è¦æ±‚å¯¹åœ°å€ç±»å‹çš„è§£è¯»)ï¼Œè¿™æ˜¯ä¸ºäº†ä½¿å¾—å‡½æ•°æ”¯æŒä»»æ„ç±»å‹çš„å‚æ•°å’Œè¿”å›å€¼ã€‚\n27.2 Thread Completion ç­‰å¾…çº¿ç¨‹å®Œæˆçš„ API ä¸º\nint pthread_join(pthread_t thread, void **value_ptr); thread è¡¨ç¤ºè¦ç­‰å¾…è¿è¡Œå®Œæˆçš„çº¿ç¨‹ç»“æ„ä½“ã€‚ value_ptr æ˜¯ä¸€ä¸ªæŒ‡å‘ void * ç±»å‹æŒ‡é’ˆçš„æŒ‡é’ˆï¼Œpthread_join() è¿”å›æ—¶ï¼Œ value_ptr ä¼šæŒ‡å‘çº¿ç¨‹åˆ›å»ºæ—¶çš„ start_routine() å‡½æ•°çš„è¿”å›å€¼ã€‚å¦‚æœæˆ‘ä»¬ä¸åœ¨ä¹è¿™ä¸ªè¿”å›å€¼ï¼Œå¯ä»¥ç›´æ¥ä¼ å…¥ NULLã€‚ å¾ˆå¤šæ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦çš„çº¿ç¨‹å‡½æ•°è¿”å›å€¼åªæ˜¯ä¸€ä¸ªæ•° (å¦‚ 0 è¡¨ç¤ºæˆåŠŸï¼Œ1 è¡¨ç¤ºå¤±è´¥)ï¼Œè¿™æ—¶æˆ‘ä»¬æœ‰æ¯”è¾ƒç®€å•çš„å†™æ³•ï¼š\nvoid *mythread(void *arg) { return (void *)(arg + 1); } int main () { int r; pthread_t p; pthread_create(\u0026amp;p, NULL, mythread, (void *)100); pthread_join(p, (void **)\u0026amp;r); } åœ¨çº¿ç¨‹å‡½æ•°ä¸­å°†è¿”å›å€¼è½¬æ¢æˆ void * ç±»å‹ï¼Œåœ¨ä¸»å‡½æ•°ä¸­æˆ‘ä»¬åªè¦å°†æ•´å‹å˜é‡ r çš„åœ°å€è½¬æ¢æˆ void ** ç±»å‹ï¼Œå°±å¯ä»¥ç›´æ¥æŠŠè¿”å›å€¼å­˜åˆ° r é‡Œé¢ã€‚\nä½¿ç”¨çº¿ç¨‹è¿”å›æ—¶è¦æ ¼å¤–æ³¨æ„ï¼šè¿”å›å€¼çš„å®ä½“ä¸èƒ½åœ¨çº¿ç¨‹æ ˆä¸Šï¼Œå› ä¸ºçº¿ç¨‹è¿”å›æ—¶çº¿ç¨‹æ ˆä¼šè¢«é‡Šæ”¾ã€‚æ¯”å¦‚\nvoid *mythread(void *arg) { myret_t r; r = {10, 20}; return (void *)\u0026amp;r; } è¿™ä¸ªå†™æ³•æ˜¯ä¸åˆç†çš„ï¼Œè¿”å›æ—¶ r å·²ç»è¢«é‡Šæ”¾ï¼Œè¿”å›ç»“æœæ˜¯ UBã€‚å°†ç»“æ„ä½“å®šä¹‰åœ¨å †åŒºå¯ä»¥é¿å…è¿™ä¸ªé—®é¢˜ï¼š\nvoid *mythread(void *arg) { myret_t *r = malloc(sizeof(myret_t)); *r = {10, 20}; return (void *)r; } 27.3 Locks ç”¨äºè·å¾—äº’æ–¥é”å’Œé‡Šæ”¾äº’æ–¥é”çš„ API ä¸ºï¼š\nint pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_unlock(pthread_mutex_t *mutex); ç¬¬ä¸€ä¸ªå‡½æ•°ä¼šå°è¯•è·å¾—é”ï¼Œç›´åˆ°è·å¾—äº†ä¹‹åè¿”å› (äº’æ–¥é”ä¸ä¼šè½®è¯¢é”çš„çŠ¶æ€ï¼Œåœ¨å¾—ä¸åˆ°æ—¶ä¼šè¿›å…¥ç¡çœ çŠ¶æ€)ã€‚ç¬¬äºŒä¸ªç¬¬äºŒä¸ªå‡½æ•°ç”¨äºé‡Šæ”¾é”ã€‚\næ³¨ï¼šè¿™ä¸¤ä¸ªå‡½æ•°æ˜¯æœ‰è¿”å›å€¼çš„ã€‚æ­£å¸¸æƒ…å†µä¸‹å®ƒä»¬åº”è¯¥è¿”å› 0ã€‚ä¸€ä¸ªå¥½çš„ç¼–ç¨‹ä¹ æƒ¯æ˜¯åœ¨è°ƒç”¨è¿™äº› API æ—¶éšæ‰‹æ£€æŸ¥è¿”å›å€¼ï¼Œæ¯”å¦‚å°è£…æˆè¿™æ ·ï¼š\nvoid Pthread_mutex_lock(pthread_mutex_t *mutex) { int rc = pthread_mutex_lock(mutex); assert(rc == 0); } äº’æ–¥é”åœ¨ä½¿ç”¨ä¹‹å‰éœ€è¦å…ˆåˆå§‹åŒ–ã€‚åˆå§‹åŒ–æœ‰ä¸¤ç§æ–¹å¼ï¼š\nåœ¨å®šä¹‰äº’æ–¥é”å˜é‡æ—¶ç›´æ¥ä½¿ç”¨ INITIALIZERï¼Œå®ƒä¼šæŒ‰ç…§é»˜è®¤å±æ€§åˆå§‹åŒ–é”ï¼š\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; åœ¨è¿è¡Œè¿‡ç¨‹ä¸­åˆå§‹åŒ–ï¼š\nvoid Pthread_mutex_init(pthread_mutex_t *mutex) { int rc = pthread_mutex_init(mutex, NULL); assert(rc == 0); } int main () { pthread_mutex_t lock; Pthread_mutex_init(\u0026amp;lock); } pthread_mutex_init() çš„ç¬¬äºŒä¸ªå‚æ•°ç”¨äºæŒ‡å®šåˆå§‹åŒ–é”çš„å±æ€§ï¼Œé€šå¸¸æƒ…å†µä¸‹ä½¿ç”¨ NULL å³å¯ã€‚\né”ç”¨å®Œä¹‹åï¼Œåº”å½“ä½¿ç”¨å’Œåˆå§‹åŒ–å‡½æ•°ç›¸å¯¹åº”çš„ pthread_mutex_destroy() å‡½æ•°æ¥é”€æ¯ä¸€ä¸ªé”ã€‚\nå¦æœ‰ä¸¤ä¸ª APIï¼š\nint pthread_mutex_trylock(pthread_mutex_t *mutex); int pthread_mutex_timedlock(pthread_mutex_t *mutex, struct timespec *abs_timeout); trylock() ä¼šå°è¯•è·å¾—é”ï¼Œå¦‚æœé”æ­£åœ¨è¢«å ç”¨åˆ™ç›´æ¥è¿”å›ã€‚timedlock() ä¼šåœ¨ä¸€ä¸ªæŒ‡å®šçš„æ—¶é—´èŒƒå›´å†…å°è¯•è·å¾—é”ï¼Œå¦‚æœè¿™ä¸ªæ—¶é—´æ®µå†…æœªèƒ½è·å¾—é”å°±è¿”å›ã€‚trylock() å¯ä»¥ç†è§£ä¸º timedlock() çš„ 0 ç§’ç‰ˆæœ¬ï¼›ä¹‹å‰çš„ lock() å¯ä»¥ç†è§£ä¸º timedlock() çš„æ— é™é•¿æ—¶é—´ç‰ˆæœ¬ã€‚\nè¿™ä¸¤ä¸ª API ä¸å¸¸ç”¨ï¼Œä½†åœ¨ä¸€äº›æƒ…å¢ƒä¸‹å¯ä»¥ç”¨äºé¿å…æ­»é”ã€‚\n27.4 Condition Variables æ¡ä»¶å˜é‡çš„ä¸¤ä¸ªä¸»è¦ API ä¸º\nint pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex); int pthread_cond_signal(pthread_cond_t *cond); è°ƒç”¨ cond_wait() æ—¶ï¼Œå½“å‰çº¿ç¨‹å¿…é¡»å·²ç»æ‹¥æœ‰äº’æ–¥é” mutexã€‚cond_wait() ä¼šé‡Šæ”¾ mutex å¹¶å°†å½“å‰çº¿ç¨‹ç¡çœ åœ¨æ¡ä»¶å˜é‡ cond ä¸Šã€‚å½“å¦å¤–çš„æŸä¸ªçº¿ç¨‹è°ƒç”¨ cond_signal() å”¤é†’äº†è¯¥çº¿ç¨‹æ—¶ï¼Œè¯¥çº¿ç¨‹ä¼šé‡æ–°å°è¯•è·å¾—äº’æ–¥é” mutexï¼Œè·å¾—äº†ä¹‹åä» cond_wait() å‡½æ•°è¿”å›ã€‚\nä½¿ç”¨æ¡ä»¶å˜é‡ä¹‹å‰è¦å…ˆå¯¹æ¡ä»¶å˜é‡åˆå§‹åŒ–ï¼Œå…¶æ–¹æ³•å’Œäº’æ–¥é”æ˜¯ç±»ä¼¼çš„ï¼š\npthread_cond_t cond = PTREAD_COND_INITALIZER; 27.5 Compiling and Running è¦ä½¿ç”¨ä¸Šè¿°çš„ POSIX çº¿ç¨‹åº“ä¸­çš„å‡½æ•°ï¼Œæˆ‘ä»¬éœ€è¦åœ¨æºä»£ç ä¸­ #include \u0026lt;pthread.h\u0026gt; ï¼Œå¹¶åœ¨ç¼–è¯‘æ—¶åŠ å…¥ -lpthread é€‰é¡¹ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"421d05f9f7252296267a9debab2db0c6","permalink":"https://kristoff-starling.github.io/notes/booknotes/ostep/ch27/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/booknotes/ostep/ch27/","section":"notes","summary":"27.1 Thread Creation åˆ›å»ºçº¿ç¨‹çš„ API ä¸º\nint pthread_create( pthread_t *thread, const pthread_attr_t *attr, void * (*start_routine)(void*), void * arg); thread æ˜¯æŒ‡å‘ pthread_t ç±»å‹å˜é‡çš„æŒ‡é’ˆï¼Œæˆ‘ä»¬å°†æ¥è¦é€šè¿‡è¿™ä¸ªç»“æ„ä½“æ¥æ§åˆ¶è¿™ä¸ªçº¿ç¨‹ï¼Œæ‰€ä»¥ç°åœ¨éœ€è¦å¯¹å…¶è¿›è¡Œåˆå§‹åŒ–ã€‚ attr è¡¨æ˜äº†å¸Œæœ›è¯¥çº¿ç¨‹æ‹¥æœ‰çš„å±æ€§ï¼Œå¤§å¤šæ•°æƒ…å†µä¸‹å¯ä»¥ä¼  NULLï¼Œè¡¨ç¤ºæŒ‰ç…§é»˜è®¤å±æ€§åˆ›å»ºã€‚ start_routine æ˜¯ä¸€ä¸ªæŒ‡å‘å‡½æ•°çš„æŒ‡é’ˆï¼Œæ–°åˆ›å»ºçš„çº¿ç¨‹ä¼šä»è¿™ä¸ªå‡½æ•°å¼€å§‹æ‰§è¡Œã€‚ arg æ˜¯ä¼ ç»™ start_routine() çš„å‚æ•°ã€‚ è¿™é‡Œå‚æ•°çš„ç±»å‹å’Œè¿”å›å€¼ç±»å‹éƒ½æ˜¯ void * ç±»å‹çš„æŒ‡é’ˆ (ç›¸å½“äºåªè¦æ±‚åœ°å€ï¼Œä¸è¦æ±‚å¯¹åœ°å€ç±»å‹çš„è§£è¯»)ï¼Œè¿™æ˜¯ä¸ºäº†ä½¿å¾—å‡½æ•°æ”¯æŒä»»æ„ç±»å‹çš„å‚æ•°å’Œè¿”å›å€¼ã€‚","tags":null,"title":"Chapter 27: Interlude: Thread API","type":"docs"},{"authors":null,"categories":null,"content":"29.1 Concurrent Counters ä¸€ä¸ªæœ€ç®€å•çš„ thread-safe çš„è®¡æ•°å™¨å®ç°å¦‚ä¸‹ (ç”¨é”ä¿æŠ¤æ¯æ¬¡è¯»å†™)ï¼š\ntypedef struct __counter_t { int value; pthread_mutex_t lock; } counter_t; void init(counter_t *c) { c-\u0026gt;value = 0; Pthread_mutex_init(\u0026amp;c-\u0026gt;lock, NULL); } void increment(counter_t *c) { Pthread_mutex_lock(\u0026amp;c-\u0026gt;lock); c-\u0026gt;value++; Pthread_mutex_unlock(\u0026amp;c-\u0026gt;lock); } void decrement(counter_t *c) { Pthread_mutex_lock(\u0026amp;c-\u0026gt;lock); c-\u0026gt;value--; Pthread_mutex_unlock(\u0026amp;c-\u0026gt;lock); } int get(counter_t *c) { Pthread_mutex_lock(\u0026amp;c-\u0026gt;lock); int rc = c-\u0026gt;value; Pthread_mutex_unlock(\u0026amp;c-\u0026gt;lock); return rc; } ä½†è¿™ç§å®ç°çš„ scalability å¾ˆå·®ï¼šå¦‚æœç»™ $n$ ä¸ªæ ¸åˆ†é…ç­‰é‡çš„ä»»åŠ¡ï¼Œæœ€ç»ˆæ‰€æ¶ˆè€—çš„æ—¶é—´å‡ ä¹æ˜¯å•ä¸ªä»»åŠ¡æ—¶é•¿çš„ $n$ å€ã€‚å¤§éƒ¨åˆ†æ—¶é—´ CPU æ ¸ä¹‹é—´åœ¨äº’ç›¸ç­‰é”ï¼Œæˆ‘ä»¬æ²¡æœ‰åˆ©ç”¨å¤šå¤„ç†å™¨è¾¾åˆ°å¹¶è¡Œçš„æ•ˆç‡ã€‚\nå¦‚æœæ„¿æ„ç‰ºç‰²ä¸€éƒ¨åˆ†ç²¾ç¡®æ€§ï¼Œæˆ‘ä»¬å¯ä»¥è®¾è®¡ä¸€ç§ approximate counter æ¥æå‡æ•ˆç‡ã€‚approximate counter ä¸­ï¼Œæ¯ä¸ª CPU æ ¸æœ‰ä¸€ä¸ªå•ç‹¬çš„ counterï¼Œæ­¤å¤–è¿˜æœ‰ä¸€ä¸ªå…¨å±€çš„ counterã€‚å…¨å±€å’Œæœ¬åœ°çš„ counter éƒ½æœ‰é”ä¿æŠ¤ã€‚ä¿®æ”¹æ“ä½œä¸­ (å‡è®¾åªæœ‰ increment)ï¼ŒCPU æ ¸ç›´æ¥ä¿®æ”¹æœ¬åœ°çš„ counterï¼Œå› æ­¤å„ä¸ªæ ¸å¯ä»¥å¹¶è¡Œã€‚å½“æœ¬åœ° counter çš„å€¼è¾¾åˆ°ä¸€ä¸ªé˜ˆå€¼æ—¶ï¼Œæœ¬åœ° counter ä¼šå’Œå…¨å±€ counter åšä¸€æ¬¡åŒæ­¥ï¼Œå°†æœ¬åœ°å€¼åŠ åˆ°å…¨å±€å€¼ä¸Šå¹¶å°†æœ¬åœ°å€¼æ¸…é›¶ã€‚æŸ¥è¯¢æ“ä½œä¸­ç›´æ¥è¿”å›å…¨å±€ counter çš„å€¼å³å¯ã€‚\ntypedef struct __counter_t { int global; pthread_mutex_t glock; int local[NUMCPUS]; pthread_mutex_t llock[NUMCPUS]; int threshold; }counter_t; void init(counter_t *c, int threshold) { c-\u0026gt;threshold = threshold; c-\u0026gt;global = 0; Pthread_mutex_init(\u0026amp;c-\u0026gt;glock, NULL); for (int i = 0; i \u0026lt; NUMCPUS; ++i) { c-\u0026gt;local[i] = 0; Pthread_mutex_init(\u0026amp;c-\u0026gt;llock[i], NULL); } } void update(counter_t *c, int threadID, int amt) { int cpu = threadID % NUMCPUS; Pthread_mutex_lock(\u0026amp;c-\u0026gt;llock[cpu]); c-\u0026gt;local[cpu] += amt; if (c-\u0026gt;local[cpu] \u0026gt;= c-\u0026gt;threshold) { Pthread_mutex_lock(\u0026amp;c-\u0026gt;glock); c-\u0026gt;glocal += c-\u0026gt;local[cpu]; Pthread_mutex_unlock(\u0026amp;c-\u0026gt;glock); c-\u0026gt;local[cpu] = 0; } Pthread_mutex_unlock(\u0026amp;c-\u0026gt;llock[cpu]); } int get(counter_t *c) { Pthread_mutex_lock(\u0026amp;c-\u0026gt;glock); int rt = c-\u0026gt;global; Pthread_mutex_unlock(\u0026amp;c-\u0026gt;glock); return rt; } åœ¨è¯¥å®ç°ç‰ˆæœ¬ä¸­ï¼Œæ¯ä¸ªçº¿ç¨‹å¹¶ä¸ä¼šå»ç¡®è®¤è‡ªå·±æ‰€å¤„çš„æ ¸ï¼Œè€Œæ˜¯ç›´æ¥éšæœº (è¿›ç¨‹å·å–æ¨¡) åˆ†é…ä¸€ä¸ªæ ¸å¯¹åº”çš„æœ¬åœ°è®¡æ•°å™¨ã€‚è¿™æ ·åšå’Œä¹‹å‰æè¿°çš„ç®—æ³•æ— å¼‚ã€‚\nä¸Šè¿°ç®—æ³•ä¸­ï¼Œå¦‚æœé˜ˆå€¼æ˜¯ 0 åˆ™ä¸ç²¾ç¡®çš„è®¡æ•°å™¨æ— å¼‚ã€‚éšç€é˜ˆå€¼çš„æé«˜ï¼Œè®¡æ•°å™¨çš„å¹¶è¡Œæ•ˆç‡ä¼šè¶Šæ¥è¶Šé«˜ (å¤§è‡´å‘ˆåæ¯”ä¾‹å‡½æ•°)ï¼Œä½†è¿”å›çš„ç»“æœä¼šè¶Šæ¥è¶Šä¸ç²¾ç¡®ã€‚\n29.2 Concurrent Linked List ä¸€ä¸ªæœ´ç´ çš„åšæ³•æ˜¯ç”¨ä¸€æŠŠå¤§é”ä¿æŠ¤æ•´ä¸ªé“¾è¡¨çš„ä¿®æ”¹å’ŒæŸ¥è¯¢ã€‚ä¸€ç§å¾ˆå®¹æ˜“å‡ºé”™çš„æƒ…å½¢æ˜¯ï¼šå¦‚æœå‡½æ•°ä¸­é—´æœ‰å¤šå¤„ returnï¼Œåˆ™æ¯å¤„ return å‰éƒ½è¦è®°å¾—é‡Šæ”¾é”ã€‚ä¸ºäº†é¿å…è¿™ç§ bugï¼Œä¹¦å†™ä»£ç æ—¶å¯ä»¥è€ƒè™‘å¤šç”¨ break æ›¿ä»£ return å‡å°‘ return åˆ†æ”¯æ•°ï¼Œæˆ–è€…å¦å†™ä¸€ä¸ª wrapper è°ƒç”¨çœŸæ­£çš„å‡½æ•°ï¼Œåœ¨ wrapper ä¸­ç»´æŠ¤é”ã€‚\nä¸€ç§å¢åŠ é“¾è¡¨è®¿é—®å¹¶è¡Œåº¦çš„æ–¹æ¡ˆæ˜¯æ‰€è°“çš„ hand-over-hand locking (lock coupling)ã€‚åœ¨æŸ¥è¯¢é“¾è¡¨ä¸­æ˜¯å¦æœ‰æŸä¸ªå…ƒç´ æ—¶ï¼Œæˆ‘ä»¬å¹³å¸¸çš„åšæ³•æ˜¯ç”¨ä¸€ä¸ªå¤§é”ä¿æŠ¤æ•´ä¸ªé“¾è¡¨ï¼Œç„¶åä¾æ¬¡æ‰«æé“¾è¡¨èŠ‚ç‚¹ã€‚hand-over-hand locking çš„æ€æƒ³æ˜¯ä¸ºæ¯ä¸ªé“¾è¡¨èŠ‚ç‚¹åˆ›å»ºä¸€æŠŠé”ï¼Œæ¯æ¬¡å‡†å¤‡è®¿é—®ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ—¶ï¼Œå…ˆè·å¾—ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„é”ï¼Œå†é‡Šæ”¾æœ¬èŠ‚ç‚¹çš„é”ã€‚è¿™æ ·å¤šä¸ªçº¿ç¨‹å°±å¯ä»¥å¹¶è¡Œåœ°æŸ¥è¯¢é“¾è¡¨ã€‚\nè¿™ä¸ªæ–¹æ¡ˆåœ¨ç†è®ºä¸Šå¯è¡Œï¼Œä½†å®é™…æ“ä½œä¸­ï¼Œé¢‘ç¹åœ°è·å¾—å’Œé‡Šæ”¾é”ä¼šå¸¦æ¥æ˜‚è´µçš„ä»£ä»·ã€‚ä¸€ä¸ªæ›´å¯è¡Œçš„æ–¹æ¡ˆæ˜¯æ¯ $n$ ä¸ªèŠ‚ç‚¹ç”¨ä¸€æŠŠé”ä¿æŠ¤ï¼Œå‡†å¤‡è¿›å…¥ä¸‹ä¸€ä¸ªâ€œåŒºåŸŸâ€æ—¶åšä¸€æ¬¡ overhead acquiring and releasingã€‚\n29.3 Concurrent Queues æˆ‘ä»¬å¯ä»¥åœ¨é˜Ÿå¤´å’Œé˜Ÿå°¾åˆ†åˆ«ç»´æŠ¤ä¸€æŠŠé”ï¼Œè¿™æ ·ä»é˜Ÿå¤´å–å…ƒç´ å’Œå‘é˜Ÿå°¾æ·»åŠ å…ƒç´ çš„æ“ä½œå¯ä»¥å¹¶è¡Œåœ°æ‰§è¡Œï¼š\ntypedef struct __node_t { int val; struct __node_t *next; }node_t; typedef struct __queue_t { node_t *head; node_t *tail; pthread_mutex_t headlock; pthread_mutex_t taillock; }queue_t; void queue_init(queue_t *q) { node *tmp = malloc(sizeof(node_t)); tmp-\u0026gt;next = NULL; q-\u0026gt;head = q-\u0026gt;tail = tmp; pthread_mutex_init(\u0026amp;q-\u0026gt;headlock, NULL); pthread_mutex_init(\u0026amp;q-\u0026gt;taillock, NULL); } int queue_enqueue(queue_t *q, int val) { node *tmp = malloc(sizeof(node_t)); if (tmp == NULL) return -1; tmp-\u0026gt;val = val; tmp-\u0026gt;next = NULL; pthread_mutex_lock(\u0026amp;q-\u0026gt;taillock); q-\u0026gt;tail-\u0026gt;next = tmp; q-\u0026gt;tail = tmp; pthread_mutex_unlock(\u0026amp;q-\u0026gt;taillock); } int queue_dequeue(queue_t *q, int *val) { pthread_mutex_lock(\u0026amp;q-\u0026gt;headlock); node *tmp = q-\u0026gt;head; node *newhead = tmp-\u0026gt;next; if (newhead == NULL) { pthread_mutex_unlock(\u0026amp;q-\u0026gt;headlock); return -1; // queue was empty } *val = tmp-\u0026gt;val; q-\u0026gt;head = newhead; pthread_mutex_unlock(\u0026amp;q-\u0026gt;headlock); free(tmp); return 0; } è¿™é‡Œçš„ä¸€ä¸ªé‡è¦çš„æŠ€å·§æ˜¯ï¼šæˆ‘ä»¬åœ¨åˆå§‹åŒ–é˜Ÿåˆ—æ—¶åˆ›å»ºäº†ä¸€ä¸ª dummy nodeï¼Œå¹¶è®© q-\u0026gt;head å’Œ q-\u0026gt;tail éƒ½æŒ‡å‘å®ƒã€‚è¿™ä¸ª dummy node æ˜¯æ°¸è¿œä¸ä¼šå‡ºé˜Ÿçš„ã€‚è¿™æ ·æˆ‘ä»¬é¿å…äº†é˜Ÿåˆ—åœ¨å½¢çŠ¶ä¸Šå®Œå…¨ä¸ºç©ºçš„æƒ…å†µï¼Œä»è€Œä¿è¯ headlock å’Œ taillock åšçš„å·¥ä½œæ°¸è¿œæ˜¯æ²¡æœ‰äº¤å‰çš„ã€‚\n29.4 Concurrent Hash Table ä¸€ä¸ªæ”¯æŒå¹¶å‘è®¿é—®çš„ Hash table å®ç°å¾ˆç®€å•ï¼šä½¿ç”¨å¤šä¸ªä¹‹å‰æåˆ°çš„é“¾è¡¨å³å¯ï¼š\n#define BUCKETS (101) typedef struct __hash_t { list_t lists[BUCKETS]; }hash_t; void Hash_Init(hash_t *H) { for (int i = 0; i \u0026lt; BUCKETS; i++) List_Init(\u0026amp;H-\u0026gt;lists[i]); } int Hash_Insert(hash_t *H, int key) { int bucket = key % BUCKETS; return List_Insert(\u0026amp;H-\u0026gt;lists[bucket], key); } int Hash_Lookup(hash_t *H, int key) { int bucket = key % BUCKETS; return List_Lookup(\u0026amp;H-\u0026gt;lists[bucket], key); } è¿™ä¸ªå®ç°åœ¨å®é™…ä¸­æ•ˆç‡ä¸ä½çš„åŸå› æ˜¯ï¼šæˆ‘ä»¬å¹¶æ²¡æœ‰ç”¨ä¸€æŠŠå¤§é”ä¿æŠ¤æ•´ä¸ªå“ˆå¸Œè¡¨ï¼Œè€Œæ˜¯å¯¹æ¯ä¸ªé“¾è¡¨å•ç‹¬ç”¨ä¸€æŠŠæ‰€ä¿æŠ¤ã€‚å¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®å“ˆå¸Œè¡¨çš„ä¸€ä¸ª bucket çš„å‡ ç‡è¾ƒä½ï¼Œè¿™ä½¿å¾— lock contention å‘ç”Ÿæ¬¡æ•°è¾ƒå°‘ã€‚\nTip: Avoid Premature Optimization\n\u0026ldquo;Premature Optimization is the root of all evil.\u0026rdquo; - Knuth\nå¾ˆå¤šæ“ä½œç³»ç»Ÿå†…æ ¸å¼€å‘æ—¶ï¼Œéƒ½æ˜¯å…ˆä½¿ç”¨ä¸€ä¸ªå¤§å†…æ ¸é” (big kernel lock, BKL)ï¼Œå…ˆä¿è¯æ­£ç¡®æ€§ï¼Œå†è€ƒè™‘å¦‚ä½•æŠŠé”æ‹†å¼€æå‡æ•ˆç‡ã€‚\n29.5 Summary ç•¥ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"88bb0c5429d7fcb79eb2688cc6947794","permalink":"https://kristoff-starling.github.io/notes/booknotes/ostep/ch29/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/booknotes/ostep/ch29/","section":"notes","summary":"29.1 Concurrent Counters ä¸€ä¸ªæœ€ç®€å•çš„ thread-safe çš„è®¡æ•°å™¨å®ç°å¦‚ä¸‹ (ç”¨é”ä¿æŠ¤æ¯æ¬¡è¯»å†™)ï¼š\ntypedef struct __counter_t { int value; pthread_mutex_t lock; } counter_t; void init(counter_t *c) { c-\u0026gt;value = 0; Pthread_mutex_init(\u0026amp;c-\u0026gt;lock, NULL); } void increment(counter_t *c) { Pthread_mutex_lock(\u0026amp;c-\u0026gt;lock); c-\u0026gt;value++; Pthread_mutex_unlock(\u0026amp;c-\u0026gt;lock); } void decrement(counter_t *c) { Pthread_mutex_lock(\u0026amp;c-\u0026gt;lock); c-\u0026gt;value--; Pthread_mutex_unlock(\u0026amp;c-\u0026gt;lock); } int get(counter_t *c) { Pthread_mutex_lock(\u0026amp;c-\u0026gt;lock); int rc = c-\u0026gt;value; Pthread_mutex_unlock(\u0026amp;c-\u0026gt;lock); return rc; } ä½†è¿™ç§å®ç°çš„ scalability å¾ˆå·®ï¼šå¦‚æœç»™ $n$ ä¸ªæ ¸åˆ†é…ç­‰é‡çš„ä»»åŠ¡ï¼Œæœ€ç»ˆæ‰€æ¶ˆè€—çš„æ—¶é—´å‡ ä¹æ˜¯å•ä¸ªä»»åŠ¡æ—¶é•¿çš„ $n$ å€ã€‚å¤§éƒ¨åˆ†æ—¶é—´ CPU æ ¸ä¹‹é—´åœ¨äº’ç›¸ç­‰é”ï¼Œæˆ‘ä»¬æ²¡æœ‰åˆ©ç”¨å¤šå¤„ç†å™¨è¾¾åˆ°å¹¶è¡Œçš„æ•ˆç‡ã€‚","tags":null,"title":"Chapter 29: Lock-based Concurrent Data Structures","type":"docs"},{"authors":null,"categories":null,"content":"å¾ˆå¤šæ—¶å€™ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªä»»åŠ¡ç­‰å¾…å¦ä¸€ä¸ªä»»åŠ¡çš„éœ€æ±‚ï¼Œæ¯”å¦‚ä¸»çº¿ç¨‹ç­‰åˆ°å­çº¿ç¨‹ç»“æŸåå†ç»§ç»­æ‰§è¡Œ (è¿™ä¸ªå‡½æ•°é€šå¸¸è¢«ç§°ä¸º join() )ã€‚ä¸€ä¸ªæœ´ç´ çš„æƒ³æ³•æ˜¯åˆ©ç”¨ä¸€ä¸ªå…±äº«å˜é‡å®ç°ï¼š\nvolatile int done = 0; void *child(void *arg) { do_something(); done = 1; return NULL; } int main () { pthread_t c; Pthread_create(\u0026amp;c, NULL, child, NULL); while (done == 0) ; do_something_else(); return 0; } ä½†è¿™æ ·åšä¸»çº¿ç¨‹ä¼šåœ¨ done å˜é‡ä¸Šä¸åœåœ°è‡ªæ—‹ï¼Œå  CPU ä¸å¹²æ´»ã€‚æˆ‘ä»¬å¸Œæœ›æœ‰æ›´é«˜æ•ˆçš„å®ç°æ–¹æ³•ã€‚\n30.1 Definition and Routines ä¸ºäº†è®©ä¸€ä¸ªçº¿ç¨‹ç­‰å¾…ä¸€ä¸ªæ¡ä»¶æˆç«‹ï¼Œæˆ‘ä»¬é€šå¸¸ä½¿ç”¨æ¡ä»¶å˜é‡ (condition variable)ã€‚æ¡ä»¶å˜é‡å¯ä»¥ç†è§£ä¸ºä¸€ä¸ªæ˜¾å¼çš„é˜Ÿåˆ—ï¼Œçº¿ç¨‹å¯ä»¥å°†è‡ªå·±åŠ å…¥åˆ°è¿™ä¸ªé˜Ÿåˆ—ä¸­æŒ‚èµ·ï¼Œå½“å…¶ä»–çº¿ç¨‹çš„æ“ä½œä½¿å¾—æ¡ä»¶å˜åŒ–æ—¶ï¼Œå®ƒä¼šå”¤é†’è¿™ä¸ªâ€œé˜Ÿåˆ—â€ä¸­çš„çº¿ç¨‹ã€‚æˆ‘ä»¬æä¾›ä¸¤ä¸ª APIï¼šwait() å¯ä»¥è®©çº¿ç¨‹å°†è‡ªå·±åŠ å…¥åˆ°é˜Ÿåˆ—ä¸­ç­‰å¾…ï¼›signal() å¯ä»¥è®©åˆ«çš„çº¿ç¨‹æ”¹å˜äº†æ¡ä»¶çŠ¶æ€æ—¶å‘é˜Ÿåˆ—ä¸­çš„çº¿ç¨‹â€œå‘é€ä¿¡å·â€ã€‚\nPOSIX æä¾›çš„æ¡ä»¶å˜é‡ API ä¸º\nint pthread_cond_wait(pthread_cont_t *c, pthread_mutex_t *m); int pthread_cond_signal(pthread_cond_t *c); æ³¨æ„åˆ° wait() çš„å‚æ•°ä¸­é™¤äº†æ¡ä»¶å˜é‡ c è¿˜æœ‰ä¸€ä¸ªè‡ªæ—‹é” mã€‚wait() çš„è¯­ä¹‰è¦æ±‚è°ƒç”¨æ—¶çº¿ç¨‹å¿…é¡»æ‹¥æœ‰è‡ªæ—‹é” mï¼Œwait() ä¼šè´Ÿè´£é‡Šæ”¾è¿™ä¸ªè‡ªæ—‹é”å¹¶ä½¿å½“å‰çº¿ç¨‹è¿›å…¥ç¡çœ çŠ¶æ€ (è¿™ä¸¤æ­¥æ˜¯åŸå­çš„)ï¼›å½“ signal() ä½¿å½“å‰çº¿ç¨‹è¢«å”¤é†’åï¼Œwait() ä¼šè´Ÿè´£è®©çº¿ç¨‹é‡æ–°è·å¾—è‡ªæ—‹é” mï¼Œç„¶åè¿”å›ã€‚\njoin.c æä¾›äº†ä¸€ä¸ªä¸»çº¿ç¨‹ç­‰å¾…å­çº¿ç¨‹ç»“æŸçš„æ­£ç¡®å®ç°ã€‚äº‹å®ä¸Šè¿™ä¸ªè¿‡ç¨‹æ˜¯å¾ˆå®¹æ˜“å®ç°é”™çš„ï¼Œæ¯”å¦‚å¦‚ä¸‹ä¸€äº›å†™æ³•ï¼š\nvoid thr_exit() { Pthread_mutex_lock(\u0026amp;m); Pthread_cond_signal(\u0026amp;c); Pthread_mutex_unlock(\u0026amp;m); } void thr_join() { Pthread_mutex_lock(\u0026amp;m); Pthread_cond_wait(\u0026amp;c, \u0026amp;m); Pthread_mutex_unlock(\u0026amp;m); } è¿™ä¸ªå†™æ³•åªæœ‰åœ¨ thr_join() åœ¨ thr_exit() ä¹‹å‰æ‰§è¡Œçš„æƒ…å†µä¸‹æ‰æ˜¯æ­£ç¡®çš„ã€‚å¦‚æœé¢ å€’äº†é¡ºåºï¼Œthr_join() å°†æ°¸è¿œä¸ä¼šè¢«å”¤é†’ ( join_no_state_var.c ä¸­ï¼Œä¸»çº¿ç¨‹é‡Œä½¿ç”¨äº† sleep() ä»¥ç²¾ç¡®å¤ç°è¿™ä¸€æƒ…å½¢)ã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œä½¿ç”¨æ¡ä»¶å˜é‡æ—¶ç†åº”æœ‰ä¸€ä¸ªæ¡ä»¶çŠ¶æ€çš„åˆ¤æ–­ã€‚\nvoid thr_exit() { done = 1; Pthread_cond_signal(\u0026amp;c); } void thr_join() { while (done == 0) Pthread_cond_wait(\u0026amp;c); } è¿™ä¸ªå†™æ³•æ²¡æœ‰ç”¨é”ä¿æŠ¤çŠ¶æ€å˜é‡ done çš„è¯»å†™ï¼Œç¼ºå¤±äº†åŸå­æ€§ã€‚è¿™é‡Œçš„åŸå­æ€§ç¼ºå¤±æŒ‡çš„æ˜¯ï¼šè™½ç„¶åœ¨ while åˆ¤æ–­æ—¶ done == 0ï¼Œä½†åœ¨ wait() æ—¶ done å¯èƒ½å·²ç»ä¸ç­‰äº 0 äº†ã€‚è€ƒè™‘è¿™æ ·ä¸€ç§æ‰§è¡Œæµï¼šthr_join() åšå®Œ while åˆ¤æ–­è¿›å…¥å¾ªç¯ï¼Œè¿˜æ²¡æ¥å¾—åŠ wait() æ—¶ï¼Œæ‰§è¡Œæµè¢«æ‰“æ–­ï¼Œthr_exit() æ‰§è¡Œå¹¶ signal()ï¼Œä½†æ­¤æ—¶é˜Ÿåˆ—ä¸­å¹¶æ²¡æœ‰çº¿ç¨‹ã€‚æ¥ç€ thr_join() ç»§ç»­æ‰§è¡Œé™·å…¥ç¡çœ ï¼Œé‚£ä¹ˆå®ƒå°†æ°¸è¿œä¸ä¼šè¢«å”¤é†’ ( join_no_lock() ä¸­åœ¨ä¸»çº¿ç¨‹ä½¿ç”¨äº†æ¯”å­çº¿ç¨‹æ—¶é—´æ›´é•¿çš„ sleep() ä»¥ç²¾ç¡®å¤ç°è¿™ä¸€æƒ…å†µ)ã€‚\nTip: Always Hold The Lock While Signaling\nPOSIX çš„ wait() å‡½æ•°çš„è¯­ä¹‰å·²ç»è¦æ±‚äº†æˆ‘ä»¬åœ¨è°ƒç”¨ wait() æ—¶å¿…é¡»è¦æ‹¥æœ‰è‡ªæ—‹é”ï¼›è™½ç„¶å°‘æ•°æƒ…å†µä¸‹æˆ‘ä»¬å¯ä»¥æ— é”åœ°è°ƒç”¨ signal()ï¼Œä½†ä¸ºäº†å®‰å…¨å’Œç®€å•ï¼Œæˆ‘ä»¬åº”å½“åœ¨ signal() æ—¶ä¹Ÿç”¨è‡ªæ—‹é”ä¿æŠ¤ã€‚\n30.2 The Producer/Consumer (Bounded Buffer) Problem ç”Ÿäº§è€…-æ¶ˆè´¹è€…é—®é¢˜åœ¨ç³»ç»Ÿä¸­å¾ˆå¸¸è§ï¼Œæ¯”å¦‚ä¸‹é¢çš„ä¾‹å­ï¼š\ngrep foo file.txt | wc -l grep æ‰¾åˆ°çš„å†…å®¹é€šè¿‡ç®¡é“ä¼ é€ç»™ wc ç»Ÿè®¡ä¸ªæ•°ã€‚ç®¡é“åœ¨å†…æ ¸ä¸­å°±æ˜¯ä¸€ä¸ªç¼“å†²åŒºï¼Œå› æ­¤è¿™é‡Œ grep æ˜¯ä¸€ä¸ªç”Ÿäº§è€…ï¼Œwc æ˜¯ä¸€ä¸ªæ¶ˆè´¹è€…ï¼Œwc ä¸èƒ½åœ¨ buffer ä¸ºç©ºçš„æ—¶å€™ä»ç®¡é“é‡Œè¯»ä¸œè¥¿ï¼Œgrep ä¹Ÿä¸èƒ½åœ¨ç¼“å†²åŒºæ»¡äº†çš„æ—¶å€™å†å¾€é‡Œå¡«ã€‚\nA Broken Solution ä¸€ä¸ªæ¯”è¾ƒè‡ªç„¶ä½†å´é”™è¯¯çš„å®ç°å¦‚ä¸‹æ‰€ç¤ºï¼š\nvoid *producer(void *arg) { for (int i = 0; i \u0026lt; LOOP; i++) { lock(\u0026amp;lk); if (count == 1) wait(\u0026amp;cond, \u0026amp;lk); put(i); // count becomes 1 signal(\u0026amp;cond); unlock(\u0026amp;lk); } } void *consumer(void *arg) { while (1) { lock(\u0026amp;lk); if (count == 0) wait(\u0026amp;cond, \u0026amp;lk); int rt = get(); // count becomes 0 signal(\u0026amp;cond); unlock(\u0026amp;lk); printf(\u0026quot;%d\\n\u0026quot;, rt); } } å¦‚æœåªæœ‰ä¸€ä¸ªç”Ÿäº§è€…çº¿ç¨‹å’Œä¸€ä¸ªæ¶ˆè´¹è€…çº¿ç¨‹ï¼Œè¿™ä¸ªå®ç°æ˜¯æ­£ç¡®çš„ã€‚ä½†å¦‚æœæœ‰å¤šä¸ªï¼Œæ¯”å¦‚ä¸€ä¸ªç”Ÿäº§è€…å’Œä¸¤ä¸ªæ¶ˆè´¹è€…ï¼Œå°±ä¼šæœ‰å¹¶å‘ bugã€‚è€ƒè™‘å¦‚ä¸‹æ‰§è¡Œè¿‡ç¨‹ï¼š\n$T_{c_1}$ è¿è¡Œï¼Œå‘ç° count == 0ï¼ŒæŒ‚èµ·ï¼› $T_p$ è¿è¡Œï¼Œå¾€ buffer é‡Œæ”¾äº†ä¸€ä¸ªæ•°ï¼Œç„¶åé€šè¿‡ signal() å”¤é†’ $T_{c_1}$ã€‚ $T_{c_1}$ åˆšè¢«å”¤é†’ï¼Œè¿˜æ²¡æ¥å¾—åŠè·å¾—è‡ªæ—‹é”è¿”å›çš„æ—¶å€™ï¼Œ$T_{c_2}$ è¿è¡Œï¼Œä» buffer é‡Œå–èµ°äº†è¿™ä¸ªæ•°æ‰“å°ï¼› è¿™æ—¶è¿”å›åˆ° $T_{c_1}$ï¼Œè·å¾—è‡ªæ—‹é”è¿”å›åï¼Œç”±äºä¹‹å‰çš„åˆ¤æ–­æ˜¯ if è¯­å¥ï¼Œå®ƒæ— æ³•å‘ç° count æ­¤æ—¶åˆå˜æˆ 0 äº†ï¼Œäºæ—¶å†æ¬¡ä» buffer ä¸­å–æ•°ï¼Œè§¦å‘ assertion failã€‚ å¹¶å‘ bug äº§ç”Ÿçš„åŸå› æ˜¯ï¼šä»æ¶ˆè´¹è€…çº¿ç¨‹è¢«å”¤é†’åˆ°æ¶ˆè´¹è€…çº¿ç¨‹çœŸæ­£è·å¾—è‡ªæ—‹é”å¼€å§‹å·¥ä½œè¿™æ®µæ—¶é—´å†…ï¼Œbuffer çš„çŠ¶æ€æ”¹å˜äº†ã€‚signal() çš„è¯­ä¹‰åªæ˜¯é€šçŸ¥ä¸€ä¸ªæ­£åœ¨ç­‰å¾…çš„çº¿ç¨‹ï¼šä¸–ç•Œçš„çŠ¶æ€æ”¹å˜äº†ï¼Œä½†å®ƒä¸ä¿è¯ä¸–ç•Œçš„çŠ¶æ€è¢«æ”¹å˜æˆäº†è°ƒç”¨ signal() ä¹‹å‰é‚£ä¸€ç¬çš„çŠ¶æ€ã€‚ è¿™ç§ signal() çš„è¯­ä¹‰è¢«ç§°ä¸º Mesa semanticsã€‚ä¸ä¹‹ç›¸å¯¹çš„æ˜¯ Hoare Semanticsï¼Œå®ƒä¿è¯è°ƒç”¨ signal() ä¹‹åä¸€ä¸ªçº¿ç¨‹è¢«å”¤é†’å¹¶ç«‹å³è¢«æ‰§è¡Œ (åŸå­æ€§)ã€‚ä½†åè€…éš¾å®ç°çš„å¤šï¼Œç°åœ¨ç»å¤§éƒ¨åˆ†ç³»ç»Ÿçš„ signal() ä½¿ç”¨çš„éƒ½æ˜¯ Mesa semanticsã€‚\nBetter, But Still Broken: While, Not If Mesa semantics æ˜¯æ¯”è¾ƒå®¹æ˜“å…‹æœçš„ï¼šæˆ‘ä»¬åªè¦å°†ä¸Šé¢ç¨‹åºä¸­å¯¹çŠ¶æ€å˜é‡åšåˆ¤æ–­çš„ if æ¢æˆ while å³å¯ã€‚è¿™æ ·å³ä½¿è¢«å”¤é†’åçŠ¶æ€åˆè¢«æ”¹å˜ï¼Œçº¿ç¨‹è·å¾—è‡ªæ—‹é”åä¼šå†æ¬¡æ£€æŸ¥çŠ¶æ€ï¼Œå‘ç°ä¸å¯¹åå¯ä»¥å†æ¬¡è¿›å…¥ç¡çœ ã€‚\nAlways use while loops when working with condition variables!\nä½†å³ä½¿å°† if æ”¹æˆ whileï¼Œæˆ‘ä»¬çš„ç¨‹åºä»ç„¶æœ‰å¹¶å‘ bugã€‚è€ƒè™‘å¦‚ä¸‹æ‰§è¡Œè¿‡ç¨‹ï¼š\n$T_{c_1}$ è¿è¡Œï¼Œå‘ç° count == 0ï¼ŒæŒ‚èµ·ï¼› $T_{c_2}$ è¿è¡Œï¼Œå‘ç° count == 0ï¼ŒæŒ‚èµ·ï¼› $T_p$ è¿è¡Œï¼Œå¾€ buffer é‡Œæ·»åŠ äº†ä¸€ä¸ªæ•°å­—ï¼Œç„¶åé€šè¿‡ signal() å”¤é†’äº† $T_{c_1}$ã€‚å”¤é†’å $T_{c_1}$ å¹¶æœªç«‹åˆ»æ‰§è¡Œï¼Œè€Œæ˜¯ $T_p$ ç»§ç»­è¿è¡Œï¼Œç¬¬äºŒæ¬¡å¾ªç¯æ—¶ $T_p$ å‘ç° count == 1ï¼ŒæŒ‚èµ·ï¼› $T_{c_1}$ è¿è¡Œï¼Œä» buffer é‡Œè¯»å–äº†ä¸€ä¸ªæ•°å­— (count å˜ä¸º 0) ç„¶åé€šè¿‡ signal() å”¤é†’ä¸€ä¸ªçº¿ç¨‹ã€‚æ³¨æ„æ­¤æ—¶ç¡çœ åœ¨æ¡ä»¶å˜é‡ä¸Šçš„çº¿ç¨‹æœ‰ $T_p$ å’Œ $T_{c_2}$ ä¸¤ä¸ªã€‚$T_{c_1}$ é€‰æ‹©å”¤é†’ $T_{c_2}$ã€‚ $T_{c_1}$ å’Œ $T_{c_2}$ éƒ½å‘ç°æ²¡æœ‰æ•°æ®å¯è¯»ï¼ŒæŒ‚èµ·ã€‚ åˆ°è¿™é‡Œï¼Œä¸‰ä¸ªçº¿ç¨‹å…¨éƒ¨é™·å…¥ç¡çœ ï¼Œç¨‹åºåœæ»ã€‚ä»è¿™ä¸ªä¾‹å­ä¸­æˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼šæ¶ˆè´¹è€…çº¿ç¨‹æ¶ˆè´¹å®Œååº”è¯¥å”¤é†’ç”Ÿäº§è€…çº¿ç¨‹ï¼›ç”Ÿäº§è€…çº¿ç¨‹ç”Ÿäº§å®Œååº”è¯¥å”¤é†’æ¶ˆè´¹è€…çº¿ç¨‹ï¼Œæˆ‘ä»¬åº”è¯¥æœ‰ä¸¤ä¸ªæ¡ä»¶å˜é‡ã€‚\nThe Correct Producer/Consumer Solution pc.c æä¾›äº†ä¸€ä¸ªå®Œæ•´ã€æ­£ç¡®çš„ç”Ÿäº§è€…-æ¶ˆè´¹è€…å®ç°ï¼Œå…¶ä¸­çš„è¦ç‚¹å¦‚ä¸‹ï¼š\nä½¿ç”¨ä¸¤ä¸ªæ¡ä»¶å˜é‡ï¼Œä¿è¯æ¶ˆè´¹è€…åªèƒ½å”¤é†’ç”Ÿäº§è€…ï¼Œç”Ÿäº§è€…åªèƒ½å”¤é†’æ¶ˆè´¹è€…ã€‚ åˆ¤æ–­çŠ¶æ€å˜é‡ä½¿ç”¨ while è¯­å¥ã€‚ ä½¿ç”¨ä¸€ä¸ªå¾ªç¯æ•°ç»„ä½œä¸º bufferï¼Œcount çš„ä¸Šé™ä¸å†æ˜¯ 1 è€Œæ˜¯ä¸€ä¸ªæŒ‡å®šçš„ maxï¼Œè¿™ä½¿å¾— buffer æœ‰äº†ä¸€å®šçš„å®¹é‡ã€‚ è¿™æ˜¯ä¸€ä¸ªå•ç”Ÿäº§è€…-å¤šæ¶ˆè´¹è€…çš„ç¨‹åºï¼Œç”Ÿäº§è€…æœ€åä¸ºæ¯ä¸ªæ¶ˆè´¹è€…å‡†å¤‡äº†ä¸€ä¸ª -1ï¼Œä»¥ä¿è¯æ¶ˆè´¹è€…çº¿ç¨‹èƒ½å¤Ÿå…¨éƒ¨é€€å‡ºã€‚ Tip: Use While (Not If) for Conditions\nä½¿ç”¨ while æ€»æ˜¯å¯¹çš„ï¼Œåœ¨å°‘æ•°åœºåˆä¸‹ä½¿ç”¨ if ä¹Ÿå¯ä»¥è¾¾åˆ°ç›®çš„ï¼Œä½†ä¸ºäº†å®‰å…¨æ€§æœ€å¥½é€šé€šä½¿ç”¨ whileã€‚\næˆ‘ä»¬æ¨èä½¿ç”¨ while è€Œä¸æ˜¯ if çš„å¦ä¸€ä¸ªåŸå› æ˜¯ï¼šä¸€äº›å®ç°çš„æœ‰é—®é¢˜çš„ signal() å¯èƒ½ä¼šå”¤é†’ä¸æ­¢ä¸€ä¸ªç­‰å¾…çš„çº¿ç¨‹ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œwhile ä»ç„¶èƒ½å¸®æˆ‘ä»¬ä¿è¯æ­£ç¡®ã€‚\n30.3 Covering Conditions å‡è®¾æˆ‘ä»¬å¸Œæœ›ç”¨æ¡ä»¶å˜é‡å®ç°ä¸€ä¸ªå†…å­˜åˆ†é…å™¨ï¼Œalloc() æ—¶å¦‚æœå‰©ä½™å†…å­˜ä¸è¶³åˆ™æŒ‚èµ·ï¼Œä¸€æ®µä¼ªä»£ç å¦‚ä¸‹ï¼š\nint bytesLeft = MAX_HEAP_SIZE; void *allocate(int size) { lock(\u0026amp;lk); while (bytesLeft \u0026lt; size) wait(\u0026amp;cond, \u0026amp;lk); void *ptr = GetMemoryFromHeap(size); bytesLeft -= size; unlock(\u0026amp;lk); return ptr; } void free(void *ptr, int size) { lock(\u0026amp;lk); bytesLeft += size; FreeMemoryToHeap(ptr, size); signal(\u0026amp;cond); unlock(\u0026amp;lk); } å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ª alloc(100) å’Œ alloc(10) å¤„äºç¡çœ çŠ¶æ€ï¼Œç°åœ¨æ¥äº†ä¸€ä¸ª free(50)ï¼Œé—®é¢˜å‡ºç°äº†ï¼šå¦‚æœæˆ‘ä»¬éšæ„æŒ‘ä¸€ä¸ªçº¿ç¨‹å”¤é†’ï¼Œå‡å¦‚æŒ‘äº† alloc(100) çš„é‚£ä¸ªï¼Œåˆ†é…è¿˜æ˜¯ä¼šå¤±è´¥ï¼Œä¸”æˆ‘ä»¬é”™è¿‡äº†è®© alloc(10) æˆåŠŸçš„æœºä¼šã€‚ä¸€ç§è§£å†³æ–¹æ¡ˆæ˜¯ï¼šç”¨ä¸€ä¸ª broadcast() å‡½æ•°æ›¿ä»£ signal() å‡½æ•°ï¼Œå®ƒå¯ä»¥å”¤é†’ç¡çœ åœ¨æ¡ä»¶å˜é‡ä¸Šçš„æ‰€æœ‰çº¿ç¨‹ã€‚è¿™ç§æ–¹å¼è¢«ç§°ä¸º covering conditionsã€‚\nbroadcast() ç›¸è¾ƒäº signal() çš„åå¤„åœ¨äºï¼šå¹¶ä¸æ˜¯æ‰€æœ‰çš„çº¿ç¨‹éƒ½èƒ½åœ¨è¢«å”¤é†’åè¿è¡Œä¸‹å»ï¼Œæ¯”å¦‚ç°åœ¨ buffer é‡Œåªæœ‰ä¸€ä¸ªå­—ç¬¦ï¼Œè€Œ broadcast() å”¤é†’äº† 100 ä¸ªæ¶ˆè´¹è€…ï¼Œé‚£ä¹ˆåªæœ‰ä¸€ä¸ªæ¶ˆè´¹è€…èƒ½å¾—åˆ°å­—ç¬¦ã€‚è¿è¡Œä¸ä¸‹å»çš„å­—ç¬¦ä¼šé‡Šæ”¾é”å¹¶å†æ¬¡è¿›å…¥ç¡çœ ï¼Œè¿™ç§æ— è°“æ‰“æ…äº†ç¡çœ çº¿ç¨‹çš„æ–¹å¼å¯¹æ€§èƒ½å½±å“å¾ˆå¤§ã€‚\næ­£å› å¦‚æ­¤ï¼Œè™½ç„¶æˆ‘ä»¬åœ¨ä¹‹å‰çš„ç”Ÿäº§è€…-æ¶ˆè´¹è€…é—®é¢˜ä¸­å¯ä»¥ä½¿ç”¨ä¸€ä¸ªæ¡ä»¶å˜é‡+broadcast çš„æ–¹å¼è§£å†³é—®é¢˜ï¼Œä½†é‚£æ—¶æˆ‘ä»¬æ˜¾ç„¶æœ‰å¾ˆç®€å•çš„ 2-æ¡ä»¶å˜é‡è§£å†³æ–¹æ¡ˆï¼Œæ‰€ä»¥ä¸è€ƒè™‘è¿™ç§æ•ˆç‡è¾ƒä½çš„æ–¹å¼ã€‚ä¸è¿‡åœ¨å†…å­˜åˆ†é…çš„åœºæ™¯ä¸­ï¼Œbroadcast() å‡ ä¹æ˜¯å”¯ä¸€çš„é€‰æ‹©ã€‚\n30.4 Summary ç•¥ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"78f9e1402c1b9556a1c713df45ecbbd8","permalink":"https://kristoff-starling.github.io/notes/booknotes/ostep/ch30/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/booknotes/ostep/ch30/","section":"notes","summary":"å¾ˆå¤šæ—¶å€™ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªä»»åŠ¡ç­‰å¾…å¦ä¸€ä¸ªä»»åŠ¡çš„éœ€æ±‚ï¼Œæ¯”å¦‚ä¸»çº¿ç¨‹ç­‰åˆ°å­çº¿ç¨‹ç»“æŸåå†ç»§ç»­æ‰§è¡Œ (è¿™ä¸ªå‡½æ•°é€šå¸¸è¢«ç§°ä¸º join() )ã€‚ä¸€ä¸ªæœ´ç´ çš„æƒ³æ³•æ˜¯åˆ©ç”¨ä¸€ä¸ªå…±äº«å˜é‡å®ç°ï¼š\nvolatile int done = 0; void *child(void *arg) { do_something(); done = 1; return NULL; } int main () { pthread_t c; Pthread_create(\u0026amp;c, NULL, child, NULL); while (done == 0) ; do_something_else(); return 0; } ä½†è¿™æ ·åšä¸»çº¿ç¨‹ä¼šåœ¨ done å˜é‡ä¸Šä¸åœåœ°è‡ªæ—‹ï¼Œå  CPU ä¸å¹²æ´»ã€‚æˆ‘ä»¬å¸Œæœ›æœ‰æ›´é«˜æ•ˆçš„å®ç°æ–¹æ³•ã€‚","tags":null,"title":"Chapter 30: Condition Variables","type":"docs"},{"authors":null,"categories":null,"content":"ä¿¡å·é‡çš„æ¦‚å¿µæœ€æ—©ç”± Dijkstra æå‡ºï¼Œå®ƒæ—¢å¯ä»¥ä½œä¸ºé”ä½¿ç”¨ä¹Ÿå¯ä»¥ä½œä¸ºæ¡ä»¶å˜é‡ä½¿ç”¨ã€‚\n31.1 Semaphores: A Definition ä½¿ç”¨ä¸€ä¸ªä¿¡å·é‡ä¹‹å‰æˆ‘ä»¬è¦å®šä¹‰å…¶åˆå§‹å€¼ï¼š\n#include \u0026lt;semaphore.h\u0026gt; sem_t s; sem_init(\u0026amp;s, 0, 1); sem_init() çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä¿¡å·é‡ï¼Œç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯åˆå§‹å€¼ï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸º 0 è¡¨ç¤ºè¯¥ä¿¡å·é‡åœ¨åŒè¿›ç¨‹ä¸‹çš„æ‰€æœ‰çº¿ç¨‹ä¹‹é—´å…±äº« (å¦‚æœæƒ³è®©ä¿¡å·é‡åœ¨ä¸åŒè¿›ç¨‹ä¹‹é—´å…±äº«ï¼Œå¯ä»¥è®¾ç½®ä¸ºå…¶ä»–æ•°å€¼)ã€‚\nPOSIX æ ‡å‡†æä¾›äº†ä¿¡å·é‡æ“ä½œç›¸å…³çš„ APIï¼šsem_wait() å’Œ sem_post()ã€‚ç›¸è¾ƒäºæ¡ä»¶å˜é‡ï¼Œä¿¡å·é‡ä½¿ç”¨èµ·æ¥éå¸¸ç®€å•ï¼šæˆ‘ä»¬ä¸éœ€è¦å…³æ³¨ä»€ä¹ˆæ—¶å€™è·å¾—é”ï¼Œç”¨ while è¿˜æ˜¯ if ç­‰é—®é¢˜ï¼Œåœ¨ç”¨æˆ·å±‚é¢æˆ‘ä»¬å¯ä»¥è®¤ä¸ºè¿™äº› API éƒ½æ˜¯åŸå­çš„ã€‚å®ƒä»¬çš„è¯­ä¹‰å¯ä»¥ç”¨å¦‚ä¸‹ä¼ªä»£ç æè¿°ï¼š\nvoid sem_wait(sem_t *s) { decrement the value of s by one; wait if value of s is negative; } void sem_post(sem_t *s) { increment the value of s by one; if there are one or more threads waiting, wake one; } å½“ s çš„å€¼ä¸ºæ­£æ—¶ï¼Œå…¶æ„ä¹‰æ˜¯å‰©ä½™çš„èµ„æºé‡ï¼›å½“ s çš„å€¼ä¸ºè´Ÿæ—¶ï¼Œå…¶æ„ä¹‰æ˜¯å½“å‰æ­£åœ¨ç­‰å¾…çš„çº¿ç¨‹æ•°é‡ã€‚\n(æ³¨ï¼šä¸åŒäºé”ï¼Œsem_post() å¹¶ä¸éœ€è¦ä¸€ä¸ªçº¿ç¨‹æ›¾ç»è°ƒç”¨è¿‡ sem_wait()ï¼Œè¿™ç›¸å½“äºçº¿ç¨‹å¯ä»¥å‡­ç©ºâ€œåˆ›é€ â€ä¸€ä»½èµ„æºã€‚å› æ­¤ä½¿ç”¨æ—¶ä¸€å®šè¦æ ¼å¤–å°å¿ƒï¼Œæ³¨æ„ sem_wait() å’Œ sem_post() çš„å¯¹åº”ã€‚)\n31.2 Binary Semaphores (Locks) ä¿¡å·é‡å¯ä»¥å½“ä½œé”æ¥ä½¿ç”¨ï¼Œè¿™ç§ä¿¡å·é‡è¢«ç§°ä¸º binary semaphoreã€‚ binary.c å±•ç¤ºäº†å…·ä½“çš„å®ç°ã€‚\nsem_t m; sem_init(\u0026amp;m, 0, 1); sem_wait(\u0026amp;m); // critical section sem_post(\u0026amp;m); ä¿¡å·é‡çš„åˆå§‹å€¼è®¾ç½®ä¸º 1ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠå®ƒæƒ³è±¡æˆä¸€ä¸ªå•ä½çš„èµ„æº (ä»»ä½•æ—¶åˆ»åªèƒ½ä¸Šä¸€æŠŠé”)ã€‚è€ƒè™‘ä¸€ä¸ª lock contention çš„æƒ…å†µï¼š\nçº¿ç¨‹ 1 è°ƒç”¨ sem_wait()ï¼Œm çš„å€¼å˜ä¸º 0ï¼Œçº¿ç¨‹ 1 æˆåŠŸè¿›å…¥ä¸´ç•ŒåŒºåŸŸã€‚ çº¿ç¨‹ 2 è°ƒç”¨ sem_wait()ï¼Œm çš„å€¼å˜ä¸º -1ï¼Œè¯¥çº¿ç¨‹è¿›å…¥ç­‰å¾…åºåˆ—ã€‚ çº¿ç¨‹ 3 è°ƒç”¨ sem_wait()ï¼Œm çš„å€¼å˜ä¸º -2ï¼Œè¯¥çº¿ç¨‹è¿›å…¥ç­‰å¾…åºåˆ—ã€‚ çº¿ç¨‹ 1 ç¦»å¼€ä¸´ç•ŒåŒºåŸŸï¼Œè°ƒç”¨ sem_post()ï¼Œm çš„å€¼å˜ä¸º -1ï¼Œçº¿ç¨‹ 1 å”¤é†’ä¸€ä¸ªç­‰å¾…åºåˆ—é‡Œçš„çº¿ç¨‹ (å‡è®¾æ˜¯çº¿ç¨‹ 2) ç»§ç»­æ‰§è¡Œã€‚çº¿ç¨‹ 2 æˆåŠŸè¿›å…¥ä¸´ç•ŒåŒºåŸŸã€‚ çº¿ç¨‹ 2 ç¦»å¼€ä¸´ç•ŒåŒºåŸŸï¼Œè°ƒç”¨ sem_post()ï¼Œm çš„å€¼å˜ä¸º 0ï¼Œçº¿ç¨‹ 2 å”¤é†’çº¿ç¨‹ 3ï¼Œçº¿ç¨‹ 3 æˆåŠŸè¿›å…¥ä¸´ç•ŒåŒºåŸŸã€‚ çº¿ç¨‹ 3 ç¦»å¼€ä¸´ç•ŒåŒºåŸŸï¼Œè°ƒç”¨ sem_post()ï¼Œm çš„å€¼æ¢å¤ä¸º 1 (é”å½“å‰ç©ºé—²)ï¼Œçº¿ç¨‹ 3 æ²¡æœ‰å”¤é†’ä»»åŠ¡ã€‚ ç”¨ä¿¡å·é‡å®ç°çš„é”æ˜¯ sleep lock è€Œä¸æ˜¯ spinlockã€‚\n31.3 Semaphores For Ordering ä¿¡å·é‡å¯ä»¥ç”¨æ¥å®ç°ç­‰å¾… (ç±»ä¼¼äº join() çš„åŠŸèƒ½)ã€‚è¿™æ—¶ä¿¡å·é‡çš„åˆå§‹å€¼åº”å½“è¢«è®¾ä¸º 0ã€‚åœ¨ç­‰å¾…çš„çº¿ç¨‹ä¸­ä½¿ç”¨ sem_wait()ï¼Œåœ¨è¢«ç­‰å¾…çš„çº¿ç¨‹ç»“å°¾ä½¿ç”¨ sem_post()ã€‚ join.c ç»™å‡ºäº†å…·ä½“çš„å®ç°ã€‚\næˆ‘ä»¬åˆ†æä¸¤ç§å¯èƒ½çš„æƒ…å†µï¼š\nä¸»çº¿ç¨‹åœ¨å­çº¿ç¨‹ç»“æŸä¹‹å‰è°ƒç”¨ sem_wait()ï¼Œæ­¤æ—¶ä¿¡å·é‡çš„å€¼å˜ä¸º -1ï¼Œä¸»çº¿ç¨‹è¢«æŒ‚èµ·ã€‚å¾…å­è¿›ç¨‹æ‰§è¡Œç»“æŸåï¼Œè°ƒç”¨ sem_post()ï¼Œä¿¡å·é‡çš„å€¼æ¢å¤ä¸º 0ï¼Œå¹¶å”¤é†’ç­‰å¾…çš„ä¸»çº¿ç¨‹ç»§ç»­æ‰§è¡Œã€‚ ä¸»çº¿ç¨‹åœ¨å­çº¿ç¨‹ç»“æŸä¹‹åè°ƒç”¨ sem_wait()ï¼Œé‚£ä¹ˆå­çº¿ç¨‹ç»“æŸæ—¶è°ƒç”¨ sem_post() åï¼Œä¿¡å·é‡çš„å€¼å˜ä¸º 1ã€‚ä¸»çº¿ç¨‹è°ƒç”¨ sem_wait()ï¼Œä¿¡å·é‡çš„å€¼æ¢å¤ä¸º 0ï¼Œå› ä¸ºéè´Ÿï¼Œæ‰€ä»¥ä¸»çº¿ç¨‹å¯ä»¥ç›´æ¥ç»§ç»­æ‰§è¡Œã€‚ 31.4 The Producer/Consumer (Bounded Buffer) Problem æœ€ç›´æ¥çš„æƒ³æ³•æ˜¯å°†ä¹‹å‰åŒæ¡ä»¶å˜é‡çš„ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹ç›´æ¥å¥—ç”¨è¿‡æ¥ï¼š\nvoid put(int val) {buffer[fill] = val; fill = (fill + 1) % MAX;} int get() {int rt = buffer[use]; use = (use + 1) % MAX; return rt;} void *producer(void *arg) { for (int i = 0; i \u0026lt; LOOP; i++) { sem_wait(\u0026amp;empty); put(i); sem_post(\u0026amp;full); } } void *consumer(void *arg) { while (1) { sem_wait(\u0026amp;full); printf(\u0026quot;%d\\n\u0026quot;, get()); sem_post(\u0026amp;empty); } } sem_init(\u0026amp;empty, 0, MAX); sem_init(\u0026amp;full, 0, 0); è¿™ä¸ªåšæ³•åœ¨ MAX=1 æ—¶æ˜¯å¯ä»¥æ­£ç¡®æ‰§è¡Œçš„ï¼Œä½† MAX å¤§äºç­‰äº 2 æ—¶ä¼šå‡ºç°å¹¶å‘ bugã€‚è€ƒè™‘ä¸¤ä¸ªç”Ÿäº§è€…çº¿ç¨‹å¹¶å‘æ‰§è¡Œçš„è¿‡ç¨‹ï¼šT1 æ‰§è¡Œå®Œ sem_wait() ä¹‹åè¿›å…¥å‡½æ•° put()ï¼Œåˆšå°† val æ”¾è¿› bufferï¼Œè¿˜æ²¡æœ‰æ¥å¾—åŠç»™ fill +1 æ—¶ï¼ŒT1 è¢«æ‰“æ–­ï¼ŒT2 å¼€å§‹æ‰§è¡Œï¼Œå› ä¸º MAX\u0026gt;=2ï¼Œè¿™æ—¶ empty ä¸ä¸º 0ï¼ŒT2 å¯ä»¥é¡ºåˆ©è¿›å…¥ put()ï¼Œè¿™æ—¶å‘ç”Ÿäº†é—®é¢˜ï¼šT1 æ”¾è¿› buffer çš„å†…å®¹è¢« T2 çš„å†…å®¹è¦†ç›–äº†ã€‚\nå¯ä»¥çœ‹åˆ°å‡ºç°å¹¶å‘ bug çš„æ ¹æœ¬åŸå› åœ¨äºä¸¤ä¸ªè¿›ç¨‹åŒæ—¶è¿›å…¥äº†ä¸´ç•ŒåŒºåŸŸï¼Œå‘ç”Ÿäº†æ•°æ®ç«äº‰ã€‚è”æƒ³æ¡ä»¶å˜é‡çš„å†™æ³•ï¼Œçº¿ç¨‹åœ¨ wait() ä¸­è¢«å”¤é†’åæœ‰ä¸€ä¸ªå°è¯•é‡æ–°è·å¾—è‡ªæ—‹é”çš„è¿‡ç¨‹ï¼Œè€Œåœ¨è¿™é‡Œçš„ä¿¡å·é‡å®ç°ä¸­æˆ‘ä»¬æ²¡æœ‰ç”¨é”æŠŠä¸´ç•ŒåŒºåŸŸä¿æŠ¤èµ·æ¥ã€‚å› æ­¤æˆ‘ä»¬åªè¦åŠ é”å³å¯ã€‚\nçœŸçš„éšä¾¿åŠ ä¸€ä¸ªé”å°±å¯ä»¥äº†å—ï¼Ÿ\nè€ƒè™‘å¦‚ä¸‹åŠ é”åçš„å®ç°ï¼š\nvoid *producer(void *arg) { for (int i = 0; i \u0026lt; LOOP; i++) { lock(\u0026amp;lk); sem_wait(\u0026amp;empty); put(i); sem_post(\u0026amp;full); unlock(\u0026amp;lk); } } void *consumer(void *arg) { while (1) { lock(\u0026amp;lk); sem_wait(\u0026amp;full); printf(\u0026quot;%d\\n\u0026quot;, get()); sem_post(\u0026amp;empty); unlock(\u0026amp;lk); } } å‡è®¾ä¸€ä¸ªæ¶ˆè´¹è€…çº¿ç¨‹å…ˆè¿è¡Œï¼Œå®ƒè·å¾—äº†é”ä¹‹åï¼Œè°ƒç”¨ sem_wait()ï¼Œå‘ç° full == -1ï¼Œäºæ˜¯å¸¦ç€é”é™·å…¥äº†ç¡çœ ã€‚è¿™æ ·åˆ«çš„çº¿ç¨‹å†è¦å°è¯•è·å¾—é”æ—¶å°±ä¼šé™·å…¥æ­»é”ï¼šæ¶ˆè´¹è€…çº¿ç¨‹æ‹¥æœ‰é”ï¼Œåœ¨ç­‰å¾… full ä¿¡å·ï¼›ç”Ÿäº§è€…çº¿ç¨‹å¯ä»¥ signalï¼Œä½†å¾—å…ˆè·å¾—é”ï¼Œè¿™æ˜¯ä¸€ä¸ªæ ‡å‡†çš„æ­»é”ã€‚\nè”æƒ³æ¡ä»¶å˜é‡çš„å®ç°ï¼Œcond_wait() å’Œ sem_wait() çš„ä¸åŒåœ¨äºï¼Œcond_wait() æ¥æ”¶ä¸€ä¸ªé”çš„å‚æ•°ï¼Œä¼šåŸå­åœ°å®Œæˆçº¿ç¨‹ç¡çœ å’Œé”é‡Šæ”¾ï¼Œè€Œ sme_wait() æ²¡æœ‰å¸®æˆ‘ä»¬é‡Šæ”¾é”çš„åŠŸèƒ½ã€‚\näº‹å®ä¸Šï¼Œæ¡ä»¶å˜é‡è¦æŠŠé”åŠ åœ¨å‰é¢æ˜¯å› ä¸ºæˆ‘ä»¬è¦ä¿è¯å¯¹å…¨å±€çš„çŠ¶æ€å˜é‡çš„è®¿é—® ( while (!cond) ) æ˜¯åŸå­çš„ã€‚ä½†ä¿¡å·é‡æœ¬èº«å·²ç»ä¿è¯åŸå­æ€§äº†ã€‚æˆ‘ä»¬åªè¦æŠŠé”åŠ åœ¨é‡Œé¢å°±æ˜¯æ­£ç¡®çš„å®ç°ï¼š\nvoid *producer(void *arg) { for (int i = 0; i \u0026lt; LOOP; i++) { sem_wait(\u0026amp;empty); lock(\u0026amp;lk); put(i); unlock(\u0026amp;lk); sem_post(\u0026amp;full); } } void *consumer(void *arg) { while (1) { sem_wait(\u0026amp;full); lock(\u0026amp;lk); printf(\u0026quot;%d\\n\u0026quot;, get()); unlock(\u0026amp;lk); sem_post(\u0026amp;empty); } } produer_consumer_works.c æä¾›äº†å®Œæ•´çš„å®ç°ã€‚\n31.5 Reader-Writer Locks åŠ¨æœºï¼šå¯¹äºå¹¶å‘æ•°æ®ç»“æ„ï¼Œæˆ‘ä»¬ä¼šç”¨é”ä¿æŠ¤ä¸ä¹‹ç›¸å…³çš„å‡½æ•°ã€‚æˆ‘ä»¬ç”¨é”ä¿æŠ¤è¯»å‡½æ•°æ˜¯ä¸ºäº†é¿å…å†™çš„è¿‡ç¨‹ä¸­è¯»å–å‡½æ•°æ‰§è¡Œå¯¼è‡´å¥‡æ€ªçš„é—®é¢˜ï¼Œä½†è¿™ä¹Ÿå¯¼è‡´äº†å¦‚æœå½“å‰åªæœ‰å¾ˆå¤šä¸ªçº¿ç¨‹è¯»å–è€Œæ²¡æœ‰å†™æ“ä½œï¼Œæˆ‘ä»¬çš„è¯»å–æ— æ³•å¹¶è¡Œã€‚Reader-Writer Locks è‡´åŠ›äºè§£å†³è¿™ä¸ªé—®é¢˜ (äº‹å®ä¸Šä»¥ä¸‹æ–¹æ³•ä¸­çš„ä¿¡å·é‡éƒ½åœ¨æ¨¡æ‹Ÿé”çš„è¡Œä¸ºï¼Œå¯ä»¥åªä½¿ç”¨è‡ªæ—‹é”å®Œæˆ)ã€‚\nè§£å†³è¿™ä¸ªé—®é¢˜çš„åŸºæœ¬æ€è·¯æ˜¯ï¼šå†™æ“ä½œæ¯æ¬¡è¦è·å¾—ä¸€ä¸ªå†™é”ï¼Œå®Œæˆä»»åŠ¡åè¦é‡Šæ”¾å†™é”ã€‚è¯»æ“ä½œçš„è¡Œä¸ºæœ‰æ‰€ä¸åŒï¼šæˆ‘ä»¬ç»´æŠ¤ä¸€ä¸ªå˜é‡ reader è®°å½•å½“å‰æ­£åœ¨è¯»çš„çº¿ç¨‹çš„ä¸ªæ•°ï¼Œå½“ reader == 1 æ—¶ï¼Œè¯»çº¿ç¨‹è¦è·å¾—å†™é”ï¼Œè¿™æ ·å°±å±è”½äº†å†™æ“ä½œï¼Œåç»­æ›´å¤šçš„è¯»æ“ä½œå¯ä»¥åŠ å…¥è¿›æ¥ã€‚å½“ reader == 0 æ—¶ï¼Œè¯»çº¿ç¨‹è¦é‡Šæ”¾å†™é”ã€‚(å½“ç„¶ï¼Œè¯»çº¿ç¨‹ä¿®æ”¹ reader å˜é‡çš„è¿‡ç¨‹è¿˜éœ€è¦ä¸€ä¸ªé”ä¿æŠ¤)ã€‚å¤§è‡´çš„ä¼ªä»£ç å®ç°å¦‚ä¸‹ï¼š\ntypedef struct _rwlock_t { sem_t reader_lock; sem_t writelock; int readers; }rwlock_t; void rwlock_init(rwlock_t *rw) { rw-\u0026gt;readers = 0; sem_init(\u0026amp;rw-\u0026gt;reader_lock, 0, 1); // ä¿¡å·é‡ä½œä¸ºç¡çœ é” sem_init(\u0026amp;rw-\u0026gt;writelock, 0, 1); // ä¿¡å·é‡ä½œä¸ºç¡çœ é” } void rwlock_acquire_readlock(rwlock_t *rw) { sem_wait(\u0026amp;rw-\u0026gt;reader_lock); reader++; if (reader == 1) sem_wait(\u0026amp;rw-\u0026gt;writelock); sem_post(\u0026amp;rw-\u0026gt;reader_lock); } void rwlock_release_readlock(rwlock_t *rw) { sem_wait(\u0026amp;rw-\u0026gt;reader_lock); reader--; if (reader == 0) sem_post(\u0026amp;rw-\u0026gt;writelock); sem_post(\u0026amp;rw-\u0026gt;reader_lock); } void rwlock_acquire_writelock(rwlock_t *rw) {sem_wait(\u0026amp;rw-\u0026gt;writelock);} void rwlock_release_writelock(rwlock_t *rw) {sem_post(\u0026amp;rw-\u0026gt;writelock);} rwlock.c æä¾›äº†å®Œæ•´çš„å®ç°ã€‚\nè¯¥ç®—æ³•å­˜åœ¨ä¸€å®šçš„å…¬å¹³æ€§éšæ‚£ï¼šå¦‚æœè¯»çº¿ç¨‹æ¯”è¾ƒå¤šï¼Œæºæºä¸æ–­åœ°åŠ å…¥ï¼Œå†™çº¿ç¨‹å¯èƒ½ä¼šä¸€ç›´è°ƒåº¦ä¸ä¸Šã€‚(ä¸€ä¸ªå¯èƒ½çš„ç»´æŠ¤å…¬å¹³æ€§çš„æ–¹æ³•æ˜¯ä¸º reader è®¾ç½®ä¸€ä¸ªä¸Šé™ï¼Œå¦‚æœ reader == MAX_READERï¼Œåˆ™æŠŠè¯»çº¿ç¨‹æŒ‚èµ·ã€‚)\nHill\u0026rsquo;s Law\nHill\u0026rsquo;s Law å¤§è‡´çš„æ„æ€æ˜¯åœ¨å¾ˆå¤šæƒ…å†µä¸‹ï¼Œé‚£äº›çœ‹ä¸Šå»ç®€å•ç¬¨æ‹™çš„å®ç°åè€Œæ˜¯å¥½çš„ã€‚åœ¨è¿™é‡Œï¼Œreader-writer lock è™½ç„¶çœ‹èµ·æ¥å¾ˆ fancyï¼Œä½†å®é™…ä½¿ç”¨æ—¶æœªå¿…å¥½è¿‡ç®€å•çš„è‡ªæ—‹é”ï¼Œè¿™æ˜¯å› ä¸ºç»´æŠ¤ç²¾å·§çš„ç»“æ„æ€»éœ€è¦æ›´å¤šçš„å¼€é”€ã€‚å› æ­¤ï¼ŒæŠ›å¼€ workload è°ˆä¼˜åŒ–å°±æ˜¯è€æµæ°“ã€‚\n31.6 The Dining Philosophers ä¸€ä¸ªå“²å­¦å®¶çš„è¡Œä¸ºå¯ä»¥ç”¨å¦‚ä¸‹å‡½æ•°æè¿°ï¼š\nvoid *philosopher(void *arg) { while (1) { think(); getforks(); eat(); putforks(); } } å¦‚æœæˆ‘ä»¬ç®€å•åœ°ä¸ºæ¯æŠŠå‰å­å»ºç«‹ä¸€ä¸ªä¿¡å·é‡ï¼Œç„¶åè¿™æ ·æ„å»º getforks() å’Œ putforks()ï¼š\nint left(int p) {return p;} int right(int p) {return (p + 1) % PHI_NUM;} void getforks(int p) { sem_wait(forks[left(p)]); sem_wait(forks[right(p)]); } void putforks(int p) { sem_post(forks[left(p)]); sem_post(forks[right(p)]); } å®¹æ˜“å‘ç°è¿™ä¸ªç¨‹åºæœ‰æ­»é”é£é™©ï¼šå¦‚æœæ¯ä¸ªå“²å­¦å®¶éƒ½æ‹¿èµ·äº†è‡ªå·±å·¦æ‰‹çš„å‰å­ï¼Œé‚£ä¹ˆæ‰€æœ‰äººéƒ½ä¼šç­‰å¾…è‡ªå·±å³æ‰‹è¾¹çš„å‰å­ï¼Œè€Œåˆæ²¡æœ‰ä»»ä½•äººä¼šæ”¾ä¸‹è‡ªå·±å·¦æ‰‹ä¸Šçš„å‰å­â€”â€”æ­»é”ã€‚ dining_philosophers_deadlock_print.c æ‰“å°å‡ºäº†æ­»é”çš„å±€é¢ã€‚\nå¦‚æœé”çš„éœ€æ±‚é“¾å‡ºç°äº†ç¯ï¼Œå°±ä¼šå‘ç”Ÿæ­»é”ï¼ŒDijkstra ç”¨ä¸€ä¸ªç®€å•çš„æ–¹æ³•è§£å†³äº†è¿™ä¸ªé—®é¢˜ï¼šåªè¦å®‰æ’æŸä¸€ä¸ªå“²å­¦å®¶å…ˆæ‹¿å³æ‰‹å‰å­å†æ‹¿å·¦æ‰‹å‰å­ï¼Œå°±å¯ä»¥ç ´è¿™ä¸ªå±€ï¼š\nvoid getforks(int p) { if (p == PHI_NUM) { sem_wait(forks[right(p)]); sem_wait(forks[left(p)]); } else { sem_wait(forks[left(p)]); sem_wait(forks[right(p)]); } } dining_philosophers_no_deadlock.c æä¾›äº†å®Œæ•´çš„å®ç°ã€‚\n31.7 How To Implement Semaphores æˆ‘ä»¬åœ¨ 31.1 å·²ç»å»ºç«‹äº†ä¿¡å·é‡çš„è¯­ä¹‰ï¼Œå› æ­¤ç”¨æ¡ä»¶å˜é‡å®ç°ä¿¡å·é‡ (ä¸å¦¨ç§°ä¹‹ä¸º zemaphore) éå¸¸ç®€å•ï¼š\ntypedef struct _zem_t { int val; pthread_cond_t cond; pthread_mutex_t lock; }zem_t; void zem_init(zem_t *z, int val) { z-\u0026gt;val = val; Cond_init(\u0026amp;z-\u0026gt;cond); // å¸¦è¿”å›å€¼æ£€æŸ¥çš„ pthread_cond_init() Mutex_init(\u0026amp;z-\u0026gt;lock); } void zem_wait(zem_t *z) { Mutex_lock(\u0026amp;z-\u0026gt;lock); while (z-\u0026gt;val \u0026lt;= 0) Cond_wait(\u0026amp;z-\u0026gt;cond, \u0026amp;z-\u0026gt;lock); z-\u0026gt;val--; Mutex_unlock(\u0026amp;z-\u0026gt;lock); } void zem_post(zem_t *z) { Mutex_lock(\u0026amp;z-\u0026gt;lock); z-\u0026gt;val++; Cond_signal(\u0026amp;z-\u0026gt;cond); Mutex_unlock(\u0026amp;z-\u0026gt;lock); } zemaphore.h æä¾›äº†å®Œæ•´çš„å®ç°ï¼Œ zemaphore.c æä¾›äº†ä¸€ä¸ªä½¿ç”¨ zemaphores çš„ä¾‹å­ã€‚\n31.8 Summary ç•¥ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"bf66ee416f3064ccbc869b0cfa08e580","permalink":"https://kristoff-starling.github.io/notes/booknotes/ostep/ch31/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/booknotes/ostep/ch31/","section":"notes","summary":"ä¿¡å·é‡çš„æ¦‚å¿µæœ€æ—©ç”± Dijkstra æå‡ºï¼Œå®ƒæ—¢å¯ä»¥ä½œä¸ºé”ä½¿ç”¨ä¹Ÿå¯ä»¥ä½œä¸ºæ¡ä»¶å˜é‡ä½¿ç”¨ã€‚\n31.1 Semaphores: A Definition ä½¿ç”¨ä¸€ä¸ªä¿¡å·é‡ä¹‹å‰æˆ‘ä»¬è¦å®šä¹‰å…¶åˆå§‹å€¼ï¼š\n#include \u0026lt;semaphore.h\u0026gt; sem_t s; sem_init(\u0026amp;s, 0, 1); sem_init() çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä¿¡å·é‡ï¼Œç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯åˆå§‹å€¼ï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸º 0 è¡¨ç¤ºè¯¥ä¿¡å·é‡åœ¨åŒè¿›ç¨‹ä¸‹çš„æ‰€æœ‰çº¿ç¨‹ä¹‹é—´å…±äº« (å¦‚æœæƒ³è®©ä¿¡å·é‡åœ¨ä¸åŒè¿›ç¨‹ä¹‹é—´å…±äº«ï¼Œå¯ä»¥è®¾ç½®ä¸ºå…¶ä»–æ•°å€¼)ã€‚\nPOSIX æ ‡å‡†æä¾›äº†ä¿¡å·é‡æ“ä½œç›¸å…³çš„ APIï¼šsem_wait() å’Œ sem_post()ã€‚ç›¸è¾ƒäºæ¡ä»¶å˜é‡ï¼Œä¿¡å·é‡ä½¿ç”¨èµ·æ¥éå¸¸ç®€å•ï¼šæˆ‘ä»¬ä¸éœ€è¦å…³æ³¨ä»€ä¹ˆæ—¶å€™è·å¾—é”ï¼Œç”¨ while è¿˜æ˜¯ if ç­‰é—®é¢˜ï¼Œåœ¨ç”¨æˆ·å±‚é¢æˆ‘ä»¬å¯ä»¥è®¤ä¸ºè¿™äº› API éƒ½æ˜¯åŸå­çš„ã€‚å®ƒä»¬çš„è¯­ä¹‰å¯ä»¥ç”¨å¦‚ä¸‹ä¼ªä»£ç æè¿°ï¼š","tags":null,"title":"Chapter 31: Semaphores","type":"docs"},{"authors":null,"categories":null,"content":"è¾“å…¥è¾“å‡ºå¯¹äºè®¡ç®—æœºæ¥è¯´éå¸¸é‡è¦ï¼šå¦‚æœæ²¡æœ‰è¾“å…¥ï¼Œè®¡ç®—æœºæ¯æ¬¡è¾“å‡ºçš„éƒ½æ˜¯ç›¸åŒçš„ç»“æœï¼›å¦‚æœæ²¡æœ‰è¾“å‡ºï¼Œé‚£æˆ‘ä»¬è®©è®¡ç®—æœºè¿è¡Œç¨‹åºçš„ç›®çš„æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿå› æ­¤æˆ‘ä»¬çš„é—®é¢˜æ˜¯å¦‚ä½•å°† Input/Output èå…¥è®¡ç®—æœºç³»ç»Ÿã€‚\n36.1 System Architecture ä¸€ä¸ªç»å…¸çš„è®¡ç®—æœºç³»ç»Ÿçš„ç»“æ„å¸ƒå±€å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š\nCPU å’Œå†…å­˜é€šè¿‡å†…å­˜æ€»çº¿è¿æ¥ã€‚æœ‰ä¸€äº›è®¾å¤‡é€šè¿‡é€šç”¨ I/O æ€»çº¿ (åœ¨ç°ä»£ç³»ç»Ÿä¸­é€šå¸¸æ˜¯ PCI æ€»çº¿) è¿å…¥ç³»ç»Ÿï¼Œè¿™ç±»è®¾å¤‡é€šå¸¸æ˜¯ä¸€äº›é«˜é€Ÿè®¾å¤‡ï¼Œæ¯”å¦‚æ˜¾å¡ã€‚å†å¾€ä¸‹ä¸€å±‚ï¼Œä¸€äº›æ¯”è¾ƒä½é€Ÿçš„è®¾å¤‡ä¼šé€šè¿‡å¤–å›´æ€»çº¿ (peripheral busï¼Œæ¯”å¦‚ SATA, USB ç­‰) è¿å…¥ç³»ç»Ÿï¼ŒåŒ…æ‹¬é¼ æ ‡ï¼Œé”®ç›˜ç­‰ã€‚\nä½¿ç”¨è¿™ç§ hierarchical ä¸»è¦æ˜¯å¤„äºæ€§ä»·æ¯”çš„è€ƒé‡ã€‚é€šå¸¸æ¥è¯´ä¸€æ¡æ€»çº¿é€Ÿåº¦è¶Šå¿«ï¼Œå®ƒçš„å•ä»·å°±è¶Šè´µï¼Œå®ƒçš„é•¿åº¦ä¹Ÿè¶ŠçŸ­ï¼Œä¸Šé¢å¯ä»¥æ’çš„è®¾å¤‡æ•°é‡å°±è¶Šå°‘ã€‚å› æ­¤ç³»ç»Ÿè®¾è®¡è€…é‡‡ç”¨è¿™ç§å±‚çº§ç»“æ„ï¼Œè®©é€Ÿåº¦æ›´å¿«çš„è®¾å¤‡æ›´é è¿‘ CPUï¼Œä¸‹æ–¹çš„ä½é€Ÿæ€»çº¿ä¸Šåˆ™å¯ä»¥æ’å¾ˆå¤šè®¾å¤‡ã€‚\nç°ä»£çš„ç³»ç»Ÿæ›´å¤šåœ°é‡‡ç”¨èŠ¯ç‰‡ç»„å’Œå¿«é€Ÿçš„ç‚¹å¯¹ç‚¹äº’è¿æ¥æå‡æ•ˆç‡ã€‚Intel Z270 èŠ¯ç‰‡ç»„çš„ç»“æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š\nåœ¨è¿™ç§ç»“æ„ä¸­ï¼ŒCPU å’Œå†…å­˜ä¹‹é—´çš„è¿æ¥å¾ˆè¿‘ï¼Œæ­¤å¤–æœ‰ä¸€æ¡é«˜é€Ÿçš„é€šé“ç›´æ¥è¿æ¥ CPU å’Œæ˜¾å¡ï¼Œä»è€Œä½¿ graphic-intensive çš„åº”ç”¨æœ‰æ›´æµç•…çš„ä½¿ç”¨ä½“éªŒã€‚CPU å’Œ I/O èŠ¯ç‰‡ä¹‹é—´é€šè¿‡ä¸€ä¸ªä¸“é—¨çš„ DMI (Direct Media Interface) è¿æ¥ï¼Œå‰©ä¸‹çš„è®¾å¤‡éƒ½é€šè¿‡ I/O èŠ¯ç‰‡ä¸ CPU äº¤äº’ã€‚I/O èŠ¯ç‰‡æä¾›äº†å¤šç§ç±»å‹çš„æ¥å£ï¼šå³ä¾§æœ‰å¾ˆå¤šçš„ç¡¬ç›˜é©±åŠ¨å™¨é€šè¿‡ eSATA æ¥å£ä¸ I/O èŠ¯ç‰‡è¿æ¥ã€‚ä¸‹æ–¹æœ‰å¾ˆå¤šçš„ USB æ¥å£ï¼Œé€šå¸¸ç”¨äºè¿æ¥é”®ç›˜ã€é¼ æ ‡ç­‰ä½é€Ÿè®¾å¤‡ã€‚å·¦ä¾§çš„ PCIe (Peripheral Component Interconnect Express) æ¥å£å¯ä»¥æ¥ä¸€äº›é«˜é€Ÿè®¾å¤‡ï¼Œæ¯”å¦‚é«˜é€Ÿç½‘å¡ç­‰ã€‚\n36.2 A Canonical Device ä¸€ä¸ªå…¸å‹çš„è®¾å¤‡é€šå¸¸ç”±ä¸¤ä¸ªéƒ¨åˆ†ç»„æˆï¼šç¬¬ä¸€ä¸ªéƒ¨åˆ†æ˜¯å®ƒæš´éœ²ç»™ç³»ç»Ÿçš„ç¡¬ä»¶æ¥å£ï¼Œç³»ç»Ÿå¯ä»¥æ ¹æ®è®¾å¤‡çš„åè®®ï¼Œé€šè¿‡è¿™äº›ç¡¬ä»¶æ¥å£æ¥æ“çºµè®¾å¤‡ã€‚ç¬¬äºŒéƒ¨åˆ†æ˜¯è®¾å¤‡çš„å†…éƒ¨ç»“æ„ï¼Œç”¨äºå®ç°è®¾å¤‡æä¾›ç»™ç³»ç»Ÿçš„æŠ½è±¡ã€‚ç®€å•çš„è®¾å¤‡å¯èƒ½åªæœ‰ä¸€ä¸ªæˆ–å‡ ä¸ªå¾ˆå°çš„èŠ¯ç‰‡ï¼Œä½†ä¹Ÿæœ‰æ¯”è¾ƒå¤æ‚çš„è®¾å¤‡ï¼Œé‡Œé¢ç”šè‡³ä¼šæœ‰ä¸€ä¸ªç®€å•çš„ CPUï¼Œæ¯”å¦‚ç°ä»£çš„ RAID æ§åˆ¶å™¨ä¸­åŒ…å«äº†å‡ åƒè¡Œå›ºä»¶ä»£ç ã€‚\n36.3 The Canonical Protocol ä¸€ä¸ªæŠ½è±¡çš„è®¾å¤‡å‘å¤–æš´éœ²çš„æ¥å£é€šå¸¸æœ‰ä»¥ä¸‹éƒ¨åˆ†ï¼š\nä¸€ä¸ªçŠ¶æ€å¯„å­˜å™¨ï¼Œæ“ä½œç³»ç»Ÿè¯»å–å®ƒçš„å€¼å¯ä»¥è·çŸ¥è®¾å¤‡çš„çŠ¶æ€ï¼› ä¸€ä¸ªæŒ‡ä»¤å¯„å­˜å™¨ï¼Œæ“ä½œç³»ç»Ÿå‘å®ƒå†™å…¥å‘½ä»¤å¯ä»¥æ§åˆ¶è®¾å¤‡çš„è¡Œä¸ºï¼› ä¸€ä¸ªæ•°æ®å¯„å­˜å™¨ï¼Œç”¨äºæ“ä½œç³»ç»Ÿå’Œè®¾å¤‡çš„æ•°æ®äº¤æ¢ã€‚ ä¸€ä¸ªå…¸å‹çš„ OS å’Œè®¾å¤‡äº¤äº’çš„åè®®å¦‚ä¸‹ï¼š\nwhile (STATUS == BUSY) ; Write data to DATA register; Write command to COMMAND register; (Doing so starts the device and executes the command) while (STATUS == busy) ; // wait until device is done with your request æ•´ä¸ªè¿‡ç¨‹åˆ†ä¸ºå››æ­¥ï¼š\né¦–å…ˆ OS ç­‰å¾…ç›´åˆ°è®¾å¤‡çš„çŠ¶æ€å¯„å­˜å™¨è¡¨ç¤ºè®¾å¤‡å·²ç»å‡†å¤‡å°±ç»ªï¼Œè¿™ä¸ªè¿‡ç¨‹ç§°ä¸º OS è½®è¯¢ (polling) è®¾å¤‡ã€‚ OS å°†æ•°æ®é€šè¿‡æ•°æ®å¯„å­˜å™¨ä¼ é€ç»™è®¾å¤‡ï¼Œå¦‚æœè¿™ä¸ªæ•°æ®è¿ç§»çš„è¿‡ç¨‹æ˜¯ç”±ä¸» CPU å®Œæˆçš„ï¼Œæˆ‘ä»¬ç§°è¿™ç§æ–¹å¼ä¸º programmed I/O (PIO)ã€‚ OS å‘æŒ‡ä»¤å¯„å­˜å™¨å†™å…¥å‘½ä»¤ï¼Œè¿™æ ·ç›¸å½“äºéšå¼åœ°å‘Šè¯‰è®¾å¤‡æ•°æ®ä¹Ÿå·²ç»ä¼ é€å®Œæˆï¼Œäºæ˜¯è®¾å¤‡ä¼šå¼€å§‹å·¥ä½œæ‰§è¡Œè¿™æ¡å‘½ä»¤ã€‚ OS å†æ¬¡é€šè¿‡è½®è¯¢çš„æ–¹å¼ç­‰å¾…è®¾å¤‡å·¥ä½œå®Œæˆã€‚ è¯¥åè®®çš„æœ€å¤§ä¼˜ç‚¹æ˜¯ç®€å•ï¼Œä½†å®ƒçš„æ•ˆç‡æ¯”è¾ƒä½ã€‚ä¸€ä¸ªæ¯”è¾ƒæ˜æ˜¾çš„ç¼ºç‚¹æ˜¯ CPU è½®è¯¢è®¾å¤‡çŠ¶æ€ä¼šæµªè´¹å¤§é‡çš„æ—¶é—´ã€‚\n36.4 Lowering CPU Overhead With Interrupts è§£å†³è½®è¯¢æµªè´¹æ—¶é—´é—®é¢˜çš„ä¸€ä¸ªæ–¹æ³•æ˜¯ä½¿ç”¨ä¸­æ–­ã€‚å½“ OS å‘ç°å½“å‰è®¾å¤‡æ­£å¿™æ—¶ï¼Œå®ƒå¯ä»¥å°†å½“å‰è¿›ç¨‹ç¡çœ ã€‚å½“è®¾å¤‡å‡†å¤‡å°±ç»ªæ—¶ï¼Œè®¾å¤‡å¯ä»¥ç”Ÿæˆä¸€ä¸ªç¡¬ä»¶ä¸­æ–­å‘é€ç»™æ“ä½œç³»ç»Ÿï¼ŒOS ä¸­çš„ä¸­æ–­å¤„ç†ç¨‹åºä¼šæ ¹æ®æƒ…å†µè¿›è¡Œè¿›ç¨‹åˆ‡æ¢ã€‚\nä¸­æ–­ I/O çš„æ–¹å¼å¯ä»¥åœ¨è®¾å¤‡å·¥ä½œæ—¶è®© OS åšåˆ«çš„äº‹æƒ…ï¼Œä»è€Œè¾¾åˆ°æ›´å¥½çš„å¹¶è¡Œåº¦ã€‚ä½†ä¸­æ–­å¹¶ä¸æ˜¯åœ¨ä»»ä½•æƒ…å†µä¸‹éƒ½æ¯”è½®è¯¢æ¥å¾—å¥½ã€‚ä¸­æ–­æœ¬èº«æ˜¯æœ‰ä¸€å®šçš„ä»£ä»·çš„ (æ¯”å¦‚å¤„ç†ä¸­æ–­ï¼Œä¸Šä¸‹æ–‡åˆ‡æ¢ç­‰)ï¼Œå› æ­¤å¯¹äºä¸€äº›å·¥ä½œçš„å¾ˆå¿«çš„é«˜é€Ÿè®¾å¤‡ï¼Œä½¿ç”¨è½®è¯¢åè€Œå¯ä»¥è·å¾—æ›´å¥½çš„æ•ˆç‡ã€‚å¯¹äºä¸€äº›å·¥ä½œå¾—æ—¶å¿«æ—¶æ…¢çš„è®¾å¤‡ï¼ŒOS å¯ä»¥é‡‡å–ç»¼åˆçš„æ–¹å¼ï¼šå…ˆè½®è¯¢ä¸€å°æ®µæ—¶é—´ï¼Œå¦‚æœè®¾å¤‡æ²¡æœ‰å‡†å¤‡å°±ç»ªï¼Œåˆ™èµ°ä¸­æ–­æµç¨‹ã€‚è¿™ç§ä¸¤é˜¶æ®µçš„æ–¹æ³•å¯¹äºå¿«æ…¢ä¸¤ç§æƒ…å†µéƒ½å¯ä»¥æœ‰ä¸é”™çš„æ•ˆæœã€‚\nå¦ä¸€ä¸ªä¸èƒ½æ»¥ç”¨ä¸­æ–­çš„åŸå› åœ¨ç½‘ç»œé¢†åŸŸã€‚å¦‚æœæœ‰å¤§é‡åˆ°æ¥çš„ç½‘ç»œæ•°æ®åŒ…ï¼Œæ¯ä¸ªéƒ½ä¼šç”Ÿæˆä¸­æ–­ï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„æœåŠ¡å™¨å°±ä¼šé™·å…¥ä¸€ä¸ª livelock çš„çŠ¶æ€ï¼šOS ä¸€ç›´åœ¨ä¸­æ–­å¤„ç†ç¨‹åºä¸­å¤„ç†ä¸­æ–­ï¼Œå¾ˆé•¿æ—¶é—´å†…éƒ½æ²¡æœ‰ç”¨æˆ·å°è¿›ç¨‹æœ‰è¿›å±•ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ—¶ä¸æ—¶åœ°ä½¿ç”¨ä¸€äº›è½®è¯¢å¯ä»¥æ›´å¥½åœ°æ§åˆ¶å½“å‰ç³»ç»Ÿä¸­æ­£åœ¨å‘ç”Ÿçš„äº‹æƒ…ï¼šå³ä½¿æœ‰å¤§é‡çš„æ•°æ®åŒ…åˆ°æ¥ï¼ŒæœåŠ¡å™¨ä¹Ÿå¯ä»¥é€‰æ‹©å¤„ç†ä¸€éƒ¨åˆ† requestï¼Œç„¶åå†å»å“åº”æ•°æ®åŒ…ã€‚\nå¦ä¸€ç§åŸºäºä¸­æ–­çš„ä¼˜åŒ–å«åš coalescing (åˆå¹¶)ã€‚å½“è®¾å¤‡éœ€è¦å‘å‡ºä¸­æ–­æ—¶ï¼Œå®ƒå…ˆä¸æ€¥ç€å‘é€è€Œæ˜¯ç­‰ä¸€å°ä¼šå„¿ï¼Œè¿™æ®µæ—¶é—´å¯èƒ½åˆæœ‰åˆ«çš„äº‹ä»¶å‘ç”Ÿ (æ¯”å¦‚ä¸€ä¸ªå…¶ä»–ä»»åŠ¡å®Œæˆäº†)ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥æŠŠå¤šä¸ªäº‹ä»¶æ”¾åœ¨ä¸€ä¸ªä¸­æ–­é‡Œå‘é€ï¼Œæé«˜äº†æ•ˆç‡ã€‚ä½†ç­‰å¾…çš„äº‹ä»¶å¦‚æœè¿‡é•¿ä¸­æ–­çš„æ—¶æ•ˆæ€§å°±é™ä½äº†ï¼Œå› æ­¤è¿™å…¶ä¸­ä¹Ÿæœ‰ trade-offã€‚\n36.5 More Efficient Data Movement With DMA Canonical Protocol çš„å¦ä¸€ä¸ªé—®é¢˜åœ¨äºï¼šå½“æˆ‘ä»¬ä½¿ç”¨ programmed I/O çš„æ–¹å¼æ¥æ¬è¿å¤§é‡æ•°æ®æ—¶ï¼Œå¤§é‡çš„ CPU æ—¶é—´è¢«æµªè´¹åœ¨äº†è¿™ç§éå¸¸é‡å¤å’Œç®€å•çš„äº‹æƒ…ä¸Šã€‚æˆ‘ä»¬å¸Œæœ›æŠŠè¿™éƒ¨åˆ† CPU æ—¶é—´èŠ‚çœä¸‹æ¥ç”¨æ¥å¤„ç†è¿›ç¨‹ç›¸å…³çš„äº‹ä»¶ã€‚\nè¿™ä¸ªé—®é¢˜çš„å¤„ç†æ–¹æ³•ç§°ä¸º Direct Memory Access (DMA)ã€‚DMA å¯ä»¥ç†è§£ä¸ºä¸€ä¸ªä¸“é—¨ç”¨æ¥æ¬è¿æ•°æ®çš„è®¾å¤‡ã€‚å½“ OS éœ€è¦æ¬è¿æ•°æ®çš„æ—¶å€™ï¼Œå®ƒä¼šå‘é€ä¿¡å·ç»™ DMAï¼Œå‘Šè¯‰å®ƒæ•°æ®åœ¨å†…å­˜ä¸­çš„åœ°å€ï¼Œæ•°æ®çš„é•¿åº¦ï¼Œä»¥åŠç›®æ ‡è®¾å¤‡ï¼Œç„¶å DMA ä¾¿ä¼šå¸® CPU æ¬æ•°æ®ï¼Œä¸æ­¤åŒæ—¶ CPU å°±å¯ä»¥å¹¶è¡Œåœ°åšå…¶ä»–äº‹æƒ…ã€‚\n36.6 Methods Of Device Interaction OS å’Œè®¾å¤‡åˆ°åº•æ˜¯å¦‚ä½•äº¤äº’çš„ï¼Ÿå†å²ä¸Šä¸»è¦æœ‰ä¸¤ç§æ–¹æ³•ã€‚ç¬¬ä¸€ç§æ˜¯åœ¨ ISA ä¸­ä¸“é—¨è®¾è®¡ä¸€ç»„æ˜¾å¼çš„ I/O äº¤äº’æŒ‡ä»¤ (in/out)ã€‚è¯¥æŒ‡ä»¤å¯ä»¥è®© OS æŒ‡å®šå°†ä»€ä¹ˆæ•°æ®å‘é€åˆ°å“ªä¸ªè®¾å¤‡çš„å“ªä¸ªå¯„å­˜å™¨ã€‚è¿™æ ·çš„æŒ‡ä»¤ä¸€èˆ¬éƒ½æ˜¯ç‰¹æƒæŒ‡ä»¤ï¼Œå³åªæœ‰æ“ä½œç³»ç»Ÿå†…æ ¸å¯ä»¥æ‰§è¡Œè¿™æ ·çš„æ“ä½œï¼Œå¦åˆ™ç”¨æˆ·æ€çš„æ¶æ„ç¨‹åºå¾ˆå®¹æ˜“æ‰°ä¹±æœºå™¨çŠ¶æ€ã€‚ç¬¬äºŒç§æ–¹æ³•æ˜¯ä½¿ç”¨æ‰€è°“çš„å†…å­˜æ˜ å°„ I/O (memory-mapped I/O)ã€‚è¿™ç§æ–¹å¼ä¸‹è®¾å¤‡å¯„å­˜å™¨è¢«ç»‘å®šåˆ°ç‰¹å®šçš„å†…å­˜å•å…ƒï¼Œæ“ä½œç³»ç»Ÿå¯ä»¥ä½¿ç”¨æ™®é€šçš„è®¿å­˜æŒ‡ä»¤ (load/store) é€šè¿‡ç‰¹å®šçš„åœ°å€æ¥è®¿é—®è®¾å¤‡ï¼Œç¡¬ä»¶ (MMU) ä¼šå°†è¯¥è®¿é—®è·¯ç”±åˆ°æ­£ç¡®çš„è®¾å¤‡ä¸Šã€‚\nè¿™ä¸¤ç§æ–¹æ³•æ²¡æœ‰æ˜æ˜¾çš„ä¼˜åŠ£ï¼Œè™½ç„¶å†…å­˜æ˜ å°„ I/O å› ä¸ºæ²¡æœ‰å¼•å…¥æ–°çš„æŒ‡ä»¤çœ‹ä¸Šå»æ›´ç®€æ´ï¼Œä½†ä¸¤ç§æ–¹æ³•äº‹å®ä¸Šç°åœ¨éƒ½æœ‰åœ¨ä½¿ç”¨ã€‚\n36.7 Fitting Into The OS: The Device Driver è¿™ä¸ªç« èŠ‚æˆ‘ä»¬å…³æ³¨çš„é—®é¢˜æ˜¯ï¼šä¸åŒçš„è®¾å¤‡æœ‰å„å¼‚çš„æ¥å£ï¼Œæˆ‘ä»¬å¦‚ä½•è®© OS å¯ä»¥ä»¥ä¸€ä¸ªæ¯”è¾ƒç»Ÿä¸€çš„æ–¹å¼æ¥è®¿é—®è®¾å¤‡å‘¢ï¼Ÿæ¯”å¦‚ï¼Œæ–‡ä»¶ç³»ç»Ÿå¯èƒ½å»ºç«‹åœ¨ SCSI ç£ç›˜ã€IDE ç£ç›˜ã€USB è®¾å¤‡ä¸Šç­‰ç­‰ï¼Œæˆ‘ä»¬å¸Œæœ›æœ‰ä¸€ä¸ªä¸œè¥¿èƒ½å¸®æˆ‘ä»¬æŠ½è±¡æ‰è¿™äº›è®¾å¤‡åº•å±‚çš„ç»†èŠ‚å·®å¼‚ï¼Œæä¾›ç»Ÿä¸€çš„æ¥å£ (æ¯”å¦‚ read/write)ï¼Œè®©æ–‡ä»¶ç³»ç»Ÿå¯ä»¥ä»¥ä¸€ä¸ªç»Ÿä¸€çš„æ–¹å¼è¯»å†™æ•°æ®ã€‚\nè®¾å¤‡é©±åŠ¨å°±æ˜¯å¸®åŠ©æˆ‘ä»¬æŠ½è±¡æ‰è®¾å¤‡çš„åº•å±‚ç»†èŠ‚ï¼Œå‘ä¸Šæä¾›ç»Ÿä¸€æ¥å£çš„ç³»ç»Ÿè½¯ä»¶ã€‚å½“ç„¶ï¼Œç›²ç›®çš„æŠ½è±¡ä¹Ÿæœ‰å…¶å¼Šç«¯ï¼šå¦‚æœä¸€ä¸ªè®¾å¤‡æœ‰ä¸°å¯Œçš„åŠŸèƒ½ï¼Œé‚£ä¹ˆä¸ºäº†ä½¿å…¶é€‚é…ç®€å•ç»Ÿä¸€çš„æ¥å£ï¼Œè®¾å¤‡é©±åŠ¨å¯èƒ½å°±ä¸å¾—ä¸ä¸¢å¼ƒä¸€äº›ä¿¡æ¯ã€‚æ¯”å¦‚ SCSI ç£ç›˜æœ‰ä¸°å¯Œçš„æŠ¥é”™ä¿¡æ¯ï¼Œä½†ç”±äºå…¶ä»–çš„å—è®¾å¤‡çš„ error handling éƒ½éå¸¸ç®€å•ï¼Œæ‰€ä»¥ä¸Šå±‚è½¯ä»¶ä¸€èˆ¬éƒ½åªæ¥å—ä¸€ä¸ª error codeï¼Œè¿™å¯¼è‡´ SCSI æä¾›çš„ä¿¡æ¯æ— æ³•è¿›å…¥åˆ°æ–‡ä»¶ç³»ç»Ÿã€‚\nè®¾å¤‡é©±åŠ¨ä»£ç å æ®äº†æ“ä½œç³»ç»Ÿå†…æ ¸ä»£ç çš„ä¸€å¤§éƒ¨åˆ†ï¼Œä¹Ÿæ˜¯æ“ä½œç³»ç»Ÿå†…æ ¸ bug çš„é‡ç¾åŒºã€‚\n36.8 Case Study: A Simple IDE Disk Driver è¿™ä¸€ç« èŠ‚ä¸»è¦å…³æ³¨ä¸€ä¸ªå®é™…çš„ä¾‹å­ï¼šIDE ç£ç›˜çš„é©±åŠ¨ç¨‹åºã€‚IDE ç£ç›˜æä¾›çš„åè®®å¦‚ä¸‹ï¼š\nä¸‹é¢æ˜¯ Xv6 ä¸­å…³äº IDE ç£ç›˜é©±åŠ¨çš„ä»£ç ï¼š\nstatic int ide_wait_ready() { while ((int r = inb(0x1f7)) \u0026amp; IDE_BSY || !(r \u0026amp; IDE_READY)) ; // è½®è¯¢è®¾å¤‡çš„å½“å‰çŠ¶æ€ï¼Œç›´åˆ°è®¾å¤‡å‡†å¤‡å°±ç»ª } static void ide_start_request(struct buf *b) { ide_wait_ready(); outb(0x3f6, 0); // ç”Ÿæˆä¸­æ–­ä¿¡å· outb(0x1f2, 1); // è¦è¯»/å†™çš„sectorçš„ä¸ªæ•° outb(0x1f3, b-\u0026gt;sector \u0026amp; 0xff); // ç›®æ ‡sectorçš„LBA outb(0x1f4, (b-\u0026gt;sector \u0026gt;\u0026gt; 8) \u0026amp; 0xff); outb(0x1f5, (b-\u0026gt;sector \u0026gt;\u0026gt; 16) \u0026amp; 0xff); outb(0x1f6, 0xe0 | ((b-\u0026gt;dev\u0026amp;1)\u0026lt;\u0026lt;4) | ((b-\u0026gt;sector\u0026gt;\u0026gt;24)\u0026amp;0xff)); if (b-\u0026gt;flags \u0026amp; B_DIRTY) { // bufçš„B_DIRTYä½ä¸º1è¯´æ˜è¿™æ˜¯ä¸€æ¬¡å†™å…¥æ“ä½œ outb(0x1f7, IDE_CMD_WRITE); // å‘0x1f7ä¼ å…¥å†™çš„command outsl(0x1f0, b-\u0026gt;data, 512/4); // ä¼ è¾“è¦å†™å…¥çš„æ•°æ® } else { outb(0x1f7, IDE_CMD_READ); // å‘0x1f7ä¼ å…¥è¯»çš„command } } void ide_rw(struct buf *b) { acquire(\u0026amp;ide_lock); for (struct buf **pp = \u0026amp;ide_queue; *pp; pp = \u0026amp;(*pp)-\u0026gt;qnext) ; *pp = b; // å°†ä»»åŠ¡æ”¾åˆ°é˜Ÿåˆ—æœ«å°¾ if (ide_queue == b) ide_start_request(b); // å¦‚æœè¯¥ä»»åŠ¡æ˜¯å½“å‰çš„å”¯ä¸€ä»»åŠ¡ï¼Œç«‹åˆ»å¼€å§‹åš while ((b-\u0026gt;flags \u0026amp; (B_VALID|B_DIRTY)) != B_VALID) sleep(b, \u0026amp;ide_lock); // ç­‰å¾…ä»»åŠ¡å®Œæˆæ—¶ä¸­æ–­å¤„ç†ç¨‹åºå”¤é†’è¯¥è¿›ç¨‹ release(\u0026amp;ide_lock); } void ide_intr() { struct buf *b; acquire(\u0026amp;ide_lock); if (!(b-\u0026gt;flags \u0026amp; B_DIRTY) \u0026amp;\u0026amp; ide_wait_ready() \u0026gt;= 0) insl(0x1f0, b-\u0026gt;data, 512/4); // å¦‚æœæ˜¯è¯»å–ä»»åŠ¡çš„æ•°æ®å‡†å¤‡å¥½ï¼Œåˆ™å°†æ•°æ®è¯»è¿›æ¥ b-\u0026gt;flags |= B_VALID; b-\u0026gt;flags \u0026amp;= B_DIRTY; wakeup(b); // å”¤é†’å¯¹åº”è¿›ç¨‹ï¼Œé€šçŸ¥å®ƒä»»åŠ¡å·²å®Œæˆ if ((ide_queue = b-\u0026gt;qnext) != 0) ide_start_request(ide_queue); // å½“å‰ä»»åŠ¡åšå®Œï¼Œç»§ç»­åšä¸‹ä¸€ä¸ªä»»åŠ¡ release(\u0026amp;ide_lock); } 36.9 Historical Notes è®¡ç®—æœºç³»ç»Ÿçš„è¿›æ­¥ä¸­æ²¡æœ‰ revolutionï¼Œåªæœ‰ evolutionã€‚ä¸­æ–­ã€DMA ç­‰æƒ³æ³•éƒ½æ˜¯ä¸ºäº†æé«˜ç³»ç»Ÿæ€§èƒ½å¯ä»¥è‡ªç„¶è€Œç„¶æƒ³åˆ°çš„ã€‚\n36.10 Summary ç•¥ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"6cdfc3899408e9b66a0de197b8f91e4d","permalink":"https://kristoff-starling.github.io/notes/booknotes/ostep/ch36/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/booknotes/ostep/ch36/","section":"notes","summary":"è¾“å…¥è¾“å‡ºå¯¹äºè®¡ç®—æœºæ¥è¯´éå¸¸é‡è¦ï¼šå¦‚æœæ²¡æœ‰è¾“å…¥ï¼Œè®¡ç®—æœºæ¯æ¬¡è¾“å‡ºçš„éƒ½æ˜¯ç›¸åŒçš„ç»“æœï¼›å¦‚æœæ²¡æœ‰è¾“å‡ºï¼Œé‚£æˆ‘ä»¬è®©è®¡ç®—æœºè¿è¡Œç¨‹åºçš„ç›®çš„æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿå› æ­¤æˆ‘ä»¬çš„é—®é¢˜æ˜¯å¦‚ä½•å°† Input/Output èå…¥è®¡ç®—æœºç³»ç»Ÿã€‚\n36.1 System Architecture ä¸€ä¸ªç»å…¸çš„è®¡ç®—æœºç³»ç»Ÿçš„ç»“æ„å¸ƒå±€å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š\nCPU å’Œå†…å­˜é€šè¿‡å†…å­˜æ€»çº¿è¿æ¥ã€‚æœ‰ä¸€äº›è®¾å¤‡é€šè¿‡é€šç”¨ I/O æ€»çº¿ (åœ¨ç°ä»£ç³»ç»Ÿä¸­é€šå¸¸æ˜¯ PCI æ€»çº¿) è¿å…¥ç³»ç»Ÿï¼Œè¿™ç±»è®¾å¤‡é€šå¸¸æ˜¯ä¸€äº›é«˜é€Ÿè®¾å¤‡ï¼Œæ¯”å¦‚æ˜¾å¡ã€‚å†å¾€ä¸‹ä¸€å±‚ï¼Œä¸€äº›æ¯”è¾ƒä½é€Ÿçš„è®¾å¤‡ä¼šé€šè¿‡å¤–å›´æ€»çº¿ (peripheral busï¼Œæ¯”å¦‚ SATA, USB ç­‰) è¿å…¥ç³»ç»Ÿï¼ŒåŒ…æ‹¬é¼ æ ‡ï¼Œé”®ç›˜ç­‰ã€‚\nä½¿ç”¨è¿™ç§ hierarchical ä¸»è¦æ˜¯å¤„äºæ€§ä»·æ¯”çš„è€ƒé‡ã€‚é€šå¸¸æ¥è¯´ä¸€æ¡æ€»çº¿é€Ÿåº¦è¶Šå¿«ï¼Œå®ƒçš„å•ä»·å°±è¶Šè´µï¼Œå®ƒçš„é•¿åº¦ä¹Ÿè¶ŠçŸ­ï¼Œä¸Šé¢å¯ä»¥æ’çš„è®¾å¤‡æ•°é‡å°±è¶Šå°‘ã€‚å› æ­¤ç³»ç»Ÿè®¾è®¡è€…é‡‡ç”¨è¿™ç§å±‚çº§ç»“æ„ï¼Œè®©é€Ÿåº¦æ›´å¿«çš„è®¾å¤‡æ›´é è¿‘ CPUï¼Œä¸‹æ–¹çš„ä½é€Ÿæ€»çº¿ä¸Šåˆ™å¯ä»¥æ’å¾ˆå¤šè®¾å¤‡ã€‚\nç°ä»£çš„ç³»ç»Ÿæ›´å¤šåœ°é‡‡ç”¨èŠ¯ç‰‡ç»„å’Œå¿«é€Ÿçš„ç‚¹å¯¹ç‚¹äº’è¿æ¥æå‡æ•ˆç‡ã€‚Intel Z270 èŠ¯ç‰‡ç»„çš„ç»“æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š\nåœ¨è¿™ç§ç»“æ„ä¸­ï¼ŒCPU å’Œå†…å­˜ä¹‹é—´çš„è¿æ¥å¾ˆè¿‘ï¼Œæ­¤å¤–æœ‰ä¸€æ¡é«˜é€Ÿçš„é€šé“ç›´æ¥è¿æ¥ CPU å’Œæ˜¾å¡ï¼Œä»è€Œä½¿ graphic-intensive çš„åº”ç”¨æœ‰æ›´æµç•…çš„ä½¿ç”¨ä½“éªŒã€‚CPU å’Œ I/O èŠ¯ç‰‡ä¹‹é—´é€šè¿‡ä¸€ä¸ªä¸“é—¨çš„ DMI (Direct Media Interface) è¿æ¥ï¼Œå‰©ä¸‹çš„è®¾å¤‡éƒ½é€šè¿‡ I/O èŠ¯ç‰‡ä¸ CPU äº¤äº’ã€‚I/O èŠ¯ç‰‡æä¾›äº†å¤šç§ç±»å‹çš„æ¥å£ï¼šå³ä¾§æœ‰å¾ˆå¤šçš„ç¡¬ç›˜é©±åŠ¨å™¨é€šè¿‡ eSATA æ¥å£ä¸ I/O èŠ¯ç‰‡è¿æ¥ã€‚ä¸‹æ–¹æœ‰å¾ˆå¤šçš„ USB æ¥å£ï¼Œé€šå¸¸ç”¨äºè¿æ¥é”®ç›˜ã€é¼ æ ‡ç­‰ä½é€Ÿè®¾å¤‡ã€‚å·¦ä¾§çš„ PCIe (Peripheral Component Interconnect Express) æ¥å£å¯ä»¥æ¥ä¸€äº›é«˜é€Ÿè®¾å¤‡ï¼Œæ¯”å¦‚é«˜é€Ÿç½‘å¡ç­‰ã€‚","tags":null,"title":"Chapter 36: I/O Devices","type":"docs"},{"authors":null,"categories":null,"content":"æˆ‘ä»¬å¯¹ç£ç›˜æœ‰ä¸‰ä¸ªç»´åº¦çš„éœ€æ±‚ï¼šæˆ‘ä»¬å¸Œæœ›å®ƒè¯»å†™é€Ÿåº¦å¿« (I/O æ“ä½œé€Ÿåº¦æ…¢ï¼Œå› è€Œæˆä¸ºæ•´ä¸ªç³»ç»Ÿçš„é€Ÿåº¦ç“¶é¢ˆ)ï¼Œæˆ‘ä»¬å¸Œæœ›å®ƒå®¹é‡å¤§ï¼Œæˆ‘ä»¬è¿˜å¸Œæœ›å®ƒå¯é  (å¦‚æœå‘ç”Ÿç£ç›˜æŸåï¼Œä»ç„¶èƒ½æ¢å¤æ•°æ®)ã€‚\næœ¬ç« èŠ‚ä¸»è¦ä»‹ç» Redundant Arrays of Inexpensive Disks (RAIDs) æŠ€æœ¯ï¼Œå®ƒçš„æ ¸å¿ƒæ€æƒ³æ˜¯ç”¨å¤šå—ç‰©ç†ç£ç›˜å»æ„å»ºä¸€ä¸ªå¤§å®¹é‡çš„ï¼Œé«˜é€Ÿçš„ï¼Œå¯é æ€§é«˜çš„ç£ç›˜ã€‚å¯¹å¤–æ¥çœ‹ï¼ŒRAID è™šæ‹Ÿå‡ºäº†ä¸€å—å¯è¯»å¯å†™çš„ç£ç›˜ï¼›åœ¨å…¶å†…éƒ¨ï¼ŒRAID ç”±ä¸€ä¸ªéå¸¸å¤æ‚çš„ç³»ç»Ÿæ„æˆï¼ŒåŒ…å«äº†è‹¥å¹²ä¸ªç‰©ç†ç£ç›˜å’Œä¸€ä¸ªæˆ–å¤šä¸ªç”¨äºæ§åˆ¶çš„èŠ¯ç‰‡ï¼Œå¯ä»¥è¯´ RAID å†…éƒ¨å°±æ˜¯ä¸€ä¸ªå°å‹çš„è®¡ç®—æœºç³»ç»Ÿã€‚\nRAID çš„ä¼˜ç‚¹åœ¨äºï¼šå®ƒå¯ä»¥é€šè¿‡å¤šå—ç£ç›˜å¹¶è¡Œçš„è¯»å†™æ¥æä¾›å¾ˆå¥½çš„ performanceï¼›é€šè¿‡å åŠ ç£ç›˜çš„æ•°é‡æ¥è·å¾— capacityï¼›é€šè¿‡å­˜å‚¨ä¸€éƒ¨åˆ†çš„å†—ä½™æ•°æ®æ¥ä¿è¯æ•°æ®çš„ reliabilityã€‚æ›´é‡è¦çš„æ˜¯ï¼ŒRAID å¯ä»¥é€æ˜åœ°æä¾›è¿™äº›ä¼˜åŠ¿ï¼Œè¿™é‡Œé€æ˜çš„æ„æ€æ˜¯å¯¹äºå…¶ä»–ç¡¬ä»¶/OSæ¥è¯´ï¼ŒRAID çœ‹ä¸Šå»å°±åƒæ˜¯ä¸€æ•´å—æ™®é€šçš„ç£ç›˜ã€‚æ•´ä¸ªç³»ç»Ÿçš„å…¶ä»–éƒ¨åˆ†ä¸éœ€è¦åšä»»ä½•ä¿®æ”¹å°±å¯ä»¥å…¼å®¹ RAIDã€‚è¿™ä¸€ç‚¹æå¤§åœ°æå‡äº† RAID çš„å¯éƒ¨ç½²æ€§ (deployability)ã€‚ç”¨æˆ·å¯ä»¥æ”¾å¿ƒåœ°å°†è‡ªå·±ç°æœ‰çš„ç£ç›˜æ›´æ¢æˆ RAIDï¼Œä¸éœ€è¦æ‹…å¿ƒå…¼å®¹é—®é¢˜ã€‚\n38.1 Interface And RAID Internals å¯¹äºä¸Šå±‚çš„æ–‡ä»¶ç³»ç»Ÿæ¥è¯´ï¼ŒRAID deng |çœ‹ä¸Šå»å°±åƒä¸€ä¸ªç£ç›˜ã€‚å’Œå…¶ä»–å•å—ç£ç›˜çš„æŠ½è±¡ä¸€æ ·ï¼ŒRAID å¯¹å¤–æš´éœ²æˆä¸€ä¸ªçº¿æ€§çš„ block arrayï¼Œæ¯ä¸ªå—éƒ½å¯è¯»å¯å†™ã€‚\nå½“æ–‡ä»¶ç³»ç»Ÿå‘ RAID å‘é€ä¸€ä¸ª logical I/O è¯·æ±‚æ—¶ï¼ŒRAID å†…éƒ¨éœ€è¦ææ¸…æ¥šè¿™ä¸ªé€»è¾‘åœ°å€å¯¹åº”çš„å—ç©¶ç«Ÿåœ¨å“ªäº›ç›˜çš„ä»€ä¹ˆä½ç½®ï¼Œå¹¶é€šè¿‡ä¸€æ¬¡æˆ–å¤šæ¬¡ physical I/O è¯·æ±‚æ¥å®Œæˆè¿™æ¬¡ä»»åŠ¡ã€‚RAID çš„å†…éƒ¨ç»“æ„ç›¸å½“å¤æ‚ï¼Œé€šå¸¸ä¼šæœ‰ä¸€ä¸ª microcontroller æ‰§è¡Œå›ºä»¶ä»£ç æ¥æ§åˆ¶ RAID çš„è¡Œä¸ºï¼›ä¼šæœ‰ DRAM æ¥ä½œä¸ºæ•°æ®å—çš„ buffer cacheï¼›æœ‰æ—¶è¿˜ä¼šæœ‰ä¸€äº›éæ˜“å¤±æ€§çš„å­˜å‚¨ç”¨æ¥è¿›è¡Œæ ¡éªŒè®¡ç®—ç­‰ã€‚RAID æœ‰ä¸€ä¸ªå®Œæ•´è®¡ç®—æœºç³»ç»Ÿçš„å¤§éƒ¨åˆ†è®¾æ–½ (å¤„ç†å™¨ï¼Œå†…å­˜ï¼Œç£ç›˜ç­‰ç­‰)ï¼Œä½†å®ƒæ˜¯ä¸€ä¸ªä¸“é—¨è¿è¡Œç£ç›˜ç®¡ç†ç¨‹åºçš„ä¸“ç”¨ç³»ç»Ÿã€‚\n38.2 Fault Model æˆ‘ä»¬åœ¨è¿™é‡Œè€ƒè™‘çš„é”™è¯¯æ¨¡å‹æ˜¯ä¸€ä¸ªæ¯”è¾ƒç®€å•çš„é”™è¯¯æ¨¡å‹ï¼Œç§°ä¸º fail-stopã€‚åœ¨è¿™ä¸ªæ¨¡å‹ä¸­ï¼Œæ¯å—ç£ç›˜åªä¼šå¤„äº working æˆ– failed çš„çŠ¶æ€ã€‚åœ¨ working çŠ¶æ€ï¼Œç£ç›˜ä¸€åˆ‡æ­£å¸¸ï¼Œå¯è¯»å¯å†™ï¼›åœ¨ failed çŠ¶æ€ï¼Œç£ç›˜æŸåï¼Œå¯ä»¥ç†è§£ä¸ºè¯¥ç£ç›˜å†…éƒ¨çš„æ•°æ®æ°¸ä¹…ä¸¢å¤±ã€‚\nåœ¨ fail-stop æ¨¡å‹ä¸­ï¼Œæˆ‘ä»¬è®¤ä¸ºæˆ‘ä»¬æ€»æ˜¯å¯ä»¥ç«‹åˆ»æ£€æµ‹åˆ°ç£ç›˜çš„æŸåï¼Œå³å½“æŸå—ç£ç›˜ä» working å˜ä¸º failed æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥è¿…é€Ÿå‘ç°ã€‚å› æ­¤æˆ‘ä»¬ä¸ç”¨è€ƒè™‘ä¸€äº›éå¸¸å¾®å¦™çš„ silent failure (è™½ç„¶è¿™æ˜¯å®é™…ä¸­æ›´å¯èƒ½å‘ç”Ÿçš„é”™è¯¯)ã€‚\n38.3 How To Evaluate A RAID æˆ‘ä»¬ä¸»è¦ä»ä¸‰ä¸ªå°ºåº¦æ¥è¡¡é‡ RAIDï¼š\nå®¹é‡ (capacity)ï¼šå‡è®¾ RAID ä¸­æœ‰ $N$ å—ç£ç›˜ï¼Œæ¯å—ç£ç›˜ä¸­æœ‰ $B$ ä¸ª blockï¼Œé‚£ä¹ˆç†è®ºä¸Šçš„æœ€å¤§å­˜å‚¨é‡æ˜¯ $N\\cdot B$ ä¸ª blockï¼Œä½†ç”±äºæˆ‘ä»¬éœ€è¦å­˜å‚¨ä¸€äº›å¿…è¦çš„å†—ä½™æ•°æ®æ¥ä¿è¯å¯é æ€§ï¼Œå®é™…ä¸Šçš„å®¹é‡è¾¾ä¸åˆ°è¿™ä¸ªæœ€å¤§å€¼ã€‚ å¯é æ€§ (reliability)ï¼šæˆ‘ä»¬çš„ RAID ç³»ç»Ÿè‡³å¤šå¯ä»¥å®¹å¿å¤šå°‘ä¸ªç£ç›˜åŒæ—¶æŸåï¼Ÿ(å®¹å¿æŒ‡æŸååå¯ä»¥æ¢å¤æ•°æ®) æ€§èƒ½ (performance)ï¼šæ€§èƒ½æ˜¯æ¯”è¾ƒéš¾è¡¡é‡çš„ä¸€ä¸ªå°ºåº¦ï¼Œå› ä¸ºå®ƒå’Œ workload æ¯æ¯ç›¸å…³ã€‚ 38.4 RAID Level 0: Striping æœ€ç®€å•çš„ä¸€ç§è®¾è®¡æ–¹æ³•æ˜¯å°† block ä»¥æ¡å¸¦çŠ¶æ”¾åœ¨å„ä¸ªç‰©ç†ç£ç›˜ä¸Šï¼Œä¸‹é¢å±•ç¤ºäº† 4 å—ç‰©ç†ç£ç›˜æ—¶çš„æ‘†æ”¾é¡ºåºï¼š\nDisk 0 Disk 1 Disk 2 Disk 3 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 block ä»¥ä¸€ç§ round-robin çš„æ–¹å¼æ”¾åœ¨å„ä¸ªç£ç›˜ä¸Šï¼Œæˆ‘ä»¬ç§°ä¸€è¡Œä¸­çš„ block ä¸ºä¸€ä¸ª stripeã€‚è¿™ç§æ–¹å¼çš„å¥½å¤„æ˜¯æˆ‘ä»¬åœ¨è¯»å†™ä¸€ä¸²è¿ç»­çš„ block æ—¶å¯ä»¥è¾¾åˆ°æœ€ä½³çš„å¹¶è¡Œæ€§èƒ½ã€‚ä¸Šé¢çš„æ‘†æ”¾æ–¹å¼æ˜¯ chunk size = 1 block çš„æ–¹å¼ï¼Œå³æ¯æ¬¡æ”¾æ”¾ä¸€ä¸ª block å°±è½¬åˆ°ä¸‹ä¸€ä¸ª diskã€‚æˆ‘ä»¬å¯ä»¥è°ƒæ•´ chunk sizeï¼Œæ¯”å¦‚ä¸‹é¢å±•ç¤ºäº† chunk size = 2 block çš„æ‘†æ”¾æ–¹å¼\nDisk 0 Disk 1 Disk 2 Disk 3 0 2 4 6 1 3 5 7 8 10 12 14 9 11 13 15 The RAID Mapping Problem\nåœ¨ RAID ä¸­æˆ‘ä»¬æ€»æ˜¯è¦å¤„ç†çš„ä¸€ä¸ªé—®é¢˜å°±æ˜¯ mapping problemï¼šç»™å®šä¸€ä¸ªé€»è¾‘å—å·ï¼Œæˆ‘ä»¬è¦ç¡®å®šå®ƒåœ¨å“ªä¸€ä¸ªç‰©ç†ç£ç›˜ä¸Šï¼Œä»¥åŠåœ¨ç‰©ç†ç£ç›˜ä¸Šçš„åç§»é‡ã€‚å¯¹äº chunk size = 1 block çš„ RAID 0ï¼Œmapping problem æ˜¯å®¹æ˜“çš„ï¼šå‡è®¾é€»è¾‘å—å·ä¸º $A$ï¼Œåˆ™\nDisk = A % number_of_disks; Offset = A / numbre_of_disks; Chunk Size chunk size ä¸»è¦å½±å“è¯»å†™çš„æ€§èƒ½ã€‚å°çš„ chunk size å¯ä»¥å¸¦æ¥æ›´å¥½çš„å¹¶è¡Œæ€§ï¼Œä½†æ¯ä¸ªç‰©ç†ç£ç›˜ä¸Šçš„ chunk çš„ä¸ªæ•°ä¼šæ¯”è¾ƒå¤šï¼Œå®šä½ chunk ä¹Ÿæ˜¯éœ€è¦æ—¶é—´ä»£ä»·çš„ã€‚\nä¸‹é¢çš„è®¨è®ºä¸­é»˜è®¤ chunk size = 1 blockã€‚\nBack To RAID-0 Analysis RAID-0 çš„ capacity æ˜¯å®Œç¾çš„ï¼šç‰©ç†ç£ç›˜çš„æ¯ä¸ª block éƒ½è¢«ç”¨æ¥å­˜å‚¨ä¿¡æ¯äº†ï¼›RAID-0 çš„ reliability æ˜¯ç³Ÿç³•çš„ï¼šä»»ä½•ä¸€ä¸ªç£ç›˜çš„ä»»ä½•ä¸€ä¸ªéƒ¨åˆ†æŸåéƒ½ä¼šå¯¼è‡´æ•°æ®ä¸¢å¤±ï¼›RAID-0 çš„ performance æ˜¯æ¯”è¾ƒå¥½çš„ï¼ŒåŸºæœ¬å¯ä»¥è¾¾åˆ°ç™¾åˆ†ä¹‹ç™¾çš„å¸¦å®½ã€‚\nEvaluating RAID Performance æˆ‘ä»¬è¡¡é‡ RAID çš„æ€§èƒ½æ—¶é€šå¸¸ä»ä¸¤ç§å°ºåº¦å‡ºå‘ï¼šä¸€ç§æ˜¯å•æ¬¡è¯·æ±‚çš„å»¶è¿Ÿï¼Œä¸€ç§æ˜¯ç¨³å®šçŠ¶æ€ä¸‹çš„ååç‡ã€‚åœ¨è¡¡é‡ç¨³å®šçŠ¶æ€ä¸‹çš„ååç‡æ—¶ï¼Œæˆ‘ä»¬å¯¹ä¸¤ç§ wordload æ¯”è¾ƒæ„Ÿå…´è¶£ï¼šä¸€ç§æ˜¯ sequential çš„ï¼Œå³ä¸€æ¬¡æ€§è¯»å–è¿ç»­çš„å¤šä¸ª blockï¼›å¦ä¸€ç§æ˜¯ random çš„ï¼Œå³å¤šæ¬¡è¯»å–å°‘é‡çš„ blockã€‚å¯ä»¥é¢„è§åœ°ï¼Œå› ä¸ºç‰©ç†ç£ç›˜æœ‰å¯»é“æ—¶é—´å’Œæ—‹è½¬å»¶è¿Ÿï¼Œæ‰€ä»¥ random çš„ workload ä¸‹ç£ç›˜è¦ä¸åœåœ°é‡æ–°å®šä½ï¼Œååç‡ä¼šæ¯” sequential çš„æƒ…å†µä½å¾ˆå¤šã€‚ä¸‹é¢çš„åˆ†æä¸­ï¼Œæˆ‘ä»¬ä»¤ $S$ è¡¨ç¤º sequential çš„ä¸€æ®µé•¿çš„æ•°æ®çš„å¹³å‡è¯»å–é€Ÿåº¦ï¼Œ$R$ è¡¨ç¤º random çš„ä¸€å—çŸ­çš„æ•°æ®çš„å¹³å‡è¯»å–é€Ÿåº¦ã€‚\nBack To RAID-0 Analysis, Again ä»å•æ¬¡è¯·æ±‚å»¶è¿Ÿçš„è§’åº¦æ¥çœ‹ï¼Œ RAID-0 çš„å»¶è¿ŸåŸºæœ¬ç­‰äºä¸€å—ç‰©ç†ç£ç›˜çš„å»¶è¿Ÿï¼Œå› ä¸ºä¸€ä¸ª single-block request ä¼šè¢« RAID çš„ç³»ç»Ÿå®šå‘åˆ°æŸä¸€å—ç‰©ç†ç£ç›˜ä¸Šã€‚\nä»ç¨³å®šçŠ¶æ€ä¸‹çš„ååç‡æ¥çœ‹ï¼ŒRAID-0 å¯ä»¥è¾¾åˆ°æœ€å¤§çš„å¸¦å®½ï¼Œå› ä¸ºä¸è®ºæ˜¯ sequential è¿˜æ˜¯ randomï¼Œå½“è¯»å–çš„ block ä¸ªæ•°è¶³å¤Ÿå¤šæ—¶ï¼ŒæœŸæœ›æƒ…å†µä¸‹æ‰€æœ‰çš„ç‰©ç†ç£ç›˜éƒ½åœ¨æ»¡è´Ÿè·è¿ä½œã€‚å³ sequential çš„ååç‡ä¸º $N\\cdot S\\text{ MB/s}$ï¼Œrandom çš„ååç‡ä¸º $N\\cdot R\\text{ MB/s}$ã€‚\n38.5 RAID Level 1: Mirroring RAID 1 çš„åŸºæœ¬æ€æƒ³æ˜¯é•œåƒï¼šä¸ºæ¯ä¸ª block ä¿å­˜å‰¯æœ¬ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å¿å— disk failureã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š\nDisk 0 Disk 1 Disk 2 Disk 3 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 è¿™ç§æ–¹å¼ä¹Ÿè¢«ç§°ä¸º RAID-10 (RAID-1+0)ï¼Œå› ä¸ºå®ƒæ˜¯å…ˆå¤åˆ¶å†æŒ‰ç…§ RAID-0 çš„æ–¹å¼æ’å¼€ã€‚ç›¸åº”åœ°ä¹Ÿæœ‰ RAID-01 (RAID-0+1)ï¼Œå…ˆæ’å¼€å†åšé•œåƒã€‚æˆ‘ä»¬æ‰€è¯´çš„ RAID-1 é€šå¸¸æŒ‡ RAID-10ã€‚\nRAID-1 åœ¨è¯»å–ä¸€ä¸ªå—æ—¶æœ‰ä¸¤ä¸ªé€‰æ‹©ï¼Œä½† RAID-1 çš„å†™å…¥æ“ä½œå¿…é¡»åŒæ—¶ä¿®æ”¹ä¸¤ä¸ªå‰¯æœ¬ã€‚ä¸è¿‡ RAID-1 çš„è®¾è®¡ä¸­ä¸€ä¸ªå—çš„ä¸¤ä¸ªå‰¯æœ¬ä½äºä¸åŒçš„ç‰©ç†ç£ç›˜ä¸Šï¼Œå¯¹ä¸¤ä¸ªå‰¯æœ¬çš„ä¿®æ”¹å¯ä»¥å¹¶è¡Œè¿›è¡Œã€‚\nRAID-1 Analysis ä» capacity çš„è§’åº¦ï¼ŒRAID-1 æ¯”è¾ƒç³Ÿç³•ï¼šåªæœ‰ä¸€åŠçš„å®¹é‡çœŸæ­£å­˜å‚¨äº†ä¿¡æ¯ï¼Œå‰©ä¸‹çš„ä¸€åŠéƒ½æ˜¯å‰¯æœ¬ã€‚\nä» reliability çš„è§’åº¦ï¼ŒRAID-1 å¾ˆå¯é ï¼Œå› ä¸ºä»»ä½•ä¸€ä¸ªç‰©ç†ç£ç›˜æŸåéƒ½ä¸ä¼šå¯¼è‡´æ•°æ®ä¸¢å¤±ã€‚ç”šè‡³åœ¨ä¸Šè¿°ä¾‹å­ä¸­ï¼Œå¦‚æœ disk 0 å’Œ disk 2 åŒæ—¶æŸåï¼ŒRAID-1 ä¹Ÿä¸ä¼šä¸¢å¤±æ•°æ®ã€‚RAID-1 reliability çš„ä¸‹é™æ˜¯ 1 ä¸ªç£ç›˜ï¼Œè¿æ°”å¥½çš„æƒ…å†µä¸‹ç”šè‡³å¯ä»¥åšåˆ° $N/2$ å—ç£ç›˜ã€‚\nä» performance çš„è§’åº¦ï¼Œé¦–å…ˆè€ƒè™‘ latencyï¼šå¯¹äºè¯»æ“ä½œæ¥è¯´å»¶è¿Ÿå°±æ˜¯ä¸€å—ç‰©ç†ç£ç›˜çš„å»¶è¿Ÿï¼›å†™æ“ä½œåˆ™æœ‰ä¸€ç‚¹ä¸åŒï¼Œå†™æ“ä½œéœ€è¦æ›´æ–°ä¸¤ä¸ªå‰¯æœ¬ï¼Œè™½ç„¶è¿™ä¸¤ä¸ªå†™å…¥åœ¨ä¸åŒçš„ç‰©ç†ç£ç›˜ä¸Šå¯ä»¥å¹¶è¡Œï¼Œä½†ä¸¤å—ç£ç›˜ä¸­å¯»é“+æ—‹è½¬æ—¶é—´è¾ƒé•¿çš„é‚£å—ç£ç›˜å°†å†³å®šå†™æ“ä½œçš„å»¶è¿Ÿï¼Œå› æ­¤å†™æ“ä½œå»¶è¿Ÿç•¥é«˜äºä¸€å—ç‰©ç†ç£ç›˜çš„æœŸæœ›å»¶è¿Ÿã€‚\næ¥ä¸‹æ¥è€ƒè™‘ååç‡ã€‚é¦–å…ˆæ˜¯ sequential çš„ workloadã€‚å†™å…¥æ–¹é¢ï¼Œå› ä¸ºæ¯ä¸ªé€»è¾‘å—çš„å†™å…¥éƒ½è¦åŒæ—¶å†™å…¥ä¸¤ä¸ªå‰¯æœ¬ï¼Œæ‰€ä»¥ååç‡ä¸º $\\frac{N\\cdot S}{2}$ã€‚ä¸€ä¸ªæœ‰ç‚¹åç›´è§‰çš„ç»“è®ºæ˜¯ï¼šè¯»å–çš„ååç‡ä¹Ÿæ˜¯ $\\frac{N\\cdot S}{2}$ã€‚è™½ç„¶æˆ‘ä»¬æ¯ä¸ªå—æœ‰ä¸¤ä¸ªå‰¯æœ¬ï¼Œä½†ç²¾å¿ƒå®‰æ’è¯»å–é¡ºåºå¹¶ä¸èƒ½ç»™æˆ‘ä»¬å¸¦æ¥æ•ˆç‡æå‡ã€‚æ¯”å¦‚æˆ‘ä»¬è¦è¯»å– 0, 1, 2, 3, 4, 5, 6, 7ï¼Œå¦‚æœæˆ‘ä»¬åªä½¿ç”¨ Disk 0 å’Œ Disk 2ï¼Œååç‡æ˜¾ç„¶ä¸º $\\frac{N\\cdot S}{2}$ï¼›æˆ‘ä»¬å¯èƒ½ä¼šæƒ³å‡ºè¿™æ ·çš„å®‰æ’æ–¹æ¡ˆï¼šDisk 0 å’Œ Disk 2 è¯» 0 å’Œ 1ï¼ŒDisk 1 å’Œ Disk 3 è¯» 2 å’Œ 3ï¼Œåé¢ä¾æ¬¡ç±»æ¨ï¼Œè¿™æ ·æ˜¯ä¸æ˜¯å¯ä»¥ç”¨æ»¡å¸¦å®½å‘¢ï¼Ÿå®é™…ä¸Šä¸ç„¶ã€‚æˆ‘ä»¬è€ƒè™‘ä¸€ä¸ª Disk æ¥å—åˆ°çš„ä»»åŠ¡ï¼Œæ¯”å¦‚ Disk 0ï¼šå®ƒè¦è¯»å– 0, 4, 8\u0026hellip;\u0026hellip; è¿™äº› blockï¼Œè¿™äº› block åœ¨ Disk 0 ä¸Šä¸æ˜¯è¿ç»­å­˜æ”¾çš„ï¼Œæ‰€ä»¥ç£ç›˜åœ¨æ—‹è½¬çš„æ—¶å€™æ¯è¯»å–ä¸€ä¸ªå—ï¼Œå°±è¦ç­‰å¾…ä¸€ä¸ªå—ï¼Œç£ç›˜åˆ’è¿‡ä¸éœ€è¦çš„å—çš„æ—¶å€™å¹¶æ²¡æœ‰å‘ç”¨æˆ·è¾“å‡ºæœ‰æ•ˆçš„å¸¦å®½ï¼Œå› æ­¤å®ƒå®é™…ä¸Šåªè¾“å‡ºäº†ä¸€åŠçš„æ•ˆç‡ã€‚\nåœ¨ random çš„ workload ä¸‹ï¼ŒRAID-1 çš„è¯»å–æ˜¯å®Œç¾çš„ï¼šDisk 2 å’Œ Disk 4 ä½œä¸º Disk 0 å’Œ Disk 3 çš„å‰¯æœ¬ä¹Ÿå¯ä»¥ä¸ºç”¨æˆ·æä¾›å¸¦å®½ï¼Œå› æ­¤èªæ˜çš„é€‰æ‹©å½“å‰ç©ºé—²çš„ç£ç›˜å¯ä»¥ä½¿ååç‡è¾¾åˆ° $N\\cdot R$ã€‚å†™å…¥æ–¹é¢ï¼Œå› ä¸ºè¦åŒæ—¶ä¿®æ”¹ä¸¤ä¸ªç£ç›˜ä¸­çš„å‰¯æœ¬ï¼Œæ‰€ä»¥ååç‡æ˜¯ $\\frac{N\\cdot R}{2}$ã€‚\nThe RAID Consistent-Update Problem\nRAID-1 ä¸­æ¶‰åŠ mirroringï¼Œåœ¨å†™å…¥æ“ä½œæ—¶è¦åŒæ—¶æ›´æ–°ä¸¤ä¸ªå‰¯æœ¬ï¼Œå› æ­¤å­˜åœ¨æ‰€è°“çš„ consistent-update é—®é¢˜ï¼šå¦‚æœæˆ‘ä»¬æ— è„‘åœ°ä¿®æ”¹ç¬¬ä¸€ä¸ªéƒ¨åˆ†å†ä¿®æ”¹ç¬¬äºŒä¸ªå‰¯æœ¬ï¼Œé‚£ä¹ˆåŠ å…¥ä¿®æ”¹å®Œç¬¬ä¸€ä¸ªå‰¯æœ¬åç³»ç»Ÿæ‰ç”µäº†ï¼Œé‚£ä¹ˆé‡å¯åæ•´ä¸ªç£ç›˜å°†å¤„äºä¸€ä¸ª inconsistent çš„çŠ¶æ€â€”â€”ä¸¤ä¸ªå‰¯æœ¬çš„å†…å®¹ä¸ä¸€è‡´ã€‚å› æ­¤ä¿®æ”¹ä¸¤ä¸ªå‰¯æœ¬çš„æ“ä½œåº”å½“æ˜¯åŸå­çš„ã€‚\nåœ¨æ–‡ä»¶ç³»ç»Ÿä¸­æˆ‘ä»¬ç”¨ journaling çš„æ–¹æ³•æ¥è§£å†³åŸå­æ€§çš„é—®é¢˜ï¼Œåœ¨ RAID ä¸­è¯¥æ–¹æ³•åŒæ ·é€‚ç”¨ã€‚æˆ‘ä»¬åªè¦ä¿å­˜ä¸€ä¸ªä¿®æ”¹æ“ä½œçš„ loggingï¼Œæ„å¤–æ‰ç”µé‡å¯åå°±å¯ä»¥æ ¹æ® logging çš„å†…å®¹æ¥åšæ¢å¤ã€‚å€¼å¾—ä¸€æçš„æ˜¯ï¼Œæ¯æ¬¡å†™å…¥æ“ä½œéƒ½åœ¨ disk ä¸­åš logging çš„ä»£ä»·å¤ªå¤§æ— æ³•å¿å—ï¼Œå› æ­¤ RAID ä¸­ä¸€èˆ¬ä¼šæœ‰ä¸€å°å— non-volatile çš„ RAM ç”¨äºå†™å…¥ loggingã€‚\n38.6 RAID Level 4: Saving Space With Parity é•œåƒæ‰€éœ€è¦çš„é¢å¤–å­˜å‚¨ç©ºé—´å¤ªå¤šã€‚äº‹å®ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ ¡éªŒç çš„æ€è·¯æ¥ä¸ºæ•°æ®ä¿å­˜å‰¯æœ¬ï¼Œè¿™å°±æ˜¯ RAID-4ã€‚RAID-4 çš„ä¸€ä¸ªä¾‹å­å¦‚ä¸‹ï¼š\nDisk 0 Disk 1 Disk 2 Disk 3 Disk 4 0 1 2 3 P0 4 5 6 7 P1 8 9 10 11 P2 12 13 14 15 P3 å…¶ä¸­ Disk 4 ä¸Šå­˜å‚¨çš„éƒ½æ˜¯å‰ 4 ä¸ª disk çš„æ ¡éªŒç ï¼š$P0 = 0\\oplus 1\\oplus 2\\oplus 3$ï¼Œä¾æ­¤ç±»æ¨ã€‚è¿™æ ·å¦‚æœæœ‰ä»»ä½•ä¸€ä¸ªç£ç›˜æŸåï¼Œå°†å…¶ä»– 4 ä¸ªç£ç›˜çš„æ•°æ®å¼‚æˆ–èµ·æ¥å°±å¯ä»¥æ¢å¤è¯¥ç£ç›˜çš„æ•°æ®ã€‚\nRAID-4 Analysis ä» capacity çš„è§’åº¦ï¼šå®ƒæ¯” RAID-1 å¥½å¾ˆå¤šï¼š$\\frac{N-1}{N}$ çš„ç©ºé—´éƒ½å¯ä»¥ç”¨æ¥å­˜å‚¨æœ‰æ•ˆçš„ä¿¡æ¯ã€‚\nä» reliability çš„è§’åº¦ï¼šRAID-4 å¯ä»¥å®¹å¿ä¸€ä¸ªç£ç›˜çš„æŸåã€‚\nä» performance çš„è§’åº¦ï¼š\né¦–å…ˆè€ƒè™‘ååç‡ï¼šsequential çš„æƒ…å†µæ˜¯æ¯”è¾ƒå®¹æ˜“åˆ†æçš„ï¼šè¯»å–çš„æ—¶å€™ï¼Œåªæœ‰ $N-1$ ä¸ªç£ç›˜ä¸­å­˜å‚¨çš„æ˜¯æœ‰æ•ˆæ•°æ®ï¼Œæ‰€ä»¥å¸¦å®½ä¸º $(N-1)\\cdot S$ã€‚å†™å…¥çš„æ—¶å€™ï¼Œæ¯ä¸€ä¸ª stripe ($N-1$ ä¸ª block) çš„æ•°æ®å¯ä»¥ç”± $N$ ä¸ªç£ç›˜å¹¶è¡Œå†™å…¥ï¼Œå› æ­¤å¸¦å®½ä¹Ÿæ˜¯ $(N-1)\\cdot S$ã€‚random çš„è¯»å–ä¹Ÿå®¹æ˜“åˆ†æï¼šåªæœ‰ $N-1$ ä¸ªå­˜å‚¨äº†æœ‰æ•ˆæ•°æ®çš„ç£ç›˜ä¼šå·¥ä½œï¼Œå› æ­¤å¸¦å®½ä¸º $(N-1)\\cdot R$ã€‚\nå›°éš¾çš„æ˜¯ random å†™å…¥çš„åˆ†æã€‚æˆ‘ä»¬åœ¨ä¿®æ”¹ä¸€ä¸ª block çš„æ—¶å€™åŒæ—¶ä¹Ÿè¦ä¿®æ”¹å®ƒæ‰€åœ¨çš„ stripe çš„æ ¡éªŒ blockã€‚æˆ‘ä»¬æœ‰ä¸¤ç§æ€è·¯æ¥è®¡ç®—æ–°çš„æ ¡éªŒå€¼ï¼šä¸€æ˜¯ addictive parityï¼Œå³æŠŠè¯¥ stripe ä¸­å…¶ä»–çš„ block éƒ½è¯»å‡ºæ¥ï¼Œç„¶åè®¡ç®—æ–°æ ¡éªŒå€¼å¹¶å†™å…¥ï¼Œè¯¥æ–¹æ³•çš„é—®é¢˜æ˜¯å…¶ä»£ä»·éšç€ RAID ä¸­ç£ç›˜çš„ä¸Šå‡è€Œä¸Šå‡ (è¦åšå¾ˆå¤šå¼‚æˆ–)ï¼›äºŒæ˜¯ subtractive parityï¼Œå³è¯»å‡ºæ—§çš„æ ¡éªŒå€¼ï¼Œå¼‚æˆ–æ‰æ—§çš„ blockï¼Œå†å¼‚æˆ–ä¸Šæ–°çš„ block ä»¥è·å¾—æ–°çš„æ ¡éªŒå€¼ã€‚å†™æˆå…¬å¼å°±æ˜¯ $P_{new}=P_{old}\\oplus(C_{old}\\oplus C_{new})$ï¼Œè¯¥æ–¹æ³•éœ€è¦å¯¹æ ¡éªŒ block å’Œæ•°æ® block å„åšä¸€æ¬¡è¯»å’Œä¸€æ¬¡å†™ã€‚é€šå¸¸æ¥è¯´æˆ‘ä»¬é€‰æ‹© subtractive parityï¼Œä½†è¯¥æ–¹æ³•çš„å…³é”®é—®é¢˜åœ¨äºä¸ç®¡æˆ‘ä»¬ä¿®æ”¹å“ªä¸ªç‰©ç†ç£ç›˜ä¸Šçš„æ•°æ®ï¼Œéƒ½è¦è¯»å†™æ ¡éªŒç£ç›˜ï¼Œå› æ­¤å³ä½¿æ•°æ®ç£ç›˜çš„ä¿®æ”¹å¯ä»¥å¹¶è¡Œï¼Œæ ¡éªŒç£ç›˜ä»ç„¶ä¼šå°†æ•´ä¸ªè¿‡ç¨‹å˜æˆä¸²è¡Œï¼Œå®ƒæˆä¸ºäº†æ•´ä¸ªç³»ç»Ÿçš„ç“¶é¢ˆã€‚è¿™ä¸ªé—®é¢˜è¢«æˆä¸º small-write problemã€‚RAID-4 åœ¨ random å†™å…¥ä¸‹çš„å¸¦å®½æ˜¯ $(R/2)$ï¼Œè¿™éå¸¸ç³Ÿç³•ï¼Œå› ä¸ºå®ƒä¸éšç€ RAID è§„æ¨¡çš„å¢å¤§è€Œæé«˜ã€‚\næ¥ç€åˆ†æ latencyï¼šè¯»ä¸€ä¸ª block çš„å»¶è¿Ÿå’Œä¸€å—ç‰©ç†ç£ç›˜ä¸Šçš„å»¶è¿Ÿç›¸åŒï¼›å†™ä¸€ä¸ª block çš„å»¶è¿Ÿåˆ™å¤æ‚ä¸€äº›ï¼šæ ¹æ®ä¹‹å‰çš„ subtractive parity çš„æ–¹æ³•ï¼Œæˆ‘ä»¬è¦è¯»ä¸€æ¬¡å†™ä¸€æ¬¡æ•°æ®ç£ç›˜å’Œæ ¡éªŒç£ç›˜ï¼Œå› æ­¤å»¶è¿Ÿå¤§çº¦æ˜¯ä¸€å—ç‰©ç†ç£ç›˜å»¶è¿Ÿçš„ä¸¤å€ã€‚\n38.7 RAID Level 5: Rotating Parity RAID-5 é’ˆå¯¹ RAID-4 çš„ small-write problem åšå‡ºäº†æ”¹è¿›ï¼ŒæŠŠæ ¡éªŒ block åˆ†æ•£åˆ°äº†å„ä¸ªç£ç›˜å½“ä¸­ï¼š\nDisk 0 Disk 1 Disk 2 Disk 3 Disk 4 0 1 2 3 P0 4 5 6 P1 7 8 9 P2 10 11 12 P3 13 14 15 P4 16 17 18 19 RAID-5 Analysis RAID-5 å¾ˆå¤šæ–¹é¢çš„å‚æ•°å’Œ RAID-4 æ˜¯å·®ä¸å¤šçš„ã€‚è¿™é‡Œä¸»è¦å…³æ³¨ RAID-5 åœ¨ random workload ä¸‹çš„ååç‡ï¼š\nå¯¹äºè¯»å–æ“ä½œï¼Œç”±äºç°åœ¨ $N$ ä¸ªç£ç›˜ä¸Šéƒ½å­˜å‚¨äº†æ•°æ®ï¼Œæ‰€ä»¥å¸¦å®½å¯ä»¥è¾¾åˆ° $N\\cdot R$ã€‚ å¯¹äºå†™å…¥æ“ä½œï¼ŒRAID-5 ç›¸æ¯”è¾ƒäº RAID-4 æœ‰å¾ˆå¤§æ”¹å–„ã€‚æˆ‘ä»¬å¯ä»¥è®¤ä¸ºåœ¨ random request è¶³å¤Ÿå¤šçš„æƒ…å†µä¸‹ï¼Œæ‰€æœ‰çš„ç‰©ç†ç£ç›˜éƒ½åœ¨æ»¡è´Ÿè·è¿è½¬ï¼Œå› æ­¤å¸¦å®½å¯ä»¥è¾¾åˆ° $\\frac{N\\cdot R}{4}$ï¼Œè¿™é‡Œè¦é™¤ä»¥ 4 æ˜¯å› ä¸ºä¸€ä¸ªæ•°æ®å—çš„å†™å…¥è¦æ¶‰åŠ 4 æ¬¡ I/O æ“ä½œã€‚ åœ¨ç»å¤§å¤šæ•°åœºåˆä¸‹ï¼ŒRAID-5 å·²ç»å®Œå…¨å–ä»£äº† RAID-4ã€‚é™¤äº†æŸäº›ç‰¹æ®Šçš„åœºæ™¯ï¼Œä½¿ç”¨è€…ç¡®å®šä¸ä¼šå‡ºç°å¤§é‡çš„éšæœºè¯»å†™ï¼Œè¿™æ—¶ä½¿ç”¨ RAID-4 ä¼šä½¿ç£ç›˜åœ¨ç»“æ„ä¸Šç®€å•ä¸€äº›ã€‚\n38.8 RAID Comparison: A Summary RAID-0 RAID-1 RAID-4 RAID-5 Capacity $N\\cdot B$ $(N\\cdot B)/2$ $(N-1)\\cdot B$ $(N-1)\\cdot B$ Reliability $0$ $1$ (for sure)\n$N/2$ (if lucky) $1$ $1$ Throughput Sequential Read $N\\cdot S$ $(N\\cdot S)/2$ $(N-1)\\cdot S$ $(N-1)\\cdot S$ Sequential Write $N\\cdot S$ $(N\\cdot S)/2$ $(N-1)\\cdot S$ $(N-1)\\cdot S$ Random Read $N\\cdot R$ $N\\cdot R$ $(N-1)\\cdot R$ $N\\cdot R$ Random Write $N\\cdot R$ $(N\\cdot R)/2$ $R/2$ $(N\\cdot R)/4$ Latency Read $T$ $T$ $T$ $T$ Write $T$ $T$ $2T$ $2T$ å¦‚æœä½ æƒ³è¦æè‡´çš„æ€§èƒ½ï¼Œä¸åœ¨ä¹æ•°æ®çš„å¯é æ€§ï¼Œé‚£ä¹ˆå°±é€‰ RAID-0ï¼›å¦‚æœä½ åœ¨ä¹ random I/O çš„æ•ˆç‡ä¸”éœ€è¦å¯é æ€§ï¼Œé‚£ä¹ˆå°±é€‰ RAID-1 (ä»£ä»·æ˜¯å®¹é‡)ï¼›å¦‚æœ reliability å’Œ capacity ä½ éƒ½åœ¨ä¹ï¼Œé‚£ä¹ˆå°±é€‰ RAID-5 (ä»£ä»·æ˜¯ small-write performance)ã€‚\n38.9 Other Interesting RAID Issues å…³äº RAID è¿˜æœ‰å¾ˆå¤šæœ‰æ„æ€çš„é—®é¢˜å¯ä»¥ç ”ç©¶ï¼Œæ¯”å¦‚åœ¨å‘ç”Ÿ failure çš„æ—¶å€™ç³»ç»Ÿä¼šç»å†æ€æ ·çš„è¿ä½œè¿‡ç¨‹ï¼Œè¿™æ—¶å€™çš„æ€§èƒ½ä¼šæœ‰ä»€ä¹ˆå˜åŒ–ç­‰ç­‰ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥æå‡ºä¸€äº›æ›´è´´åˆå®é™…çš„ fault modelï¼Œä»¥è€ƒè™‘åˆ° block corruptionï¼Œlatent sector error ç­‰ç­‰ã€‚ç”šè‡³æœ‰äººå°† RAID system æ”¾åˆ°è½¯ä»¶å±‚é¢ã€‚\n38.10 Summary RAID çš„æ ¸å¿ƒæ€æƒ³æ˜¯å°†è®¸å¤šå—ä¸å¤ªå¯é çš„ç‰©ç†ç£ç›˜ç»„åˆåœ¨ä¸€èµ·å½¢æˆä¸€ä¸ªåˆå¤§åˆå¿«åˆå¯é çš„ç£ç›˜ã€‚RAID çš„é€‰æ‹©ä¸ä½¿ç”¨åœºæ™¯çš„ workload æ¯æ¯ç›¸å…³ï¼Œå¹¶ä¸æ˜¯è¯´ RAID-5 å°±ä¸€å®šæ¯” RAID-1 æ¥çš„å¥½ã€‚å› æ­¤é€‰æ‹©åˆé€‚çš„ RAID æ¨¡å‹å¹¶ä¸ºå…¶è°ƒæ•´åˆé€‚çš„å‚æ•° (æ¯”å¦‚ chunk sizeï¼Œç‰©ç†ç£ç›˜ä¸ªæ•°ç­‰) æ˜¯ä¸€é—¨è‰ºæœ¯ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"a5c1380b7aa14a749aaf52d67284ecb4","permalink":"https://kristoff-starling.github.io/notes/booknotes/ostep/ch38/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/booknotes/ostep/ch38/","section":"notes","summary":"æˆ‘ä»¬å¯¹ç£ç›˜æœ‰ä¸‰ä¸ªç»´åº¦çš„éœ€æ±‚ï¼šæˆ‘ä»¬å¸Œæœ›å®ƒè¯»å†™é€Ÿåº¦å¿« (I/O æ“ä½œé€Ÿåº¦æ…¢ï¼Œå› è€Œæˆä¸ºæ•´ä¸ªç³»ç»Ÿçš„é€Ÿåº¦ç“¶é¢ˆ)ï¼Œæˆ‘ä»¬å¸Œæœ›å®ƒå®¹é‡å¤§ï¼Œæˆ‘ä»¬è¿˜å¸Œæœ›å®ƒå¯é  (å¦‚æœå‘ç”Ÿç£ç›˜æŸåï¼Œä»ç„¶èƒ½æ¢å¤æ•°æ®)ã€‚\næœ¬ç« èŠ‚ä¸»è¦ä»‹ç» Redundant Arrays of Inexpensive Disks (RAIDs) æŠ€æœ¯ï¼Œå®ƒçš„æ ¸å¿ƒæ€æƒ³æ˜¯ç”¨å¤šå—ç‰©ç†ç£ç›˜å»æ„å»ºä¸€ä¸ªå¤§å®¹é‡çš„ï¼Œé«˜é€Ÿçš„ï¼Œå¯é æ€§é«˜çš„ç£ç›˜ã€‚å¯¹å¤–æ¥çœ‹ï¼ŒRAID è™šæ‹Ÿå‡ºäº†ä¸€å—å¯è¯»å¯å†™çš„ç£ç›˜ï¼›åœ¨å…¶å†…éƒ¨ï¼ŒRAID ç”±ä¸€ä¸ªéå¸¸å¤æ‚çš„ç³»ç»Ÿæ„æˆï¼ŒåŒ…å«äº†è‹¥å¹²ä¸ªç‰©ç†ç£ç›˜å’Œä¸€ä¸ªæˆ–å¤šä¸ªç”¨äºæ§åˆ¶çš„èŠ¯ç‰‡ï¼Œå¯ä»¥è¯´ RAID å†…éƒ¨å°±æ˜¯ä¸€ä¸ªå°å‹çš„è®¡ç®—æœºç³»ç»Ÿã€‚\nRAID çš„ä¼˜ç‚¹åœ¨äºï¼šå®ƒå¯ä»¥é€šè¿‡å¤šå—ç£ç›˜å¹¶è¡Œçš„è¯»å†™æ¥æä¾›å¾ˆå¥½çš„ performanceï¼›é€šè¿‡å åŠ ç£ç›˜çš„æ•°é‡æ¥è·å¾— capacityï¼›é€šè¿‡å­˜å‚¨ä¸€éƒ¨åˆ†çš„å†—ä½™æ•°æ®æ¥ä¿è¯æ•°æ®çš„ reliabilityã€‚æ›´é‡è¦çš„æ˜¯ï¼ŒRAID å¯ä»¥é€æ˜åœ°æä¾›è¿™äº›ä¼˜åŠ¿ï¼Œè¿™é‡Œé€æ˜çš„æ„æ€æ˜¯å¯¹äºå…¶ä»–ç¡¬ä»¶/OSæ¥è¯´ï¼ŒRAID çœ‹ä¸Šå»å°±åƒæ˜¯ä¸€æ•´å—æ™®é€šçš„ç£ç›˜ã€‚æ•´ä¸ªç³»ç»Ÿçš„å…¶ä»–éƒ¨åˆ†ä¸éœ€è¦åšä»»ä½•ä¿®æ”¹å°±å¯ä»¥å…¼å®¹ RAIDã€‚è¿™ä¸€ç‚¹æå¤§åœ°æå‡äº† RAID çš„å¯éƒ¨ç½²æ€§ (deployability)ã€‚ç”¨æˆ·å¯ä»¥æ”¾å¿ƒåœ°å°†è‡ªå·±ç°æœ‰çš„ç£ç›˜æ›´æ¢æˆ RAIDï¼Œä¸éœ€è¦æ‹…å¿ƒå…¼å®¹é—®é¢˜ã€‚\n38.1 Interface And RAID Internals å¯¹äºä¸Šå±‚çš„æ–‡ä»¶ç³»ç»Ÿæ¥è¯´ï¼ŒRAID deng |çœ‹ä¸Šå»å°±åƒä¸€ä¸ªç£ç›˜ã€‚å’Œå…¶ä»–å•å—ç£ç›˜çš„æŠ½è±¡ä¸€æ ·ï¼ŒRAID å¯¹å¤–æš´éœ²æˆä¸€ä¸ªçº¿æ€§çš„ block arrayï¼Œæ¯ä¸ªå—éƒ½å¯è¯»å¯å†™ã€‚","tags":null,"title":"Chapter 38: Redundant Arrays of Inexpensive Disks (RAIDs)","type":"docs"},{"authors":null,"categories":null,"content":"æ–‡ä»¶ç³»ç»Ÿæ˜¯ä¸€ä¸ªçº¯ç²¹çš„è½¯ä»¶ï¼Œå› æ­¤åœ¨æœ¬ç« èŠ‚ä¸­æˆ‘ä»¬ä¸è€ƒè™‘åŠ å…¥ä»»ä½•çš„ç¡¬ä»¶ feature ä½¿æ–‡ä»¶ç³»ç»Ÿå·¥ä½œå¾—æ›´å¥½ (å½“ç„¶æˆ‘ä»¬è¿˜æ˜¯ä¼šæ³¨æ„å—è®¾å¤‡æœ¬èº«çš„ç‰¹æ€§)ã€‚æ–‡ä»¶ç³»ç»Ÿè®¾è®¡æœ¬èº«æœ‰å¾ˆå¤§çš„å¼¹æ€§ï¼Œå› æ­¤ç°å­˜çš„æ–‡ä»¶ç³»ç»Ÿå¾ˆå¤šï¼Œå®ƒä»¬ä½¿ç”¨ä¸åŒçš„æ•°æ®ç»“æ„ï¼Œåœ¨å„æ–¹é¢çš„è¡¨ç°ä¹Ÿå„æœ‰åƒç§‹ã€‚\n40.1 The Way To Think è®¾è®¡æ–‡ä»¶ç³»ç»Ÿæˆ‘ä»¬é€šå¸¸è€ƒè™‘ä¸¤ä»¶äº‹æƒ…ï¼š\næ•°æ®ç»“æ„ï¼šæˆ‘ä»¬å‡†å¤‡ä½¿ç”¨ä»€ä¹ˆæ•°æ®ç»“æ„æ¥ç»„ç»‡ç£ç›˜ä¸Šçš„æ•°æ®å’Œå…ƒæ•°æ®ï¼Ÿåœ¨ç®€å•çš„æ–‡ä»¶ç³»ç»Ÿå®ç°ä¸­æˆ‘ä»¬é€šå¸¸ä½¿ç”¨ç®€å•çš„å—é“¾è¡¨ï¼Œåœ¨ä¸€äº›æ¯”è¾ƒç²¾å¯†çš„æ–‡ä»¶ç³»ç»Ÿå®ç°ä¸­ä¹Ÿæœ‰ä½¿ç”¨æ ‘çŠ¶ç»“æ„çš„ã€‚ è®¿é—®æ–¹å¼ï¼šè¿›ç¨‹ä½¿ç”¨çš„ open(), read(), write() ç­‰å‡½æ•°è¯¥å¦‚ä½•å¯¹åº”åˆ°æ–‡ä»¶ç³»ç»Ÿçš„ç»“æ„ä¸Šï¼Ÿå¯¹äºä¸€ä¸ªç‰¹å®šçš„ç³»ç»Ÿè°ƒç”¨ï¼Œå“ªäº›æ•°æ®éœ€è¦è¢«è¯»å†™ï¼Ÿæ¯ä¸€æ­¥çš„æ•ˆç‡å¦‚ä½•ï¼Ÿ 40.2 Overall Organization vsfs (very simple file systemï¼Œä¸€ä¸ª UNIX æ–‡ä»¶ç³»ç»Ÿçš„ç²¾ç®€ç‰ˆæœ¬) çš„ç»“æ„å¦‚ä¸‹ï¼š\næ•´ä¸ªç£ç›˜è¢«åˆ’åˆ†æˆ 64 ä¸ª blockï¼Œæ¯ä¸ª block çš„å¤§å°æ˜¯ 4KBã€‚\nåé¢çš„ 56 ä¸ª block æ˜¯ data regionï¼Œç”¨æ¥å­˜å‚¨ç”¨æˆ·æ•°æ®ã€‚ 3~7 è¿™ 5 ä¸ª block æ˜¯ inode table åŒºï¼Œå­˜å‚¨äº†ä¸€ä¸ª inode æ•°ç»„ï¼Œæ³¨æ„åˆ°ä¸€ä¸ª inode é€šå¸¸æ²¡æœ‰ä¸€ä¸ª block é‚£ä¹ˆå¤§â€”â€”åªæœ‰ 128 æˆ– 256 å­—èŠ‚ï¼Œè¿™é‡Œå‡è®¾ 256 å­—èŠ‚ï¼Œåˆ™ 5 ä¸ª block å¯ä»¥å­˜å‚¨ 80 ä¸ª inodeï¼Œå³æˆ‘ä»¬çš„æ–‡ä»¶ç³»ç»Ÿä¸­æœ€å¤šå¯ä»¥æœ‰ 80 ä¸ªæ–‡ä»¶ (åœ¨æ›´å¤§çš„ç£ç›˜ä¸Šï¼Œæˆ‘ä»¬çš„ inode table å¯ä»¥æ›´å¤§ï¼Œä»è€Œå¯ä»¥å­˜å‚¨æ›´å¤šçš„æ–‡ä»¶)ã€‚ block 1 æ˜¯ inode bitmapï¼Œblock 2 æ˜¯ data bitmapï¼Œbitmap å­˜å‚¨äº†æ¯ä¸ª inode/data block å¤„äºç©ºé—²çŠ¶æ€è¿˜æ˜¯æ­£åœ¨ä½¿ç”¨çš„çŠ¶æ€ã€‚ block 0 æ˜¯ superblockï¼Œå­˜å‚¨äº†æ–‡ä»¶ç³»ç»Ÿçš„å…ƒæ•°æ®ï¼Œæ¯”å¦‚ inode çš„ä¸ªæ•°ï¼Œç£ç›˜çš„å¤§å°ï¼Œinode table çš„èµ·å§‹ä½ç½®ï¼Œæ–‡ä»¶ç³»ç»Ÿçš„é­”æ•°ç­‰ç­‰ã€‚ 40.3 File Organization: The Inode å‡ ä¹æ‰€æœ‰çš„æ–‡ä»¶ç³»ç»Ÿéƒ½æœ‰ç±»ä¼¼äº inode çš„ç»“æ„ï¼šå®ƒä¿å­˜äº†ä¸€ä¸ªæ–‡ä»¶çš„å…ƒæ•°æ®ï¼Œæ¯”å¦‚å¤§å°ã€æƒé™ç­‰ç­‰ã€‚inode çš„å…¨ç§°æ˜¯ index nodeï¼Œè¿™æ˜¯å› ä¸ºä¸€èˆ¬ inode è¢«æ•´é½åœ°å­˜æ”¾åœ¨ä¸€ä¸ªæ•°ç»„é‡Œé¢ï¼Œå› æ­¤ç»™å®šä¸€ä¸ªä¸‹æ ‡ï¼Œæˆ‘ä»¬å¾ˆå®¹æ˜“ç´¢å¼•åˆ°ä¸€ä¸ªå¯¹åº”çš„ inodeã€‚ä»¥æˆ‘ä»¬çš„ vsfs ä¸ºä¾‹ï¼Œinode table çš„èµ·å§‹åœ°å€ inodeStartAddr = 12KBï¼Œæ¯ä¸ª inode çš„å¤§å°æ˜¯ 256Bï¼Œå› æ­¤ç»™å®šä¸€ä¸ª inumberï¼Œæˆ‘ä»¬æœ‰å¦‚ä¸‹çš„è®¡ç®—å…¬å¼ï¼š\nblk = (inumber * sizeof(inode_t)) / blockSize; sector = ((blk * blockSize) + inodeStartAddr) / sectorSize; (æ³¨ï¼šç£ç›˜ä¸æ˜¯ byte addressable çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬åªç®—å‡ºç²¾ç¡®çš„åœ°å€æ²¡æœ‰ç”¨ï¼Œè€Œè¦ç®—å‡ºå®ƒåœ¨å“ªä¸ª sector ä¸­ï¼ŒæŠŠæ•´ä¸ª sector è¯»å‡ºæ¥ï¼Œå†æ ¹æ® offset å®šä½ inodeã€‚)\ninode ä¸­æœ‰å…³äºä¸€ä¸ªæ–‡ä»¶çš„æ‰€æœ‰ä¿¡æ¯ï¼šæ¯”å¦‚å®ƒçš„ç±»å‹ (æ–‡ä»¶/æ–‡ä»¶å¤¹/è®¾å¤‡ etc.)ï¼Œå®ƒçš„å¤§å°ï¼Œå®ƒåŒ…å«çš„ block æ•°ç›®ï¼Œå®ƒçš„è®¿é—®æƒé™ï¼Œå®ƒçš„åˆ›å»º/ä¿®æ”¹æ—¥æœŸç­‰ã€‚è¿™äº›ä¿¡æ¯é€šå¸¸è¢«ç§°ä¸ºæ–‡ä»¶çš„å…ƒæ•°æ® (metadata) (é€šå¸¸æ–‡ä»¶ç³»ç»Ÿä¸­å’Œç”¨æˆ·æ•°æ®æ— å…³çš„å…¶ä»–æ•°æ®éƒ½è¢«ç§°ä¸ºå…ƒæ•°æ®)ã€‚ä¸‹é¢å±•ç¤ºäº†ä¸€ä¸ªç®€åŒ–çš„ ext2 æ–‡ä»¶ç³»ç»Ÿçš„ inode ä¸­å­˜å‚¨çš„å…ƒæ•°æ®ï¼š\ninode ä¸­æœ€é‡è¦çš„éƒ¨åˆ†å°±æ˜¯æŒ‡ç¤º data block ä½ç½®çš„éƒ¨åˆ†ã€‚ä¸€ç§ç®€å•çš„æ–¹æ³•æ˜¯åœ¨ inode ä¸­å­˜å‚¨è‹¥å¹²ä¸ª direct pointersï¼Œæ¯ä¸ªæŒ‡é’ˆä¿å­˜ä¸€ä¸ª data block çš„åœ°å€ã€‚è¿™ç§æ–¹æ³•çš„å±€é™æ€§åœ¨äºæ— æ³•ä¿å­˜å¤§æ–‡ä»¶çš„æ‰€æœ‰ data blockã€‚\nThe Multi-Level Index è§£å†³å¤§æ–‡ä»¶å­˜å‚¨çš„æ–¹æ³•é€šå¸¸æ˜¯æ‰€è°“çš„ indirect pointerï¼šæˆ‘ä»¬ä»æ•°æ®åŒºåˆ†é…ä¸€ä¸ª blockï¼Œè®© inode ä¸­çš„ indirect pointer æŒ‡å‘è¿™ä¸ª blockï¼Œç„¶åè¿™ä¸ª block é‡Œå­˜æ”¾ä¸€å † direct pointerã€‚å‡è®¾ä¸€ä¸ªåœ°å€å  4Bï¼Œé‚£ä¹ˆä¸€ä¸ª block é‡Œå¯ä»¥å­˜æ”¾ 1024 ä¸ª direct pointerï¼Œè¿™æ„å‘³ç€åªéœ€è¦ä¸€ä¸ª indirect pointer å°±å¯ä»¥è®°å½•ä¸€ä¸ª 1024*4 KB çš„æ–‡ä»¶çš„æ‰€æœ‰ data block çš„ä½ç½®ã€‚\nè¿™ä¸ªæ€æƒ³æœ‰ç‚¹åƒé¡µè¡¨ã€‚æ­£å¦‚é¡µè¡¨å¯ä»¥æœ‰å¤šçº§ï¼Œæ–‡ä»¶ç³»ç»Ÿä¸­æˆ‘ä»¬ä¹Ÿå¯ä»¥æœ‰ double indirect pointer å’Œ triple indirect pointerï¼Œè¿™æ ·æˆ‘ä»¬ç”¨æ ‘çŠ¶ç»“æ„å­˜ä¸‹äº†å¾ˆå¤š data block çš„åœ°å€ã€‚å€¼å¾—ä¸€æçš„æ˜¯ï¼Œé€šå¸¸ inode é‡Œä¼šæœ‰ 12 ä¸ªå·¦å³çš„ direct pointer å’Œä¸€ä¸ª indirect pointerï¼Œå­˜æ”¾å¦‚æ­¤å¤šçš„ direct pointer æ˜¯å› ä¸ºä»ç»Ÿè®¡è§„å¾‹ä¸Šï¼Œå¤§éƒ¨åˆ†çš„æ–‡ä»¶éƒ½éå¸¸å°ï¼Œç”¨ direct pointer ç›´æ¥å­˜åœ°å€å¯ä»¥ç•¥å»éå†â€œé¡µè¡¨â€çš„è¿‡ç¨‹ï¼Œæ›´åŠ é«˜æ•ˆã€‚\nLinked-Based Approaches\ninode çš„å¦ä¸€ç§å¸¸è§çš„è®¾è®¡æ–¹æ¡ˆæ˜¯ä½¿ç”¨é“¾è¡¨ã€‚åœ¨è¿™ç§è®¾è®¡ä¸‹æˆ‘ä»¬ä¸éœ€è¦åœ¨ inode ä¸­å­˜å‚¨æ‰€æœ‰ data block çš„åœ°å€ï¼Œè€Œåªè¦å­˜å‚¨ç¬¬ä¸€ä¸ª data block çš„åœ°å€ã€‚æ¯ä¸ª data block è‡ªå·±æœ‰ä¸€ä¸ª next æŒ‡é’ˆå­˜å‚¨ä¸‹ä¸€ä¸ª data block çš„åœ°å€ï¼Œè¿™æ ·ä¹Ÿå¯ä»¥å­˜å‚¨å¤§æ–‡ä»¶ã€‚\næœ´ç´ çš„æƒ³æ³•æ˜¯å°†æ¯ä¸ª data block çš„ next æŒ‡é’ˆå­˜å‚¨åœ¨ data block å†…éƒ¨ã€‚ä½†è¿™æ ·æ–‡ä»¶ç³»ç»Ÿåœ¨ random access çš„ workload ä¸‹è¡¨ç°å¾—ä¼šå¾ˆåï¼šæ³¨æ„åˆ°ç£ç›˜æ˜¯ä¸€ä¸ªå—è®¾å¤‡ï¼Œå¦‚æœæˆ‘ä»¬è¦è®¿é—®ä¸€ä¸ªæ–‡ä»¶å°¾éƒ¨çš„å†…å®¹ï¼Œæˆ‘ä»¬å°±å¿…é¡»é¡ºç€é“¾è¡¨å¾€åæ‰¾ï¼Œè€Œæ¯æ¬¡æˆ‘ä»¬è¦è·å¾—ä¸€ä¸ª next æŒ‡é’ˆéƒ½è¦æŠŠæ•´ä¸ª data block è¯»å‡ºæ¥ï¼Œå¤§é‡çš„ç£ç›˜è¯»å–ä¼šä½¿å¾—è®¿é—®éå¸¸æ…¢ã€‚\nä¸€ä¸ªä¼˜åŒ–æ˜¯æŠŠæ‰€æœ‰çš„ next æŒ‡é’ˆæ”¾åœ¨ä¸€èµ·åšæˆä¸€å¼ è¡¨é›†ä¸­å­˜å‚¨ã€‚è¿™æ ·æˆ‘ä»¬åªè¦å°†è¿™ä¸ª next æŒ‡é’ˆè¡¨ä»ç£ç›˜è¯»è¿›å†…å­˜ï¼Œå°±å¯ä»¥å®šä½ä¸€ä¸ªå¤§æ–‡ä»¶çš„ä»»ä½•ä¸€ä¸ª data block çš„ä½ç½®ï¼Œå†å»ç£ç›˜ä¸­æŠ“å–å¯¹åº”çš„ data block å³å¯ã€‚\nè¿™å°±æ˜¯ FAT çš„ä¸»è¦æ€æƒ³ã€‚\n40.4 Directory Organization åœ¨å¾ˆå¤šæ–‡ä»¶ç³»ç»Ÿä¸­ï¼Œç›®å½•æ–‡ä»¶çš„å†…å®¹å°±æ˜¯ä¸€ç³»åˆ—çš„ (æ–‡ä»¶å, inode) é”®å€¼å¯¹ã€‚ä¸¾ä¸€ä¸ªä¾‹å­ï¼Œæ¯”å¦‚ä¸€ä¸ª inode ä¸º 5 çš„ç›®å½•æ–‡ä»¶ dir ä¸­åŒ…å«äº†æ–‡ä»¶ foo, bar å’Œ foobar_is_a_pretty_longnameï¼Œé‚£ä¹ˆ dir æ–‡ä»¶çš„å†…å®¹å°±å¤§çº¦é•¿è¿™æ ·ï¼š\ninum reclen strlen name 5 12 2 . 2 12 3 .. 12 12 4 foo 13 12 4 bar 24 36 36 foobar_is_a_pretty_longname è¿™é‡Œçš„ strlen è¡¨ç¤ºæ–‡ä»¶åçš„å®é™…é•¿åº¦ (åŒ…æ‹¬æœ«å°¾çš„ \\0)ï¼Œreclen åˆ™è¡¨ç¤ºå½“å‰åˆ†é…ç»™è¿™ä¸ªç›®å½•é¡¹æ–‡ä»¶åçš„é•¿åº¦ (åå­—çš„é•¿åº¦å’Œå¯èƒ½å­˜åœ¨çš„è‹¥å¹²ç©ºé—²ç©ºé—´)ã€‚æ¯ä¸ªç›®å½•æ–‡ä»¶ä¸­éƒ½æœ‰ä¸¤ä¸ªæ–‡ä»¶ï¼š. è¡¨ç¤ºå½“å‰ç›®å½•ï¼Œ.. è¡¨ç¤ºä¸Šä¸€çº§ç›®å½•ã€‚\nå¦‚æœæˆ‘ä»¬åœ¨ä¸€ä¸ªç›®å½•ä¸‹åˆ å»ä¸€ä¸ªæ–‡ä»¶ï¼Œé‚£ä¹ˆå®ƒå¯¹åº”çš„ç›®å½•é¡¹å°±ä¼šè¢«æŒ–ç©ºã€‚é€šå¸¸æˆ‘ä»¬ä¼šä½¿ç”¨ inode 0 æ¥è¡¨ç¤ºè¯¥ç›®å½•é¡¹æ˜¯ç©ºé—²çš„ã€‚åˆ é™¤ä¹Ÿæ˜¯æˆ‘ä»¬ç•™æœ‰ reclen å­—æ®µçš„åŸå› ï¼šæ¯”å¦‚ä¸€ä¸ªé•¿åæ–‡ä»¶è¢«åˆ é™¤åï¼Œä¸€ä¸ªçŸ­åæ–‡ä»¶è¢«åŠ è¿›ç›®å½•ï¼Œé‚£ä¹ˆæ–°æ–‡ä»¶å¯ä»¥å¤ç”¨æ—§æ–‡ä»¶çš„ç›®å½•é¡¹ï¼ŒåŒ…æ‹¬ä¹‹å‰åˆ†é…çš„é•¿æ–‡ä»¶åçš„ç©ºé—´ï¼Œå› æ­¤æ–‡ä»¶ååå¯èƒ½ä¼šæœ‰ç©ºæ ¼ã€‚\nç›®å½•æ–‡ä»¶ä¹Ÿæ˜¯ä¸€ç§æ–‡ä»¶ï¼Œå› æ­¤åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­å®ƒä¹Ÿæœ‰å¯¹åº”çš„ inodeï¼Œä¸Šé¢æè¿°çš„è¿™äº›é”®å€¼å¯¹å°±å­˜åœ¨è¯¥æ–‡ä»¶çš„ data block ä¸­ã€‚å€¼å¾—ä¸€æçš„æ˜¯å¹¶ä¸æ˜¯æ‰€æœ‰æ–‡ä»¶ç³»ç»Ÿéƒ½ä½¿ç”¨è¿™ç§é¡ºåºåˆ—è¡¨çš„æ–¹å¼å­˜å‚¨é”®å€¼å¯¹â€”â€”æ•°æ®ç»“æ„æœ‰å¾ˆå¤šçš„é€‰æ‹©ç©ºé—´ï¼Œæ¯”å¦‚æœ‰çš„æ–‡ä»¶ç³»ç»Ÿä½¿ç”¨ B æ ‘å­˜å‚¨é”®å€¼å¯¹ï¼Œè¿™æ ·å®ƒä»¬åœ¨æœç´¢æ–‡ä»¶åæ—¶å°±å¯ä»¥é¿å…ç©·ä¸¾éå†ã€‚\n40.5 Free Space Management åœ¨ vsfs ä¸­ï¼Œæˆ‘ä»¬ä¸º inode table å’Œ data region å„å‡†å¤‡äº†ä¸€ä¸ª bitmap æ¥è®°å½•æ¯ä¸ª inode/data block æ˜¯å¦å¤„äºç©ºé—²çŠ¶æ€ã€‚åˆ†é…çš„æ—¶å€™ï¼Œæˆ‘ä»¬éå† bitmap å¯»æ‰¾ç©ºé—²çš„ inode/data block å³å¯ã€‚\nåˆ†é…ä¸­ä¹Ÿæœ‰ä¸€äº›â€œèŠ±æ´»â€å¯ä»¥ç©ï¼Œæ¯”å¦‚ ext2/ext3 æ–‡ä»¶ç³»ç»Ÿä¸­ï¼Œå½“ä¸€ä¸ªæ–°æ–‡ä»¶è¢«åˆ›å»ºä¸”éœ€è¦æ•°æ®å—æ—¶ï¼Œæ–‡ä»¶ç³»ç»Ÿä¼šå»å¯»æ‰¾ç©ºé—²çš„è¿ç»­æ•°æ®å— (8 ä¸ªæˆ–æ›´å¤š)ï¼Œè¿™æ ·æ–‡ä»¶åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­å­˜å‚¨çš„æ›´åŠ è¿ç»­ï¼Œæœ‰åŠ©äºæå‡æ€§èƒ½ã€‚\n40.6 Access Paths: Reading and Writing Reading A File From Disk æˆ‘ä»¬é¦–å…ˆè€ƒè™‘è¿™æ ·ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨ï¼šopen(\u0026quot;/foo/bar\u0026quot;, O_RDONLY)ã€‚æˆ‘ä»¬çš„ç›®æ ‡æ˜¯æ‰¾åˆ° bar æ–‡ä»¶çš„ inodeï¼Œä½†è¿™æ˜¯æ— æ³•ç›´æ¥åšåˆ°çš„ï¼Œå› æ­¤æˆ‘ä»¬å¿…é¡»å¾—é€šè¿‡æ–‡ä»¶åä¸€å±‚ä¸€å±‚åœ°å»æ‰¾ã€‚ä¸€ä¸ªæ–‡ä»¶çš„ inode ç¼–å·å­˜æ”¾åœ¨å®ƒçš„çˆ¶ç›®å½•çš„æ–‡ä»¶å†…å®¹ä¸­ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦å»è¯»å– /foo ç›®å½•æ–‡ä»¶çš„å†…å®¹ï¼Œä»è€Œéœ€è¦å…¶ inode ç¼–å·ï¼Œå†å‘ä¸Šæˆ‘ä»¬éœ€è¦ / ç›®å½•æ–‡ä»¶çš„å†…å®¹ï¼Œä»¥åŠ / çš„ inode ç¼–å·ã€‚\næ ¹ç›®å½•æ²¡æœ‰çˆ¶ç›®å½•ï¼Œå› æ­¤æ ¹ç›®å½•æ–‡ä»¶çš„ inode ç¼–å·å¿…é¡»è¢«æ˜¾å¼æˆ–éšå¼åœ°è§„å®šã€‚åœ¨ç»å¤§å¤šæ•°çš„ UNIX æ–‡ä»¶ç³»ç»Ÿä¸­ï¼Œæ ¹ç›®å½•æ–‡ä»¶çš„ inode ç¼–å·éƒ½æ˜¯ 2ã€‚å› æ­¤æ•´ä¸ªè¿‡ç¨‹å¦‚ä¸‹ï¼š\nè¯»å–æ ¹ç›®å½•çš„ inode 2ï¼Œæ ¹æ® inode ä¸­çš„æŒ‡é’ˆæ‰¾åˆ°æ ¹ç›®å½•æ–‡ä»¶å†…å®¹ï¼Œä»ç›®å½•é¡¹ä¸­æ‰¾åˆ° /foo æ–‡ä»¶çš„ inode å·ã€‚ è¯»å– /foo çš„ inodeï¼Œæ ¹æ® inode ä¸­çš„æŒ‡é’ˆæ‰¾åˆ° /foo æ–‡ä»¶å†…å®¹ï¼Œä»ç›®å½•é¡¹ä¸­æ‰¾åˆ° /foo/bar çš„ inode å·ã€‚ è¯»å– /foo/bar çš„ inodeï¼Œè¿›è¡Œä¸€ç³»åˆ—æƒé™æ£€æŸ¥ï¼Œè¿”å›ç»™å½“å‰è¿›ç¨‹ä¸€ä¸ªæŒ‡å‘ /foo/bar çš„æ–‡ä»¶æè¿°ç¬¦ã€‚ æ‰“å¼€æ–‡ä»¶åï¼Œç¨‹åºå°±å¯ä»¥é€šè¿‡ read() ç³»ç»Ÿè°ƒç”¨æ¥è¯»å–æ–‡ä»¶å†…å®¹ã€‚å¯¹äºä¸€æ¬¡ read() ç³»ç»Ÿè°ƒç”¨ï¼Œæ–‡ä»¶ç³»ç»Ÿé¦–å…ˆè¦è¯»å– inodeï¼Œæ ¹æ® read çš„ offset æ‰¾åˆ°å¯¹åº” data block çš„åœ°å€ï¼Œç„¶åè¯»å–å¯¹åº”çš„ data blockï¼Œæœ€åè¿˜è¦ä¿®æ”¹æ–‡ä»¶çš„ inodeï¼Œæ›´æ–°æœ€è¿‘è®¿é—®æ—¶é—´ç­‰å­—æ®µã€‚åœ¨æ–‡ä»¶ç³»ç»Ÿä¹‹å¤–ï¼Œæ–‡ä»¶æè¿°ç¬¦çš„ offset ä¹Ÿè¦æ›´æ–°ã€‚\nåœ¨æŸä¸ªæ—¶åˆ»ï¼Œè¯¥æ–‡ä»¶ä¼šè¢«å…³é—­ã€‚å…³é—­æ–‡ä»¶éœ€è¦é‡Šæ”¾æ‰å¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œä¸è¿‡è¿™ä¸æ˜¯æ–‡ä»¶ç³»ç»Ÿå±‚é¢çš„åŠ¨ä½œï¼Œclose() çš„æ—¶å€™æ²¡æœ‰ä»»ä½•çš„ disk I/O æ“ä½œã€‚\nä¸‹å›¾å±•ç¤ºäº†æ•´ä¸ªè¿‡ç¨‹å„éƒ¨åˆ†æ•°æ®çš„è¯»å†™æƒ…å†µï¼š\nWriting A File To Disk å†™å…¥çš„è¿‡ç¨‹å’Œè¯»å–çš„è¿‡ç¨‹åŸºæœ¬ç±»ä¼¼ï¼Œä½†å†™å…¥æ›´éº»çƒ¦çš„åœ°æ–¹åœ¨äºæˆ‘ä»¬æœ‰æ—¶å€™è¦åˆ†é…æ–°çš„ inode/data blockï¼Œå› æ­¤è¿˜è¦è¯»å†™ bitmapã€‚é€šå¸¸æ¥è¯´åœ¨æ–‡ä»¶å·²ç»æ‰“å¼€çš„æƒ…å†µä¸‹ï¼Œä¸€æ¬¡ write æ“ä½œè¦å¯¹åº” 5 æ¬¡ç£ç›˜ I/O æ“ä½œï¼šä¸€æ¬¡è¯»å–æ•°æ®åŒºçš„ bitmap (å¯»æ‰¾å¯ç”¨æ•°æ®å—)ï¼Œä¸€æ¬¡å†™å…¥æ•°æ®åŒºçš„ bitmap (æ›´æ–°ä½¿ç”¨æƒ…å†µ)ï¼Œè¯»å–å’Œå†™å…¥è¯¥æ–‡ä»¶çš„ inodeï¼Œä»¥åŠå¯¹æ•°æ®å—çš„å†™å…¥ã€‚\nå¦‚æœæˆ‘ä»¬è€ƒè™‘æ–‡ä»¶çš„åˆ›å»ºï¼Œæ¶‰åŠåˆ°çš„ disk I/O æ¬¡æ•°åˆ™æ›´å¤šï¼šåˆ›å»ºæ–‡ä»¶æ—¶æˆ‘ä»¬è¦ä¸ºæ–‡ä»¶åˆ›å»º inodeï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦è¯»å†™ inode çš„ bitmapï¼›æˆ‘ä»¬è¦åˆå§‹åŒ–æ–°åˆ†é…çš„ inodeï¼Œå› æ­¤éœ€è¦å†™å…¥æ–°æ–‡ä»¶çš„ inodeï¼›æˆ‘ä»¬éœ€è¦æ›´æ–°è¯¥æ–‡ä»¶çš„çˆ¶ç›®å½•çš„é”®å€¼å¯¹ï¼Œå› æ­¤æˆ‘ä»¬è¦ä¿®æ”¹çˆ¶ç›®å½•çš„ data blockï¼Œä»è€Œè¿˜è¦è¯»å†™çˆ¶ç›®å½•æ–‡ä»¶çš„ inodeã€‚å¦‚æœçˆ¶ç›®å½•æ–‡ä»¶çš„ data block å®¹é‡ä¸è¶³ï¼Œæˆ‘ä»¬è¿˜è¦ä¸ºçˆ¶ç›®å½•æ–‡ä»¶åˆ†é…æ–°çš„ data blockï¼Œè¿™åˆè¦æ¶‰åŠæ•°æ®åŒº bitmap çš„è¯»å†™â€¦â€¦\nç”±æ­¤æˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œæ–‡ä»¶ç³»ç»Ÿ disk I/O çš„æ¬¡æ•°éå¸¸å¤šï¼Œè´Ÿæ‹…å¾ˆé‡ï¼Œæˆ‘ä»¬éœ€è¦æƒ³åŠæ³•è®©é¢‘ç¹çš„ I/O æ›´åŠ é«˜æ•ˆã€‚\n40.7 Caching and Buffering ä¸ºäº†ç¼“è§£æ–‡ä»¶ç³»ç»Ÿå¤§é‡çš„ç£ç›˜ I/O å¼€é”€ï¼Œå¤§å¤šæ•°æ–‡ä»¶ç³»ç»Ÿä½¿ç”¨å†…å­˜ä½œä¸ºç£ç›˜çš„ cacheï¼Œåœ¨å†…å­˜ä¸­ä¿å­˜ä¸€äº›å¸¸ç”¨çš„/é‡è¦çš„ blockã€‚æ—©æœŸçš„æ–‡ä»¶ç³»ç»Ÿä½¿ç”¨å›ºå®šå¤§å°çš„ cacheï¼Œé€šå¸¸æ˜¯ DRAM çš„ 10%ï¼Œè¿™ç§é™æ€åˆ†åŒºçš„åšæ³•ä¸å¤ªé«˜æ•ˆâ€”â€”å½“å‰ç©ºé—²çš„æ–‡ä»¶ç³»ç»Ÿ cache slot æ— æ³•ä½œä¸ºå…¶ä»–ä¸œè¥¿ä½¿ç”¨ã€‚å› æ­¤ç°ä»£çš„æ–‡ä»¶ç³»ç»Ÿé‡‡ç”¨ dynamic partitioning çš„æ–¹æ³•ï¼ŒæŠŠè™šæ‹Ÿå†…å­˜çš„é¡µé¢å’Œæ–‡ä»¶ç³»ç»Ÿçš„é¡µé¢æ”¾åœ¨ä¸€èµ·ç»Ÿä¸€ç®¡ç†ã€‚\nUnderstand Static VS. Dynamic Partitioning\nå½“æˆ‘ä»¬å°†èµ„æºåˆ†æˆè‹¥å¹²ç§ä¸åŒç”¨é€”çš„æ—¶å€™ï¼Œæˆ‘ä»¬é€šå¸¸æœ‰é™æ€å’ŒåŠ¨æ€ä¸¤ç§æ–¹æ³•ã€‚é™æ€æ–¹æ³•æå‰å°†èµ„æºåˆ’åˆ†æˆå›ºå®šçš„æ¯”ä¾‹ï¼Œæ¯ç§ç”¨é€”å–ä¸€ä»½ï¼›åŠ¨æ€æ–¹æ³•åˆ™æ ¹æ®å½“å‰çš„ workload åŠ¨æ€è°ƒæ•´æ¯ç§ç”¨é€”çš„ä½¿ç”¨é‡ã€‚é™æ€å®ç°ç®€å•ï¼Œæ•ˆç‡æ›´ç¨³å®šï¼›è€ŒåŠ¨æ€å¯ä»¥è¾¾åˆ°æ›´å¥½çš„èµ„æºåˆ©ç”¨ç‡ï¼Œä½†å®ç°èµ·æ¥æ¯”è¾ƒå¤æ‚ã€‚ä¸¤è€…å„æœ‰åƒç§‹ã€‚\nç®€å•åˆ†æ caching å¯¹äºæ–‡ä»¶ç³»ç»Ÿè¯»å†™çš„å¥½å¤„ï¼šåœ¨è¯»å–æ–¹é¢ï¼Œå¦‚æœæˆ‘ä»¬éå†ä¸€ä¸ªç›®å½•ä¸‹çš„æ‰€æœ‰æ–‡ä»¶ï¼Œé‚£ä¹ˆç›®å½•æ–‡ä»¶ä»¥åŠå…¶ inode å°±å¯ä»¥ä¸€ç›´æ”¾åœ¨ cache ä¸­ä¾›è¯»å–ï¼ŒèŠ‚çœäº†å¾ˆå¤š I/O æ“ä½œï¼›åœ¨å†™å…¥æ–¹é¢ï¼Œwrite buffering å¸¦æ¥çš„å»¶è¿Ÿå†™å…¥å¯ä»¥å°†å¤šæ¬¡æ“ä½œ batch åœ¨ä¸€èµ·ï¼Œå‡å°‘ I/O æ¬¡æ•° (æ¯”å¦‚åˆ›å»ºæ–‡ä»¶å†åˆ é™¤=ä»€ä¹ˆéƒ½ä¸ç”¨åš)ï¼Œç³»ç»Ÿè¿˜å¯ä»¥è°ƒåº¦å¤šæ¬¡å†™å…¥çš„é¡ºåºä»¥è·å¾—æ›´å¥½çš„æ•ˆç‡ã€‚\nDurability/Performance Trade-Off\nå­˜å‚¨ç³»ç»Ÿé€šå¸¸é¢ä¸´ durability/performance trade-offã€‚å¦‚æœç”¨æˆ·å¸Œæœ›å†™å…¥çš„æ•°æ®èƒ½ç«‹åˆ»å˜å¾—æŒä¹…ï¼Œé‚£ä¹ˆæ–‡ä»¶ç³»ç»Ÿå°±å¿…é¡»å°†æ–°æ•°æ®ç«‹åˆ»è½ç›˜ï¼Œä½†è¿™æ ·ä¼šå¾ˆæ…¢ï¼›å¦‚æœç”¨æˆ·å¯ä»¥å¿å—å°é‡çš„æ•°æ®ä¸¢å¤±ï¼Œé‚£ä¹ˆæ–‡ä»¶ç³»ç»Ÿå°±å¯ä»¥å°†æ•°æ®åœ¨å†…å­˜ä¸­æ”¾ä¸€ä¼šå„¿ï¼Œæ¯éš”ä¸€æ®µæ—¶é—´è½ç›˜ä¸€æ¬¡ï¼Œè¿™æ ·æ•ˆç‡ä¼šæœ‰æ˜æ˜¾æå‡ã€‚è‡³äºå¦‚ä½•åœ¨ trade-off ä¸­é€‰æ‹©ï¼Œè¿™ä¸ç”¨æˆ·éœ€æ±‚æ¯æ¯ç›¸å…³ã€‚\nä¸€äº›åº”ç”¨ (æ¯”å¦‚æ•°æ®åº“) ä¸å–œæ¬¢è¿™ç§ trade-offï¼Œå› æ­¤å®ƒä»¬ä¼šé€šè¿‡ä½¿ç”¨ fsync()ï¼Œæˆ–è€…è·³è¿‡æ–‡ä»¶ç³»ç»Ÿå±‚ç›´æ¥ä½¿ç”¨ç£ç›˜ I/O API ç­‰æ–¹å¼æ¥å¼ºåˆ¶è½ç›˜ã€‚å®ƒä»¬ç‰ºç‰²äº†æ•ˆç‡ä½†è·å¾—äº†ç¨³å®šæ€§ã€‚\n40.8 Summary ç•¥ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"1cc8ca04bb0b1f758ba671289ccfae03","permalink":"https://kristoff-starling.github.io/notes/booknotes/ostep/ch40/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/booknotes/ostep/ch40/","section":"notes","summary":"æ–‡ä»¶ç³»ç»Ÿæ˜¯ä¸€ä¸ªçº¯ç²¹çš„è½¯ä»¶ï¼Œå› æ­¤åœ¨æœ¬ç« èŠ‚ä¸­æˆ‘ä»¬ä¸è€ƒè™‘åŠ å…¥ä»»ä½•çš„ç¡¬ä»¶ feature ä½¿æ–‡ä»¶ç³»ç»Ÿå·¥ä½œå¾—æ›´å¥½ (å½“ç„¶æˆ‘ä»¬è¿˜æ˜¯ä¼šæ³¨æ„å—è®¾å¤‡æœ¬èº«çš„ç‰¹æ€§)ã€‚æ–‡ä»¶ç³»ç»Ÿè®¾è®¡æœ¬èº«æœ‰å¾ˆå¤§çš„å¼¹æ€§ï¼Œå› æ­¤ç°å­˜çš„æ–‡ä»¶ç³»ç»Ÿå¾ˆå¤šï¼Œå®ƒä»¬ä½¿ç”¨ä¸åŒçš„æ•°æ®ç»“æ„ï¼Œåœ¨å„æ–¹é¢çš„è¡¨ç°ä¹Ÿå„æœ‰åƒç§‹ã€‚\n40.1 The Way To Think è®¾è®¡æ–‡ä»¶ç³»ç»Ÿæˆ‘ä»¬é€šå¸¸è€ƒè™‘ä¸¤ä»¶äº‹æƒ…ï¼š\næ•°æ®ç»“æ„ï¼šæˆ‘ä»¬å‡†å¤‡ä½¿ç”¨ä»€ä¹ˆæ•°æ®ç»“æ„æ¥ç»„ç»‡ç£ç›˜ä¸Šçš„æ•°æ®å’Œå…ƒæ•°æ®ï¼Ÿåœ¨ç®€å•çš„æ–‡ä»¶ç³»ç»Ÿå®ç°ä¸­æˆ‘ä»¬é€šå¸¸ä½¿ç”¨ç®€å•çš„å—é“¾è¡¨ï¼Œåœ¨ä¸€äº›æ¯”è¾ƒç²¾å¯†çš„æ–‡ä»¶ç³»ç»Ÿå®ç°ä¸­ä¹Ÿæœ‰ä½¿ç”¨æ ‘çŠ¶ç»“æ„çš„ã€‚ è®¿é—®æ–¹å¼ï¼šè¿›ç¨‹ä½¿ç”¨çš„ open(), read(), write() ç­‰å‡½æ•°è¯¥å¦‚ä½•å¯¹åº”åˆ°æ–‡ä»¶ç³»ç»Ÿçš„ç»“æ„ä¸Šï¼Ÿå¯¹äºä¸€ä¸ªç‰¹å®šçš„ç³»ç»Ÿè°ƒç”¨ï¼Œå“ªäº›æ•°æ®éœ€è¦è¢«è¯»å†™ï¼Ÿæ¯ä¸€æ­¥çš„æ•ˆç‡å¦‚ä½•ï¼Ÿ 40.2 Overall Organization vsfs (very simple file systemï¼Œä¸€ä¸ª UNIX æ–‡ä»¶ç³»ç»Ÿçš„ç²¾ç®€ç‰ˆæœ¬) çš„ç»“æ„å¦‚ä¸‹ï¼š\næ•´ä¸ªç£ç›˜è¢«åˆ’åˆ†æˆ 64 ä¸ª blockï¼Œæ¯ä¸ª block çš„å¤§å°æ˜¯ 4KBã€‚","tags":null,"title":"Chapter 40: File System Implementation","type":"docs"},{"authors":null,"categories":null,"content":"Problem 1.1 è§£ï¼š(1) $A_1\\cap \\overline{A_2}\\cap \\overline{A_3}$ã€‚\n(2) $A_1\\cup A_2\\cup A_3$ã€‚\n(3) $(A_1\\cap \\overline{A_2}\\cap \\overline{A_3})\\cup (\\overline{A_1}\\cap A_2\\cap \\overline{A_3})\\cup (\\overline{A_1}\\cap \\overline{A_2}\\cap A_3)\\cup (\\overline{A_1}\\cap \\overline{A_2}\\cap \\overline{A_3})$ã€‚\n(4) $\\overline{A_1\\cap A_2\\cap A_3}$ã€‚\n(5) $(A_1\\cap A_2)\\cup(A_1\\cap A_3)\\cup (A_2\\cap A_3)$ã€‚\nProblem 1.3 è§£ï¼š $$ P=\\frac{\\binom{10}{4}\\binom{4}{3}\\binom{3}{2}}{\\binom{17}{9}}=\\frac{252}{2431}ã€‚ $$\nProblem 1.7 è§£ï¼š $$ P=\\frac{9^n-5^n-8^n+4^n}{9^n}=1-\\frac{5^n+ 8^n-4^n}{9^n} $$\nProblem 1.10 è§£ï¼šè®°ç¬¬ä¸€å¤©ä¸‹é›¨ä¸ºäº‹ä»¶ $A$ï¼Œç¬¬äºŒå¤©ä¸‹é›¨ä¸ºäº‹ä»¶ $B$ã€‚\n(1) $P(è‡³å°‘æœ‰ä¸€å¤©ä¸‹é›¨)=P(A\\cup B)=P(A)+P(B)-P(A\\cap B)=0.6+0.3-0.1=0.8$ã€‚\n(2) $P(ä¸¤å¤©éƒ½ä¸ä¸‹é›¨)=P(\\overline{A}\\cap \\overline{B})=P(\\Omega)-P(A\\cup B)=1-0.8=0.2$ã€‚\n(3) $P(è‡³å°‘æœ‰ä¸€å¤©ä¸ä¸‹é›¨)=P(\\overline{A}\\cup \\overline{B})=P(\\Omega)-P(A\\cap B)=1-0.1=0.9$ã€‚\n(4) $P(ç¬¬ä¸€å¤©ä¸‹é›¨ä¸”ç¬¬äºŒå¤©ä¸ä¸‹é›¨)=P(A\\cap \\overline{B})=P(A)-P(AB)=0.6-0.1=0.5$ã€‚\n(5) $P(æ°å¥½ä¸€å¤©ä¸‹é›¨)=P(A)+P(B)-2P(AB)=0.6+0.3-0.1-0.1=0.7$ã€‚\nProblem 1.13 è§£ï¼šå®¹æ˜“å‘ç°ä¸‰æ¡æŠ˜çº¿èƒ½æ„æˆä¸‰è§’å½¢ $\\Leftrightarrow$ ä¸‰æ¡æŠ˜çº¿çš„é•¿åº¦å‡å°äº $a$ã€‚\nè®¾ç¬¬ä¸€å¤„æŠ˜ç‚¹è·ç¦»çº¿æ®µå·¦ç«¯ç‚¹çš„è·ç¦»ä¸º $x$ï¼Œç¬¬äºŒå¤„æŠ˜ç‚¹è·ç¦»çº¿æ®µå·¦ç«¯ç‚¹çš„è·ç¦»ä¸º $y$ï¼Œåˆ™ä¸Šè¿°çº¦æŸå¯ä»¥è¢«ç¿»è¯‘ä¸ºï¼š $$ \\begin{cases} x\u0026lt;y\\\\ x\u0026lt;a\\\\ y-x\u0026lt;a\\\\ y\u0026gt;a \\end{cases} $$ ç”»å›¾ï¼š\nå®¹æ˜“çœ‹å‡ºï¼Œ$P(èƒ½æ„æˆä¸‰è§’å½¢)=0.25$ã€‚\nProblem 1.15 è§£ï¼š$P(AB)=P(A)P(B|A)=\\frac{1}{4}\\cdot \\frac{1}{3}=\\frac{1}{12}$ï¼Œæ‰€ä»¥ $P(B)=\\frac{P(AB)}{P(A|B)}=\\frac{1}{6}$ã€‚\n$P(\\bar{A}\\bar{B})=P(\\Omega-A\\cup B)=1-(P(A)+P(B)-P(AB))=1-\\frac{1}{4}-\\frac{1}{6}+\\frac{1}{12}=\\frac{2}{3}$ã€‚\nProblem 1.18 è§£ï¼šè®°å–äº†ç”²è½¦é—´äº§å“ä¸ºäº‹ä»¶ $A$ï¼Œä¹™ä¸ºäº‹ä»¶ $B$ï¼Œä¸™ä¸ºäº‹ä»¶ $C$ï¼Œå–åˆ°æ¬¡å“ä¸ºäº‹ä»¶ $D$ã€‚\n(1) $P(D)=P(AD)+P(BD)+P(CD)=0.25\\cdot 0.05+0.35\\cdot 0.04+0.4\\cdot 0.02=0.0345$ã€‚\n(2) $P(A|D)=\\frac{P(AD)}{P(D)}=\\frac{P(A)P(D|A)}{P(D)}=\\frac{0.25\\cdot 0.05}{0.0345}=\\frac{25}{69}$ã€‚\nProblem 1.21 è§£ï¼šä¸€å…±æœ‰ 3 ä¸ªé¢æ˜¯çº¢è‰²çš„ï¼Œè¿™ä¸‰ä¸ªçº¢è‰²çš„é¢ä¸­åªæœ‰ 1 ä¸ªé¢èƒŒåæ˜¯é»„è‰²çš„ï¼Œæ‰€ä»¥ $P=\\frac{1}{3}$ã€‚\nProblem 1.24 è§£ï¼šå› ä¸º $A,B$ ç›¸äº’ç‹¬ç«‹ï¼Œæ‰€ä»¥ $P(AB)=P(A)P(B)$ã€‚æˆ‘ä»¬åˆ—å‡ºæ–¹ç¨‹ï¼š $$ \\begin{cases} P(A)-P(A)P(B)\u0026amp;=\\frac{5}{9}\\\\ P(A)+P(B)-P(A)P(B)\u0026amp;=\\frac{8}{9}\\\\ 0\\leq P(A),P(B)\\leq 1 \\end{cases} $$ è§£å¾— $$ \\begin{cases} P(A)=\\frac{5}{6}\\\\ P(B)=\\frac{1}{3} \\end{cases} $$ ç»¼ä¸Šï¼Œ$P(A)=\\frac{5}{6}$ã€‚\nProblem 1.29 è§£ï¼š$P(A)=\\frac{3}{6}=\\frac{1}{2},P(B)=\\frac{3}{6}=\\frac{1}{2},P(C)=\\frac{18}{36}=\\frac{1}{2}$ã€‚\næ˜¾ç„¶ $P(ABC)=0\\neq P(A)P(B)P(C)$ã€‚\nä½† $$ \\begin{align} P(AB)\u0026amp;=\\frac{3\\times 3}{6\\times 6}=\\frac{1}{4}=P(A)P(B)\\\\ P(AC)\u0026amp;=P(A\\cap \\overline{B})=\\frac{9}{36}=\\frac{1}{4}=P(A)P(C)\\\\ P(BC)\u0026amp;=P(B\\cap \\overline{A})=\\frac{9}{36}=\\frac{1}{4}=P(B)P(C) \\end{align} $$ æ‰€ä»¥è¿™ä¸‰ä¸ªäº‹ä»¶ä¸¤ä¸¤ç‹¬ç«‹ï¼Œä½†ä¸ç›¸äº’ç‹¬ç«‹ã€‚\nProblem 1.32 è§£ï¼šè®°ä¸¤äººå‘½ä¸­æ•°ä¸€æ ·ä¸ºäº‹ä»¶ $A$ï¼Œä¸¤äººéƒ½ä¸­ $i$ çƒä¸ºäº‹ä»¶ $B_i$ï¼Œåˆ™ $$ \\begin{align} P(A)\u0026amp;=P(A|B_0)+P(A|B_1)+P(A|B_2)\\\\ \u0026amp;=\\left(\\frac{1}{3}\\right)^2\\left(\\frac{2}{3}\\right)^2+\\frac{4}{9}\\cdot \\frac{4}{9}+\\left(\\frac{2}{3}\\right)^2\\left(\\frac{1}{3}\\right)^2\\\\ \u0026amp;=\\frac{8}{27} \\end{align} $$\nProblem 1.34 è§£ï¼šè®°ä¸€ä¸ªäººè’™åŠæ ¼ä¸ºäº‹ä»¶ $A$ã€‚\n(1) $$ P(A)=\\sum_{k=3}^5\\binom{5}{k}\\left(\\frac{1}{4}\\right)^k\\left(\\frac{3}{4}\\right)^{5-k}=\\frac{53}{512} $$ (2) $$ \\begin{align} P(è‡³å°‘ä¸¤äººè’™åŠæ ¼)\u0026amp;=1-P(è‡³å¤šä¸€äººè’™åŠæ ¼)\\\\ \u0026amp;=1-\\sum_{k=0}^1\\binom{5}{k}P(A)^k(1-P(A))^{5-k}\\\\ \u0026amp;=0.0866 \\end{align} $$\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"2ffb0bdb9708704a9494543b65315b37","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-probability/hw1/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-probability/hw1/","section":"notes","summary":"Problem 1.1 è§£ï¼š(1) $A_1\\cap \\overline{A_2}\\cap \\overline{A_3}$ã€‚\n(2) $A_1\\cup A_2\\cup A_3$ã€‚\n(3) $(A_1\\cap \\overline{A_2}\\cap \\overline{A_3})\\cup (\\overline{A_1}\\cap A_2\\cap \\overline{A_3})\\cup (\\overline{A_1}\\cap \\overline{A_2}\\cap A_3)\\cup (\\overline{A_1}\\cap \\overline{A_2}\\cap \\overline{A_3})$ã€‚\n(4) $\\overline{A_1\\cap A_2\\cap A_3}$ã€‚\n(5) $(A_1\\cap A_2)\\cup(A_1\\cap A_3)\\cup (A_2\\cap A_3)$ã€‚","tags":null,"title":"Homework 1","type":"docs"},{"authors":null,"categories":null,"content":"Problem 2.1 è§£ï¼š $$ \\begin{align} P(X=1)\u0026amp;=\\frac{\\binom{4}{3}\\cdot 6}{4^3}=\\frac{3}{8}\\\\ P(X=2)\u0026amp;=\\frac{\\binom{3}{2}\\binom{4}{2}\\cdot 2}{4^3}=\\frac{9}{16}\\\\ P(X=3)\u0026amp;=\\frac{4}{4^3}=\\frac{1}{16} \\end{align} $$ ç»¼ä¸Šï¼Œ$X$ çš„åˆ†å¸ƒåˆ—ä¸º\n$X$ $1$ $2$ $3$ $P(X)$ $\\frac{3}{8}$ $\\frac{9}{16}$ $\\frac{1}{16}$ Problem 2.4 è§£ï¼šå„ä¸ªå¸¸æ•°çš„è®¡ç®—è¿‡ç¨‹å¦‚ä¸‹ï¼š\n$a=\\frac{3}{4}-P(X=-1)=\\frac{1}{2}$ã€‚\n$b=1-P(X=-1)-P(X=0)=\\frac{1}{4}$ã€‚\n$c=P(X\u0026lt;-1)=0$ã€‚\n$d=P(X\u0026lt;0)=P(X=-1)=\\frac{1}{4}$ã€‚\n$e=P(X=-1)+P(X=0)+P(X=1)=1$ã€‚\nProblem 2.8 è§£ï¼š(1) $$ \\begin{align} P(X\\leq 3)\u0026amp;=e^{-\\lambda}\\sum_{k=0}^3\\frac{\\lambda^k}{k!}\\approx 0.7576\\\\ P(è½¬æ¸¯)\u0026amp;=P(X\u0026gt;3)=1-P(X\\leq 3)=0.2424 \\end{align} $$ (2) è€ƒå¯Ÿå‡½æ•° $f(x)=\\frac{2.5^x}{x!},x\\in \\mathbb N$ï¼Œæ˜¾ç„¶å½“ $x=2$ æ—¶ $f(x)$ å–å¾—æœ€å¤§å€¼ã€‚æ‰€ä»¥æœ€å¤§å¯èƒ½åˆ°è¾¾æ¸¯å£çš„æ²¹èˆ¹æ•°ä¸º 2ï¼Œæ¦‚ç‡ä¸º $\\frac{2.5^2}{2}e^{-2.5}\\approx 0.2565$ã€‚\n(3) æ³¨æ„åˆ° $$ \\begin{align} P(X\\leq 4)\u0026amp;=e^{-\\lambda}\\sum_{k=0}^4\\frac{\\lambda^k}{k!}=0.8912\u0026lt;0.9\\\\ P(X\\leq 5)\u0026amp;=e^{-\\lambda}\\sum_{k=0}^5\\frac{\\lambda^k}{k!}=0.9553\\geq 0.9 \\end{align} $$ æ‰€ä»¥æœåŠ¡èƒ½åŠ›æé«˜åˆ° 5 åªæ²¹èˆ¹æ‰èƒ½ä½¿å¾—åˆ°è¾¾æ¸¸èˆ¹ä»¥ $90%$ çš„æ¦‚ç‡å¾—åˆ°æœåŠ¡ã€‚\nProblem 2.12 è§£ï¼š(1) $$ \\int_{-\\infty}^{+\\infty}p(x)dx=\\int_0^1p(x)dx=A\\int_0^1x^3dx=\\left.\\frac{A}{4}x^4\\right|_0^1=\\frac{A}{4}=1 $$ è§£å¾— $A=4$ã€‚\n(2) $$ F(x)=P(X\\leq x)=\\int_{-\\infty}^xp(u)du= \\begin{cases} 0\u0026amp;,x\\leq 1\\\\ x^4\u0026amp;,0\u0026lt;x\\leq 1\\\\ 1\u0026amp;,x\u0026gt;1 \\end{cases} $$ (3) ä»¤ $F(x)=0.5$ï¼Œè§£å¾— $x=(\\frac{1}{2})^{\\frac{1}{4}}$ï¼Œæ‰€ä»¥ $B=\\left(\\frac{1}{2}\\right)^{\\frac{1}{4}}$ã€‚\nProblem 2.16 è§£ï¼šä»¤ $Z=\\frac{X-\\mu}{4},W=\\frac{Y-\\mu}{5}$ï¼Œåˆ™ $Z\\sim N(0,1),W\\sim N(0,1)$ã€‚ $$ \\begin{align} p_1\u0026amp;=P(X\\leq \\mu-4)=P(4Z+\\mu\\leq \\mu-4)=P(Z\\leq -1)=P(Z\\geq 1)\\\\ p_2\u0026amp;=P(Y\\geq \\mu+5)=P(5W+\\mu\\geq \\mu+5)=P(W\\geq 1) \\end{align} $$ åˆ $Z,W$ åˆ†å¸ƒå‡½æ•°ç›¸åŒï¼Œæ‰€ä»¥ $p_1=p_2$ã€‚\nProblem 2.19 è§£ï¼š(1) $Y=2X$ çš„åˆ†å¸ƒå¾‹å¦‚ä¸‹ï¼š\n$Y$ $-4$ $-1$ $0$ $1$ $8$ $P$ $\\frac{1}{8}$ $\\frac{1}{4}$ $\\frac{1}{8}$ $\\frac{1}{6}$ $\\frac{1}{3}$ (2) $Y=X^2$ çš„åˆ†å¸ƒå¾‹å¦‚ä¸‹ï¼š\n$Y$ $0$ $\\frac{1}{4}$ $4$ $16$ $P$ $\\frac{1}{8}$ $\\frac{5}{12}$ $\\frac{1}{8}$ $\\frac{1}{3}$ (3) $Y=\\sin \\left(\\frac{\\pi}{2}X\\right)$ çš„åˆ†å¸ƒå¾‹å¦‚ä¸‹ï¼š\n$Y$ $-\\frac{\\sqrt 2}{2}$ $0$ $\\frac{\\sqrt 2}{2}$ $P$ $\\frac{1}{4}$ $\\frac{7}{12}$ $\\frac{1}{6}$ Problem 2.26 è¯æ˜ï¼š$X$ æœä»å‚æ•°ä¸º 2 çš„æŒ‡æ•°åˆ†å¸ƒï¼Œå³ $$ p_X(x)=\\begin{cases} 2e^{-2x}\u0026amp;,x\\geq 0\\\\ 0\u0026amp;,x\u0026lt;0 \\end{cases} $$ $Y=g(X)=1-e^{-2X}$ï¼Œ$g\u0026rsquo;(x)=-e^{-2x}\\cdot (-2)=2e^{-2x}\u0026gt;0$ï¼Œæ‰€ä»¥ $g(x)$ ä¸¥æ ¼å•è°ƒé€’å¢ä¸”å¤„å¤„å¯å¯¼ã€‚å› æ­¤ $$ \\begin{align} p_Y(y)\u0026amp;=p_X(g^{-1}(y))\\cdot \\left|g^{-1}(y)\\right|\\\\ \u0026amp;=\\frac{1}{2(1-y)}p_X(-\\frac{1}{2}\\ln(1-y))\\\\ \u0026amp;= \\begin{cases} 1\u0026amp;,0\\leq x\\leq 1\\\\ 0\u0026amp;, otherwise \\end{cases} \\end{align} $$ å¯ä»¥çœ‹åˆ°åœ¨ $[0,1]$ ä¸­ï¼Œ$p_Y(y)=1=\\frac{1}{1-0}$ï¼Œæ‰€ä»¥ $Y$ åœ¨ $[0,1]$ ä¸Šæœä»å‡åŒ€åˆ†å¸ƒã€‚$\\blacksquare$\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"438f7c5e77431f0a481c0bcf37d8f9f9","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-probability/hw2/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-probability/hw2/","section":"notes","summary":"Problem 2.1 è§£ï¼š $$ \\begin{align} P(X=1)\u0026amp;=\\frac{\\binom{4}{3}\\cdot 6}{4^3}=\\frac{3}{8}\\\\ P(X=2)\u0026amp;=\\frac{\\binom{3}{2}\\binom{4}{2}\\cdot 2}{4^3}=\\frac{9}{16}\\\\ P(X=3)\u0026amp;=\\frac{4}{4^3}=\\frac{1}{16} \\end{align} $$ ç»¼ä¸Šï¼Œ$X$ çš„åˆ†å¸ƒåˆ—ä¸º\n$X$ $1$ $2$ $3$ $P(X)$ $\\frac{3}{8}$ $\\frac{9}{16}$ $\\frac{1}{16}$ Problem 2.4 è§£ï¼šå„ä¸ªå¸¸æ•°çš„è®¡ç®—è¿‡ç¨‹å¦‚ä¸‹ï¼š\n$a=\\frac{3}{4}-P(X=-1)=\\frac{1}{2}$ã€‚\n$b=1-P(X=-1)-P(X=0)=\\frac{1}{4}$ã€‚\n$c=P(X\u0026lt;-1)=0$ã€‚\n$d=P(X\u0026lt;0)=P(X=-1)=\\frac{1}{4}$ã€‚\n$e=P(X=-1)+P(X=0)+P(X=1)=1$ã€‚","tags":null,"title":"Homework 2","type":"docs"},{"authors":null,"categories":null,"content":"Questions Letâ€™s examine a simple program, â€œloop.sâ€. First, just read and understand it. Then, run it with these arguments (./x86.py -p loop.s -t 1 -i 100 -R dx) This specifies a single thread, an interrupt every 100 instructions, and tracing of register %dx. What will %dx be during the run? Use the -c flag to check your answers; the answers, on the left, show the value of the register (or memory value) after the instruction on the right has run. Same code, different flags: (./x86.py -p loop.s -t 2 -i 100 -a dx=3,dx=3 -R dx) This specifies two threads, and initializes each %dx to 3. What values will %dx see? Run with -c to check. Does the presence of multiple threads affect your calculations? Is there a race in this code? Run this: ./x86.py -p loop.s -t 2 -i 3 -r -a dx=3,dx=3 -R dx This makes the interrupt interval small/random; use different seeds (-s) to see different interleavings. Does the interrupt frequency change anything? Now, a different program, looping-race-nolock.s, which accesses a shared variable located at address 2000; weâ€™ll call this variable value. Run it with a single thread to confirm your understanding: ./x86.py -p looping-race-nolock.s -t 1 -M 2000 What is value (i.e., at memory address 2000) throughout the run? Use -c to check. Run with multiple iterations/threads: ./x86.py -p looping-race-nolock.s -t 2 -a bx=3 -M 2000 Why does each thread loop three times? What is final value of value? Run with random interrupt intervals: ./x86.py -p looping-race-nolock.s -t 2 -M 2000 -i 4 -r -s 0 with different seeds (-s 1, -s 2, etc.) Can you tell by looking at the thread interleaving what the final value of value will be? Does the timing of the interrupt matter? Where can it safely occur? Where not? In other words, where is the critical section exactly? Now examine fixed interrupt intervals: ./x86.py -p looping-race-nolock.s -a bx=1 -t 2 -M 2000 -i 1 What will the final value of the shared variable value be? What about when you change -i 2, -i 3, etc.? For which interrupt intervals does the program give the â€œcorrectâ€ answer? Run the same for more loops (e.g., set -a bx=100). What interrupt intervals (-i) lead to a correct outcome? Which intervals are surprising? One last program: wait-for-me.s. Run: ./x86.py -p wait-for-me.s -a ax=1,ax=0 -R ax -M 2000 This sets the %ax register to 1 for thread 0, and 0 for thread 1, and watches %ax and memory location 2000. How should the code behave? How is the value at location 2000 being used by the threads? What will its final value be? Now switch the inputs: ./x86.py -p wait-for-me.s -a ax=0,ax=1 -R ax -M 2000 How do the threads behave? What is thread 0 doing? How would changing the interrupt interval (e.g., -i 1000, or perhaps to use random intervals) change the trace outcome? Is the program efficiently using the CPU? Solutions %dx å¯„å­˜å™¨åˆå§‹å€¼ä¸º 0ï¼Œæ‰§è¡Œä¸€æ¬¡ sub æŒ‡ä»¤åå˜ä¸º -1ï¼Œéšåè·³å‡ºå¾ªç¯ã€‚\n%dx ä» 3 å¼€å§‹æ¯åšä¸€æ¬¡å¾ªç¯ -1,ç›´åˆ°å˜ä¸ºè´Ÿæ•°åé€€å‡ºã€‚ä¸¤ä¸ªçº¿ç¨‹çš„è¡Œä¸ºæ˜¯å®Œå…¨ä¸€æ ·çš„ã€‚å¤šçº¿ç¨‹æ²¡æœ‰å½±å“è®¡ç®—ï¼Œè¿™é‡Œæ²¡æœ‰å‡ºç°ç«äº‰æ¡ä»¶ã€‚\nä¸­æ–­çš„é¢‘ç‡ä¸ä¼šå¯¹çº¿ç¨‹è¡Œä¸ºäº§ç”Ÿä»»ä½•å½±å“ã€‚loop.s ä¸­åªæœ‰é’ˆå¯¹å¯„å­˜å™¨çš„è¡Œä¸ºï¼Œä¸åŒçº¿ç¨‹çš„å¯„å­˜å™¨ä¹‹é—´æ˜¯äº’ç›¸ç‹¬ç«‹çš„ã€‚\nå¾ªç¯åªåšäº†ä¸€æ¬¡ï¼Œåœ°å€ 2000 å¤„æœ€ç»ˆæ•°å€¼ä¸º 1ã€‚\n%bx å¯„å­˜å™¨çš„åˆå§‹å€¼ä¸º 3ï¼Œæ‰€ä»¥æ¯ä¸ªçº¿ç¨‹åšä¸‰æ¬¡å¾ªç¯ï¼Œæœ€ç»ˆåœ°å€ 2000 å¤„çš„å€¼ä¸º 6ã€‚\nä½¿ç”¨ 0 å’Œ 2 åšç§å­å¯ä»¥å¾—åˆ°æ­£ç¡®çš„ç»“æœ 2ï¼Œå› ä¸ºä¸¤ä¸ªçº¿ç¨‹ä¸´ç•ŒåŒºåŸŸçš„ä»£ç æ²¡æœ‰äº¤å‰ï¼š\n# seed = 0 2000 bx Thread 0 Thread 1 0 0 0 0 1000 mov 2000, %ax 0 0 1001 add $1, %ax 1 0 1002 mov %ax, 2000 1 -1 1003 sub $1, %bx 1 0 ------ Interrupt ------ ------ Interrupt ------ 1 0 1000 mov 2000, %ax 1 0 1001 add $1, %ax 2 0 1002 mov %ax, 2000 2 -1 1003 sub $1, %bx 2 -1 ------ Interrupt ------ ------ Interrupt ------ 2 -1 1004 test $0, %bx 2 -1 1005 jgt .top 2 -1 ------ Interrupt ------ ------ Interrupt ------ 2 -1 1004 test $0, %bx 2 -1 1005 jgt .top 2 -1 ------ Interrupt ------ ------ Interrupt ------ 2 -1 1006 halt 2 -1 ----- Halt;Switch ----- ----- Halt;Switch ----- 2 -1 1006 halt ä½¿ç”¨ 1 åšç§å­ä¼šå¾—åˆ°é”™è¯¯çš„ç»“æœ 1ï¼Œå› ä¸ºä¸¤ä¸ªçº¿ç¨‹çš„ä¸´ç•ŒåŒºåŸŸå‡ºç°äº†äº¤å‰ (ç¬¬ä¸€ä¸ªçº¿ç¨‹åšäº†ç¬¬ä¸€æ¡æŒ‡ä»¤ååˆ‡æ¢åˆ°äº†ç¬¬äºŒä¸ªçº¿ç¨‹)ã€‚\n2000 bx Thread 0 Thread 1 0 0 0 0 1000 mov 2000, %ax 0 0 ------ Interrupt ------ ------ Interrupt ------ 0 0 1000 mov 2000, %ax 0 0 1001 add $1, %ax 1 0 1002 mov %ax, 2000 1 -1 1003 sub $1, %bx 1 0 ------ Interrupt ------ ------ Interrupt ------ 1 0 1001 add $1, %ax 1 0 1002 mov %ax, 2000 1 -1 1003 sub $1, %bx 1 -1 1004 test $0, %bx 1 -1 ------ Interrupt ------ ------ Interrupt ------ 1 -1 1004 test $0, %bx 1 -1 1005 jgt .top 1 -1 ------ Interrupt ------ ------ Interrupt ------ 1 -1 1005 jgt .top 1 -1 1006 halt 1 -1 ----- Halt;Switch ----- ----- Halt;Switch ----- 1 -1 ------ Interrupt ------ ------ Interrupt ------ 1 -1 1006 halt åªæœ‰ä¸¤ä¸ªçº¿ç¨‹åœ¨æ‰§è¡Œä¸´ç•ŒåŒºåŸŸä»£ç æ—¶ä¿æŒåŸå­æ€§ (ä¸è¢«æ‰“æ–­)ï¼Œæ‰èƒ½å¾—åˆ°æ­£ç¡®çš„ç»“æœã€‚ä¸´ç•ŒåŒºåŸŸä¸ºï¼š\n.main .top # \u0026lt;-- critical section begin --\u0026gt; mov 2000, %ax add $1, %ax mov %ax, 2000 # \u0026lt;-- critical section end --\u0026gt; sub $1, %bx test $0, %bx jgt .top halt ä¸­æ–­æ­¥é•¿ä¸º 1 å’Œ 2 æ—¶æ— æ³•è·å¾—æ­£ç¡®çš„ç»“æœ (ä¸´ç•ŒåŒºåŸŸäº¤ç»‡)ã€‚åœ¨åªå¾ªç¯ä¸€æ¬¡çš„æƒ…å†µä¸‹ï¼Œä¸­æ–­æ­¥é•¿å¤§äºç­‰äº 3 å³å¯ä¿è¯ç»“æœæ­£ç¡®ã€‚\nä¿è¯æ‰§è¡Œç»“æœæ­£ç¡®æœ‰ä»¥ä¸‹å‡ ç§æ€è·¯ï¼š\nåªè¦è®¾ç½® -i å‚æ•°è¶³å¤Ÿå¤§ä»¥ä½¿å¾—ä¸¤ä¸ªçº¿ç¨‹ä¸²è¡Œåœ°æ‰§è¡Œï¼Œå°±å¯ä»¥ä¿è¯ç»“æœæ­£ç¡®ã€‚ è¯¥æ±‡ç¼–ä»£ç æ‰§è¡Œä¸€ä¸ªå¾ªç¯ä¸€å…±æœ‰ 6 æ¡è¯­å¥ï¼Œå…¶ä¸­ä¸´ç•ŒåŒºåŸŸæœ‰ 3 æ¡è¯­å¥ã€‚å› æ­¤åªè¦è®¾ç½® -i å‚æ•°ä¸º 3 çš„å€æ•°ï¼Œå°±å¯ä»¥ä¿è¯ä¸´ç•ŒåŒºåŸŸä¸ä¼šäº¤å‰ã€‚ å¯¹äºé‚£äº›ä¸æ˜¯ 3 çš„å€æ•°çš„å‚æ•°ï¼Œåœ¨å‚æ•°è¾ƒå°æ—¶å°šå¯é¢„ä¼° (æ¯”å¦‚å¦‚æœè®¾ç½® -i 1/2ï¼Œåˆ™æ¯ä¸ªä¸´ç•ŒåŒºåŸŸéƒ½ä¼šäº¤ç»‡ï¼Œæœ€åç­”æ¡ˆä¸º Nï¼Œ-i 4 æœ€åçš„ç»“æœä¼šæ˜¯ 3N/2 ä¸Šå–æ•´)ï¼Œå‚æ•°è¾ƒå¤§æ—¶å¾—åˆ°çš„ç»“æœå°±éš¾ä»¥ç†è§£äº†ã€‚\nwait-for-me.s ä»£ç ä¼šæ ¹æ® %ax çš„å€¼é€‰æ‹© waiter æˆ– signaller èº«ä»½ã€‚waiter ç­‰å¾…åœ°å€ 2000 å¤„å€¼ä¸º 1ç»“æŸï¼Œsignaller è´Ÿè´£å‘ 2000 å¤„æ”¾ä¸€ä¸ª 1ã€‚\n.main test $1, %ax # ax should be 1 (signaller) or 0 (waiter) je .signaller .waiter\tmov 2000, %cx test $1, %cx jne .waiter halt .signaller mov $1, 2000 halt è¿è¡ŒæŒ‡ä»¤åä¼šçœ‹åˆ°ç¬¬ä¸€ä¸ªçº¿ç¨‹æ”¾ 1 ç»“æŸï¼Œç¬¬äºŒä¸ªçº¿ç¨‹çœ‹åˆ°æœ‰ 1 ç»“æŸã€‚\nå¦‚æœåè¿‡æ¥ï¼Œåˆ™ä¼šçœ‹åˆ°çº¿ç¨‹ 1 åœ¨è½®è¯¢åœ°å€ 2000 å¤„çš„å€¼ï¼Œç›´åˆ°å‘ç”Ÿçº¿ç¨‹åˆ‡æ¢ï¼Œçº¿ç¨‹ 2 å‘ 2000 å¤„å¡«å†™äº† 1ï¼Œçº¿ç¨‹ 1 æ‰å¾—ä»¥é€€å‡ºã€‚è¿™æ˜¯è‡ªæ—‹é”çš„é›å½¢ã€‚å¦‚æœå°† -i è°ƒå¾—å¾ˆå¤§ï¼Œçº¿ç¨‹ 1 å°†æµªè´¹ CPU cycle è¿›è¡Œå¤§é‡è½®è¯¢ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"2740481f457925b639784272ac936222","permalink":"https://kristoff-starling.github.io/notes/booknotes/ostep/hw26/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/booknotes/ostep/hw26/","section":"notes","summary":"Questions Letâ€™s examine a simple program, â€œloop.sâ€. First, just read and understand it. Then, run it with these arguments (./x86.py -p loop.s -t 1 -i 100 -R dx) This specifies a single thread, an interrupt every 100 instructions, and tracing of register %dx.","tags":null,"title":"Homework 26","type":"docs"},{"authors":null,"categories":null,"content":"Questions First build main-race.c. Examine the code so you can see the (hopefully obvious) data race in the code. Now run helgrind (by typing valgrind \u0026ndash;tool=helgrind main-race) to see how it reports the race. Does it point to the right lines of code? What other information does it give to you? What happens when you remove one of the offending lines of code? Now add a lock around one of the updates to the shared variable, and then around both. What does helgrind report in each of these cases? Now letâ€™s look at main-deadlock.c. Examine the code. This code has a problem known as deadlock (which we discuss in much more depth in a forthcoming chapter). Can you see what problem it might have? Now run helgrind on this code. What does helgrind report? Now run helgrind on main-deadlock-global.c. Examine the code; does it have the same problem that main-deadlock.c has? Should helgrind be reporting the same error? What does this tell you about tools like helgrind? Letâ€™s next look at main-signal.c. This code uses a variable (done) to signal that the child is done and that the parent can now continue. Why is this code inefficient? (what does the parent end up spending its time doing, particularly if the child thread takes a long time to complete?) Now run helgrind on this program. What does it report? Is the code correct? Now look at a slightly modified version of the code, which is found in main-signal-cv.c. This version uses a condition variable to do the signaling (and associated lock). Why is this code preferred to the previous version? Is it correctness, or performance, or both? Once again run helgrind on main-signal-cv. Does it report any errors? Solutions helgrind å·¥å…·å¯ä»¥å‡†ç¡®åœ°æŠ¥å‘Šå‡º main-race.c çš„ç¬¬ 15 è¡Œå’Œç¬¬ 8 è¡Œçš„æ“ä½œå­˜åœ¨ data raceã€‚æ­¤å¤–ï¼Œhelgrind å¯ä»¥æŠ¥å‘Šå‡ºäº§ç”Ÿæ•°æ®ç«äº‰çš„åœ°å€ (0 bytes inside data symbol \u0026ldquo;balance\u0026rdquo;)ï¼Œè¿˜å¯ä»¥æŠ¥å‘Šçº¿ç¨‹åˆ›å»ºçš„è¿‡ç¨‹ï¼š\n---Thread-Announcement------------------------------------------ Thread #2 was created at 0x49A9D42: clone (clone.S:71) by 0x4878281: create_thread (createthread.c:103) by 0x4879C8B: pthread_create@@GLIBC_2.2.5 (pthread_create.c:821) by 0x484D627: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so) by 0x109209: main (main-race.c:14) å¦‚æœåˆ é™¤æ‰ä»»æ„ä¸€ä¸ªå¯¹ balance çš„æ“ä½œï¼Œhelgrind å°±ä¸ä¼šæŠ¥å‘Šé”™è¯¯ã€‚å¦‚æœåªç”¨é”ä¿æŠ¤ä¸€å¤„æ“ä½œï¼Œhelgrind ä»ç„¶ä¼šæŠ¥å‘Š data race (ä¸”èƒ½æŠ¥å‘Šå¤„å“ªä¸€å¤„æ“ä½œè¢«é”ä¿æŠ¤äº†)ã€‚å¦‚æœç”¨é”å°†ä¸¤å¤„æ“ä½œéƒ½ä¿æŠ¤äº†ï¼Œhelgrind ä¸ä¼šæŠ¥å‘Šé”™è¯¯ã€‚\nmain-deadlock.c å­˜åœ¨å‘ç”Ÿæ­»é”çš„é£é™©ï¼šå¦‚æœ p1 çº¿ç¨‹è·å¾—äº†é” m1ï¼Œç„¶å p2 çº¿ç¨‹è·å¾—äº†é” m2ï¼Œè¿™æ—¶ p1 çº¿ç¨‹è¯•å›¾è·å¾—é” m2ï¼Œp2 çº¿ç¨‹è¯•å›¾è·å¾—é” m1ï¼Œå®ƒä»¬éƒ½å¾—ä¸åˆ°éœ€è¦çš„é”ï¼Œä¹Ÿä¸ä¼šé‡Šæ”¾è‡ªå·±å·²ç»å¾—åˆ°çš„é”ï¼Œä»è€Œé™·å…¥æ­»é”ã€‚\nhelgrind ä¼šæŠ¥å‘Šå½¢å¦‚ä¸‹é¢æ‰€ç¤ºçš„é”™è¯¯ï¼š\nThread #3: lock order \u0026quot;0x10C040 before 0x10C080\u0026quot; violated Observed (incorrect) order is: acquisition of lock at 0x10C080 ... followed by a later acquisition of lock at 0x10C040 ... Required order was established by acquisition of lock at 0x10C040 ... followed by a later acquisition of lock at 0x10C080 ... Lock at 0x10C040 was first observed ... Address 0x10c040 is 0 bytes inside data symbol \u0026quot;m1\u0026quot; Lock at 0x10C080 was first observed ... Address 0x10c080 is 0 bytes inside data symbol \u0026quot;m2\u0026quot; å¯¹äºç¨‹åºä¸­çš„ä»»æ„ä¸¤ä¸ªé”ï¼Œæ‰€æœ‰è·å–é”çš„è¡Œä¸ºéƒ½ä¸€å®šè¦æŒ‰ç…§ç›¸åŒçš„é¡ºåºï¼Œå¦åˆ™å°±æœ‰å¯èƒ½å¼•å‘æ­»é”ã€‚helgrind æ ¹æ®è¿™ä¸ªåŸç†æ£€æµ‹åˆ°äº†å¯èƒ½å­˜åœ¨çš„æ­»é”ï¼Œå¹¶ä¸”ç»™å‡ºäº†ä¸¤æ¬¡ä¸åŒçš„é¡ºåºä»¥åŠé”çš„åç§°ã€‚\nä¸ºä»€ä¹ˆæˆ‘æ— æ³•ä½¿æ­»é”æš´éœ²å‡ºæ¥ï¼Ÿ\nä¸¤ä¸ªçº¿ç¨‹çš„åˆ›å»ºæ˜¯æœ‰æ—¶é—´å·®çš„ï¼Œæ–°åˆ›å»ºçš„çº¿ç¨‹å¯ä»¥åˆ©ç”¨è¿™ä¸ªæ—¶é—´å·®æŠŠä¸¤ä¸ªé”éƒ½å¾—åˆ°ï¼Œè¿™æ ·æ­»é”å°±ä¸ä¼šæš´éœ²å‡ºæ¥ã€‚\nä¸ºäº†æ›´å¥½åœ°è§‚æµ‹æ­»é”ç°è±¡ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ worker() å‡½æ•°çš„å¼€å¤´æ·»åŠ ä¸€å¥ usleep(1)ï¼Œè¿™ä¼šè®©çº¿ç¨‹åœ¨æ­¤å¤„ç­‰å¾…è‡³å°‘ 1 å¾®ç§’çš„æ—¶é—´ã€‚è€ƒè™‘åˆ°ç³»ç»Ÿæ´»åŠ¨ç­‰å› ç´ ï¼Œusleep(1) å…¶å®ä¼šå¸¦æ¥ä¸€æ®µæ—¶é•¿æ¯”è¾ƒéšæœºçš„ delayï¼Œè¿™è®©ä¸¤ä¸ªçº¿ç¨‹è¢«æ‹‰å›â€œåŒä¸€èµ·è·‘çº¿â€çš„å‡ ç‡å¤§å¤§å¢åŠ ã€‚æ­¤å¤–ï¼Œå¤šæ¬¡é‡å¤å®éªŒï¼Œå³å¯æ¯”è¾ƒå®¹æ˜“åœ°è§‚å¯Ÿåˆ°æ­»é”ç°è±¡ã€‚\nmain-deadlock-global.c ä¸­ç”±äºæœ‰ä¸€ä¸ªå¤–å±‚çš„å¤§é”ä¿æŠ¤ï¼Œæ‰€ä»¥ä¸ä¼šå‘ç”Ÿæ­»é”ã€‚ä½†ä½¿ç”¨ helgrind æ£€æŸ¥ä»ç„¶å’Œä¼šæŠ¥å‘Šæœ‰éæ³•çš„é”è·å¾—é¡ºåºé—®é¢˜ã€‚helgrind åªæ˜¯è®°å½•è®¿é—®é”çš„é¡ºåºå¹¶åˆ¤æ–­æ˜¯å¦å‡ºç°äº†ç¯ï¼Œå¹¶ä¸èƒ½å‡†ç¡®åœ°åˆ¤æ–­æ­»é”æ˜¯å¦å¯èƒ½å‘ç”Ÿã€‚\nä¸»çº¿ç¨‹åœ¨å­çº¿ç¨‹æ‰“å°çš„æ—¶å€™ä¼šè½®è¯¢ done å˜é‡ï¼Œè®© CPU ç©ºè½¬ï¼Œæ‰€ä»¥è¿™ä¸ªæ–¹æ³•æ˜¯ä¸é«˜æ•ˆçš„ã€‚\nhelgrind æŠ¥å‘Šè¯¥ç¨‹åºå­˜åœ¨æ•°æ®ç«äº‰ã€‚ä¸¤ä¸ªçº¿ç¨‹å¯¹ done çš„è¯»å†™æ²¡æœ‰ç”¨é”ä¿æŠ¤èµ·æ¥ï¼Œå­˜åœ¨ race conditionã€‚\nmain-signal-cv.c ç›¸è¾ƒäºå‰è€…æœ‰ä¸¤ä¸ªæ”¹è¿›ï¼šä¸€æ˜¯ä¸¤ä¸ªè¿›ç¨‹å¯¹ done å˜é‡çš„è®¿é—®éƒ½ç”¨é”ä¿æŠ¤äº†èµ·æ¥ï¼Œä¿è¯äº†ä¸ä¼šå‘ç”Ÿ race conditionï¼›äºŒæ˜¯è¯¥ç¨‹åºä½¿ç”¨äº†æ¡ä»¶å˜é‡ï¼Œå¦‚æœä¸»çº¿ç¨‹æ£€æŸ¥ done ç»“æœä¸º 0ï¼Œä¼šåœ¨æ¡ä»¶å˜é‡ä¸Šç¡çœ ï¼Œç¡çœ çš„çº¿ç¨‹å¯ä»¥è¢« CPU è°ƒåº¦å‡ºå»ï¼Œä»è€Œä¸å æ® CPU æ—¶é’Ÿå‘¨æœŸã€‚ç­‰åˆ°å­çº¿ç¨‹æ‰“å°å®Œäº†å”¤é†’æ¡ä»¶å˜é‡ï¼Œä¸»çº¿ç¨‹å†æ¥æ£€æŸ¥ done å˜é‡å¹¶æ‰“å°è‡ªå·±çš„å†…å®¹ã€‚\nhelgrind æ²¡æœ‰æŠ¥å‘Šä»»ä½•é”™è¯¯ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"eb0714df356e5364fe4e7ecd6a9c4630","permalink":"https://kristoff-starling.github.io/notes/booknotes/ostep/hw27/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/booknotes/ostep/hw27/","section":"notes","summary":"Questions First build main-race.c. Examine the code so you can see the (hopefully obvious) data race in the code. Now run helgrind (by typing valgrind \u0026ndash;tool=helgrind main-race) to see how it reports the race.","tags":null,"title":"Homework 27","type":"docs"},{"authors":null,"categories":null,"content":"A. ä¸ºä¸–ç•Œæ‰€æœ‰ç¾å¥½è€Œæˆ˜ é¢˜é¢æè¿° yjher æ˜¯ä¸€åå¸¦å­¦ç”Ÿï¼Œä»–æœ‰ä¸€ä¸ªæ¢¦æƒ³ï¼Œä¸ºä¸–ç•Œæ‰€æœ‰ç¾å¥½è€Œæˆ˜ã€‚ä½œä¸ºå¸¦å­¦ç”Ÿï¼Œä»–é¦–å…ˆè¦è§£å†³ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯é€‰è¯¾é—®é¢˜ã€‚ä¿—è¯è¯´ï¼Œé€‰è¯¾ä¸€æ—¶çˆ½ï¼ŒæœŸæœ«ç«è‘¬åœºï¼Œä¸ºäº†é¿å…è¿™ç§æƒ…å†µï¼Œä»–å†³å®šæ ¹æ®æœŸæœ«æœ€åçš„æ€»å¤ä¹ æ—¶é—´ $m$ æ¥ç¡®å®šé€‰è¯¾æ–¹æ¡ˆã€‚(æ¯é—¨è¯¾åªèƒ½é€‰ä¸€æ¬¡ï¼‰ å·²çŸ¥ç°åœ¨ä¸€å…±æœ‰ $n$ é—¨è¯¾ï¼Œæ¯é—¨è¯¾æœ‰ä¸¤ä¸ªå±æ€§ $v_i$ å’Œ $t_i$ï¼Œåˆ†åˆ«è¡¨ç¤ºè¿™é—¨è¯¾ä¿®å®Œèƒ½è·å¾—çš„å­¦åˆ†å’Œå¤ä¹ éœ€è¦èŠ±çš„æ—¶é—´ã€‚ ç°åœ¨é—®ä½ å¤ä¹ æ‰€èŠ±æ—¶é—´çš„å’Œä¸è¶…è¿‡ $m$ çš„æƒ…å†µä¸‹ï¼Œèƒ½è·å¾—çš„æœ€é«˜åˆ†æ•°ã€‚ $n\\leq 1000,m\\leq 10^9,v_i\\leq 300,t\\leq 3e6$â€‹â€‹â€‹ã€‚ é¢˜è§£ ç”±äº $m$ çš„èŒƒå›´è¿‡å¤§ï¼Œè€Œå­¦åˆ† $v_i$â€‹â€‹ çš„èŒƒå›´ç›¸å¯¹è¾ƒå°ï¼Œå› æ­¤è€ƒè™‘å°†å­¦åˆ†ä½œä¸ºèƒŒåŒ…dpçš„çŠ¶æ€ã€‚\nä»¤ $dp[i][j]$ è¡¨ç¤ºå½“å‰è€ƒè™‘åˆ°ç¬¬ $i$ é—¨è¯¾ï¼Œè·å¾— $j$ å­¦åˆ†çš„æƒ…å†µä¸‹æ‰€éœ€ä½¿ç”¨çš„æœ€å°æ—¶é—´ï¼Œè½¬ç§»æ˜¯ç®€å•çš„ï¼š $dp[i][j]=min{dp[i-1][j],dp[i-1][j-v[i]]+t[i]}$â€‹â€‹ã€‚\næ—¶é—´å¤æ‚åº¦ $O(n\\sum v_i)$ï¼Œå¯ä»¥é€šè¿‡ï¼Œä½†ç©ºé—´å¤æ‚åº¦ $O(n\\sum v_i)$â€‹â€‹ ä¸èƒ½æ¥å—ã€‚\nèƒŒåŒ…dpæœ‰ä¸€ç§ç®€å•çš„ç©ºé—´ä¼˜åŒ–çš„æ–¹å¼ï¼Œè€ƒè™‘å°†dpçŠ¶æ€å‹ç¼©æˆä¸€ç»´ $dp[j]$ï¼ŒåŒé‡å¾ªç¯çš„ç¬¬ $i$ è½®ç»“æŸæ—¶è¡¨ç¤ºè·å¾— $j$ å­¦åˆ†æ‰€éœ€çš„æœ€å°æ—¶é—´ã€‚æˆ‘ä»¬åªè¦åœ¨å†…å¾ªç¯ä¸­å€’åºå¾ªç¯ï¼Œå°±èƒ½ä¿è¯ $dp[j]$ çš„æ›´æ–°æ¥æºéƒ½æ˜¯ä¸Šä¸€å±‚çš„æ•°æ®ï¼Œä»è€Œä¿è¯äº†æ­£ç¡®æ€§ï¼Œè¿™æ ·ç©ºé—´å¤æ‚åº¦å‹ç¼©åˆ° $O(\\sum v_i)$â€‹ã€‚\nB. æ•°åˆ— é¢˜é¢æè¿° ç»™å®šä¸€ä¸ª $n$ ä¸ªæ•°çš„æ•°åˆ— $a[i]$ï¼Œå¯¹äºæ¯ä¸ª $i$ ,åœ¨å³è¾¹æ‰¾åˆ°ä¸€ä¸ªæœ€é å³çš„ä½ç½® $k$ï¼ˆå³ $k$ å°½å¯èƒ½å¤§ï¼‰ï¼Œæ»¡è¶³ $a[k]\u0026lt;a[i]$ï¼Œè¾“å‡º $k-i-1$ï¼Œå¦‚æœä¸€ä¸ªéƒ½æ‰¾ä¸åˆ°ï¼Œè¾“å‡º $-1$ã€‚å¯¹äºåºåˆ—çš„æ¯ä¸ªå…ƒç´ éƒ½è¦è¾“å‡ºã€‚ $n\\leq 500000$â€‹ã€‚ é¢˜è§£ è€ƒè™‘æŒ‰ç…§æƒå€¼ä»å°åˆ°å¤§çš„é¡ºåºå‘ç©ºåºåˆ—ä¸­ä¾æ¬¡æ·»åŠ è¿™äº›æ•°ï¼Œè¿™æ ·åšçš„å¥½å¤„æ˜¯ï¼ŒæŸä¸€æ¬¡æ·»åŠ  $a[i]$â€‹ æ—¶ï¼Œæ•°åˆ—ä¸­å·²ç»å­˜åœ¨çš„æ•°ä¸€å®šæ˜¯æ¯”å½“å‰æ•°å°çš„æ•°ï¼Œå› æ­¤æˆ‘ä»¬åªéœ€è¦ä¸€è¾¹åŠ æ•°ï¼Œä¸€è¾¹æ›´æ–°ä¸‹æ ‡çš„æœ€å¤§å€¼å³å¯ã€‚ï¼ˆå¦‚æœä¸‹æ ‡æœ€å¤§å€¼å°äºå½“å‰æ•°çš„ä¸‹æ ‡ï¼Œåˆ™ç­”æ¡ˆä¸º-1ï¼‰ã€‚\næ€»æ—¶é—´å¤æ‚åº¦ $O(nlogn)$â€‹ã€‚\nC. åªæœ‰ä¸€ç§è‹±é›„ä¸»ä¹‰ é¢˜é¢æè¿° è¿™ä¸ªä¸–ç•Œä¸Šåªæœ‰ä¸€ç§è‹±é›„ä¸»ä¹‰ï¼Œé‚£å°±æ˜¯åœ¨è®¤æ¸…ç”Ÿæ´»çš„çœŸç›¸åä¾ç„¶çƒ­çˆ±å®ƒã€‚yjher é¢å¯¹ç€ $n$â€‹â€‹ ä¸ªç”Ÿæ´»çš„çœŸç›¸ï¼Œè¿™äº›ç”Ÿæ´»çš„çœŸç›¸æŒ‰åºä¾æ¬¡æ’å¥½æˆä¸ºä¸€ä¸ªæ•°åˆ—ï¼Œyjher å¯¹æ¯ä¸ªç”Ÿæ´»çš„çœŸç›¸éƒ½æœ‰ $m$â€‹â€‹ ç§çƒ­çˆ±ç­‰çº§å¯é€‰ï¼ˆå³å¯ä»¥ç†è§£ä¸ºæ¯ä¸ªç”Ÿæ´»çœŸç›¸å¯ä»¥å¯¹åº”äºä¸€ä¸ª $1$â€‹â€‹ åˆ° $m$â€‹â€‹ çš„çƒ­çˆ±ç­‰çº§)ã€‚ä¸ºäº†è®©ç”Ÿæ´»çœ‹èµ·æ¥ä¸è¦é‚£ä¹ˆå•è°ƒï¼Œè¦æ±‚ç›¸é‚»çš„ç”Ÿæ´»çœŸç›¸æœ‰ä¸åŒçƒ­çˆ±ç­‰çº§ï¼ˆå³å¦‚æœä½ åœ¨ç¬¬ $i$â€‹â€‹ ä¸ªç”Ÿæ´»çœŸç›¸ä¸­çƒ­çˆ±ç­‰çº§æ˜¯5ï¼Œé‚£ä¹ˆç¬¬ $i+1$â€‹â€‹ ä¸ªç”Ÿæ´»çœŸç›¸çš„çƒ­çˆ±ç­‰çº§å°±ä¸èƒ½æ˜¯5ï¼‰ï¼Œä¸” yjher æ¯”è¾ƒåå¥½æ•°å­— $k$â€‹â€‹ï¼Œä»–å¸Œæœ›æ‰€æœ‰ç”Ÿæ´»çœŸç›¸æ€»å…±ä½¿ç”¨çš„çƒ­çˆ±ç­‰çº§æ•°ä¸ºæ°å¥½ $k$â€‹â€‹ ä¸ªã€‚ï¼ˆå°±æ¯”å¦‚ $k=3,n=5,m=4$â€‹â€‹ï¼Œé‚£ä¹ˆ $1,2,3,2,1$â€‹â€‹ å’Œ $2,3,4,3,2$â€‹â€‹ å°±æ˜¯ä¸¤ä¸ªå¯è¡Œæ–¹æ¡ˆï¼Œä½†æ˜¯ $1,2,3,4,3$â€‹â€‹â€‹ å°±ä¸æ˜¯ï¼Œå› ä¸ºä»–ç”¨äº†è¶…è¿‡3ä¸ªä¸åŒçš„çƒ­çˆ±ç­‰çº§ï¼‰ã€‚\nç°åœ¨é—®ä½ æ‰€æœ‰å¯è¡Œçš„æ–¹æ¡ˆæ•°ã€‚ä¸¤ä¸ªæ–¹æ¡ˆæ•°è®¤ä¸ºæ˜¯ä¸åŒçš„ï¼Œå½“å‰ä»…å½“ä¸¤ä¸ªæ–¹æ¡ˆçš„æŸä¸ªç”Ÿæ´»çœŸç›¸æœ‰ä¸åŒçš„çƒ­çˆ±ç­‰çº§ï¼ˆå°±æ¯”å¦‚ $1,2,3$ å’Œ $2,3,4$ å°±æ˜¯ä¸åŒçš„æ–¹æ¡ˆï¼‰ï¼Œå› ä¸ºç­”æ¡ˆå¯èƒ½å¾ˆå¤§ï¼Œä»¤ç­”æ¡ˆå¯¹ $1e9+7$å–æ¨¡ã€‚\n$n,m\\leq 10^9,k\\leq 10^6$â€‹ã€‚\né¢˜è§£ é¦–å…ˆä» $m$ ä¸ªç­‰çº§ä¸­é€‰å‡º $k$ ä¸ªæ¥è¿›è¡Œå®‰æ’ï¼Œè¿™ä¸€éƒ¨åˆ†çš„æ–¹æ¡ˆæ•°æ˜¯ $\\binom{m}{k}$ï¼Œä¹‹åçš„è®¡ç®—é»˜è®¤å¯é€‰çš„ç­‰çº§ä¸º 1~kã€‚\næ°å¥½é€‰æ»¡äº† $k$â€‹ ç§ç­‰çº§è¾ƒéš¾æ§åˆ¶ï¼Œè€ƒè™‘å®¹æ–¥ã€‚ä»¤ $C(i)$â€‹ è¡¨ç¤ºåœ¨ $k$â€‹ ç§ç­‰çº§çš„å…¶ä¸­ $i$â€‹ ç§çš„èŒƒå›´ä¸­è¿›è¡Œé€‰æ‹©çš„æ–¹æ¡ˆæ•°ã€‚ä¸ºäº†ä¿è¯ç›¸é‚»ä¸ç›¸åŒçš„çº¦æŸï¼Œç¬¬ä¸€ä¸ªçœŸç›¸æœ‰ $i$â€‹ ç§é€‰æ‹©ï¼Œåé¢æ¯ä¸€ç§éƒ½åªæœ‰ $i-1$â€‹ ç§é€‰æ‹©ï¼Œå› æ­¤ $C(i)=i\\cdot (i-1)^{n-1}$â€‹ã€‚\næ ¹æ®å®¹æ–¥åŸç†ï¼Œ\n$$\\begin{align*}ans \u0026amp;= \\binom mk\\sum_{i=0}^{n-2}(-1)^i\\sum_{1\\leq a_1,a_2,\u0026hellip;,a_{k-i}\\leq k}C(a_1,a_2,\u0026hellip;,a_{k-i}) \\\\ \u0026amp;= \\binom mk \\sum_{i=0}^{n-2}(-1)^i\\binom kiC(i) \\\\ \u0026amp;= \\binom mk\\sum_{i=0}^{n-2}(-1)^i\\binom ki(k-i)(k-i-1)^{n-1} \\end{align*}$$$\\binom mk$ å¯ä»¥é€šè¿‡ä¸‹é™å¹‚çš„æ–¹å¼ $O(k)$ åœ°è®¡ç®—ã€‚é¢„å¤„ç†é˜¶ä¹˜åŠå…¶é€†å…ƒä¹‹åï¼Œå¾ªç¯å†…éƒ¨çš„ç»„åˆæ•°å¯ä»¥ $O(1)$ è®¡ç®—ï¼Œ $(k-i-1)^{n-1}$ éœ€è¦ä½¿ç”¨å¿«é€Ÿå¹‚ï¼Œç»¼ä¸Šï¼Œæ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(klogn)$â€‹ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"9b1b45fa4bbf1737fe6cf401e1e64696","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-problem-solving/oj-solutions/ii-final/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-problem-solving/oj-solutions/ii-final/","section":"notes","summary":"A. ä¸ºä¸–ç•Œæ‰€æœ‰ç¾å¥½è€Œæˆ˜ é¢˜é¢æè¿° yjher æ˜¯ä¸€åå¸¦å­¦ç”Ÿï¼Œä»–æœ‰ä¸€ä¸ªæ¢¦æƒ³ï¼Œä¸ºä¸–ç•Œæ‰€æœ‰ç¾å¥½è€Œæˆ˜ã€‚ä½œä¸ºå¸¦å­¦ç”Ÿï¼Œä»–é¦–å…ˆè¦è§£å†³ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯é€‰è¯¾é—®é¢˜ã€‚ä¿—è¯è¯´ï¼Œé€‰è¯¾ä¸€æ—¶çˆ½ï¼ŒæœŸæœ«ç«è‘¬åœºï¼Œä¸ºäº†é¿å…è¿™ç§æƒ…å†µï¼Œä»–å†³å®šæ ¹æ®æœŸæœ«æœ€åçš„æ€»å¤ä¹ æ—¶é—´ $m$ æ¥ç¡®å®šé€‰è¯¾æ–¹æ¡ˆã€‚(æ¯é—¨è¯¾åªèƒ½é€‰ä¸€æ¬¡ï¼‰ å·²çŸ¥ç°åœ¨ä¸€å…±æœ‰ $n$ é—¨è¯¾ï¼Œæ¯é—¨è¯¾æœ‰ä¸¤ä¸ªå±æ€§ $v_i$ å’Œ $t_i$ï¼Œåˆ†åˆ«è¡¨ç¤ºè¿™é—¨è¯¾ä¿®å®Œèƒ½è·å¾—çš„å­¦åˆ†å’Œå¤ä¹ éœ€è¦èŠ±çš„æ—¶é—´ã€‚ ç°åœ¨é—®ä½ å¤ä¹ æ‰€èŠ±æ—¶é—´çš„å’Œä¸è¶…è¿‡ $m$ çš„æƒ…å†µä¸‹ï¼Œèƒ½è·å¾—çš„æœ€é«˜åˆ†æ•°ã€‚ $n\\leq 1000,m\\leq 10^9,v_i\\leq 300,t\\leq 3e6$â€‹â€‹â€‹ã€‚ ","tags":null,"title":"é—®é¢˜æ±‚è§£ II - Final é¢˜è§£","type":"docs"},{"authors":null,"categories":null,"content":"Overview è¯¥å®éªŒçš„ä¸»è¦ç›®çš„æ˜¯åœ¨ abstract-machine æŠ½è±¡çš„ bare-metal ä¸Šç¼–å†™ä¸€ä¸ªå°æ¸¸æˆã€‚ç¬”è€…å®ç°çš„å°æ¸¸æˆæ˜¯è´ªåƒè›‡ã€‚\nDesignation API æˆ‘ä»¬éœ€è¦ä½¿ç”¨çš„æ¯”è¾ƒé‡è¦çš„ AM çš„æ¥å£æœ‰ï¼š\nputch() åŠå…¶å°è£…ç‰ˆæœ¬ puts() ï¼Œè´Ÿè´£å‘æ§åˆ¶å°è¾“å‡ºå­—ç¬¦å’Œå­—ç¬¦ä¸²ã€‚ AM_TIMER_UPTIME ï¼Œå¯¹è¯¥æŠ½è±¡å¯„å­˜å™¨è¿›è¡Œè¯»å–å¯ä»¥è·å¾—ç³»ç»Ÿå¯åŠ¨ä»¥æ¥è¿è¡Œæ—¶é—´çš„å¾®ç§’æ•°ã€‚ AM_INPUT_KEYBRDï¼Œå¯¹è¯¥æŠ½è±¡å¯„å­˜å™¨è¿›è¡Œè¯»å–å¯ä»¥è·å¾—ä¸€ä¸ª AM_INPUT_KEYBRD_T ç»“æ„ä½“ï¼Œå…¶ä¸­å­˜å‚¨äº†å½“å‰æ˜¯å¦æœ‰æŒ‰é”®è¢«æŒ‰ä¸‹ï¼Œè¢«æŒ‰ä¸‹çš„æŒ‰é”®ç¼–ç ç­‰ã€‚ AM_GPU_CONFIGï¼Œå¯¹è¯¥æŠ½è±¡å¯„å­˜å™¨è¿›è¡Œè¯»å–å¯ä»¥è·å¾— VGA çš„åŸºæœ¬ä¿¡æ¯ï¼ŒåŒ…æ‹¬çª—å£å®½é«˜çš„åƒç´ æ•°é‡ã€‚ AM_GPU_FBDRAWï¼Œå¯¹è¯¥æŠ½è±¡å¯„å­˜å™¨å†™å…¥ä¸€ä¸ª AM_GPU_FBDRAW_T ç»“æ„ä½“å¯ä»¥å‘ VGA è¾“å‡ºä¸€ä¸ªæ–¹æ ¼çš„é¢œè‰²ã€‚ Game Logic ä¸€ä¸ªæ¸¸æˆçš„åŸºæœ¬æ¡†æ¶ä¸ºï¼š\nwhile (1) { while (uptime() \u0026lt; next_frame); while ((key = read_key() != AM_KEY_NONE) kbd_event(key); game_process(); screen_update(); next_frame += 1000 / FPS; } å¯¹äºè´ªåƒè›‡æ¸¸æˆï¼š\nåœ¨ kbd_event() ä¸­ï¼Œæˆ‘ä»¬éœ€è¦å¤„ç† ESC æŒ‰é”®ï¼Œä»¤å…¶è°ƒç”¨ halt()ï¼Œä»¥åŠå››ä¸ªæ–¹å‘é”®ç”¨äºæ§åˆ¶è´ªåƒè›‡çš„è¡Œèµ°æ–¹å‘ã€‚ç¬”è€…è¿˜è®¾ç½®äº†æŒ‰ R é”®é‡æ–°å¼€å§‹æ¸¸æˆçš„åŠŸèƒ½ã€‚\nåœ¨ game_process() ä¸­\næˆ‘ä»¬éœ€è¦ç»´æŠ¤è´ªåƒè›‡æ¯ä¸€èŠ‚èº«ä½“çš„ä½ç½®ï¼Œå¹¶å°†å¤´éƒ¨æŒ‰ç…§å½“å‰æ–¹å‘ç§»åŠ¨ä¸€æ ¼ï¼Œåˆ¤æ–­æœ‰æ²¡æœ‰å‡ºç°æ’å¢™æˆ–è€…åƒäº†è‡ªå·±çš„æƒ…å†µï¼Œå¦‚æœå‡ºç°äº†ï¼Œåœ¨æ¸¸æˆä¸»å¾ªç¯ä¸­åº”è¯¥åœæ­¢ç”»é¢æ›´æ–°ã€‚ æˆ‘ä»¬éœ€è¦ç»´æŠ¤é£Ÿç‰©ï¼Œå¦‚æœé£Ÿç‰©å’Œè›‡å¤´é‡åˆï¼Œåˆ™åº”è¯¥åˆ†æ•°+1ï¼Œå¹¶éšæœºä¸€ä¸ªä½ç½® (ä¸èƒ½å’Œè›‡é‡åˆ) é‡æ–°æ”¾ç½®é£Ÿç‰©ã€‚ ä¸ºäº†é€æ­¥å¢åŠ æ¸¸æˆçš„éš¾åº¦ï¼Œç¬”è€…ç»´æŠ¤ FPS = 5 + (score / 2)ï¼Œå³æ¯å¤šå¾—ä¸¤åˆ†ï¼Œè´ªåƒè›‡çš„ç§»åŠ¨é€Ÿåº¦ä¾¿ä¼šåŠ å¿«ä¸€çº§ã€‚ åœ¨ screen_update() ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å°†èƒŒæ™¯æ¶‚æˆé»‘è‰²ï¼Œå°†è¾¹ç¼˜æ¶‚æˆæ©™è‰²ï¼Œå°†è›‡èº«æ¶‚æˆç»¿è‰²ï¼Œè›‡å¤´æ¶‚æˆè“è‰²ï¼Œé£Ÿç‰©æ¶‚æˆçº¢è‰²ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"de85713c9f7d3639a93d765d6cdcb140","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/labs/lab00/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/labs/lab00/","section":"notes","summary":"Overview è¯¥å®éªŒçš„ä¸»è¦ç›®çš„æ˜¯åœ¨ abstract-machine æŠ½è±¡çš„ bare-metal ä¸Šç¼–å†™ä¸€ä¸ªå°æ¸¸æˆã€‚ç¬”è€…å®ç°çš„å°æ¸¸æˆæ˜¯è´ªåƒè›‡ã€‚\nDesignation API æˆ‘ä»¬éœ€è¦ä½¿ç”¨çš„æ¯”è¾ƒé‡è¦çš„ AM çš„æ¥å£æœ‰ï¼š\nputch() åŠå…¶å°è£…ç‰ˆæœ¬ puts() ï¼Œè´Ÿè´£å‘æ§åˆ¶å°è¾“å‡ºå­—ç¬¦å’Œå­—ç¬¦ä¸²ã€‚ AM_TIMER_UPTIME ï¼Œå¯¹è¯¥æŠ½è±¡å¯„å­˜å™¨è¿›è¡Œè¯»å–å¯ä»¥è·å¾—ç³»ç»Ÿå¯åŠ¨ä»¥æ¥è¿è¡Œæ—¶é—´çš„å¾®ç§’æ•°ã€‚ AM_INPUT_KEYBRDï¼Œå¯¹è¯¥æŠ½è±¡å¯„å­˜å™¨è¿›è¡Œè¯»å–å¯ä»¥è·å¾—ä¸€ä¸ª AM_INPUT_KEYBRD_T ç»“æ„ä½“ï¼Œå…¶ä¸­å­˜å‚¨äº†å½“å‰æ˜¯å¦æœ‰æŒ‰é”®è¢«æŒ‰ä¸‹ï¼Œè¢«æŒ‰ä¸‹çš„æŒ‰é”®ç¼–ç ç­‰ã€‚ AM_GPU_CONFIGï¼Œå¯¹è¯¥æŠ½è±¡å¯„å­˜å™¨è¿›è¡Œè¯»å–å¯ä»¥è·å¾— VGA çš„åŸºæœ¬ä¿¡æ¯ï¼ŒåŒ…æ‹¬çª—å£å®½é«˜çš„åƒç´ æ•°é‡ã€‚ AM_GPU_FBDRAWï¼Œå¯¹è¯¥æŠ½è±¡å¯„å­˜å™¨å†™å…¥ä¸€ä¸ª AM_GPU_FBDRAW_T ç»“æ„ä½“å¯ä»¥å‘ VGA è¾“å‡ºä¸€ä¸ªæ–¹æ ¼çš„é¢œè‰²ã€‚ Game Logic ä¸€ä¸ªæ¸¸æˆçš„åŸºæœ¬æ¡†æ¶ä¸ºï¼š","tags":null,"title":"Lab 00: AM Game","type":"docs"},{"authors":null,"categories":null,"content":"Overview è¯¥å®éªŒçš„ç›®æ ‡æ˜¯å®ç°ä¸€ä¸ª (å†…æ ¸ä½¿ç”¨çš„) å †åŒºçš„å†…å­˜åˆ†é…å™¨ã€‚ä»¥ä¸‹ä¸»è¦è®°å½•ä¸€äº›æœ‰è¶£çš„è®¾è®¡/æ€§èƒ½è°ƒä¼˜ç»å†ã€‚\nDesignation ç»´æŠ¤å †åŒºçš„æ•°æ®ç»“æ„åº”è¯¥æ”¾åœ¨å †åŒºé‡Œï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸åº”è¯¥å¼€é™æ€æ•°ç»„ä¿å­˜ç»´æŠ¤å †åŒºçš„é“¾è¡¨ç­‰ï¼Œè€Œåº”è¯¥å°†é“¾è¡¨èŠ‚ç‚¹å°±å­˜å‚¨åœ¨ç©ºé—²çš„å†…å­˜å—ä¸Š (åæ­£ç©ºé—²çš„å†…å­˜å—å½“å‰ä¹Ÿæ²¡æœ‰æœ‰æ•ˆä¿¡æ¯)ã€‚\nç”±äº kfree() åªä¼ å…¥äº†è¦é‡Šæ”¾å†…å­˜å—çš„èµ·å§‹åœ°å€ï¼Œè€Œæ²¡æœ‰ä¼ å…¥ sizeï¼Œæ‰€ä»¥æˆ‘ä»¬åº”å½“åœ¨ kalloc() çš„æ—¶å€™è®°å½•æ¯ä¸ªé‡Šæ”¾å‡ºå»çš„å†…å­˜å—çš„å¤§å°ã€‚ç¬”è€…æœ€åˆçš„å®ç°æ˜¯ç»´æŠ¤äº†ä¸€ä¸ªåˆ†é…å‡ºå»çš„å†…å­˜å—çš„é“¾è¡¨ï¼Œkfree() åˆ°æ¥æ—¶ï¼Œåœ¨é“¾è¡¨é‡ŒæŸ¥æ‰¾ç»™å®šçš„åœ°å€æ˜¯å¦å­˜åœ¨ä»¥åŠå¯¹åº”çš„å¤§å°ã€‚ä½†è¿™æ ·æ•ˆç‡å¤ªä½ï¼Œäºæ˜¯ç¬”è€…ä½¿ç”¨äº†åœ¨åœ°å€å‰æ‰“é­”æ•°çš„æ–¹æ³•ã€‚ç¬”è€…å®šä¹‰äº†ä¸€ä¸ªå¦‚ä¸‹çš„ headerï¼š\n#define ALLOC_MAGIC 0x1234567; typedef struct __header_t { size_t sz; union { uintptr_t magic; struct __header_t *next; }; }header_t; æ¯ä¸ªå†…å­˜å—å‰éƒ½æœ‰ä¸€ä¸ªè¿™æ ·çš„ headerã€‚è¿™ä¸ª header çš„å¥½å¤„æ˜¯ï¼šæœªåˆ†é…å†…å­˜å’Œå·²åˆ†é…å†…å­˜å¯ä»¥å…±ç”¨è¿™ä¸ª headerï¼Œå½“å†…å­˜å—å¤„äºæœªåˆ†é…çŠ¶æ€æ—¶ï¼Œå†…å­˜å—è¢«æ”¾åœ¨é“¾è¡¨ä¸­ï¼Œunion å­—æ®µå­˜æ”¾çš„æ˜¯ä¸‹ä¸€ä¸ªé“¾è¡¨èŠ‚ç‚¹çš„åœ°å€ï¼›å½“å†…å­˜å—å¤„äºå·²åˆ†é…çŠ¶æ€æ—¶ï¼Œunion å­—æ®µå­˜æ”¾é­”æ•°ã€‚ä¸€ä¸ª kfree() åœ°å€æ¥ä¸´æ—¶ï¼Œåªè¦æŸ¥çœ‹å…¶å‰ä¸€ä¸ª uintptr_t ä¸­æ˜¯ä¸æ˜¯ ALLOC_MAGICï¼Œå°±èƒ½ç¡®å®šè¿™ä¸ªåœ°å€åˆä¸åˆæ³•ï¼Œå†å¾€å‰çœ‹å°±èƒ½è·å¾—å†…å­˜å—çš„ sizeã€‚\n(æ³¨ï¼šä½¿ç”¨ header çš„æ–¹æ³•æœ‰ä¸€ä¸ªå¼±ç‚¹ï¼šåŸæœ¬åœ¨å †åŒºä¸­ 1B çš„å†…å­˜åŠ ä¸Š header åå˜å¾—å¾ˆå¤§ã€‚æ­¤å¤–ï¼Œç”±äºå¯¹é½çš„åŸå› ï¼Œæˆ‘ä»¬æ— æ³•å°†å¤šä¸ªå¤§å°ç›¸åŒçš„å†…å­˜å—â€œæŒ¨åœ¨ä¸€èµ·â€å­˜æ”¾åœ¨å †åŒºä¸­ï¼Œä¸­é—´æœ‰å¾ˆå¤šâ€œæ´â€ã€‚)\nç”±äº pmm ä¼šè¢«å¹¶å‘åœ°æ‰§è¡Œï¼Œæ‰€ä»¥è®¿é—®å…±äº«æ•°æ®ç»“æ„è¦ä¸Šé”ã€‚\nDefensive Programming ç¬”è€…è®¤ä¸ºä»¥ä¸‹çš„é˜²å¾¡æ€§ç¼–ç¨‹æ˜¯æœ‰æ„ä¹‰çš„ï¼š\nåœ¨ kalloc(), kfree() ä¸­åŠ å…¥è¶³å¤Ÿçš„å¯¹åœ°å€æ€§è´¨ï¼Œç©ºé—´å¤§å°åˆ†æçš„ panic(), panic_on() ç­‰ï¼Œè¿™æœ‰åŠ©äºæå‰å‘ç° failureã€‚ ç¬”è€…å®ç°çš„è‡ªæ—‹é”ä¸­è®°å½•äº†å½“å‰æ‹¥æœ‰é”çš„ CPU ç¼–å·ï¼Œè¿™æ ·åœ¨ acquire() å’Œ release() å‰æ£€æŸ¥å½“å‰æ˜¯å¦æ‹¥æœ‰é”ï¼Œå¯ä»¥æœ‰æ•ˆé˜²å¾¡ AA-deadlock å’Œä¸€äº›æ„æ–™ä¹‹å¤–çš„æƒ…å†µã€‚ kalloc()/kfree() ç»“æŸæ—¶åº”è¯¥å°†å¯¹åº”å†…å­˜åŒºé—´ memset æˆå¥‡æ€ªæ•°å€¼ï¼Œè¿™æ ·åç»­ä½¿ç”¨æ—¶å¦‚æœå¿˜äº†æ¸…é›¶/åœ°å€æº¢å‡ºï¼Œè¯»åˆ°åƒåœ¾æ•°æ®å¯ä»¥åŠ å¿« failure å‡ºç°çš„é€Ÿåº¦ï¼Œå‡å°‘æ’æŸ¥ bug çš„æ—¶é—´ã€‚ ä½†ä»¥ä¸Šé˜²å¾¡æ€§ç¼–ç¨‹å¯¹æ•ˆç‡æœ‰ä¸€å®šå½±å“ï¼Œå› æ­¤ç¬”è€…åœ¨æäº¤ OJ çš„ç‰ˆæœ¬ä¸­æ²¡æœ‰ç¼–è¯‘è¿™äº› (å°¤å…¶æ˜¯ç¬¬ä¸‰æ¡) é˜²å¾¡æ€§ç¼–ç¨‹ã€‚\nPerformance Tuning è¯¥å®éªŒå¯¹æ•ˆç‡æœ‰ä¸€å®šçš„è¦æ±‚ï¼Œç¬”è€…ä¸»è¦ä½¿ç”¨ Linux perf å·¥å…·å¯¹ä»£ç çš„è¿è¡Œæ—¶é—´/å¹¶è¡Œåº¦è¿›è¡Œè§‚æµ‹ã€‚æœ¬åœ° Workload çš„ä¿¡æ¯ä¸ºï¼š$60%$ çš„ 128K ä»¥å†…å†…å­˜åˆ†é…ï¼Œ$30%$ çš„ pagesize å†…å­˜åˆ†é…ï¼Œ$10%$ çš„å¤§å†…å­˜åˆ†é…ã€‚é‡Šæ”¾çš„é¢‘ç‡å’Œåˆ†é…ç›¸ä»¿ã€‚æ¯ä¸ªæ ¸åš 400,000 æ¬¡åˆ†é…å’Œå›æ”¶ã€‚\nç¬”è€…åšè¿‡å¦‚ä¸‹ä¼˜åŒ–ï¼š\nFast Path å°†æ•´ä¸ªå †åŒºåˆ†æˆ cpu_count() ä»½ï¼Œæ¯ä¸ª CPU æ ¸åªåœ¨è‡ªå·±çš„é‚£ä¸€ä»½çš„é“¾è¡¨ä¸­ alloc() å’Œ free() (free æ—¶æ ¹æ®åœ°å€è¿˜åˆ°ç›¸åº”çš„èµ„æºåŒºä¸­)ï¼Œå› ä¸ºä¸€ä¸ªæ ¸çš„ kalloc() å¯èƒ½åœ¨å¦ä¸€ä¸ªæ ¸ä¸­ kfree()ï¼Œæ‰€ä»¥å³ä½¿åˆ†æˆäº†å¤šä»½ï¼Œè®¿é—®æ•°æ®ç»“æ„ä¾æ—§è¦ä¸Šé”ã€‚å¦‚æœæœ¬åœ°èµ„æºä¸è¶³ï¼Œåˆ™ä»åˆ«çš„èµ„æºåŒºå·èµ„æºã€‚è¯¥åšæ³•æœ‰ä¸€å®šæ•ˆç‡æå‡ï¼Œä½†ä¸æ˜æ˜¾ã€‚\nslabã€‚ç¬”è€…å¯¹ 1KB ä»¥ä¸‹å†…å­˜åˆ†é…çš„æ¯ç§å¤§å°éƒ½å¼€äº†ä¸€ä¸ªå•ç‹¬çš„é“¾è¡¨ï¼Œå¯¹ pagesize (4KB) ä¹Ÿå¼€äº†ä¸€ä¸ªé“¾è¡¨ã€‚slab çš„æ ¸å¿ƒåšæ³•æ˜¯ï¼šæ²¡æœ‰èµ„æºæ—¶èµ° slow pathï¼Œä»å…¨å±€èµ„æºä¸­æ‰¹å‘å¾ˆå¤šå°å—ä¸²æˆé“¾è¡¨ï¼›æœ‰èµ„æºæ—¶ç›´æ¥ä»é“¾è¡¨å¤´å–ä¸€ä¸ªå°å—ã€‚è¿™é‡Œæ¯æ¬¡èµ° slow path æ‰¹å‘å¤šå°‘ä¸ªå°å—æ˜¯ä¸€ä¸ªéœ€è¦è°ƒæ•´çš„å‚æ•°ï¼Œä¸åŒçš„å‚æ•°ä¼šå¯¹æ•ˆç‡å’Œå¤±è´¥ç‡äº§ç”Ÿå½±å“ã€‚\nè¿™é‡Œçš„ä¸€ä¸ªç»†èŠ‚æ˜¯ï¼šç¬”è€…å¸Œæœ›æ¯ä¸ªæ ¸ä»è‡ªå·±çš„ slab ä¸­è·å–èµ„æºï¼Œé‡Šæ”¾æ—¶å°†èµ„æºé‡Šæ”¾åˆ°è‡ªå·±çš„ slab ä¸­ï¼Œè¿™æ · fast path ä¸éœ€è¦ä¸Šé”ã€‚ä½†æäº¤ OJ å‘ç° smp=2 æ—¶å°±ä¼šå‡ºç° low memory usageï¼Œè¿™å¾ˆå¯èƒ½æ˜¯å› ä¸º OJ ä¸Šä¸¤ä¸ªæ ¸çš„ä»»åŠ¡ä¸å¯¹ç§°ï¼Œå¦‚ä¸€ä¸ªæ ¸ä¸“é—¨ kalloc()ï¼Œä¸€ä¸ªæ ¸ä¸“é—¨ kfree()ï¼Œå¯¼è‡´èµ„æºå…¨éƒ¨å †ç§¯åœ¨ç¬¬äºŒä¸ªæ ¸çš„ slab é‡Œæ— æ³•åˆ©ç”¨ã€‚å› æ­¤ç¬”è€…ä¸å¾—ä¸å¯¹ slab çš„è®¿é—®ä¸Šé”ï¼Œæœ¬åœ° slab æ²¡æœ‰èµ„æºæ—¶å»å·åˆ«äººçš„ slab çš„èµ„æºã€‚\nä¸ºäº†å‡å°‘ slab ä¸Šçš„é”æ‹¥å µï¼Œç¬”è€…å°è¯•äº†ä»¥ä¸‹ä¸¤ç§â€œç„å­¦â€ä¼˜åŒ–ï¼š\næ¯ä¸ªæ ¸ kalloc() æ—¶éšæœºä¸€ä¸ª slab å–èµ„æºï¼Œkfree() æ—¶éšæœºä¸€ä¸ª slab è¿˜èµ„æº (å…¶å®ä¸¤ä¸ªéƒ½éšæœºå’Œåªéšæœºä¸€ä¸ªæ•ˆæœæ˜¯ä¸€æ ·çš„)ã€‚è¯¥ç­–ç•¥åªéœ€è¦è®¿é—®ä¸€ä¸ª slabï¼Œæ¯”ä¹‹å‰çš„å·èµ„æºç­–ç•¥è¦é«˜æ•ˆä¸€äº›ï¼Œä¸”æ‰“ç ´äº†â€ä¸å¯¹ç§°ä»»åŠ¡â€œçº¦æŸï¼Œä¸ä¼š low memory usageã€‚è¯¥ä¼˜åŒ–åœ¨æœ¬åœ° workload ä¸­æ˜¾è‘—å‡å°‘äº†é”çš„æ‹¥å µç¨‹åº¦ã€‚ ä¸ºäº†è¿›ä¸€æ­¥å‡å°‘é”çš„æ‹¥å µ (æ¯•ç«Ÿä¸¤ä¸ªæ ¸éšæœºåˆ°ä¸€ä¸ª slab çš„æ¦‚ç‡è¿˜æ˜¯ä¸å°çš„)ï¼Œç¬”è€…ç»™æ¯ä¸ªæ ¸é€‰å®šä¸€ä¸ª target slab (è¿™æ˜¯ä¸€ä¸ª permutation)ï¼Œæ¯ä¸ªæ ¸å‘ target slab ç´¢å–èµ„æºï¼Œé‡Šæ”¾æ—¶å½’è¿˜åˆ° target slab ä¸­ã€‚ä¸ºäº†é¿å…â€œä¸å¯¹ç§°ä»»åŠ¡â€çº¦æŸï¼Œæ¯è¿›è¡Œä¸€å®šæ¬¡æ•°çš„åˆ†é…åï¼Œshuffle ä¸€ä¸‹ target slab çš„ permutationã€‚è¯¥ä¼˜åŒ–åœ¨æœ¬åœ°çš„ workload ä¸­ç›¸è¾ƒå‰ä¸€ç§æ–¹æ³•ç¡®å®è¿›ä¸€æ­¥å‡å°‘äº†é”çš„æ‹¥å µç¨‹åº¦ï¼Œä½†æ²¡æœ‰çœ‹åˆ°æ˜æ˜¾çš„æ•ˆç‡æå‡ã€‚ Slow Path ä¸ºäº†é˜²æ­¢ (å¯ä»¥é¿å…çš„) è¿‡äºç ´ç¢çš„å†…å­˜ï¼Œé“¾è¡¨ä¸­åº”å½“æœ‰åˆå¹¶æœºåˆ¶ï¼Œå³æ’å…¥ä¸€ä¸ªèŠ‚ç‚¹åï¼Œå°†å…¶ä¸å·¦å³é‚»å±…æ¯”è¾ƒï¼Œè‹¥ç«¯ç‚¹é‡åˆåˆ™åˆå¹¶èŠ‚ç‚¹ã€‚\nOSTEP ä¸­æåˆ°è¿‡ best/first/next fit ç­‰å¤šç§å¯»æ‰¾å¯ç”¨èŠ‚ç‚¹çš„ç­–ç•¥ï¼Œå¦‚æœä½¿ç”¨ first fitï¼Œä¸€æ®µæ—¶é—´åå †åŒºçš„å‰éƒ¨å°±ä¼šå‡ºç°è¾ƒå¤šç ´ç¢å†…å­˜ï¼Œåéƒ¨ç›¸å¯¹å®Œæ•´ï¼Œä½¿æœç´¢ç›¸å¯¹è¾ƒæ…¢ã€‚next fit ç†è®ºä¸Šä¼šæœ‰æ›´å¥½çš„è¡¨ç°ï¼Œä½†ç¬”è€…æ²¡æœ‰åœ¨æœ¬åœ°æµ‹è¯•ä¸­è§‚æµ‹åˆ°æ˜æ˜¾çš„æ•ˆç‡æå‡ã€‚\nä¸ºäº†è¿›ä¸€æ­¥å‡å°‘ç ´ç¢å†…å­˜ï¼Œç¬”è€…ä½¿ç”¨å¦‚ä¸‹ç­–ç•¥ï¼šä¸€ä¸ªå†…å­˜å—å¦‚æœè¢«åˆ†é…å®Œåå‰©ä½™ç©ºé—´è¿‡å°‘ (å°äºä¸€ä¸ªé˜ˆå€¼)ï¼Œåˆ™ä¸é€‰æ‹©åˆ‡åˆ†è¿™ä¸ªå†…å­˜å—ï¼Œè€Œæ˜¯å°†æ•´å—ç»™å½“å‰åˆ†é…ã€‚è¿™æ ·å¯ä»¥å‡å°‘é“¾è¡¨ä¸­å®¹é‡å¾ˆå°çš„å†…å­˜å—ä¸ªæ•°ã€‚è¯¥ä¼˜åŒ–åœ¨æœ¬åœ° workload ä¸­ä½“ç°å‡ºäº†æ•ˆæœã€‚\nåœ¨ä¸€æ¬¡ alloc() å¤±è´¥åï¼Œè®°å½•è¿™æ¬¡çš„éœ€æ±‚å¤§å°ï¼Œåœ¨ä¸‹ä¸€æ¬¡ free() æ¥ä¸´ä¹‹å‰ï¼Œå¦‚æœå†å‡ºç°å¤§äºä¹‹å‰å¤±è´¥æœ€å°å€¼çš„ alloc()ï¼Œå¯ä»¥ä¸éå†é“¾è¡¨ç›´æ¥è¿”å› NULLã€‚æ³¨æ„ free() ä¹‹åè¦å°†è®°å½•å˜é‡æ¸…ç©ºã€‚è¯¥ä¼˜åŒ–åœ¨å¤±è´¥ç‡æ¯”è¾ƒé«˜çš„ workload ä¸­ä½“ç°å‡ºäº†æ•ˆæœã€‚\nç¬”è€…å‘ç°å®Œå…¨æŠ›å¼ƒé“¾è¡¨ï¼Œåªç”¨ä¸€ä¸ªå…¨å±€æŒ‡é’ˆç»´æŠ¤å †åŒºï¼Œå¯¹äºä¸€ä¸ªåˆ†é…å¯»æ‰¾å…¨å±€æŒ‡é’ˆæœ€è¿‘çš„ä¸‹ä¸€ä¸ªå¯¹é½ç‚¹ (ç»“åˆ slabï¼Œkfree() ç›´æ¥æ”¾åˆ° slab ä¸­) çš„æ–¹æ³•ä¸ä¼šåœ¨ OJ ä¸­æŠ¥ low memory usageã€‚è¿™æ ·å¤æ‚çš„é“¾è¡¨æ“ä½œè¢«å¤§å¹…ç®€åŒ–ã€‚è¯¥ä¼˜åŒ–åœ¨æœ¬åœ° workload ä¸­ä½“ç°å‡ºå·¨å¤§æ•ˆæœã€‚(æ³¨ï¼šå¦‚æœå¾ˆå°çš„å†…å­˜ alloc å’Œå¾ˆå¤§çš„å†…å­˜ alloc äº¤æ›¿å‡ºç°ï¼Œè¯¥æ–¹æ³•ä¼šæµªè´¹å¾ˆå¤šå†…å­˜ã€‚è¯¥æ–¹æ³•å±äºç”¨å¤±è´¥ç‡æ¢æ•ˆç‡çš„ä¸€ä¸ªå°è¯•ã€‚)\nå³ä½¿ç¬”è€…ç»“åˆ Fast Path å’Œ Slow Path ä¸­èƒ½æƒ³åˆ°çš„æœ€ä¼˜çš„å®ç°ï¼Œä¹Ÿæ— æ³•é€šè¿‡æ—§ç‰ˆ OJ ä¸Š smp=8 çš„æµ‹è¯•ç”¨ä¾‹ã€‚åœ¨æœ¬åœ° workload ä¸‹ç¬”è€…çš„æœ€ä¼˜å®ç°å¯ä»¥åœ¨ 1.5s åˆ° 2s å®Œæˆ 8 æ ¸çš„æ‰€æœ‰ä»»åŠ¡ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"8dae62133b0683bfa4d827e0081132f8","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/labs/lab01/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/labs/lab01/","section":"notes","summary":"Overview è¯¥å®éªŒçš„ç›®æ ‡æ˜¯å®ç°ä¸€ä¸ª (å†…æ ¸ä½¿ç”¨çš„) å †åŒºçš„å†…å­˜åˆ†é…å™¨ã€‚ä»¥ä¸‹ä¸»è¦è®°å½•ä¸€äº›æœ‰è¶£çš„è®¾è®¡/æ€§èƒ½è°ƒä¼˜ç»å†ã€‚\nDesignation ç»´æŠ¤å †åŒºçš„æ•°æ®ç»“æ„åº”è¯¥æ”¾åœ¨å †åŒºé‡Œï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸åº”è¯¥å¼€é™æ€æ•°ç»„ä¿å­˜ç»´æŠ¤å †åŒºçš„é“¾è¡¨ç­‰ï¼Œè€Œåº”è¯¥å°†é“¾è¡¨èŠ‚ç‚¹å°±å­˜å‚¨åœ¨ç©ºé—²çš„å†…å­˜å—ä¸Š (åæ­£ç©ºé—²çš„å†…å­˜å—å½“å‰ä¹Ÿæ²¡æœ‰æœ‰æ•ˆä¿¡æ¯)ã€‚\nç”±äº kfree() åªä¼ å…¥äº†è¦é‡Šæ”¾å†…å­˜å—çš„èµ·å§‹åœ°å€ï¼Œè€Œæ²¡æœ‰ä¼ å…¥ sizeï¼Œæ‰€ä»¥æˆ‘ä»¬åº”å½“åœ¨ kalloc() çš„æ—¶å€™è®°å½•æ¯ä¸ªé‡Šæ”¾å‡ºå»çš„å†…å­˜å—çš„å¤§å°ã€‚ç¬”è€…æœ€åˆçš„å®ç°æ˜¯ç»´æŠ¤äº†ä¸€ä¸ªåˆ†é…å‡ºå»çš„å†…å­˜å—çš„é“¾è¡¨ï¼Œkfree() åˆ°æ¥æ—¶ï¼Œåœ¨é“¾è¡¨é‡ŒæŸ¥æ‰¾ç»™å®šçš„åœ°å€æ˜¯å¦å­˜åœ¨ä»¥åŠå¯¹åº”çš„å¤§å°ã€‚ä½†è¿™æ ·æ•ˆç‡å¤ªä½ï¼Œäºæ˜¯ç¬”è€…ä½¿ç”¨äº†åœ¨åœ°å€å‰æ‰“é­”æ•°çš„æ–¹æ³•ã€‚ç¬”è€…å®šä¹‰äº†ä¸€ä¸ªå¦‚ä¸‹çš„ headerï¼š\n#define ALLOC_MAGIC 0x1234567; typedef struct __header_t { size_t sz; union { uintptr_t magic; struct __header_t *next; }; }header_t; æ¯ä¸ªå†…å­˜å—å‰éƒ½æœ‰ä¸€ä¸ªè¿™æ ·çš„ headerã€‚è¿™ä¸ª header çš„å¥½å¤„æ˜¯ï¼šæœªåˆ†é…å†…å­˜å’Œå·²åˆ†é…å†…å­˜å¯ä»¥å…±ç”¨è¿™ä¸ª headerï¼Œå½“å†…å­˜å—å¤„äºæœªåˆ†é…çŠ¶æ€æ—¶ï¼Œå†…å­˜å—è¢«æ”¾åœ¨é“¾è¡¨ä¸­ï¼Œunion å­—æ®µå­˜æ”¾çš„æ˜¯ä¸‹ä¸€ä¸ªé“¾è¡¨èŠ‚ç‚¹çš„åœ°å€ï¼›å½“å†…å­˜å—å¤„äºå·²åˆ†é…çŠ¶æ€æ—¶ï¼Œunion å­—æ®µå­˜æ”¾é­”æ•°ã€‚ä¸€ä¸ª kfree() åœ°å€æ¥ä¸´æ—¶ï¼Œåªè¦æŸ¥çœ‹å…¶å‰ä¸€ä¸ª uintptr_t ä¸­æ˜¯ä¸æ˜¯ ALLOC_MAGICï¼Œå°±èƒ½ç¡®å®šè¿™ä¸ªåœ°å€åˆä¸åˆæ³•ï¼Œå†å¾€å‰çœ‹å°±èƒ½è·å¾—å†…å­˜å—çš„ sizeã€‚","tags":null,"title":"Lab 01: Physical Memory Manager","type":"docs"},{"authors":null,"categories":null,"content":"Overview è¯¥å®éªŒçš„ä¸»è¦å†…å®¹æ˜¯å®ç°å†…æ ¸çº¿ç¨‹çš„è°ƒåº¦ã€‚æœ¬å®éªŒæŠ¥å‘Šä¸»è¦è®°å½•ä¸€äº›æœ‰è¶£çš„è®¾è®¡å’Œæµ‹è¯•æ–¹æ³•ã€‚\nDesignation spinlock åœ¨ L2 ä¸­æˆ‘ä»¬éœ€è¦å®ç°ä¸€ä¸ªç›¸è¾ƒäº L1 æ›´åŠ ç²¾ç»†çš„è‡ªæ—‹é”ã€‚åœ¨å¼•å…¥äº†ä¸­æ–­æœºåˆ¶åï¼Œæˆ‘ä»¬åœ¨ä¸´ç•ŒåŒºå†…éœ€è¦å…³é—­ä¸­æ–­ï¼Œå¦åˆ™ä¸€æ—¦æŒæœ‰é”çš„çº¿ç¨‹è¢«è°ƒåº¦ä¸‹äº† CPU ä¸€æ•´ä¸ªæ—¶é—´ç‰‡å°±ä¼šå¡ä½ã€‚æˆ‘ä»¬éœ€è¦å°å¿ƒåœ°ç»´æŠ¤ä¸­æ–­çš„åµŒå¥—ã€‚æˆ‘ä»¬éœ€è¦ä¸€ä¸ª per-cpu çš„å˜é‡æ¥è®°å½•ä¸­æ–­åµŒå¥—çš„å±‚æ•°ï¼Œåœ¨ç¬¬ä¸€å±‚çš„æ—¶å€™å…³é—­ä¸­æ–­ï¼Œå¹¶åœ¨æœ€åä¸€å±‚è¢«è§£å¼€æ—¶æ‰“å¼€ä¸­æ–­ã€‚\nInline Assembly ç¬”è€…çš„åˆä»£å®ç°ä½¿ç”¨äº†å…§è”æ±‡ç¼–è¿›è¡Œæ ˆåˆ‡æ¢ (æ¨¡ä»¿ xv6 çš„è®¾è®¡)ï¼Œå› è€Œæ˜¯æ¶æ„ç›¸å…³çš„ (ç¬”è€…é’ˆå¯¹ x86-64 å’Œ x86 å„å†™äº†ä¸€éæ±‡ç¼–)ã€‚åœ¨è¿™ç§å®ç°ä¸‹ï¼Œä¸€æ¬¡çº¿ç¨‹åˆ‡æ¢ (ä»¥æ—¶é’Ÿä¸­æ–­ä¸ºä¾‹) ä¼šç»å†å¦‚ä¸‹å†ç¨‹ï¼š\nç»è¿‡ AM ä¸­çš„ä¸€äº›ä»£ç åï¼Œä¸Šä¸‹æ–‡ä¿å­˜åœ¨äº†æ ˆä¸Šçš„ Context ç»“æ„ä½“ä¸­ï¼Œè¿›å…¥ os-\u0026gt;trapã€‚\nos-\u0026gt;trap æ ¹æ®ä¸­æ–­åŸå› ï¼Œè¿›å…¥æ—¶é’Ÿä¸­æ–­çš„ handlerã€‚æ—¶é’Ÿä¸­æ–­è¦æ±‚å½“å‰çº¿ç¨‹ä¸»åŠ¨è®©å‡º CPUã€‚handler ä¼šé€šè¿‡ä¸€ä¸ª swtch() å‡½æ•° (å…§è”æ±‡ç¼–) è·³è½¬åˆ° scheduler çº¿ç¨‹ï¼Œè¯¥å‡½æ•°åŸç†ç±»ä¼¼ setjmp å’Œ longjmpï¼Œæ¢å¤å¯„å­˜å™¨ç°åœºå¹¶åˆ‡æ¢æ ˆã€‚scheduler çº¿ç¨‹ä½¿ç”¨è‡ªå·±çš„ç‹¬ç«‹çš„æ ˆ (å³ä¸æ˜¯çº¿ç¨‹çš„å†…æ ¸æ ˆ)ï¼Œæ¯ä¸ª CPU æ ¸ä¸€ä¸ªã€‚\nè°ƒåº¦å™¨çº¿ç¨‹æ˜¯ä¸€ä¸ªæ­»å¾ªç¯ï¼Œå®ƒä¸æ–­é€‰æ‹©çŠ¶æ€ä¸º RUNNABLE çš„çº¿ç¨‹å¹¶è°ƒç”¨ swtch() å‡½æ•°åˆ‡æ¢è¿‡å»ã€‚\nç›®æ ‡çº¿ç¨‹è¿”å›è‡ªå·±çš„ Context ç»“æ„ä½“ã€‚\nè¿™ç§å†™æ³•ä¸‹ï¼Œæ¯ä¸ª os-\u0026gt;trap æœ€ç»ˆè¿”å›çš„ Context ç»“æ„ä½“å°±æ˜¯ä¼ è¿›æ¥çš„é‚£ä¸ªï¼Œå› æ­¤ä¸éœ€è¦å¯¹ Context åšé¢å¤–çš„ä¿å­˜ã€‚è¿™å…¶ä¸­æœ‰ä¸€äº›ç»†èŠ‚éœ€è¦æ³¨æ„ï¼š\nscheduler çº¿ç¨‹å¿…é¡»æ‰“å¼€ä¸­æ–­ï¼Œæ¯”å¦‚å½“å‰æ‰€æœ‰ input_task çº¿ç¨‹éƒ½å¤„äºç¡çœ çŠ¶æ€ï¼Œæˆ‘ä»¬åªæœ‰è®©è°ƒåº¦å™¨çº¿ç¨‹å“åº”é”®ç›˜ä¸­æ–­ä¿¡å·ï¼Œæ‰èƒ½å”¤é†’è¿™äº› input_task çº¿ç¨‹ã€‚ CPU ä¸Šé”ä¹‹å‰çš„ä¸­æ–­å¼€å…³æƒ…å†µæ˜¯ä¸€ä¸ª proc local çš„çŠ¶æ€ï¼Œåœ¨è°ƒç”¨ swtch() åˆ‡æ¢å‰å¿…é¡»ä¿å­˜ä¸‹æ¥ï¼šæ¯”å¦‚åœ¨ç¬”è€…çš„å®ç°ä¸­ï¼Œæˆ‘ä»¬å¯èƒ½æ˜¯åœ¨ä¸­æ–­å¤„ç†ç¨‹åºä¸­ yieldï¼Œè¿™æ—¶ intena æ˜¯å…³ä¸­æ–­çŠ¶æ€ï¼›è€Œä¿¡å·é‡çš„ sleep() ä¸­ä¹Ÿä¼šè°ƒç”¨ swtch()ï¼Œè¿™æ—¶ intena æ˜¯å¼€ä¸­æ–­çŠ¶æ€ã€‚ ä¸ä½¿ç”¨ AM API çš„æœ€å¤§åå¤„æ˜¯ï¼šæˆ‘ä»¬å¿…é¡»æ‰‹åŠ¨ç»´æŠ¤ç¬¬ä¸€æ¬¡è¿›å…¥ä¸€ä¸ªçº¿ç¨‹çš„è¿‡ç¨‹ï¼Œå› ä¸ºæˆ‘ä»¬ä¹‹ååˆ‡æ¢åˆ°ä¸€ä¸ªçº¿ç¨‹ä¾èµ–çš„æ˜¯å®ƒä¹‹å‰æœ‰ä¸€ä¸ª swtch() åˆ° scheduler çš„ç°åœºï¼Œä½†ä¸€ä¸ªè¿›ç¨‹åˆšè¢«åˆ›å»ºæ—¶æ²¡æœ‰ç°åœºã€‚ç¬”è€…çš„è§£å†³æ–¹æ³•æ˜¯ï¼šä¼ªé€ ä¸€ä¸ªå¯„å­˜å™¨ç°åœºå®Œæˆæ ˆåˆ‡æ¢ï¼Œå¹¶é€šè¿‡ä¸€ä¸ªå…§è”æ±‡ç¼–çš„ wrapper call ç›´æ¥è·³è½¬åˆ°ç›®æ ‡å‡½æ•°æ‰§è¡Œ (ç±»ä¼¼ M2)ã€‚ Semaphore ç¬”è€…ä¸ºæ¯ä¸ªä¿¡å·é‡å‡†å¤‡äº†ä¸€æŠŠé”ï¼Œè¿™æ ·å¯ä»¥ç”¨ç±»ä¼¼æ¡ä»¶å˜é‡çš„æ–¹å¼å®ç°ä¿¡å·é‡ã€‚sem_wait() å’Œ sem_post() å…±ç”¨ä¿¡å·é‡çš„é”ï¼Œsleep() é€šè¿‡çº¿ç¨‹çš„é”æ¥ä¿è¯åŸå­æ€§ã€‚è¿™å…¶ä¸­çš„å…³é”®ç»†èŠ‚åœ¨äº sleep() ä¸­å…ˆè·å–çº¿ç¨‹é”å†é‡Šæ”¾ä¿¡å·é‡é”ï¼Œè¿™æ ·å¯¹äº wait() å‡½æ•°æ¥è¯´ï¼Œsleep() é‡Šæ”¾é”ã€çº¿ç¨‹ç¡çœ  (ä¿®æ”¹çº¿ç¨‹çš„çŠ¶æ€) å’Œçº¿ç¨‹åˆ‡æ¢è¿™å‡ ä¸ªæ­¥éª¤å°±æ˜¯åŸå­çš„ã€‚\næœ‰äº†ä¿¡å·é‡ä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ binary semaphore ä½œä¸ºä¸€ä¸ªç¡çœ é”ï¼Œåœ¨é•¿ä¸´ç•ŒåŒºçš„ä»£ç ç‰‡æ®µä¸­ç¡çœ é”å¯ä»¥æå‡æ•ˆç‡ã€‚\nTesting Producer Consumer åœ¨å¤šæ ¸ä¸Šå¤šçº¿ç¨‹è·‘ç”Ÿäº§è€…æ¶ˆè´¹è€…æ˜¯ä¸€ç§æ¯”è¾ƒå¥½çš„æš´éœ²å¹¶å‘ bug çš„å¥½æ–¹æ³•ã€‚åœ¨æµ‹è¯•é›†çš„å‚æ•°ä¸Šç¬”è€…æœ‰å¦‚ä¸‹å¿ƒå¾—ï¼š\næˆ‘ä»¬å¹¶ä¸éœ€è¦å°†æ‹¬å·æ‰“å°åœ¨å±å¹•ä¸Šè‚‰çœ¼æ£€æŸ¥ï¼Œå¯ä»¥é€‰æ‹©å†™ä¸€ä¸ª python ç¨‹åºæ¥æ”¶ oslab çš„è¾“å‡ºè‡ªåŠ¨æ£€æŸ¥ï¼Œæˆ–è€…åœ¨ oslab çš„æ‹¬å·è¾“å‡ºå‡½æ•°ä¸­ç›´æ¥ä¿®æ”¹ä¸€ä¸ªå…¨å±€è®¡æ•°å™¨å¹¶æ‰§è¡Œæ£€æŸ¥ã€‚ åˆ›å»ºè¾ƒå¤šçš„çº¿ç¨‹ï¼Œå°†æ‹¬å·çš„åµŒå¥—å±‚æ•°è°ƒå¾—æµ…ä¸€äº› (æ¯”å¦‚ 5 ä»¥å†…) æ¯”è¾ƒæœ‰åˆ©äºæµ‹è¯•å¹¶å‘æ­£ç¡®æ€§ï¼Œå› ä¸ºåµŒå¥—å±‚æ•°æµ…æ—¶æ›´å®¹æ˜“è§¦å‘é”™è¯¯ï¼Œä»¥åŠç”Ÿäº§è€…/æ¶ˆè´¹è€…çš„ç¡çœ æ¡ä»¶æ›´å®¹æ˜“æ»¡è¶³ï¼Œç¨‹åºçš„å¹¶å‘è¡Œæ›´é«˜ã€‚ åˆ›å»ºè¾ƒå°çš„çº¿ç¨‹å¯èƒ½æœ‰åˆ©äºæ£€æŸ¥æ­»é”é”™è¯¯ã€‚ dev Test Suite ä¸€æ¬¡å®Œæ•´çš„è¾“å…¥è¾“å‡ºä¼šç»è¿‡å¦‚ä¸‹æ­¥éª¤ï¼š\ntty_reader çº¿ç¨‹å‘ tty è¾“å‡ºå‘½ä»¤è¡Œæç¤ºç¬¦ï¼Œç„¶åè°ƒç”¨ tty çš„ read() å‡½æ•°ã€‚tty çš„ read() å‡½æ•°è¦ç­‰å¾… tty_cook() çš„ä¿¡å·ï¼Œå› æ­¤æš‚æ—¶æŒ‚èµ·ã€‚\næ¯å½“ç”¨æˆ·æŒ‰ä¸‹ä¸€ä¸ªé”®ï¼Œç¡¬ä»¶ä¼šç”Ÿæˆä¸€ä¸ªä¸­æ–­ï¼Œdev æµ‹è¯•é›†ä¸­çš„ input_notify() å‡½æ•°è´Ÿè´£å¤„ç†è¿™ä¸ªä¸­æ–­ï¼Œå®ƒä¼šå‘é€ä¸€ä¸ª kbdirq ä¿¡å·ï¼Œå”¤é†’æ­£åœ¨ç¡çœ çš„ input_task çº¿ç¨‹ã€‚input_task çº¿ç¨‹ä»è®¾å¤‡å¯„å­˜å™¨ä¸­è¯»å–æŒ‰é”®çš„å†…å®¹ï¼Œæ›´æ–°å½“å‰çš„é”®ç›˜æŒ‰é”®çŠ¶æ€ï¼Œè°ƒç”¨ push_event() å°†æŒ‰é”®äº‹ä»¶æ”¾å…¥ in-\u0026gt;events[] é˜Ÿåˆ—ä¸­ï¼Œå¹¶å‘é€ä¸€ä¸ª event_sem ä¿¡å·ã€‚æ­¤å¤–ï¼Œæ—¶é’Ÿä¸­æ–­ä¹Ÿä¼šå‘é€ kbdirq ä¿¡å·å”¤é†’ input_task çº¿ç¨‹ï¼Œå¦‚æœä¸€æ®µæ—¶é—´å†…æ²¡æœ‰ä»»ä½•æŒ‰é”®ï¼Œinput_task ä¼š push ä¸€ä¸ªç©ºçš„æŒ‰é”®äº‹ä»¶å¹¶å‘é€ event_semï¼Œå‘åˆ«çš„çº¿ç¨‹æä¾›ä¸€ä¸ªä¼ªæ—¶é’Ÿã€‚\ntty_task çº¿ç¨‹ä¼šä¸æ–­è°ƒç”¨ input_read() å‡½æ•°è¯»å–é”®ç›˜è¾“å…¥ï¼Œinput_read() ä¼šè°ƒç”¨ pop_event() ä» in-\u0026gt;events[] é˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªæŒ‰é”®äº‹ä»¶è¿”å›ï¼Œå¯¹äºä¸€ä¸ªæ™®é€šçš„æŒ‰é”®äº‹ä»¶ï¼Œtty_task ä¼šè°ƒç”¨ tty_cook() å‡½æ•°å°†å­—ç¬¦åŠ å…¥ä¸€ä¸ªå’Œè¯»å–çº¿ç¨‹å…±äº«çš„é˜Ÿåˆ— (ä¿æŠ¤è¯¥é˜Ÿåˆ—çš„é”æ˜¯ tty-\u0026gt;lock)ï¼Œå¹¶è°ƒç”¨ ttydev-\u0026gt;ops-\u0026gt;write å°†å­—ç¬¦å›æ˜¾åœ¨ tty ä¸Šã€‚\ntty_cook() è°ƒç”¨ tty_enqueue() å‡½æ•°å°†å­—ç¬¦æ”¾å…¥é˜Ÿåˆ— tty-\u0026gt;queueï¼Œå¦‚æœé‡åˆ°æ¢è¡Œç¬¦ \\nï¼Œtty_cook() ä¼šå‘é€ cooked ä¿¡å·æ¥å”¤é†’ tty_reader çº¿ç¨‹ã€‚\ntty_read() å‡½æ•°è¢«å”¤é†’åï¼Œä¼šå°†é˜Ÿåˆ—é‡Œçš„å­—ç¬¦æ‹·è´åˆ°æŒ‡å®šçš„åœ°å€ã€‚ç„¶å tty_reader çº¿ç¨‹æ‰“å°ç›¸åº”çš„é•¿åº¦ä¿¡æ¯ã€‚\næ³¨ï¼štty_read() æ‰“å°ä¿¡æ¯å’Œå­—ç¬¦å›æ˜¾çš„å…ˆåæ— æ³•ä¿è¯ã€‚è¿™é‡Œç†åº”æœ‰çš„é¡ºåºæ˜¯ï¼šåœ¨å­—ç¬¦å›æ˜¾å®Œæˆå tty_reader è¢«å”¤é†’å¹¶æ‰“å°ä¿¡æ¯ï¼›tty_reader æ‰“å°å‡ºä¸‹ä¸€ä¸ªå‘½ä»¤è¡Œæç¤ºç¬¦ä¹‹åå†è¿›è¡Œå­—ç¬¦å›æ˜¾ç¤ºã€‚å¦‚æœè¦è·å¾—æ›´å¥½çš„ä½“éªŒå¯èƒ½éœ€è¦ä¸€äº›åŒæ­¥æœºåˆ¶ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"7d83881d248fbc7ec98f7e99e83f5443","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/labs/lab02/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/labs/lab02/","section":"notes","summary":"Overview è¯¥å®éªŒçš„ä¸»è¦å†…å®¹æ˜¯å®ç°å†…æ ¸çº¿ç¨‹çš„è°ƒåº¦ã€‚æœ¬å®éªŒæŠ¥å‘Šä¸»è¦è®°å½•ä¸€äº›æœ‰è¶£çš„è®¾è®¡å’Œæµ‹è¯•æ–¹æ³•ã€‚\nDesignation spinlock åœ¨ L2 ä¸­æˆ‘ä»¬éœ€è¦å®ç°ä¸€ä¸ªç›¸è¾ƒäº L1 æ›´åŠ ç²¾ç»†çš„è‡ªæ—‹é”ã€‚åœ¨å¼•å…¥äº†ä¸­æ–­æœºåˆ¶åï¼Œæˆ‘ä»¬åœ¨ä¸´ç•ŒåŒºå†…éœ€è¦å…³é—­ä¸­æ–­ï¼Œå¦åˆ™ä¸€æ—¦æŒæœ‰é”çš„çº¿ç¨‹è¢«è°ƒåº¦ä¸‹äº† CPU ä¸€æ•´ä¸ªæ—¶é—´ç‰‡å°±ä¼šå¡ä½ã€‚æˆ‘ä»¬éœ€è¦å°å¿ƒåœ°ç»´æŠ¤ä¸­æ–­çš„åµŒå¥—ã€‚æˆ‘ä»¬éœ€è¦ä¸€ä¸ª per-cpu çš„å˜é‡æ¥è®°å½•ä¸­æ–­åµŒå¥—çš„å±‚æ•°ï¼Œåœ¨ç¬¬ä¸€å±‚çš„æ—¶å€™å…³é—­ä¸­æ–­ï¼Œå¹¶åœ¨æœ€åä¸€å±‚è¢«è§£å¼€æ—¶æ‰“å¼€ä¸­æ–­ã€‚\nInline Assembly ç¬”è€…çš„åˆä»£å®ç°ä½¿ç”¨äº†å…§è”æ±‡ç¼–è¿›è¡Œæ ˆåˆ‡æ¢ (æ¨¡ä»¿ xv6 çš„è®¾è®¡)ï¼Œå› è€Œæ˜¯æ¶æ„ç›¸å…³çš„ (ç¬”è€…é’ˆå¯¹ x86-64 å’Œ x86 å„å†™äº†ä¸€éæ±‡ç¼–)ã€‚åœ¨è¿™ç§å®ç°ä¸‹ï¼Œä¸€æ¬¡çº¿ç¨‹åˆ‡æ¢ (ä»¥æ—¶é’Ÿä¸­æ–­ä¸ºä¾‹) ä¼šç»å†å¦‚ä¸‹å†ç¨‹ï¼š\nç»è¿‡ AM ä¸­çš„ä¸€äº›ä»£ç åï¼Œä¸Šä¸‹æ–‡ä¿å­˜åœ¨äº†æ ˆä¸Šçš„ Context ç»“æ„ä½“ä¸­ï¼Œè¿›å…¥ os-\u0026gt;trapã€‚","tags":null,"title":"Lab 02: Kernel Multi-Threads","type":"docs"},{"authors":null,"categories":null,"content":"Overview è¯¥å®éªŒçš„ä¸»è¦å†…å®¹æ˜¯å®ç°ç”¨æˆ·è¿›ç¨‹ã€‚ç”¨æˆ·è¿›ç¨‹å¯ä»¥ç†è§£ä¸ºå¥—ä¸Šäº†è™šæ‹Ÿå†…å­˜çš„çº¿ç¨‹ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦å¼•å…¥ VME ç³»åˆ—çš„ APIã€‚æœ¬å®éªŒæŠ¥å‘Šä¸»è¦è®°å½•ä¸€äº›æœ‰è¶£çš„è®¾è®¡å’Œé‡åˆ°çš„ bugã€‚\nDesignation ucontext() ç”±äºç¬”è€…åœ¨ L2 ä¸­é€‰æ‹©äº†é€šè¿‡æ±‡ç¼–æ‰§è¡Œæ ˆåˆ‡æ¢å’Œæ‰§è¡Œæµåˆ‡æ¢çš„æ“ä½œï¼Œå› æ­¤åœ¨ L3 çš„å¼€å§‹è¦åšä¸€äº›é¢å¤–çš„æ”¹è¿›ã€‚åœ¨ L2 ä¸­æ²¡æœ‰è™šæ‹Ÿå†…å­˜å’Œé¡µè¡¨åˆ‡æ¢çš„æ¦‚å¿µï¼Œå› æ­¤ç¬¬ä¸€æ¬¡è¿›å…¥ä¸€ä¸ªçº¿ç¨‹çš„æ—¶å€™æˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“åœ°é€šè¿‡ä¸€ä¸ªå…§è”æ±‡ç¼–çš„ wrapper call ç›´æ¥è·³è½¬åˆ°çº¿ç¨‹ä»£ç æ‰§è¡Œã€‚ä½†å¼•å…¥äº†ç”¨æˆ·è¿›ç¨‹åï¼Œåˆå§‹ä¸Šä¸‹æ–‡ç»“æ„ä½“çš„åˆ›å»ºå˜å¾—æ¯”è¾ƒå›°éš¾ï¼Œè¿”å›ç”¨æˆ·æ€ä¹Ÿéœ€è¦åšæ›´å¤šçš„äº‹æƒ… (æ¯”å¦‚é¡µè¡¨åˆ‡æ¢ï¼Œå¼¹æ ˆç­‰)ï¼Œå› æ­¤ç¬”è€…å¸Œæœ›ä½¿ç”¨ AM çš„ APIã€‚è¿™å°±äº§ç”Ÿäº†ä¸€äº›çŸ›ç›¾ã€‚\nå¹¸è¿çš„æ˜¯ï¼Œç¬”è€…å‘ç° AM ä¸­ trap64.S ä¸­çš„æ±‡ç¼–å‡½æ•° __am_iret() æ˜¯æœ‰ label çš„ï¼Œè¿™æ„å‘³ç€ç¬”è€…åªéœ€è¦æŠ„å†™ä¸€äº› AM çš„å¤´æ–‡ä»¶ï¼Œå°±å¯ä»¥è°ƒç”¨ __am_iret() æ¥å®Œæˆç”¨æˆ·æ€çš„è¿”å›ã€‚ ç¬”è€…æœ€ç»ˆçš„ä»£ç æ˜¯è¿™æ ·æƒè¡¡çš„ï¼š\nå› ä¸ºè°ƒåº¦å™¨ swtch() çš„åŸç†æ˜¯æ¢å¤å†…æ ¸çº¿ç¨‹æ‰§è¡Œçš„ä¸Šä¸‹æ–‡ï¼Œæ‰€ä»¥æˆ‘ä»¬ä»ç„¶éœ€è¦ä¸€ä¸ªç±»ä¼¼äº xv6 ä¸­ forkret() å‡½æ•°é‚£æ ·çš„ä¸œè¥¿ä½œä¸ºä¸€ä¸ªè¿›ç¨‹ç¬¬ä¸€æ¬¡è¿›å…¥ç”¨æˆ·æ€çš„è·³æ¿ã€‚åˆ›å»ºè¿›ç¨‹æ—¶ï¼Œæˆ‘ä»¬éœ€è¦ä¼ªé€ ä¸€ä¸ªå†…æ ¸çº¿ç¨‹çš„æ‰§è¡Œç°åœºæ¥è®©è°ƒåº¦å™¨è·³è½¬åˆ°ä¸€ä¸ªå‡½æ•° task_start()ã€‚ åœ¨ task_start() ä¸­ï¼Œæˆ‘ä»¬éœ€è¦å®Œæˆ AM ä¸­ä» user_handler() è¿”å›åˆ°è°ƒç”¨ __am_iret() ä¹‹é—´åšçš„äº‹æƒ…ï¼Œå³åˆ‡æ¢ç”¨æˆ·é¡µè¡¨å’Œæ ˆæŒ‡é’ˆã€‚ç„¶åè°ƒç”¨ __am_iret() å®Œæˆæœ€åçš„å·¥ä½œå³å¯ (å¼¹æ ˆ+iretq è¿”å›ç”¨æˆ·æ€)ã€‚ Page Table Walk VME å¯¹å¤–çš„æ¥å£æ²¡æœ‰ page table walkï¼Œè¿™è®©è¿›ç¨‹çš„å¤åˆ¶å˜å¾—å›°éš¾ï¼šæˆ‘ä»¬æ— æ³•åˆ›å»ºå‡ºä¸€ä¸ªå’Œçˆ¶è¿›ç¨‹é¡µè¡¨ä¸€æ¨¡ä¸€æ ·çš„å­è¿›ç¨‹é¡µè¡¨ã€‚ä¸€ç§é€‰æ‹©æ˜¯åœ¨å†…æ ¸ä»£ç ä¸­å¯¹ç€ vme.c ä¸­çš„ ptwalk() å†™ä¸€ä¸ªåŠŸèƒ½ç±»ä¼¼çš„å‡½æ•°ï¼Œä½†ç¬”è€…ä½¿ç”¨äº†æ¯”è¾ƒç®€å•çš„å®ç°ï¼šåœ¨æ¯ä¸ªè¿›ç¨‹ä¸­é¢å¤–ç»´æŠ¤äº†ä¸€ä¸ªé“¾è¡¨ï¼Œè®°å½•äº†è¯¥è¿›ç¨‹æ‹¥æœ‰çš„æ‰€æœ‰è™šæ‹Ÿé¡µé¢ä»¥åŠå…¶å¯¹åº”çš„ç‰©ç†åœ°å€å’Œä¿æŠ¤å‚æ•°ã€‚é“¾è¡¨è¿™æ ·æ‰å¹³çš„ç»“æ„ä¼šä½¿å¾—å°†æ¥çš„æŸ¥æ‰¾æ•ˆç‡å˜ä½ï¼Œä½†æ¯”è¾ƒå®¹æ˜“å†™å¯¹ä¸”æ¯”è¾ƒç®€å•ã€‚\nwait()/exit() xv6 book ä¸­èŠ±äº†å¤§é‡ç¯‡å¹…è®²è§£è¿™ä¸¤ä¸ª APIï¼Œå› ä¸ºè¿™é‡Œå¤„ç†ç¨æœ‰ä¸æ…å°±å¯èƒ½å¯¼è‡´ data race æˆ–æ­»é”ã€‚åœ¨ oslab ä¸­è¯¥é—®é¢˜çš„éš¾åº¦å¤§å¹…ä¸‹é™ï¼Œå› ä¸ºæˆ‘ä»¬ä¸éœ€è¦åœ¨ exit() æ—¶å°†å­¤å„¿è¿›ç¨‹ reparent ç»™ initï¼Œä½†ä»éœ€è¦éå¸¸å°å¿ƒã€‚\nç¬”è€…åœ¨ä¹¦å†™ä»£ç æ—¶æ³¨æ„äº†é”çš„å…¨å±€æ‹“æ‰‘åºé—®é¢˜ï¼šç¬”è€…è§„å®šä»»æ„ä¸€å¤„ä»£ç å¦‚æœè¦åŒæ—¶è·å¾—ä¸¤ä¸ªè¿›ç¨‹çš„é”ï¼Œå¿…é¡»å…ˆè·å¾—çˆ¶è¿›ç¨‹çš„é”å†è·å¾—å­è¿›ç¨‹çš„é”ï¼Œè¿™æ ·ä¸€å®šç¨‹åº¦ä¸Šé¿å…äº†æ­»é”é£é™©ã€‚\nCopy-on-write Fork å®ç° cow fork çš„åŸºæœ¬æ€è·¯ä¸ºï¼šåœ¨çˆ¶è¿›ç¨‹ fork æ—¶ï¼Œå°†é¡µé¢çš„å†™å…¥æƒé™å»æ‰ï¼Œå¹¶è®©çˆ¶å­è¿›ç¨‹çš„é¡µè¡¨æŒ‡å‘åŒä¸€ä¸ªç‰©ç†é¡µé¢ã€‚å°†æ¥å¦‚æœæŸä¸ªè¿›ç¨‹å¯¹è¯¥é¡µé¢å†™å…¥ï¼Œåˆ™ä¼šè§¦å‘ page faultï¼Œåœ¨ page fault handler ä¸­æˆ‘ä»¬æ–°ç”³è¯·ä¸€ä¸ªé¡µé¢ï¼Œå°†åŸé¡µé¢çš„å†…å®¹å¤åˆ¶ä¸€ä»½ï¼Œä¿®æ”¹å½“å‰è¿›ç¨‹çš„é¡µè¡¨ä½¿å…¶æŒ‡å‘æ–°é¡µé¢ï¼Œå¹¶é‡æ–°èµ‹äºˆå…¶å†™å…¥æƒé™ã€‚\ncow fork ä¼šå¸¦æ¥ä¸€äº›é¢å¤–çš„ç»†èŠ‚ï¼Œæ¯”å¦‚æˆ‘ä»¬éœ€è¦å¯¹æ¯ä¸ªé¡µé¢ç»´æŠ¤ä¸€ä¸ª reference count è¡¨ç¤ºå½“å‰æœ‰å¤šå°‘ä¸ªè¿›ç¨‹ä½¿ç”¨è¿™ä¸ªé¡µé¢ã€‚åœ¨é‡Šæ”¾ä¸€ä¸ªè¿›ç¨‹æ—¶æˆ‘ä»¬ä¸èƒ½ç›´æ¥é‡Šæ”¾å®ƒæ‰€æœ‰çš„ç‰©ç†é¡µé¢ï¼Œè€Œæ˜¯è¦ä¿®æ”¹å…¶ reference countï¼Œåªæœ‰ä¸€ä¸ªé¡µé¢çš„ reference count å˜ä¸º 0 æ—¶æ‰èƒ½é‡Šæ”¾ã€‚ç¬”è€…çš„è®¾è®¡æ˜¯å°† reference count çš„å¢åŠ å·¥ä½œæ”¾åœ¨ fork() å’Œ pgmap() ä¸­ï¼Œå°† reference count çš„å‡å°‘å·¥ä½œæ”¾åœ¨ kfree() ä¸­ï¼Œç”± kfree() åˆ¤æ–­å½“å‰å‡å®Œ rfcnt åæ˜¯å¦éœ€è¦æ‰§è¡ŒçœŸæ­£çš„ free()ï¼Œè¿™æ ·è®¾è®¡çš„å¥½å¤„åœ¨äºä¹‹å‰å†™çš„æ¶‰åŠ free çš„ä»£ç ä¸éœ€è¦ä¿®æ”¹ã€‚\néœ€è¦æ ¼å¤–æ³¨æ„çš„æ˜¯åœ¨å¼•å…¥ cow fork åï¼Œä¸€ä¸ªé¡µé¢å°±ä¸åªæ˜¯ä¸€ä¸ªè¿›ç¨‹çš„â€œèµ„äº§â€äº†ï¼Œåœ¨å¤„ç†é¡µé¢ metadata ç›¸å…³çš„ä¿¡æ¯æ—¶è¦è®°å¾—ä¸Šé”ã€‚\nmmap() ç”¨æˆ·è¿›ç¨‹çš„è™šæ‹Ÿåœ°å€ç©ºé—´ç†åº”ä»¥é¡µä¸ºåŸå­å•ä½ï¼Œå› æ­¤ç¬”è€…å°† mmap() å‚æ•°ä¸­çš„ length å‘ pgsize ä¸Šå–æ•´ã€‚åˆ†é…æ—¶æˆ‘ä»¬è¦ç¡®å®šä¸€ä¸ªåœ°å€ addr æ˜¯å¦æ»¡è¶³ [addr, addr + length) ä¸å½“å‰åœ°å€ç©ºé—´æ²¡æœ‰å†²çªï¼Œç”±äºæ— æ³•ç›´æ¥è®¿é—®é¡µè¡¨ï¼Œè¯¥æ£€æŸ¥ç¬”è€…é€šè¿‡ä¹‹å‰æåˆ°çš„é“¾è¡¨å®Œæˆï¼Œè¿™ä¸€éƒ¨åˆ†æ•ˆç‡æ¯”è¾ƒä½ä¸‹ã€‚\nmmap() è¦æ³¨æ„ MAP_PRIVATE å’Œ MAP_SHARED ä¸¤ç§é¡µé¢çš„æ€§è´¨å·®å¼‚ã€‚å¯¹äºå‰è€…ï¼Œfork æ—¶è¦è¿›è¡Œ copy-on-write çš„å¤„ç†ï¼Œå»æ‰å†™å…¥æƒé™å¹¶åœ¨ page fault handler ä¸­è¿›ä¸€æ­¥å¤„ç†ï¼›å¯¹äºåè€…ï¼Œfork æ—¶ä¸éœ€è¦åšæ”¹åŠ¨ã€‚çˆ¶å­è¿›ç¨‹å¯¹äº MAP_SHARED çš„é¡µé¢çš„è¯»å†™çš„å®‰å…¨æ€§ç”±ç”¨æˆ·è‡ªå·±ä¿è¯ã€‚\nInteresting Bugs dfs-fork() ç¬”è€…åœ¨ç§»æ¤ dfs-fork æ—¶é‡åˆ°äº†ç”¨æˆ·æ€æŒ‡é’ˆè·‘é£çš„æƒ…å†µã€‚ç»è¿‡æ£€æŸ¥å‘ç°è·‘é£çš„åœ°å€å°±æ˜¯ dfs-fork.c ä¸­ map[] æ•°ç»„çš„åœ°å€ã€‚ç»è¿‡ä»”ç»†æ£€æŸ¥ï¼Œç¬”è€…å‘ç° Makefile ä¸­çš„å‘½ä»¤\nx86_64-linux-gnu-ld -static --omagic --pic-executable --no-dynamic-linker --gc-sections -o _init -e _start trampoline.o ./printf.o ./init.o x86_64-linux-gnu-objcopy -S -j .text* -j.rodata* -j .data* -j .bss* --set-section-flags .bss=alloc,contents -O binary _init å‰è€…å¹¶ä¸èƒ½ä¿è¯æ•´ä¸ªç¨‹åºé™æ€é“¾æ¥ï¼Œmap[] çš„åœ°å€è¢«æ”¾åœ¨äº† GOT ä¸­ã€‚åœ¨åç»­çš„ objcopy ä¸­ï¼Œåªæœ‰ä»£ç èŠ‚ã€æ•°æ®èŠ‚ã€.bss èŠ‚è¢«ä¿ç•™äº†ä¸‹æ¥ï¼Œä»è€Œ map[] çš„åœ°å€ä¸¢å¤±äº†ã€‚\nåœ¨ dfs-fork çš„å…¨å±€æ•°ç»„å‰åŠ ä¸Š static ä¿®é¥°å°±å¯ä»¥å°†æ•°ç»„æ”¾åˆ°æ•°æ®èŠ‚ä¸­ï¼Œä»è€Œè§£å†³è¿™ä¸ªé—®é¢˜ã€‚\nPage Table Teardown ç¬”è€…åœ¨ç§»æ¤ dfs-fork è¿›è¡Œå¤šæ ¸æµ‹è¯•æ—¶æ›¾ç»é‡åˆ°ç¥ç§˜çš„ CPU resetã€‚ç»è¿‡æ’æŸ¥å‘ç°è¿™æ¶‰åŠä¸€ä¸ªæ¯”è¾ƒå¾®å¦™çš„é¡µè¡¨é—®é¢˜ã€‚å‡è®¾ä¸€ä¸ªæ ¸ä¸Šçˆ¶è¿›ç¨‹æ­£åœ¨ wait()ï¼Œå¦ä¸€ä¸ªæ ¸ä¸Šå­è¿›ç¨‹åœ¨ exit()ã€‚æ ¹æ®ç¬”è€…çš„è®¾è®¡ï¼Œå­è¿›ç¨‹ exit() åä¼šå”¤é†’æ­£åœ¨ç­‰å¾…çš„çˆ¶è¿›ç¨‹ï¼Œç„¶åè·³è½¬åˆ°è°ƒåº¦å™¨çº¿ç¨‹ã€‚ä½†éœ€è¦æ³¨æ„çš„æ˜¯è°ƒåº¦å™¨çº¿ç¨‹ç°åœ¨ä½¿ç”¨çš„ä»ç„¶æ˜¯â€œå­è¿›ç¨‹â€çš„é¡µè¡¨ã€‚çˆ¶è¿›ç¨‹é†’æ¥åå‘ç°æœ‰åƒµå°¸å­è¿›ç¨‹ï¼Œäºæ˜¯å›æ”¶èµ„æºï¼Œå›æ”¶æ—¶è°ƒç”¨ unprotect() é”€æ¯å­è¿›ç¨‹çš„é¡µè¡¨ï¼Œä»è€Œå¯¼è‡´å¦ä¸€ä¸ªæ ¸çš„è°ƒåº¦å™¨çº¿ç¨‹ crashã€‚\nå¦‚æœåœ¨ L2 ä¸­æ²¡æœ‰ä½¿ç”¨å…§è”æ±‡ç¼–åšæ ˆåˆ‡æ¢ï¼Œæˆ‘ä»¬åº”è¯¥ä¼šæœ‰ä¸€ä¸ªâ€œç­‰å¾…ä¸‹ä¸€æ¬¡è¿›å…¥ os_trap å†é‡Šæ”¾ä¸Šä¸€æ¬¡è¿›å…¥ os_trap çš„è¿›ç¨‹çš„é”â€ çš„æ“ä½œï¼Œè¿™ä¸ªæ“ä½œåœ¨ L3 ä¸­åŒæ—¶å¯ä»¥ç¡®ä¿é¡µè¡¨ä¸ä¼šè¢«æå‰ teardownã€‚ä½†ç¬”è€…çš„ L2 è®¾è®¡çš„ç‰¹æ®Šæ€§å¯¼è‡´äº†è¿™é‡Œå¿…é¡»å¤„ç†è¿™æ ·ä¸€ä¸ªç›¸ä¼¼çš„é—®é¢˜ã€‚ç¬”è€…çš„è§£å†³æ–¹æ³•éå¸¸ç®€å•ï¼šç”¨æˆ·è¿›ç¨‹åœ¨é™·å…¥å†…æ ¸åæ‰§è¡Œçš„éƒ½æ˜¯å†…æ ¸ä»£ç ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åœ¨ os_trap çš„å¼€å¤´æŠŠé¡µè¡¨åˆ‡æ¢æˆå†…æ ¸é¡µè¡¨ï¼Œè¿™æ ·å°±ä¸ä¼š crash äº†ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"87fbeacf335707ab13c4b4de2567b40c","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/labs/lab03/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/labs/lab03/","section":"notes","summary":"Overview è¯¥å®éªŒçš„ä¸»è¦å†…å®¹æ˜¯å®ç°ç”¨æˆ·è¿›ç¨‹ã€‚ç”¨æˆ·è¿›ç¨‹å¯ä»¥ç†è§£ä¸ºå¥—ä¸Šäº†è™šæ‹Ÿå†…å­˜çš„çº¿ç¨‹ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦å¼•å…¥ VME ç³»åˆ—çš„ APIã€‚æœ¬å®éªŒæŠ¥å‘Šä¸»è¦è®°å½•ä¸€äº›æœ‰è¶£çš„è®¾è®¡å’Œé‡åˆ°çš„ bugã€‚\nDesignation ucontext() ç”±äºç¬”è€…åœ¨ L2 ä¸­é€‰æ‹©äº†é€šè¿‡æ±‡ç¼–æ‰§è¡Œæ ˆåˆ‡æ¢å’Œæ‰§è¡Œæµåˆ‡æ¢çš„æ“ä½œï¼Œå› æ­¤åœ¨ L3 çš„å¼€å§‹è¦åšä¸€äº›é¢å¤–çš„æ”¹è¿›ã€‚åœ¨ L2 ä¸­æ²¡æœ‰è™šæ‹Ÿå†…å­˜å’Œé¡µè¡¨åˆ‡æ¢çš„æ¦‚å¿µï¼Œå› æ­¤ç¬¬ä¸€æ¬¡è¿›å…¥ä¸€ä¸ªçº¿ç¨‹çš„æ—¶å€™æˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“åœ°é€šè¿‡ä¸€ä¸ªå…§è”æ±‡ç¼–çš„ wrapper call ç›´æ¥è·³è½¬åˆ°çº¿ç¨‹ä»£ç æ‰§è¡Œã€‚ä½†å¼•å…¥äº†ç”¨æˆ·è¿›ç¨‹åï¼Œåˆå§‹ä¸Šä¸‹æ–‡ç»“æ„ä½“çš„åˆ›å»ºå˜å¾—æ¯”è¾ƒå›°éš¾ï¼Œè¿”å›ç”¨æˆ·æ€ä¹Ÿéœ€è¦åšæ›´å¤šçš„äº‹æƒ… (æ¯”å¦‚é¡µè¡¨åˆ‡æ¢ï¼Œå¼¹æ ˆç­‰)ï¼Œå› æ­¤ç¬”è€…å¸Œæœ›ä½¿ç”¨ AM çš„ APIã€‚è¿™å°±äº§ç”Ÿäº†ä¸€äº›çŸ›ç›¾ã€‚\nå¹¸è¿çš„æ˜¯ï¼Œç¬”è€…å‘ç° AM ä¸­ trap64.S ä¸­çš„æ±‡ç¼–å‡½æ•° __am_iret() æ˜¯æœ‰ label çš„ï¼Œè¿™æ„å‘³ç€ç¬”è€…åªéœ€è¦æŠ„å†™ä¸€äº› AM çš„å¤´æ–‡ä»¶ï¼Œå°±å¯ä»¥è°ƒç”¨ __am_iret() æ¥å®Œæˆç”¨æˆ·æ€çš„è¿”å›ã€‚ ç¬”è€…æœ€ç»ˆçš„ä»£ç æ˜¯è¿™æ ·æƒè¡¡çš„ï¼š","tags":null,"title":"Lab 03: User Level Processes","type":"docs"},{"authors":null,"categories":null,"content":"æˆ‘ä»¬å¯ä»¥é€šè¿‡éšæœºè¯•éªŒæ¥ç ”ç©¶éšæœºç°è±¡ã€‚éšæœºè¯•éªŒåº”å½“å…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š\nç›¸åŒæ¡ä»¶ä¸‹å¯é‡å¤ï¼› è¯•éªŒç»“æœä¸å”¯ä¸€ï¼Œè¯•éªŒå‰æœªçŸ¥ï¼Œä½†æ‰€æœ‰å¯èƒ½çš„ç»“æœå·²çŸ¥ï¼› æ¦‚ç‡ç©ºé—´æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(\\Omega, \\mathscr F, P)$ï¼Œå…¶ä¸­ $\\Omega$ ä¸ºæ ·æœ¬ç©ºé—´ï¼Œ$\\mathscr F$ ä¸ºå¯æµ‹äº‹ä»¶é›†ï¼Œ$P$ ä¸ºæ¦‚ç‡æµ‹åº¦ã€‚\nSample Space $\\fbox{Definition 1.1}$ éšæœºè¯•éªŒçš„æ‰€æœ‰å¯èƒ½ç»“æœçš„é›†åˆç§°ä¸ºæ ·æœ¬ç©ºé—´ (sample space)ï¼Œè®°ä½œ $\\Omega$ã€‚æ¯ä¸ªéšæœºè¯•éªŒçš„å¯èƒ½ç»“æœç§°ä¸ºæ ·æœ¬ç‚¹/åŸºæœ¬äº‹ä»¶ (sample point)ï¼Œè®°ä½œ $e$ æˆ– $\\omega$ï¼Œ$e\\in \\Omega$ã€‚\nMeasurable Event Set $\\fbox{Definition 1.2.1}$ ç§° $\\mathscr{F}\\subseteq Pot(\\Omega)$ æ˜¯é›†åˆ $\\Omega$ ä¸Šçš„ä¸€ä¸ª $\\sigma$-åŸŸ ($\\sigma$-field)ï¼Œå½“ä¸”ä»…å½“\n$\\Omega \\in \\mathscr{F}$ï¼› è‹¥ $A\\in \\mathscr F$ï¼Œåˆ™ $A^C\\in \\mathscr F$ï¼› è‹¥ $A_1,\\cdots A_n\\cdots \\in \\mathscr F$ï¼Œåˆ™ $\\bigcup_{i=1}^\\infty A_i\\in \\mathscr F$ (å³å¯æ•°ä¸ªé›†åˆçš„å¹¶ä¹Ÿæ˜¯ $\\mathscr F$ çš„å…ƒç´ )ã€‚ $\\fbox{Definition 1.2.2}$ å¯æµ‹äº‹ä»¶é›† $\\mathscr F$ æ˜¯ $\\Omega$ ä¸Šçš„ä¸€ä¸ª $\\sigma$-åŸŸï¼Œè‹¥ $A\\subseteq \\Omega$ï¼Œ$A\\in \\mathscr F$ï¼Œåˆ™ç§° $A$ æ˜¯ä¸€ä¸ªäº‹ä»¶ (event)ã€‚\nProbability Metric $\\fbox{Definition 1.3}$ é›†åˆå‡½æ•° $P:\\mathscr F\\rightarrow [0,1]$ æ˜¯ $(\\Omega, \\mathscr F)$ ä¸Šçš„ä¸€ä¸ªæ¦‚ç‡æµ‹åº¦ (probability metric)ï¼Œå½“ä¸”ä»…å½“\n$P(\\Omega)=1$ï¼› å¯¹äºä»»æ„ $A\\in \\mathscr F$ï¼Œ$P(A)\\geq 0$ï¼› æ»¡è¶³å¯åˆ—å¯åŠ æ€§ï¼šå¯¹äºäº’ä¸ç›¸å®¹çš„äº‹ä»¶ $A_1,\\cdots,A_n\\cdots\\in \\mathscr F$ï¼Œ$P(\\bigcup_{n=1}^\\infty A_n)=\\sum_{n=1}^\\infty P(A_n)$ã€‚ ä»¥ä¸‹æ˜¯ä¸€ç³»åˆ—æœ‰ç”¨çš„æ¨è®ºï¼š\n$P(\\emptyset)=0$ã€‚\nProof: å– $A_1=\\Omega, A_2=A_3=\\cdots =\\emptyset$ï¼Œé‚£ä¹ˆ $$ P(\\Omega)=P(\\bigcup_{n=1}^\\infty A_n)=\\sum_{n=1}^\\infty P(A_n)=P(\\Omega)+\\sum_{n=2}^\\infty P(\\emptyset) $$ æ‰€ä»¥ $P(\\emptyset)=0$ã€‚$\\blacksquare$\nå¯åˆ—å¯åŠ æ€§å¯ä»¥æ¨å‡ºæœ‰é™å¯åŠ æ€§ï¼Œå³å¯¹äº $n\\in \\mathbb{N}$ ï¼Œ $P(\\bigcup_{k=1}^nA_k)=\\sum_{k=1}^nP(A_k)$ã€‚\nProof: å– $A_{n+1}=A_{n+2}=\\cdots =\\emptyset$ï¼Œåˆ™æœ‰ $$ \\begin{align} P(\\bigcup_{k=1}^nA_k)\u0026amp;=P(\\bigcup_{k=1}^\\infty A_k)=\\sum_{k=1}^\\infty P(A_k)\\\\ \u0026amp;=\\sum_{k=1}^nP(A_k)+\\sum_{k=n+1}^\\infty P(\\emptyset)=\\sum_{k=1}^nP(A_k) \\end{align} $$ æœ‰é™å¯åŠ æ€§å¾—è¯ã€‚$\\blacksquare$\n$P(A-B)=P(A)-P(A\\cap B)$ã€‚\nProof: ç”± $A=(A-B)\\cup (A\\cap B)$ å’Œç»“è®º 2 æ˜“å¾—ã€‚$\\blacksquare$\n$P(A\\cup B)=P(A)+P(B)-P(A\\cap B)$ã€‚æ›´ä¸€èˆ¬åœ°ï¼Œ $$ P(\\bigcup_{k=1}^nA_k)=\\sum_{i=1}^n\\left((-1)^{i+1}\\sum_{1\\leq j_1\u0026lt;j_2\u0026lt;\\cdots\u0026lt;j_i\\leq n}P(\\bigcap_{k=1}^iA_{j_i})\\right) $$ (å®¹æ–¥åŸç†çš„è¡¨è¾¾å¼)ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"5356e3eb94eab1acb963fdda80d2d534","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-probability/lec01/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-probability/lec01/","section":"notes","summary":"æˆ‘ä»¬å¯ä»¥é€šè¿‡éšæœºè¯•éªŒæ¥ç ”ç©¶éšæœºç°è±¡ã€‚éšæœºè¯•éªŒåº”å½“å…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š\nç›¸åŒæ¡ä»¶ä¸‹å¯é‡å¤ï¼› è¯•éªŒç»“æœä¸å”¯ä¸€ï¼Œè¯•éªŒå‰æœªçŸ¥ï¼Œä½†æ‰€æœ‰å¯èƒ½çš„ç»“æœå·²çŸ¥ï¼› æ¦‚ç‡ç©ºé—´æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(\\Omega, \\mathscr F, P)$ï¼Œå…¶ä¸­ $\\Omega$ ä¸ºæ ·æœ¬ç©ºé—´ï¼Œ$\\mathscr F$ ä¸ºå¯æµ‹äº‹ä»¶é›†ï¼Œ$P$ ä¸ºæ¦‚ç‡æµ‹åº¦ã€‚\nSample Space $\\fbox{Definition 1.1}$ éšæœºè¯•éªŒçš„æ‰€æœ‰å¯èƒ½ç»“æœçš„é›†åˆç§°ä¸ºæ ·æœ¬ç©ºé—´ (sample space)ï¼Œè®°ä½œ $\\Omega$ã€‚æ¯ä¸ªéšæœºè¯•éªŒçš„å¯èƒ½ç»“æœç§°ä¸ºæ ·æœ¬ç‚¹/åŸºæœ¬äº‹ä»¶ (sample point)ï¼Œè®°ä½œ $e$ æˆ– $\\omega$ï¼Œ$e\\in \\Omega$ã€‚\nMeasurable Event Set $\\fbox{Definition 1.","tags":null,"title":"Lecture 01: Probability Space","type":"docs"},{"authors":null,"categories":null,"content":"Classical Probability å¤å…¸æ¦‚å‹çš„ç‰¹ç‚¹ï¼š\n$\\Omega={e_1,e_2,\\cdots,e_n},n\\in \\mathbb{N}$ã€‚ å¯¹äºä»»æ„ $1\\leq i\\leq n$ï¼Œ$P({e_i})=\\frac{1}{n}$ (å³æ¯ä¸ªæ ·æœ¬ç‚¹ç­‰å¯èƒ½)ã€‚ åœ¨æ­¤åŸºç¡€ä¸Šï¼Œè‹¥ $A={e_{i_1},\\cdots e_{i_k}}$ ï¼Œåˆ™ $P(A)=\\frac{k}{n}$ã€‚\nPermutations and Combinations $n$ ä¸ªå¯åˆ†è¾¨çš„çƒé€‰ $r$ ä¸ªï¼Œå¯é‡å¤é€‰ï¼Œæ’åˆ—ï¼š$n^r$ã€‚\n$n$ ä¸ªå¯åˆ†è¾¨çš„çƒé€‰ $r$ ä¸ªï¼Œä¸å¯é‡å¤é€‰ï¼Œæ’åˆ—ï¼š$n^{\\underline r}=\\frac{n!}{(n-r)!}$ã€‚\n$n$ ä¸ªå¯åˆ†è¾¨çš„çƒé€‰ $r$ ä¸ªï¼Œä¸å¯é‡å¤é€‰ï¼Œç»„åˆï¼š$\\binom{n}{r}$ã€‚\n$n$ ä¸ªå¯åˆ†è¾¨çš„çƒé€‰ $r$ ä¸ªï¼Œå¯é‡å¤é€‰ï¼Œç»„åˆï¼š$\\binom{n+r-1}{r}$ã€‚\nè€ƒè™‘ä¸€ä¸ªé€‰æ‹©æ–¹æ¡ˆ $1\\leq x_1\\leq x_2\\leq \\cdots \\leq x_r\\leq n$ï¼Œç°è®¾è®¡å¦ä¸€ä¸ªæ•°åˆ— $y$ï¼Œæ»¡è¶³ $y_1=x_1,y_2=x_2+1,y_3=x_3+2,\\cdots,y_r=x_r+r-1$ã€‚é‚£ä¹ˆ $y$ ä¸¥æ ¼å•è°ƒå¢ï¼Œä¸” $1\\leq y_i\\leq n+r-1$ã€‚$x$ åºåˆ—å’Œ $y$ åºåˆ—ä¸€ä¸€å¯¹åº”ï¼Œå› æ­¤ $x$ åºåˆ—ä¸ªæ•° = $y$ åºåˆ—ä¸ªæ•° = $\\binom{n+r-1}{r}$ã€‚\nã€ä¾‹ã€‘æ±‚ $(a+b+c)^n$ åˆå¹¶åŒç±»é¡¹çš„å±•å¼€å¼ä¸­æœ‰å¤šå°‘é¡¹ã€‚\nè§£ï¼šç›¸å½“äºæ±‚å½¢å¦‚ $a^{n_1}b^{n_2}c^{n_3},n_1+n_2+n_3=n$ çš„ä¸ªæ•°ã€‚å¯ä»¥å°†å…¶ç†è§£ä¸ºä» $3$ ä¸ªç‰©å“ä¸­é€‰ $n$ ä¸ªï¼Œå¯é‡å¤é€‰çš„ç»„åˆæ–¹æ¡ˆæ•°ï¼Œå› æ­¤ç­”æ¡ˆä¸º $\\binom{n+2}{n}=\\frac{1}{2}(n+1)(n+2)$ã€‚\næœ‰å…³ç»„åˆæ•°çš„ä¸€äº›æ€§è´¨ï¼š\n$(1+x)^n=\\sum_{k=0}^n\\binom{n}{k}x^k$ï¼Œä»¤ $x=1$ ï¼Œå¯å¾— $\\sum_{k=0}^n\\binom{n}{k}=2^n$ã€‚ $(1+x)^{a+b}=(1+x)^a(1+x)^b$ï¼Œå› æ­¤ $\\binom{a+b}{n}=\\sum_{k=0}^a\\binom{a}{k}\\binom{b}{n-k}$ã€‚è‹¥å– $a=b=n$ï¼Œåˆ™å¯ä»¥å¾—åˆ° $\\binom{2n}{n}=\\sum_{k=0}^n\\binom{n}{k}\\binom{n}{n-k}=\\sum_{k=0}^n\\binom{n}{k}^2$ã€‚ Geometrical Probability $\\fbox{Definition 2.1}$ (å‡ ä½•æ¦‚å‹) è‹¥ $\\Omega$ ä¸­çš„æ ·æœ¬ç‚¹ä¸ä¸€ä¸ªæœ‰ç•ŒåŒºåŸŸ $S$ ä¸­çš„ç‚¹ä¸€ä¸€å¯¹åº”ï¼Œåˆ™äº‹ä»¶ $A$ å¯¹åº”äº $S$ çš„ä¸€ä¸ªå­é›† $D$ã€‚è‹¥ $A$ çš„æ¦‚ç‡åªå’Œ $D$ çš„æµ‹åº¦æœ‰å…³ï¼Œè€Œä¸ $D$ çš„å½¢çŠ¶ï¼Œä½ç½®æ— å…³ï¼Œé‚£ä¹ˆ $P(A)=\\frac{Dçš„æµ‹åº¦}{S çš„æµ‹åº¦}$ã€‚\nã€ä¾‹ã€‘ç”²ä¹™ä¸¤äººå„åœ¨ 1h å†…éšæœºä¸€ä¸ªæ—¶é—´ç‚¹åˆ°è¾¾çº¦ä¼šåœ°ç‚¹ï¼Œå…ˆåˆ°çš„äººæœ€å¤šç­‰ååˆ°çš„äºº 15 åˆ†é’Ÿï¼Œæ±‚ä¸¤äººç¢°é¢çš„æ¦‚ç‡ã€‚\nè§£ï¼šç”¨æ•°å¯¹ $(x,y)$ è¡¨ç¤ºç”²ä¹™ä¸¤äººåˆ°è¾¾çš„æ—¶é—´ï¼Œåˆ™ä¸¤äººå¯ä»¥ç¢°é¢å½“ä¸”å³å½“ $|x-y|\\leq 15$ï¼Œç”»å›¾ï¼š\nå› æ­¤ç¢°é¢æ¦‚ç‡ä¸º $\\frac{60^2-45^2}{60^2}=\\frac{7}{16}$ã€‚\nã€ä¾‹ã€‘ (è’²ä¸°æŠ•é’ˆ) ä¸¤å¹³è¡Œçº¿é—´è· $a$ï¼Œå‘å…¶æŠ•æ·é•¿åº¦ä¸º $l$ $(l\u0026lt;a)$ çš„é’ˆï¼Œä½¿é’ˆçš„ä¸­ç‚¹åœ¨ä¸¤å¹³è¡Œçº¿ä¹‹é—´ï¼Œæ±‚é’ˆä¸ä¸¤æ¡å¹³è¡Œçº¿ä¸­ä»»æ„ä¸€æ¡ç›¸äº¤çš„æ¦‚ç‡ã€‚\nè§£ï¼š $l\u0026lt;a$ ä¿è¯äº†é’ˆè‡³å¤šåªä¼šå’Œä¸€æ¡çº¿ç›¸äº¤ï¼Œæ ¹æ®å¯¹ç§°æ€§ï¼Œæˆ‘ä»¬åªè€ƒè™‘é’ˆä¸ä¸‹é¢çš„çº¿ç›¸äº¤çš„æƒ…å†µã€‚\nè®¾é’ˆçš„ä¸­ç‚¹ä¸çº¿çš„è·ç¦»ä¸º $x$ï¼Œé’ˆæ‰€åœ¨çš„ç›´çº¿ä¸çº¿çš„å¤¹è§’ä¸º $\\theta$ï¼Œåˆ™é’ˆä¸çº¿ç›¸äº¤å½“ä¸”ä»…å½“ $x\\leq \\frac{l}{2}\\sin\\theta$ã€‚æˆ‘ä»¬ä»¥ $x$ å’Œ $\\theta$ ä¸ºåæ ‡è½´ç”»å‡ºæ ·æœ¬ç©ºé—´å’Œç›¸äº¤äº‹ä»¶ï¼š $$ \\begin{align} \\Omega \u0026amp;= {(\\theta,x)|0\u0026lt;\\theta\u0026lt;\\pi,0\\leq x\\leq \\frac{a}{2}}\\\\ A \u0026amp;= {(\\theta,x)|0\\leq \\theta \\leq \\pi, 0\\leq x \\leq \\frac{l}{2}\\sin \\theta} \\end{align} $$ $A$ çš„å›¾åƒæ˜¯ä¸€ä¸ªæ­£å¼¦å‡½æ•°ï¼Œè¦è®¡ç®—é¢ç§¯ï¼Œåªéœ€è¦è®¡ç®—ç§¯åˆ†ï¼š $$ P(A)=\\frac{1}{\\pi\\cdot \\frac{a}{2}}\\int_{0}^\\pi\\frac{l}{2}\\sin \\theta d\\theta=\\left.-\\frac{l}{2}\\cos\\theta\\right|_{0}^\\pi=\\frac{2l}{a\\pi} $$ è¿™ä¸ªæ–¹æ³•å¯ä»¥ç”¨äºä¼°ç®— $\\pi$ çš„å€¼ã€‚é€šè¿‡å¤§é‡é‡å¤è¯•éªŒç”¨ $f_N(A)$ æ¥ä»£æ›¿ $P(A)$ åï¼Œ$\\pi=\\frac{2l}{aP(A)}$ã€‚\nã€ä¾‹ã€‘ (è´ç‰¹æœ—å¥‡è®º) åœ¨ä¸€ä¸ªåŠå¾„ä¸º 1 çš„åœ†ä¸­ç­‰æ¦‚ç‡åœ°å–ä¸€æ ¹å¼¦ï¼Œå¼¦é•¿ $l\u0026gt;\\sqrt 3$ çš„æ¦‚ç‡æ˜¯å¤šå°‘ï¼Ÿ\nç”±äºè¿™é‡Œçš„â€œç­‰æ¦‚ç‡â€æ²¡æœ‰è¢«ä¸¥æ ¼åœ°å®šä¹‰ï¼Œå› æ­¤å¯èƒ½æœ‰å¤šç§å¯¹ç­‰æ¦‚ç‡çš„è§£è¯»ï¼Œå®ƒä»¬éƒ½æ˜¯å¯¹çš„ä¸”ä¼šç®—å‡ºä¸åŒçš„ç»“æœï¼š\nåœ¨åœ†å‘¨ä¸Šå›ºå®šä¸€ä¸ªç‚¹ï¼Œç„¶åå¦ä¸€ä¸ªç‚¹åœ¨åœ†å‘¨ä¸Šéšæœºé€‰å–ï¼š$P(A)=\\frac{1}{3}$ã€‚ è®©ä¸€æ¡ç›´çº¿ä»ä¸Šå¾€ä¸‹å‡åŒ€åœ°æ‰«ä¸€éï¼Œå‘ç°åªæœ‰ä¸­ç‚¹è·ç¦»åœ†å¿ƒå°äº $\\frac{1}{2}$ æ—¶å¼¦é•¿æ»¡è¶³è¦æ±‚ï¼š$P(A)=\\frac{1}{2}$ã€‚ åœ¨åœ†å†…éšæœºé€‰å–å¼¦çš„ä¸­ç‚¹ï¼Œå‘ç°åªæœ‰ä¸­ç‚¹ä½äºåŠå¾„ä¸º $\\frac{1}{2}$ çš„å°åœ†å†…æ˜¯å¼¦é•¿æ»¡è¶³è¦æ±‚ï¼š$P(A)=\\frac{1}{4}$ã€‚ â€¦â€¦ ","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"f29440c01199a69d27c54f764694fca1","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-probability/lec02/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-probability/lec02/","section":"notes","summary":"Classical Probability å¤å…¸æ¦‚å‹çš„ç‰¹ç‚¹ï¼š\n$\\Omega={e_1,e_2,\\cdots,e_n},n\\in \\mathbb{N}$ã€‚ å¯¹äºä»»æ„ $1\\leq i\\leq n$ï¼Œ$P({e_i})=\\frac{1}{n}$ (å³æ¯ä¸ªæ ·æœ¬ç‚¹ç­‰å¯èƒ½)ã€‚ åœ¨æ­¤åŸºç¡€ä¸Šï¼Œè‹¥ $A={e_{i_1},\\cdots e_{i_k}}$ ï¼Œåˆ™ $P(A)=\\frac{k}{n}$ã€‚\nPermutations and Combinations $n$ ä¸ªå¯åˆ†è¾¨çš„çƒé€‰ $r$ ä¸ªï¼Œå¯é‡å¤é€‰ï¼Œæ’åˆ—ï¼š$n^r$ã€‚\n$n$ ä¸ªå¯åˆ†è¾¨çš„çƒé€‰ $r$ ä¸ªï¼Œä¸å¯é‡å¤é€‰ï¼Œæ’åˆ—ï¼š$n^{\\underline r}=\\frac{n!}{(n-r)!}$ã€‚\n$n$ ä¸ªå¯åˆ†è¾¨çš„çƒé€‰ $r$ ä¸ªï¼Œä¸å¯é‡å¤é€‰ï¼Œç»„åˆï¼š$\\binom{n}{r}$ã€‚","tags":null,"title":"Lecture 02: Classical Probability and Geometric Probability","type":"docs"},{"authors":null,"categories":null,"content":"Conditional Probability â€œäº‹ä»¶ $A$ å’Œ $B$ åŒæ—¶å‘ç”Ÿçš„æ¦‚ç‡â€ä¸â€œ $B$ å‘ç”Ÿçš„æ¡ä»¶ä¸‹ï¼Œ$A$ å‘ç”Ÿçš„æ¦‚ç‡â€ä¸ä¸€å®šç›¸ç­‰ï¼\nâ€œäº‹ä»¶ $A$ å’Œ $B$ åŒæ—¶å‘ç”Ÿâ€ æ˜¯åœ¨ $\\Omega$ ä¸­ å¯»æ‰¾ $A\\cap B$ï¼Œ$P(A\\cap B)=\\frac{|A\\cap B|}{|\\Omega|}$ã€‚ â€œ $B$ å‘ç”Ÿçš„æ¡ä»¶ä¸‹ï¼Œ$A$ å‘ç”Ÿâ€ï¼Œæ ·æœ¬ç©ºé—´é€€åŒ–ä¸º $B$ï¼Œ$P(A|B)=\\frac{|A\\cap B|}{|B|}$ã€‚ $\\fbox{Definition 3.1}$ è®¾äº‹ä»¶ $A,B$ æ»¡è¶³ $P(B)\u0026gt;0$ï¼Œåˆ™ç§° $P(A|B)=\\frac{P(AB)}{P(B)}$ ä¸ºåœ¨äº‹ä»¶ $B$ å‘ç”Ÿçš„æ¡ä»¶ä¸‹äº‹ä»¶ $A$ å‘ç”Ÿçš„æ¦‚ç‡ã€‚\næ³¨ï¼šè‹¥å°† $B$ è§†ä¸ºä¸€ä¸ªæ ·æœ¬ç©ºé—´ $\\Omega_B$ï¼Œåˆ™å¯å®šä¹‰æ¦‚ç‡ç©ºé—´ $(\\Omega_B,\\mathscr{F}_B,P_B)$ï¼Œå…¶ä¸­ $\\mathscr{F}_B={A\\cap B| A\\in \\mathscr{F}}$ï¼Œ$P_B(A)=P(A|B)$ã€‚æ­¤æ—¶è‹¥ç›´æ¥å– $P$ ä¸º $\\Omega_B$ çš„æ¦‚ç‡æµ‹åº¦ï¼Œå³ä»¤ $P_B=P$ï¼Œåˆ™ $P_B(B)\u0026lt;1$ï¼Œè¿åäº†æ¦‚ç‡ç©ºé—´çš„å®šä¹‰ (å‡ºç°äº†æŸç§æ¦‚ç‡æŸå¤±)ï¼Œæ‰€ä»¥åº”è¯¥å¯¹å…¶é™¤æ‰ $P(B)$ è¿›è¡Œä¸€ä¸ªå½’ä¸€åŒ–ï¼š$P_B(A)=\\frac{P(AB)}{P(B)}$ã€‚\näº‹å®ä¸Šï¼Œ $P_B$ ä¹Ÿæ˜¯ $(\\Omega,\\mathscr{F})$ ä¸Šçš„ä¸€ä¸ªæ¦‚ç‡\n$P_B(A)\\geq 0$ï¼Œ$P_B(\\Omega)=1$ï¼› æ»¡è¶³å¯åˆ—å¯åŠ æ€§ã€‚ å› æ­¤ï¼Œä¹‹å‰æ¨å¯¼çš„å…³äºäº¤ã€å¹¶çš„æ¦‚ç‡å…¬å¼åœ¨æ¡ä»¶æ¦‚ç‡ä¸Šä»ç„¶é€‚ç”¨ã€‚$P_B$ çš„ç‰¹ç‚¹æ˜¯å°†æ‰€æœ‰å‘ç”Ÿçš„äº‹ä»¶èšç„¦åœ¨ $B$ ä»¥å†…ï¼Œå³å¯¹äºä»»æ„ $A\\cap B=\\emptyset$ï¼Œ$P_B(A)=0$ã€‚\nä¹˜æ³•å…¬å¼ï¼šå½“ $P(A_{n-1}\\cdots A_1)\u0026gt;0$ æ—¶ï¼Œ $$ P(A_nA_{n-1}\\cdots A_1)=P(A_n|A_{n-1}A_{n-2}\\cdots A_1)P(A_{n-1}|A_{n-2}\\cdots A_1)\\cdots P(A_2|A_1)P(A_1) $$ æ³¨ï¼šå¯¹äºä»»æ„ $1\\leq m\\leq n-1$ï¼Œ$\\bigcap_{i=1}^{n-1}A_i\\subseteq \\bigcap_{i=1}^mA_i$ï¼Œå› æ­¤ $P(\\bigcap_{i=1}^{n-1}A_i)\u0026gt;0$ çš„æ¡ä»¶å·²ç»ä¸ºä¹‹åæ‰€æœ‰çš„æ¡ä»¶æ¦‚ç‡åšå¥½äº†å‡è®¾ã€‚\nã€ä¾‹ã€‘$n$ ä¸ªäººæŠ½ç­¾ï¼Œæ±‚æ”¾å›/ä¸æ”¾å›çš„æƒ…å†µä¸‹ï¼Œç¬¬ $k$ ä¸ªäººæŠ½ä¸­çš„æ¦‚ç‡ã€‚\nè§£ï¼šä»¤ $A_k$ è¡¨ç¤ºäº‹ä»¶â€œç¬¬ $k$ ä¸ªäººæŠ½ä¸­â€œï¼Œåˆ™è¦æ±‚ $P(A_k\\overline{A_{k-1}}\\cdots\\overline{A_1})$ï¼Œæ ¹æ®ä¹˜æ³•å…¬å¼ï¼Œ$P(A_k\\overline{A_{k-1}}\\cdots\\overline{A_1})=P(A_k|\\overline{A_{k-1}}\\cdots\\overline{A_1})P(\\overline{A_{k-1}}|\\overline{A_{k-2}}\\cdots \\overline{A_1})\\cdots P(\\overline{A_2}|\\overline{A_1})P(\\overline{A_1})$ã€‚\n(a) å½“ $k=1$ æ—¶ï¼Œ$P(A_k)=\\frac{1}{n}$ï¼Œå½“ $k\\geq 2$ æ—¶ï¼Œ$P(\\overline{A_1})=\\frac{n-1}{n}$ï¼Œå¯¹äºä»»æ„ $2\\leq m\\leq k-1$ï¼Œ$P(\\overline{A_m}|\\overline{A_{m-1}}\\cdots\\overline{A_1})=\\frac{n-m}{n-m+1}$ï¼Œ$P(A_k|\\overline{A_{k-1}}\\cdots\\overline{A_1})=\\frac{1}{n-k+1}$ï¼Œæ‰€ä»¥ $P=(\\prod_{m=1}^{k-1}\\frac{n-m}{n-m+1})\\frac{1}{n-k+1}=\\frac{1}{n}$\n(b) å½“ $k=1$ æ—¶ï¼Œ$P(A_k)=\\frac{1}{n}$ï¼Œå½“ $k\\geq 2$ æ—¶ï¼Œ$P(\\overline{A_1})=\\frac{n-1}{n}$ï¼Œå¯¹äºä»»æ„ $2\\leq m\\leq k-1$ï¼Œ$P(\\overline{A_m}|\\overline{A_{m-1}}\\cdots\\overline{A_1})=\\frac{n-1}{n}$ï¼Œ$P(A_k|\\overline{A_{k-1}}\\cdots\\overline{A_1})=\\frac{1}{n}$ï¼Œæ‰€ä»¥ $P=\\left(\\frac{n-1}{n}\\right)^{k-1}\\frac{1}{n}$ã€‚\nTotal Probability Formula $\\fbox{Definition 3.2}$ è‹¥äº‹ä»¶ $A_1,A_2,\\cdots,A_n$ æ»¡è¶³\nå¯¹äºä»»æ„ $1\\leq i\u0026lt;j\\leq n$ï¼Œ$A_i\\cap A_j=\\emptyset$ï¼› $\\bigcup_{i=1}^nA_i=\\Omega$ã€‚ åˆ™ç§° $A_1,\\cdots,A_n$ ä¸º $\\Omega$ çš„ä¸€ä¸ªåˆ’åˆ†/å®Œå¤‡äº‹ä»¶é›†ã€‚\n$\\fbox{Theorem 3.3}$ (å…¨æ¦‚ç‡å…¬å¼) è®¾ $A_1,\\cdots,A_n$ ä¸º $\\Omega$ çš„ä¸€ä¸ªåˆ’åˆ†ï¼Œåˆ™ $$ P(B)=\\sum_{i=1}^nP(BA_i)=\\sum_{i=1}^nP(A_i)P(B|A_i)\\upharpoonleft {P(A_i)\u0026gt;0} $$ å…¶ä¸­æœ€åçš„éƒ¨åˆ†æ˜¯ç¤ºæ€§å‡½æ•° (indicator function)ï¼Œè¡¨ç¤ºç•¥è¿‡ $P(A_i)=0$ çš„é‚£äº›éƒ¨åˆ†çš„æ¡ä»¶æ¦‚ç‡ã€‚\nProofï¼šé¦–å…ˆæœ‰ $B=B\\Omega=B(\\bigcup_{i=1}^nA_i)=\\bigcup_{i=1}^n(BA_i)$ï¼Œä¸” $BA_i$ å½¼æ­¤äº’ä¸ç›¸å®¹ï¼Œæ‰€ä»¥ $$ P(B)=P\\left(\\bigcup_{i=1}^n(BA_i)\\right)\\overset{å¯åˆ—å¯åŠ æ€§}{=}\\sum_{i=1}^nP(BA_i) \\qquad\\qquad\\qquad \\blacksquare $$\næ³¨ï¼šå…¨æ¦‚ç‡å…¬å¼å¯¹äºæ— é™å¯åˆ—çš„åˆ’åˆ†ä»ç„¶æˆç«‹ã€‚\nå¯¹äºå…¨æ¦‚ç‡å…¬å¼çš„ä¸€ä¸ªæ„Ÿæ€§ç†è§£æ˜¯ï¼šå¦‚æœè¦è®¡ç®—äº‹ä»¶Açš„æ¦‚ç‡ï¼Œæˆ‘ä»¬å¯ä»¥â€œåˆ†ç±»è®¨è®ºâ€Aåœ¨å„ç§æƒ…å†µä¸‹å‘ç”Ÿçš„æ¦‚ç‡ï¼Œå†å…¨éƒ¨åŠ èµ·æ¥ã€‚\nå¯¹äºä¸€ä¸ªæ¡ä»¶æ¦‚ç‡ $P(B|C)$ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘ä¸€ä¸ªåˆ’åˆ† $A_1,\\cdots,A_n$ å¹¶å°†å…¶å†™ä¸º $P(B|C)=\\sum_{i=1}^nP(BA_i|C)$ã€‚è‹¥è¿™ä»ä¸å¥½ç®—ï¼Œä»ç„¶å¯ä»¥æœ‰ä»¥ä¸‹å˜å½¢ï¼š $$ \\sum_{i=1}^nP(BA_i|C)=\\sum_{i=1}^n\\frac{P(BA_iC)}{P(C)}=\\sum_{i=1}^n\\frac{P(A_iC)}{P(C)}P(B|A_iC)\\upharpoonleft {P(A_iC)\u0026gt;0} $$ æˆ‘ä»¬å°†æ¡ä»¶ $C$ åŠ å¼ºåˆ°äº†æ¡ä»¶ $A_iC$ï¼Œä»è€Œå¯èƒ½æ›´å®¹æ˜“è®¡ç®—ã€‚\nã€ä¾‹ã€‘æœ‰ä¸¤æ‰¹ç¯æ³¡å„10æ”¯ï¼Œç¬¬ä¸€æ‰¹æœ‰ä¸€ä¸ªæ¬¡å“ï¼Œç¬¬äºŒæ‰¹æœ‰ä¸¤ä¸ªæ¬¡å“ã€‚è¿è¾“è¿‡ç¨‹ä¸­ä¸¤æ‰¹å„æ‰“ç¢äº†ä¸€ä¸ªã€‚ç°ä»å‰©ä½™ç¯æ³¡ä¸­æŠ½å–ä¸€ä¸ªï¼ŒæŠ½åˆ°æ¬¡å“çš„æ¦‚ç‡æ˜¯å¤šå°‘ï¼Ÿ\nè§£ï¼šè®¨è®ºæ‰“ç¢çš„ä¸¤ä¸ªç¯æ³¡çš„æƒ…å†µï¼š$B_1=(å¥½,å¥½),B_2=(å¥½,æ¬¡),B_3=(æ¬¡,å¥½),B_4=(æ¬¡,æ¬¡)$ã€‚è®° $A$ ä¸ºæŠ½åˆ°æ¬¡å“è¿™ä¸ªäº‹ä»¶ $$ \\begin{align} P(A)\u0026amp;=P(B_1)P(A|B_1)+P(B_2)P(A|B_2)+P(B_3)P(A|B_3)+P(B_4)P(A|B_4)\\\\ \u0026amp;=\\frac{9}{10}\\cdot \\frac{8}{10}\\cdot \\frac{3}{18}+\\frac{9}{10}\\cdot \\frac{2}{10}\\cdot \\frac{2}{18}+\\frac{1}{10}\\cdot \\frac{8}{10}\\cdot \\frac{2}{18}+\\frac{1}{10}\\cdot \\frac{2}{10}\\cdot \\frac{1}{18}\\\\ \u0026amp;=\\frac{3}{20} \\end{align} $$\nBayes Formula åœ¨å…¨æ¦‚ç‡å…¬å¼ $P(B)=\\sum_{i=1}^nP(A_i)P(B|A_i)$ ä¸­ï¼Œ$B$ å¯ä»¥çœ‹ä½œå‘ç”Ÿçš„ç»“æœï¼Œ$A_i$ å¯ä»¥çœ‹ä½œ $B$ å‘ç”Ÿçš„å¯èƒ½åŸå› ã€‚$P(A_i)$ è¢«ç§°ä¸ºå…ˆéªŒæ¦‚ç‡ï¼Œ$P(A_i|B)$ è¡¡é‡äº† $B$ å·²ç»å‘ç”Ÿçš„æƒ…å†µä¸‹åŸå› å‘ç”Ÿçš„å¯èƒ½æ€§ï¼Œç§°ä¸ºåéªŒæ¦‚ç‡ã€‚\n$\\fbox{Theorem 3.4}$ (è´å¶æ–¯å…¬å¼) è®¾ $A_1,\\cdots,A_n$ ä¸º $\\Omega$ çš„ä¸€ä¸ªåˆ’åˆ†ï¼Œå¯¹äºä»»æ„ $1\\leq k\\leq n$ï¼Œ$P(A_k)\u0026gt;0$ã€‚åˆ™å¯¹äº $B\\in \\mathscr F$ï¼Œæˆ‘ä»¬æœ‰ $$ P(A_k|B)=\\frac{P(A_kB)}{P(\\Omega B)}=\\frac{P(A_k)P(B|A_k)}{\\sum_{i=1}^nP(A_i)P(B|A_i)} $$ ã€ä¾‹ã€‘æœ‰ä¸€ç§ç½•è§ç—…ï¼Œç”¨æŸæ–¹æ³•æ¥æ£€æµ‹æ—¶ï¼Œå¦‚æœè¯¥äººæ‚£ç—…ï¼Œé‚£ä¹ˆä»–è¢«æ£€æµ‹å‡ºæœ‰ç—…çš„æ¦‚ç‡æ˜¯ 0.95ï¼Œå¦‚æœä¸€ä¸ªäººæ²¡æœ‰æ‚£ç—…ï¼Œé‚£ä¹ˆä»–è¢«æ£€æµ‹å‡ºæ²¡ç—…çš„æ¦‚ç‡æ˜¯ 0.9ï¼Œæ­£å¸¸äººä¸­ç½•è§ç—…å‘ç—…ç‡ä¸º 0.0004ã€‚ç°æœ‰ä¸€ä¸ªäººæ£€æµ‹å‡ºæœ‰ç—…ï¼Œä»–çœŸæ­£æœ‰ç—…çš„æ¦‚ç‡æ˜¯å¤šå°‘ï¼Ÿ\nè§£ï¼šä»¤ $C={æŸäººæ‚£ç½•è§ç—…},A={æŸäººè¢«æ£€æµ‹å‡ºç½•è§ç—…}$ï¼Œåˆ™ $$ P(C|A)=\\frac{P(C)P(A|C)}{P(C)P(A|C)+P(\\overline{C})P(A|\\overline{C})}=\\frac{0.0004\\cdot 0.95}{0.0004\\cdot 0.95+0.9996\\cdot 0.1}\\approx 0.003 $$\nè¯¥æ¦‚ç‡å®é™…ä¸Šéå¸¸å°çš„åŸå› æ˜¯ï¼šäººç¾¤ä¸­ä¸æ‚£ç—…çš„å¾ˆå¤šï¼Œè€Œä¸æ‚£ç—…æƒ…å†µä¸‹çš„è¯¯è¯Šç‡ä¸å¤Ÿå°ï¼Œè¿™å¯¼è‡´æœ‰å¾ˆå¤§æ¦‚ç‡éƒ½æ˜¯è¿™ç§æƒ…å†µå¯¼è‡´çš„æ£€æµ‹ç»“æœå¼‚å¸¸ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"862c307bfbcb3278bbb2f0145ceb66b6","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-probability/lec03/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-probability/lec03/","section":"notes","summary":"Conditional Probability â€œäº‹ä»¶ $A$ å’Œ $B$ åŒæ—¶å‘ç”Ÿçš„æ¦‚ç‡â€ä¸â€œ $B$ å‘ç”Ÿçš„æ¡ä»¶ä¸‹ï¼Œ$A$ å‘ç”Ÿçš„æ¦‚ç‡â€ä¸ä¸€å®šç›¸ç­‰ï¼\nâ€œäº‹ä»¶ $A$ å’Œ $B$ åŒæ—¶å‘ç”Ÿâ€ æ˜¯åœ¨ $\\Omega$ ä¸­ å¯»æ‰¾ $A\\cap B$ï¼Œ$P(A\\cap B)=\\frac{|A\\cap B|}{|\\Omega|}$ã€‚ â€œ $B$ å‘ç”Ÿçš„æ¡ä»¶ä¸‹ï¼Œ$A$ å‘ç”Ÿâ€ï¼Œæ ·æœ¬ç©ºé—´é€€åŒ–ä¸º $B$ï¼Œ$P(A|B)=\\frac{|A\\cap B|}{|B|}$ã€‚ $\\fbox{Definition 3.","tags":null,"title":"Lecture 03: Conditional Probability and Bayes Formula","type":"docs"},{"authors":null,"categories":null,"content":"Independence ã€ä¾‹ã€‘$a$ ä¸ªé»‘çƒï¼Œ$b$ ä¸ªç™½çƒï¼Œåˆ†åˆ«åœ¨æœ‰æ”¾å›ã€æ— æ”¾å›çš„æƒ…å†µä¸‹è®¡ç®—ï¼š\n(1) ç¬¬ä¸€æ¬¡æ‘¸åˆ°é»‘çƒ (A)ï¼Œç¬¬äºŒæ¬¡æ‘¸åˆ°é»‘çƒçš„æ¦‚ç‡ (B)ã€‚\n(2) ç¬¬äºŒæ¬¡æ‘¸åˆ°é»‘çƒçš„æ¦‚ç‡ã€‚\nå®¹æ˜“å‘ç°ï¼Œæœ‰æ”¾å›æ—¶ï¼Œ$P(B|A)=P(B)$ (æ”¾å›åï¼Œç¬¬äºŒæ¬¡çš„å®éªŒæ¡ä»¶ä¸ç¬¬ä¸€æ¬¡çš„ç»“æœæ— å…³)ï¼Œæ— æ”¾å›æ—¶ $P(B|A)\\neq P(B)$ã€‚\n$\\fbox{Definition 4.1}$ ç§°äº‹ä»¶ $A$ å’Œ $B$ äº’ç›¸ç‹¬ç«‹ï¼Œè‹¥ $P(AB)=P(A)P(B)$ (æˆ–è€…è¯´ï¼Œ$P(B)=P(B|A)$)ã€‚\nä»¥ä¸‹æ˜¯ä¸€äº›æ¨è®ºï¼š\n$\\emptyset,\\Omega$ ä¸ä»»æ„äº‹ä»¶ç‹¬ç«‹ã€‚\nè‹¥ $A,B$ ç‹¬ç«‹ï¼Œåˆ™ $\\overline{A},B$ï¼Œ$A,\\overline{B}$ ï¼Œ$\\overline{A},\\overline{B}$ ä¹Ÿç‹¬ç«‹ã€‚\nProof: ç¬¬ä¸€æ¡ï¼š$P(\\overline{A}B)=P(B-BA)=P(B)-P(BA)=P(B)-P(B)P(A)=P(B)(1-P(A))=P(B)P(\\overline{A})$\nå®¹æ˜“æ¨å¾—ç¬¬äºŒï¼Œç¬¬ä¸‰æ¡ä¹Ÿæˆç«‹ã€‚$\\blacksquare$\næ³¨ï¼šäº‹ä»¶ç‹¬ç«‹å’ŒéŸ¦æ©å›¾ä¸Šä¸¤ä¸ªäº‹ä»¶æ²¡æœ‰äº¤é›†æ²¡æœ‰ä»»ä½•å…³ç³»ï¼\n$\\fbox{Definition 4.2}$ (ä¸‰ä¸ªäº‹ä»¶çš„ç‹¬ç«‹æ€§) $A,B,C$ ç›¸äº’ç‹¬ç«‹ï¼Œè‹¥\n$A,B,C$ ä¸¤ä¸¤äº’ç›¸ç‹¬ç«‹ã€‚ $P(ABC)=P(A)P(B)P(C)$ã€‚ æ³¨ï¼šè¿™ä¸¤æ¡å¹¶ä¸èƒ½äº’ç›¸æ¨å‡ºï¼Œä»¥ä¸‹æ˜¯ä¾‹å­ï¼š\n(1) æ¨ä¸å‡º (2)ï¼šä¸€ä¸ªæ­£å››é¢ä½“ï¼Œä¸€é¢çº¢è‰² (A)ï¼Œä¸€é¢ç»¿è‰² (B)ï¼Œä¸€é¢è“è‰² (C)ï¼Œä¸€é¢ä¸‰ä¸ªé¢œè‰²éƒ½æœ‰ï¼Œè®¨è®ºå‘ä¸‹é¢çš„é¢œè‰²ï¼š $P(A)=P(B)=P(C)=2/4=1/2$ï¼Œ$P(AB)=1/4=P(A)P(B)$ã€‚ ç„¶è€Œ $P(ABC)=1/4\\neq P(A)P(B)P(C)$ã€‚ (2) æ¨ä¸å‡º (1)ï¼šä¸€ä¸ªæ­£å…«é¢ä½“ï¼Œ1,2,3,4é¢æœ‰çº¢è‰²ï¼Œ1,2,3,5é¢æœ‰ç»¿è‰²ï¼Œ1,6,7,8é¢æœ‰è“è‰²ã€‚ $P(A)=P(B)=P(C)=4/8=1/2$ï¼Œ$P(ABC)=1/8=P(A)P(B)P(C)$ã€‚ ç„¶è€Œ $P(AB)=3/8\\neq P(A)P(B)$ã€‚ ç±»ä¼¼åœ°å¯ä»¥å®šä¹‰ $n$ ä¸ªäº‹ä»¶çš„ç‹¬ç«‹æ€§ï¼šå¯¹äºäº‹ä»¶ $A_1,\\cdots,A_n$ï¼Œä»¤ $I$ ä¸ºæŒ‡æ ‡é›†ï¼Œåˆ™å®ƒä»¬ç‹¬ç«‹å½“ä¸”ä»…å½“å¯¹äºä»»æ„ $S\\subseteq I$ï¼Œæœ‰ $P(\\bigcap_{\\alpha\\in S}A_\\alpha)=\\prod_{\\alpha\\in S}P(A_\\alpha)$ã€‚\n$\\fbox{Theorem 4.3}$ è‹¥äº‹ä»¶ $A_1,\\cdots, A_n$ äº’ç›¸ç‹¬ç«‹ï¼Œé‚£ä¹ˆè€ƒè™‘äº‹ä»¶é›†çš„ä»»æ„ä¸€ä¸ªåˆ’åˆ†ï¼Œæ¯ä¸ªç»„é‡Œçš„äº‹ä»¶åšä»»æ„è¿ç®—çš„ç»“æœä¸åˆ«ç»„çš„ç»“æœä¹Ÿäº’ç›¸ç‹¬ç«‹ã€‚\n$\\fbox{Theorem 4.4}$ è‹¥ $A_1,\\cdots, A_n$ ç›¸äº’ç‹¬ç«‹ï¼Œåˆ™ $P(\\bigcup_{k=1}^nA_k)=1-\\prod_{k=1}^nP(\\overline{A_k})$ã€‚\nè¯æ˜ï¼š$P(\\bigcup_{k=1}^nA_k)=1-P(\\overline{\\bigcup_{k=1}^nA_k})=1-P(\\bigcap_{k=1}^n\\overline{A_k})=1-\\prod_{k=1}^nP(\\overline{A_k})$ã€‚$\\blacksquare$\nBernoulli Experiments $\\fbox{Definition 4.5}$ è‹¥ä¸€ä¸ªç‹¬ç«‹é‡å¤è¯•éªŒæ»¡è¶³\næ¯ä¸ªäº‹ä»¶åªæœ‰ä¸¤ä¸ªç»“æœï¼š$A$ å’Œ $\\overline{A}$ï¼Œ$P(A)=p,P(\\overline(A))=1-p$ã€‚ è¯•éªŒå¯é‡å¤ï¼Œæ¯ä¸¤æ¬¡è¯•éªŒä¹‹é—´äº’ç›¸ç‹¬ç«‹ã€‚ åˆ™ $n$ æ¬¡ä¸Šè¿°å®éªŒç§°ä¸º $n$ é‡ä¼¯åŠªåˆ©è¯•éªŒ (Bernoulli Experiment)ã€‚\n$\\fbox{Theorem 4.6}$ ä¼¯åŠªåˆ©è¯•éªŒä¸­ï¼Œè®° $P_n(k)$ ä¸º $A$ å‘ç”Ÿ $k$ æ¬¡çš„æ¦‚ç‡ï¼Œåˆ™ $P_n(k)=\\binom{n}{k}p^k(1-p)^{n-k}$ã€‚\nã€ä¾‹ã€‘ (ç®€å•éšæœºæ¸¸èµ° simple random walk) ä¸€ä¸ªç²’å­ä»0å‡ºå‘åœ¨æ•´æ•°æ•°è½´ä¸Šè¿åŠ¨ï¼Œæ¯æ¬¡å‘å³ç§»åŠ¨çš„æ¦‚ç‡ä¸º $p$ï¼Œæ±‚è·³ $n$ æ¬¡åä½äº $k$ çš„æ¦‚ç‡ã€‚\nè§£ï¼šä»¥ä¸‹åªè®¨è®º $k\\geq 0$ çš„æƒ…å†µï¼š $$ P(n,k)= \\begin{cases} 0\u0026amp;, k\u0026gt;n\\\\ 0\u0026amp;, nä¸kå¥‡å¶æ€§ä¸åŒ\\\\ \\binom{n}{(n+k)/2}p^{(n+k)/2}(1-p)^{(n-k)/2}\u0026amp;ï¼Œotherwise \\end{cases} $$\n$\\fbox{Theorem 4.7}$ (æ³Šæ¾å®šç†, Poisson) è‹¥ $np_n=\\lambda$ï¼Œåˆ™å¯¹äºå›ºå®šçš„ $k$ï¼Œ $$ \\lim_{n\\rightarrow \\infty} \\binom{n}{k}p_n^k(1-p_n)^{n-k}=\\frac{\\lambda^k}{k!}e^{-\\lambda} $$ è¯æ˜ï¼š $$ \\begin{align} \\lim_{n\\rightarrow \\infty}\\binom{n}{k}p_n^k(1-p_n)^{n-k}\u0026amp;=\\lim_{n\\rightarrow \\infty}\\frac{n(n-1)\\cdots (n-k+1)}{k!}(\\frac{\\lambda}{n})^k(1-\\frac{\\lambda}{n})^{n-k}\\\\ \u0026amp;=\\lim_{n\\rightarrow \\infty}\\frac{\\lambda^k}{k!}\\cdot 1(1-\\frac{1}{n})(1-\\frac{2}{n})\\cdots (1-\\frac{k-1}{n})(1-\\frac{\\lambda}{n})^n(1-\\frac{\\lambda}{n})^{-k}\\\\ \u0026amp;=\\lim_{n\\rightarrow \\infty}\\frac{\\lambda^k}{k!}(1-\\frac{\\lambda}{n})^n\\\\ \u0026amp;=\\frac{\\lambda^k}{k!}\\left[\\lim_{n\\rightarrow \\infty}(1+\\frac{-\\lambda}{n})^{\\frac{n}{-\\lambda}}\\right]^{-\\lambda}\\\\ \u0026amp;=\\frac{\\lambda^k}{k!}e^{-\\lambda} \\end{align} $$\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"5de02205838af2c574f2297e8ae89f81","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-probability/lec04/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-probability/lec04/","section":"notes","summary":"Independence ã€ä¾‹ã€‘$a$ ä¸ªé»‘çƒï¼Œ$b$ ä¸ªç™½çƒï¼Œåˆ†åˆ«åœ¨æœ‰æ”¾å›ã€æ— æ”¾å›çš„æƒ…å†µä¸‹è®¡ç®—ï¼š\n(1) ç¬¬ä¸€æ¬¡æ‘¸åˆ°é»‘çƒ (A)ï¼Œç¬¬äºŒæ¬¡æ‘¸åˆ°é»‘çƒçš„æ¦‚ç‡ (B)ã€‚\n(2) ç¬¬äºŒæ¬¡æ‘¸åˆ°é»‘çƒçš„æ¦‚ç‡ã€‚\nå®¹æ˜“å‘ç°ï¼Œæœ‰æ”¾å›æ—¶ï¼Œ$P(B|A)=P(B)$ (æ”¾å›åï¼Œç¬¬äºŒæ¬¡çš„å®éªŒæ¡ä»¶ä¸ç¬¬ä¸€æ¬¡çš„ç»“æœæ— å…³)ï¼Œæ— æ”¾å›æ—¶ $P(B|A)\\neq P(B)$ã€‚\n$\\fbox{Definition 4.1}$ ç§°äº‹ä»¶ $A$ å’Œ $B$ äº’ç›¸ç‹¬ç«‹ï¼Œè‹¥ $P(AB)=P(A)P(B)$ (æˆ–è€…è¯´ï¼Œ$P(B)=P(B|A)$)ã€‚\nä»¥ä¸‹æ˜¯ä¸€äº›æ¨è®ºï¼š\n$\\emptyset,\\Omega$ ä¸ä»»æ„äº‹ä»¶ç‹¬ç«‹ã€‚\nè‹¥ $A,B$ ç‹¬ç«‹ï¼Œåˆ™ $\\overline{A},B$ï¼Œ$A,\\overline{B}$ ï¼Œ$\\overline{A},\\overline{B}$ ä¹Ÿç‹¬ç«‹ã€‚","tags":null,"title":"Lecture 04: Independence and Bernoulli Experiments","type":"docs"},{"authors":null,"categories":null,"content":"Definitions $\\fbox{Definition 5.1}$ è®¾ $X:\\Omega \\rightarrow \\mathbb{R}$ï¼Œä¸”å¯¹äºä»»æ„ $\\mathbb{R}$ ä¸­çš„ Borel é›† $B$ï¼Œ$\\{e|X(e)\\in B\\}\\in \\mathscr{F}$ï¼Œåˆ™ç§° $X$ æ˜¯ $(\\Omega, \\mathscr F, P)$ ä¸Šçš„éšæœºå˜é‡ã€‚\næ³¨ï¼š1. Borel é›†æ˜¯ç”±æ‰€æœ‰çš„ $\\{(a,b]|-\\infty\\leq a,b\\leq +\\infty\\}$ ç»è¿‡å¯æ•°æ¬¡äº¤æˆ–å¹¶å¾—åˆ°çš„é›†åˆã€‚\nâ€‹\t2. åœ¨å¤§éƒ¨åˆ†åœºåˆï¼Œåªéœ€å…³æ³¨ $X$ æ˜¯ä» $\\Omega$ åˆ° $\\mathbb{R}$ ä¸Šçš„æ˜ å°„å³å¯ã€‚\nã€ä¾‹ã€‘ç¤ºæ€§éšæœºå˜é‡ (indicator)ï¼Œå¯¹äº $A\\in \\mathscr{F}$ï¼Œå®šä¹‰ $X_A(e)=\\begin{cases}1,e\\in A\\\\0, e\\notin A\\end{cases}$ã€‚\n$\\fbox{Definition 5.2}$ è®¾ $X$ æ˜¯éšæœºå˜é‡ï¼Œåˆ™ç§° $F_X(x)\\triangleq P(X\\leq x)$ ä¸º $X$ çš„åˆ†å¸ƒå‡½æ•°ã€‚\nåˆ†å¸ƒå‡½æ•°æ»¡è¶³ä»¥ä¸‹æ€§è´¨ï¼š\nå•è°ƒä¸é™ã€‚\nå¯¹äº $x_1\u0026lt;x_2$ï¼Œ$F(x_2)-F(x_1)=P(x_1\u0026lt;x\\leq x_2)\\geq 0$ã€‚\n$\\lim_{x\\rightarrow +\\infty}F(x)=1,\\lim_{x\\rightarrow -\\infty}F(x)=0$ã€‚\nLemma (å•è°ƒæ”¶æ•›å®šç†) å½“è¢«ç§¯å‡½æ•°å•è°ƒé€’å¢æ—¶ï¼Œç§¯åˆ†å’Œæé™å¯ä»¥æ¢åºã€‚\n${X\\leq x}\\overset{x\\rightarrow +\\infty}{\\longrightarrow}\\Omega$ï¼Œ$lim_{x\\rightarrow \\infty}P(X\\leq x)\\overset{lemma}{=}P(\\lim_{x\\rightarrow \\infty}{X\\leq x})=P(\\Omega)=1$ã€‚\n$F$ å³è¿ç»­ä¸”å­˜åœ¨å·¦æé™ (cÃ dlÃ g, RCLL)ï¼Œi.e. $\\lim_{x\\rightarrow x_0^+}F(x)=F(x_0)$ï¼Œ$F(x_0-0)$ å­˜åœ¨ã€‚\n$F(x)-F(x_0)=P(X\\leq x)-P(X\\leq x_0)=P(x_0\u0026lt;X\\leq x)\\overset{x\\rightarrow x_0^+}{\\longrightarrow}P(\\emptyset)=0$ã€‚\n$x\u0026lt;x_0$ æ—¶ï¼Œ$F(x)\\leq F(x_0)$ ä¸” $F(x)$ å•å¢ï¼Œæ‰€ä»¥å·¦æé™å­˜åœ¨ã€‚\næ³¨ï¼šå·¦ä¸ä¸€å®šè¿ç»­çš„åŸå› æ˜¯ï¼š$F(x_0)-F(x)=P(x\u0026lt;X\\leq x_0)\\overset{x\\rightarrow x_0^-}{\\longrightarrow}P(X=x_0)$ ä¸ä¸€å®šä¸º 0ã€‚\n$\\fbox{Theorem 5.3}$ å¦‚æœä¸€ä¸ªå‡½æ•° $F$ æ»¡è¶³ä¸Šè¿°ä¸‰æ¡æ€§è´¨ï¼Œé‚£ä¹ˆå®ƒå¿…ç„¶æ˜¯æŸä¸ªéšæœºå˜é‡ $X$ çš„åˆ†å¸ƒå‡½æ•°ã€‚\nDiscrete Random Variable $\\fbox{Definition 5.4}$ è‹¥éšæœºå˜é‡ $X$ çš„å–å€¼ä¸ºæœ‰é™å¤šä¸ªæˆ–æ— é™å¯æ•°ä¸ªï¼Œåˆ™ $X$ ä¸ºç¦»æ•£éšæœºå˜é‡ã€‚è®¾ $X$ çš„å–å€¼ä¸º $x_1,x_2,\\cdots $ï¼Œä»¤ $P(x=x_k)=P_k$ï¼Œç§° ${P_k}$ ä¸º $X$ çš„åˆ†å¸ƒåˆ—/åˆ†å¸ƒå¾‹ã€‚\næ³¨ï¼š$F(x)=P(X\\leq x)=P(\\bigcup_{x_k\\leq x}P_k)=\\sum_{x_k\\leq x}P_k$ã€‚\nCommon Distributions ã€ä¾‹ã€‘ (0-1åˆ†å¸ƒ) è®¾ $A\\in \\mathscr{F}$ï¼Œ$P(A)=p\\in(0,1)$ã€‚ä»¤ $X_A$ ä¸º $A$ çš„ indicatorï¼Œåˆ™ $P(X_A=1)=P(A)=p,P(X_A=0)=1-p$ã€‚\nã€ä¾‹ã€‘ (äºŒé¡¹åˆ†å¸ƒ) è®¾ $X$ çš„åˆ†å¸ƒå¾‹ä¸º $p_k=P(X=k)=\\binom{n}{k}p^k(1-p)^{n-k},p\\in (0,1)$ï¼Œ$p_k$ å³ä¸º $n$ é‡ Bernoulli è¯•éªŒæˆåŠŸ $k$ æ¬¡çš„æ¦‚ç‡ï¼Œ$X$ æœä»äºŒé¡¹åˆ†å¸ƒï¼Œè®°ä¸º $X\\sim B(n,p)$ã€‚\nã€ä¾‹ã€‘ (æ³Šæ¾åˆ†å¸ƒ) è®¾ $X$ çš„åˆ†å¸ƒå¾‹ä¸º $p_k=P(X=k)=\\frac{\\lambda^k}{k!}e^{-\\lambda}$ï¼Œåˆ™ç§° $X$ æœä»æ³Šæ¾åˆ†å¸ƒï¼Œè®°ä¸º $X\\sim P(\\lambda)$ã€‚\n$$ \\sum_{k=0}^\\infty \\frac{\\lambda^k}{k!}e^{-\\lambda}=e^{-\\lambda}\\sum_{k=0}^\\infty \\frac{\\lambda^k}{k!}\\overset{Taylor\\space Series}{=}e^{-\\lambda}e^\\lambda=1 $$\næ³¨ï¼šåœ¨ $\\lambda=np_n$ å›ºå®šçš„æƒ…å†µä¸‹ï¼Œå½“ $n$ å¾ˆå¤§æ—¶ï¼Œ$p_n$ åˆ™å¾ˆå°ã€‚é‚£ä¹ˆåœ¨ $k\u0026laquo;n$ çš„æƒ…å†µä¸‹ï¼ŒäºŒé¡¹åˆ†å¸ƒå¯ä»¥è¿‘ä¼¼ä¸ºæ³Šæ¾åˆ†å¸ƒã€‚\nã€ä¾‹ã€‘ (å‡ ä½•åˆ†å¸ƒ) ç‹¬ç«‹é‡å¤è¯•éªŒï¼ŒæˆåŠŸæ¦‚ç‡ä¸º $p$ï¼Œè®°ç¬¬ $k$ æ¬¡è¯•éªŒé¦–æ¬¡æˆåŠŸçš„æ¦‚ç‡ä¸º $p_k=P(X=k)=(1-p)^{k-1}p$ï¼Œåˆ™ $X$ æœä»å‡ ä½•åˆ†å¸ƒï¼Œè®°ä¸º $X\\sim g(p)$ã€‚\n$$ \\sum_{k=1}^\\infty (1-p)^{k-1}p=p\\sum_{k=0}^\\infty(1-p)^k=p\\cdot\\frac{1}{1-(1-p)}=p\\cdot \\frac{1}{p}=1 $$\nå‡ ä½•åˆ†å¸ƒæ²¡æœ‰è®°å¿†æ€§ã€‚å‡è®¾å‰ $t$ æ¬¡è¯•éªŒå‡å¤±è´¥ï¼Œåˆ™å†è¯• $s$ æ¬¡æˆåŠŸçš„æ¦‚ç‡ $P(X=t+s|X\u0026gt;t)=P(X=s)$ã€‚æˆ–è€…ï¼š$P(X\\geq t+s|x\u0026gt;t)=\\sum_{k=s}^\\infty P(X=t+k|X\u0026gt;t)=\\sum_{k=s}^\\infty P(X=k)=P(X\\geq s)$ã€‚\nã€ä¾‹ã€‘ (å·´æ–¯å¡åˆ†å¸ƒ) ç‹¬ç«‹é‡å¤è¯•éªŒï¼Œæ¯æ¬¡æˆåŠŸæ¦‚ç‡ä¸º $p$ï¼Œè®°åšå®Œç¬¬ $k$ æ¬¡è¯•éªŒåæ°å¥½å–å¾—äº† $r$ æ¬¡æˆåŠŸ $(k\\geq r)$ çš„æ¦‚ç‡ä¸º $p_k$ï¼Œæœ‰ $$ p_k=P(X=k)=\\binom{k-1}{r-1}p^r(1-p)^{k-r} $$ æˆ‘ä»¬ç§° $X$ æœä»å·´æ–¯å¡åˆ†å¸ƒ ($r=1$ æ—¶çš„å·´æ–¯å¡åˆ†å¸ƒå°±æ˜¯å‡ ä½•åˆ†å¸ƒ)ã€‚\n$$ \\sum_{k=r}^\\infty p_k=\\sum_{k=r}^\\infty \\binom{k-1}{r-1}p^r(1-p)^{k-r}=p^r\\sum_{k=r}^\\infty \\binom{k-1}{r-1}(1-p)^{k-r} $$\nä»¤ $q=1-p$ï¼Œåªè¦è¯ $\\sum_{k=r}^\\infty \\binom{k-1}{r-1}q^{k-r}=(1-q)^{-r}$ã€‚å¯¹ $f(x)=(1-x)^{-r}$ æ³°å‹’å±•å¼€ï¼Œ $$ \\begin{align} f(x)=(1-x)^{-r}\u0026amp;=\\sum_{k=0}^\\infty \\frac{f^{(k)}(0)}{k!}x^k\\\\ \u0026amp;=\\sum_{k=0}^\\infty\\frac{1}{k!}(-1)^k(-r)(-r-1)\\cdots (-r-k+1)x^k\\\\ \u0026amp;=\\sum_{k=0}^\\infty\\frac{1}{k!}r(r+1)\\cdots (r+k-1)x^k\\\\ \u0026amp;=\\sum_{k=0}^\\infty\\frac{(r+k-1)!}{k!(r-1)!}x^k\\\\ \u0026amp;=\\sum_{k=0}^\\infty\\binom{r+k-1}{k}x^k\\\\ \u0026amp;=\\sum_{k=r}^\\infty\\binom{k-1}{r-1}x^{k-r} \\end{align} $$\nã€ä¾‹ã€‘ (è¶…å‡ ä½•åˆ†å¸ƒ) å¯¹ $N$ ä¸ªäº§å“æ— æ”¾å›æŠ½æ · $n$ æ¬¡ï¼Œå…¶ä¸­æœ‰ $M$ ä¸ªæ¬¡å“ï¼Œä»¤æŠ½åˆ° $k$ ä¸ªæ¬¡å“çš„æ¦‚ç‡ä¸º $p_k$ï¼Œåˆ™ $$ p_k=P(X=k)=\\frac{\\binom{M}{k}\\binom{N-M}{n-k}}{\\binom{N}{n}} $$ æˆ‘ä»¬ç§° $X$ æœä»è¶…å‡ ä½•åˆ†å¸ƒã€‚\n$$ \\sum_{k=0}^\\infty p_k=\\frac{1}{\\binom{N}{n}}\\sum_{k=max(0,n-(N-M))}^{min(n,M)} \\binom{M}{k}\\binom{N-M}{n-k} $$\nå³è¾¹çš„éƒ¨åˆ†ç”¨â€œè®²æ•…äº‹æ³•â€å®¹æ˜“è¯æ˜ç­‰äº $\\binom{N}{n}$ã€‚å¦‚æœéœ€è¦æ¯”è¾ƒæ•°å­¦çš„æ–¹æ³•ï¼Œå¯ä»¥ä» $(1+x)^N$ å’Œ $(1+x)^M(1+x)^{N-M}$ ä¸¤ä¸ªè§’åº¦å»è€ƒå¯Ÿ $x^n$ å‰çš„ç³»æ•°ã€‚\næ³¨ï¼šå½“ $N,N-M\u0026raquo;n\\geq k$ æ—¶ï¼Œè¶…å‡ ä½•åˆ†å¸ƒå¯ä»¥è¿‘ä¼¼åœ°å½“ä½œäºŒé¡¹åˆ†å¸ƒè®¡ç®—ï¼š $$ \\begin{align} \\frac{\\binom{M}{k}\\binom{N-M}{n-k}}{\\binom{N}{n}}\u0026amp;=\\frac{n!}{k!(n-k)!}\\frac{M(M-1)\\cdots (M-k+1)}{N(N-1)\\cdots (N-k+1)}\\frac{(N-M)\\cdots (N-M-(n-k)+1)}{(N-k)\\cdots (N-k-(n-k)+1)}\\\\ \u0026amp;\\approx \\binom{n}{k}\\left(\\frac{M}{N}\\right)^k\\left(\\frac{N-M}{N}\\right)^{n-k} \\end{align} $$\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"6de58b27325c3621f55ddda1917755c7","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-probability/lec05/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-probability/lec05/","section":"notes","summary":"Definitions $\\fbox{Definition 5.1}$ è®¾ $X:\\Omega \\rightarrow \\mathbb{R}$ï¼Œä¸”å¯¹äºä»»æ„ $\\mathbb{R}$ ä¸­çš„ Borel é›† $B$ï¼Œ$\\{e|X(e)\\in B\\}\\in \\mathscr{F}$ï¼Œåˆ™ç§° $X$ æ˜¯ $(\\Omega, \\mathscr F, P)$ ä¸Šçš„éšæœºå˜é‡ã€‚\næ³¨ï¼š1. Borel é›†æ˜¯ç”±æ‰€æœ‰çš„ $\\{(a,b]|-\\infty\\leq a,b\\leq +\\infty\\}$ ç»è¿‡å¯æ•°æ¬¡äº¤æˆ–å¹¶å¾—åˆ°çš„é›†åˆã€‚\nâ€‹\t2. åœ¨å¤§éƒ¨åˆ†åœºåˆï¼Œåªéœ€å…³æ³¨ $X$ æ˜¯ä» $\\Omega$ åˆ° $\\mathbb{R}$ ä¸Šçš„æ˜ å°„å³å¯ã€‚","tags":null,"title":"Lecture 05: Random Variable and Distribution Function","type":"docs"},{"authors":null,"categories":null,"content":"$\\fbox{Definition 6.1}$ è®¾å­˜åœ¨ä¸€ä¸ªéè´Ÿçš„å¯ç§¯å‡½æ•° $p(x)$ï¼Œè‹¥ $X$ çš„åˆ†å¸ƒå‡½æ•° $F(x)=\\int_{-\\infty}^xp(u)du$ï¼Œåˆ™ç§° $X$ ä¸ºè¿ç»­å‹éšæœºå˜é‡ï¼Œ$p(x)$ ä¸ºå¯†åº¦å‡½æ•°ã€‚\næ ¹æ®å®šä¹‰ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ° $$ \\begin{align} P(X\\leq a)\u0026amp;=F(a)=\\int_{-\\infty}^ap(x)dx\\\\ P(a\u0026lt;X\\leq b)\u0026amp;=F(b)-F(a)=\\int_a^b p(x)dx \\end{align} $$ ä¸€äº›æ³¨æ„ç‚¹ï¼š\n$F(x)$ è¿ç»­ã€‚\næ˜¾ç„¶ $p(x)$ æœ‰ç•Œï¼Œè®¾ $p(x)\\leq M\u0026lt;+\\infty$ï¼Œå¯¹äºå›ºå®šçš„ $x_0$ï¼Œ $$ |F(x)-F(x_0)|=\\left|\\int_{x_0}^xp(u)d(u)\\right|\\leq \\int_{x_0}^x |p(u)|du\\leq |x-x_0|M $$ $\\forall \\varepsilon\u0026gt;0$ï¼Œå½“ $|x-x_0|\\leq \\frac{\\varepsilon}{M}$ æ—¶ï¼Œ$|F(x)-F(x_0)|\\leq \\varepsilon$ã€‚\n$p(x)$ å¹¶ä¸èƒ½è¡¨ç¤º $P(X=x)$ã€‚äº‹å®ä¸Šå¯¹äºä»»æ„ $x_0$ï¼Œ$P(X=x_0)=0$ã€‚$p(x)$ åªèƒ½ç†è§£ä¸º $X$ åœ¨ $x$ çš„ä¸€ä¸ªå°é‚»åŸŸå†…çš„æ¦‚ç‡ä¸è¯¥é‚»åŸŸçš„é•¿åº¦çš„è¿‘ä¼¼æ¯”ï¼Œå³ $$ P(x\u0026lt;X\\leq x+ \\Delta x)=\\int_{x}^{x+\\Delta x}p(u)du\\approx p(x)\\Delta x $$ å…³äº $P(X=x_0)=0$ çš„è¯´æ˜ï¼š $$ 0\\leq P(X=x_0)\\leq P(x_0-\\Delta x\u0026lt;X\\leq x_0)=F(x_0)-F(x_0-\\Delta x)\\overset{\\Delta x\\rightarrow 0}{\\longrightarrow} 0 $$\nè‹¥ $p(x)$ åœ¨ $x_0$ è¿ç»­ï¼Œåˆ™ $F(x)$ åœ¨ $x_0$ å¤„å¯å¯¼ï¼Œä¸” $F\u0026rsquo;(x_0)=p(x_0)$ã€‚\n$$ \\begin{align} F(x)-F(x_0)\u0026amp;=\\int_{x_0}^x p(u)du\\\\ \u0026amp;=\\int_{x_0}^x(p(u)-p(x_0))du+\\int_{x_0}^xp(x_0)du\\\\ \u0026amp;=\\int_{x_0}^x(p(u)-p(x_0))du+p(x_0)(x-x_0) \\end{align} $$\näºæ˜¯ $$ \\left|\\frac{F(x)-F(x_0)}{x-x_0}-p(x_0)\\right|\\leq \\frac{1}{|x-x_0|}\\int_{x_0}^x|p(u)-p(x_0)|du\\quad (*) $$ $\\forall \\varepsilon\u0026gt; 0,\\exists \\delta,|x-x_0|\u0026lt;\\delta \\Rightarrow |p(u)-p(x_0)|\u0026lt;\\varepsilon \\Rightarrow (*)\\leq \\frac{1}{|x-x_0|}\\cdot \\varepsilon |x-x_0|=\\varepsilon$ã€‚\nã€ä¾‹ã€‘ (å‡åŒ€åˆ†å¸ƒ) $[a,b]$ çš„å‡åŒ€åˆ†å¸ƒ $U[a,b]$ ä¸­ï¼Œ$X$ çš„å¯†åº¦å‡½æ•°å’Œåˆ†å¸ƒå‡½æ•°ä¸º $$ \\begin{align} p(x)\u0026amp;=\\begin{cases}\\frac{1}{b-a}\u0026amp;,a\\leq x\\leq b\\\\0\u0026amp;, otherwise\\end{cases}\\\\ F(x)\u0026amp;=\\begin{cases}0\u0026amp;,x\u0026lt;a\\\\\\int_a^x\\frac{du}{b-a}=\\frac{x-a}{b-a}\u0026amp;,a\\leq x\\leq b\\\\1\u0026amp;,x\u0026gt;b\\end{cases} \\end{align} $$ ã€ä¾‹ã€‘ (æ­£æ€åˆ†å¸ƒ) $X$ æœä»æ­£æ€åˆ†å¸ƒï¼Œè®°ä¸º $X\\sim N(\\mu, \\sigma^2)$ ï¼Œè‹¥ $$ p(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}ï¼Œ-\\infty\u0026lt;x\u0026lt;\\infty $$\n$$ \\begin{align} \\left(\\int_{-\\infty}^{+\\infty}p(x)dx\\right)^2\u0026amp;=\\left(\\int_{-\\infty}^{+\\infty}\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}dx\\right)\\left(\\int_{-\\infty}^{+\\infty}\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(y-\\mu)^2}{2\\sigma^2}}dy\\right)\\\\ \u0026amp;\\overset{u=\\frac{x-\\mu}{\\sigma},v=\\frac{y-\\mu}{\\sigma}}{=} \\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty}\\int_{-\\infty}^{+\\infty}e^{-\\frac{u^2+v^2}{2}}dudv\\\\ \u0026amp;\\overset{u=r\\cos \\theta,v=r\\sin \\theta}{=} \\frac{1}{2\\pi}\\int_0^{2\\pi}\\int_{0}^{+\\infty}e^{-\\frac{r^2}{2}}rdrd\\theta\\\\ \u0026amp;=1 \\end{align} $$\næ­£æ€åˆ†å¸ƒ $p(x)$ çš„å›¾åƒæœ‰ä»¥ä¸‹æ€§è´¨ï¼š\n$p(x)$ å…³äº $x=\\mu$ è½´å¯¹ç§°ã€‚$F(\\mu-a)+F(\\mu+a)=1$ã€‚ $\\sigma^2$ è¶Šå¤§ï¼Œ$p(x)$ çš„å›¾åƒè¶Šå¹³ã€‚(æœ€å¤§å€¼å˜å°ï¼Œä¸¤å¤´å˜é«˜ï¼Œæ–¹å·® $\\uparrow$) å½“ $\\mu=0,\\sigma=1$ æ—¶ï¼Œ$X$ ç§°ä¸ºæ ‡å‡†æ­£æ€åˆ†å¸ƒï¼š $$ \\begin{align} \\varphi(x)\u0026amp;=\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{x^2}{2}}\\\\ \\Phi(x)\u0026amp;=\\int_{-\\infty}^x\\varphi(u)du \\end{align} $$ $\\fbox{Theorem 6.2}$ è®¾ $X\\sim N(\\mu, \\sigma^2)$ï¼Œåˆ™ $Z=\\frac{X-\\mu}{\\sigma}\\sim N(0,1)$ã€‚\n$$ \\begin{align} F_Z(x)\u0026amp;=P(\\frac{X-\\mu}{\\sigma}\\leq x)=P(X\\leq \\sigma x+\\mu)\\\\ \u0026amp;=\\int_{-\\infty}^{\\sigma x+\\mu}\\frac{1}{\\sqrt{2\\pi}\\sigma} e^{-\\frac{(v-\\mu)^2}{2\\sigma^2}}dv\\\\ \u0026amp;\\overset{\\frac{v-\\mu}{\\sigma}=z}{=}\\int_{-\\infty}^x\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{z^2}{2}}d(\\sigma z+\\mu)\\\\ \u0026amp;=\\int_{-\\infty}^x\\varphi(u)du \\end{align} $$\nåˆ©ç”¨è¯¥å®šç†ï¼Œæˆ‘ä»¬å¯ä»¥å°†æ‰€æœ‰çš„æ­£æ€åˆ†å¸ƒè½¬æ¢ä¸ºæ ‡å‡†æ­£æ€åˆ†å¸ƒçš„è®¡ç®—ï¼š $$ P(X\\leq a)=P\\left(\\frac{X-\\mu}{\\sigma}\\leq \\frac{a-\\mu}{\\sigma}\\right)=\\Phi\\left(\\frac{a-\\mu}{\\sigma}\\right)\\\\ P(a\u0026lt;X\\leq b)=\\Phi\\left(\\frac{b-\\mu}{\\sigma}\\right)-\\Phi\\left(\\frac{a-\\mu}{\\sigma}\\right) $$\n\u0026ldquo;3-$\\sigma$\u0026rdquo; å‡†åˆ™ï¼š $$ \\begin{align} P(|X-\\mu|\\leq \\sigma)\u0026amp;=\\Phi(1)-\\Phi(-1)\\approx 0.6826\\\\ P(|X-\\mu|\\leq 2\\sigma)\u0026amp;\\approx 0.9544\\\\ P(|X-\\mu|\\leq 3\\sigma)\u0026amp;\\approx 0.9974 \\end{align} $$\nå½“æŸä¸ªæ ·æœ¬è¶…è¿‡å‡å€¼ä¸‰ä¸ªæ ‡å‡†å·®ä»¥ä¸Šæ—¶ï¼Œå¯ä»¥æ€€ç–‘å®ƒå­˜åœ¨ä¸€äº›é—®é¢˜ã€‚\n$\\fbox{Theorem 6.3}$ $$ (\\frac{1}{x}-\\frac{1}{x^3})\\varphi(x)\\leq 1-\\Phi(x)\\leq \\frac{1}{x}\\varphi(x) $$ ä¸”å½“ $x$ å……åˆ†å¤§æ—¶ï¼Œ$1-\\Phi(x)\\approx \\frac{1}{x}\\varphi(x)$ã€‚\nã€ä¾‹ã€‘ (æŒ‡æ•°åˆ†å¸ƒ) ç§° $X$ æœä»å‚æ•°ä¸º $\\lambda(\\lambda \u0026gt; 0)$ çš„æŒ‡æ•°åˆ†å¸ƒï¼Œè®°ä¸º $X\\sim E(\\lambda)$ï¼Œè‹¥ $$ \\begin{align} p(x)\u0026amp;=\\begin{cases} \\lambda e^{-\\lambda x}\u0026amp;,x\\geq 0\\\\ 0\u0026amp;, x\u0026lt;0 \\end{cases}\\\\ F(x)\u0026amp;=\\begin{cases} \\int_0^x \\lambda e^{-\\lambda u}du=1-e^{-\\lambda x}\u0026amp;, x\u0026gt;0\\\\ 0\u0026amp;, x\u0026lt;0 \\end{cases} \\end{align} $$ æ³¨ï¼šæŒ‡æ•°åˆ†å¸ƒå…·æœ‰æ— è®°å¿†æ€§ï¼Œi.e. $P(X\u0026gt;s+t|x\u0026gt;t)=P(X\u0026gt;s)$ã€‚æŒ‡æ•°åˆ†å¸ƒå’Œå‡ ä½•åˆ†å¸ƒæ˜¯å”¯äºŒå…·æœ‰æ— è®°å¿†æ€§çš„åˆ†å¸ƒã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"e51bbabbc6076ef72be701594e2ef10c","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-probability/lec06/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-probability/lec06/","section":"notes","summary":"$\\fbox{Definition 6.1}$ è®¾å­˜åœ¨ä¸€ä¸ªéè´Ÿçš„å¯ç§¯å‡½æ•° $p(x)$ï¼Œè‹¥ $X$ çš„åˆ†å¸ƒå‡½æ•° $F(x)=\\int_{-\\infty}^xp(u)du$ï¼Œåˆ™ç§° $X$ ä¸ºè¿ç»­å‹éšæœºå˜é‡ï¼Œ$p(x)$ ä¸ºå¯†åº¦å‡½æ•°ã€‚\næ ¹æ®å®šä¹‰ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ° $$ \\begin{align} P(X\\leq a)\u0026amp;=F(a)=\\int_{-\\infty}^ap(x)dx\\\\ P(a\u0026lt;X\\leq b)\u0026amp;=F(b)-F(a)=\\int_a^b p(x)dx \\end{align} $$ ä¸€äº›æ³¨æ„ç‚¹ï¼š\n$F(x)$ è¿ç»­ã€‚\næ˜¾ç„¶ $p(x)$ æœ‰ç•Œï¼Œè®¾ $p(x)\\leq M\u0026lt;+\\infty$ï¼Œå¯¹äºå›ºå®šçš„ $x_0$ï¼Œ $$ |F(x)-F(x_0)|=\\left|\\int_{x_0}^xp(u)d(u)\\right|\\leq \\int_{x_0}^x |p(u)|du\\leq |x-x_0|M $$ $\\forall \\varepsilon\u0026gt;0$ï¼Œå½“ $|x-x_0|\\leq \\frac{\\varepsilon}{M}$ æ—¶ï¼Œ$|F(x)-F(x_0)|\\leq \\varepsilon$ã€‚","tags":null,"title":"Lecture 06: Continuous Random Variables","type":"docs"},{"authors":null,"categories":null,"content":"è®¾ $X$ æ˜¯ä¸€ä¸ªéšæœºå˜é‡ï¼Œå‡½æ•° $g(x):\\mathbb R\\rightarrow \\mathbb{R}$ã€‚æ„é€ éšæœºå˜é‡ $Y$ï¼Œå½“ $X=x$ æ—¶ï¼Œ$Y=g(x)$ï¼Œç§° $Y$ æ˜¯ $X$ çš„å‡½æ•°ï¼Œè®°ä¸º $Y=g(X)$ã€‚åœ¨å·²çŸ¥ $X$ çš„åˆ†å¸ƒæ—¶ï¼Œæˆ‘ä»¬å¸Œæœ›æ±‚å‡º $Y$ çš„åˆ†å¸ƒã€‚\nDiscrete Situation è®¾ $X$ æ˜¯ä¸€ä¸ªç¦»æ•£å‹éšæœºå˜é‡ï¼Œå…¶åˆ†å¸ƒå¾‹ä¸º\n$x_1$ $x_2$ $\\cdots$ $x_k$ $\\cdots$ $p_1$ $p_2$ $\\cdots$ $p_k$ $\\cdots$ é‚£ä¹ˆ $Y\\in {g(x_k)}_{k=1}^n$ï¼Œå»é‡åå¯ä»¥å†™æˆ ${y_1,y_2,\\cdots,y_k,\\cdots}$ï¼Œæ˜¾ç„¶ $Y$ ä¹Ÿæ˜¯ç¦»æ•£å‹éšæœºå˜é‡ã€‚\nè€ƒè™‘ $P(Y=y)=P(g(X)=y)=P(x\\in{x|g(x)=y})$ï¼Œç”±å¯åˆ—å¯åŠ æ€§å¯çŸ¥ $P(Y=y)=\\sum_{x:g(x)=y}P(X=x)$ã€‚\nã€ä¾‹ã€‘$X$ æ˜¯ç¦»æ•£å‹éšæœºå˜é‡ï¼Œ$P(X=0)=0$ï¼Œå¯¹äºä»»æ„ $k\\in \\mathbb{N}$ï¼Œ$P(X=k)=P(X=-k)=p^k$ã€‚æ±‚ $Y=X^2$ çš„åˆ†å¸ƒå¾‹ã€‚\nè§£ï¼šé¦–å…ˆè§£å‡º $p$ï¼š$\\sum_{k=1}^\\infty P(X=\\pm k)=\\sum_{k=1}^\\infty 2P(X=k)=2\\sum_{k=1}^\\infty p^k=1$ï¼Œè§£å¾— $p=\\frac{1}{3}$ã€‚\næ˜¾ç„¶ $Y$ çš„å–å€¼åªèƒ½æ˜¯æ­£æ•´æ•°ã€‚å¯¹äºä»»æ„ $n\\in \\mathbb{N}$ï¼Œæœ‰ $$ P(Y=n)=P(X^2=n)=P(X=\\pm \\sqrt{n})=\\begin{cases}2(\\frac{1}{3})^{\\sqrt{n}}\u0026amp;, \\sqrt n\\in \\mathbb{N}\\\\0\u0026amp;, otherwise\\end{cases} $$\næ³¨ï¼šå¯ä»¥çœ‹å‡ºå³ä½¿ $P(X=k)\\neq P(X=-k)$ï¼Œåªè¦ $P(X=\\pm k)=2p^k$ï¼Œ$Y$ çš„åˆ†å¸ƒå°±æ˜¯ä¸Šè¿°ç»“æœã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œéšæœºå˜é‡çš„åˆ†å¸ƒå’Œéšæœºå˜é‡å‡½æ•°çš„åˆ†å¸ƒå¹¶ä¸æ˜¯ä¸€ä¸€æ˜ å°„ã€‚\nContinuous Situation è®¾ $X$ ä¸ºè¿ç»­å‹éšæœºå˜é‡ï¼Œ$y=g(x)$ ä¸ºè¿ç»­å‡½æ•°ï¼Œ$Y=g(X)$ï¼Œä¸€èˆ¬åœ°ï¼Œå¯å¦‚ä¸‹æ±‚ $Y$ çš„åˆ†å¸ƒå‡½æ•° $F_Y(y)$ å’Œå¯†åº¦å‡½æ•° $P_Y(y)$ï¼š $$ F_Y(y)=P(Y\\leq y)=P(g(X)\\leq y)=P(x\\in {x|g(x)\\leq y})=\\int_{x:g(x)\\leq y} p_X(x)dx $$ æœ€åçš„ç§¯åˆ†å¼å«å‚æ•° $y$ï¼Œç»“æœæ˜¯å…³äº $y$ çš„è¡¨è¾¾å¼ã€‚è‹¥ $F_Y(y)$ å¯å¯¼ï¼Œåˆ™ $p_Y(y)=F_Y\u0026rsquo;(y)$ã€‚\nã€ä¾‹ã€‘$X\\sim N(0,1)$ï¼Œæ±‚ $Y=X^2$ çš„åˆ†å¸ƒã€‚\nè§£ï¼šæ³¨æ„åˆ° $Y\\geq 0$ï¼Œæ‰€ä»¥å¯¹äºä»»æ„ $y\u0026lt;0$ï¼Œ$F_y(y)=0$ã€‚\nå¯¹äº $y\\geq 0$ï¼Œæœ‰ $$ F_Y(y)=P(Y\\leq y)=P(X^2\\leq y)=P(-\\sqrt{y}\\leq X\\leq \\sqrt{y})=F_X(\\sqrt{y})-F_X(-\\sqrt{y}) $$ æ¬²æ±‚ $p_Y(y)$ï¼Œæˆ‘ä»¬è¦å¯¹ $F_Y(y)$ æ±‚å¯¼ï¼Œæ³¨æ„ä½¿ç”¨é“¾å¼æ³•åˆ™ï¼š $$ \\begin{align} P_Y(y)\u0026amp;=F_Y\u0026rsquo;(y)=F_X\u0026rsquo;(\\sqrt{y})-F_X\u0026rsquo;(-\\sqrt{y})\\\\ \u0026amp;=p_X(\\sqrt{y})\\frac{1}{2\\sqrt{y}}-p_X(-\\sqrt{y})\\frac{-1}{2\\sqrt{y}}\\\\ \u0026amp;=\\frac{1}{\\sqrt{y}}p_X(\\sqrt{y})=\\frac{1}{\\sqrt{2\\pi y}}e^{-\\frac{y}{2}} \\end{align} $$ ç»¼ä¸Šï¼Œ $$ p_Y(y)=\\begin{cases}\\frac{1}{\\sqrt{2\\pi y}}e^{-\\frac{y}{2}}\u0026amp;,y\\geq 0\\\\0\u0026amp;,y\u0026lt;0\\end{cases} $$\næ³¨ï¼š$Y=X^2$ ç§°ä¸ºæœä»ä¸€ä¸ªè‡ªç”±åº¦çš„ $\\chi^2$ åˆ†å¸ƒã€‚$\\chi^2$ åˆ†å¸ƒæ˜¯ç»Ÿè®¡å­¦ä¸­çš„ä¸€ä¸ªé‡è¦åˆ†å¸ƒã€‚\nä¸Šè¿°åšæ³•éœ€è¦å…ˆè®¡ç®— $F_Y(y)$ å†æ±‚å¯¼è®¡ç®— $p_Y(y)$ã€‚è‹¥ $y=g(x)$ ä¸¥æ ¼å•è°ƒï¼Œåˆ™å¯¹ $g(x)$ åŠ ä»¥ä¸€äº›å¯å¯¼æ¡ä»¶ï¼Œå¯ä»¥ç›´æ¥è®¡ç®—å¯†åº¦å‡½æ•° $p_Y(y)$ã€‚\n$\\fbox{Theorem 7.1}$ è®¾ $X$ ä¸ºè¿ç»­å‹éšæœºå˜é‡ï¼Œå¯†åº¦å‡½æ•°ä¸º $p_X(x)$ã€‚è®¾ $y=g(x)$ ä¸¥æ ¼å•è°ƒå¤„å¤„å¯å¯¼ä¸”æ’æœ‰ $g\u0026rsquo;(x)\u0026gt;0$ æˆ– $g\u0026rsquo;(x)\u0026lt;0$ï¼Œåˆ™ $Y=g(X)$ ä¹Ÿä¸ºè¿ç»­å‹éšæœºå˜é‡ï¼Œä¸” $$ p_Y(y)=\\begin{cases} p_X(g^{-1}(y))\\cdot \\left|(g^{-1}(y))\u0026rsquo;\\right|\u0026amp;,Yå¯å–åˆ°y\\\\ 0\u0026amp;,Yå–ä¸åˆ°y \\end{cases} $$ å…¶ä¸­ $g^{-1}(y)$ æ˜¯ $g(x)$ çš„åå‡½æ•°ã€‚\næ³¨ï¼šå½“ $g(x)$ å•è°ƒä¸” $g\u0026rsquo;(x_0)$ å­˜åœ¨éé›¶ï¼Œå¯ä»¥è¯æ˜ $g^{-1}(y)$ åœ¨ $y_0=g(x_0)$ å¤„å¯å¯¼ã€‚ä½†å³ä½¿ä¸¥æ ¼å•è°ƒï¼Œ$g\u0026rsquo;(x)$ ä»å¯èƒ½åœ¨æŸä¸ª $x_0$ å–åˆ° 0 (å¦‚ $f(x)=x^3$ çš„ $x=0$ å¤„)ï¼Œæ­¤æ—¶ $g^{-1}(y)$ åœ¨ $y_0=g(x_0)$ å¤„çš„å¯å¯¼æ€§å­˜åœ¨é—®é¢˜ï¼Œæ•…è¦æ±‚ $g\u0026rsquo;(x)$ ä¸èƒ½å– 0ã€‚\nè¯æ˜ï¼šè¿™é‡Œä»…è¯å•è°ƒé€’å¢çš„æƒ…å†µï¼Œå•è°ƒé€’å‡å¤§åŒå°å¼‚ (æœ€ç»ˆä½¿ç»“è®ºæ·»ä¸Šç»å¯¹å€¼)ï¼š $$ F_Y(y_0)=P(Y\\leq y_0)=P(g(X)\\leq y_0)=\\int_{-\\infty}^{g^{-1}(y_0)}p_X(x)dx $$ ä½œå˜é‡æ›¿æ¢ $x=g^{-1}(y)$ï¼š $$ F_Y(y_0)=\\int_{-\\infty}^{y_0}p_X(g^{-1}(y))dg^{-1}(y)=\\int_{-\\infty}^{y_0}p_X(g^{-1}(y))(g^{-1}(y))\u0026lsquo;dy $$ æ ¹æ®å¾®ç§¯åˆ†åŸºæœ¬å®šç†ï¼Œ $$ p_Y(y_0)=F_Y\u0026rsquo;(y_0)=p_X(g^{-1}(y_0))(g^{-1}(y_0))\u0026rsquo; $$\nã€ä¾‹ã€‘$X\\sim N(\\mu, \\sigma^2)$ï¼Œ$Z=\\frac{X-\\mu}{\\sigma}$ï¼Œå³ $g(x)=\\frac{x-\\mu}{\\sigma}$ï¼Œ$Z=g(X)$ã€‚æ±‚ $Z$ çš„åˆ†å¸ƒã€‚\nè§£ï¼šæ˜¾ç„¶ $g(x)$ å•è°ƒé€’å¢ï¼Œä¸” $g\u0026rsquo;(x)=\\frac{1}{\\sigma}\u0026gt;0$ã€‚$g^{-1}(z)=\\sigma z+\\mu$ã€‚ $$ \\begin{align} p_Z(z)\u0026amp;=p_X(g^{-1}(z))\\left|(g^{-1}(z))\u0026rsquo;\\right|=p_X(\\sigma z+\\mu)\\cdot \\sigma\\\\ \u0026amp;=\\sigma\\cdot \\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(\\sigma z+\\mu-\\mu)^2}{2\\sigma^2}}\\\\ \u0026amp;=\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{z^2}{2}} \\end{align} $$ å³ $Z\\sim N(0,1)$ã€‚\nã€ä¾‹ã€‘è‹¥ $X$ æœä» $\\left(-\\frac{\\pi}{2},\\frac{\\pi}{2}\\right)$ ä¸Šçš„å‡åŒ€åˆ†å¸ƒï¼Œ$Y=\\tan X$ï¼Œæ±‚ $Y$ çš„åˆ†å¸ƒã€‚\nè§£ï¼š$y=g(x)=\\tan x$ï¼Œ$x=g^{-1}(y)=\\arctan y$ï¼Œ$(\\arctan y)\u0026rsquo;=\\frac{1}{1+y^2}$ã€‚äºæ˜¯ $$ \\begin{align} p_Y(y)\u0026amp;=p_X(\\arctan y)\\cdot \\left|\\frac{1}{1+y^2}\\right|\\\\ \u0026amp;= \\frac{1}{\\pi}\\cdot \\frac{1}{1+y^2} \\end{align} $$\næ³¨ï¼š$Y$ çš„åˆ†å¸ƒç§°ä¸ºæŸ¯è¥¿åˆ†å¸ƒã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"78e716fdb372f8383846ad165cd2dae0","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-probability/lec07/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-probability/lec07/","section":"notes","summary":"è®¾ $X$ æ˜¯ä¸€ä¸ªéšæœºå˜é‡ï¼Œå‡½æ•° $g(x):\\mathbb R\\rightarrow \\mathbb{R}$ã€‚æ„é€ éšæœºå˜é‡ $Y$ï¼Œå½“ $X=x$ æ—¶ï¼Œ$Y=g(x)$ï¼Œç§° $Y$ æ˜¯ $X$ çš„å‡½æ•°ï¼Œè®°ä¸º $Y=g(X)$ã€‚åœ¨å·²çŸ¥ $X$ çš„åˆ†å¸ƒæ—¶ï¼Œæˆ‘ä»¬å¸Œæœ›æ±‚å‡º $Y$ çš„åˆ†å¸ƒã€‚\nDiscrete Situation è®¾ $X$ æ˜¯ä¸€ä¸ªç¦»æ•£å‹éšæœºå˜é‡ï¼Œå…¶åˆ†å¸ƒå¾‹ä¸º\n$x_1$ $x_2$ $\\cdots$ $x_k$ $\\cdots$ $p_1$ $p_2$ $\\cdots$ $p_k$ $\\cdots$ é‚£ä¹ˆ $Y\\in {g(x_k)}_{k=1}^n$ï¼Œå»é‡åå¯ä»¥å†™æˆ ${y_1,y_2,\\cdots,y_k,\\cdots}$ï¼Œæ˜¾ç„¶ $Y$ ä¹Ÿæ˜¯ç¦»æ•£å‹éšæœºå˜é‡ã€‚","tags":null,"title":"Lecture 07: Distribution of Random Variable Function","type":"docs"},{"authors":null,"categories":null,"content":"Distribution Function of 2-Dimensional Random Variable $\\fbox{Definition 8.1}$ è®¾ $X,Y$ æ˜¯å®šä¹‰åœ¨ $(\\Omega, \\mathscr F, P)$ ä¸Šçš„éšæœºå˜é‡ï¼Œåˆ™ç§° $(X,Y)$ ä¸º $(\\Omega, \\mathscr F, P)$ ä¸Šçš„äºŒç»´éšæœºå˜é‡ã€‚å¯¹äºä»»æ„ $x,y\\in \\mathbb R$ï¼Œç§° $$ F(x,y)=P({X\\leq x}\\cap {Y\\leq y})=P(X\\leq x,Y\\leq y) $$ ä¸º $(X,Y)$ çš„ (è”åˆ) åˆ†å¸ƒå‡½æ•°ã€‚\næ³¨ï¼šä»å›¾åƒä¸Šæ¥çœ‹ï¼Œ$F(x_0,y_0)$ å³ä¸ºè½åœ¨ç‚¹ $(x_0,y_0)$ å·¦ä¸‹æ–¹æ— ç©·çŸ©å½¢çš„æ¦‚ç‡ã€‚\n$F(x,y)$ çš„è‹¥å¹²æ€§è´¨ï¼š\nå›ºå®š $x_0$ï¼Œ$F(x_0,y)$ å•è°ƒä¸å‡ï¼›å›ºå®š $y_0$ï¼Œ$F(x,y_0)$ å•è°ƒä¸å‡ã€‚\n(æ¨è®ºï¼š$\\forall x_1\u0026gt;x_2,y_1\u0026gt;y_2,F(x_1,y_1)\\geq F(x_2,y_2)$ã€‚)\nå›ºå®š $x_0$ï¼Œ$\\lim_{y\\rightarrow -\\infty}F(x_0,y)=F(x_0,-\\infty)=0$ï¼Œç±»ä¼¼å¯å¾— $F(-\\infty,-\\infty)=0,F(+\\infty,+\\infty)=1$ã€‚\nå›ºå®š $x_0$ï¼Œ$F(x_0,y)$ å¤„å¤„æœ‰å·¦æé™ä¸”å³è¿ç»­ (cÃ dlÃ g)ï¼Œå›ºå®š $y_0$ æ—¶äº¦ç„¶ã€‚\n$\\forall x_1\u0026gt;x_2,y_1\u0026gt;y_2,F(x_1,y_1)-F(x_1,y_2)-F(x_2,y_1)+F(x_2,y_2)\\geq 0$ã€‚\næ³¨ï¼šä¸Šè¿°æ€§è´¨ä¹Ÿæ˜¯ä¸€ä¸ªå‡½æ•°æ˜¯æŸä¸ª $(X,Y)$ çš„åˆ†å¸ƒå‡½æ•°çš„å……åˆ†æ¡ä»¶ã€‚\n$\\fbox{Definition 8.2}$ ç»™å®š $(X,Y)$ï¼Œ$X$ æˆ– $Y$ çš„åˆ†å¸ƒå‡½æ•°ç§°ä¸ºè¾¹ç¼˜æ¦‚ç‡ã€‚\nåœ¨ $F(x,y)$ å·²çŸ¥çš„æƒ…å†µä¸‹ï¼Œè¾¹ç¼˜æ¦‚ç‡å¯ä»¥ç›´æ¥æ±‚å‡ºï¼š $$ F_X(x)=P(X\\leq x)=P(X\\leq x,Y\\in \\mathbb{R})=\\lim_{y\\rightarrow +\\infty}F(x,y) $$ $\\fbox{Definition 8.3}$ è®¾éšæœºå˜é‡ $X,Y$ æ»¡è¶³å¯¹äºä»»æ„ $x,y\\in \\mathbb{R}$ï¼Œ${X\\leq x}$ ä¸ ${Y\\leq y}$ ç‹¬ç«‹ï¼Œå³ $P(X\\leq x,Y\\leq y)=P(X\\leq x)P(Y\\leq y), F(x,y)=F_X(x)F_Y(y)$ï¼Œåˆ™ç§° $X,Y$ ç›¸äº’ç‹¬ç«‹ã€‚\næ³¨ï¼šè™½ç„¶ä¸Šè¿°å®šä¹‰åªå¯¹ä¸€éƒ¨åˆ†äº‹ä»¶çš„ç‹¬ç«‹æ€§è¿›è¡Œäº†æè¿°ï¼Œä½†æ›´å¤æ‚çš„äº‹ä»¶çš„æƒ…å½¢ä¹Ÿæ˜¯å¯ä»¥æ¨å‡ºçš„ï¼š\n$$ \\begin{align} P(x_1\u0026lt;X\\leq x_2,y_1\u0026lt;Y\\leq y_2)\u0026amp;= F(x_2,y_2)-F(x_2,y_1)-F(x_1,y_2)+F(x_1,y_1)\\\\ \u0026amp;=F_X(x_2)F_Y(y_2)-F_X(x_2)F_Y(y_1)-F_X(x_1)F_Y(y_2)+F_x(x_1)F_Y(y_1)\\\\ \u0026amp;=(F_X(x_2)-F_X(x_1))(F_Y(y_2)-F_Y(y_1))\\\\ \u0026amp;=P(x_1\u0026lt;X\\leq x_2)P(y_1\u0026lt;Y\\leq Y_2) \\end{align} $$\nè®¾ $I_n,J_m$ æ˜¯ä¸¤åˆ—å·¦å¼€å³é—­åŒºé—´ï¼Œä¸” $\\forall n\\leq k,I_n\\cap I_k=\\emptyset,J_n\\cap J_k=\\emptyset$ï¼Œé‚£ä¹ˆ $$ \\begin{align} P(X\\in \\bigcup_{n=1}^\\infty I_n,Y\\in \\bigcup_{m=1}^\\infty J_m)\u0026amp;=P(\\bigcup_{n=1}^\\infty \\bigcup_{m=1}^\\infty {X\\in I_n, Y\\in J_m})\\\\ \u0026amp;\\overset{å¯åˆ—å¯åŠ æ€§}{=}\\sum_{n=1}^\\infty \\sum_{m=1}^\\infty P(X\\in I_n,Y\\in J_m)\\\\ \u0026amp;\\overset{ä¸Šä¸€æ¡ç»“è®º}{=}\\sum_{n=1}^\\infty \\sum_{m=1}^\\infty P(X\\in I_n)P(Y\\in J_m)\\\\ \u0026amp;= \\left(\\sum_{n=1}^\\infty P(X\\in I_n)\\right)\\left(\\sum_{m=1}^\\infty P(Y\\in J_m)\\right)\\\\ \u0026amp;=P(X\\in \\bigcup_{n=1}^\\infty I_n)P(Y\\in \\bigcup_{m=1}^\\infty J_m) \\end{align} $$\n$\\fbox{Theorem 8.4}$ è‹¥ $X,Y$ ç‹¬ç«‹ï¼Œ$f(x),g(y)$ ä¸ºè¿ç»­å‡½æ•°æˆ–åˆ†æ®µè¿ç»­å‡½æ•°ï¼Œé‚£ä¹ˆ $f(X)$ å’Œ $g(Y)$ ä¹Ÿç›¸äº’ç‹¬ç«‹ã€‚\nn-Dimensional Case é«˜ç»´æƒ…å†µå’ŒäºŒç»´æƒ…å†µçš„å®šä¹‰ï¼Œæ€§è´¨åŸºæœ¬ç›¸åŒã€‚æ±‚è§£å…¶ $k$ ç»´è¾¹ç¼˜æ¦‚ç‡æ—¶ï¼Œå°†å‰©ä¸‹çš„ $n-k$ ç»´éƒ½æ¨åˆ° $+\\infty$ å³å¯ã€‚\n$n$ ç»´éšæœºå˜é‡çš„ç‹¬ç«‹æ€§è¦æ±‚ï¼š$\\forall (x_1,x_2,\\cdots x_n)\\in \\mathbb{R}^n, P(X_1\\leq x_1,\\cdots X_n\\leq x_n)=\\prod_{k=1}^nP(X_k\\leq x_k)$ã€‚è”æƒ³ $n$ ä¸ªäº‹ä»¶ç‹¬ç«‹çš„å®šä¹‰ï¼Œè¯¥æ¡ä»¶ä¼¼ä¹æ›´å¼±ï¼š$n$ ä¸ªäº‹ä»¶çš„ç‹¬ç«‹æ€§å¯¹æ‰€æœ‰å­é›†éƒ½åšäº†çº¦æŸã€‚ä½†äº‹å®ä¸Šä¸Šè¿°æ¡ä»¶ä¹Ÿå¯¹æ‰€æœ‰å­é›†åšäº†çº¦æŸï¼šåªè¦å°†æŸäº›ç»´çš„ $x_i$ æ¨åˆ° $+\\infty$ ï¼Œåˆ™æ˜¯ä¸€ä¸ªå¯¹å­é›†çš„çº¦æŸã€‚\n2-Dimensional Discrete Random Variable $\\fbox{Definition 8.5}$ è‹¥äºŒç»´éšæœºå˜é‡ $(X,Y)$ çš„å¯èƒ½å–å€¼æ˜¯æœ‰é™å¤šä¸ªæˆ–å¯åˆ—æ— é™ä¸ªï¼Œåˆ™ç§° $(X,Y)$ ä¸ºç¦»æ•£å‹äºŒç»´éšæœºå˜é‡ï¼Œè®¾ $(X,Y)$ æ‰€æœ‰å¯èƒ½å–å€¼ä¸º $(x_i,y_j), \\forall i,j=1,2,\\cdots$ï¼Œåˆ™ç§° $P(X=x_i,Y=y_j),\\forall i,j=1,2,\\cdots$ ä¸º $(X,Y)$ çš„è”åˆåˆ†å¸ƒå¾‹ï¼Œå¯ç”¨è¡¨æ ¼è¡¨ç¤ºä¸º\nX/Y $y_1$ $\\cdots$ $y_k$ $\\cdots$ $x_1$ $p_{11}$ $\\cdots$ $p_{1k}$ $\\cdots$ $\\vdots$ $\\vdots$ $\\ddots$ $\\vdots$ $\\cdots$ $x_k$ $p_{k1}$ $\\cdots$ $p_{kk}$ $\\cdots$ $\\vdots$ $\\vdots$ $\\vdots$ $\\vdots$ $\\ddots$ $(X,Y)$ è”åˆåˆ†å¸ƒå¾‹çš„æ€§è´¨ï¼š\n$\\forall i,j, p_{ij}\\geq 0$\n$\\sum_{i=1}^\\infty \\sum_{j=1}^\\infty p_{ij}=1$\nè¾¹ç¼˜åˆ†å¸ƒçš„æ±‚æ³•ï¼š $$ \\begin{align} P(X=x_i)\u0026amp;=P\\left(X=x_i,Y\\in \\bigcup_{j=1}^\\infty {y_j}\\right)=P\\left(\\bigcup_{j=1}^\\infty {X=x_i,Y=y_j}\\right)\\\\ \u0026amp;=\\sum_{j=1}^\\infty P(X=x_i,Y=y_j)=\\sum_{j=1}^\\infty p_{i,j}\\overset{def}{=} P_{i\\cdot} \\\\ P(Y=y_j)\u0026amp;=\\sum_{i=1}^\\infty P(X=x_i,Y=y_j)\\overset{def}{=}P_{\\cdot j} \\end{align} $$\nå†è€ƒè™‘ç¦»æ•£å‹äºŒç»´éšæœºå˜é‡çš„åˆ†å¸ƒå‡½æ•°åŠå…¶è¾¹ç¼˜åˆ†å¸ƒå‡½æ•°ï¼š $$ F(x,y)=\\sum_{i:x_i\\leq x}\\sum_{j:y_j\\leq y}p_{i,j}\\\\ F_X(x)=\\sum_{i:x_i\\leq x}p_{i\\cdot}=\\sum_{i:x_i\\leq x}\\sum_{j=1}^\\infty p_{i,j} $$ ä¸€èˆ¬åœ°ï¼Œå¯¹äºåŒºåŸŸ $D\\subset \\mathbb{R}^2$ï¼Œæœ‰ $$ P((x,y)\\in D)=\\sum_{i,j:(x_i,y_j)\\in D}p_{i,j} $$ å¯¹äºç¦»æ•£å‹éšæœºå˜é‡çš„ç‹¬ç«‹æ€§ï¼Œ$X$ å’Œ $Y$ ç‹¬ç«‹å½“ä¸”ä»…å½“å¯¹äºä»»æ„ $i,j$ï¼Œ$P(X=x_i,Y=y_j)=P(X=x_i)P(Y=y_j)$ï¼Œæˆ–è€…å†™æˆ $p_{i,j}=p_{i\\cdot }p_{\\cdot j}$ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"6d31328016255aee4c17231ed93e802b","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-probability/lec08/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-probability/lec08/","section":"notes","summary":"Distribution Function of 2-Dimensional Random Variable $\\fbox{Definition 8.1}$ è®¾ $X,Y$ æ˜¯å®šä¹‰åœ¨ $(\\Omega, \\mathscr F, P)$ ä¸Šçš„éšæœºå˜é‡ï¼Œåˆ™ç§° $(X,Y)$ ä¸º $(\\Omega, \\mathscr F, P)$ ä¸Šçš„äºŒç»´éšæœºå˜é‡ã€‚å¯¹äºä»»æ„ $x,y\\in \\mathbb R$ï¼Œç§° $$ F(x,y)=P({X\\leq x}\\cap {Y\\leq y})=P(X\\leq x,Y\\leq y) $$ ä¸º $(X,Y)$ çš„ (è”åˆ) åˆ†å¸ƒå‡½æ•°ã€‚","tags":null,"title":"Lecture 08: Mult-dimensional Random Variable","type":"docs"},{"authors":null,"categories":null,"content":"Examples of Discrete 2-D Random Variable ã€ä¾‹ã€‘ (ä¸‰é¡¹åˆ†å¸ƒ) è‹¥äºŒç»´ç¦»æ•£å‹éšæœºå˜é‡ $(X,Y)$ çš„åˆ†å¸ƒå¾‹ä¸º $$ P(X=i,Y=j)=\\frac{n!}{i!j!(n-i-j)!}p_1^ip_2^j(1-p_1-p_2)^{n-i-j} $$ å…¶ä¸­ $i,j=0,1,\\cdots,n,i+j\\leq n,0\\leq p_1,p_2,p_1+p_2\\leq 1$ï¼Œåˆ™ç§° $(X,Y)$ æœä»å‚æ•° $n,p_1,p_2$ çš„ä¸‰é¡¹åˆ†å¸ƒã€‚\næ¦‚ç‡èƒŒæ™¯ï¼šåœ¨ $n$ é‡ç‹¬ç«‹é‡å¤è¯•éªŒä¸­ï¼Œæ¯æ¬¡è¯•éªŒæœ‰ä¸‰ç§å¯èƒ½çš„ç»“æœ $A_1,A_2,A_3$ï¼Œ$P(A_1)=p_1,P(A_2)=p_2$ã€‚ä»¤ $A_1$ å‘ç”Ÿæ¬¡æ•°ä¸º $X$ï¼Œ$A_2$ å‘ç”Ÿæ¬¡æ•°ä¸º $Y$ï¼Œåˆ™ $(X,Y)$ æœä»ä¸Šè¿°ä¸‰é¡¹åˆ†å¸ƒã€‚\nä¸‰é¡¹åˆ†å¸ƒçš„è¾¹ç¼˜åˆ†å¸ƒæ˜¯äºŒé¡¹åˆ†å¸ƒï¼Œå› ä¸ºåœ¨è®¡ç®— $P(X=k)$ æ—¶ï¼Œæˆ‘ä»¬ä¸å…³å¿ƒåœ¨æ²¡æœ‰å‘½ä¸­ $A_1$ æ—¶å‘½ä¸­çš„æ˜¯ $A_2$ è¿˜æ˜¯ $A_3$ï¼Œç›¸å½“äºåªå‰©ä¸‹äº†ä¸¤ç§äº‹ä»¶ã€‚æˆ‘ä»¬ä¹Ÿå¯ä»¥ä»ä»£æ•°ä¸Šè¿›è¡ŒéªŒè¯ï¼š $$ \\begin{align} P(X=k)\u0026amp;=P(X=k,0\\leq Y\\leq n-k)=\\sum_{i=0}^{n-k}P(X=k,Y=i)\\\\ \u0026amp;=\\sum_{i=0}^{n-k}\\frac{n!}{k!i!(n-k-i)!}p_1^kp_2^i(1-p_1-p_2)^{n-k-i}\\\\ \u0026amp;=\\frac{n!}{k!(n-k)!}p_1^k\\sum_{i=0}^{n-k}\\frac{(n-k)!}{i!(n-k-i)!}p_2^i(1-p_1-p_2)^{n-k-i}\\\\ \u0026amp;=\\frac{n!}{k!(n-k)!}p_1^k(p_2+(1-p_1-p_2))^{n-k}\\\\ \u0026amp;=\\binom{n}{k}p_1^k(1-p_1)^{n-k} \\end{align} $$ ä¸€èˆ¬åœ°ï¼Œå¯ä»¥å®šä¹‰ $k$ é¡¹åˆ†å¸ƒã€‚è®° $P(A_1)=p_1,\\cdots, P(A_k)=p_k$ï¼Œ$0\\leq p_1,\\cdots, p_k,\\sum_{i=1}^kp_i\\leq 1$ï¼Œè®° $X_j$æ˜¯ $n$ æ¬¡è¯•éªŒä¸­ $A_j$ å‘ç”Ÿçš„æ¬¡æ•°ï¼Œåˆ™ $(X_1,\\cdots, X_k)$ çš„åˆ†å¸ƒå¾‹ä¸º $$ P(X_1=j_1,\\cdots, X_k=j_k)=\\frac{n!}{j_1!\\cdots j_k!}p_1^{j_1}\\cdots p_k^{j_k} $$ å…¶ä¸­ $0\\leq j_1,\\cdots, j_k\\leq n,\\sum_{i=1}^kj_i=n$ã€‚\nã€ä¾‹ã€‘ (äºŒç»´è¶…å‡ ä½•åˆ†å¸ƒ) è‹¥äºŒç»´ç¦»æ•£å‹éšæœºå˜é‡ $(X,Y)$ çš„åˆ†å¸ƒå¾‹ä¸º $$ P(X=n_1,Y=n_2)=\\frac{\\binom{N_1}{n_1}\\binom{N_2}{n_2}\\binom{N_3}{n_3}}{\\binom{N}{n}} $$ å…¶ä¸­ $0\\leq n_1\\leq N_1,0\\leq n_2\\leq N_2,0\\leq n_3\\leq N_4,n_1+n_2+n_3=n,N_1+N_2+N_3=N$ï¼Œåˆ™ç§° $(X,Y)$ æœä»äºŒç»´è¶…å‡ ä½•åˆ†å¸ƒã€‚\næ¦‚ç‡èƒŒæ™¯ï¼šè®¾ $N$ ä¸ªç‰©å“åˆ†ä¸ºä¸‰ç±»ï¼Œå„æœ‰ $N_1,N_2,N_3$ ä¸ªï¼Œä¸æ”¾å›åœ°æŒ‘ $n$ ä¸ªï¼Œç¬¬ä¸€ç±»æŠ½åˆ° $X$ ä¸ªï¼Œç¬¬äºŒç±»æŠ½åˆ° $Y$ ä¸ªï¼Œåˆ™ $(X,Y)$ æœä»ä¸Šè¿°äºŒç»´è¶…å‡ ä½•åˆ†å¸ƒã€‚\nç±»ä¼¼åœ°ï¼ŒäºŒç»´è¶…å‡ ä½•åˆ†å¸ƒçš„è¾¹ç¼˜åˆ†å¸ƒæ˜¯ä¸€ç»´çš„è¶…å‡ ä½•åˆ†å¸ƒï¼š $$ \\begin{align} P(X=n_1)\u0026amp;=P(X=n_1,0\\leq Y\\leq \\min{N_2,n-n_1})\\\\ \u0026amp;=\\sum_{k=0}^{\\min{N_2,n-n_1}}\\frac{\\binom{N_1}{n_1}\\binom{N_2}{k}\\binom{N_3}{n-n_1-k}}{\\binom{N}{n}}\\\\ \u0026amp;=\\frac{\\binom{N_1}{n_1}}{\\binom{N}{n}}\\left(\\sum_{k=0}^{\\min{N_2,n-n_1}}\\binom{N_2}{k}\\binom{N_3}{n-n_1-k}\\right)\\\\ \u0026amp;=\\frac{\\binom{N_1}{n_1}}{\\binom{N}{n}}\\binom{N_2+N_3}{n-n_1}\\\\ \u0026amp;=\\frac{\\binom{N_1}{n_1}\\binom{N-N_1}{n-n_1}}{\\binom{N}{n}}\\qquad (ä¸€ç»´è¶…å‡ ä½•åˆ†å¸ƒ) \\end{align} $$\n2-Dimensional Continuous Random Variable $\\fbox{Definition 9.1}$ å¯¹äºä¸€ä¸ªäºŒç»´éšæœºå˜é‡ $(X,Y)$ çš„åˆ†å¸ƒå‡½æ•° $F(x,y)$ï¼Œè‹¥å­˜åœ¨éè´Ÿå¯ç§¯å‡½æ•° $p(x,y)$ï¼Œä½¿å¾—å¯¹äºä»»æ„ $(x,y)\\in \\mathbb{R}^2$ï¼Œæœ‰ $$ F(x,y)=\\int_{-\\infty}^x\\int_{-\\infty}^yp(u,v)dudv $$ åˆ™ç§° $(X,Y)$ æ˜¯äºŒç»´è¿ç»­å‹éšæœºå˜é‡ï¼Œç§° $p(x,y)$ æ˜¯ $(X,Y)$ çš„ (è”åˆ) æ¦‚ç‡å¯†åº¦å‡½æ•°ã€‚\n$p(x,y)$ çš„æ€§è´¨ï¼š\n$\\forall (x,y)\\in \\mathbb{R}^2,p(x,y)\\geq 0$\n$$ \\int_{-\\infty}^{+\\infty}\\int_{-\\infty}^{+\\infty}p(x,y)dxdy=F(+\\infty,+\\infty)=1 $$\nè®¾ $D\\subseteq \\mathbb{R}^2$ï¼Œåˆ™ $(X,Y)$ è½å…¥ $D$ ä¸­çš„æ¦‚ç‡ä¸º $$ P((X,Y)\\in D)=\\iint_D p(x,y)dxdy $$\nè‹¥ $p(x,y)$ åœ¨ $(x_0,y_0)$ é™„è¿‘è¿ç»­ï¼Œåˆ™æœ‰ $$ \\left.\\frac{\\partial^2 F(x,y)}{\\partial x\\partial y}\\right|_{(x,y)=(x_0,y_0)}=p(x_0,y_0) $$ æ³¨ï¼šå’Œä¸€ç»´çš„æƒ…å½¢ç±»ä¼¼ï¼Œåœ¨äºŒç»´è¿ç»­å‹éšæœºå˜é‡ä¸­ï¼Œ$p(x_0,y_0)$ ä¸èƒ½ç†è§£ä¸º $x=x_0,y=y_0$ çš„æ¦‚ç‡ã€‚äº‹å®ä¸Šï¼Œ$\\forall x_0,y_0\\in \\mathbb{R},P(X=x_0,Y=y_0)=0$ã€‚$p(x_0,y_0)$ åªèƒ½ç†è§£ä¸º $(X,Y)$ è½å…¥ $(x_0,y_0)$ é™„è¿‘ä¸€å°å—é¢ç§¯çš„æ¦‚ç‡çš„è¿‘ä¼¼å€¼ï¼Œå³ $$ \\int_{x_0}^{x_0+\\Delta x}\\int_{y_0}^{y_0+\\Delta y}p(x,y)dxdy\\approx p(x_0,y_0)\\Delta x\\Delta y $$\nè¾¹ç¼˜åˆ†å¸ƒå’Œå¯†åº¦å‡½æ•°çš„æ±‚æ³•ï¼š\n$X$ çš„è¾¹ç¼˜åˆ†å¸ƒå‡½æ•°ä¸º $$ F_X(x)=F(X,+\\infty)=\\int_{-\\infty}^x\\left[\\int_{-\\infty}^{+\\infty}p(u,y)dy\\right]du $$ $X$ çš„è¾¹ç¼˜å¯†åº¦å‡½æ•°ä¸º $$ p_X(x)=\\frac{d}{dx}F_X(x)=\\int_{-\\infty}^{\\infty}p(x,y)dy $$ (ç›´è§‚åœ°æƒ³ï¼Œç¦»æ•£æ—¶è¾¹ç¼˜å¯†åº¦çš„æ±‚æ³•æ˜¯å›ºå®š $x$ï¼Œå¯¹æ‰€æœ‰å¯èƒ½çš„ $y$ æ±‚å’Œï¼Œé‚£ä¹ˆåœ¨è¿ç»­å‹ä¸­å°†æ±‚å’Œæ¢ä½œç§¯åˆ†å³å¯ã€‚)\n$Y$ çš„è¾¹ç¼˜åˆ†å¸ƒå’Œå¯†åº¦å‡½æ•°æ±‚æ³•ç±»ä¼¼ã€‚\nå…³äºç‹¬ç«‹æ€§ï¼šå¯¹äºä¸€èˆ¬çš„äºŒç»´éšæœºå˜é‡ï¼Œ$X,Y$ çš„ç‹¬ç«‹æ€§å®šä¹‰ä¸º $$ \\forall (x,y)\\in \\mathbb{R}^2,F(x,y)=F_X(x)F_Y(y) $$ åœ¨è¿ç»­çš„æƒ…å½¢ä¸­ï¼Œå³ $$ \\int_{-\\infty}^x\\int_{-\\infty}^yp(u,v)dudv=\\int_{-\\infty}^xp_X(u)du\\int_{-\\infty}^yp_Y(v)dv=\\int_{-\\infty}^x\\int_{-\\infty}^yp_X(u)p_Y(v)dudv $$ å› ä¸ºä¸Šå¼å¯¹äºä»»æ„ $x,y$ å‡æˆç«‹ï¼Œæ‰€ä»¥ç‹¬ç«‹æ€§æ¡ä»¶å¯ä»¥ç”¨å¯†åº¦å‡½æ•°ç›´æ¥è¡¨ç¤ºä¸º $$ \\forall (x,y)\\in \\mathbb{R}^2,p(x,y)=p_X(x)p_Y(y) $$\nn-Dimensional Continuous Random Variable $\\fbox{Definition 9.2}$ è®¾ $n$ ç»´éšæœºå˜é‡ $(X_1,\\cdots, X_n)$ çš„åˆ†å¸ƒå‡½æ•°ä¸º $F(x_1,\\cdots, x_n)$ï¼Œè‹¥å­˜åœ¨éè´Ÿå¯ç§¯å‡½æ•° $p(x_1,\\cdots, x_n)$ ä½¿å¾— $$ \\forall (x_1,\\cdots,x_n)\\in \\mathbb{R}^n,F(x_1,\\cdots, x_n)=\\int_{-\\infty}^{x_1}\\cdots \\int_{-\\infty}^{x_n} p(u_1,\\cdots, u_n)du_1\\cdots du_n $$ åˆ™ç§° $(X_1,\\cdots, X_n)$ ä¸º $n$ ç»´è¿ç»­å‹éšæœºå˜é‡ï¼Œ$p(x_1,\\cdots, x_n)$ ä¸º (è”åˆ) æ¦‚ç‡å¯†åº¦å‡½æ•°ã€‚\nExamples of 2-D Continuous Random Variable ã€ä¾‹ã€‘ (äºŒç»´å‡åŒ€åˆ†å¸ƒ) è®¾ $D\\subset \\mathbb{R}^2$ ä¸ºæœ‰ç•ŒåŒºåŸŸï¼Œé¢ç§¯ä¸º $S_D$ã€‚è‹¥ $(X,Y)$ çš„è”åˆå¯†åº¦å‡½æ•°ä¸º $$ p(x,y)=\\begin{cases} \\frac{1}{S_D}\u0026amp;, (X,Y)\\in D\\\\ 0\u0026amp;, (X,Y)\\in D \\end{cases} $$ åˆ™ç§° $(X,Y)$ æœä»åŒºåŸŸ $D$ ä¸Šçš„äºŒç»´å‡åŒ€åˆ†å¸ƒã€‚\n(æ³¨ï¼šäº‹å®ä¸Šè¯¥å®šä¹‰å’Œä¸€ç»´æƒ…å†µç›¸åŒï¼Œä¸€ç»´æƒ…å†µçš„æµ‹åº¦æ˜¯é•¿åº¦ï¼ŒäºŒç»´æƒ…å†µçš„æµ‹åº¦æ˜¯é¢ç§¯ã€‚)\nè¯¥åˆ†å¸ƒçš„å‡åŒ€æ€§ä½“ç°åœ¨ï¼šå¯¹äºä»»æ„ $A\\subseteq D$ï¼Œè‹¥ $A$ çš„é¢ç§¯ä¸º $S_A$ï¼Œåˆ™ $P((X,Y)\\in A)=\\frac{S_A}{S_D}$ï¼Œä¸ $A$ çš„å½¢çŠ¶ã€ä½ç½®æ— å…³ï¼Œåªä¸ $A$ çš„é¢ç§¯æœ‰å…³ (ç±»æ¯”äºŒç»´å‡ ä½•æ¦‚å‹)ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"d3d8ec1e0310ef8d743f2840f609fea5","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-probability/lec09/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-probability/lec09/","section":"notes","summary":"Examples of Discrete 2-D Random Variable ã€ä¾‹ã€‘ (ä¸‰é¡¹åˆ†å¸ƒ) è‹¥äºŒç»´ç¦»æ•£å‹éšæœºå˜é‡ $(X,Y)$ çš„åˆ†å¸ƒå¾‹ä¸º $$ P(X=i,Y=j)=\\frac{n!}{i!j!(n-i-j)!}p_1^ip_2^j(1-p_1-p_2)^{n-i-j} $$ å…¶ä¸­ $i,j=0,1,\\cdots,n,i+j\\leq n,0\\leq p_1,p_2,p_1+p_2\\leq 1$ï¼Œåˆ™ç§° $(X,Y)$ æœä»å‚æ•° $n,p_1,p_2$ çš„ä¸‰é¡¹åˆ†å¸ƒã€‚\næ¦‚ç‡èƒŒæ™¯ï¼šåœ¨ $n$ é‡ç‹¬ç«‹é‡å¤è¯•éªŒä¸­ï¼Œæ¯æ¬¡è¯•éªŒæœ‰ä¸‰ç§å¯èƒ½çš„ç»“æœ $A_1,A_2,A_3$ï¼Œ$P(A_1)=p_1,P(A_2)=p_2$ã€‚ä»¤ $A_1$ å‘ç”Ÿæ¬¡æ•°ä¸º $X$ï¼Œ$A_2$ å‘ç”Ÿæ¬¡æ•°ä¸º $Y$ï¼Œåˆ™ $(X,Y)$ æœä»ä¸Šè¿°ä¸‰é¡¹åˆ†å¸ƒã€‚","tags":null,"title":"Lecture 09: 2-Dimensional Continuous Random Variable","type":"docs"},{"authors":null,"categories":null,"content":"$\\fbox{Definition 10.1}$ è‹¥äºŒç»´éšæœºå˜é‡ $(X,Y)$ çš„è”åˆå¯†åº¦ä¸º $$ p(x,y)=\\frac{1}{2\\pi \\sigma_1\\sigma_2\\sqrt{1-\\rho^2}}e^{-\\frac{1}{2(1-\\rho^2)}[(\\frac{x-\\mu_1}{\\sigma_1})^2-2\\rho(\\frac{x-\\mu_1}{\\sigma_1})(\\frac{y-\\mu_2}{\\sigma_2})+(\\frac{y-\\mu_2}{\\sigma_2})^2]} $$ å…¶ä¸­ $\\mu_1,\\mu_2\\in \\mathbb R$ï¼Œ$\\sigma_1,\\sigma_2\u0026gt;0$ï¼Œ$|\\rho|\u0026lt;1$ï¼Œåˆ™ç§° $(X,Y)$ æœä»äºŒç»´æ­£æ€åˆ†å¸ƒã€‚è®°ä¸º $(X,Y)\\sim N(\\mu_1,\\mu_2,\\sigma_1^2,\\sigma_2^2,\\rho)$ (è¿™é‡Œçš„æ¯ä¸ªå‚æ•°éƒ½æœ‰å…·ä½“å«ä¹‰)ã€‚\n$\\fbox{Theorem 10.2}$ è‹¥ $(X,Y)\\sim N(\\mu_1,\\mu_2,\\sigma_1^2,\\sigma_2^2,\\rho)$ï¼Œåˆ™å…¶è¾¹ç¼˜åˆ†å¸ƒä¸º $X\\sim N(\\mu_1,\\sigma_1^2)$ï¼Œ$Y\\sim N(\\mu_2,\\sigma_2^2)$ã€‚\nè¯æ˜ï¼šæ ¹æ®å¯¹ç§°æ€§ï¼Œæˆ‘ä»¬ä»…éœ€è¯æ˜ $X$ çš„è¾¹ç¼˜åˆ†å¸ƒä¸ºæ­£æ€åˆ†å¸ƒã€‚\n$$ \\begin{align} p_X(x)\u0026amp;=\\int_{-\\infty}^{+\\infty}p(x,y)dy\\\\ \u0026amp;=\\frac{1}{2\\pi \\sigma_1\\sigma_2\\sqrt{1-\\rho^2}}e^{-\\frac{1}{2(1-\\rho^2)}\\left(\\frac{x-\\mu_1}{\\sigma_1}\\right)^2}\\int_{-\\infty}^{+\\infty}e^{-\\frac{1}{2}\\left[\\left(\\frac{y-\\mu_2}{\\sigma_2\\sqrt {1-\\rho^2}}\\right)^2-\\frac{2\\rho}{1-\\rho^2}\\left(\\frac{x-\\mu_1}{\\sigma_1}\\right)\\left(\\frac{y-\\mu_2}{\\sigma_2}\\right)\\right]}dy\\\\ \u0026amp;\\overset{é…æ–¹}{=} \\frac{1}{2\\pi \\sigma_1\\sigma_2\\sqrt{1-\\rho^2}}e^{-\\frac{1}{2(1-\\rho^2)}\\left(\\frac{x-\\mu_1}{\\sigma_1}\\right)^2}\\int_{-\\infty}^{+\\infty}e^{-\\frac{1}{2}\\left[\\left(\\frac{y-\\mu_2}{\\sigma_2\\sqrt {1-\\rho^2}}\\right)^2-\\frac{2\\rho}{1-\\rho^2}\\left(\\frac{x-\\mu_1}{\\sigma_1}\\right)\\left(\\frac{y-\\mu_2}{\\sigma_2}\\right)+\\left(\\frac{x-\\mu_1}{\\sigma_1\\sqrt{1-\\rho^2}}\\right)^2\\right]+\\frac{1}{2}\\frac{\\rho^2(x-\\mu_1)^2}{\\sigma_1^2(1-\\rho^2)}}dy\\\\ \u0026amp;=\\frac{1}{2\\pi \\sigma_1\\sigma_2\\sqrt{1-\\rho^2}}e^{-\\frac{1}{2}(\\frac{x-\\mu_1}{\\sigma_1})^2}\\int_{-\\infty}^{+\\infty}e^{-\\frac{1}{2}\\left(\\frac{y-\\mu_2}{\\sigma_2 \\sqrt{1-\\rho^2}}-\\frac{\\rho (x-\\mu_1)}{\\sigma_1 \\sqrt{1-\\rho^2}}\\right)^2}dy\\\\ \u0026amp;\\overset{u=\\frac{y-\\mu_2}{\\sigma_1\\sqrt{1-\\rho^2}}-\\frac{\\rho(x-\\mu_1)}{\\sigma_1\\sqrt{1-\\rho^2}}}{=}\\frac{1}{2\\pi \\sigma_1 \\sigma_2 \\sqrt{1-\\rho^2}}e^{\\frac{1}{2}\\left(\\frac{x-\\mu_1}{\\sigma_1}\\right)^2}\\int_{-\\infty}^{+\\infty}e^{-\\frac{1}{2}u^2}d(\\sigma_2\\sqrt{1-\\rho^2}u)\\\\ \u0026amp;=\\frac{1}{2\\pi \\sigma_1}e^{-\\frac{1}{2}\\left(\\frac{x-\\mu_1}{\\sigma_1}\\right)^2}\\int_{-\\infty}^{+\\infty}e^{-\\frac{u^2}{2}}du\\\\ \u0026amp;=\\frac{1}{\\sqrt{2\\pi}\\sigma_1}e^{-\\frac{1}{2}\\left(\\frac{x-\\mu_1}{\\sigma_1}\\right)^2} \\end{align} $$\nå› æ­¤ $X\\sim N(\\mu_1,\\sigma_1^2)$ã€‚$\\blacksquare$\næ³¨ï¼šäºŒç»´æ­£æ€åˆ†å¸ƒå¯ä»¥ç”¨çŸ©é˜µæè¿°æˆå¦‚ä¸‹æ›´ç®€æ´çš„å½¢å¼ï¼šè®° $\\Sigma=\\begin{bmatrix}\\sigma_1^2 \u0026amp; \\rho\\sigma_1\\sigma_2\\\\\\rho \\sigma_1\\sigma_2 \u0026amp; \\sigma_2^2 \\end{bmatrix}$ï¼Œåˆ™ $$ p(x,y)=\\frac{1}{2\\pi\\sqrt{|\\Sigma|}}e^{-\\frac{1}{2}(x-\\mu_1,y-\\mu_2)\\Sigma^{-1}\\begin{pmatrix}x-\\mu_1\\\\y-\\mu_2\\end{pmatrix}} $$ äºŒç»´æ­£æ€åˆ†å¸ƒçš„è¾¹ç¼˜åˆ†å¸ƒéƒ½æ˜¯æ­£æ€åˆ†å¸ƒï¼Œé‚£ä¹ˆä¸¤ä¸ªè¾¹ç¼˜åˆ†å¸ƒéƒ½æ˜¯æ­£æ€åˆ†å¸ƒçš„äºŒç»´åˆ†å¸ƒæ˜¯å¦ä¸€å®šæ˜¯äºŒç»´æ­£æ€åˆ†å¸ƒå‘¢ï¼Ÿç­”æ¡ˆæ˜¯å¦å®šçš„ã€‚è€ƒè™‘å¦‚ä¸‹åˆ†å¸ƒï¼šä»¤ $\\varphi(x)=\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{x^2}{2}}$ï¼Œ$g(x)=\\begin{cases}\\cos x\u0026amp;, |x|\\leq \\pi\\\\ 0\u0026amp;,|x| \u0026gt; \\pi\\end{cases}$ï¼Œå¯ä»¥çœ‹åˆ° $\\varphi$ å°±æ˜¯ä¸€ç»´æ ‡å‡†æ­£æ€åˆ†å¸ƒçš„å¯†åº¦å‡½æ•°ã€‚ä»¤ $$ p(x,y)=\\varphi(x)\\varphi(y)+\\frac{1}{2\\pi} e^{-\\pi^2}g(x)g(y) $$ è¿™æ˜¾ç„¶ä¸æ˜¯è”åˆæ­£æ€å¯†åº¦å‡½æ•°ï¼Œä½†æˆ‘ä»¬é€ä¸€éªŒè¯äºŒç»´åˆ†å¸ƒçš„æ¡ä»¶å’Œè¾¹ç¼˜åˆ†å¸ƒï¼š\n$p(x,y)\\geq 0$ï¼šæˆ‘ä»¬åªéœ€è€ƒè™‘ $|x|\\leq \\pi, |y|\\leq \\pi$ çš„æ–¹å½¢åŒºåŸŸï¼š $$ p(x,y)=\\frac{1}{2\\pi}\\left(e^{-\\frac{x^2+y^2}{2}}+e^{-\\pi^2}\\cos x\\cos y\\right)\\geq \\frac{1}{2\\pi}\\left(e^{-\\frac{x^2+y^2}{2}}-e^{-\\pi^2}\\right)\\geq 0 $$\n$$ \\begin{align} p_X(x)\u0026amp;=\\int_{-\\infty}^{+\\infty}\\varphi(x)\\varphi(y)dy+\\frac{1}{2\\pi}e^{-\\pi^2}\\int_{-\\infty}^{+\\infty}g(x)g(y)dy\\\\ \u0026amp;=\\varphi(x)+\\frac{1}{2\\pi}e^{-\\pi^2}g(x)\\int_{-\\pi}^{\\pi}\\cos y dy\\\\ \u0026amp;=\\varphi(x) \\end{align} $$\n$$ \\int_{-\\infty}^{+\\infty}\\left(\\int_{-\\infty}^{+\\infty}p(x,y)dy\\right)dx=\\int_{-\\infty}^{+\\infty}\\varphi(x)dx=1 $$\n$\\fbox{Theorem 10.3}$ è‹¥ $(X,Y)\\sim N(\\mu_1,\\mu_2,\\sigma_1^2,\\sigma_2^2,\\rho)$ ï¼Œåˆ™ $X,Y$ ç‹¬ç«‹ $\\Leftrightarrow$ $\\rho =0$ã€‚\nè¯æ˜ï¼š$\\Leftarrow$ï¼šå½“ $\\rho=0$ æ—¶ï¼Œ $$ p(x,y)=\\frac{1}{2\\pi\\sigma_1\\sigma_2}e^{-\\frac{1}{2}\\left[\\left(\\frac{x-\\mu_1}{\\sigma_1}\\right)^2+\\left(\\frac{y-\\mu_2}{\\sigma_2}\\right)^2\\right]}=\\frac{1}{\\sqrt{2\\pi}\\sigma_1}e^{-\\frac{1}{2}\\left(\\frac{x-\\mu_1}{\\sigma_1}\\right)^2}\\cdot \\frac{1}{\\sqrt{2\\pi}\\sigma_2}e^{-\\frac{1}{2}\\left(\\frac{y-\\mu_2}{\\sigma_2}\\right)^2}=p_X(x)p_Y(y) $$ $\\Rightarrow$ï¼šå½“ $X,Y$ ç‹¬ç«‹æ—¶ï¼Œå– $x=\\mu_1,y=\\mu_2$ï¼Œåˆ™ $$ p(\\mu_1,\\mu_2)=\\frac{1}{2\\pi\\sigma_1\\sigma_2\\sqrt{1-\\rho^2}}=p_X(x)p_Y(y)=\\frac{1}{2\\pi\\sigma_1\\sigma_2} $$ æ‰€ä»¥ $\\sqrt{1-\\rho^2}=1$ï¼Œ$\\rho = 0$ã€‚$\\blacksquare$\nã€ä¹ é¢˜3-5ã€‘äºŒç»´éšæœºå˜é‡ $(X,Y)$ çš„è”åˆå¯†åº¦å‡½æ•°ä¸º $$ p(x,y)=\\begin{cases}xe^{-y}\u0026amp;,0\u0026lt;x\u0026lt;y\\\\0\u0026amp;,otherwise\\end{cases} $$ æ±‚ $(X,Y)$ çš„è”åˆåˆ†å¸ƒå‡½æ•°ã€‚\n(ATTENTIONï¼š$F(x,y)$ çš„å«ä¹‰æ˜¯è½åœ¨ $(x,y)$ å·¦ä¸‹æ–¹çŸ©å½¢çš„æ¦‚ç‡ï¼Œåˆ‡å‹¿åœ¨ $p(x,y)$ ä¸ºé›¶æ—¶ç›´æ¥æ¨æµ‹ $F(x,y)$ ä¹Ÿä¸ºé›¶ï¼)\nè§£ï¼šå½“ $x\u0026lt;0$ æˆ– $y\u0026lt;0$ æ—¶ï¼Œ$F(x,y)=0$ã€‚\nå½“ $0\u0026lt;x\\leq y$ æ—¶ï¼Œæˆ‘ä»¬è¦ç§¯çš„æ˜¯ä¸€ä¸ªæ¢¯å½¢åŒºåŸŸï¼Œ $$ \\begin{align} F(x,y)\u0026amp;=\\int_0^x\\left(\\int_{u}^{y}ue^{-v}dv\\right)du\\\\ \u0026amp;=\\int_{0}^xu(e^{-u}-e^{-y})du\\\\ \u0026amp;=\\left(\\int_0^xue^{-u}du\\right)-\\frac{1}{2}x^2e^{-y}\\\\ \u0026amp;=1-e^{-x}-xe^{-x}-\\frac{1}{2}x^2e^{-y} \\end{align} $$ è€ƒè™‘åˆ° $F$ çš„è¿ç»­æ€§ï¼Œå½“ $0\u0026lt;y\u0026lt;x$ æ—¶ï¼Œ$F(x,y)=F(y,y)=1-e^{-y}-ye^{-y}-\\frac{1}{2}y^2e^{-y}$ã€‚\n2-Dimensional Random Variable Function è®¾ $(X,Y)$ ä¸ºäºŒç»´éšæœºå˜é‡ï¼Œ$z=g(x,y)$ ä¸ºäºŒå…ƒå®å‡½æ•°ï¼Œå®šä¹‰ $(X,Y)$ çš„å‡½æ•° $Z=g(X,Y)$ï¼Œå³ $Z$ åœ¨ $(X,Y)=(x,y)$ æ—¶å–å€¼ $g(x,y)$ï¼Œåˆ™ $Z$ æ˜¯ä¸€ä¸ªéšæœºå˜é‡ã€‚ä¸‹é¢ç»™å‡ºæ±‚ $Z$ çš„åˆ†å¸ƒçš„æ–¹æ³•ã€‚ $$ F_Z(z)=P(Z\\leq z)=P(g(x,y)\\leq z) $$ å¯¹äºç¦»æ•£æƒ…å½¢ï¼Œè®° $(X,Y)$ çš„åˆ†å¸ƒå¾‹ä¸º $P(X=x_i,Y=y_j)=p_{ij},i,j=1,2,\\cdots$ï¼Œåˆ™ $Z$ ä¹Ÿä¸ºç¦»æ•£å‹éšæœºå˜é‡ã€‚è®° $Z$ çš„å¯èƒ½å–å€¼ä¸º $z_k,k=1,2,\\cdots$ï¼Œåˆ™ $$ \\begin{align} P(Z=z_k)\u0026amp;=P(g(X,Y)=z_k)=P((X,Y)\\in {(x,y)|g(x,y)=z_k})\\\\ \u0026amp;= \\sum_{i,j:g(x_i,y_j)=z_k}P(X=x_i,Y=y_j)=\\sum_{i,j:g(x_i,y_j)=z_k}p_{ij} \\end{align} $$ å¯¹äºè¿ç»­æƒ…å½¢ï¼Œè®° $(X,Y)$ çš„å¯†åº¦å‡½æ•°ä¸º $p(x,y)$ï¼Œåˆ™ $$ \\begin{align} F_Z(z)\u0026amp;=P(g(X,Y)\\leq z)=P((X,Y)\\in {(x,y)|g(x,y)\\leq z})\\\\ \u0026amp;=\\iint_{{(x,y):g(x,y)\\leq z}}p(x,y)dxdy \\end{align} $$ è‹¥ $F_Z(z)$ å¯å¯¼ï¼Œåˆ™ $p_Z(z)=F_Z\u0026rsquo;(z)$ã€‚\nå¯¹äºæ··åˆæƒ…å½¢ï¼Œè‹¥ $X$ ä¸ºè¿ç»­å‹éšæœºå˜é‡ï¼Œå¯†åº¦å‡½æ•°ä¸º $p(x)$ï¼Œ$Y$ ä¸ºç¦»æ•£å‹éšæœºå˜é‡ï¼Œåˆ†å¸ƒä¸º $P(Y=y_j)=q_j,j=1,2,\\cdots$ã€‚é‚£ä¹ˆ $$ \\begin{align} F_Z(z)\u0026amp;=P(g(X,Y)\\leq z)=\\sum_{j=1}^\\infty P(g(X,Y)\\leq z,Y=y_j)\\\\ \u0026amp;=\\sum_{j=1}^\\infty P(g(X,y_j)\\leq z,Y=y_j)\\\\ \u0026amp;=\\sum_{j=1}^\\infty q_jP(g(X,y_j)\\leq z|Y=y_j)\\quad (æ¡ä»¶æ¦‚ç‡) \\end{align} $$ è‹¥ $X,Y$ ç‹¬ç«‹ï¼Œåˆ™ä¸Šå¼å¯åŒ–ä¸º $$ \\sum_{j=1}^\\infty P(g(X,y_j)\\leq z)=\\sum_{j=1}^\\infty q_j\\int_{x:g(x,y_j)\\leq z}p(x)dx $$\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"0dbdc34078b5ff51258092a6b4b9df2a","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-probability/lec10/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-probability/lec10/","section":"notes","summary":"$\\fbox{Definition 10.1}$ è‹¥äºŒç»´éšæœºå˜é‡ $(X,Y)$ çš„è”åˆå¯†åº¦ä¸º $$ p(x,y)=\\frac{1}{2\\pi \\sigma_1\\sigma_2\\sqrt{1-\\rho^2}}e^{-\\frac{1}{2(1-\\rho^2)}[(\\frac{x-\\mu_1}{\\sigma_1})^2-2\\rho(\\frac{x-\\mu_1}{\\sigma_1})(\\frac{y-\\mu_2}{\\sigma_2})+(\\frac{y-\\mu_2}{\\sigma_2})^2]} $$ å…¶ä¸­ $\\mu_1,\\mu_2\\in \\mathbb R$ï¼Œ$\\sigma_1,\\sigma_2\u0026gt;0$ï¼Œ$|\\rho|\u0026lt;1$ï¼Œåˆ™ç§° $(X,Y)$ æœä»äºŒç»´æ­£æ€åˆ†å¸ƒã€‚è®°ä¸º $(X,Y)\\sim N(\\mu_1,\\mu_2,\\sigma_1^2,\\sigma_2^2,\\rho)$ (è¿™é‡Œçš„æ¯ä¸ªå‚æ•°éƒ½æœ‰å…·ä½“å«ä¹‰)ã€‚\n$\\fbox{Theorem 10.2}$ è‹¥ $(X,Y)\\sim N(\\mu_1,\\mu_2,\\sigma_1^2,\\sigma_2^2,\\rho)$ï¼Œåˆ™å…¶è¾¹ç¼˜åˆ†å¸ƒä¸º $X\\sim N(\\mu_1,\\sigma_1^2)$ï¼Œ$Y\\sim N(\\mu_2,\\sigma_2^2)$ã€‚\nè¯æ˜ï¼šæ ¹æ®å¯¹ç§°æ€§ï¼Œæˆ‘ä»¬ä»…éœ€è¯æ˜ $X$ çš„è¾¹ç¼˜åˆ†å¸ƒä¸ºæ­£æ€åˆ†å¸ƒã€‚\n$$ \\begin{align} p_X(x)\u0026amp;=\\int_{-\\infty}^{+\\infty}p(x,y)dy\\\\ \u0026amp;=\\frac{1}{2\\pi \\sigma_1\\sigma_2\\sqrt{1-\\rho^2}}e^{-\\frac{1}{2(1-\\rho^2)}\\left(\\frac{x-\\mu_1}{\\sigma_1}\\right)^2}\\int_{-\\infty}^{+\\infty}e^{-\\frac{1}{2}\\left[\\left(\\frac{y-\\mu_2}{\\sigma_2\\sqrt {1-\\rho^2}}\\right)^2-\\frac{2\\rho}{1-\\rho^2}\\left(\\frac{x-\\mu_1}{\\sigma_1}\\right)\\left(\\frac{y-\\mu_2}{\\sigma_2}\\right)\\right]}dy\\\\ \u0026amp;\\overset{é…æ–¹}{=} \\frac{1}{2\\pi \\sigma_1\\sigma_2\\sqrt{1-\\rho^2}}e^{-\\frac{1}{2(1-\\rho^2)}\\left(\\frac{x-\\mu_1}{\\sigma_1}\\right)^2}\\int_{-\\infty}^{+\\infty}e^{-\\frac{1}{2}\\left[\\left(\\frac{y-\\mu_2}{\\sigma_2\\sqrt {1-\\rho^2}}\\right)^2-\\frac{2\\rho}{1-\\rho^2}\\left(\\frac{x-\\mu_1}{\\sigma_1}\\right)\\left(\\frac{y-\\mu_2}{\\sigma_2}\\right)+\\left(\\frac{x-\\mu_1}{\\sigma_1\\sqrt{1-\\rho^2}}\\right)^2\\right]+\\frac{1}{2}\\frac{\\rho^2(x-\\mu_1)^2}{\\sigma_1^2(1-\\rho^2)}}dy\\\\ \u0026amp;=\\frac{1}{2\\pi \\sigma_1\\sigma_2\\sqrt{1-\\rho^2}}e^{-\\frac{1}{2}(\\frac{x-\\mu_1}{\\sigma_1})^2}\\int_{-\\infty}^{+\\infty}e^{-\\frac{1}{2}\\left(\\frac{y-\\mu_2}{\\sigma_2 \\sqrt{1-\\rho^2}}-\\frac{\\rho (x-\\mu_1)}{\\sigma_1 \\sqrt{1-\\rho^2}}\\right)^2}dy\\\\ \u0026amp;\\overset{u=\\frac{y-\\mu_2}{\\sigma_1\\sqrt{1-\\rho^2}}-\\frac{\\rho(x-\\mu_1)}{\\sigma_1\\sqrt{1-\\rho^2}}}{=}\\frac{1}{2\\pi \\sigma_1 \\sigma_2 \\sqrt{1-\\rho^2}}e^{\\frac{1}{2}\\left(\\frac{x-\\mu_1}{\\sigma_1}\\right)^2}\\int_{-\\infty}^{+\\infty}e^{-\\frac{1}{2}u^2}d(\\sigma_2\\sqrt{1-\\rho^2}u)\\\\ \u0026amp;=\\frac{1}{2\\pi \\sigma_1}e^{-\\frac{1}{2}\\left(\\frac{x-\\mu_1}{\\sigma_1}\\right)^2}\\int_{-\\infty}^{+\\infty}e^{-\\frac{u^2}{2}}du\\\\ \u0026amp;=\\frac{1}{\\sqrt{2\\pi}\\sigma_1}e^{-\\frac{1}{2}\\left(\\frac{x-\\mu_1}{\\sigma_1}\\right)^2} \\end{align} $$","tags":null,"title":"Lecture 10: 2-Dimensional Normal Distribution and Random Variable Function","type":"docs"},{"authors":null,"categories":null,"content":"ã€ä¾‹ã€‘ (é¡ºåºç»Ÿè®¡é‡, order statistics) è®¾ $X,Y$ ç›¸äº’ç‹¬ç«‹ï¼Œåˆ†å¸ƒå‡½æ•°åˆ†åˆ«ä¸º $F_X(x)$ å’Œ $F_Y(y)$ã€‚ä»¤ $M=\\max \\{X,Y\\}$ï¼Œ$N=\\min \\{X,Y\\}$ï¼Œç°è€ƒè™‘ $M,N$ çš„åˆ†å¸ƒã€‚ $$ \\begin{align} F_M(z)\u0026amp;=P(M\\leq z)=P(\\max {X,Y}\\leq z)=P(X\\leq z,Y\\leq z)\\overset{ç‹¬ç«‹æ€§}{=}P(X\\leq z)P(Y\\leq z)=F_X(z)F_Y(z)\\\\ F_N(z)\u0026amp;=P(N\\leq z)=P(\\min {X,Y}\\leq z)=1-P(X\u0026gt;z,Y\u0026gt;z)=1-(1-F_X(z))(1-F_Y(z)) \\end{align} $$ æ³¨ï¼š(1) è®¾ $X,Y$ åªå–æ•´æ•°ï¼Œåˆ™ $P(M=n)=P(M\\leq n)-P(M\\leq n-1)=F_M(n)-F_M(n-1)$ã€‚\n(2) ä¸Šè¿°ç»“æœå¯ä»¥æ¨å¹¿åˆ° $n$ ä¸ªç‹¬ç«‹éšæœºå˜é‡ $X_1,\\cdots, X_n$ çš„æƒ…å½¢ï¼Œæ­¤æ—¶æœ‰ $$ \\begin{align} F_M(z)\u0026amp;=\\prod_{k=1}^nF_{X_i}(z)\\\\ F_N(z)\u0026amp;=1-\\prod_{k=1}^n(1-F_{X_i}(z)) \\end{align} $$ ã€ä¾‹ã€‘ (å’Œçš„åˆ†å¸ƒ) ä»¤ $Z=X+Y$ï¼Œè€ƒè™‘ä¸‹åˆ—æƒ…å½¢ä¸­ $Z$ çš„åˆ†å¸ƒï¼š\n$X,Y$ ç›¸äº’ç‹¬ç«‹ï¼Œä¸”å–å€¼å‡ä¸ºéè´Ÿæ•´æ•°ã€‚æ­¤æ—¶ $X,Y$ æ˜¾ç„¶å‡ä¸ºç¦»æ•£å‹éšæœºå˜é‡ï¼Œè®° $P(X=k)=p_k$ï¼Œ$P(Y-k)=q_k$ï¼Œ$k=0,1,2,\\cdots$ã€‚ $(X,Y)$ çš„å¯†åº¦å‡½æ•°ä¸º $p(x,y)$ã€‚ å¯¹äºç¦»æ•£æƒ…å½¢ï¼š $$ P(Z=n)=P(X+Y=n)=\\sum_{k=0}^nP(X=k,Y=n-k)=\\sum_{k=0}^nP(X=k)P(Y=n-k)=\\sum_{k=0}^np_kq_{n-k} $$ ä¸Šå¼ç§°ä¸º (ç¦»æ•£) å·ç§¯ (convolution) å…¬å¼ã€‚\nå¯¹äºè¿ç»­æƒ…å½¢ï¼š $$ \\begin{align} F_Z(z)\u0026amp;=P(X+Y\\leq z)=\\iint_{{(x,y):x+y\\leq z}}p(x,y)dxdy\\\\ \u0026amp;=\\int_{-\\infty}^{+\\infty}\\int_{-\\infty}^{z-x}p(x,y)dydx\\\\ \u0026amp;\\overset{y=v-x}{=}\\int_{-\\infty}^{+\\infty}\\int_{-\\infty}^zp(x,v-x)dvdx\\\\ \u0026amp;\\overset{æ¢åº}{=}\\int_{-\\infty}^z\\left(\\int_{-\\infty}^{+\\infty}p(x,v-x)dx\\right)dv \\end{align} $$ å› ä¸º $\\displaystyle{F_Z(z)=\\int_{-\\infty}^z p_Z(u)du}$ï¼Œå’Œä¸Šå¼å¯¹æ¯”ï¼Œæˆ‘ä»¬å‘ç°æ‹¬å·å†…çš„éƒ¨åˆ†æ­£å¥½æ˜¯ $Z$ çš„å¯†åº¦å‡½æ•°ã€‚ $$ p_Z(v)=\\int_{-\\infty}^{+\\infty}p(x,v-x)dx $$ ä¸Šå¼ç§°ä¸º (è¿ç»­) å·ç§¯å…¬å¼ã€‚\nè¿›ä¸€æ­¥åœ°ï¼Œè‹¥ $X,Y$ ç‹¬ç«‹ï¼Œåˆ™ $p(x,y)=p_X(x)p_Y(y)$ï¼Œå› æ­¤ $Z$ çš„å¯†åº¦ä¸º $$ p_Z(v)=\\int_{-\\infty}^{+\\infty}p_X(x)p_Y(v-x)dx $$\nã€ä¾‹é¢˜ã€‘ è®¾ $X\\sim B(n_1,p),Y\\sim B(n_2,p)$ï¼Œä¸” $X,Y$ ç‹¬ç«‹ï¼Œæ±‚ $X+Y$ çš„åˆ†å¸ƒã€‚\nè§£ï¼š$P(X=k)=\\binom{n_1}{k}p^k(1-p)^{n_1-k},k=0,\\cdots,n_1$ï¼Œ$P(Y=k)=\\binom{n_2}{k}p^k(1-p)^{n_2-k},k=0,\\cdots n_2$ã€‚\nä»¤ $Z=X+Y$ï¼Œåˆ™ $$ \\begin{align} P(Z=n)\u0026amp;=\\sum_{k=0}^nP(X=k,Y=n-k)=\\sum_{k=0}^nP(X=k)P(Y=n-k)\\\\ \u0026amp;=\\sum_{k=\\max \\{0,n-n_2\\}}^{\\min\\{n,n_1\\}}\\binom{n_1}{k}p^k(1-p)^{n_1-k}\\binom{n_2}{n-k}p^{n-k}(1-p)^{n_2-n+k}\\\\ \u0026amp;=p^n(1-p)^{n_1+n_2-n}\\sum_{k=\\max \\{0,n-n_2\\}}^{\\min \\{n,n_1\\}}\\binom{n_1}{k}\\binom{n_2}{n-k}\\\\ \u0026amp;=p^n(1-p)^{n_1+n_2-n}\\binom{n_1+n_2}{n} \\end{align} $$ å› æ­¤ $Z\\sim B(n_1+n_2,p)$ã€‚\nåœ¨å¤šæ¬¡å®éªŒ $p$ ç›¸åŒçš„æƒ…å†µä¸‹ï¼Œè¿™ä¸ªç»“è®ºæ˜¯å®¹æ˜“ç†è§£çš„ï¼šå…ˆåš $n_1$ æ¬¡å†åš $n_2$ æ¬¡å’Œä¸€å…±åš $n_1+n_2$ æ¬¡æ˜¯ä¸€æ ·çš„ã€‚\næ³¨ï¼šä¸Šè¿°ç»“è®ºå¯ä»¥æ¨å¹¿åˆ° $n$ ä¸ªå˜é‡çš„æƒ…å½¢ã€‚ä¸”ç±»ä¼¼å¯è¯å¯¹äºç‹¬ç«‹çš„æ³Šæ¾åˆ†å¸ƒ $X_k\\sim P(\\lambda_k),k=1,\\cdots n$ï¼Œæœ‰ $X=\\sum_{k=1}^nX_k\\sim P(\\sum_{k=1}^n\\lambda_k)$ã€‚\nã€ä¾‹é¢˜ã€‘è®¾ $X\\sim N(\\mu_1,\\sigma_1^2),Y\\sim N(\\mu_2,\\sigma_2^2)$ ä¸” $X,Y$ ç›¸äº’ç‹¬ç«‹ï¼Œæ±‚ $Z=X+Y$ çš„åˆ†å¸ƒã€‚\nè§£ï¼š$p_X(x)=\\frac{1}{\\sqrt {2\\pi}\\sigma_1}e^{-\\frac{(x-\\mu_1)^2}{2\\sigma_1^2}},p_Y(y)=\\frac{1}{\\sqrt {2\\pi}\\sigma_2}e^{-\\frac{(y-\\mu_2)^2}{2\\sigma_2^2}}$ã€‚\næ­£æ€åˆ†å¸ƒå˜é‡çš„å–å€¼å‡ä¸º $\\mathbb R$ ï¼Œå› æ­¤æˆ‘ä»¬ç›´æ¥ä½¿ç”¨å·ç§¯å…¬å¼ï¼š $$ \\begin{align} p_Z(z)=\\int_{-\\infty}^{+\\infty}p_X(x)p_Y(z-x)dx=\\frac{1}{2\\pi \\sigma_1 \\sigma_2}\\int_{-\\infty}^{+\\infty}e^{-\\frac{1}{2}\\left[\\left(\\frac{x-\\mu_1}{\\sigma_1}\\right)^2+\\left(\\frac{z-x-\\mu_2}{\\sigma_2}\\right)^2\\right]}dx \\end{align} $$ é‡åˆ°è¿™ç§ e ä¸Šå¸¦æŒ‡æ•°ï¼Œç§¯åˆ†åŒºåŸŸæ˜¯ $\\mathbb R$ çš„ç§¯åˆ†ï¼Œå¸¸è§çš„å¤„ç†æ‰‹æ³•æ˜¯å°†å…¶å‡‘æˆå¹³æ–¹çš„å½¢å¼ï¼Œç„¶åå¥—ç”¨é«˜æ–¯ç§¯åˆ†ã€‚å› æ­¤æˆ‘ä»¬ç°åœ¨å¸Œæœ›ä¸­æ‹¬å·ä¸­ä¸¤ä¸ªå¹³æ–¹å¼çš„äº¤å‰é¡¹æ¶ˆæ‰ã€‚è¿™é‡Œç»™å‡ºä¸€ä¸ªå¤„ç†æŠ€å·§ï¼šä»¤ $x=y+a$ï¼Œ$a$ ä¸ºå¾…å®šçš„ç³»æ•°ï¼Œåˆ™ $$ \\begin{align} p_Z(z)=\\frac{1}{2\\pi \\sigma_1 \\sigma_2}\\int_{-\\infty}^{+\\infty}e^{-\\frac{1}{2}\\left[\\left(\\frac{y+a-\\mu_1}{\\sigma_1}\\right)^2+\\left(\\frac{y+a+\\mu_2-z}{\\sigma_2}\\right)^2\\right]}dy \\end{align} $$ ä»¤äº¤å‰é¡¹ä¸ºé›¶ï¼Œå³ $$ \\frac{y}{\\sigma_1}\\cdot \\frac{a-\\mu_1}{\\sigma_1}+\\frac{y}{\\sigma_2}\\cdot \\frac{a+\\mu_2-z}{\\sigma_2}=0 $$ è§£å¾— $$ a=\\frac{\\mu_1\\sigma_2^2-\\mu_2\\sigma_1^2+z\\sigma_1^2}{\\sigma_1^2+\\sigma_2^2} $$ å¸¦å›åŸå¼ï¼Œæœ‰ $$ \\begin{align} p_Z(z)\u0026amp;=\\frac{1}{2\\pi \\sigma_1 \\sigma_2}\\int_{-\\infty}^{+\\infty}e^{-\\frac{1}{2}\\left[\\left(\\frac{y}{\\sigma_1}\\right)^2+\\left(\\frac{y}{\\sigma_2}\\right)^2+\\frac{(z-\\mu_1-\\mu_2)^2}{\\sigma_1^2+\\sigma_2^2}\\right]}dy\\\\ \u0026amp;=\\frac{1}{2\\pi \\sigma_1 \\sigma_2}e^{-\\frac{(z-\\mu_1-\\mu_2)^2}{2\\left(\\sigma_1^2+\\sigma_2^2\\right)}}\\int_{-\\infty}^{+\\infty}e^{-\\frac{1}{2}\\cdot \\frac{\\sigma_1^2+\\sigma_2^2}{\\sigma_1^2\\sigma_2^2}y^2}dy\\\\ \u0026amp;\\overset{v=\\sqrt{\\frac{\\sigma_1^2+\\sigma_2^2}{\\sigma_1^2\\sigma_2^2}}y}{=}\\frac{1}{2\\pi \\sigma_1 \\sigma_2}e^{-\\frac{(z-\\mu_1-\\mu_2)^2}{2\\left(\\sigma_1^2+\\sigma_2^2\\right)}}\\int_{-\\infty}^{+\\infty}e^{-\\frac{v^2}{2}}d\\left(\\sqrt{\\frac{\\sigma_1\\sigma_2}{\\sigma_1^2+\\sigma_2^2}}y\\right)\\\\ \u0026amp;=\\frac{1}{\\sqrt{2\\pi}\\cdot \\sqrt{\\sigma_1^2+\\sigma_2^2}}e^{-\\frac{(z-\\mu_1-\\mu_2)^2}{2\\left(\\sigma_1^2+\\sigma_2^2\\right)}} \\end{align} $$ å› æ­¤ $Z\\sim N(\\mu_1+\\mu_2,\\sigma_1^2+\\sigma_2^2)$ã€‚\nã€ä¾‹é¢˜ã€‘ (ä¹ é¢˜ 3.25) è®¾ $X\\sim U[0,2],Y\\sim U[0,1]$ ä¸” $X,Y$ ç‹¬ç«‹ï¼Œæ±‚ $Z=X+Y$ çš„å¯†åº¦å‡½æ•°ã€‚\nè§£ï¼šè¯¥é¢˜éšæœºå˜é‡å–å€¼ä¸æ˜¯ $\\mathbb R$ï¼Œå› æ­¤ä¸èƒ½å¥—ç”¨å·ç§¯å…¬å¼ï¼Œè¦ä»å®šä¹‰å‡ºæ³•æ±‚è§£ã€‚\n$p_X(x)=\\begin{cases}\\frac{1}{2}\u0026amp;,0\\leq x\\leq 2\\\\0\u0026amp;,otherwise\\end{cases}$ï¼Œ$p_Y(y)=\\begin{cases}1\u0026amp;,0\\leq y\\leq 1\\\\0\u0026amp;,otherwise\\end{cases}$ã€‚$(X,Y)$ çš„æœ‰æ•ˆåŒºåŸŸæ˜¯ä¸€ä¸ªé•¿æ–¹å½¢ã€‚ $$ F_Z(z)=P(X+Y\\leq z)=\\iint_{{(x,y):x+y\\leq z}}p(x,y)dxdy $$ åœ¨æœ‰æ•ˆåŒºåŸŸå†…ï¼Œæœ‰ $p(x,y)=p_X(x)p_Y(y)=\\frac{1}{2}$ã€‚è€ƒè™‘æ‹¿ç›´çº¿ $x+y\\leq z$ æ»‘è¿‡å¹³é¢ï¼Œçœ‹ç›´çº¿å·¦ä¾§ã€‚\nå®¹æ˜“çœ‹å‡º $z\\leq 0$ æ—¶ $F_Z(z)=0$ï¼›$z\\geq 3$ æ—¶ $F_Z(z)=1$ã€‚å‰©ä¸‹çš„å‡ ç§æƒ…å½¢éœ€è¦ä»”ç»†è€ƒè™‘ï¼š\n$0\u0026lt;z\u0026lt;1$ï¼Œæ­¤æ—¶è·å¾—çš„æ˜¯ä¸€ä¸ªä¸‰è§’å½¢ï¼Œ$F_Z(z)=\\frac{1}{2}\\cdot \\frac{z^2}{2}=\\frac{z^2}{4},p_Z(z)=F\u0026rsquo;_Z(z)=\\frac{z}{2}$ã€‚ $1\\leq z\u0026lt;2$ï¼Œæ­¤æ—¶è·å¾—çš„æ˜¯ä¸€ä¸ªæ¢¯å½¢ï¼Œ$F_Z(z)=\\frac{1}{2}\\cdot \\frac{z-1+z}{2}=\\frac{z}{2}-\\frac{1}{4}ï¼Œp_Z(z)=\\frac{1}{2}$ã€‚ $2\\leq z\u0026lt;3$ï¼Œæ­¤æ—¶è·å¾—çš„æ˜¯çŸ©å½¢å‡å»ä¸€ä¸ªä¸‰è§’å½¢ï¼Œ$F_Z(z)=\\frac{1}{2}\\cdot (2-\\frac{1}{2}(3-z)^2)=1-\\frac{1}{4}(3-z)^2$ï¼Œ$p_Z(z)=\\frac{1}{2}(3-z)$ã€‚ ","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"3cf2a896ca4fe155a38d4529fd33b0bd","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-probability/lec11/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-probability/lec11/","section":"notes","summary":"ã€ä¾‹ã€‘ (é¡ºåºç»Ÿè®¡é‡, order statistics) è®¾ $X,Y$ ç›¸äº’ç‹¬ç«‹ï¼Œåˆ†å¸ƒå‡½æ•°åˆ†åˆ«ä¸º $F_X(x)$ å’Œ $F_Y(y)$ã€‚ä»¤ $M=\\max \\{X,Y\\}$ï¼Œ$N=\\min \\{X,Y\\}$ï¼Œç°è€ƒè™‘ $M,N$ çš„åˆ†å¸ƒã€‚ $$ \\begin{align} F_M(z)\u0026amp;=P(M\\leq z)=P(\\max {X,Y}\\leq z)=P(X\\leq z,Y\\leq z)\\overset{ç‹¬ç«‹æ€§}{=}P(X\\leq z)P(Y\\leq z)=F_X(z)F_Y(z)\\\\ F_N(z)\u0026amp;=P(N\\leq z)=P(\\min {X,Y}\\leq z)=1-P(X\u0026gt;z,Y\u0026gt;z)=1-(1-F_X(z))(1-F_Y(z)) \\end{align} $$ æ³¨ï¼š(1) è®¾ $X,Y$ åªå–æ•´æ•°ï¼Œåˆ™ $P(M=n)=P(M\\leq n)-P(M\\leq n-1)=F_M(n)-F_M(n-1)$ã€‚","tags":null,"title":"Lecture 11: Examples of 2-Dimensional Random Variable Function","type":"docs"},{"authors":null,"categories":null,"content":"ã€ä¾‹ã€‘ (å·®çš„åˆ†å¸ƒ) è®¾ $(X,Y)$ çš„å¯†åº¦ä¸º $p(x,y)$ï¼Œè€ƒè™‘ $Z=X-Y$ çš„åˆ†å¸ƒï¼š $$ \\begin{align} F_Z(z)\u0026amp;=P(X-Y\\leq z)=\\iint_{{(x,y):x-y\\leq z}}p(x,y)dxdy\\\\ \u0026amp;=\\int_{-\\infty}^{+\\infty}\\left(\\int_{x-z}^{+\\infty}p(x,y)dy\\right)dx\\\\ \u0026amp;\\overset{y=x-v}{=}\\int_{-\\infty}^{+\\infty}\\int_z^{-\\infty}p(x,x-v)d(-v)dx\\\\ \u0026amp;=\\int_{-\\infty}^z\\left(\\int_{-\\infty}^{+\\infty}p(x,x-v)dx\\right)dv \\end{align} $$ å› æ­¤ $Z$ çš„å¯†åº¦å‡½æ•°ä¸º $$ p_Z(v)=\\int_{-\\infty}^{+\\infty}p(x,x-v)dx $$ å¦‚æœå…ˆç§¯ xï¼Œå¯ä»¥ç±»ä¼¼åœ°å¾—åˆ°å¦ä¸€ç§è¡¨è¾¾å¼ï¼š$p_Z(u)=\\int_{-\\infty}^{+\\infty}p(y+u,y)dy$ã€‚\nã€ä¾‹é¢˜ã€‘ (ä¹ é¢˜ 3.27) è®¾ $(X,Y)$ çš„å¯†åº¦ä¸º $p(x,y)=\\begin{cases}3x\u0026amp;,0\u0026lt;y\u0026lt;x\u0026lt;1\\\\0\u0026amp;,otherwise\\end{cases}$ï¼Œæ±‚ $Z=X-Y$ çš„å¯†åº¦ã€‚\nè§£ï¼šç”»å›¾å®¹æ˜“å¾—å‡º $p(x,y)$ çš„æœ‰æ•ˆåŒºåŸŸæ˜¯ä¸€ä¸ªä¸‰è§’å½¢ã€‚ $$ F_Z(z)=P(X-Y\\leq z)=\\iint_{{(x,y):x-y\\leq z}}p(x,y)dxdy $$ ç”¨ç›´çº¿ $x=y+z$ æ»‘è¿‡å¹³é¢ï¼Œå…³æ³¨ç›´çº¿çš„å·¦ä¾§ã€‚å®¹æ˜“çœ‹å‡º $z\u0026lt;0$ æ—¶ $F_Z(z)=0$ï¼Œ$z\\geq 1$ æ—¶ $F_Z(z)=1$ã€‚è¿™ä¸¤ä¸­æƒ…å†µä¸‹ $p_Z(z)=0$ã€‚$0\\leq z\u0026lt;1$ æ—¶ï¼ŒåŒºåŸŸä¸å¤ªè§„åˆ™ï¼Œè¦åˆ†æˆä¸¤ä¸ªéƒ¨åˆ†ï¼š $$ \\begin{align} F_Z(z)\u0026amp;=\\int_0^z\\int_0^x3xdydx+\\int_z^1\\int_{x-z}^x3xdydx\\\\ \u0026amp;=\\int_0^z3x^2dx+\\int_z^13zxdx\\\\ \u0026amp;=-\\frac{1}{2}z^3+\\frac{3}{2}z \\end{align} $$ ä»è€Œ $p_Z(z)=F_Z\u0026rsquo;(z)=-\\frac{3}{2}z^2+\\frac{3}{2}$ã€‚\nã€ä¾‹ã€‘ (ç§¯å’Œå•†çš„åˆ†å¸ƒ) è®¾ $(X,Y)$ çš„å¯†åº¦ä¸º $p(x,y)$ï¼Œè€ƒè™‘ä¸¤è€…ç§¯å’Œå•†çš„åˆ†å¸ƒï¼š\n$Z=XY$ $Z=\\frac{X}{Y}$ã€‚ å¯¹äºç§¯çš„åˆ†å¸ƒï¼Œ $$ F_Z(z)=P(XY\\leq z)=\\iint_{{(x,y):xy\\leq z}}p(x,y)dxdy $$ æˆ‘ä»¬è¦å°å¿ƒ $x$ çš„ç¬¦å·å¯¹ç§¯åˆ†ä¸Šä¸‹é™çš„å½±å“ï¼Œå› æ­¤è¦åˆ†ç±»è®¨è®º $x\u0026lt;0$ å’Œ $x\u0026gt;0$ çš„æƒ…å†µï¼š $$ \\begin{align} F_Z(z)\u0026amp;=\\int_{-\\infty}^0\\left(\\int_{z/x}^{+\\infty} p(x,y)dy\\right)dx+\\int_0^{+\\infty}\\left(\\int_{-\\infty}^{z/x}p(x,y)dy\\right)dx\\\\ \u0026amp;\\overset{y=\\frac{v}{x}}{=}\\int_{-\\infty}^0\\left(\\int_z^{-\\infty}p(x,\\frac{v}{x})d\\frac{v}{x}\\right) dx+\\int_0^{+\\infty}\\left(\\int_{-\\infty}^zp(x,\\frac{v}{x})d\\frac{v}{x}\\right)dx\\\\ \u0026amp;=\\int_{-\\infty}^z\\int_{-\\infty}^0-p(x,\\frac{v}{x})\\frac{1}{x}dxdv+\\int_{-\\infty}^z\\int_0^{+\\infty}p(x,\\frac{v}{x})\\frac{1}{x}dxdv\\\\ \u0026amp;=\\int_{-\\infty}^z\\left(\\int_{-\\infty}^{+\\infty}p(x,\\frac{v}{x})\\frac{1}{|x|}dx\\right)dv \\end{align} $$ å› æ­¤å¯†åº¦å‡½æ•° $$ p_Z(z)=\\int_{-\\infty}^{+\\infty}p(x,\\frac{v}{x})\\frac{1}{|x|}dx $$ å½“ç„¶ï¼Œå¦‚æœå…ˆç§¯ $y$ å†ç§¯ $x$ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°å¯¹ç§°çš„å½¢å¼ï¼š$p_Z(u)=\\int_{-\\infty}^{+\\infty}p(\\frac{u}{y},y)\\frac{1}{|y|}dy$ã€‚\nå¯¹äºå•†çš„åˆ†å¸ƒï¼Œ $$ F_Z(z)=P(X/Y\\leq z)=\\iint_{{(x,y):\\frac{x}{y}\\leq z}}p(x,y)dxdy $$ ç±»ä¼¼åœ°ï¼Œè€ƒè™‘ $y\u0026lt;0$ å’Œ $y\u0026gt;0$ï¼Œ $$ \\begin{align} F_Z(z)\u0026amp;=\\int_{-\\infty}^0\\left(\\int_{yz}^{+\\infty}p(x,y)dx\\right)dy+\\int_0^{+\\infty}\\left(\\int_{-\\infty}^{yz}p(x,y)dx\\right)dy\\\\ \u0026amp;\\overset{x=yu}{=}\\int_{-\\infty}^0\\left(\\int_z^{-\\infty}p(yu,y)d(yu)\\right)dy+\\int_0^{+\\infty}\\left(\\int_{-\\infty}^zp(yu,y)d(yu)\\right)dy\\\\ \u0026amp;=\\int_{-\\infty}^z\\left(\\int_{-\\infty}^0p(yu,y)(-y)dy\\right)du+\\int_{-\\infty}^z\\left(\\int_0^{+\\infty}p(yu,y)ydy\\right)du\\\\ \u0026amp;=\\int_{-\\infty}^z\\left(\\int_{-\\infty}^{+\\infty}p(yu,y)|y|dy\\right)du \\end{align} $$ å› æ­¤å¯†åº¦å‡½æ•° $$ p_Z(u)=\\int_{-\\infty}^{+\\infty}p(yu,y)|y|dy $$ ã€ä¾‹é¢˜ã€‘ (ä¹ é¢˜ 3.28) $(X,Y)$ çš„å¯†åº¦ä¸º $p(x,y)=\\begin{cases}\\frac{1}{2}\u0026amp;,0\\leq x\\leq 2,0\\leq y\\leq 1\\\\0\u0026amp;,otherwise\\end{cases}$ï¼Œæ±‚ $Z=XY$ çš„å¯†åº¦ã€‚\nè§£ï¼šç”¨åæ¯”ä¾‹å‡½æ•°æ›²çº¿ $z=xy$ æ»‘è¿‡å¹³é¢ï¼Œè€ƒè™‘æ›²çº¿ä¸‹æ–¹çš„éƒ¨åˆ†ã€‚æ˜¾ç„¶å½“ $z\u0026lt;0$ æ—¶ $F_Z(z)=0$ï¼Œ$z\\geq 2$ æ—¶ $F_Z(z)=1$ã€‚ä¸‹é¢è€ƒè™‘ $0\\leq z\u0026lt;2$ çš„éƒ¨åˆ†ï¼š $$ F_Z(z)=\\int_0^z\\int_0^1\\frac{1}{2}dydx+\\int_z^2\\int_0^{\\frac{z}{x}}\\frac{1}{2}dydx=\\frac{z}{2}(\\ln 2+1-\\ln z) $$ ä»è€Œ $p_Z(z)=F_Z\u0026rsquo;(z)=\\frac{1}{2}(\\ln 2-\\ln z)$ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"975f9e13dc3952850abc64dc6bafa889","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-probability/lec12/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-probability/lec12/","section":"notes","summary":"ã€ä¾‹ã€‘ (å·®çš„åˆ†å¸ƒ) è®¾ $(X,Y)$ çš„å¯†åº¦ä¸º $p(x,y)$ï¼Œè€ƒè™‘ $Z=X-Y$ çš„åˆ†å¸ƒï¼š $$ \\begin{align} F_Z(z)\u0026amp;=P(X-Y\\leq z)=\\iint_{{(x,y):x-y\\leq z}}p(x,y)dxdy\\\\ \u0026amp;=\\int_{-\\infty}^{+\\infty}\\left(\\int_{x-z}^{+\\infty}p(x,y)dy\\right)dx\\\\ \u0026amp;\\overset{y=x-v}{=}\\int_{-\\infty}^{+\\infty}\\int_z^{-\\infty}p(x,x-v)d(-v)dx\\\\ \u0026amp;=\\int_{-\\infty}^z\\left(\\int_{-\\infty}^{+\\infty}p(x,x-v)dx\\right)dv \\end{align} $$ å› æ­¤ $Z$ çš„å¯†åº¦å‡½æ•°ä¸º $$ p_Z(v)=\\int_{-\\infty}^{+\\infty}p(x,x-v)dx $$ å¦‚æœå…ˆç§¯ xï¼Œå¯ä»¥ç±»ä¼¼åœ°å¾—åˆ°å¦ä¸€ç§è¡¨è¾¾å¼ï¼š$p_Z(u)=\\int_{-\\infty}^{+\\infty}p(y+u,y)dy$ã€‚\nã€ä¾‹é¢˜ã€‘ (ä¹ é¢˜ 3.27) è®¾ $(X,Y)$ çš„å¯†åº¦ä¸º $p(x,y)=\\begin{cases}3x\u0026amp;,0\u0026lt;y\u0026lt;x\u0026lt;1\\\\0\u0026amp;,otherwise\\end{cases}$ï¼Œæ±‚ $Z=X-Y$ çš„å¯†åº¦ã€‚","tags":null,"title":" Lecture 12: More Examples of 2-Dimensional Random Variable Function","type":"docs"},{"authors":null,"categories":null,"content":"Expectation of Discrete Random Variables ç¦»æ•£å‹éšæœºå˜é‡çš„æ•°å­¦æœŸæœ›ç±»ä¼¼äºâ€œåŠ æƒå¹³å‡æ•°â€ï¼Œä½†æˆ‘ä»¬è¦å°†é¢‘ç‡æ¢æˆä¸¥æ ¼çš„æ¦‚ç‡ã€‚\n$\\fbox{Definition 13.1}$ è®¾ç¦»æ•£å‹éšæœºå˜é‡ $X$ çš„åˆ†å¸ƒå¾‹ä¸º $P(X=x_i)=p_i,i=1,2,\\cdots$ã€‚è‹¥çº§æ•° $\\sum_{i=1}^\\infty |x_i|p_i$ æ”¶æ•›ï¼Œåˆ™ç§° $$ E[x]\\triangleq \\sum_{i=1}^\\infty x_ip_i $$ ä¸º $X$ çš„æ•°å­¦æœŸæœ›ï¼Œç®€ç§°å‡å€¼æˆ–æœŸæœ›ã€‚\næ³¨ï¼š(1) åˆ†å¸ƒå”¯ä¸€å†³å®šäº†æœŸæœ›ã€‚\n(2) åœ¨å®šä¹‰ä¸­ï¼Œæˆ‘ä»¬è¦æ±‚çº§æ•° $\\sum_{i=1}^\\infty x_ip_i$ ç»å¯¹æ”¶æ•›ï¼Œè¿™æ˜¯ä¸ºäº†ä¿è¯é‡æ’ $x_ip_i$ çš„é¡ºåºä¸å½±å“æœŸæœ›çš„å€¼ (é‡‡æ ·é¡ºåºä¸åº”å½±å“å‡å€¼)ã€‚\n(3) å½“ $\\sum_{i=1}^\\infty |x_i|p_i$ ä¸æ”¶æ•›æ—¶ï¼Œç§° $X$ çš„æœŸæœ›ä¸å­˜åœ¨ã€‚\nã€ä¾‹ã€‘è€ƒè™‘æ³Šæ¾åˆ†å¸ƒ $P(\\lambda)$ çš„æœŸæœ›ã€‚æ³Šæ¾åˆ†å¸ƒçš„åˆ†å¸ƒå¾‹ä¸º $$ P(X=k)=\\frac{\\lambda^k}{k!}e^{-\\lambda}\\qquad k=0,1,\\cdots $$ å› æ­¤ $$ \\begin{align} E[x]\u0026amp;=\\sum_{k=1}^\\infty kP(X=k)=\\sum_{k=1}^\\infty k\\frac{\\lambda^k}{k!}e^{-\\lambda}=e^{-\\lambda}\\sum_{k=1}^\\infty \\frac{\\lambda^k}{(k-1)!}\\\\ \u0026amp;=e^{-\\lambda}\\lambda\\cdot \\sum_{n=0}^{\\infty} \\frac{\\lambda^n}{n!}=e^{-\\lambda}\\cdot \\lambda\\cdot e^{\\lambda}\\\\ \u0026amp;=\\lambda \\end{align} $$ ã€ä¾‹ã€‘è€ƒè™‘äºŒé¡¹åˆ†å¸ƒ $X\\sim B(n,p)$ çš„æœŸæœ›ã€‚äºŒé¡¹åˆ†å¸ƒçš„åˆ†å¸ƒå¾‹ä¸º $$ P(X=k)=\\binom{n}{k}p^k(1-p)^{n-k}\\qquad k=0,1,\\cdots, n $$ å› æ­¤ $$ \\begin{align} E[x]\u0026amp;=\\sum_{k=1}^\\infty kP(X=k)=\\sum_{k=1}^n k\\binom{n}{k}p^k(1-p)^{n-k}\\\\ \u0026amp;=\\sum_{k=1}^n \\frac{n!}{(k-1)!(n-k)!}p^k(1-p)^{n-k}\\\\ \u0026amp;=np\\sum_{k=1}^n\\frac{(n-1)!}{(k-1)!(n-k)!}p^{k-1}(1-p)^{n-k}\\\\ \u0026amp;=np\\sum_{k\u0026rsquo;=0}^{n-1}\\binom{n-1}{k\u0026rsquo;}p^{k\u0026rsquo;}(1-p)^{n-1-k\u0026rsquo;}\\\\ \u0026amp;=np\\cdot [p+(1-p)]^{n-1}\\\\ \u0026amp;=np \\end{align} $$ ã€ä¾‹ã€‘è€ƒè™‘å‡ ä½•åˆ†å¸ƒ $X\\sim g(p)$ çš„æœŸæœ›ã€‚å‡ ä½•åˆ†å¸ƒçš„åˆ†å¸ƒå¾‹ä¸º $$ P(X=k)=(1-p)^{k-1}p\\qquad k=1,2,\\cdots $$ å› æ­¤ $$ \\begin{align} E[x]\u0026amp;=\\sum_{k=1}^\\infty kP(X=k)=\\sum_{k=1}^\\infty k(1-p)^{k-1}p=p\\sum_{k=1}^\\infty k(1-p)^{k-1} \\end{align} $$ ä»¤ $$ F(p)=\\sum_{k=1}^\\infty (1-p)^k=\\frac{1-p}{p} $$ (æ³¨ï¼š$1-p\\in [0,1]$ åœ¨æ”¶æ•›åŠå¾„å†…ï¼Œå› æ­¤ç­‰å¼æˆç«‹ï¼Œåç»­çš„æ±‚å¯¼å’Œæ±‚å’Œå¯ä»¥äº¤æ¢ã€‚)\nåˆ™ $$ \\frac{d}{dp}F(p)=-\\sum_{k=1}^\\infty k(1-p)^{k-1} $$ æ‰€ä»¥ $$ E[x]=-pF\u0026rsquo;(p)=-p\\cdot \\left(\\frac{1-p}{p}\\right)\u0026rsquo;=-p\\cdot -\\frac{1}{p^2}=\\frac{1}{p} $$ ã€ä¾‹ã€‘ (åœ£å½¼å¾—å ¡æ‚–è®º) è¿ç»­æ‰”ä¸€æšå‡åŒ€ç¡¬å¸ï¼Œå½“å‡ºç°åé¢æ—¶åœæ­¢ã€‚è‹¥æ­¤å‰å‡ºç°çš„æ­£é¢æ¬¡æ•°ä¸º $k$ æ¬¡ï¼Œåˆ™æ”¶ç›Šä¸º $2^k$ï¼Œæ±‚è¯¥æ¸¸æˆæ”¶ç›Šçš„æœŸæœ›ã€‚\nè§£ï¼šè®¾æ”¶ç›Šä¸º $X$ï¼Œåˆ™ $P(X=2^k)=\\frac{1}{2^{k+1}},k=0,1,\\cdots$ $$ E[x]=\\sum_{k=0}^\\infty x_kP(X=x_k)=\\sum_{k=0}^\\infty 2^k\\frac{1}{2^{k+1}}=\\sum_{k=0}^\\infty \\frac{1}{2}=+\\infty $$ å› æ­¤æœŸæœ›ä¸å­˜åœ¨ã€‚\nè¿™æ˜¯ä¸€ä¸ªæœŸæœ›ä¸å­˜åœ¨çš„ä¾‹å­ã€‚æœ‰å…¶ä»–è§’åº¦å¯ä»¥ç ”ç©¶å¦‚ä½•å®šä»·å¯ä»¥ä½¿è¯¥æ¸¸æˆå…¬å¹³ã€‚ä¸€ä¸ªåˆç†çš„å®šä»·æ˜¯æ”¯ä»˜ $n\\log_2 n$ ç© $n$ æ¬¡ã€‚\nExpectation of Continuous Random Variables $\\fbox{Definition 13.2}$ è®¾è¿ç»­å‹éšæœºå˜é‡ $X$ çš„å¯†åº¦ä¸º $p(x)$ï¼Œè‹¥ç§¯åˆ† $\\int_{-\\infty}^{+\\infty}|x|p(x)dx\u0026lt;+\\infty$ï¼Œåˆ™ç§° $$ E[x]\\triangleq \\int_{-\\infty}^{+\\infty}xp(x)dx $$ ä¸º $X$ çš„æœŸæœ›ã€‚\næ³¨ï¼šè‹¥å¯¹ $\\mathbb R$ å–å¾ˆå¯†çš„åˆ’åˆ† $$ \\begin{align} \u0026amp;0=x_0\u0026lt;x_1\u0026lt;\\cdots \u0026lt;x_n\u0026lt;\\cdots\u0026lt;+\\infty\\\\ \u0026amp;0=y_0\u0026gt;y_1\u0026gt;\\cdots \u0026gt;y_n\u0026gt;\\cdots\u0026gt;-\\infty \\end{align} $$ æŠŠ $X$ è¿‘ä¼¼çœ‹æˆâ€éšæœºå˜é‡â€œ $\\tilde{X}$ï¼Œæ»¡è¶³ $$ \\begin{align} \\tilde P(\\tilde X=x_k)\u0026amp;=p(x_k)(x_{k+1}-x_k),k\\geq 0\\\\ \\tilde P(\\tilde X=y_k)\u0026amp;=p(y_k)(y_{k-1}-y_k),k\\geq 1 \\end{align} $$ åˆ™ $$ \\tilde E[\\tilde X]=\\sum_{k=0}^\\infty x_kp(x_k)(x_{k+1}-x_k)+\\sum_{k=1}^\\infty y_kp(y_k)(y_{k-1}-y_k) $$ ä¸º $E[x]$ çš„æ¸è¿›å’Œå¼ã€‚\nã€ä¾‹ã€‘è€ƒè™‘æŒ‡æ•°åˆ†å¸ƒ $X\\sim E(\\lambda)$ çš„æœŸæœ›ã€‚æŒ‡æ•°åˆ†å¸ƒçš„å¯†åº¦ä¸º $$ p(x)=\\begin{cases}\\lambda e^{-\\lambda x}\u0026amp;,x\\geq 0\\\\0\u0026amp;,x\u0026lt;0\\end{cases} $$ å› æ­¤\n$$ \\begin{align} E[x]\u0026amp;=\\int_{-\\infty}^{+\\infty}xp(x)dx=\\int_0^{+\\infty}x\\cdot \\lambda e^{-\\lambda x}dx=-\\int_0^{+\\infty}xe^{-\\lambda x}d(-\\lambda x)=-\\int_{0}^{+\\infty}xd(e^{-\\lambda x})\\\\ \u0026amp;=\\left .-xe^{-\\lambda x}\\right|_{0}^{\\infty}+\\int_0^{+\\infty}e^{-\\lambda x}dx=-\\frac{1}{\\lambda}\\int_0^{+\\infty}e^{-\\lambda x}d(-\\lambda x)=\\left.-\\frac{e^{-\\lambda x}}{\\lambda}\\right|_0^{+\\infty}\\\\ \u0026amp;=\\frac{1}{\\lambda} \\end{align} $$\nã€ä¾‹ã€‘è€ƒè™‘æ­£æ€åˆ†å¸ƒ $X\\sim N(\\mu,\\sigma^2)$ çš„æœŸæœ›ã€‚æ­£æ€åˆ†å¸ƒçš„å¯†åº¦ä¸º $$ p(x)-\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}} $$ å› æ­¤ $$ \\begin{align} E[x]\u0026amp;=\\int_{-\\infty}^{+\\infty}xp(x)dx=\\int_{-\\infty}^{+\\infty}x\\cdot \\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}dx\\\\ \u0026amp;\\overset{y=x-\\mu}{=}\\int_{-\\infty}^{+\\infty}(y+\\mu)\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{y^2}{2\\sigma^2}}dy\\\\ \u0026amp;=\\frac{1}{\\sqrt{2\\pi}\\sigma}\\int_{-\\infty}^{+\\infty}ye^{-\\frac{y^2}{2\\sigma^2}}dy+\\mu\\cdot \\frac{1}{\\sqrt{2\\pi}\\sigma}\\int_{-\\infty}^{+\\infty}e^{-\\frac{y^2}{2\\sigma^2}}dy \\end{align} $$ ç¬¬ä¸€é¡¹æ˜¯å¥‡å‡½æ•°åœ¨å¯¹ç§°åŒºåŸŸä¸Šçš„ç§¯åˆ†ï¼Œä¸º 0ã€‚ç¬¬äºŒé¡¹é™¤äº† $\\mu$ åé¢çš„éƒ¨åˆ†æ­£å¥½æ˜¯æ­£æ€åˆ†å¸ƒå…¨åŒºåŸŸä¸Šçš„ $p(x$) çš„ç§¯åˆ†ï¼Œä¸º 1ï¼Œå› æ­¤ $E[x]=\\mu$ã€‚\nã€ä¾‹ã€‘ è¿ç»­å‹éšæœºå˜é‡çš„æœŸæœ›ä¹Ÿå¯èƒ½ä¸å­˜åœ¨ã€‚è€ƒè™‘æŸ¯è¥¿åˆ†å¸ƒ $X$ï¼Œ$p(x)=\\frac{1}{\\pi(1+x^2)}$ï¼Œæ±‚å…¶æœŸæœ›ã€‚\nè§£ï¼š $$ \\begin{align} \\int_{-\\infty}^{+\\infty}|x|p(x)dx\u0026amp;=\\int_{-\\infty}^{+\\infty}\\frac{|x|dx}{\\pi(1+x^2)}=2\\int_0^{+\\infty}\\frac{xdx}{\\pi(1+x^2)}\\\\ \u0026amp;=\\frac{1}{\\pi}\\int_0^{+\\infty}\\frac{d(1+x^2)}{1+x^2}=\\left.\\frac{1}{\\pi}\\ln (1+x^2)\\right|_{0}^{+\\infty}=+\\infty \\end{align} $$ å› æ­¤æœŸæœ›ä¸å­˜åœ¨ã€‚\næ³¨ï¼šå¾®å¦™çš„ä¸€ç‚¹æ˜¯ï¼šæŸ¯è¥¿åˆ†å¸ƒçš„å¯†åº¦å‡½æ•°æ˜¯å…³äº $y$ è½´å¯¹ç§°çš„ï¼Œä½†è¿™å¹¶ä¸èƒ½è¯´æ˜æœŸæœ›å­˜åœ¨ä¸”ç­‰äº 0ã€‚\nExpectation of Random Variable Functions è®¾ $X$ çš„åˆ†å¸ƒå·²çŸ¥ï¼Œ$Y=g(X)$ï¼Œå¯é€šè¿‡ä¸‹é¢çš„å®šç†æ±‚ $E[Y]$ è€Œä¸å¿…å…ˆæ±‚å‡º $Y$ çš„åˆ†å¸ƒå†æ±‚æœŸæœ›ï¼š\n$\\fbox{Theorem 13.3}$ è‹¥ $X$ ä¸ºç¦»æ•£éšæœºå˜é‡ï¼Œåˆ†å¸ƒå¾‹ä¸º $P(X=x_k)=p_k,k=1,2,\\cdots$ï¼Œè‹¥ $\\sum_{k=1}^\\infty |g(x_k)|p_k\u0026lt;+\\infty$ï¼Œåˆ™ $$ E[Y]=E[g(x)]=\\sum_{k=1}^{\\infty} g(x_k)p_k $$ è‹¥ $X$ ä¸ºè¿ç»­å‹éšæœºå˜é‡ï¼Œå¯†åº¦ä¸º $p(x)$ï¼Œä¸”æœŸæœ›å­˜åœ¨ï¼Œåˆ™ $$ E[Y]=E[g(X)]=\\int_{-\\infty}^{+\\infty}g(x)p(x)dx $$\nè¯æ˜ï¼šè¿™é‡Œä»…è®¨è®ºç¦»æ•£æƒ…å½¢çš„è¯æ˜ã€‚è®¾ $Y=g(X)$ çš„å–å€¼ä¸º $y_1,y_2,\\cdots$ï¼Œ$Y$ æ˜¾ç„¶ä¹Ÿæ˜¯ç¦»æ•£å‹éšæœºå˜é‡ã€‚è®° $A_n={Xçš„å–å€¼}\\cap {x|g(x)=y_n}={x_n^1,x_n^2,\\cdots}$ï¼Œåˆ™ $A$ æ„æˆäº†å…¨ç©ºé—´ $\\Omega$ çš„ä¸€ä¸ªåˆ’åˆ†ã€‚ $$ \\begin{align} E[Y]\u0026amp;=\\sum_{n=1}^\\infty y_nP(X\\in A_n)=\\sum_{n=1}^\\infty y_n\\sum_{m=1}^\\infty P(X=x_n^m)\\\\ \u0026amp;=\\sum_{n=1}^\\infty \\sum_{m=1}^\\infty y_nP(X=x_n^m)=\\sum_{n=1}^\\infty\\sum_{m=1}^\\infty g(x_n^m)P(X=x_n^m)\\\\ \u0026amp;=\\sum_{n=1}^\\infty \\sum_{x\\in A_n}g(x)P(X=x)\\\\ \u0026amp;=\\sum_{k=1}^\\infty g(x_k)P(X=x_k)\\qquad \\blacksquare \\end{align} $$\nå¯¹äºäºŒç»´éšæœºå˜é‡å‡½æ•°æˆ‘ä»¬ä¹Ÿæœ‰ç±»ä¼¼çš„ç»“è®ºï¼š\n$\\fbox{Theorem 13.4}$ è®¾ $(X,Y)$ ä¸ºäºŒç»´éšæœºå˜é‡ï¼Œ$Z=g(X,Y)$ã€‚\n(1) ç¦»æ•£æƒ…å½¢ï¼š$(X,Y)$ æœ‰åˆ†å¸ƒå¾‹ $P(X=x_i,Y=y_j)=p_{i,j}$ã€‚è‹¥æœŸæœ›å­˜åœ¨ï¼Œé‚£ä¹ˆ $$ E[Z]=E[g(X,Y)]=\\sum_{i=1}^\\infty\\sum_{j=1}^\\infty g(x_i,y_j)p_{i,j} $$ (2) è¿ç»­æƒ…å½¢ï¼š$(X,Y)$ çš„å¯†åº¦å‡½æ•°ä¸º $p(x,y)$ï¼Œè‹¥æœŸæœ›å­˜åœ¨ï¼Œåˆ™ $$ E[Z]=E[g(X,Y)]=\\int_{-\\infty}^{+\\infty}\\int_{-\\infty}^{+\\infty}g(x,y)p(x,y)dxdy $$ ã€ä¾‹é¢˜ã€‘ (ä¹ é¢˜ 4.5) å•†å“å‡ºå£éœ€æ±‚ $X\\sim U[2000,4000]$ï¼Œå”®å‡º 1 å•ä½å•†å“å¯ä»¥è·å¾— 3 ä¸‡å…ƒæ”¶ç›Šï¼Œä¸èƒ½å”®å‡ºè¦å€’è´´ 1 ä¸‡å…ƒã€‚é—®åº”å‡ºå£å¤šå°‘å¨æ‰èƒ½å¾—åˆ°æœ€å¤§æ”¶ç›Šã€‚\nè§£ï¼šè®¾å‡ºå£é‡ä¸º $y$ï¼Œæ˜¾ç„¶æœ‰ $2000\\leq y\\leq 4000$ã€‚ä»¤æ”¶ç›Šä¸º $Z$ï¼š $$ Z=g(X)=\\begin{cases}3y\u0026amp;,X\u0026gt;y\\\\3X-(y-X)\u0026amp;,X\\leq y\\end{cases} $$ è€ƒè™‘ $Z$ çš„æœŸæœ›ï¼š $$ \\begin{align} E[Z]\u0026amp;=E[g(X)]=\\int_{-\\infty}^{+\\infty}g(x)p(x)dx=\\int_{2000}^{4000}g(x)\\frac{1}{2000}dx\\\\ \u0026amp;=\\frac{1}{2000}\\left(\\int_{2000}^y(4x-y)dx+\\int_y^{4000}3ydx\\right)\\\\ \u0026amp;=\\frac{1}{1000}(-y^2+7000y-4\\cdot 10^6) \\end{align} $$ å½“ $y=3500$ æ—¶æœŸæœ›æ”¶ç›Šæœ€å¤§ã€‚\nProperties of Expectation è‹¥éšæœºå˜é‡ $X\\equiv a$ï¼Œåˆ™ $E[x]=a$ã€‚\nå¯¹äºä»»æ„å¸¸æ•° $a,b$ï¼Œæœ‰ $E[aX+bY]=aE[X]+bE[Y]$ã€‚\nè¯æ˜ï¼šè¿™é‡Œçš„è¯æ˜è€ƒè™‘ $X,Y$ æ˜¯ç¦»æ•£å‹éšæœºå˜é‡çš„æƒ…å†µï¼š\nè®¾ $X,Y$ çš„åˆ†å¸ƒå¾‹ä¸º $P(X=x_i,Y=y_j)=p_{ij}$ï¼Œé‚£ä¹ˆ $$ \\begin{align} E[aX+bY]\u0026amp;=\\sum_{i=1}^\\infty\\sum_{j=1}^\\infty(ax_i+by_j)p_{ij}\\\\ \u0026amp;=a\\sum_{i=1}^\\infty x_i\\sum_{j=1}^\\infty p_{ij}+b\\sum_{j=1}^\\infty y_j\\sum_{i=1}^\\infty p_{ij}\\\\ \u0026amp;=a\\sum_{i=1}^\\infty x_ip_{i\\cdot}+b\\sum_{j=1}^\\infty y_jp_{\\cdot j}\\\\ \u0026amp;=aE[X]+bE[Y] \\end{align} $$\nè‹¥ $X,Y$ ç‹¬ç«‹ï¼Œåˆ™ $E[XY]=E[X]E[Y]$ã€‚\nè¯æ˜ï¼šè¿™é‡Œçš„è¯æ˜è€ƒè™‘ $X,Y$ æ˜¯ç¦»æ•£å‹éšæœºå˜é‡çš„æƒ…å†µï¼š\nè®¾ $X,Y$ çš„åˆ†å¸ƒå¾‹ä¸º $P(X=x_i,Y=y_j)=p_{ij}$ï¼Œå› ä¸º $X,Y$ ç›¸äº’ç‹¬ç«‹ï¼Œæ‰€ä»¥ $p_{ij}=p_{i\\cdot}\\cdot p_{\\cdot j}$ã€‚é‚£ä¹ˆ $$ \\begin{align} E(XY)\u0026amp;=\\sum_{i=1}^\\infty\\sum_{j=1}^\\infty x_iy_jp_{ij}\\\\ \u0026amp;=\\sum_{i=1}^\\infty\\sum_{j=1}^\\infty x_iy_jp_{i\\cdot }p_{\\cdot j}\\\\ \u0026amp;=\\left(\\sum_{i=1}^\\infty x_ip_{i\\cdot }\\right)\\left(\\sum_{j=1}^\\infty y_jp_{\\cdot j}\\right)\\\\ \u0026amp;=E[X]E[Y] \\end{align} $$\nåˆ©ç”¨æœŸæœ›çš„çº¿æ€§æ€§ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆæ–¹ä¾¿åœ°è§£å†³ä¸€äº›é—®é¢˜ï¼Œæ¯”å¦‚è€ƒè™‘ $X\\sim B(n,p)$ çš„æœŸæœ›ï¼Œä»¤ $x_i$ è¡¨ç¤ºç¬¬ $i$ æ¬¡å®éªŒæ˜¯å¦æˆåŠŸçš„ç¤ºæ€§éšæœºå˜é‡ i.e. $x_i=\\begin{cases}1\u0026amp;,ç¬¬iæ¬¡å®éªŒæˆåŠŸ\\\\0\u0026amp;,otherwise\\end{cases}$ï¼Œå®¹æ˜“å‘ç° $E(x_i)=P(x_i=1)=p$ã€‚é‚£ä¹ˆ $$ E[X]=E\\left[\\sum_{i=1}^nx_i\\right]=\\sum_{i=1}^nE[x_i]=\\sum_{i=1}^nP(x_i=1)=np. $$ å†ä¸¾ä¸€ä¾‹ï¼Œè®¾ $X$ æœä»è¶…å‡ ä½•åˆ†å¸ƒï¼Œè€ƒè™‘ $X$ çš„æœŸæœ›ã€‚ç±»ä¼¼åœ°ï¼Œæˆ‘ä»¬ä»¤ç¤ºæ€§éšæœºå˜é‡ $x_i$ åˆ»ç”»ç¬¬ $i$ ä¸ªæ¬¡å“è¢«æŠ½ä¸­çš„æƒ…å†µï¼Œæ˜¾ç„¶æœ‰ $P(x_i=1)=\\frac{\\binom{N-1}{n-1}}{\\binom{N}{n}}=\\frac{n}{N}$ (åˆ†å­çš„æ„ä¹‰æ˜¯ï¼šä¿è¯è¯¥æ¬¡å“è¢«æŠ½ä¸­ï¼Œå‰©ä¸‹çš„ $n-1$ ä¸ªç‰©å“éšä¾¿æŠ½)ï¼Œé‚£ä¹ˆ $$ E[x]=E\\left[\\sum_{i=1}^Mx_i\\right]=\\sum_{i=1}^ME[x_i]=\\sum_{i=1}^M\\frac{n}{N}=\\frac{nM}{N}. $$ ã€ä¾‹é¢˜ã€‘ (ä¹ é¢˜ 4.8) $n$ ä¸ªäººæ— æ”¾å›æ‹¿ $n$ ä¸ªå¸½å­ï¼Œæ±‚æ‹¿åˆ°è‡ªå·±çš„å¸½å­çš„äººæ•°çš„æœŸæœ›ã€‚\nè§£ï¼šä»¤ $x_i$ æ˜¯åˆ»ç”»ç¬¬ $i$ ä¸ªäººæ˜¯å¦æ‹¿åˆ°å¸½å­çš„ç¤ºæ€§éšæœºå˜é‡ï¼Œé‚£ä¹ˆ $$ E[X]=E\\left[\\sum_{i=1}^nx_i\\right]=\\sum_{i=1}^nE[x_i]=\\sum_{i=1}^n\\frac{(n-1)!}{n!}=1. $$\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"03e661b54a38ecaf3b015fc4e4532cb7","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-probability/lec13/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-probability/lec13/","section":"notes","summary":"Expectation of Discrete Random Variables ç¦»æ•£å‹éšæœºå˜é‡çš„æ•°å­¦æœŸæœ›ç±»ä¼¼äºâ€œåŠ æƒå¹³å‡æ•°â€ï¼Œä½†æˆ‘ä»¬è¦å°†é¢‘ç‡æ¢æˆä¸¥æ ¼çš„æ¦‚ç‡ã€‚\n$\\fbox{Definition 13.1}$ è®¾ç¦»æ•£å‹éšæœºå˜é‡ $X$ çš„åˆ†å¸ƒå¾‹ä¸º $P(X=x_i)=p_i,i=1,2,\\cdots$ã€‚è‹¥çº§æ•° $\\sum_{i=1}^\\infty |x_i|p_i$ æ”¶æ•›ï¼Œåˆ™ç§° $$ E[x]\\triangleq \\sum_{i=1}^\\infty x_ip_i $$ ä¸º $X$ çš„æ•°å­¦æœŸæœ›ï¼Œç®€ç§°å‡å€¼æˆ–æœŸæœ›ã€‚\næ³¨ï¼š(1) åˆ†å¸ƒå”¯ä¸€å†³å®šäº†æœŸæœ›ã€‚\n(2) åœ¨å®šä¹‰ä¸­ï¼Œæˆ‘ä»¬è¦æ±‚çº§æ•° $\\sum_{i=1}^\\infty x_ip_i$ ç»å¯¹æ”¶æ•›ï¼Œè¿™æ˜¯ä¸ºäº†ä¿è¯é‡æ’ $x_ip_i$ çš„é¡ºåºä¸å½±å“æœŸæœ›çš„å€¼ (é‡‡æ ·é¡ºåºä¸åº”å½±å“å‡å€¼)ã€‚","tags":null,"title":"Lecture 13: Mathematical Expectation","type":"docs"},{"authors":null,"categories":null,"content":"æˆ‘ä»¬å¸Œæœ›è¡¡é‡ä¸€ä¸ªéšæœºå˜é‡æ¯ä¸ªå–å€¼å’Œå¹³å‡å€¼çš„å·®å¼‚ï¼Œå¹¶ä¸”å¸Œæœ›è¿™ä¸ªå€¼æ˜¯æ­£æ•°ã€‚å› æ­¤æˆ‘ä»¬å¼•å…¥æ–¹å·®çš„æ¦‚å¿µã€‚\n$\\fbox{Definition 14.1}$ è®¾ $X$ æ˜¯ä¸€ä¸ªéšæœºå˜é‡ã€‚è‹¥ $E[|X|^2]$ å­˜åœ¨ï¼Œåˆ™ç§° $$ D(X)\\triangleq E[(X-E[x])^2] $$ ä¸º $X$ çš„æ–¹å·®ï¼ŒåŒæ—¶ç§° $\\sigma(X)\\triangleq \\sqrt{D(X)}$ ä¸º $X$ çš„å‡æ–¹å·®/æ ‡å‡†å·®ã€‚\næ³¨ï¼š(1) $(X-E[X])^2$ çš„æ•°å­¦æ€§è´¨å¥½äº $|X-E[X]|$ï¼Œæ¯”å¦‚å¯å¯¼æ€§ï¼Œä»¥åŠä»£æ•°è¿ç®—æ—¶çš„æ–¹ä¾¿æ€§ã€‚\n(2) $E[X^2]\u0026lt;+\\infty$ å¯ä»¥æ¨å‡º $E[X]\u0026lt;+\\infty$ (åè¿‡æ¥ä¸æˆç«‹)ã€‚\n(3) å¯¹äºç¦»æ•£å‹éšæœºå˜é‡ï¼Œè®¾ $P(X=x_i)=p_i$ï¼Œåˆ™ $$ D(X)=\\sum_{k=1}^\\infty(x_k-E[X])^2p_k $$ å¯¹äºè¿ç»­å‹éšæœºå˜é‡ï¼Œè®¾å¯†åº¦å‡½æ•°ä¸º $p(x)$ï¼Œåˆ™ $$ D(X)=\\int_{-\\infty}^{+\\infty}(x-E[X])^2p(x)dx $$ (4) æ–¹å·®å…¬å¼è¿˜æœ‰å¦å¤–ä¸€ç§å½¢å¼ï¼š $$ \\begin{align} D(X)\u0026amp;=E[(X-E[X])^2]\\\\ \u0026amp;=E[X^2-2E[X]X+E[X]^2]\\\\ \u0026amp;=E[X^2]-E[2E[X]X]+E[E[X]^2]\\\\ \u0026amp;=E[X^2]-2E[X]^2+E[X]^2\\\\ \u0026amp;=E[X^2]-E[X]^2 \\end{align} $$ ä»è¿™ä¸ªå…¬å¼ä¸­æˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼š$D(X)\\leq E[X^2]$ã€‚\nã€ä¾‹ã€‘è€ƒè™‘ $X\\sim B(n,p)$ çš„æ–¹å·®ã€‚$X$ çš„åˆ†å¸ƒå¾‹ä¸º $P(X=k)=\\binom{n}{k}p^k(1-p)^{n-k}$ã€‚æˆ‘ä»¬å·²çŸ¥ $E[X]=np$ï¼Œå› æ­¤åªéœ€è¦æ±‚ $E[X^2]$ã€‚ $$ \\begin{align} E[X^2]\u0026amp;=\\sum_{k=1}^nk^2\\frac{n!}{k!(n-k)!}p^k(1-p)^{n-k}\\\\ \u0026amp;=\\sum_{k=1}^nk\\frac{n!}{(k-1)!(n-k)!}p^k(1-p)^{n-k}\\\\ \u0026amp;=\\sum_{k=1}^n(k-1)\\frac{n!}{(k-1)!(n-k!)}p^k(1-p)^{n-k}+\\sum_{k=1}^n\\frac{n!}{(k-1)!(n-k)!}p^k(1-p)^{n-k}\\\\ \u0026amp;=n(n-1)p^2\\sum_{k=2}^n\\frac{(n-2)!}{(k-2)!(n-k)!}p^{k-2}(1-p)^{n-k}+np\\sum_{k=1}^n\\frac{(n-1)!}{(k-1)!(n-k)!}p^{k-1}(1-p)^{n-k}\\\\ \u0026amp;=n(n-1)p^2[1+(1-p)]^{n-2}+np[1+(1-p)]^{n-1}\\\\ \u0026amp;=n(n-1)p^2+np \\end{align} $$ å› æ­¤ $D(X)=E[X^2]-E[X]^2=np-np^2=np(1-p)$ã€‚\nã€ä¾‹ã€‘è€ƒè™‘ $X\\sim p(\\lambda)$ çš„æ³Šæ¾åˆ†å¸ƒçš„æ–¹å·®ã€‚$X$ çš„åˆ†å¸ƒå¾‹ä¸º $P(X=k)=\\frac{\\lambda^k}{k!}e^{-\\lambda}$ï¼Œæˆ‘ä»¬å·²çŸ¥ $E[X]=\\lambda$ï¼Œå› æ­¤åªéœ€è¦æ±‚ $E[X^2]$ã€‚ $$ \\begin{align} E[X^2]\u0026amp;=\\sum_{k=1}^\\infty k^2\\frac{\\lambda^k}{k!}e^{-\\lambda}=\\sum_{k=1}^\\infty k\\frac{\\lambda^k}{(k-1)!}e^{-\\lambda}\\\\ \u0026amp;=\\sum_{k=1}^\\infty(k-1)\\frac{\\lambda^k}{(k-1)!}e^{-\\lambda}+\\sum_{k=1}^\\infty\\frac{\\lambda^k}{(k-1)!}e^{-\\lambda}\\\\ \u0026amp;=\\lambda^2\\sum_{k=2}^\\infty\\frac{\\lambda^{k-2}}{(k-2)!}e^{-\\lambda}+\\lambda\\sum_{k=1}^\\infty\\frac{\\lambda^{k-1}}{(k-1)!}e^{-\\lambda}\\\\ \u0026amp;=\\lambda^2+\\lambda \\end{align} $$ å› æ­¤ $D(X)=E[X^2]-E[X]^2=\\lambda$ã€‚\nã€ä¾‹ã€‘ è€ƒè™‘æŒ‡æ•°åˆ†å¸ƒ $X\\sim E(\\lambda)$ çš„æ–¹å·®ã€‚$X$ çš„å¯†åº¦å‡½æ•°ä¸º $p(x)=\\begin{cases}\\lambda e^{-\\lambda x}\u0026amp;,x\u0026gt;0\\\\0\u0026amp;,x\\leq 0\\end{cases}$ã€‚æˆ‘ä»¬å·²çŸ¥ $E[X]=\\frac{1}{\\lambda}$ï¼Œå› æ­¤åªéœ€è¦æ±‚ $E[X^2]$ã€‚ $$ \\begin{align} E[X^2]\u0026amp;=\\int_{-\\infty}^{+\\infty}x^2p(x)dx=\\int_0^{+\\infty}x^2\\lambda e^{-\\lambda x}dx=-\\int_0^{+\\infty}x^2e^{-\\lambda x}d(-\\lambda x)\\\\ \u0026amp;=-\\int_0^{+\\infty}x^2d(e^{-\\lambda x})=\\left.x^2e^{-\\lambda x}\\right|_0^{+\\infty}+2\\int_0^{+\\infty}xe^{-\\lambda x}dx\\\\ \u0026amp;=\\frac{2}{\\lambda}\\int_0^{+\\infty}x\\lambda e^{-\\lambda x}dx\\\\ \u0026amp;=\\frac{2}{\\lambda}E[X]=\\frac{2}{\\lambda^2} \\end{align} $$ å› æ­¤ $D(X)=E[X^2]-E[X]^2=\\frac{1}{\\lambda^2}$ã€‚\nã€ä¾‹ã€‘è€ƒè™‘æ­£æ€åˆ†å¸ƒ $X\\sim N(\\mu, \\sigma^2)$ çš„æ–¹å·®ã€‚$X$ çš„å¯†åº¦å‡½æ•°ä¸º $p(x)=\\frac{1}{\\sqrt {2\\pi }\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}$ã€‚æˆ‘ä»¬å®¹æ˜“å‘ç°è¿™é‡Œç›´æ¥æ–¹å·®çš„åŸå§‹å®šä¹‰å¼è®¡ç®—ä¼šæ›´åŠ æ–¹ä¾¿ï¼š $$ \\begin{align} D(X)\u0026amp;=E[(X-E[X])^2]=\\frac{1}{\\sqrt{2\\pi}\\sigma}\\int_{-\\infty}^{+\\infty}(x-\\mu)^2e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}dx\\\\ \u0026amp;\\overset{y=\\frac{x-\\mu}{\\sigma}}{=}\\frac{\\sigma^2}{\\sqrt{2\\pi}}\\int_{-\\infty}^{+\\infty}y^2e^{-\\frac{y^2}{2}}dy\\\\ \u0026amp;=-\\frac{\\sigma^2}{\\sqrt{2\\pi}}\\int_{-\\infty}^{+\\infty}yd\\left(e^{-\\frac{y^2}{2}}\\right)\\\\ \u0026amp;=\\left.-\\frac{\\sigma^2}{\\sqrt{2\\pi}}ye^{-\\frac{y^2}{2}}\\right|_{-\\infty}^{+\\infty}+\\sigma^2\\cdot \\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{+\\infty}e^{-\\frac{y^2}{2}}dy\\\\ \u0026amp;=0+\\sigma^2\\cdot (æ ‡å‡†æ­£æ€åˆ†å¸ƒåœ¨ \\mathbb R ä¸Šçš„å¯†åº¦å‡½æ•°ç§¯åˆ†)\\\\ \u0026amp;=\\sigma^2 \\end{align} $$ æ–¹å·®çš„æ€§è´¨ï¼š\nè‹¥ $X\\equiv a$ï¼Œåˆ™ $D(X)=E[(X-a)^2]=0$ ã€‚\nè‹¥ $D(X)$ å­˜åœ¨ï¼Œå¯¹äºä»»æ„ $a,b\\in \\mathbb R$ï¼Œ$D(aX+b)=a^2D(X)$ã€‚\nè¯æ˜ï¼š $$ \\begin{align} D(aX+b)\u0026amp;=E[(aX+b-E[aX+b])^2]\\\\ \u0026amp;=E[(aX+b-aE[X]-b)^2]\\\\ \u0026amp;=E[(a(X-E[X]))^2]\\\\ \u0026amp;=a^2D(X) \\end{align} $$\nç›´è§‚æ¥çœ‹è¿™ä¸ªå…¬å¼ä¹Ÿå®¹æ˜“ç†è§£ï¼šå…¨å±€åŠ ä¸Š $b$ ä¸å½±å“å¯¹æœŸæœ›çš„åç¦»ï¼›å…¨å±€ä¹˜ $a$ åœ¨ L2 åå·®ä¸‹æœ€ç»ˆåæ˜ ä¸º $a^2$ã€‚\nåœ¨è¯¥æ€§è´¨çš„æ”¯æ’‘ä¸‹ï¼Œå¯¹äºéšæœºå˜é‡ $X$ï¼Œè‹¥ $D(X)$ å­˜åœ¨ï¼Œè€ƒè™‘ $Z=\\frac{X-E[X]}{\\sqrt{D(X)}}$ï¼Œåˆ™ $E[Z]=0$ï¼Œ$D(Z)=\\left(\\frac{1}{\\sqrt{D(X)}}\\right)^2D(X)=1$ï¼Œå› æ­¤ç§° $Z$ ä¸º $X$ çš„æ ‡å‡†åŒ–ã€‚(æ ‡å‡†æ­£æ€åˆ†å¸ƒå’Œæ­£æ€åˆ†å¸ƒä¹‹é—´çš„è½¬åŒ–æ˜¯è¯¥å…¬å¼çš„ä¸€ä¸ªç‰¹ä¾‹)ã€‚\nè®¾ $X,Y$ ä¸ºéšæœºå˜é‡ï¼Œåˆ™ $D(X\\pm Y)=D(X)+D(Y)\\pm 2E[(X-E )(Y-E(Y))]$ã€‚\nè¯æ˜ï¼šè¿™é‡Œåªè¯ + çš„æƒ…å†µï¼Œ- çš„æƒ…å†µåŒç†ã€‚ $$ \\begin{align} D(X+Y)\u0026amp;=E[(X+Y-E[X+Y])^2]=E[((X-E[X])+(Y-E[Y]))^2]\\\\ \u0026amp;=E[(X-E[X])^2]+E[(Y-E[Y])^2]+2E[(X-E[X])(Y-E[Y])]\\\\ \u0026amp;=D(X)+D(Y)+2E[(X-E[X])(Y-E[Y])] \\end{align} $$\nç‰¹åˆ«åœ°ï¼Œè‹¥ $X,Y$ ç‹¬ç«‹ï¼Œåˆ™ $X-E[X], Y-E[Y]$ ä¹Ÿç‹¬ç«‹ï¼Œåˆ™ $$ E[(X-E[X])(Y-E[Y])]=E[X-E[X]]E[Y-E[Y]]=0 $$ ä»è€Œ $D(X\\pm Y)=D(X)+D(Y)$ (æ³¨æ„ç¬¦å·ï¼)ã€‚\nä¸Šè¿°ç»“è®ºå¯ä»¥æ¨å¹¿åˆ° $n$ ä¸ªéšæœºå˜é‡çš„æƒ…å½¢ï¼š $$ D\\left(\\sum_{i=1}^nx_i\\right)=\\sum_{i=1}^nD(x_i)-\\sum_{1\\leq i\u0026lt;j\\leq n}E[(x_i-E[x_i])(x_j-E[x_j])] $$ è‹¥è¿™äº›å˜é‡ä¸¤ä¸¤ç‹¬ç«‹ (æ³¨æ„ï¼Œè¯¥æ¡ä»¶æ¯” $n$ ä¸ªå˜é‡çš„ç‹¬ç«‹æ€§å¼±ï¼)ï¼Œåˆ™ $$ D\\left(\\sum_{i=1}^nx_i\\right)=\\sum_{i=1}^nD(x_i) $$\nå¯¹äºä»»æ„ $c\\in \\mathbb R$ï¼Œ$D(X)\\leq E[(X-c)^2]$ã€‚\nè¯æ˜ï¼š $$ \\begin{align} D(X)\u0026amp;=E[(X-E[X])^2]=E[(X-c+c-E[X])^2]\\\\ \u0026amp;=E[(X-c)^2]+2E[(X-c)(c-E[X])]+E[(c-E[X])^2]\\\\ \u0026amp;=E[(X-c)^2]+2(c-E[X])(E[X]-c)+(c-E[X])^2\\\\ \u0026amp;=E[(X-c)^2]-(c-E[X])^2\\\\ \u0026amp;\\leq E[(X-c)^2] \\end{align} $$\nåˆ©ç”¨æœŸæœ›çš„å¯æ‹†åˆ†æ€§ (æ€§è´¨ 3) æœ‰æ—¶èƒ½å¤§å¹…ç®€åŒ–è®¡ç®—è¿‡ç¨‹ï¼Œè¿™é‡Œä»¥äºŒé¡¹åˆ†å¸ƒ $X\\sim B(n,p)$ ä¸ºä¾‹ã€‚ä»¤ $x_i$ ä¸ºæè¿°ç¬¬ $i$ æ¬¡å®éªŒæ˜¯å¦æˆåŠŸçš„ç¤ºæ€§éšæœºå˜é‡ï¼Œæ˜¾ç„¶ $x_1,\\cdots, x_n$ ä¸¤ä¸¤ç‹¬ç«‹ã€‚é‚£ä¹ˆ $$ \\begin{align} D(X)\u0026amp;=D\\left(\\sum_{i=1}^nx_i\\right)=\\sum_{i=1}^nD(x_i)=nD(x_1)\\\\ \u0026amp;=nE[(x_1-E[x_1])^2]=n((1-p)^2p+(0-p)^2(1-p))\\\\ \u0026amp;=np(1-p) \\end{align} $$\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"699d77816fd43bef3682cbbd9c6eaabc","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-probability/lec14/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-probability/lec14/","section":"notes","summary":"æˆ‘ä»¬å¸Œæœ›è¡¡é‡ä¸€ä¸ªéšæœºå˜é‡æ¯ä¸ªå–å€¼å’Œå¹³å‡å€¼çš„å·®å¼‚ï¼Œå¹¶ä¸”å¸Œæœ›è¿™ä¸ªå€¼æ˜¯æ­£æ•°ã€‚å› æ­¤æˆ‘ä»¬å¼•å…¥æ–¹å·®çš„æ¦‚å¿µã€‚\n$\\fbox{Definition 14.1}$ è®¾ $X$ æ˜¯ä¸€ä¸ªéšæœºå˜é‡ã€‚è‹¥ $E[|X|^2]$ å­˜åœ¨ï¼Œåˆ™ç§° $$ D(X)\\triangleq E[(X-E[x])^2] $$ ä¸º $X$ çš„æ–¹å·®ï¼ŒåŒæ—¶ç§° $\\sigma(X)\\triangleq \\sqrt{D(X)}$ ä¸º $X$ çš„å‡æ–¹å·®/æ ‡å‡†å·®ã€‚\næ³¨ï¼š(1) $(X-E[X])^2$ çš„æ•°å­¦æ€§è´¨å¥½äº $|X-E[X]|$ï¼Œæ¯”å¦‚å¯å¯¼æ€§ï¼Œä»¥åŠä»£æ•°è¿ç®—æ—¶çš„æ–¹ä¾¿æ€§ã€‚\n(2) $E[X^2]\u0026lt;+\\infty$ å¯ä»¥æ¨å‡º $E[X]\u0026lt;+\\infty$ (åè¿‡æ¥ä¸æˆç«‹)ã€‚\n(3) å¯¹äºç¦»æ•£å‹éšæœºå˜é‡ï¼Œè®¾ $P(X=x_i)=p_i$ï¼Œåˆ™ $$ D(X)=\\sum_{k=1}^\\infty(x_k-E[X])^2p_k $$ å¯¹äºè¿ç»­å‹éšæœºå˜é‡ï¼Œè®¾å¯†åº¦å‡½æ•°ä¸º $p(x)$ï¼Œåˆ™ $$ D(X)=\\int_{-\\infty}^{+\\infty}(x-E[X])^2p(x)dx $$ (4) æ–¹å·®å…¬å¼è¿˜æœ‰å¦å¤–ä¸€ç§å½¢å¼ï¼š $$ \\begin{align} D(X)\u0026amp;=E[(X-E[X])^2]\\\\ \u0026amp;=E[X^2-2E[X]X+E[X]^2]\\\\ \u0026amp;=E[X^2]-E[2E[X]X]+E[E[X]^2]\\\\ \u0026amp;=E[X^2]-2E[X]^2+E[X]^2\\\\ \u0026amp;=E[X^2]-E[X]^2 \\end{align} $$ ä»è¿™ä¸ªå…¬å¼ä¸­æˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼š$D(X)\\leq E[X^2]$ã€‚","tags":null,"title":"Lecture 14: Variance","type":"docs"},{"authors":null,"categories":null,"content":"$\\fbox{Theorem 15.1}$ (Chebyshev) è®¾éšæœºå˜é‡ $X$ çš„æ–¹å·®å­˜åœ¨ï¼Œåˆ™æœ‰ $$ \\forall \\varepsilon\u0026gt;0,P(|X-E[X]|\u0026gt;\\varepsilon)\\leq \\frac{D(X)}{\\varepsilon^2} $$ è¯æ˜ï¼šè®¾ $X$ å­˜åœ¨å¯†åº¦å‡½æ•° $p(x)$ï¼Œåˆ™ $$ \\begin{align} P(|X-E[X]|\u0026gt;\\varepsilon)\u0026amp;=\\int_{{x:|X-E[X]|\u0026gt;\\varepsilon}}p(x)dx\\\\ \u0026amp;\\leq \\int_{{x:|X-E[X]|\u0026gt;\\varepsilon}}\\frac{|X-E[x]|^2}{\\varepsilon^2}p(x)dx\\\\ \u0026amp;\\leq \\frac{1}{\\varepsilon^2}\\int_{-\\infty}^{+\\infty}|X-E[X]|^2p(x)dx\\\\ \u0026amp;=\\frac{D(X)}{\\varepsilon^2}\\qquad \\blacksquare \\end{align} $$ æˆ‘ä»¬çš„è¯æ˜è¿‡ç¨‹ä¸­ä½¿ç”¨äº†ä¸¤æ¬¡çœ‹ä¸Šå»å¾ˆâ€œæ¾â€çš„æ”¾ç¼©ï¼Œä½†ä¸‹é¢çš„ä¾‹å­å¯ä»¥è¯´æ˜ï¼Œåœ¨å¯¹ $X$ æ²¡æœ‰ä»»ä½•é¢å¤–é™åˆ¶çš„æƒ…å†µä¸‹ï¼ŒChebyshev çš„ç»“æœå·²ç»æ˜¯æœ€ç´§çš„äº†ï¼š\nä¾‹ï¼šè®¾ $X$ çš„åˆ†å¸ƒå¾‹ä¸º $P(X=1)=P(X=-1)=\\frac{1}{2k^2}$ï¼Œ$P(X=0)=1-\\frac{1}{k^2}$ï¼Œæ˜¾ç„¶æœ‰ $E[X]=0$ã€‚é‚£ä¹ˆ $$ P(|X-E[x]|\\geq 1)=P(X=\\pm 1)=\\frac{1}{k^2}\\leq \\frac{D(X)}{\\varepsilon^2}=\\frac{1/k^2}{1^2}=\\frac{1}{k^2} $$ ã€ä¾‹é¢˜ã€‘ç”¨ Chebyshev ä¸ç­‰å¼è¯æ˜ï¼šå¦‚æœéšæœºå˜é‡ $X$ æ»¡è¶³ $D(X)=0$ï¼Œåˆ™ $P(X=E[X])=1$ã€‚\nè¯æ˜ï¼šä»¤ $A={w:|X(w)-E[X]|\u0026gt;0}$ï¼Œæˆ‘ä»¬è¦è¯æ˜çš„ç›®æ ‡æ˜¯ $P(A)=0$ã€‚\nä»¤ $A_n={w:|X(w)-E[X]|\u0026gt;\\frac{1}{n}}$ï¼Œé‚£ä¹ˆæ˜¾ç„¶æœ‰ $A=\\bigcup_{n=1}^\\infty A_n$ï¼Œä»è€Œ $$ P(A)=P(\\bigcup_{n=1}^\\infty A_n)\\leq \\sum_{n=1}^\\infty P(A_n)=\\sum_{n=1}^\\infty P(X-E[X]\u0026gt;\\frac{1}{n})\\leq \\sum_{n=1}^\\infty \\frac{1}{n^2}D(X)=0 $$ åˆ $P(A)\\geq 0$ï¼Œæ‰€ä»¥ $P(A)=0$ã€‚\nï¼ˆæ³¨ï¼šç¬¬ä¸€ä¸ªä¸ç­‰å·æ˜¯ union boundã€‚æ³¨æ„ $A_n$ ä¹‹é—´ä¸æ˜¯äº’ä¸ç›¸äº¤çš„ï¼Œæ‰€ä»¥ä¸èƒ½ç”¨â€œå¯åˆ—å¯åŠ æ€§â€ã€‚ï¼‰\nCovariance $\\fbox{Definition 15.2}$ $X,Y$ ä¸ºéšæœºå˜é‡ï¼Œ$E[X],E[Y],E[XY]$ å‡å­˜åœ¨ï¼Œåˆ™ $$ cov(X,Y)\\triangleq E[(X-E[X])(Y-E[Y])] $$ ä¸º $X$ å’Œ $Y$ çš„åæ–¹å·®ã€‚\næ³¨ï¼š(1) $cov(X,X)=D(X)$ã€‚\n(2) $D(X\\pm Y)=D(X)+D(Y)\\pm 2cov(X,Y)$ã€‚\nä¸€èˆ¬åœ°ï¼Œ $$ D(\\sum_{k=1}^nX_k)=\\sum_{k=1}^nD(X_k)+2\\sum_{1\\leq i\u0026lt;j\\leq n}cov(X_i,X_j). $$ (3) $cov(X,Y)=E[XY-XE[Y]-YE[X]+E[X]E[Y]]=E[XY]-E[X]E[Y]$ã€‚\n(4) $cov(X,Y)\u0026gt;0$ è¯´æ˜ $X$ å’Œ $Y$ æœ‰å¾ˆå¤§å€¾å‘åŒæ—¶å¤§äºæˆ–å°äºå„è‡ªçš„æœŸæœ›ï¼›$cov(X,Y)\u0026lt;0$ è¯´æ˜ $X$ å’Œ $Y$ æœ‰å¾ˆå¤§å€¾å‘ä¸€ä¸ªå¤§äºè‡ªèº«æœŸæœ›ï¼Œä¸€ä¸ªå°äºè‡ªèº«æœŸæœ›ã€‚\n(5) $cov(X,Y)$ ä¾èµ–äºå•ä½ã€‚æ¯”å¦‚å¦‚æœå°†ä¸¤è€…çš„å•ä½æœ¬æ¥æ˜¯ç±³ï¼Œå°†å®ƒä»¬æ”¹æˆæ¯«ç±³ï¼Œåæ–¹å·®çš„æ•°å€¼å°†ä¼šå˜å¤§å¾ˆå¤šã€‚å› æ­¤åæ–¹å·®ä¸æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„è¡¡é‡ç›¸å…³æ€§çš„å®¢è§‚æ•°å€¼ã€‚\nåæ–¹å·®çš„æ€§è´¨ï¼š\n$cov(X,Y)=cov(Y,X)$ã€‚\nå¯¹äºä»»æ„ $a,b,c,d\\in \\mathbb R$ï¼Œ$cov(aX+c,bY+d)=abcov(X,Y)$ã€‚\nè¯æ˜ï¼š $$ \\begin{align} cov(aX+c,bY+d)\u0026amp;=E[(aX+c)(bY+d)]-E[aX+c]E[bY+d]\\\\ \u0026amp;=E[abXY+adX+bcY+cd]-(aE[X]+c)(bE[Y]+d)\\\\ \u0026amp;=abE[XY]-abE[X]E[Y]\\\\ \u0026amp;=abcov(X,Y) \\end{align} $$\n$cov(X_1+X_2,Y)=cov(X_1,Y)+cov(X_2,Y)$ã€‚\nè¯æ˜ï¼š $$ \\begin{align} cov(X_1+X_2,Y)\u0026amp;=E[(X_1+X_2)Y]-E[X_1+X_2]E[Y]\\\\ \u0026amp;=E[X_1Y]+E[X_2Y]-E[X_1]E[Y]-E[X_2]E[Y]\\\\ \u0026amp;=cov(X_1,Y)+cov(X_2,Y) \\end{align} $$\nè‹¥ $X,Y$ ç‹¬ç«‹ï¼Œåˆ™ $cov(X,Y)=0$ã€‚\nè¯æ˜ï¼š$cov(X,Y)=E[XY]-E[X]E[Y]=E[X]E[Y]-E[X]E[Y]=0$ã€‚\nä¸‹é¢å±•ç¤ºä¸€ä¸ªæ¯”è¾ƒç²¾å·§çš„è®¡ç®—åæ–¹å·®çš„ä¾‹å­ï¼š\nã€ä¾‹ã€‘è®¾ $(X,Y)$ æœä»å‚æ•°ä¸º $n,p_1,p_2$ çš„ä¸‰é¡¹åˆ†å¸ƒï¼Œå³å¯¹äºä»»æ„ $i,j$ï¼Œ$i+j\\leq n$ï¼Œ $$ P(X=i,Y=j)=\\frac{n!}{i!j!(n-i-j)!}p_1^ip_2^j(1-p_1-p_2)^{n-i-j} $$ è€ƒè™‘è®¡ç®— $cov(X,Y)$ã€‚æˆ‘ä»¬å‘ç°åˆ©ç”¨å®šä¹‰è®¡ç®—éå¸¸éº»çƒ¦ï¼Œä½†è€ƒè™‘å…¬å¼ $$ D(X+Y)=D(X)+D(Y)+2cov(X,Y) $$ è¿™ä¸‰ä¸ªæ–¹å·®éƒ½å¾ˆå®¹æ˜“æ±‚ï¼šå› ä¸º $X\\sim B(n,p_1),Y\\sim B(n,p_2),X+Y\\sim B(n,p_1+p_2)$ï¼Œæ‰€ä»¥ $$ \\begin{align} cov(X,Y)\u0026amp;=\\frac{1}{2}(D(X+Y)-D(X)-D(Y))\\\\ \u0026amp;=\\frac{1}{2}(n(p_1+p_2)(1-p_1-p_2)-np_1(1-p_2)-np_2(1-p_2))\\\\ \u0026amp;=-np_1p_2 \\end{align} $$ $\\fbox{Theorem 15.3}$ (Cauchy-Schwarz) è®¾éšæœºå˜é‡ $X,Y$ çš„æ–¹å·®éƒ½å­˜åœ¨ï¼Œåˆ™ $$ (cov(X,Y))^2\\leq D(X)D(Y) $$ å…¶ä¸­ç­‰å·å–åˆ°å½“ä¸”ä»…å½“å­˜åœ¨ä¸å…¨ä¸º 0 çš„å¸¸æ•° $a,b$ï¼Œä½¿å¾— $P(Y=aX+b)=1$ã€‚\nè¯æ˜ï¼šå¯¹äºä»»æ„ $t\\in \\mathbb R$ï¼Œä»¤ $$ u(t)=E[(t(X-E[X])-(Y-E[Y]))^2]\\geq 0 $$ é‚£ä¹ˆ $$ \\begin{align} u(t)\u0026amp;=t^2E[(X-E[X])^2]-2tE[(X-E[X])(Y-E[Y])]+E[(Y-E[Y])^2]\\\\ \u0026amp;=t^2D(X)-2tcov(X,Y)+D(Y) \\end{align} $$ å› ä¸º $u(t)\\geq 0$ï¼Œæ‰€ä»¥äºŒæ¬¡å‡½æ•°åˆ¤åˆ«å¼å°äºç­‰äº 0ï¼Œå³ $(cov(X,Y))^2\\leq D(X)D(Y)$ã€‚\nä¸‹é¢è€ƒè™‘ç­‰å·æˆç«‹çš„æ¡ä»¶ï¼š\n$\\Rightarrow:$ è‹¥ $(cov(X,Y))^2=D(X)D(Y)$ï¼Œé‚£ä¹ˆå­˜åœ¨ $t_0\\in \\mathbb R$ï¼Œ$u(t_0)=0$ã€‚ä»¤ $Z=t_0(X-E[X])-(Y-E[Y])$ï¼Œåˆ™ $$ 0=u(t_0)=E[Z^2]\\geq D(Z)\\geq 0 $$ æ‰€ä»¥ $D(Z)=0$ï¼Œ$P(Z=E[Z])=P(Z=0)=1$ã€‚\n$\\Leftarrow:$ è‹¥å­˜åœ¨ä¸å…¨ä¸º 0 çš„ $a,b\\in \\mathbb R$ æ»¡è¶³ $P(Y=aX+b)=1$ï¼Œé‚£ä¹ˆ $$ \\begin{align} cov(X,Y)\u0026amp;=E[XY]-E[X]E[Y]\\\\ \u0026amp;=E[X(aX+b)]-E[X]E[aX+b]\\\\ \u0026amp;=aE[X^2]+bE[X]-a(E[X])^2-bE[X]\\\\ \u0026amp;=aD(X)=\\pm \\sqrt{a^2D(X)^2} \\end{align} $$ æ³¨æ„åˆ° $D(Y)=D(aX+b)=a^2D(X)$ï¼Œæ‰€ä»¥ $cov(X,Y)=\\pm \\sqrt{D(X)D(Y)}$ã€‚$\\blacksquare$\nCorrelation Coefficient ç”± Cauchy-Schwarz ä¸ç­‰å¼å¯çŸ¥ï¼Œ$D(X),D(Y)\u0026gt;0$ æ—¶ï¼Œ$\\left|\\frac{cov(X,Y)}{\\sqrt{D(X)D(Y)}}\\right|\\leq 1$ï¼Œæˆ‘ä»¬åœ¨æ­¤åŸºç¡€ä¸Šå®šä¹‰ç›¸å…³ç³»æ•°ã€‚\n$\\fbox{Definition 15.4}$ è®¾éšæœºå˜é‡ $X,Y$ æ–¹å·®å‡å­˜åœ¨ï¼Œ$D(X)\u0026gt;0,D(Y)\u0026gt;0$ï¼Œåˆ™ä»¤ $$ \\rho_{XY}\\triangleq \\frac{cov(X,Y)}{\\sqrt{D(X)D(Y)}} $$ ä¸º $X,Y$ çš„ç›¸å…³ç³»æ•°ï¼Œä¹Ÿå¯è®°ä½œ $corr(X,Y)$ã€‚è‹¥ $\\rho_{XY}\u0026gt;0$ï¼Œåˆ™ç§° $X,Y$ æ­£ç›¸å…³ï¼›è‹¥ $\\rho_{XY}\u0026lt;0$ï¼Œåˆ™ç§° $X,Y$ è´Ÿç›¸å…³ã€‚\næ³¨ï¼š(1) è€ƒè™‘ $X,Y$ çš„æ ‡å‡†åŒ–éšæœºå˜é‡ $X^*=\\frac{X-E[X]}{\\sqrt{D(X)}},Y^*=\\frac{Y-E[Y]}{\\sqrt{D(Y)}}$ï¼Œé‚£ä¹ˆ $$ cov(X^*,Y^*)=E[(X^*-E[X^*])(Y^*-E[Y^*])]=E\\left[\\frac{X-E[X]}{\\sqrt{D(X)}}\\cdot \\frac{Y-E[Y]}{\\sqrt{D(Y)}}\\right]=\\frac{cov(X,Y)}{\\sqrt{D(X)D(Y)}}=\\rho_{XY} $$ å³æ ‡å‡†åŒ–åçš„éšæœºå˜é‡çš„åæ–¹å·®ç­‰äºå…¶åŸå˜é‡çš„ç›¸å…³ç³»æ•°ã€‚\n(2) $\\rho_{XY}$ ä¸ä¾èµ– $X,Y$ æ•°é‡çº§çš„é€‰å–ã€‚\n(3) æ ¹æ® Cauchy-Schwarz çš„å–ç­‰æ¡ä»¶ï¼Œ$|\\rho_{XY}=1|$ å½“ä¸”ä»…å½“ $|cov(X,Y)|=\\sqrt{D(X)D(Y)}$ï¼Œå³å­˜åœ¨ä¸å…¨ä¸º 0 çš„å¸¸æ•° $a,b$ï¼Œ$P(Y=aX+b)=1$ã€‚$\\rho_{XY}$ åˆ»ç”»äº† $X,Y$ ä¹‹é—´çº¿æ€§ç›¸å…³çš„ç¨‹åº¦ï¼Œ$|\\rho_{XY}|$ è¶Šå¤§ï¼Œ$X,Y$ çš„çº¿æ€§å…³ç³»å°±è¶Šå¯†åˆ‡ã€‚\n$\\fbox{Definition 15.5}$ è‹¥ $X,Y$ æ»¡è¶³ $\\rho_{XY}=0$ï¼Œåˆ™ç§° $X,Y$ çº¿æ€§æ— å…³æˆ–ä¸ç›¸å…³ã€‚\n$\\fbox{Proposition 15.6}$ åœ¨ $X,Y$ æ–¹å·®å­˜åœ¨çš„æƒ…å†µä¸‹ï¼Œä¸‹è¿° 4 æ¡ç­‰ä»·ï¼š\n$\\rho_{XY}=0$ã€‚ $cov(X,Y)=0$ã€‚ $E[XY]=E[X]E[Y]$ã€‚ $D(X\\pm Y)=D(X)+D(Y)$ã€‚ æ ¹æ®ä¸Šè¿°å‘½é¢˜ï¼Œæˆ‘ä»¬å®¹æ˜“å‘ç°å¦‚æœ $X,Y$ ç›¸äº’ç‹¬ç«‹ï¼Œé‚£ä¹ˆ $\\rho_{XY}=0$ï¼Œä½†åä¹‹ä¸æˆç«‹ï¼Œå³ä¸ç›¸å…³æ˜¯æ¯”ç›¸äº’ç‹¬ç«‹å¼±çš„æ¡ä»¶ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š\nã€ä¾‹ã€‘è®¾ $\\theta$ æœä» $[0,2\\pi]$ ä¸Šçš„å‡åŒ€åˆ†å¸ƒï¼Œä»¤ $X=\\cos \\theta,Y=\\cos (\\theta+a)$ï¼Œå…¶ä¸­ $a$ ä¸ºç»™å®šå¸¸æ•°ï¼Œè€ƒè™‘ $\\rho_{XY}$ã€‚ $$ \\begin{align} E[X]\u0026amp;=\\int_0^{2\\pi}xp(x)dx=\\frac{1}{2\\pi}\\int_0^{2\\pi}\\cos xdx=0\\\\ E[Y]\u0026amp;=\\frac{1}{2\\pi}\\int_0^{2\\pi}\\cos(x+a)dx=0\\\\ D(X)\u0026amp;=E[(X-0)^2]=\\frac{1}{2\\pi}\\int_0^{2\\pi}\\cos ^2xdx=\\frac{1}{4\\pi}\\int_0^{2\\pi}(1+\\cos 2x)dx=\\frac{1}{2}\\\\ D(Y)\u0026amp;=E[(Y-0)^2]=\\frac{1}{2\\pi}\\int_0^{2\\pi}\\cos ^2(x+a)dx=\\frac{1}{4\\pi}\\int_0^{2\\pi}(1+\\cos 2(x+a))dx=\\frac{1}{2}\\\\ E[XY]\u0026amp;=E[\\cos \\theta \\cos (\\theta +a)]=\\frac{1}{2\\pi}\\int_0^{2\\pi}\\cos x\\cos (x+a)dx\\\\ \u0026amp;\\overset{å’Œå·®åŒ–ç§¯}{=}\\frac{1}{4\\pi}(\\int_0^{2\\pi}\\cos(2x+a)+\\cos a)dx=\\frac{1}{2}\\cos a\\\\ \\rho_{XY}\u0026amp;=\\frac{cov(X,Y)}{\\sqrt{D(X)D(Y)}}=\\frac{\\frac{1}{2}cos a}{\\sqrt{\\frac{1}{2}\\cdot \\frac{1}{2}}}=\\cos a \\end{align} $$ å½“ $a=\\frac{3\\pi}{2}$ æ—¶ï¼Œ$\\rho_{XY}=0$ï¼Œ$X,Y$ ä¸ç›¸å…³ã€‚æ­¤æ—¶ $X=\\cos \\theta,Y=\\cos (\\theta+a)=\\sin \\theta$ï¼Œæœ‰ $X^2+Y^2=1$ã€‚\nè€ƒè™‘å¦‚ä¸‹äº‹ä»¶çš„æ¦‚ç‡ï¼š$P(|X|\\leq \\frac{1}{2},|Y|\\leq \\frac{1}{2})$ï¼Œå› ä¸º $X^2+Y^2=1$ï¼Œæ‰€ä»¥è¯¥æ¦‚ç‡ä¸º 0ã€‚ä½† $P(|X|\\leq \\frac{1}{2})\u0026gt;0$ï¼Œ$P(|Y|\\leq \\frac{1}{2})\u0026gt;0$ï¼Œä»è€Œ $P(|X|\\leq \\frac{1}{2},|Y|\\leq \\frac{1}{2})\\neq P(|X|\\leq \\frac{1}{2})\\cdot P(|Y|\\leq \\frac{1}{2})$ï¼Œæ‰€ä»¥ $X,Y$ ä¸ç›¸äº’ç‹¬ç«‹ã€‚\nã€ä¾‹é¢˜ã€‘è®¾ $(X,Y)\\sim N(\\mu_1,\\mu_2,\\sigma_1^2,\\sigma_2^2,\\rho)$ï¼Œæ±‚ $cov(X,Y)$ å’Œ $\\rho_{XY}$ã€‚\nè§£ï¼š $$ p(x,y)=\\frac{1}{2\\pi\\sigma_1\\sigma_2\\sqrt{1-\\rho^2}}e^{-\\frac{1}{2(1-\\rho^2)}\\left[\\left(\\frac{x-\\mu_1}{\\sigma_1}\\right)^2-2\\rho \\left(\\frac{x-\\mu_1}{\\sigma_1}\\cdot \\frac{y-\\mu_2}{\\sigma_2}\\right)+\\left(\\frac{y-\\mu_2}{\\sigma_2}\\right)^2\\right]} $$ æˆ‘ä»¬å·²çŸ¥ $E[X]=\\mu_1,E[Y]=\\mu_2,D(X)=\\sigma_1^2,D(Y)=\\sigma_2^2$ã€‚ $$ \\begin{align} cov(X,Y)\u0026amp;=E[(X-E[X])(Y-E[Y])]=\\int_{-\\infty}^{+\\infty}\\int_{-\\infty}^{+\\infty}(x-\\mu_1)(y-\\mu_2)p(x,y)dxdy\\\\ \u0026amp;\\overset{u=\\frac{x-\\mu_1}{\\sigma_1},v=\\frac{y-\\mu_2}{\\sigma_2}}{=}\\frac{1}{2\\pi\\sigma_1\\sigma_2\\sqrt{1-\\rho^2}}\\int_{-\\infty}^{+\\infty}\\int_{-\\infty}^{+\\infty}\\sigma_1u\\cdot \\sigma_2ve^{-\\frac{1}{2(1-\\rho^2)}(u^2-2\\rho uv+v^2)}d(\\sigma_1u)d(\\sigma_2v)\\\\ \u0026amp;=\\frac{\\sigma_1\\sigma_2}{2\\pi\\sqrt{1-\\rho^2}}\\int_{-\\infty}^{+\\infty}v\\int_{-\\infty}^{+\\infty}ue^{-\\frac{1}{2(1-\\rho^2)}(u^2-2\\rho vu+\\rho^2v^2-\\rho^2v^2+v^2)}dudv\\\\ \u0026amp;=\\frac{\\sigma_1\\sigma_2}{2\\pi\\sqrt{1-\\rho^2}}\\int_{-\\infty}^{+\\infty}ve^{-\\frac{v^2}{2}}\\int_{-\\infty}^{+\\infty}ue^{-\\frac{1}{2(1-\\rho^2)}(u-\\rho v)^2}dudv \\end{align} $$ æ³¨æ„åˆ° $$ \\frac{1}{\\sqrt{2\\pi}\\sqrt{1-\\rho^2}}\\int_{-\\infty}^{+\\infty}ue^{-\\frac{1}{2(1-\\rho^2)}(u-\\rho v)^2}du $$ æ˜¯æ­£æ€åˆ†å¸ƒ $N(\\rho v, 1-\\rho^2)$ çš„æœŸæœ› (è‡ªå˜é‡ä¸º $u$)ï¼Œæ‰€ä»¥ $$ \\begin{align} cov(X,Y)=\\frac{\\sigma_1\\sigma_2}{\\sqrt{2\\pi}}\\int_{-\\infty}^{+\\infty}ve^{-\\frac{v^2}{2}}\\rho vdv=\\sigma_1\\sigma_2\\rho\\cdot \\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{+\\infty}v^2e^{-\\frac{v^2}{2}}dv \\end{align} $$ æ³¨æ„åˆ° $$ \\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{+\\infty}v^2e^{-\\frac{v^2}{2}}dv=\\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{+\\infty}(v-0)^2e^{-\\frac{v^2}{2}}dv $$ æ˜¯æ ‡å‡†æ­£æ€åˆ†å¸ƒ $N(0,1)$ çš„æ–¹å·®ï¼Œæ‰€ä»¥è¯¥å¼ä¸º 1ï¼Œæ‰€ä»¥ $cov(X,Y)=\\sigma_1\\sigma_2\\rho$ã€‚ç›¸å…³ç³»æ•° $\\rho_{XY}=\\rho$ã€‚\n$\\fbox{Theorem 15.7}$ è®¾ $(X,Y)\\sim N(\\mu_1,\\mu_2,\\sigma_1^2,\\sigma_2^2,\\rho)$ï¼Œåˆ™ $X,Y$ ç›¸äº’ç‹¬ç«‹å½“ä¸”ä»…å½“ $X,Y$ ä¸ç›¸å…³ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"de807efff34d5cd14919e533e3baa01f","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-probability/lec15/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-probability/lec15/","section":"notes","summary":"$\\fbox{Theorem 15.1}$ (Chebyshev) è®¾éšæœºå˜é‡ $X$ çš„æ–¹å·®å­˜åœ¨ï¼Œåˆ™æœ‰ $$ \\forall \\varepsilon\u0026gt;0,P(|X-E[X]|\u0026gt;\\varepsilon)\\leq \\frac{D(X)}{\\varepsilon^2} $$ è¯æ˜ï¼šè®¾ $X$ å­˜åœ¨å¯†åº¦å‡½æ•° $p(x)$ï¼Œåˆ™ $$ \\begin{align} P(|X-E[X]|\u0026gt;\\varepsilon)\u0026amp;=\\int_{{x:|X-E[X]|\u0026gt;\\varepsilon}}p(x)dx\\\\ \u0026amp;\\leq \\int_{{x:|X-E[X]|\u0026gt;\\varepsilon}}\\frac{|X-E[x]|^2}{\\varepsilon^2}p(x)dx\\\\ \u0026amp;\\leq \\frac{1}{\\varepsilon^2}\\int_{-\\infty}^{+\\infty}|X-E[X]|^2p(x)dx\\\\ \u0026amp;=\\frac{D(X)}{\\varepsilon^2}\\qquad \\blacksquare \\end{align} $$ æˆ‘ä»¬çš„è¯æ˜è¿‡ç¨‹ä¸­ä½¿ç”¨äº†ä¸¤æ¬¡çœ‹ä¸Šå»å¾ˆâ€œæ¾â€çš„æ”¾ç¼©ï¼Œä½†ä¸‹é¢çš„ä¾‹å­å¯ä»¥è¯´æ˜ï¼Œåœ¨å¯¹ $X$ æ²¡æœ‰ä»»ä½•é¢å¤–é™åˆ¶çš„æƒ…å†µä¸‹ï¼ŒChebyshev çš„ç»“æœå·²ç»æ˜¯æœ€ç´§çš„äº†ï¼š","tags":null,"title":"Lecture 15: Covariance and Correlation Coefficient","type":"docs"},{"authors":null,"categories":null,"content":"Origin Moment and Central Moment $\\fbox{Definition 16.1}$ è®¾ $X$ æ˜¯éšæœºå˜é‡ï¼Œå¯¹æ­£æ•´æ•° $k$ï¼Œè‹¥ $E[|X|^k]\u0026lt;+\\infty$ï¼Œåˆ™ç§° $E[X^k]$ ä¸º $X$ çš„ $k$ é˜¶åŸç‚¹çŸ©æˆ– $k$ é˜¶çŸ©ï¼›è‹¥ $E[|X-E[X]|^k]\u0026lt;+\\infty$ï¼Œåˆ™ç§° $E[(X-E[X])^k]$ ä¸º $X$ çš„ $k$ é˜¶ä¸­å¿ƒçŸ©ã€‚\næ³¨ï¼š(1) çŸ©æ˜¯å¯¹æœŸæœ›ã€æ–¹å·®çš„æ¨å¹¿ï¼Œ1 é˜¶åŸç‚¹çŸ©å°±æ˜¯æœŸæœ›ï¼Œ2 é˜¶ä¸­å¿ƒçŸ©å°±æ˜¯æ–¹å·®ã€‚\n(2) ä¸€èˆ¬æƒ…å½¢ä¸‹ï¼Œä¸¤ä¸ªéšæœºå˜é‡çš„ä»»æ„é˜¶åŸç‚¹çŸ©/ä¸­å¿ƒçŸ©ç›¸åŒä¸èƒ½æ¨å‡ºä¸¤ä¸ªéšæœºå˜é‡çš„åˆ†å¸ƒç›¸åŒã€‚\nã€ä¾‹ã€‘è€ƒè™‘æ­£æ€åˆ†å¸ƒ $X\\sim N(\\mu,\\sigma^2)$ çš„ $k$ é˜¶ä¸­å¿ƒçŸ©ã€‚é¦–å…ˆå†™å‡º $X$ çš„å¯†åº¦å‡½æ•°ï¼š $$ p(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}} $$ æ‰€ä»¥ $$ \\begin{align} E[(X-E[X])^k]\u0026amp;=\\frac{1}{\\sqrt{2\\pi}\\sigma}\\int_{-\\infty}^{+\\infty}(x-\\mu)^ke^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}dx\\\\ \u0026amp;\\overset{t=\\frac{x-\\mu}{\\sigma}}{=}\\frac{1}{\\sqrt{2\\pi}\\sigma}\\int_{-\\infty}^{+\\infty}\\sigma^kt^ke^{-\\frac{t^2}{2}}d(\\sigma t)\\\\ \u0026amp;=\\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{+\\infty}t^ke^{-\\frac{t^2}{2}}dt \\end{align} $$ $k$ æ˜¯å¥‡æ•°æ—¶ï¼Œè¢«ç§¯å‡½æ•°æ˜¯å¥‡å‡½æ•°ï¼ŒåŸå¼ä¸º 0ã€‚$k$ æ˜¯å¶æ•°æ—¶ï¼Œæˆ‘ä»¬è€ƒè™‘å½’çº³åœ°ä½¿ç”¨åˆ†éƒ¨ç§¯åˆ†ï¼š $$ \\begin{align} \\int_{-\\infty}^{+\\infty}t^ke^{-\\frac{t^2}{2}}dt\u0026amp;=\\int_{-\\infty}^{+\\infty}t^{k-1}e^{-\\frac{t^2}{2}}d\\frac{t^2}{2}=-\\int_{-\\infty}^{+\\infty}t^{k-1}de^{-\\frac{t^2}{2}}\\\\ \u0026amp;=-\\left.t^{k-1}e^{-\\frac{t^2}{2}}\\right|_{-\\infty}^{+\\infty}+\\int_{-\\infty}^{+\\infty}e^{-\\frac{t^2}{2}}d(t^{k-1})\\\\ \u0026amp;=(k-1)\\int_{-\\infty}^{+\\infty}t^{k-2}e^{-\\frac{t^2}{2}}dt \\end{align} $$ æœ€åå‰©ä¸‹çš„ä¸œè¥¿æ˜¯é«˜æ–¯ç§¯åˆ†ï¼Œä¸º $\\sqrt{2\\pi}$ï¼Œå› æ­¤ $$ E[(X-E[X])^k]=\\begin{cases}0\u0026amp;,kæ˜¯å¶æ•°\\\\\\sigma^k(k-1)!!\u0026amp;,kæ˜¯å¥‡æ•°\\end{cases}. $$ æ³¨ï¼šæ ‡å‡†åŒ–éšæœºå˜é‡ (æ­¤æ—¶æœŸæœ›ä¸º 0ï¼Œä¸­å¿ƒçŸ©å’ŒåŸç‚¹çŸ©ç›¸åŒ) çš„ä¸‰é˜¶çŸ©ç§°ä¸ºååº¦ã€‚ååº¦ä¸ºè´Ÿæ„å‘³ç€åˆ†å¸ƒçš„å·¦å°¾æ›´é•¿ï¼Œä½†å¤§å¤šæ•°å–å€¼æ¯”æœŸæœ›å¤§ (å³æœ‰ä¸€äº›æ¦‚ç‡å–åˆ°å¾ˆå°çš„è´Ÿæ•°ï¼Œä½†æ›´å¤§æ¦‚ç‡å–åˆ°å¤§äºæœŸæœ›çš„æ•°)ï¼›ååº¦ä¸º 0 æ„å‘³ç€æ•°å€¼ç›¸å¯¹å‡åŒ€åœ°åˆ†å¸ƒåœ¨æœŸæœ›çš„ä¸¤ä¾§ (ä½†æœªå¿…å®Œå…¨å¯¹ç§°)ã€‚\nå››é˜¶çŸ©ç§°ä¸ºå³°åº¦ã€‚å³°åº¦é«˜æ„å‘³ç€å­˜åœ¨è¿œå¤§äºæˆ–è¿œå°äºæœŸæœ›çš„å–å€¼ä¸”å–åˆ°çš„æ¦‚ç‡ä¸å¤ªå°ã€‚\nå¯¹äºä¸­å¿ƒçŸ©ï¼Œæˆ‘ä»¬æœ‰å¦‚ä¸‹çš„åˆ‡æ¯”é›ªå¤«ä¸ç­‰å¼çš„æ¨å¹¿ï¼š\n$\\fbox{Theorem 16.2}$ è®¾ $E[|X-E[X]|^k]\u0026lt;+\\infty$ï¼Œåˆ™å¯¹äºä»»æ„ $\\varepsilon\u0026gt;0$ï¼Œ $$ P(|X-E[X||\u0026gt;\\varepsilon)\\leq \\frac{E[|X-E[X]|^k]}{\\varepsilon^k} $$ è¯¥ä¸ç­‰å¼åœ¨è¿œç«¯å¯ä»¥ç»™å‡ºæ¯”åˆ‡æ¯”é›ªå¤«ä¸ç­‰å¼æ›´å¥½çš„ä¼°è®¡ã€‚\nCovariance Matrix $\\fbox{Definition 16.3}$ è®¾ $X=(X_1,\\cdots, X_n)^T$ æ˜¯ä¸€ä¸ª $n$ ç»´éšæœºå˜é‡ï¼Œåˆ™ $$ E[X]\\triangleq(E[X_1],E[X_2],\\cdots, E[X_n])^T $$ ä¸º $X$ çš„æœŸæœ›ã€‚è®° $C_{ij}=cov(X_i,X_j)$ï¼Œç§°çŸ©é˜µ $$ \\Sigma=\\begin{bmatrix}C_{11} \u0026amp; C_{12}\u0026amp;\\cdots \u0026amp;C_{1n}\\\\ C_{21}\u0026amp;C_{22}\u0026amp;\\cdots\u0026amp;C_{2n}\\\\ \\vdots\u0026amp;\\vdots\u0026amp;\\ddots\u0026amp;\\vdots\\\\ C_{n1}\u0026amp;C_{n2}\u0026amp;\\cdots\u0026amp;C_{nn}\\end{bmatrix} $$ ä¸º $X$ çš„åæ–¹å·®é˜µã€‚\nã€ä¾‹ã€‘è€ƒè™‘ $(X_1,X_2)\\sim N(\\mu_1,\\mu_2,\\sigma_1^2,\\sigma_2^2,\\rho)$ï¼Œè®° $\\Sigma=\\begin{bmatrix}\\sigma_1^2\u0026amp; \\sigma_1\\sigma_2\\rho\\\\\\sigma_1\\sigma_2\\rho\u0026amp;\\sigma_2^2\\end{bmatrix}$ï¼Œ$\\mu=(\\mu_1,\\mu_2)^T,X=(X_1,X_2)^T$ï¼Œåˆ™ $$ p(x_1,x_2)=p(x)=\\frac{1}{2\\pi\\sqrt{\\det \\Sigma}}e^{-\\frac{1}{2}(X-\\mu)^T\\Sigma^{-1}(X-\\mu)} $$ $\\fbox{Theorem 16.4}$ åæ–¹å·®çŸ©é˜µæ˜¯åŠæ­£å®šçš„ï¼Œå³å¯¹äºä»»æ„ $X\\in \\mathbb R^n$ï¼Œ$X^T\\Sigma X\\geq 0$ã€‚\nè¯æ˜ï¼šå¯¹äºä»»æ„ $T=(t_1,\\cdots, t_n)^T\\in \\mathbb R^n$ï¼Œè€ƒè™‘å¦‚ä¸‹éšæœºå˜é‡çš„æœŸæœ›ï¼š $$ E\\left[\\left(\\sum_{i=1}^nt_i(X_i-E[X_i])\\right)^2\\right]\\geq 0 $$ æˆ‘ä»¬ä¸‹é¢è¯æ˜è¿™ä¸ªæœŸæœ›å°±æ˜¯åæ–¹å·®çŸ©é˜µçš„äºŒæ¬¡å‹ï¼š $$ \\begin{align} E\\left[\\left(\\sum_{i=1}^nt_i(X_i-E[X_i])\\right)^2\\right]\u0026amp;=E\\left[\\sum_{i=1}^n\\sum_{j=1}^nt_it_j(X_i-E[X_i])(X_j-E[X_j])\\right]\\\\ \u0026amp;=\\sum_{i=1}^n\\sum_{j=1}^nt_it_jE[(X_i-E[X_i])(X_j-E[X_j])]\\\\ \u0026amp;=\\sum_{i=1}^n\\sum_{j=1}^nt_it_jC_{ij}\\\\ \u0026amp;=\\sum_{j=1}^n\\left(\\sum_{i=1}^nt_iC_{ij}\\right)t_j\\\\ \u0026amp;= \\begin{pmatrix} \\sum_{i=1}^nt_iC_{i1}\u0026amp;\\sum_{i=1}^nt_iC_{i2}\u0026amp;\\cdots\u0026amp;\\sum_{i=1}^nt_iC_{in} \\end{pmatrix} \\begin{pmatrix} t_1\\\\t_2\\\\\\vdots\\\\t_n \\end{pmatrix}\\\\ \u0026amp;=\\begin{pmatrix} \\begin{pmatrix} t_1\u0026amp;\\cdots\u0026amp;t_n \\end{pmatrix} \\begin{pmatrix} C_{11}\\\\\\vdots \\\\C_{1n} \\end{pmatrix} \u0026amp; \\cdots \u0026amp; \\begin{pmatrix} t_1\u0026amp;\\cdots\u0026amp;t_n \\end{pmatrix} \\begin{pmatrix} C_{n1}\\\\\\vdots \\\\C_{nn} \\end{pmatrix} \\end{pmatrix} \\begin{pmatrix} t_1\\\\\\vdots \\\\t_n \\end{pmatrix}\\\\ \u0026amp;= \\begin{pmatrix} t_1\u0026amp;\\cdots \u0026amp;t_n \\end{pmatrix} \\begin{bmatrix}C_{11} \u0026amp; C_{12}\u0026amp;\\cdots \u0026amp;C_{1n}\\\\ C_{21}\u0026amp;C_{22}\u0026amp;\\cdots\u0026amp;C_{2n}\\\\ \\vdots\u0026amp;\\vdots\u0026amp;\\ddots\u0026amp;\\vdots\\\\ C_{n1}\u0026amp;C_{n2}\u0026amp;\\cdots\u0026amp;C_{nn}\\end{bmatrix} \\begin{pmatrix} t_1\\\\\\vdots \\\\t_n \\end{pmatrix}\\\\ \u0026amp;=T^T\\Sigma T \\end{align} $$ æ‰€ä»¥ $\\Sigma$ åŠæ­£å®šã€‚ $\\blacksquare$\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"ff2f8af92cce5eef1ab8e7eada09afd9","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-probability/lec16/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-probability/lec16/","section":"notes","summary":"Origin Moment and Central Moment $\\fbox{Definition 16.1}$ è®¾ $X$ æ˜¯éšæœºå˜é‡ï¼Œå¯¹æ­£æ•´æ•° $k$ï¼Œè‹¥ $E[|X|^k]\u0026lt;+\\infty$ï¼Œåˆ™ç§° $E[X^k]$ ä¸º $X$ çš„ $k$ é˜¶åŸç‚¹çŸ©æˆ– $k$ é˜¶çŸ©ï¼›è‹¥ $E[|X-E[X]|^k]\u0026lt;+\\infty$ï¼Œåˆ™ç§° $E[(X-E[X])^k]$ ä¸º $X$ çš„ $k$ é˜¶ä¸­å¿ƒçŸ©ã€‚\næ³¨ï¼š(1) çŸ©æ˜¯å¯¹æœŸæœ›ã€æ–¹å·®çš„æ¨å¹¿ï¼Œ1 é˜¶åŸç‚¹çŸ©å°±æ˜¯æœŸæœ›ï¼Œ2 é˜¶ä¸­å¿ƒçŸ©å°±æ˜¯æ–¹å·®ã€‚","tags":null,"title":" Lecture 16: Moment and Covariance Matrix","type":"docs"},{"authors":null,"categories":null,"content":"$\\fbox{Definition 21.1}$ è®¾ $\\theta$ æ˜¯æ€»ä½“ $X$ çš„æœªçŸ¥å‚æ•°ï¼Œ$X_1,\\cdots, X_n$ æ˜¯æ¥è‡ª $X$ çš„æ ·æœ¬ï¼Œè‹¥å¯¹äºç»™å®šçš„ $0\u0026lt;\\alpha\u0026lt;1$ï¼Œå­˜åœ¨ä¸¤ä¸ªç»Ÿè®¡é‡ $\\hat\\theta_1(X_1,\\cdots, X_n)$ å’Œ $\\hat\\theta_2(X_1,\\cdots, X_n)$ï¼Œä½¿å¾— $$ P(\\hat\\theta_1\u0026lt;\\theta\u0026lt;\\hat\\theta_2)=1-\\alpha $$ åˆ™ç§° $(\\hat\\theta_1,\\hat\\theta_2)$ æ˜¯ $\\theta$ çš„ç½®ä¿¡åº¦ä¸º $1-\\alpha$ çš„ç½®ä¿¡åŒºé—´ï¼Œ$\\theta_1,\\theta_2$ ç§°ä¸ºç½®ä¿¡ä¸‹é™å’Œç½®ä¿¡ä¸Šé™ï¼Œ$1-\\alpha$ ç§°ä¸ºç½®ä¿¡åº¦æˆ–ç½®ä¿¡ç³»æ•°ã€‚\næ³¨ï¼š(1) ä¸Šé¢æ•°å­¦è¡¨è¾¾å¼çš„å«ä¹‰ä¸ºï¼šåœ¨è¿›è¡Œäº† $m$ è½® (æ¯è½® $n$ æ¬¡) é‡‡æ ·åï¼Œæˆ‘ä»¬ä¼šå¾—åˆ° $m$ ä¸ªåŒºé—´ $(\\hat\\theta_{1,1},\\hat\\theta_{2,1})$ â€¦â€¦ $(\\hat\\theta_{1,m},\\hat\\theta_{2,m})$ã€‚è¿™å…¶ä¸­å¤§çº¦æœ‰ $(1-\\alpha)m$ ä¸ªåŒºé—´åŒ…å«äº† $\\theta$ã€‚å¯¹äºä¸€ç»„å…·ä½“çš„ä¼°è®¡å€¼ $\\hat\\theta_1(x_1,\\cdots,x_n)$ å’Œ $\\hat\\theta_2(x_1,\\cdots, x_n)$ï¼Œæˆ‘ä»¬ä¸èƒ½è¯´ $\\theta$ æœ‰ $1-\\alpha$ çš„æ¦‚ç‡è½åœ¨åŒºé—´ä¸­ï¼Œå› ä¸ºè¿™æ—¶åŒºé—´çš„ä¸Šä¸‹ç•Œå·²ç»æ˜¯ç¡®å®šçš„æ•°äº†ï¼Œä¸å†å…·æœ‰éšæœºæ€§ã€‚\n(2) $\\hat\\theta_2-\\hat\\theta_1$ è¶Šå¤§ï¼Œç½®ä¿¡åº¦è¶Šé«˜ï¼Œä½†ç²¾åº¦ä¹Ÿä¼šè¶Šå·®ã€‚\næœ‰æ—¶æˆ‘ä»¬ä¹Ÿä¼šåªå…³å¿ƒæœªçŸ¥å‚æ•°çš„ä¸Šé™æˆ–ä¸‹é™ (å¦‚ä¿è´¨æœŸ)ï¼Œå› æ­¤æˆ‘ä»¬ç±»ä¼¼åœ°æœ‰å•ä¾§ç½®ä¿¡åŒºé—´å’Œå•ä¾§ç½®ä¿¡ä¸Šé™/ä¸‹é™çš„æ¦‚å¿µã€‚\nPivot Method æ¢è½´å˜é‡æ³•çš„ä¸»è¦æ€æƒ³å¦‚ä¸‹ï¼š\næ„é€ ä¸€ä¸ªæ ·æœ¬å‡½æ•° $U(X_1,\\cdots, X_n;\\theta)$ï¼Œæˆ‘ä»¬è¦æ±‚ $U$ æ˜¯æœ‰ä¸”ä»…æœ‰æœªçŸ¥å‚æ•° $\\theta$ çš„å‡½æ•°ï¼Œä¸” $U$ çš„åˆ†å¸ƒå·²çŸ¥ã€‚æˆ‘ä»¬ç§° $U$ ä¸ºæ¢è½´å˜é‡ã€‚ å› ä¸º $U$ çš„åˆ†å¸ƒå·²çŸ¥ï¼Œæ‰€ä»¥å¯¹äºç»™å®šçš„ç½®ä¿¡åŒºé—´ $1-\\alpha$ï¼Œæˆ‘ä»¬å¯ä»¥ç¡®å®šåŒºé—´ $[a,b]$ï¼Œä½¿å¾— $P(a\\leq U\\leq b)=1-\\alpha$ (å¦‚æœè¦æ±‚å•è¾¹ç½®ä¿¡åŒºé—´ï¼Œåˆ™åªéœ€è¦ä¸€ä¸ªæ–¹å‘çš„çº¦æŸ)ã€‚ æ ¹æ® $a\\leq U\\leq b$ åæ¨å‡º $\\theta$ çš„èŒƒå›´ (èŒƒå›´è¡¨è¾¾å¼ä¸­ä»…åŒ…å« $X_1,\\cdots, X_n$)ï¼Œè¿™ä¸ªèŒƒå›´å°±æ˜¯æˆ‘ä»¬è¦æ±‚çš„ $\\hat\\theta_1$ å’Œ $\\hat\\theta_2$ã€‚ Confidence Interval of $\\mu$ in Normal Population ã€ä¾‹ã€‘ç»™å®šç½®ä¿¡åº¦ $1-\\alpha$ï¼Œæ ·æœ¬ $X_1,\\cdots, X_n$ æ¥è‡ªæ€»ä½“ $X\\sim N(\\mu,\\sigma^2)$ã€‚è€ƒè™‘ç”¨æ¢è½´å˜é‡æ³•æ±‚å‡å€¼ $\\mu$ çš„ç½®ä¿¡åŒºé—´ï¼šå› ä¸º $X\\sim N(\\mu,\\sigma^2)$ï¼Œæ‰€ä»¥ $\\overline{X}\\sim N(\\mu,\\frac{\\sigma^2}{n})$ æˆ‘ä»¬æ„é€  $U=\\frac{\\overline{X}-\\mu}{\\sigma/\\sqrt n}$ï¼Œåˆ™ $U\\sim N(0,1)$ã€‚\nè®° $u_{\\alpha}$ æ˜¯ $N(0,1)$ çš„ä¸Š $\\alpha$ åˆ†ä¸ºæ•° (å³ $P(u\u0026gt;u_\\alpha)=\\alpha$)ï¼Œé‚£ä¹ˆ $$ 1-\\alpha=P(u_{1-\\alpha/2}\u0026lt;U\u0026lt;u_{\\alpha/2})=P(-u_{\\alpha/2}\u0026lt;U\u0026lt;u_{\\alpha/2}) $$ å› æ­¤ $$ -u_{\\frac{\\alpha}{2}}\u0026lt;\\frac{\\overline{X}-\\mu}{\\sigma/\\sqrt n}\u0026lt;u_{\\frac{\\alpha}{2}}\\quad \\Rightarrow\\quad \\overline{X}-\\frac{\\sigma u_{\\frac{\\alpha}{2}}}{\\sqrt n}\u0026lt;\\mu\u0026lt;\\overline{X}+\\frac{\\sigma \\mu_{\\frac{\\alpha}{2}}}{\\sqrt n} $$ å› æ­¤ç½®ä¿¡åŒºé—´ä¸º $\\left(\\overline{X}-\\frac{\\sigma u_{\\frac{\\alpha}{2}}}{\\sqrt n},\\overline{X}+\\frac{\\sigma \\mu_{\\frac{\\alpha}{2}}}{\\sqrt n}\\right)$ã€‚\nå¦‚æœæˆ‘ä»¬ä¸çŸ¥é“ $\\sigma^2$ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ç»™å‡ºä¸€ä¸ªç½®ä¿¡åŒºé—´ã€‚æ ¹æ®æ­£æ€æ€»ä½“ç« èŠ‚çš„çŸ¥è¯†ï¼Œæˆ‘ä»¬æœ‰ $$ T=\\frac{\\sqrt n(\\overline{X}-\\mu)}{S}\\sim t(n-1) $$ å› æ­¤è®° $t_{\\alpha}(n-1)$ ä¸º $T$ çš„ä¸Š $\\alpha$ åˆ†ä¸ºæ•°ï¼Œæœ‰ $$ 1-\\alpha=P(t_{1-\\alpha/2}(n-1)\u0026lt;T\u0026lt;t_{\\alpha/2}(n-1))=P(-t_{\\alpha/2}(n-1)\u0026lt;T\u0026lt;t_{\\alpha/2}(n-1)) $$ å› æ­¤ $$ -t_{\\frac{\\alpha}{2}}(n-1)\u0026lt;\\frac{\\sqrt n(\\overline{X}-\\mu)}{S}\u0026lt;t_{\\frac{\\alpha}{2}}(n-1)\\quad \\Rightarrow \\quad ç½®ä¿¡åŒºé—´\\left(\\overline{X}-\\frac{St_{\\frac{\\alpha}{2}}(n-1)}{\\sqrt n},\\overline{X}+\\frac{St_{\\frac{\\alpha}{2}}(n-1)}{\\sqrt n}\\right) $$ $T$ åˆ†å¸ƒçš„å°¾éƒ¨æ¯”æ­£æ€åˆ†å¸ƒè¦é‡ (æ­£æ€åˆ†å¸ƒæ˜¯æŒ‡æ•°è¡°å‡çš„ï¼ŒT åˆ†å¸ƒæ˜¯å¤šé¡¹å¼è¡°å‡çš„)ï¼Œå› æ­¤ä¸Šè¿°ç½®ä¿¡åŒºé—´ä¼šæ¯”çŸ¥é“ $\\sigma^2$ æ—¶çš„ç½®ä¿¡åŒºé—´è¦å®½ä¸€äº›ã€‚è€ƒè™‘åˆ°æˆ‘ä»¬æ˜¯åœ¨çŸ¥é“æ›´å°‘çš„ä¿¡æ¯çš„æƒ…å†µä¸‹æ±‚å‡ºçš„è¯¥åŒºé—´ï¼Œè¿™ä¸€ç‚¹æ˜¯å®¹æ˜“ç†è§£çš„ã€‚\nConfidence Interval of $\\sigma^2$ in Normal Population ã€ä¾‹ã€‘ç»™å®šç½®ä¿¡åº¦ $1-\\alpha$ï¼Œæ ·æœ¬ $X_1,\\cdots, X_n$ æ¥è‡ªæ€»ä½“ $X\\sim N(\\mu,\\sigma^2)$ã€‚è€ƒè™‘ç”¨æ¢è½´å˜é‡æ³•æ±‚æ–¹å·® $\\sigma^2$ çš„ç½®ä¿¡åŒºé—´ï¼šåœ¨ $\\mu$ æœªçŸ¥çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·ç»™å‡ºæ¢è½´å˜é‡ï¼š$\\frac{(n-1)S^2}{\\sigma^2}\\sim \\chi^2(n-1)$ã€‚ä»è€Œ $$ 1-\\alpha=P\\left(\\chi^2_{1-\\frac{\\alpha}{2}}(n-1)\u0026lt;\\frac{(n-1)S^2}{\\sigma^2}\u0026lt;\\chi^2_{\\frac{\\alpha}{2}}(n-1)\\right) $$ è§£å¾—ç½®ä¿¡åŒºé—´ä¸º $$ \\left(\\frac{(n-1)S^2}{\\chi^2_{\\frac{\\alpha}{2}}(n-1)},\\frac{(n-1)S^2}{\\chi^2_{1-\\frac{\\alpha}{2}}(n-1)}\\right) $$ æ³¨ï¼š(1) å°½ç®¡ $\\chi^2$ åˆ†å¸ƒå’Œ $F$ åˆ†å¸ƒéå¯¹ç§°ï¼Œä½†é€šå¸¸ä»ç„¶æ²¿ç”¨ $\\alpha/2$ å’Œ $1-\\alpha/2$ è¿™ä¸¤ä¸ªåˆ†ä½ç‚¹ã€‚è¿™æ ·æ±‚å¾—çš„ç½®ä¿¡åŒºé—´å¯èƒ½å¹¶éæœ€çŸ­ã€‚\n(2) è‹¥ $\\mu$ å·²çŸ¥ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶è¿ç”¨èµ·æ¥ç²¾ç¡®åŒ–æˆ‘ä»¬çš„ç½®ä¿¡åŒºé—´ï¼šå– $U=\\left(\\frac{\\overline{X}-\\mu}{\\sigma/\\sqrt n}\\right)^2$ï¼Œåˆ™ $U\\sim \\chi^2(1)$ã€‚\nConfidence Interval of $\\mu_1-\\mu_2$ in Normal Population ã€ä¾‹ã€‘ç»™å®šç½®ä¿¡åº¦ $1-\\alpha$ï¼Œæ ·æœ¬ $X_1,\\cdots, X_{n_1}$ æ¥è‡ªæ€»ä½“ $X\\sim N(\\mu_1,\\sigma_1^2)$ï¼Œ$Y_1,\\cdots, Y_{n_2}$ æ¥è‡ªæ€»ä½“ $Y\\sim N(\\mu_2,\\sigma_2^2)$ï¼Œè€ƒè™‘å®ƒä»¬çš„å‡å€¼å·® $\\mu_1-\\mu_2$ çš„ç½®ä¿¡åŒºé—´ã€‚å¦‚æœ $\\sigma_1^2$ å’Œ $\\sigma_2^2$ å‡å·²çŸ¥ï¼Œé‚£ä¹ˆ $\\overline{X}\\sim N(\\mu_1,\\frac{\\sigma_1^2}{n_1})$ï¼Œ$\\overline{Y}\\sim N(\\mu_2,\\frac{\\sigma_2^2}{n_2})$ï¼Œ$\\overline{X}-\\overline{Y}\\sim N(\\mu_1-\\mu_2,\\frac{\\sigma_1^2}{n_1}+\\frac{\\sigma_2^2}{n_2})$ã€‚å› æ­¤å– $$ U=\\frac{\\overline{X}-\\overline{Y}-(\\mu_1-\\mu_2)}{\\sqrt{\\frac{\\sigma_1^2}{n_1}+\\frac{\\sigma_2^2}{n_2}}}\\sim N(0,1) $$ ä»è€Œ $$ -u_{\\frac{\\alpha}{2}}\u0026lt;\\frac{\\overline{X}-\\overline{Y}-(\\mu_1-\\mu_2)}{\\sqrt{\\frac{\\sigma_1^2}{n_1}+\\frac{\\sigma_2^2}{n_2}}}\u0026lt;u_{\\frac{\\alpha}{2}}\\Rightarrowç½®ä¿¡åŒºé—´\\left(\\overline{X}-\\overline{Y}-\\sqrt{\\frac{\\sigma_1^2}{n_1}+\\frac{\\sigma_2^2}{n_2}}u_{\\frac{\\alpha}{2}},\\overline{X}-\\overline{Y}+\\sqrt{\\frac{\\sigma_1^2}{n_1}+\\frac{\\sigma_2^2}{n_2}}u_{\\frac{\\alpha}{2}}\\right) $$ è‹¥ä¸çŸ¥é“ $\\sigma_1^2$ å’Œ $\\sigma_2^2$ï¼Œä½†çŸ¥é“ $\\sigma_1^2=\\sigma_2^2=\\sigma^2$ï¼Œé‚£ä¹ˆè€ƒè™‘å¦‚ä¸‹å…¬å¼ï¼š $$ T=\\sqrt{\\frac{n_1n_2(n_1+n_2-2)}{n_1+n_2}}\\frac{(\\overline X-\\overline Y)-(\\mu_1-\\mu_2)}{\\sqrt{(n_1-1)S_X^2+(n_2-1)S_Y^2}}\\sim t(n_1+n_2-2) $$ äºæ˜¯æœ‰ $$ 1-\\alpha=P(-t_{\\alpha/2}(n_1+n_2-2)\u0026lt;T\u0026lt;t_{\\alpha/2}(n_1+n_2-2)) $$ ä»¤ $C_{n_1,n_2}=\\sqrt{\\frac{n_1n_2(n_1+n_2-2)}{n_1+n_2}}\\frac{1}{\\sqrt{(n_1-1)S_X^2+(n_2-1)S_Y^2}}$ï¼Œåˆ™ $$ -t_{\\frac{\\alpha}{2}}(n_1+n_2-2)\u0026lt;C_{n_1,n_2}[(\\overline X-\\overline Y)-(\\mu_1-\\mu_2)]\u0026lt;t_{\\frac{\\alpha}{2}}(n_1+n_2-2) $$ è§£å¾—ç½®ä¿¡åŒºé—´ä¸º $$ \\left(\\overline{X}-\\overline{Y}-\\frac{t_{\\frac{\\alpha}{2}}(n_1+n_2-2)}{C_{n_1,n_2}},\\overline{X}-\\overline{Y}+\\frac{t_{\\frac{\\alpha}{2}}(n_1+n_2-2)}{C_{n_1,n_2}}\\right) $$\nConfidence Interval of $\\frac{\\sigma_1^2}{\\sigma_2^2}$ in Normal Population ã€ä¾‹ã€‘ç»™å®šç½®ä¿¡åº¦ $1-\\alpha$ï¼Œæ ·æœ¬ $X_1,\\cdots, X_{n_1}$ æ¥è‡ªæ€»ä½“ $X\\sim N(\\mu_1,\\sigma_1^2)$ï¼Œ$Y_1,\\cdots, Y_{n_2}$ æ¥è‡ªæ€»ä½“ $Y\\sim N(\\mu_2,\\sigma_2^2)$ï¼Œè€ƒè™‘å®ƒä»¬çš„æ–¹å·®æ¯” $\\frac{\\sigma_1^2}{\\sigma_2^2}$ çš„ç½®ä¿¡åŒºé—´ã€‚è‹¥ $\\mu_1,\\mu_2$ æœªçŸ¥ï¼Œæˆ‘ä»¬è€ƒè™‘æ¢è½´å˜é‡ $$ F=\\frac{S_X^2\\sigma_2^2}{S_Y^2\\sigma_1^2}\\sim F(n_1-1,n_2-2) $$ ä»è€Œ $$ 1-\\alpha=P(F_{1-\\frac{\\alpha}{2}}(n_1-1,n_2-1)\u0026lt;F\u0026lt;F_{\\frac{\\alpha}{2}}(n_1-1,n_2-1)) $$ è§£å¾—ç½®ä¿¡åŒºé—´ä¸º $$ \\left(\\frac{S_X^2}{S_Y^2}\\frac{1}{F_\\frac{\\alpha}{2}(n_1-1,n_2-1)},\\frac{S_X^2}{S_Y^2}\\frac{1}{F_{1-\\frac{\\alpha}{2}}(n_1-1,n_2-1)}\\right) $$ å¦‚æœæˆ‘ä»¬çŸ¥é“æ›´å¤šä¿¡æ¯ï¼Œåˆ™å¯ä»¥ç»™å‡ºæ›´å¥½çš„ä¼°è®¡ï¼Œæ¯”å¦‚ï¼š\nè‹¥ $\\mu_1$ å·²çŸ¥ï¼Œ$\\mu_2$ æœªçŸ¥ï¼Œé‚£ä¹ˆ $\\frac{\\overline X-\\mu_1}{\\sigma_1/\\sqrt{n_1}}\\sim N(0,1)$ï¼Œ$\\frac{(n_2-1)S_Y^2}{\\sigma_2^2}\\sim \\chi^2(n_2-1)$ï¼Œåˆ™ $$ U=\\frac{\\left(\\frac{\\overline X-\\mu_1}{\\sigma_1/\\sqrt{n_1}}\\right)^2}{S_Y^2/\\sigma_2^2}\\sim F(1,n_2-1) $$ (æ³¨ï¼šåˆ†å­æ­£æ€åˆ†å¸ƒçš„å¹³æ–¹ï¼Œå³ä¸€ä¸ªè‡ªç”±åº¦çš„ $\\chi^2$ åˆ†å¸ƒã€‚)\nè‹¥ $\\mu_1,\\mu_2$ å‡å·²çŸ¥ï¼Œåˆ™ $$ U=\\frac{\\left(\\frac{\\overline X-\\mu_1}{\\sigma_1/\\sqrt{n_1}}\\right)^2}{\\left(\\frac{\\overline Y-\\mu_2}{\\sigma_2/\\sqrt{n_2}}\\right)^2}\\sim F(1,1) $$\nInterval Estimation of Unknown Population éæ­£æ€æ€»ä½“å‡å€¼çš„åŒºé—´ä¼°è®¡é€šå¸¸é‡‡ç”¨æ‰€ä¸ºçš„å¤§æ ·æœ¬æ³•ï¼š\nè®¾ $X_1,\\cdots, X_n$ æ¥è‡ªæ€»ä½“ $X$ï¼Œä¸” $E[X]=\\mu,D(X)=\\sigma$ï¼Œè€ƒè™‘è®¡ç®— $\\mu$ çš„ç½®ä¿¡åº¦ä¸º $1-\\alpha$ çš„ç½®ä¿¡åŒºé—´ã€‚ç”±ä¸­å¿ƒæé™å®šç†ï¼Œæœ‰ $$ \\frac{\\sum_{k=1}^nX_k-n\\mu}{\\sqrt n\\sigma}\\to N(0,1) $$ ä»è€Œè€ƒè™‘ $U=\\frac{\\overline{X}-\\mu}{\\sigma/\\sqrt n}\\approx N(0,1)$ï¼Œäºæ˜¯ $1-\\alpha\\approx P(-u_{\\frac{\\alpha}{2}}\u0026lt;U\u0026lt;u_{\\frac{\\alpha}{2}})$ã€‚\nå½“ $\\sigma^2$ å·²çŸ¥æ—¶ï¼Œç½®ä¿¡åŒºé—´ä¸º $(\\overline X-\\frac{u_{\\frac{\\alpha}{2}}\\sigma}{\\sqrt n},\\overline X+\\frac{u_{\\frac{\\alpha}{2}}\\sigma}{\\sqrt n})$ã€‚\nå½“ $\\sigma^2$ æœªçŸ¥æ—¶ï¼Œç”¨ $S$ æ¥ä»£æ›¿ $\\sigma$ã€‚\nã€ä¾‹é¢˜ã€‘è®¾æ€»ä½“æœä» 0-1 åˆ†å¸ƒï¼Œ$X_1,\\cdots, X_n$ ä¸ºæ ·æœ¬ï¼Œæ±‚æ€»ä½“æœŸæœ› $p$ çš„ç½®ä¿¡åº¦ä¸º $1-\\alpha$ çš„ç½®ä¿¡åŒºé—´ã€‚\nè§£æ³•ä¸€ï¼šè¯¥é¢˜è®¾ç¬¦åˆæ–¹å·®æœªçŸ¥çš„æƒ…å½¢ï¼Œæ‰€ä»¥ä½¿ç”¨ç¬¬äºŒä¸ªç»“è®ºï¼Œæ‰€æ±‚åŒºé—´ä¸º $$ \\left(\\overline X-\\frac{u_{\\frac{\\alpha}{2}}S}{\\sqrt n},\\overline X+\\frac{u_{\\frac{\\alpha}{2}}S}{\\sqrt n}\\right) $$ è¿™é‡Œçš„ $S$ æ˜¯ä¸€ä¸ªäºŒé˜¶çš„ç»Ÿè®¡é‡ï¼Œåˆ©ç”¨ 0-1 åˆ†å¸ƒçš„æ€§è´¨ï¼Œæˆ‘ä»¬å¯ä»¥è¿›ä¸€æ­¥åŒ–ç®€å®ƒï¼š $$ \\begin{align} S^2\u0026amp;=\\frac{1}{n-1}\\sum_{k=1}^n(X_k-\\overline{X})^2=\\frac{1}{n-1}\\left(\\sum_{k=1}^nX_k^2-n\\overline{X}^2\\right)\\\\ \u0026amp;\\overset{\\text{0-1åˆ†å¸ƒ}}{=}\\frac{1}{n-1}\\left(\\sum_{k=1}^nX_k-n\\overline{X}^2\\right)\\\\ \u0026amp;=\\frac{n}{n-1}\\overline{X}(1-\\overline{X}) \\end{align} $$ ä»£å…¥åŸå¼å¾—ç½®ä¿¡åŒºé—´ï¼š $$ \\left(\\overline{X}-u_{\\frac{\\alpha}{2}}\\sqrt{\\frac{\\overline{X}(1-\\overline X)}{n-1}},\\overline{X}+u_{\\frac{\\alpha}{2}}\\sqrt{\\frac{\\overline{X}(1-\\overline X)}{n-1}}\\right) $$ è¿™æ ·ç½®ä¿¡åŒºé—´ä¸­åªæœ‰ä¸€é˜¶çš„ç»Ÿè®¡é‡ï¼Œæ›´åŠ å‡†ç¡®ã€‚\nè§£æ³•äºŒï¼šå› ä¸º $\\sum_{k=1}^nX_k\\sim B(n,p)$ï¼Œä¼¯åŠªåˆ©è¯•éªŒä¸­æ–¹å·® $\\sigma=\\sqrt{p(1-p)}$ã€‚æ ¹æ®ä¸­å¿ƒæé™å®šç†ï¼Œ $$ \\frac{\\sum_{k=1}^nX_k-np}{\\sqrt{n}\\sqrt{p(1-p)}}\\to N(0,1) $$ å› æ­¤å¯ä»¥å¾—åˆ°è¿‘ä¼¼çš„ç½®ä¿¡åŒºé—´ $$ \\left(\\overline{X}-u_{\\frac{\\alpha}{2}}\\sqrt{\\frac{p(1-p)}{n}},\\overline{X}+u_{\\frac{\\alpha}{2}}\\sqrt{\\frac{p(1-p)}{n}}\\right) $$ $\\overline{X}$ æ˜¯å¯¹ $p$ çš„ä¸€ä¸ªè¾ƒå¥½çš„ä¼°è®¡ï¼Œå› æ­¤ç”¨ $\\overline{X}$ ä»£æ›¿ $p$ï¼Œå³å¾—åˆ° $$ \\left(\\overline{X}-u_{\\frac{\\alpha}{2}}\\sqrt{\\frac{\\overline{X}(1-\\overline{X})}{n}},\\overline{X}+u_{\\frac{\\alpha}{2}}\\sqrt{\\frac{\\overline{X}(1-\\overline{X})}{n}}\\right) $$ è¯¥åšæ³•æ›´å¥½åœ°åˆ©ç”¨äº† 0-1 åˆ†å¸ƒ (ä¼¯åŠªåˆ©è¯•éªŒ)ï¼Œå› æ­¤ç»™å‡ºçš„åŒºé—´æ›´åŠ ç²¾ç¡®ä¸€äº›ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"f20c941cf151c3086388b7c8c58ac2b8","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-probability/lec21/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-probability/lec21/","section":"notes","summary":"$\\fbox{Definition 21.1}$ è®¾ $\\theta$ æ˜¯æ€»ä½“ $X$ çš„æœªçŸ¥å‚æ•°ï¼Œ$X_1,\\cdots, X_n$ æ˜¯æ¥è‡ª $X$ çš„æ ·æœ¬ï¼Œè‹¥å¯¹äºç»™å®šçš„ $0\u0026lt;\\alpha\u0026lt;1$ï¼Œå­˜åœ¨ä¸¤ä¸ªç»Ÿè®¡é‡ $\\hat\\theta_1(X_1,\\cdots, X_n)$ å’Œ $\\hat\\theta_2(X_1,\\cdots, X_n)$ï¼Œä½¿å¾— $$ P(\\hat\\theta_1\u0026lt;\\theta\u0026lt;\\hat\\theta_2)=1-\\alpha $$ åˆ™ç§° $(\\hat\\theta_1,\\hat\\theta_2)$ æ˜¯ $\\theta$ çš„ç½®ä¿¡åº¦ä¸º $1-\\alpha$ çš„ç½®ä¿¡åŒºé—´ï¼Œ$\\theta_1,\\theta_2$ ç§°ä¸ºç½®ä¿¡ä¸‹é™å’Œç½®ä¿¡ä¸Šé™ï¼Œ$1-\\alpha$ ç§°ä¸ºç½®ä¿¡åº¦æˆ–ç½®ä¿¡ç³»æ•°ã€‚\næ³¨ï¼š(1) ä¸Šé¢æ•°å­¦è¡¨è¾¾å¼çš„å«ä¹‰ä¸ºï¼šåœ¨è¿›è¡Œäº† $m$ è½® (æ¯è½® $n$ æ¬¡) é‡‡æ ·åï¼Œæˆ‘ä»¬ä¼šå¾—åˆ° $m$ ä¸ªåŒºé—´ $(\\hat\\theta_{1,1},\\hat\\theta_{2,1})$ â€¦â€¦ $(\\hat\\theta_{1,m},\\hat\\theta_{2,m})$ã€‚è¿™å…¶ä¸­å¤§çº¦æœ‰ $(1-\\alpha)m$ ä¸ªåŒºé—´åŒ…å«äº† $\\theta$ã€‚å¯¹äºä¸€ç»„å…·ä½“çš„ä¼°è®¡å€¼ $\\hat\\theta_1(x_1,\\cdots,x_n)$ å’Œ $\\hat\\theta_2(x_1,\\cdots, x_n)$ï¼Œæˆ‘ä»¬ä¸èƒ½è¯´ $\\theta$ æœ‰ $1-\\alpha$ çš„æ¦‚ç‡è½åœ¨åŒºé—´ä¸­ï¼Œå› ä¸ºè¿™æ—¶åŒºé—´çš„ä¸Šä¸‹ç•Œå·²ç»æ˜¯ç¡®å®šçš„æ•°äº†ï¼Œä¸å†å…·æœ‰éšæœºæ€§ã€‚","tags":null,"title":"Lecture 21: Interval Estimation","type":"docs"},{"authors":null,"categories":null,"content":"è®¾æ€»ä½“ $X\\sim N(\\mu,\\sigma^2)$ï¼Œæ¬²åˆ¤æ–­ $\\mu$ æ˜¯å¦ä¸ºæŸä¸ªç»™å®šçš„å¸¸æ•° $\\mu_0$ï¼Œæˆ‘ä»¬å°† $\\mu=\\mu_0$ ï¼Œè®°ä¸º $H_0:\\mu=\\mu_0$ï¼Œç§°ä¸ºåŸå‡è®¾æˆ–é›¶å‡è®¾ã€‚å¯¹åº”çš„ï¼Œ$H_1:\\mu\\neq \\mu_0$ ç§°ä¸ºå¤‡æ‹©å‡è®¾æˆ–å¯¹ç«‹å‡è®¾ã€‚ $$ H_0:\\mu=\\mu_0\\qquad H_1:\\mu\\neq \\mu_0 $$ æˆ‘ä»¬ä¹Ÿå¯ä»¥è€ƒè™‘åˆ¤æ–­ $\\mu\\leq \\mu_0$ æ˜¯å¦æˆç«‹ï¼Œè¿™æ—¶çš„åŸå‡è®¾å’Œå¯¹ç«‹å‡è®¾ä¸º $$ H_0:\\mu\\leq \\mu_0\\qquad H_1:\\mu\u0026gt;\\mu_0 $$ ç¬¬ä¸€ç§å‡è®¾ç§°ä¸ºåŒè¾¹æ£€éªŒ (å¯¹ç«‹å‡è®¾å±…äºåŸå‡è®¾ä¸¤è¾¹)ï¼Œç¬¬äºŒç§åˆ™æ˜¯å•è¾¹æ£€éªŒã€‚ä¸Šè¿°ä¸¤ç§å‡è®¾åªæ¶‰åŠå·²çŸ¥æ€»ä½“çš„æœªçŸ¥å‚æ•°ï¼Œç§°ä¸ºå‚æ•°å‡è®¾æ£€éªŒ (åƒ $H_0:Xæœä»æ­£æ€åˆ†å¸ƒ$ å°±æ˜¯éå‚æ•°å‡è®¾æ£€éªŒ)ã€‚\nä»¥ç¬¬ä¸€ç§å‡è®¾ä¸ºä¾‹ä»‹ç»å‡è®¾æ£€éªŒçš„ä¸€èˆ¬æ–¹æ³•ï¼š$\\overline{X}$ æ˜¯ $\\mu$ çš„ä¸€ä¸ªæ¯”è¾ƒå¥½çš„ä¼°è®¡ï¼Œå› æ­¤ $|\\overline{X}-\\mu_0|$ åº”è¯¥ä¸å¤ªå¤§ã€‚æˆ‘ä»¬å¸Œæœ›æ‰¾åˆ°ä¸€ä¸ªé˜ˆå€¼ $k$ï¼Œå½“ $|\\overline{X}-\\mu_0|\u0026lt; k$ æ—¶ï¼Œæˆ‘ä»¬è®¤ä¸ºå‡è®¾æˆç«‹ã€‚é—®é¢˜çš„å…³é”®åœ¨äºå¦‚ä½•é€‰å– $k$ã€‚åœ¨ $H_0$ æˆç«‹çš„æƒ…å†µä¸‹ï¼Œ$\\overline{X}\\sim N(\\mu_0,\\frac{\\sigma^2}{n})$ã€‚è€ƒè™‘ $\\sigma^2$ å·²çŸ¥çš„æƒ…å½¢ï¼Œåˆ™ $U=\\frac{\\overline{X}-\\mu_0}{\\sigma/\\sqrt n}\\sim N(0,1)$ã€‚$|\\overline{X}-\\mu_0|\\geq k$ æ„å‘³ç€ $|U|\\geq \\frac{k}{\\sigma/\\sqrt n}$ï¼Œæ•… $k$ çš„é€‰å–åº”å½“ä½¿å¾— $P\\left(|U|\\geq \\frac{k}{\\sigma/\\sqrt n}\\right)$ è¶³å¤Ÿå°ã€‚ç»™å®šä¸€ä¸ªå°æ¦‚ç‡ $\\alpha$ (å¸¸ç”¨å€¼ï¼š0.1, 0.05, 0.01)ï¼Œä»¤ $P(|U|\\geq \\frac{k}{\\sigma/\\sqrt n})=\\alpha$ï¼Œå³å¯ç¡®å®š $\\frac{k}{\\sigma/\\sqrt n}=u_{\\frac{\\alpha}{2}}$ã€‚\næˆ‘ä»¬æŠŠ $U$ ç§°ä¸ºæ£€éªŒç»Ÿè®¡é‡ï¼Œ$\\alpha$ ç§°ä¸ºæ˜¾è‘—æ€§æ°´å¹³ï¼Œ$u_{\\frac{\\alpha}{2}}=\\frac{k}{\\sigma/\\sqrt n}$ ç§°ä¸ºä¸´ç•Œå€¼ã€‚$W={|U|\\geq u_{\\frac{\\alpha}{2}}}$ ç§°ä¸ºæ‹’ç»åŸŸï¼Œ$\\overline{W}$ ç§°ä¸ºæ¥å—åŸŸã€‚\nåŸºæœ¬æ­¥éª¤ï¼š\næ ¹æ®é—®é¢˜æå‡º $H_0$ å’Œ $H_1$ã€‚ æ„é€ ä¸€ä¸ªåˆé€‚çš„ç»Ÿè®¡é‡ï¼Œåœ¨ $H_0$ æˆç«‹çš„æ¡ä»¶ä¸‹æ±‚è¯¥ç»Ÿè®¡é‡çš„åˆ†å¸ƒã€‚ ç»™å‡ºå°æ¦‚ç‡ $\\alpha$ï¼Œç¡®å®šä¸´ç•Œå€¼å’Œæ‹’ç»åŸŸ $W$ã€‚ ç”±æ ·æœ¬ç®—å‡ºè§‚å¯Ÿå€¼ï¼Œè‹¥å…¶è½å…¥ $W$ï¼Œåˆ™æ‹’ç» $H_0$ï¼Œå¦åˆ™æ¥å— $H_0$ã€‚ å‡è®¾æ£€éªŒçš„ä¸¤ç±»é”™è¯¯ï¼š\nå¼ƒçœŸé”™è¯¯ï¼š$H_0$ æ­£ç¡®å´æ‹’ç»äº† $H_0$ã€‚$P(æ‹’ç»H_0|H_0ä¸ºçœŸ)=P(U\\in W|H_0ä¸ºçœŸ)=\\alpha$ã€‚ å­˜ä¼ªé”™è¯¯ï¼š$H_0$ é”™è¯¯å´æ¥å—äº† $H_0$ã€‚$P(æ¥å—H_0|H_1ä¸ºçœŸ)=P(U\\notin W|H_1ä¸ºçœŸ)=\\beta$ã€‚ é€šå¸¸æ¥è¯´ $\\beta$ ä¸å®¹æ˜“æ±‚å¾—ã€‚$\\alpha$ å’Œ $\\beta$ ä¸èƒ½åŒæ—¶å‡å°ï¼Œæˆ‘ä»¬é€šå¸¸åœ¨æ§åˆ¶ $\\alpha$ è¶³å¤Ÿå°çš„æƒ…å†µä¸‹å°½å¯èƒ½å‡å° $\\beta$ (Neyman-Pearson åŸåˆ™)ï¼Œå³æ‹’ç» $H_0$ éœ€è¦æ›´å……åˆ†çš„ç†ç”±ï¼Œ$H_0$ åœ°ä½é«˜äº $H_1$ã€‚\nã€ä¾‹é¢˜ã€‘è®¾ $X\\sim N(\\mu,1)$ï¼Œ$X_1,\\cdots, X_n$ ä¸ºæ ·æœ¬ã€‚åœ¨ç»™å®šæ˜¾è‘—æ€§æ°´å¹³ $\\alpha$ çš„æƒ…å†µä¸‹æ±‚ $H_0:\\mu=\\mu_0$ï¼Œ$H_1:\\mu=\\mu_1$ çš„ç¬¬äºŒç±»é”™è¯¯æ¦‚ç‡ $\\beta$ã€‚\nè§£ï¼šåœ¨ $H_0$ ä¸‹ï¼Œæˆ‘ä»¬ä¼šæ„é€  $U=\\frac{\\overline X-\\mu_0}{1/\\sqrt n}=\\sqrt n(\\overline X-\\mu_0)\\sim N(0,1)$ã€‚ä½†ç°åœ¨ $H_1$ æˆç«‹ï¼Œå› æ­¤ $U$ å®é™…æœä»çš„åˆ†å¸ƒä¸º $$ U=\\sqrt n(\\overline X-\\mu_0)=\\sqrt n(\\overline X-\\mu_1)+\\sqrt n(\\mu_1-\\mu_0)\\sim N(\\sqrt n(\\mu_1-\\mu_0),1) $$ æ ¹æ® $\\beta$ çš„å®šä¹‰ï¼Œ $$ \\begin{align} \\beta\u0026amp;=P(U\\notin W|H_1ä¸ºçœŸ)=P(|U|\u0026lt;u_{\\frac{\\alpha}{2}}|\\mu=\\mu_1)\\\\ \u0026amp;=P(-u_{\\frac{\\alpha}{2}}-\\sqrt n(\\mu_1-\\mu_0)\u0026lt;\\sqrt n(\\overline{X}-\\mu_1)\u0026lt;u_{\\frac{\\alpha}{2}}-\\sqrt n(\\mu_1-\\mu_0)|\\mu=\\mu_1)\\\\ \u0026amp;=\\Phi(u_{\\frac{\\alpha}{2}}-\\sqrt n(\\mu_1-\\mu_0))-\\Phi(-u_{\\frac{\\alpha}{2}}-\\sqrt n(\\mu_1-\\mu_0)) \\end{align} $$\nMean Value Test of Normal Population æ€»ä½“ $X\\sim N(\\mu,\\sigma^2)$ï¼Œ$X_1,\\cdots,X_n$ ä¸ºæ ·æœ¬ï¼Œç»™å®š $\\alpha$ã€‚\n$u$ Test åœ¨ $\\sigma^2$ å·²çŸ¥çš„æƒ…å†µä¸‹ï¼Œ$H_0:\\mu=\\mu_0,H_1:\\mu\\neq \\mu_0$ã€‚è€ƒè™‘ $U=\\frac{\\overline{X}-\\mu}{\\sigma/\\sqrt n}\\sim N(0,1)$ã€‚å®¹æ˜“å¾—å‡ºä¸´ç•Œå€¼ $P(|U|\u0026gt;u_{\\frac{\\alpha}{2}})=\\alpha$ï¼Œæ‹’ç»åŸŸ $W=\\left\\{\\left|\\frac{\\overline{X}-\\mu_0}{\\sigma/\\sqrt n}\\right|\u0026gt;u_{\\frac{\\alpha}{2}}\\right\\}$ã€‚\nå¦‚æœåšå•è¾¹æ£€éªŒï¼š$H_0:\\mu=\\mu_0,H_1:\\mu\u0026gt;\\mu_0$ï¼Œåˆ™ä¸´ç•Œå€¼ä¸º $u_\\alpha$ï¼Œæ‹’ç»åŸŸï¼š$W=\\left\\{\\frac{\\overline{X}-\\mu_0}{\\sigma/\\sqrt n}\u0026gt;u_\\alpha\\right\\}$ã€‚\nè‹¥å‡è®¾ä¸º $H_0:\\mu\\leq \\mu_0,H_1:\\mu\u0026gt;\\mu_0$ã€‚æˆ‘ä»¬çš„æ‹’ç»åŸŸ $W$ åº”è¯¥æ»¡è¶³ $P(U\\in W|H_0)\\leq \\alpha$ã€‚æˆ‘ä»¬å‘ç° $\\mu_0$ æ˜¯ $\\mu$ çš„ä¸Šç•Œï¼Œå› æ­¤ $$ P\\left(\\left.\\frac{\\overline{X}-\\mu_0}{\\sigma/\\sqrt n}\u0026gt;\\lambda_\\alpha\\right|\\mu\\leq \\mu_0\\right)\\leq P\\left(\\left.\\frac{\\overline{X}-\\mu}{\\sigma/\\sqrt n}\u0026gt;\\lambda_\\alpha\\right|\\mu\\leq \\mu_0\\right) $$ ä»¤å³å¼ç­‰äº $\\alpha$ï¼Œå› ä¸º $\\frac{\\overline{X}-\\mu}{\\sigma/\\sqrt n}\\sim N(0,1)$ï¼Œæ‰€ä»¥è§£å¾— $\\lambda_\\alpha=u_\\alpha$ã€‚æ‹’ç»åŸŸï¼š$W=\\left\\{\\frac{\\overline{X}-\\mu_0}{\\sigma/\\sqrt n}\u0026gt;u_\\alpha\\right\\}$ã€‚\n$t$ Test åœ¨ $\\sigma^2$ æœªçŸ¥çš„æƒ…å†µä¸‹ï¼Œ$H_0:\\mu=\\mu_0,H_1:\\mu\\neq \\mu_0$ï¼Œå– $$ T=\\frac{\\sqrt n(\\overline{X}-\\mu_0)}{S}\\sim t(n-1) $$ å¯è§£å‡ºæ‹’ç»åŸŸ $W=\\left\\{|T|\u0026gt;t_{\\frac{\\alpha}{2}}(n-1)\\right\\}$ã€‚\nTest of the Difference of Mean Values of Two Normal Populations æ€»ä½“ $X\\sim N(\\mu_1,\\sigma_1^2),Y\\sim N(\\mu_2,\\sigma_2^2)$ã€‚å‡è®¾ $H_0:\\mu_1=\\mu_2,H_1:\\mu_1\\neq \\mu_2$ã€‚è€ƒè™‘ä»¥ä¸‹å‡ ç§æƒ…å†µï¼š\n(1) $\\sigma_1^2,\\sigma_2^2$ å·²çŸ¥ï¼Œå– $$ U=\\frac{\\overline X-\\overline Y-(\\mu_1-\\mu_2)}{\\sqrt{\\frac{\\sigma_1^2}{n_1}+\\frac{\\sigma_2^2}{n_2}}}\\overset{åœ¨H_0ä¸‹}{=}\\frac{\\overline X-\\overline Y}{\\sqrt{\\frac{\\sigma_1^2}{n_1}+\\frac{\\sigma_2^2}{n_2}}}\\sim N(0,1) $$ å› æ­¤æ‹’ç»åŸŸ $$ W=\\left\\{\\left|\\frac{\\overline X-\\overline Y}{\\sqrt{\\frac{\\sigma_1^2}{n_1}+\\frac{\\sigma_2^2}{n_2}}}\\right|\u0026gt;u_{\\frac{\\alpha}{2}}\\right\\} $$ (2) $\\sigma_1^2=\\sigma_2^2=\\sigma^2$ ä½†æœªçŸ¥ï¼Œå– $$ T=\\sqrt{\\frac{n_1n_2(n_1+n_2-2)}{n_1+n_2}}\\frac{(\\overline X-\\overline Y)-(\\mu_1-\\mu_2)}{\\sqrt{(n_1-1)S_X^2+(n_2-1)S_Y^2}}\\sim t(n_1+n_2-2) $$ (ç±»ä¼¼åœ°ï¼Œåœ¨ $H_0$ ä¸‹ï¼Œ$\\mu_1-\\mu_2$ å¯ä»¥æ¶ˆå»)\nå› æ­¤æ‹’ç»åŸŸ $$ W=\\left\\{|T|\u0026gt;t_{\\frac{\\alpha}{2}}(n_1+n_2-2)\\right\\} $$\nPairwise $t$ Test å¦å¤–ä¸€ç§æƒ…å†µæ˜¯ï¼Œ$X,Y$ åˆ†å¸ƒæœªçŸ¥ä¸”ç›¸å…³ï¼Œä½† $Z=X-Y\\sim N(\\mu,\\sigma^2)$ã€‚æˆ‘ä»¬æƒ³è¦æ£€éªŒè¿™ä¸¤ä¸ªåˆ†å¸ƒæ˜¯å¦æ¥è¿‘ã€‚å‡è®¾ $H_0:\\mu=0,H_1:\\mu\\neq 0$ã€‚é‚£ä¹ˆå– $$ T=\\frac{\\sqrt n(\\overline{Z}-\\mu)}{S_Z}\\overset{åœ¨H_0ä¸‹}{=}\\frac{\\sqrt n\\overline{Z}}{S_Z}\\sim t(n-1) $$ æ‹’ç»åŸŸ $$ W=\\left\\{|T|\u0026gt;t_{\\frac{\\alpha}{2}}(n-1)\\right\\} $$\nVariance Test of Normal Population è®¾ $X\\sim N(\\mu,\\sigma^2)$ï¼Œ$X_1,\\cdots, X_n$ æ¥è‡ªæ€»ä½“ $X$ï¼Œ$\\alpha$ ä¸ºæ˜¾è‘—æ°´å¹³ã€‚è‹¥ $\\mu$ æœªçŸ¥ï¼Œå‡è®¾ $H_0:\\sigma^2=\\sigma_0^2,H_1:\\sigma^2\\neq \\sigma_0^2$ï¼Œè€ƒè™‘å˜é‡ $$ \\chi^2=\\frac{(n-1)S^2}{\\sigma_0^2}\\sim \\chi^2(n-1) $$ å› æ­¤æ‹’ç»åŸŸ $$ W={\\chi^2\u0026lt;\\chi_{1-\\frac{\\alpha}{2}}^2(n-1)}\\cup{\\chi^2\u0026gt;\\chi^2_{\\frac{\\alpha}{2}}(n-1)} $$ ä¸¤æ­£æ€æ€»ä½“æ–¹å·®æ¯”å€¼çš„æ£€éªŒï¼šè®¾ $X\\sim N(\\mu,\\sigma^2)$ï¼Œ$X_1,\\cdots, X_n$ æ¥è‡ªæ€»ä½“ $X$ï¼Œ$\\alpha$ ä¸ºæ˜¾è‘—æ°´å¹³ã€‚è¿™æ¬¡åˆ©ç”¨ F åˆ†å¸ƒ $$ F=\\frac{S_1^2\\sigma_2^2}{S_2^2\\sigma_1^2}\\sim F(n_1-1,n_2-2) $$ å› æ­¤æ‹’ç»åŸŸ $$ W={F\u0026lt;F_{1-\\frac{\\alpha}{2}}(n_1-1,n_2-1)}\\cup {F\u0026gt;F_{\\frac{\\alpha}{2}}(n_1-1,n_2-1)} $$\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"a553e3b6607870f0024eeb18d8a0e42f","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-probability/lec22/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-probability/lec22/","section":"notes","summary":"è®¾æ€»ä½“ $X\\sim N(\\mu,\\sigma^2)$ï¼Œæ¬²åˆ¤æ–­ $\\mu$ æ˜¯å¦ä¸ºæŸä¸ªç»™å®šçš„å¸¸æ•° $\\mu_0$ï¼Œæˆ‘ä»¬å°† $\\mu=\\mu_0$ ï¼Œè®°ä¸º $H_0:\\mu=\\mu_0$ï¼Œç§°ä¸ºåŸå‡è®¾æˆ–é›¶å‡è®¾ã€‚å¯¹åº”çš„ï¼Œ$H_1:\\mu\\neq \\mu_0$ ç§°ä¸ºå¤‡æ‹©å‡è®¾æˆ–å¯¹ç«‹å‡è®¾ã€‚ $$ H_0:\\mu=\\mu_0\\qquad H_1:\\mu\\neq \\mu_0 $$ æˆ‘ä»¬ä¹Ÿå¯ä»¥è€ƒè™‘åˆ¤æ–­ $\\mu\\leq \\mu_0$ æ˜¯å¦æˆç«‹ï¼Œè¿™æ—¶çš„åŸå‡è®¾å’Œå¯¹ç«‹å‡è®¾ä¸º $$ H_0:\\mu\\leq \\mu_0\\qquad H_1:\\mu\u0026gt;\\mu_0 $$ ç¬¬ä¸€ç§å‡è®¾ç§°ä¸ºåŒè¾¹æ£€éªŒ (å¯¹ç«‹å‡è®¾å±…äºåŸå‡è®¾ä¸¤è¾¹)ï¼Œç¬¬äºŒç§åˆ™æ˜¯å•è¾¹æ£€éªŒã€‚ä¸Šè¿°ä¸¤ç§å‡è®¾åªæ¶‰åŠå·²çŸ¥æ€»ä½“çš„æœªçŸ¥å‚æ•°ï¼Œç§°ä¸ºå‚æ•°å‡è®¾æ£€éªŒ (åƒ $H_0:Xæœä»æ­£æ€åˆ†å¸ƒ$ å°±æ˜¯éå‚æ•°å‡è®¾æ£€éªŒ)ã€‚","tags":null,"title":"Lecture 22: Hypothesis Test","type":"docs"},{"authors":null,"categories":null,"content":"çŸ©æ¯å‡½æ•°æ˜¯å¿«é€Ÿæ±‚è§£é«˜é˜¶çŸ©çš„åˆ©å™¨ã€‚\nDefinitions and Properties $\\fbox{Definition 1}$ ($k$ é˜¶çŸ©) è®¾ $X$ æ˜¯ä¸€ä¸ªæ¦‚ç‡å¯†åº¦ä¸º $f$ çš„éšæœºå˜é‡ã€‚è‹¥ $X$ æ˜¯ç¦»æ•£çš„ï¼Œåˆ™å®ƒçš„ $k$ é˜¶çŸ© (è®°ä½œ $\\mu_k$) å®šä¹‰ä¸º $$ \\mu_k\\triangleq \\sum_{m=0}^{\\infty}x_m^kf(x_m) $$ è‹¥ $X$ æ˜¯è¿ç»­çš„ï¼Œåˆ™å®ƒçš„ $k$ é˜¶çŸ©å®šä¹‰ä¸º $$ \\mu_k\\triangleq \\int_{-\\infty}^{+\\infty}x^kf(x)\\text{d}x $$ $\\fbox{Definition 2}$ (çŸ©æ¯å‡½æ•°) è®¾ $X$ æ˜¯ä¸€ä¸ªæ¦‚ç‡å¯†åº¦ä¸º $f$ çš„éšæœºå˜é‡ï¼Œåˆ™å…¶çŸ©æ¯å‡½æ•° $M_X(t)$ å®šä¹‰ä¸º $\\mathbb E[e^{tX}]$ã€‚å…·ä½“åœ°è¯´ï¼Œè‹¥ $X$ æ˜¯ç¦»æ•£çš„ï¼Œåˆ™ $$ M_X(t)\\triangleq \\sum_{m=0}^\\infty e^{tx_m}f(x_m) $$ è‹¥ $X$ æ˜¯è¿ç»­çš„ï¼Œåˆ™ $$ M_X(t)\\triangleq \\int_{-\\infty}^{+\\infty}e^{tx}f(x)\\text{d}x $$ çŸ©æ¯å‡½æ•°æœ‰å¦‚ä¸‹é‡è¦æ€§è´¨ï¼š\n$$ M_X(t)=\\sum_{k=0}^\\infty\\mu_k\\frac{t^k}{k!} $$\nè¯æ˜ï¼šæ­¤å¤„ä»…è¯æ˜è¿ç»­æƒ…å½¢ã€‚è€ƒè™‘å°†çŸ©æ¯å‡½æ•°ä¸­çš„ $e^{tx}$ æ³°å‹’å±•å¼€ï¼Œåˆ™æœ‰ $$ \\begin{align} M_X(t)\u0026amp;=\\int_{-\\infty}^{+\\infty}e^{tx}f(x)\\text{d}x\\\\ \u0026amp;=\\int_{-\\infty}^{+\\infty}\\left(\\sum_{k=0}^\\infty\\frac{(tx)^k}{k!}\\right)f(x)\\text{d}x\\\\ \u0026amp;=\\sum_{k=0}^\\infty\\frac{t^k}{k!}\\int_{-\\infty}^{+\\infty}x^kf(x)\\text{d}x\\\\ \u0026amp;=\\sum_{k=0}^\\infty\\frac{t^k}{k!}\\mu_k\\qquad \\blacksquare \\end{align} $$\nå› æ­¤æˆ‘ä»¬å¯ä»¥é€šè¿‡å¯¹çŸ©æ¯å‡½æ•°æ±‚å¯¼çš„æ–¹å¼æ¥å¿«é€Ÿè·å¾—ä¸€ä¸ªéšæœºå˜é‡çš„å„ä¸ª $k$ é˜¶çŸ©ï¼š $$ \\mu_k=\\left.\\frac{\\text{d}^kM_X(t)}{\\text{d}x^k}\\right|_{t=0} $$\nè®¾ $\\alpha$ å’Œ $\\beta$ ä¸ºå¸¸æ•°ï¼Œé‚£ä¹ˆ $$ M_{\\alpha X+\\beta}(t)=e^{\\beta t}M_X(\\alpha t) $$\nè¯æ˜ï¼š $$ \\begin{align} M_{\\alpha X+\\beta}(t)=\\mathbb E[e^{t(\\alpha X+\\beta)}]=e^{\\beta t}\\mathbb E[e^{\\alpha t\\cdot X}]=e^{\\beta t}M_X(\\alpha t)\\qquad \\blacksquare \\end{align} $$\nè®¾ $X_1$ å’Œ $X_2$ ä¸ºäº’ç›¸ç‹¬ç«‹çš„ä¸¤ä¸ªéšæœºå˜é‡ï¼Œä¸” $|t|\u0026lt;\\delta$ æ—¶ $M_{X_1}(t)$ å’Œ $M_{X_2}(t)$ å‡æ”¶æ•›ï¼Œé‚£ä¹ˆ $$ M_{X_1+X_2}(t)=M_{X_1}(t)\\cdot M_{X_2}(t) $$\nè¯æ˜ï¼š $$ \\begin{align} M_{X_1+X_2}(t)=\\mathbb E[e^{t(X_1+X_2)}]=\\mathbb E[e^{tX_1}\\cdot e^{tX_2}]=\\mathbb E[e^{tX_1}]\\cdot \\mathbb E[e^{tX_2}]=M_{X_1}(t)\\cdot M_{X_2}(t)\\qquad \\blacksquare \\end{align} $$\nMGF of Common Distribution Bernoulli Distribution è®¾ $X\\sim B(n,p)$ï¼Œå³ $P(X=k)=f(k)=\\binom{n}{k}p^k(1-p)^{n-k}$ï¼Œé‚£ä¹ˆ $$ \\begin{align} M_X(t)\u0026amp;=\\sum_{k=0}^\\infty e^{tk}f(k)\\\\ \u0026amp;=\\sum_{k=0}^n e^{tk}\\binom{n}{k}p^k(1-p)^{n-k}\\\\ \u0026amp;=\\sum_{k=0}^n\\binom{n}{k}(e^tp)^k(1-p)^{n-k}\\\\ \u0026amp;=(e^tp+1-p)^n \\end{align} $$\nPoisson Distribution è®¾ $X\\sim p(\\lambda)$ï¼Œå³ $P(X=k)=f(k)=\\frac{\\lambda^ke^{-\\lambda}}{k!}$ï¼Œé‚£ä¹ˆ $$ \\begin{align} M_X(t)\u0026amp;=\\sum_{k=0}^\\infty e^{tk}f(k)\\\\ \u0026amp;=\\sum_{k=0}^\\infty e^{tk}\\cdot \\frac{\\lambda^ke^{-\\lambda}}{k!}\\\\ \u0026amp;=e^{-\\lambda}\\sum_{k=0}^\\infty\\frac{(\\lambda e^t)^k}{k!}\\\\ \u0026amp;=e^{-\\lambda}\\cdot e^{\\lambda e^t}=e^{\\lambda(e^t-1)} \\end{align} $$\nNormal Distribution æˆ‘ä»¬é¦–å…ˆè€ƒè™‘æ ‡å‡†æ­£æ€åˆ†å¸ƒï¼šè®¾ $Y\\sim N(0,1)$ï¼Œé‚£ä¹ˆ $Y$ çš„å¯†åº¦å‡½æ•° $f(y)=\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{y^2}{2}}$ï¼Œä»è€Œ $$ \\begin{align} M_Y(t)\u0026amp;=\\mathbb E[e^{tY}]=\\int_{-\\infty}^{+\\infty}e^{ty}f(y)\\text{d}y\\\\ \u0026amp;=\\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{+\\infty}e^{-\\frac{y^2}{2}+ty}\\text{d}y\\\\ \u0026amp;=e^{\\frac{1}{2}t^2}\\cdot \\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^{+\\infty}e^{-\\frac{1}{2}(y-t)^2}\\text{d}y \\end{align} $$ æ³¨æ„åˆ°ååŠéƒ¨åˆ†æ°å¥½æ˜¯ $N(t,1)$ çš„æ¦‚ç‡å¯†åº¦å‡½æ•°åœ¨ $\\mathbb R$ ä¸Šçš„ç§¯åˆ†ï¼Œå› æ­¤ååŠéƒ¨åˆ†ä¸º 1ï¼Œä»è€Œ $M_Y(t)=e^{\\frac{1}{2}t^2}$ã€‚\nå¯¹äºä¸€èˆ¬çš„æ­£æ€åˆ†å¸ƒ $X\\sim N(\\mu,\\sigma^2)$ï¼Œæ³¨æ„åˆ° $\\frac{X-\\mu}{\\sigma}=Y$ï¼Œå³ $X=\\sigma Y+\\mu$ï¼Œå› æ­¤æ ¹æ®çŸ©æ¯å‡½æ•°çš„æ€§è´¨ï¼Œ $$ M_X(t)=M_{\\sigma Y+\\mu}(t)=e^{\\mu t}M_Y(\\sigma t)=e^{\\mu t+\\frac{1}{2}\\sigma^2t^2} $$ æ­£æ€åˆ†å¸ƒçš„çŸ©æ¯å‡½æ•°æ°å¥½å°±æ˜¯å¯¹æ•°æ­£æ€åˆ†å¸ƒçš„ $k$ é˜¶çŸ©ï¼Œæ¨å¯¼è¿‡ç¨‹å¦‚ä¸‹ï¼šå‡è®¾ $X$ æœä»å¯¹æ•°æ­£æ€åˆ†å¸ƒï¼Œé‚£ä¹ˆ $\\ln X\\sim N(\\mu,\\sigma)$ï¼Œä»è€Œ $$ \\mathbb E[X^k]=\\mathbb E[(e^{\\ln X})^k]=\\mathbb E[e^{k\\ln X}]=M_{\\ln X}(k)=e^{\\mu k+\\frac{1}{2}\\sigma^2k^2} $$ æ³¨ï¼šå¯¹æ•°æ­£æ€åˆ†å¸ƒæ²¡æœ‰çŸ©æ¯å‡½æ•°ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"99d0bcf0b387e7bc896ab072df6dc887","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-probability/mgf/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-probability/mgf/","section":"notes","summary":"çŸ©æ¯å‡½æ•°æ˜¯å¿«é€Ÿæ±‚è§£é«˜é˜¶çŸ©çš„åˆ©å™¨ã€‚\nDefinitions and Properties $\\fbox{Definition 1}$ ($k$ é˜¶çŸ©) è®¾ $X$ æ˜¯ä¸€ä¸ªæ¦‚ç‡å¯†åº¦ä¸º $f$ çš„éšæœºå˜é‡ã€‚è‹¥ $X$ æ˜¯ç¦»æ•£çš„ï¼Œåˆ™å®ƒçš„ $k$ é˜¶çŸ© (è®°ä½œ $\\mu_k$) å®šä¹‰ä¸º $$ \\mu_k\\triangleq \\sum_{m=0}^{\\infty}x_m^kf(x_m) $$ è‹¥ $X$ æ˜¯è¿ç»­çš„ï¼Œåˆ™å®ƒçš„ $k$ é˜¶çŸ©å®šä¹‰ä¸º $$ \\mu_k\\triangleq \\int_{-\\infty}^{+\\infty}x^kf(x)\\text{d}x $$ $\\fbox{Definition 2}$ (çŸ©æ¯å‡½æ•°) è®¾ $X$ æ˜¯ä¸€ä¸ªæ¦‚ç‡å¯†åº¦ä¸º $f$ çš„éšæœºå˜é‡ï¼Œåˆ™å…¶çŸ©æ¯å‡½æ•° $M_X(t)$ å®šä¹‰ä¸º $\\mathbb E[e^{tX}]$ã€‚å…·ä½“åœ°è¯´ï¼Œè‹¥ $X$ æ˜¯ç¦»æ•£çš„ï¼Œåˆ™ $$ M_X(t)\\triangleq \\sum_{m=0}^\\infty e^{tx_m}f(x_m) $$ è‹¥ $X$ æ˜¯è¿ç»­çš„ï¼Œåˆ™ $$ M_X(t)\\triangleq \\int_{-\\infty}^{+\\infty}e^{tx}f(x)\\text{d}x $$ çŸ©æ¯å‡½æ•°æœ‰å¦‚ä¸‹é‡è¦æ€§è´¨ï¼š","tags":null,"title":"Moment Generating Function","type":"docs"},{"authors":null,"categories":null,"content":"è¯¥å®éªŒä¸»è¦ç›®çš„æ˜¯å®ç°ä¸€ä¸ªç²¾ç®€ç‰ˆçš„ Linux pstree å‘½ä»¤è¡Œå·¥å…·ï¼Œä»¥è¾ƒä¸ºä¼˜ç¾çš„æ–¹å¼æ‰“å°å½“å‰ç³»ç»Ÿä¸­çš„è¿›ç¨‹æ ‘ã€‚\nParse args é¦–å…ˆå¯¹è¾“å…¥çš„é€‰é¡¹åˆ—è¡¨è¿›è¡Œåˆ†æã€‚ç¬”è€…ä½¿ç”¨äº† C åº“å‡½æ•° getopt_long()ï¼Œå®ƒä¸ä»…å¯ä»¥å¸®åŠ©æˆ‘ä»¬å¿«é€Ÿè§£æé€‰é¡¹ï¼Œè¿˜å¯ä»¥åŒæ—¶è¯†åˆ«ä¸€ä¸ªé€‰é¡¹çš„é•¿çŸ­ç‰ˆæœ¬ (ä½¿ç”¨ C åº“æä¾›çš„ option ç»“æ„ä½“å¯ä»¥å®šä¹‰æ¯ç§é€‰é¡¹çš„é•¿çŸ­ç‰ˆæœ¬ä»¥åŠæ˜¯å¦éœ€è¦å‚æ•°ç­‰)ï¼Œè¯†åˆ«å¤šä¸ªé€‰å¸çº³æ›´åˆå¹¶ç»™å‡ºçš„æ ¼å¼ etc.ã€‚\nå®šä¹‰å¥½è¡¨æ ¼åï¼Œä»…éœ€ä¸€å¥è¯å³å¯å®Œæˆé€‰é¡¹è§£æï¼š\nconst struct option table[] = { {\u0026quot;numeric-sort\u0026quot;, no_argument, NULL, 'n'}, {\u0026quot;show-pids\u0026quot; , no_argument, NULL, 'p'}, {\u0026quot;version\u0026quot; , no_argument, NULL, 'V'}, {0 , 0 , NULL, 0 }, }; getopt_long(argc, argv, \u0026quot;-npV\u0026quot;, table, NULL) å…³äºç‰ˆæœ¬ä¿¡æ¯\nLinux çš„ pstree å·¥å…·ä¼šå°†ç‰ˆæœ¬ä¿¡æ¯è¾“å‡ºåˆ°æ ‡å‡†é”™è¯¯æµï¼Œä¸ºäº†æ¨¡æ‹Ÿè¿™ä¸€ç‰¹æ€§ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ fprintf è¯­å¥å°†ç‰ˆæœ¬ä¿¡æ¯è¾“å‡ºåˆ° stderr æ–‡ä»¶ã€‚\nFetch Process Information Linux æä¾› procfsï¼Œæˆ‘ä»¬å¯ä»¥ç”¨è¯»å†™æ–‡ä»¶çš„ API æ¥è·å–æ“ä½œç³»ç»Ÿä¸­çš„è¿›ç¨‹çŠ¶æ€ã€‚procfs çš„æ ¹ç›®å½•æ˜¯ /procï¼Œè¯¥ç›®å½•ä¸­æ‰€æœ‰æ˜¯æ•°å­—çš„æ–‡ä»¶å¤¹éƒ½å­˜å‚¨äº†ä¸€ä¸ªè¿›ç¨‹ç›¸å…³çš„ä¿¡æ¯ï¼Œæ–‡ä»¶å¤¹çš„æ•°å­—åå°±æ˜¯è¿›ç¨‹ç¼–å·ã€‚é…åˆä½¿ç”¨ C åº“å‡½æ•° opendir() å’Œ readdir() å°±å¯ä»¥éå† /proc ä¸‹çš„æ‰€æœ‰å†…å®¹å¹¶ç­›é€‰å‡ºé‚£äº›æ˜¯æ•°å­—çš„æ–‡ä»¶å¤¹åã€‚\næ¯ä¸ªè¿›ç¨‹æ–‡ä»¶å¤¹ä¸‹çš„ /proc/[pid]/stat æ–‡ä»¶ä¸­å­˜å‚¨äº†æˆ‘ä»¬æ‰“å°è¿›ç¨‹æ ‘æ‰€éœ€è¦çš„çŠ¶æ€ä¿¡æ¯ï¼ŒåŒ…æ‹¬ä½†ä¸é™äºè¿›ç¨‹çš„åå­—ï¼Œè¿›ç¨‹çš„çŠ¶æ€ï¼Œè¿›ç¨‹å·ï¼Œçˆ¶è¿›ç¨‹å·ç­‰ã€‚æˆ‘ä»¬å¯ä»¥åˆ©ç”¨è¿™äº›ä¿¡æ¯æŠŠè¿›ç¨‹æ ‘æ„å»ºå‡ºæ¥ã€‚\nå…³äºè¿›ç¨‹åçš„æ ¼å¼\næ ¹æ® man proc çš„æç¤ºï¼Œæ‰€æœ‰çš„è¿›ç¨‹åéƒ½æ˜¯ç”¨ä¸€å¯¹å°æ‹¬å·åŒ…è£¹ç€çš„ã€‚ç¬”è€…èµ·åˆä½¿ç”¨äº† scanf(\u0026quot;%[^)]\u0026quot;) çš„æ–¹æ³•ï¼Œè¯»åˆ°å³æ‹¬å·åœæ­¢ï¼Œä½†å‘ç°è¿›ç¨‹ä¸­æœ‰ä¸€äº›è¿›ç¨‹çš„è¿›ç¨‹åæœ¬èº«å°±å¸¦æ‹¬å·ã€‚å› æ­¤åªèƒ½ä¸€ä¸ªå­—èŠ‚ä¸€ä¸ªå­—èŠ‚è¯»å¹¶åŒæ­¥ç»´æŠ¤ä¸€ä¸ªæ‹¬å·çš„æ ˆæ¥ç¡®å®šä»€ä¹ˆæ—¶å€™åœæ­¢ã€‚\næˆ‘ä»¬å¯ä»¥åœ¨ /proc/sys/kernel/pid_max æ–‡ä»¶ä¸­æŸ¥çœ‹è¿›ç¨‹å·çš„æœ€å¤§å€¼ï¼Œåœ¨ 64 ä½ç³»ç»Ÿä¸­ï¼Œè¿™ä¸ªæœ€å¤§å€¼ä¸º $2^{22}$ã€‚ä¸ºäº†ä»£ç ç¼–å†™çš„æ–¹ä¾¿å’Œæ•ˆç‡ï¼Œç¬”è€…å¼€äº†ä¸€ä¸ªè¿™ä¹ˆå¤§çš„æ•°ç»„ proc_pos[] ç”¨äºç»´æŠ¤æ¯ä¸ªè¿›ç¨‹å·å¯¹åº”åˆ°è¿›ç¨‹ä¿¡æ¯ç»“æ„ä½“æ•°ç»„ proc[] çš„å“ªä¸ªä½ç½®ã€‚ proc ç»“æ„ä½“ä¸­ç»´æŠ¤äº†ä¸€ä¸ªå½“å‰è¿›ç¨‹çš„æ‰€æœ‰å­©å­çš„é“¾è¡¨ï¼Œå­©å­æ•°é‡ï¼Œè¿›ç¨‹åç­‰ä¿¡æ¯ã€‚ç”±äºç³»ç»Ÿä¸­çœŸæ­£åœ¨è¿è¡Œçš„è¿›ç¨‹ä¸ªæ•°è¿œå°äº $2^{22}$ï¼Œè¿™ä¸ªåšæ³•å¯ä»¥çœå¾ˆå¤šå†…å­˜ã€‚\näº‹å®ä¸Šï¼ŒLinux çš„ pstree å·¥å…·è¿˜ä¼šå°†ä¸€ä¸ªè¿›ç¨‹ä¸‹çš„æ‰€æœ‰çº¿ç¨‹æ‰“å°å‡ºæ¥ã€‚æˆ‘ä»¬å¯ä»¥åœ¨ /proc/[pid]/task ä¸‹çœ‹åˆ°æ‰€æœ‰çš„çº¿ç¨‹æ–‡ä»¶å¤¹ï¼Œ/proc/[pid]/task/[tid]/stat ä¸­ä¹Ÿæœ‰å„ä¸ªçº¿ç¨‹çš„çŠ¶æ€ï¼Œä¸è¿‡æœ¬å®éªŒä¸è¦æ±‚æ‰“å°çº¿ç¨‹ã€‚\nPrint tree æ‰“å°è¿›ç¨‹æ ‘å¯ä»¥ç”¨å¯¹è¿›ç¨‹æ ‘çš„ä¸€æ¬¡ dfs æ¥å®ç° â€”â€” æ ¹èŠ‚ç‚¹æ˜¯ 1 å·è¿›ç¨‹ systemdã€‚è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯éå†é¡ºåºçš„é—®é¢˜ï¼šåœ¨é»˜è®¤æƒ…å†µä¸‹ï¼Œpstree å„ä¸ªå­æ ‘ä¼šæŒ‰ç…§è¿›ç¨‹åçš„å­—å…¸åºæ’åºï¼Œå¦‚æœæœ‰ -n é€‰é¡¹ï¼Œåˆ™è¦æŒ‰ç…§è¿›ç¨‹å·ä»å°åˆ°å¤§æ’åºã€‚åœ¨ç¬”è€…çš„å®ç°ä¸­ï¼Œå•å‘é“¾è¡¨ä¸æ–¹ä¾¿è¿›è¡Œé«˜çº§çš„æ’åºï¼Œä½†æˆ‘ä»¬å¯ä»¥ç›´æ¥äº¤æ¢ä¸¤ä¸ªé“¾è¡¨å†…éƒ¨çš„å†…å®¹ï¼Œä½¿ç”¨æœ´ç´ çš„å†’æ³¡æ’åºæ¥å®Œæˆå·¥ä½œã€‚\næ›´ä¼˜ç¾çš„æ˜¾ç¤º\næ‰“å°æ ‘ç»“æ„çš„æœ€ç®€å•çš„æ–¹æ³•æ˜¯ä½¿ç”¨ç¼©è¿›ï¼šæˆ‘ä»¬åªéœ€è¦è®°å½•å½“å‰é€’å½’åˆ°ç¬¬å‡ å±‚ï¼Œå¹¶æ‰“å°ç›¸åº”ä¸ªæ•°çš„ TAB å³å¯ã€‚ä¸ºäº†å®ç°åƒ Linux pstree å·¥å…·é‚£æ ·ç²¾ç¾çš„æ ‘ç»“æ„ï¼Œæˆ‘ä»¬éœ€è¦ä»¥ä¸‹è§‚å¯Ÿï¼š\næ¯ä¸ªè¿›ç¨‹çš„ç¬¬ä¸€ä¸ªå­è¿›ç¨‹ä¸æ¢è¡Œã€‚ä»”ç»†æ€è€ƒä»¥ä¸‹ï¼Œæˆ‘ä»¬ä¼šå‘ç°è¿™ä¸ªè§„åˆ™ç­‰ä»·äºæˆ‘ä»¬åªä¼šåœ¨é‚£äº›å¶å­è¿›ç¨‹å¤„æ¢è¡Œã€‚ æ¯ä¸ªè¿›ç¨‹åä¹‹å‰æœ‰ä¸€ä¸ªæ ‘çš„èŠ‚ç‚¹ç¬¦å·ï¼Œè¿™ä¸ªèŠ‚ç‚¹ç¬¦å·éµå¾ªçš„è§„åˆ™å¦‚ä¸‹ï¼š å¦‚æœæŸè¿›ç¨‹æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªå­è¿›ç¨‹ï¼Œåˆ™èŠ‚ç‚¹ç¬¦å·ä¸º -ï¼› å¦‚æœæŸè¿›ç¨‹æœ‰å¤§äºä¸€ä¸ªå­è¿›ç¨‹ï¼Œåˆ™ç¬¬ä¸€ä¸ªå­©å­çš„èŠ‚ç‚¹ç¬¦å·æ˜¯ +ï¼Œæœ€åä¸€ä¸ªå­©å­çš„èŠ‚ç‚¹ç¬¦å·æ˜¯ ` ï¼Œä¸­é—´å­©å­çš„èŠ‚ç‚¹ç¬¦å·æ˜¯ |ã€‚ å½“æˆ‘ä»¬åœ¨æ‰“å°å†…å±‚è¿›ç¨‹å†…å®¹æ—¶ï¼Œå¤–å±‚è¿›ç¨‹æ ‘ä¼šæœ‰ | å»¶ä¼¸ä¸‹æ¥ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªæ ˆè®°å½•æ‰€æœ‰éœ€è¦æ‰“å° | çš„ä½ç½®ã€‚ä½†éœ€è¦æ³¨æ„çš„æ˜¯ï¼šæ¯ä¸ªè¿›ç¨‹çš„æœ€åä¸€ä¸ªå­è¿›ç¨‹å¦‚æœè¿˜æœ‰å­è¿›ç¨‹ï¼Œå­è¿›ç¨‹çš„å­è¿›ç¨‹æ˜¯ä¸ä¼šè¢«å­è¿›ç¨‹çš„çˆ¶è¿›ç¨‹çš„ | åŒ…è£¹ä½çš„ï¼Œå…·ä½“æ“ä½œä¸Šï¼Œæ¯ä¸ªè¿›ç¨‹çš„æœ€åä¸€ä¸ªå­è¿›ç¨‹è´Ÿè´£å°†çˆ¶è¿›ç¨‹ä»æ ˆä¸­å¼¹å‡ºã€‚ ","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"3c4bb3635b50e9e2e50931d8b102a4d3","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/minilabs/minilab01/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/minilabs/minilab01/","section":"notes","summary":"è¯¥å®éªŒä¸»è¦ç›®çš„æ˜¯å®ç°ä¸€ä¸ªç²¾ç®€ç‰ˆçš„ Linux pstree å‘½ä»¤è¡Œå·¥å…·ï¼Œä»¥è¾ƒä¸ºä¼˜ç¾çš„æ–¹å¼æ‰“å°å½“å‰ç³»ç»Ÿä¸­çš„è¿›ç¨‹æ ‘ã€‚\nParse args é¦–å…ˆå¯¹è¾“å…¥çš„é€‰é¡¹åˆ—è¡¨è¿›è¡Œåˆ†æã€‚ç¬”è€…ä½¿ç”¨äº† C åº“å‡½æ•° getopt_long()ï¼Œå®ƒä¸ä»…å¯ä»¥å¸®åŠ©æˆ‘ä»¬å¿«é€Ÿè§£æé€‰é¡¹ï¼Œè¿˜å¯ä»¥åŒæ—¶è¯†åˆ«ä¸€ä¸ªé€‰é¡¹çš„é•¿çŸ­ç‰ˆæœ¬ (ä½¿ç”¨ C åº“æä¾›çš„ option ç»“æ„ä½“å¯ä»¥å®šä¹‰æ¯ç§é€‰é¡¹çš„é•¿çŸ­ç‰ˆæœ¬ä»¥åŠæ˜¯å¦éœ€è¦å‚æ•°ç­‰)ï¼Œè¯†åˆ«å¤šä¸ªé€‰å¸çº³æ›´åˆå¹¶ç»™å‡ºçš„æ ¼å¼ etc.ã€‚\nå®šä¹‰å¥½è¡¨æ ¼åï¼Œä»…éœ€ä¸€å¥è¯å³å¯å®Œæˆé€‰é¡¹è§£æï¼š\nconst struct option table[] = { {\u0026quot;numeric-sort\u0026quot;, no_argument, NULL, 'n'}, {\u0026quot;show-pids\u0026quot; , no_argument, NULL, 'p'}, {\u0026quot;version\u0026quot; , no_argument, NULL, 'V'}, {0 , 0 , NULL, 0 }, }; getopt_long(argc, argv, \u0026quot;-npV\u0026quot;, table, NULL) å…³äºç‰ˆæœ¬ä¿¡æ¯","tags":null,"title":"MiniLab 01: Process Tree","type":"docs"},{"authors":null,"categories":null,"content":"æœ¬å®éªŒçš„ä¸»è¦ç›®æ ‡æ˜¯å®ç°åç¨‹åº“ (lib coroutines)ã€‚å¾ˆå¤§ç¨‹åº¦ä¸Šåç¨‹å’Œçº¿ç¨‹éå¸¸ç›¸ä¼¼ï¼Œä¸€ä¸ªä¸»è¦çš„åŒºåˆ«æ˜¯ï¼šçº¿ç¨‹å¯ä»¥å“åº”ä¸­æ–­ï¼Œç„¶åé€šè¿‡å†…æ ¸çš„è°ƒåº¦å™¨è¿›è¡Œåˆ‡æ¢ï¼Œè€Œåç¨‹å¦‚æœä¸ä¸»åŠ¨ yield åˆ™ä¸ä¼šåˆ‡æ¢ã€‚\nCoroutine Struct åç¨‹ä¹‹é—´å…±äº«å†…å­˜ï¼Œä½†å„è‡ªæœ‰ç‹¬ç«‹çš„è¿è¡Œæ—¶æ ˆã€‚ç¬”è€…å®šä¹‰çš„åç¨‹ç»“æ„ä½“å¤§è‡´å¦‚ä¸‹ï¼š\nstruct co { const char *name; void (*func)(void *); void *arg; enum co_status status; struct co *waiter; jmp_buf context; uint8_t stack[STACK_SIZE]; }coroutine[CO_SIZE]; name å­—æ®µä¸»è¦ç”¨äº debugã€‚func å’Œ arg æ˜¯ç›®æ ‡å‡½æ•°çš„åœ°å€å’Œè°ƒç”¨æ—¶çš„å‚æ•°ã€‚waiter å­˜å‚¨äº†æŒ‡å‘è°ƒç”¨ co_wait() ç­‰å¾…å½“å‰åç¨‹çš„â€œçˆ¶åç¨‹â€çš„æŒ‡é’ˆï¼Œå½“æœ¬åç¨‹ç»“æŸæ—¶ï¼Œåº”è¯¥å”¤é†’ (å¯èƒ½å­˜åœ¨çš„) ç¡çœ çš„çˆ¶åç¨‹ã€‚context å­˜å‚¨äº†åˆ‡æ¢æ—¶çš„å¯„å­˜å™¨ä¸Šä¸‹æ–‡ï¼Œåœ¨æœ¬å®éªŒä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ setjmp() å’Œ longjmp() æ¥å®Œæˆè·³è½¬ã€‚\nco_new() co_new() è¦åšçš„äº‹æƒ…å¾ˆç®€å•ï¼šå°†æ‰€æœ‰çš„åç¨‹ç›¸å…³çš„ä¿¡æ¯ä¿å­˜åˆ°ä¸€ä¸ªç»“æ„ä½“å˜é‡ä¸­å³å¯ã€‚æˆ‘ä»¬ä¸»è¦éœ€è¦æ€è€ƒçš„æ˜¯å¦‚ä½•å¼€å§‹æ‰§è¡Œä¸€ä¸ªæ–°çš„åç¨‹ã€‚å¯¹äºé‚£äº›è°ƒç”¨ co_yield() ä¸­æ–­çš„åç¨‹ï¼Œæˆ‘ä»¬åªéœ€è¦ä¸€ä¸ª longjmp() å°±å¯ä»¥è·³å›å»ï¼Œä½†æ–°çš„åç¨‹çš„è¿è¡Œæ—¶ç¯å¢ƒçš„åˆ›å»ºè¦æˆ‘ä»¬è‡ªå·±æ¥æ“å¿ƒï¼š\næˆ‘ä»¬éœ€è¦è‡ªå·±å®Œæˆæ ˆåˆ‡æ¢å¹¶è®© PC æŒ‡å‘ç›®æ ‡å‡½æ•°çš„åœ°å€ã€‚ åç¨‹å¯¹åº”çš„å‡½æ•°ç»“æŸåï¼Œæˆ‘ä»¬è¦æŒ‡å®šå¥½è¿”å›åœ°å€ã€‚ ç¬”è€…æœ€åˆçš„å®ç°ç”¨å…§è”æ±‡ç¼–åŒ…åŠäº†ä¸Šé¢çš„æ‰€æœ‰äº‹æƒ…ï¼šå°†åç¨‹æ ˆåœ°å€èµ‹ç»™ %esp/%rspï¼Œç”¨ jmp æŒ‡ä»¤ç›´æ¥è·³è½¬ï¼Œå¹¶åœ¨æ ˆä¸Šæå‰å­˜å‚¨äº†ä¸€ä¸ªæŒ‡å‘ co_exit() å‡½æ•°åœ°å€çš„â€œè¿”å›åœ°å€â€æ¥å¼•å¯¼åç¨‹ç»“æŸçš„å»å‘ã€‚ä½†åå‘ç°å…¶å®ç”¨ C è¯­è¨€åšä¸€ä¸ª wrapper å®Œæˆå‡½æ•°è·³è½¬æ›´æ–¹ä¾¿ï¼š\nvoid wrapper(void *sp, void *entry, uintptr_t arg) { // stack switching, in assembly ((void(*)(uintptr_t))entry)(arg); // coroutine goes here after entry(arg) } C ç¼–è¯‘å™¨ä¼šå°†æˆ‘ä»¬çš„è·³è½¬è¯­å¥ç¿»è¯‘æˆ callï¼Œå¸®æˆ‘ä»¬å¡«å†™å¥½è¿”å›åœ°å€ (ä¸éœ€è¦é¢å¤–åˆ›å»ºä¸€ä¸ª co_exit() å‡½æ•°äº†)ã€‚æˆ‘ä»¬åœ¨å…§è”æ±‡ç¼–ä¸­éœ€è¦åšçš„å°±æ˜¯å°† wrapper() çš„æ ˆç¯å¢ƒå¤åˆ»ä¸€ä»½åˆ°åç¨‹çš„æ ˆä¸Š ( x86_64 ç”šè‡³åªéœ€è¦æ”¹ä¸€ä¸‹ %rspï¼Œå› ä¸ºå‚æ•°æ˜¯æ”¾åœ¨å¯„å­˜å™¨é‡Œçš„ï¼›x86 éœ€è¦æŠŠæ ˆä¸Šçš„å‚æ•°ä¹Ÿæ¬ä¸€ä»½)ã€‚\nåç¨‹ç»“æŸåï¼Œæˆ‘ä»¬åº”è¯¥å°†å…¶çŠ¶æ€è®¾ç½®æˆ ZOMBIE (ç­‰å¾…çˆ¶åç¨‹å›æ”¶)ï¼Œå¹¶è·³è½¬åˆ°è°ƒåº¦å‡½æ•°ã€‚\nStack Alignment ç¬”è€…æ›¾ç»åœ¨ x86_64 ä¸­é‡åˆ°è¿‡ç¥ç§˜çš„æ®µé”™è¯¯ï¼Œä½¿ç”¨ GDB å®šä½åå‘ç°é”™è¯¯è¯­å¥å‡ºç°åœ¨ printf() åº“å‡½æ•°å½¢å¦‚\nmovaps %xmm0,0x50(%rsp) movaps %xmm1,0x60(%rsp) çš„ SSE æŒ‡ä»¤ã€‚x86_64 å¯¹æ ˆæœ‰ 16 å­—èŠ‚çš„å¯¹é½è¦æ±‚ (æ¯ä¸ªå•å…ƒæ˜¯ 8 ä¸ªå­—èŠ‚)ï¼Œè¿™æ˜¯å› ä¸º x86_64 ä¸­çš„ä¸€éƒ¨åˆ†å¯„å­˜å™¨æ˜¯ 16 å­—èŠ‚çš„ã€‚å‡ºç°è¯¥é”™è¯¯çš„æ ¹æœ¬åŸå› æ˜¯ç¬”è€…æ²¡æœ‰æŒ‰ç…§ System V ABI çš„è¦æ±‚è®¾ç½®å¥½ %rspï¼šSystem V ABI (x86-64) å¯¹å †æ ˆå¯¹é½çš„è¦æ±‚æ˜¯ï¼šcall æŒ‡ä»¤æ‰§è¡Œä¹‹å‰è¦æŒ‰ 16B å¯¹é½ï¼Œcall æŒ‡ä»¤æ‰§è¡Œä¹‹åå°±ä¸æŒ‰ç…§ 16B å¯¹é½äº†ã€‚è¿™å…¶ä¸­çš„åŸç†å¦‚ä¸‹ï¼š\ncall æŒ‡ä»¤æ‰§è¡Œä¹‹å‰ï¼Œå †æ ˆæŒ‰ 16B å¯¹é½ï¼›\ncall æŒ‡ä»¤çš„è¯­ä¹‰æ˜¯ï¼šå°†ä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€ push åˆ°æ ˆä¸Šï¼Œç„¶åæ ¹æ®æ“ä½œæ•°è®© PC è·³è½¬åˆ°å¯¹åº”çš„åœ°å€æ‰§è¡Œæ–°çš„å‡½æ•°ã€‚æˆ‘ä»¬å‘å †æ ˆ push äº†ä¸€ä¸ª 8B çš„ä¸œè¥¿ (è¿”å›åœ°å€)ï¼Œæ‰€ä»¥åˆšæ‰§è¡Œå®Œ call æŒ‡ä»¤æ—¶å †æ ˆæ˜¯ä¸å¯¹é½çš„ã€‚\nåˆšè¿›å…¥ä¸€ä¸ªæ–°å‡½æ•°æ—¶ï¼Œ(ä¸€èˆ¬æƒ…å†µä¸‹) ç¼–è¯‘å™¨ç”Ÿæˆçš„å¤´ä¸¤æ¡æŒ‡ä»¤ä¼šæ˜¯\npush %rbp mov %rsp, %rbp è¿™æ—¶æˆ‘ä»¬åˆå‘æ ˆä¸Š push äº†ä¸€ä¸ª 8B çš„ä¸œè¥¿ (æ—§ %rbp å€¼)ï¼Œå› æ­¤åœ¨æ­£å¼å¼€å§‹æ‰§è¡Œå‡½æ•°ä½“æ—¶ï¼Œå †æ ˆåˆæ˜¯å¯¹é½çš„äº†ã€‚\nåœ¨è¿™å¥—æµç¨‹ä¸‹ï¼Œè¿”å›åœ°å€æ€»æ˜¯è¢«ä¿å­˜åœ¨ä¸€ä¸ª 16B ä¸å¯¹é½çš„åœ°å€ä¸Šã€‚ç¬”è€…æœ€åˆçš„å®ç°ç”¨ jmp æŒ‡ä»¤ç›´æ¥è·³è½¬ï¼Œä¸” %rsp è®¾ç½®æˆäº† 16B å¯¹é½ï¼Œåœ¨ 16B å¯¹é½çš„ä½ç½®æ‰‹åŠ¨æ”¾äº†ä¸€ä¸ªè¿”å›åœ°å€ï¼Œè¿™æ ·è¿›å…¥æ–°å‡½æ•° push %rbp ä¹‹åï¼Œå †æ ˆå°±ä¸å¯¹é½äº†ï¼Œä»è€Œå¯¼è‡´é”™è¯¯ã€‚\nco_yield() co_yield() çš„ä»£ç éå¸¸ç®€å•ï¼š\nvoid co_yield() { int val = setjmp(current-\u0026gt;context); if (val == 0) sched(); } åˆ©ç”¨ setjmp() å’Œ longjmp()ï¼Œæˆ‘ä»¬å¯ä»¥è½»æ¾åœ°å®Œæˆå¯„å­˜å™¨ç°åœºçš„å°å­˜å’Œæ¢å¤ã€‚setjmp() åœ¨ä¿å­˜å¯„å­˜å™¨ç°åœºæ—¶çš„è¿”å›å€¼æ˜¯ 0ï¼Œlongjmp() è·³è½¬å›æ¥æ—¶å¯ä»¥æŒ‡å®šè¿”å›å€¼ä¸ºéé›¶æ•°ï¼Œè¿™æ ·ä¿å­˜å®Œç°åœºä¼šè·³è½¬åˆ°è°ƒåº¦å‡½æ•°ï¼Œè·³è½¬å›æ¥æ—¶å°±å¯ä»¥ç›´æ¥è¿”å›åç¨‹ç»§ç»­æ‰§è¡Œã€‚\nco_wait() co_wait() è¦åˆ†ä¸¤ç§æƒ…å†µï¼šä¸€æ˜¯å­åç¨‹å·²ç»æ˜¯åƒµå°¸åç¨‹ï¼Œè¿™æ—¶å€™ç›´æ¥é‡Šæ”¾å­åç¨‹çš„èµ„æºï¼›äºŒæ˜¯å­åç¨‹è¿˜ä¸æ˜¯åƒµå°¸åç¨‹ï¼Œè¿™æ—¶å€™è¦å°†å½“å‰åç¨‹ç¡çœ  (çŠ¶æ€è®¾ç½®æˆ WAITING)ï¼Œå­åç¨‹ç»“æŸæ—¶ä¼šè´Ÿè´£å”¤é†’å®ƒ (å°†çŠ¶æ€æ”¹æˆ RUNNING)ã€‚\nco_init() æˆ‘ä»¬éœ€è¦å¯¹åç¨‹åº“åšä¸€äº›å¿…è¦çš„åˆå§‹åŒ–ï¼šæ¯”å¦‚ main() å‡½æ•°æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªåç¨‹ï¼Œæˆ‘ä»¬è¦å°† main() å‡½æ•°ä½œä¸ºä¸€ä¸ª RUNNING çš„åç¨‹å­˜å‚¨å¥½ã€‚åˆå§‹åŒ–å‡½æ•°åº”å½“åœ¨ main() å‡½æ•°å¼€å§‹æ‰§è¡Œä¹‹å‰æ‰§è¡Œï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦\n__attribute__((constructor)) void co_init() { // code } æ¥ä¿®é¥° co_init()ã€‚\n","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"5847fa78360e623c3b605d28db3bfd92","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/minilabs/minilab02/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/minilabs/minilab02/","section":"notes","summary":"æœ¬å®éªŒçš„ä¸»è¦ç›®æ ‡æ˜¯å®ç°åç¨‹åº“ (lib coroutines)ã€‚å¾ˆå¤§ç¨‹åº¦ä¸Šåç¨‹å’Œçº¿ç¨‹éå¸¸ç›¸ä¼¼ï¼Œä¸€ä¸ªä¸»è¦çš„åŒºåˆ«æ˜¯ï¼šçº¿ç¨‹å¯ä»¥å“åº”ä¸­æ–­ï¼Œç„¶åé€šè¿‡å†…æ ¸çš„è°ƒåº¦å™¨è¿›è¡Œåˆ‡æ¢ï¼Œè€Œåç¨‹å¦‚æœä¸ä¸»åŠ¨ yield åˆ™ä¸ä¼šåˆ‡æ¢ã€‚\nCoroutine Struct åç¨‹ä¹‹é—´å…±äº«å†…å­˜ï¼Œä½†å„è‡ªæœ‰ç‹¬ç«‹çš„è¿è¡Œæ—¶æ ˆã€‚ç¬”è€…å®šä¹‰çš„åç¨‹ç»“æ„ä½“å¤§è‡´å¦‚ä¸‹ï¼š\nstruct co { const char *name; void (*func)(void *); void *arg; enum co_status status; struct co *waiter; jmp_buf context; uint8_t stack[STACK_SIZE]; }coroutine[CO_SIZE]; name å­—æ®µä¸»è¦ç”¨äº debugã€‚func å’Œ arg æ˜¯ç›®æ ‡å‡½æ•°çš„åœ°å€å’Œè°ƒç”¨æ—¶çš„å‚æ•°ã€‚waiter å­˜å‚¨äº†æŒ‡å‘è°ƒç”¨ co_wait() ç­‰å¾…å½“å‰åç¨‹çš„â€œçˆ¶åç¨‹â€çš„æŒ‡é’ˆï¼Œå½“æœ¬åç¨‹ç»“æŸæ—¶ï¼Œåº”è¯¥å”¤é†’ (å¯èƒ½å­˜åœ¨çš„) ç¡çœ çš„çˆ¶åç¨‹ã€‚context å­˜å‚¨äº†åˆ‡æ¢æ—¶çš„å¯„å­˜å™¨ä¸Šä¸‹æ–‡ï¼Œåœ¨æœ¬å®éªŒä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ setjmp() å’Œ longjmp() æ¥å®Œæˆè·³è½¬ã€‚","tags":null,"title":"MiniLab 02: Coroutine Library","type":"docs"},{"authors":null,"categories":null,"content":"è¯¥å®éªŒçš„ä¸»è¦ç›®æ ‡æ˜¯åˆ©ç”¨ strace ç³»ç»Ÿè°ƒç”¨å®ç°ä¸€ä¸ªæ€§èƒ½ç›‘æµ‹å™¨ï¼Œå®æ—¶è¾“å‡ºå½“å‰è¿›ç¨‹è¿è¡Œè€—æ—¶æ’åå‰ 5 çš„ç³»ç»Ÿè°ƒç”¨ã€‚\nOverview è¯¥å®éªŒçš„å¤§ä½“æ€è·¯ä¸ºï¼šæˆ‘ä»¬éœ€è¦ fork å‡ºä¸€ä¸ªå­è¿›ç¨‹ï¼Œè®©å­è¿›ç¨‹ç”¨ strace è¿è¡Œç›®æ ‡ç¨‹åºï¼Œå¹¶æŠŠ strace çš„ç»“æœé€šè¿‡ç®¡é“è¾“é€ç»™çˆ¶è¿›ç¨‹ã€‚æœ¬å®éªŒåªå…è®¸ä½¿ç”¨ execve() å‡½æ•°ï¼Œä¸å…è®¸ä½¿ç”¨å¸¦æœ‰ p çš„åº“å‡½æ•°ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬å¿…é¡»æ‰‹åŠ¨è§£æç¯å¢ƒå˜é‡ï¼Œå°†æ‰€æœ‰çš„è·¯å¾„ä¸€ä¸€åŠ åœ¨ strace çš„å‰é¢å¹¶è°ƒç”¨ execve()ï¼Œç›´åˆ°æ‰¾åˆ° strace çš„ç¡®åˆ‡ä½ç½®ä¸ºæ­¢ (å¦‚æœæˆåŠŸæ‰§è¡Œï¼Œå‡½æ•°ä¸ä¼šè¿”å›)ã€‚çˆ¶è¿›ç¨‹è´Ÿè´£ä¸æ–­ä»ç®¡é“ä¸­è¯»å– strace çš„è¾“å‡ºï¼Œè§£æå‡ºç³»ç»Ÿè°ƒç”¨åå’Œæ¶ˆè€—çš„æ—¶é—´å¹¶æ·»åŠ åˆ°æ•°æ®ç»“æ„ä¸­ï¼Œæ¯éš”ä¸€æ®µæ—¶é—´è¾“å‡ºä¸€æ¬¡ã€‚\nä»¥ä¸‹ä¸»è¦è®°å½•å®éªŒä¸­é‡åˆ°çš„ä¸€äº›æœ‰è¶£çš„ç»†èŠ‚ã€‚\ndup() vs dup2() åˆ›å»ºç®¡é“ä»¥åï¼Œæˆ‘ä»¬ä¼šæœ‰å°†å­è¿›ç¨‹çš„æ ‡å‡†è¾“å‡ºå’Œçˆ¶è¿›ç¨‹çš„æ ‡å‡†è¾“å…¥è¿æ¥åˆ°ç®¡é“çš„å†™å£/è¯»å£çš„éœ€æ±‚ã€‚æˆ‘ä»¬å¯èƒ½ä¼šå†™å‡ºè¿™æ ·çš„ä»£ç ï¼š\nclose(0); // close stdin dup(pipefd[0]); dup() æ€»æ˜¯ä¼šæŒ‘é€‰å½“å‰æœ€å°çš„æœªä½¿ç”¨æ–‡ä»¶æè¿°ç¬¦ï¼Œå› æ­¤å…³é—­äº† stdin åï¼Œdup() ä¼šå°† 0 å·æ–‡ä»¶æè¿°ç¬¦å¤åˆ¶ä¸ºç®¡é“å†™å£çš„æ–‡ä»¶æè¿°ç¬¦ã€‚ä½†è¿™å…¶å®æ˜¯ä¸€ä¸ª bad practiceï¼šåœ¨å¤šçº¿ç¨‹çš„ç¨‹åºä¸­ï¼Œå¦‚æœ close() å’Œ dup() ä¹‹é—´è¢«æ’å…¥äº†å…¶ä»–æ‰§è¡Œæµï¼Œæˆ‘ä»¬ä¸èƒ½ä¿è¯ dup() æ‰§è¡Œæ—¶æœ€å°çš„æœªä½¿ç”¨æ–‡ä»¶æè¿°ç¬¦ä»ç„¶æ˜¯ 0ã€‚å› æ­¤æˆ‘ä»¬åº”è¯¥ä½¿ç”¨å‡½æ•° dup2()ï¼š\ndup2(pipefd[0], 0); dup2() ç³»ç»Ÿè°ƒç”¨çš„å£°æ˜ä¸º\nint dup2(int oldfd, int newfd); å®ƒå’Œ dup() çš„å«ä¹‰åŸºæœ¬ç›¸åŒï¼Œä¸åŒä¹‹å¤„åœ¨äºæˆ‘ä»¬å¯ä»¥æŒ‡å®šå°† oldfd å¤åˆ¶åˆ° newfd ä¸Šè€Œä¸æ˜¯â€œæœ€å°çš„æœªä½¿ç”¨æ–‡ä»¶æè¿°ç¬¦â€ã€‚å¦‚æœ newfd å¯¹åº”çš„æ–‡ä»¶å¤„äºæ‰“å¼€çŠ¶æ€ï¼Œdup2() ä¼šå°†å…¶å…ˆå…³é—­å†ä½¿ç”¨è¯¥æè¿°ç¬¦ã€‚dup2() çš„å¥½å¤„åœ¨äºå…³é—­æ–‡ä»¶å’Œä½¿ç”¨ newfd çš„è¿‡ç¨‹æ˜¯åŸå­çš„ (æ‰‹å†Œä¿è¯äº†è¿™ä¸€ç‚¹)ã€‚\nTime Information Matching ç¬”è€…å°è¯•ä½¿ç”¨äº†æ­£åˆ™è¡¨è¾¾å¼æ¥åŒ¹é… strace è¾“å‡ºä¿¡æ¯ä¸­å’Œè¿è¡Œæ—¶é—´ç›¸å…³çš„æœ‰æ•ˆå†…å®¹ã€‚regex.h åº“ä¸­æä¾›äº†å’Œæ­£åˆ™è¡¨è¾¾å¼ç›¸å…³çš„åº“å‡½æ•°ã€‚ä¸€äº›æ¯”è¾ƒæœ‰ç”¨çš„å‡½æ•°ç½—åˆ—å¦‚ä¸‹ï¼š\nint regcomp(regex_t *preg, const char *regex, int cflags); è¯¥å‡½æ•°è´Ÿè´£å°†ä¸€ä¸ªæ­£åˆ™è¡¨è¾¾å¼ç¼–è¯‘æˆä¸€ä¸ª regex_t ç±»å‹çš„ä¸œè¥¿ã€‚\nint regexec(const regex_t *preg, const char *string, size_t nmatch, regmatch_t pmatch[], int eflags); regexec() è´Ÿè´£åŒ¹é…ã€‚preg æ˜¯ç¼–è¯‘å¥½çš„æ­£åˆ™è¡¨è¾¾å¼ï¼Œstring æ˜¯åŒ¹é…çš„ä¸²ã€‚nmatch æ˜¯åŒ¹é…æ¬¡æ•°ã€‚pmatch[] æ•°ç»„ä¼šå­˜å‚¨ nmatch ä¸ªåŒ¹é…ç»“æœï¼Œå…¶ä¸­æ¯ä¸ªç»“æœæ˜¯ä¸€ä¸ª regmatch_t ç±»å‹çš„ä¸œè¥¿ï¼š\ntypedef struct { regoff_t rm_so; regoff_t rm_eo; } regmatch_t; ä¸¤ä¸ªå˜é‡å­˜å‚¨äº†åŒ¹é…ç»“æœé¦–å°¾ç›¸å¯¹äº string é¦–åœ°å€çš„åç§»é‡ã€‚\nNoise Filtering æˆ‘ä»¬å¸Œæœ›è¿‡æ»¤æ‰ç›®æ ‡ç¨‹åºçš„å™ªéŸ³è¾“å‡ºä»¥ä¿è¯çˆ¶è¿›ç¨‹å¯ä»¥è·å¾—çº¯å‡€çš„ strace ä¿¡æ¯ã€‚æˆ‘ä»¬æœ‰ä¸¤ä¸ªæ–¹å‘ï¼š\né‡å®šå‘ç›®æ ‡ç¨‹åºçš„æ ‡å‡†é”™è¯¯ (å› ä¸º strace é»˜è®¤è¾“å‡ºåˆ°æ ‡å‡†é”™è¯¯)ï¼Œä½†ç¬”è€…å¹¶æ²¡æœ‰åœ¨ strace çš„æ‰‹å†Œä¸­æŸ¥çœ‹åˆ°åªé‡å®šå‘ç›®æ ‡ç¨‹åºçš„é€‰é¡¹ã€‚ é‡å®šå‘ strace çš„è¾“å‡ºï¼šæˆ‘ä»¬å¯ä»¥åˆ©ç”¨ strace çš„ -o é€‰é¡¹æ¥å°† strace çš„ä¿¡æ¯è¾“å‡ºåˆ°ä¸€ä¸ªæŒ‡å®šçš„æ–‡ä»¶ã€‚äº‹å®ä¸Šï¼Œæˆ‘ä»¬åˆ›å»ºçš„ç®¡é“ä¹Ÿæ˜¯ä¸€ä¸ªæ–‡ä»¶ï¼šè™½ç„¶ pipe() åˆ›å»ºçš„ç®¡é“æ˜¯åŒ¿åçš„ï¼Œä½†æˆ‘ä»¬ä»ç„¶å¯ä»¥é€šè¿‡ procfs æ‰¾åˆ°å®ƒï¼šå¯¹äºè¿›ç¨‹å· pid ä¸‹æ–‡ä»¶æè¿°ç¬¦ idï¼Œ/proc/pid/fd/id å°±æ˜¯è¯¥æ–‡ä»¶çš„æ–‡ä»¶åã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥åˆ©ç”¨ -o ç›´æ¥å°† strace çš„è¾“å‡ºç›´æ¥å®šå‘åˆ°ç®¡é“ (ç”šè‡³çœæ‰äº† dup2() çš„è¿‡ç¨‹)ã€‚ ","date":1607817600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607817600,"objectID":"8e3f4173daa95862959692f8fb3086ed","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-operating-system/minilabs/minilab03/","publishdate":"2020-12-13T00:00:00Z","relpermalink":"/notes/coursenotes/nju-operating-system/minilabs/minilab03/","section":"notes","summary":"è¯¥å®éªŒçš„ä¸»è¦ç›®æ ‡æ˜¯åˆ©ç”¨ strace ç³»ç»Ÿè°ƒç”¨å®ç°ä¸€ä¸ªæ€§èƒ½ç›‘æµ‹å™¨ï¼Œå®æ—¶è¾“å‡ºå½“å‰è¿›ç¨‹è¿è¡Œè€—æ—¶æ’åå‰ 5 çš„ç³»ç»Ÿè°ƒç”¨ã€‚\nOverview è¯¥å®éªŒçš„å¤§ä½“æ€è·¯ä¸ºï¼šæˆ‘ä»¬éœ€è¦ fork å‡ºä¸€ä¸ªå­è¿›ç¨‹ï¼Œè®©å­è¿›ç¨‹ç”¨ strace è¿è¡Œç›®æ ‡ç¨‹åºï¼Œå¹¶æŠŠ strace çš„ç»“æœé€šè¿‡ç®¡é“è¾“é€ç»™çˆ¶è¿›ç¨‹ã€‚æœ¬å®éªŒåªå…è®¸ä½¿ç”¨ execve() å‡½æ•°ï¼Œä¸å…è®¸ä½¿ç”¨å¸¦æœ‰ p çš„åº“å‡½æ•°ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬å¿…é¡»æ‰‹åŠ¨è§£æç¯å¢ƒå˜é‡ï¼Œå°†æ‰€æœ‰çš„è·¯å¾„ä¸€ä¸€åŠ åœ¨ strace çš„å‰é¢å¹¶è°ƒç”¨ execve()ï¼Œç›´åˆ°æ‰¾åˆ° strace çš„ç¡®åˆ‡ä½ç½®ä¸ºæ­¢ (å¦‚æœæˆåŠŸæ‰§è¡Œï¼Œå‡½æ•°ä¸ä¼šè¿”å›)ã€‚çˆ¶è¿›ç¨‹è´Ÿè´£ä¸æ–­ä»ç®¡é“ä¸­è¯»å– strace çš„è¾“å‡ºï¼Œè§£æå‡ºç³»ç»Ÿè°ƒç”¨åå’Œæ¶ˆè€—çš„æ—¶é—´å¹¶æ·»åŠ åˆ°æ•°æ®ç»“æ„ä¸­ï¼Œæ¯éš”ä¸€æ®µæ—¶é—´è¾“å‡ºä¸€æ¬¡ã€‚\nä»¥ä¸‹ä¸»è¦è®°å½•å®éªŒä¸­é‡åˆ°çš„ä¸€äº›æœ‰è¶£çš„ç»†èŠ‚ã€‚\ndup() vs dup2() åˆ›å»ºç®¡é“ä»¥åï¼Œæˆ‘ä»¬ä¼šæœ‰å°†å­è¿›ç¨‹çš„æ ‡å‡†è¾“å‡ºå’Œçˆ¶è¿›ç¨‹çš„æ ‡å‡†è¾“å…¥è¿æ¥åˆ°ç®¡é“çš„å†™å£/è¯»å£çš„éœ€æ±‚ã€‚æˆ‘ä»¬å¯èƒ½ä¼šå†™å‡ºè¿™æ ·çš„ä»£ç ï¼š","tags":null,"title":"MiniLab 03: Syscall Profiler","type":"docs"},{"authors":["Yuyao Wang"],"categories":null,"content":" Click the Slides button above to demo Academic\u0026rsquo;s Markdown slides feature. Supplementary notes can be added here, including code and math.\n","date":1554595200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1554595200,"objectID":"557dc08fd4b672a0c08e0a8cf0c9ff7d","permalink":"https://kristoff-starling.github.io/publication/preprint/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/preprint/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example preprint / working paper","type":"publication"},{"authors":[],"categories":[],"content":"DL Library Fuzzing Bug Report Source: release notes of latest versions, Github PRs Version: TensorFlow 2.8\u0026amp;2.9, PyTorch 1.12 Amount: 40 Multi-API triggered bugs: 8 (all in PyTorch) Typical Bugs PyTorch, GitHub #73187\nError: unexpected RuntimeError\nimport torch grad_output = torch.full((1, 1, 1, 4, 4,), 1, dtype=torch.float64, requires_grad=True) input = torch.full((5, 5, 5, 5, 5,), 3.5e+35, dtype=torch.float64, requires_grad=True) grid = torch.full((1, 1, 1, 4, 4,), 1, dtype=torch.float64, requires_grad=True) interpolation_mode = 0 padding_mode = 0 align_corners = True res = torch.grid_sampler_3d(input, grid, interpolation_mode, padding_mode, align_corners) grad_out = torch.zeros_like(res) torch.autograd.backward(res, grad_tensors=grad_out) grid_sampler_3d() + backward()\nTypical Bugs PyTorch, GitHub #75781\nError: unexpected warning\nimport torch if __name__ == \u0026quot;__main__\u0026quot;: n = 8 x = torch.zeros(n).normal_() x.requires_grad = True z = torch.fft.irfft(x).sum() z.backward() fft() + irfft() + sum() + backward()\nTypical Bugs PyTorch, GitHub #77245\nError: unexpected RuntimeError\nimport torch def fn(input): offset = 0 fn_res = torch.diagonal(input, offset=offset, ) return fn_res input = torch.rand([0, 1], dtype=torch.complex128, requires_grad=True) torch.autograd.gradcheck(fn, (input), check_forward_ad=True, check_backward_ad=False) gradcheck() + diagonal() + function parameter\nTypical Bugs PyTorch, GitHub #77526\nError: man-made assertion error\na = torch.randn((2, 2), dtype=torch.cfloat).transpose(0, 1) result = torch.abs(a) assert a.stride() == b.stride() transpose() + abs() + stride()\nSummary Linux kernel(system) v.s. DL libraries(tool kit) Common bug types Integer overflow, division by zero Out of memory(OOM), Out of bound(OOB) missing validation Documentation Documentation Semantics Learning-based semantics \u0026lsquo;understanding\u0026rsquo; seems inevitable. $\\Rightarrow$ NLP work\nAn interesting bug: PyTorch, GitHub #70657\nimport torch assert torch.ones(10)[::2].ravel().is_contiguous() == True The assertion comes from the document: \"ravel() returns a contiguous flattened tensor\".\nDocumentation Structure The \u0026ldquo;Python API\u0026rdquo; module is divided into 54 sections, including torch, torch.nn, torch.cuda etc.\nThe torch.nn section is divided into 20 subsections, including \u0026ldquo;Convolutional layers\u0026rdquo;, \u0026ldquo;Pooling layers\u0026rdquo;, \u0026ldquo;Padding layers\u0026rdquo; etc. The section contains 186 APIs in total.\nSubsection \u0026ldquo;Convolutional layers\u0026rdquo; includes 14 APIs, offering rich relational information.\nDocumentation Structure Drawback: scalability (e.g. TensorFlow's doc only has coarse categories and lots of APIs are sorted in chronological order.)\nFuzzing Fuzzing perspectives Model-level fuzzing: CRADLE, LEMON Sub-Model? API-level fuzzing: FreeFuzz, DeepREL, DocTer Sub-API? Sub-Model Fuzzing Model-level: precison loss, hard for mutation\u0026hellip; API-level: complicated situations uncovered Sub-model level fuzzing serves as an auxiliary approach to cover more cases. The scale of sub-models/combinations of APIs should be small. Example: PyTorch, GitHub #74404 import torch from torch import nn class MyModule(nn.Module): def __init__(self): super().__init__() self.module_list = nn.ModuleList([nn.Linear(1,1) for _ in range(10)]) self.parameter_list = nn.ParameterList([nn.Parameter(torch.zeros(1)) for _ in range(10)]) def forward(self, x): for m in self.module_list: x = m(x) return x if __name__ == '__main__': model = MyModule() optimize = True with torch.jit.optimized_execution(optimize): a = torch.jit.script(model, 2) Sub-API Fuzzing Under Python APIs: C++ codes\nIdea:\nMost bugs come from missing validations/boundary argument values. The propagation chain of a bug: fault $\\to$ error $\\to$ failure #error \u0026gt; #failure Open the state machine\nExample: assertion injections TensorFlow: CVE-2022-21725 (division by 0)\nint64_t GetOutputSize(const int64_t input, const int64_t filter, const int64_t stride, const Padding\u0026amp; padding) { + assert(stride != 0); if (padding == Padding::VALID) { return (input - filter + stride) / stride; // what if stride = 0 ? } else { // SAME. return (input + stride - 1) / stride; } } Example: assertion injections TensorFlow: CVE-2022-21728 (heap OOB)\nstatic DimensionHandle DimKnownRank(ShapeHandle s, int64_t idx) { + assert(-s-\u0026gt;dims_.size() \u0026lt;= idx \u0026amp;\u0026amp; idx \u0026lt; s-\u0026gt;dims_.size()); CHECK_NE(s-\u0026gt;rank_, kUnknownRank); if (idx \u0026lt; 0) { return s-\u0026gt;dims_[s-\u0026gt;dims_.size() + idx]; } return s-\u0026gt;dims_[idx]; } Example: assertion injections TensorFlow: CVE-2022-23589 (null pointer dereference)\nNodeDef* mul_left_child = node_map_-\u0026gt;GetNode(node-\u0026gt;input(0)); NodeDef* mul_right_child = node_map_-\u0026gt;GetNode(node-\u0026gt;input(1)); + assert(mul_left_child != NULL \u0026amp;\u0026amp; mul_right_child != NULL); const bool left_child_is_constant = IsReallyConstant(*mul_left_child); const bool right_child_is_constant = IsReallyConstant(*mul_right_child); ","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"32289cc6e2d5280519de71d4379386a1","permalink":"https://kristoff-starling.github.io/slides/20220727/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/20220727/","section":"slides","summary":"An introduction to using Academic's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":[],"categories":[],"content":"Atheris Automation Methodology Use FreeFuzz\u0026rsquo;s tests as templates Substitute concrete values with appropriate functions arg_1 = 56 --\u0026gt; arg_1 = fh.get_int() arg_1 = [-1.0, 6.0] --\u0026gt; arg_1 = fh.get_float_list() padding = 'VALID' --\u0026gt; padding = fh.get_string(type=padding) An Example: def TestOneInput(data): fh = FuzzingHelper(data) arg_0_tensor = fh.get_random_tensor( shape=None, dtype_set=[tf.float16, tf.float32, tf.float64, tf.int32, tf.int64], min_size=1, max_size=8) arg_0 = tf.identity(arg_0_tensor) dtype = tf.float16 _ = tf.cast(arg_0,dtype=dtype,) Issue: lots of APIs contains hidden specifications.\nExample: tf.nn.conv2d()\nSpecification: The input tensor may have rank 4 or higher. padding should be in {'VALID', 'SAME'} A dummy test such as arg_0 = fh.get_random_tensor() arg_1 = fh.get_random_tensor() strides = fh.get_int() padding = fh.get_string() _ = tf.nn.conv2d(arg_0,arg_1,strides=strides,padding=padding,) will fail. Solution: use FreeFuzz to find specifications through trials and errors.\nExample:\nGoal: Identify whether the API accepts negative inputs. Steps: Obtain a valid FreeFuzz test. Substitute the argument with \u0026ldquo;-1\u0026rdquo;. Execute the modified tests and try to catch exceptions. int/float: value range int/float list: length, negative value string: special names (reduction/padding/activation/channel) Tensor: dtype, shape(length, value range) Sometimes, two lists/tensors are required to have the same length/dimension. In this situation, we analyze the structure of an invocation and try to add restrictions on arguments on the same level. Results Success Rate (Here success means that the test terminates without \"InvalidArgument\" errors.)\nBefore specification learning: \u0026lt;50% After specification learning: 478/533, 89.6% Coverage 5 untrivial APIs were selected for coverage test:\ntf.random.stateless_parameterized_truncated_normal tf.optimizers.schedules.ExponentialDecay tf.keras.layers.SpatialDropout3D tf.keras.layers.Convolution3DTranspose tf.keras.initializers.LecunNormal 150 tests were generated for each API\nCoverage The dummy test\nimport tensorflow as tf covers 70005 lines. Besides that,\nFreeFuzz\u0026rsquo;s tests cover 1151 lines. Atheris\u0026rsquo;s tests cover 1040 lines. 1038 of which are common. Current Problems We cannot learn complicated specifications through simple experiments. FreeFuzz itself is not very stable: some tests rely on random seeds to run normally. We haven\u0026rsquo;t found bugs through these tests. Some OOM bugs have been caught but it seems that they are false positive bugs due to my local machine limitations. ","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"3dc8db85422fdd097f5b7eb557a8c0b7","permalink":"https://kristoff-starling.github.io/slides/20220907/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/20220907/","section":"slides","summary":"Atheris Automation Methodology Use FreeFuzz\u0026rsquo;s tests as templates Substitute concrete values with appropriate functions arg_1 = 56 --\u0026gt; arg_1 = fh.get_int() arg_1 = [-1.0, 6.0] --\u0026gt; arg_1 = fh.get_float_list() padding = 'VALID' --\u0026gt; padding = fh.","tags":[],"title":"Slides","type":"slides"},{"authors":[],"categories":[],"content":"C/C++ Coverage Methods We found that running programs with Atheris will not produce coverage information, i.e. \".gcda\" files. Jiawei has created an issue in Atheris's GitHub repository. We manage to walk around this issue by tracing the bytes generated by Atheris and replay the tests natively. Results 5 APIs, 100 tests under FreeFuzz \u0026 Atheris\nHow many lines are covered. How many lines are covered only by FreeFuzz/Atheris. How many lines are executed more. tf.keras.initializers.LecunNormal\nOverall:\nUnique More execution Total FreeFuzz 211 2390 6447 Atheris 105 1468 6342 TensorFlow:\nUnique More execution Total FreeFuzz 109 1080 3735 Atheris 33 884 3659 tf.keras.layers.Convolution3DTranspose\nAll:\nUnique More Execution Total FreeFuzz 192 5884 16423 Atheris 163 1457 16394 TensorFlow:\nUnique More Execution Total FreeFuzz 80 2907 5649 Atheris 11 461 5580 tf.optimizers.schedules.ExponentialDecay\nAll:\nUnique More Execution Total FreeFuzz 194 2307 6511 Atheris 117 2383 6434 TensorFlow:\nUnique More Execution Total FreeFuzz 166 1340 3872 Atheris 15 1311 3720 tf.losses.CategoricalHinge\nAll:\nUnique More Execution Total FreeFuzz 34 181 7045 Atheris 52 3136 7064 TensorFlow:\nUnique More execution Total FreeFuzz 20 25 4171 Atheris 1 1871 4153 tf.math.reduce_sum\nAll:\nUnique More Execution Total FreeFuzz 589 2955 7247 Atheris 178 1992 6838 TensorFlow:\nUnique More Execution Total FreeFuzz 350 1805 4257 Atheris 57 994 3965 ","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"e76eb6a52708786ebb499e1735bbde8b","permalink":"https://kristoff-starling.github.io/slides/20220923/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/20220923/","section":"slides","summary":"C/C++ Coverage Methods We found that running programs with Atheris will not produce coverage information, i.e. \".gcda\" files. Jiawei has created an issue in Atheris's GitHub repository. We manage to walk around this issue by tracing the bytes generated by Atheris and replay the tests natively.","tags":[],"title":"Slides","type":"slides"},{"authors":[],"categories":[],"content":"Scalability Setup 1000 times for each API (FreeFuzz\u0026rsquo;s standard) Including invalid inputs Total coverage (including C++\u0026rsquo;s libraries) Coverage 209 APIs were tested. Approximately 150 new lines per API. 4158 new lines are covered, 567 of which are \u0026ldquo;completely new\u0026rdquo;. Speed Approximately 5 min per API (with coverage test) :( Several seconds per API (generate tests only) Optimization Three strategies:\nSuccessful-execution path: Leverage FreeFuzz\u0026rsquo;s mutation strategies. (working) Non-aggresive argument generation (with learned specifications) Error-handling path: Aggresive argument generation (no specification) Atheris Test Framework Example: tf.tile\ndef TestOneInput(data): fh = FuzzingHelper(data) aggresive = False if fh.random_dice(0.3) else True follow_freefuzz = False if fh.random_dice(0.6) else True arg_0_tensor = get_argument_arg_0_tensor( name='arg_0_tensor', fh, aggresive=aggresive, follow_freefuzz=follow_freefuzz) arg_0 = tf.identity(arg_0_tensor) arg_1 = get_argument_arg_1( name='arg_1', fh, aggresive=aggresive, follow_freefuzz=follow_freefuzz) _ = tf.tile(arg_0, arg_1,) Atheris Test Framework (cont\u0026rsquo;d) def get_argument_arg_0_tensor(name, fh, aggresive=False, follow_freefuzz=False): global argument_dict if name not in argument_dict: follow_freefuzz = False if follow_freefuzz is True: res = fh.mutate(argument_dict[name]) elif not aggresive: res = fh.get_random_tensor(shape=None, dtype_set=[tf.float16, tf.float32, tf.float64, tf.int32, tf.int64], min_size=3, max_size=3) else: res = fh.get_random_tensor() argument_dict[name] = res return res ","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"fd772302ba339b112e45985d1982341f","permalink":"https://kristoff-starling.github.io/slides/20220930/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/20220930/","section":"slides","summary":"Scalability Setup 1000 times for each API (FreeFuzz\u0026rsquo;s standard) Including invalid inputs Total coverage (including C++\u0026rsquo;s libraries) Coverage 209 APIs were tested. Approximately 150 new lines per API. 4158 new lines are covered, 567 of which are \u0026ldquo;completely new\u0026rdquo;.","tags":[],"title":"Slides","type":"slides"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Academic Academic | Documentation\nFeatures Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides Controls Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;) Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\nFragments Make content appear incrementally\n{{% fragment \u0026quot;weight\u0026quot;=1%}} One {{% /fragment %}} {{% fragment \u0026quot;weight\u0026quot;=1%}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}} Press Space to play!\nOne **Two** Three A fragment can accept two optional parameters:\nclass: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}} Press the S key to view the speaker notes!\nOnly the speaker can read these notes Press S key to view Themes black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/img/boards.jpg\u0026quot; \u0026gt;}} {{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}} {{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}} Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; } Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"https://kristoff-starling.github.io/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Academic's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"d1311ddf745551c9e117aa4bb7e28516","permalink":"https://kristoff-starling.github.io/project/external-project/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/external-project/","section":"project","summary":"An example of linking directly to an external project website using `external_link`.","tags":["Demo"],"title":"External Project","type":"project"},{"authors":null,"categories":null,"content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\n","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"8f66d660a9a2edc2d08e68cc30f701f7","permalink":"https://kristoff-starling.github.io/project/internal-project/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/internal-project/","section":"project","summary":"An example of using the in-built project page.","tags":["Deep Learning"],"title":"Internal Project","type":"project"},{"authors":["Yuyao Wang","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software. Click the Slides button above to demo Academic\u0026rsquo;s Markdown slides feature. Supplementary notes can be added here, including code and math.\n","date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1441065600,"objectID":"966884cc0d8ac9e31fab966c4534e973","permalink":"https://kristoff-starling.github.io/publication/journal-article/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/journal-article/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example journal article","type":"publication"},{"authors":["Yuyao Wang","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software. Click the Slides button above to demo Academic\u0026rsquo;s Markdown slides feature. Supplementary notes can be added here, including code and math.\n","date":1372636800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1372636800,"objectID":"69425fb10d4db090cfbd46854715582c","permalink":"https://kristoff-starling.github.io/publication/conference-paper/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/conference-paper/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example conference paper","type":"publication"},{"authors":null,"categories":null,"content":" Introduction Data and Functions Enumerated Types Days of the Week Booleans Types New Types from Old Module Tuples Numbers Proof by Simplification Proof by Rewriting Proof by Case Analysis Fixpoints and Structural Recursion (Optional) Exercises Exercise: 1 star, standard (nandb) Exercise: 1 star, standard (andb3) Exercise: 1 star, standard (factorial) Exercise: 1 star, standard (ltb) Exercise: 1 star, standard (plus_id_exercise) Exercise: 1 star, standard (mult_n_1) Exercise: 2 stars, standard (andb_true_elim2) Exercise: 1 star, standard (zero_nbeq_plus_1) Exercise: 2 stars, standard, optional (decreasing) Exercise: 1 star, standard (identity_fn_applied_twice) Exercise: 1 star, standard (negation_fn_applied_twice) Exercise: 3 stars, standard, optional (andb_eq_orb) Exercise: 3 stars, standard (binary) Introduction å‡½æ•°å¼ç¼–ç¨‹ (functional programming) çš„æ€æƒ³æ¥è‡ªäºï¼šå¦‚æœä¸€ä¸ªè¿‡ç¨‹æˆ–æ–¹æ³•æ²¡æœ‰å‰¯ä½œç”¨ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªå…³å¿ƒå®ƒå¦‚ä½•å°†è¾“å…¥æ˜ å°„åˆ°è¾“å‡ºï¼Œå³è¿™ä¸ªè¿‡ç¨‹/æ–¹æ³•æ˜¯ä¸€ä¸ªæ•°å­¦å‡½æ•°çš„å…·ä½“å®ç°ã€‚å‡½æ•°å¼ç¼–ç¨‹çš„å¦ä¸€ä¸ªæƒ³æ³•æ˜¯ï¼šæ‰€æœ‰çš„å‡½æ•°éƒ½åº”å½“è¢«å½“ä½œ first-classs valueï¼šå‡½æ•°å¯ä»¥ä½œä¸ºå‚æ•°ï¼Œå¯ä»¥ä½œä¸ºè¿”å›å€¼ï¼Œå°±åƒæ™®é€šçš„æ•°æ®ä¸€æ ·ã€‚\nData and Functions Enumerated Types Coq çš„ä¸€ä¸ªæ˜¾è‘—ç‰¹ç‚¹åœ¨äºï¼šå®ƒçš„å†…ç½® features éå¸¸çš„å°‘ã€‚ä¾‹å¦‚é™¤äº†ä¸€äº›æœ€åŸºæœ¬çš„ç±»å‹ (å¦‚ boolean, integer, strings)ï¼Œå…¶ä»–çš„ç±»å‹éƒ½å¯ä»¥ç”±ç”¨æˆ·è‡ªå·±é€šè¿‡åŸºæœ¬ç±»å‹æ¥å®šä¹‰ã€‚\nDays of the Week Inductive day : Type := | monday | tuesday | wednesday | thursday | friday | saturday | sunday. è¿™æ®µä»£ç å®šä¹‰äº†ä¸€ä¸ªå« day çš„æ•°æ®ç±»å‹ï¼Œå®ƒçš„æˆå‘˜æœ‰ 7 ä¸ªã€‚åŸºäºè¿™ä¸ªç±»å‹ï¼Œæˆ‘ä»¬å¯ä»¥ä¹¦å†™ä¸€äº›å‡½æ•°ï¼š\nDefinition next_weekday (d : day) : day := match d with | monday =\u0026gt; tuesday | tuesday =\u0026gt; wednesday | wednesday =\u0026gt; thursday | thursday =\u0026gt; friday | friday =\u0026gt; monday | saturday =\u0026gt; monday | sunday =\u0026gt; monday end. è¿™æ®µä»£ç æ˜¾å¼åœ°ç»™å‡ºäº†å‡½æ•°å‚æ•°å’Œè¿”å›å€¼çš„ç±»å‹ã€‚äº‹å®ä¸Š Coq æ”¯æŒ type inferenceï¼Œä½†ä¸ºäº†é˜…è¯»æ–¹ä¾¿è¿™é‡Œè¿˜æ˜¯å†™ä¸Šäº†ã€‚\nå®šä¹‰äº†å‡½æ•°ä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨ Compute å‘½ä»¤æ¥è®¡ç®—ä¸€äº›ä½¿ç”¨äº†è¿™ä¸ªå‡½æ•°çš„è¡¨è¾¾å¼ï¼Œä¾‹å¦‚ï¼š\nCompute (next_weekday friday). (* ==\u0026gt; monday: day *) æˆ‘ä»¬è¿˜å¯ä»¥é€šè¿‡ Coq Example æ¥ç»™å‡ºä¸€ä¸ª assertionï¼š\nExample test_next_weekday: (next_weekday (next_weekday saturday)) = tuesday. è¿™æ ·çš„ä¸€ä¸ª Example æ˜¯éœ€è¦è¯æ˜çš„ã€‚ä¸€ä¸ªåˆæ³•çš„è¯æ˜å¦‚ä¸‹ (tactic çš„æ„ä¹‰è§åæ–‡)ï¼š\nProof. simpl. reflexivity. Qed. Booleans ç±»ä¼¼åœ°æˆ‘ä»¬å¯ä»¥å®šä¹‰ bool ç±»å‹ï¼Œä»¥åŠ negation, and, or ä¸‰ä¸ªè¿ç®—å‡½æ•°ï¼š\nInductive bool : Type := | true | false. Definition negb (b : bool) : bool := match b with | true =\u0026gt; false | false =\u0026gt; true end. Definition andb (b1 : bool) (b2 : bool) : bool := match b1 with | true =\u0026gt; b2 | false =\u0026gt; false end. Definition orb (b1 : bool) (b2 : bool) : bool := match b1 with | true =\u0026gt; true | false =\u0026gt; b2 end. æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ Notation å‘½ä»¤æ¥é€šè¿‡å·²æœ‰çš„ definitions å®šä¹‰æ–°ç¬¦å·ï¼š\nNotation \u0026quot;x \u0026amp;\u0026amp; y\u0026quot; := (andb x y). Notation \u0026quot;x || y\u0026quot; := (orb x y). åœ¨ Coq ä¸­æˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨æ¡ä»¶åˆ†æ”¯è¯­å¥ï¼Œä¸‹é¢æ˜¯ç”¨æ¡ä»¶åˆ†æ”¯è¯­å¥æè¿° and, or, neg çš„ä¾‹å­ ( if-then-else çš„æŠ˜è¡Œæ˜¯æ¯”è¾ƒéšæ„çš„)ï¼š\nDefinition negb' (b : bool) : bool := if b then false else true. Definition andb' (b1 : bool) (b2 : bool) : bool := if b1 then b2 else false. Definition orb' (b1 : bool) (b2 : bool) : bool := if b1 then true else b2. Coq çš„æ¡ä»¶åˆ†æ”¯è¯­å¥æ¯”ä¸€èˆ¬ç¼–ç¨‹è¯­è¨€çš„è¯­å¥çš„åŠŸèƒ½æ›´ general ä¸€äº›ï¼šå¯¹äºåªæœ‰ä¸¤ä¸ª constructor çš„ç±»å‹ï¼Œif X å¯ä»¥è¡¨ç¤ºå¦‚æœ X ç­‰äºç¬¬ä¸€ä¸ª constructorï¼Œè¿™é‡Œåªæ˜¯å› ä¸º bool ç±»å‹çš„ç¬¬ä¸€ä¸ª constructor æ­£å¥½æ˜¯ true æ‰€ä»¥çœ‹ä¸Šå»å’Œä¸€èˆ¬ç¼–ç¨‹è¯­è¨€æ²¡æœ‰åŒºåˆ«ã€‚\nTypes Coq ä¸­çš„æ¯ä¸ªè¡¨è¾¾å¼éƒ½æœ‰ç±»å‹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ Check å‘½ä»¤æ¥æ‰“å°ä¸€ä¸ªè¡¨è¾¾å¼çš„ç±»å‹ï¼š\nCheck true. (* ==\u0026gt; true: bool *) Check (negb true) : bool. ç¬¬äºŒç§å†™æ³•ç›¸å½“äºä¸€ä¸ª assertionï¼Œå¦‚æœç±»å‹æ­£ç¡® Coq ä¸ä¼šæœ‰ååº”ï¼Œå¦‚æœé”™è¯¯ Coq ä¼šæŠ¥é”™ã€‚\nåœ¨ Coq ä¸­ï¼Œå‡½æ•°ä¹Ÿæ˜¯æœ‰ç±»å‹çš„ï¼š\nCheck negb : bool -\u0026gt; bool. New Types from Old æˆ‘ä»¬ä¹‹å‰å®šä¹‰çš„ç±»å‹éƒ½æ˜¯ enumerated typesï¼Œå³è¿™äº›å®šä¹‰æ˜¾å¼åœ°åˆ—ä¸¾äº†ä¸€ä¸ªæœ‰ç©·çš„å…ƒç´ é›†åˆï¼Œè¿™äº›å…ƒç´ è¢«ç§°ä¸º constructorã€‚ä¸‹é¢çš„ä¸€ä¸ªæ›´å¤æ‚çš„ä¾‹å­ä¸­å‡ºç°äº† constructor å¸¦æœ‰å‚æ•°çš„ç”¨æ³•ï¼š\nInductive rgb : Type := | red | blue | green. Inductive color : Type := | black | white | primary (p : rgb). è¿™é‡Œæˆ‘ä»¬å¼•å‡º constructor expression çš„æ¦‚å¿µï¼šconstructor expression æŒ‡çš„æ˜¯ä»¥ç¬¦åˆå®šä¹‰çš„æ–¹å¼å°†ä¸€ä¸ª constructor apply åˆ°é›¶ä¸ªæˆ–å¤šä¸ª constructor expression ä¸Šã€‚è¿™é‡Œçš„ red, blue, black, white, primary red ç­‰éƒ½æ˜¯ constructor expressionã€‚\nè¿™é‡Œ color ç±»å‹æè¿°äº†å±äº color è¿™ä¸ªé›†åˆçš„ constructor expression çš„ä¸‰ç§å½¢å¼ï¼š\nblack white å¦‚æœ p æ˜¯ä¸€ä¸ªå±äº rgb çš„ constructor expressionï¼Œé‚£ä¹ˆ primary p å°±æ˜¯å±äº color çš„ constructor expressionã€‚ æˆ‘ä»¬ä»ç„¶å¯ä»¥ç”¨ pattern matching çš„æ–¹å¼æ¥å®šä¹‰å‡½æ•°ï¼š\nDefinition isred (c : color) : bool := match c with | black =\u0026gt; false | white =\u0026gt; false | pattern red =\u0026gt; true | pattern _ =\u0026gt; false end. è¿™é‡Œå‡ºç°äº†ä¸€ä¸ªæ–°ç”¨æ³•ï¼šwildcard pattern _ æ˜¯é€šé…ç¬¦ï¼Œåœ¨è¿™é‡Œå¯ä»¥åŒ¹é…æ‰€æœ‰ä¸æ˜¯ red çš„å…¶ä»–æƒ…å½¢ã€‚\nModule Coq æä¾›ä¸€å¥— module systemï¼šå¦‚æœæˆ‘ä»¬å°†ä¸€ä¸ªå®šä¹‰ foo åŒ…å«åœ¨äº† Module X å’Œ End X ä¹‹é—´ï¼Œé‚£ä¹ˆåœ¨æ¨¡å—å¤–æˆ‘ä»¬æƒ³è¦ä½¿ç”¨ foo æ—¶å°±è¦å†™æˆ X.foo è€Œä¸æ˜¯ç›´æ¥ fooã€‚module system è®©æˆ‘ä»¬å¯ä»¥ä¸ç”¨å¤ªæ‹…å¿ƒåå­—é‡å¤çš„é—®é¢˜ã€‚\nTuples ä¸€ä¸ªæ‹¥æœ‰å¤šä¸ªå‚æ•°çš„ constructor å¯ä»¥ç”¨æ¥è¡¨ç¤º tupleï¼Œä¸‹é¢çš„ä¾‹å­å±•ç¤ºäº†ä¸€ä¸ª nybble (half byte) ç±»å‹ï¼š\nInductive bit : Type := | B0 | B1 Inductive nybble: Type := | bits (b0, b1, b2, b3 : bit). åŒæ ·åœ°æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ pattern matching çš„æ–¹å¼ä¹¦å†™å‡½æ•°ï¼š\nDefinition all_zero (nb : nybble) : bool :=\tmatch nb with: | (bits B0 B0 B0 B0) =\u0026gt; true | (bits _ _ _ _\t) =\u0026gt; false end. Compute (all_zero(bits B1 B0 B1 B0)) (* ===\u0026gt; false : bool *) Compute (all_zero(bits B0 B0 B0 B0)) (* ===\u0026gt; true : bool *) Numbers ä¹‹å‰æˆ‘ä»¬å®šä¹‰çš„ type éƒ½æ˜¯æœ‰ç©·é›†åˆï¼Œè€Œè‡ªç„¶æ•°é›†æ˜¯ä¸€ä¸ªæ— ç©·é›†åˆï¼Œå› æ­¤æˆ‘ä»¬åœ¨è¿™é‡Œä½¿ç”¨å½’çº³çš„æ–¹æ³•ï¼Œæ ¹æ®è‡ªç„¶æ•°åœ¨æœ´ç´ é›†åˆè®ºä¸­çš„å®šä¹‰æ–¹å¼ç»™å‡ºè‡ªç„¶æ•°çš„å®šä¹‰ï¼š\nInductive nat : Type := | O | S (n : nat). è¯¥å®šä¹‰çš„æ„æ€æ˜¯ï¼š\nO æ˜¯ä¸€ä¸ªå±äº nat é›†åˆçš„ constructor expressionã€‚ å¦‚æœ n æ˜¯ä¸€ä¸ªå±äº nat é›†åˆçš„ constructor expressionï¼Œé‚£ä¹ˆ S n ä¹Ÿå±äº nat é›†åˆã€‚ é™¤äº†ä»¥ä¸Šä¸¤æ¡ï¼Œæ²¡æœ‰åˆ«çš„ constructor expression åœ¨ nat é›†åˆä¸­ã€‚ å€¼å¾—æ³¨æ„çš„æ˜¯ï¼šè¿™é‡Œçš„ O å’Œ S æ²¡æœ‰ä»»ä½•å®é™…çš„å«ä¹‰ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä»»æ„åˆ«çš„å­—ç¬¦/å•è¯æ¥æ›¿æ¢å®ƒä»¬ã€‚\nä¸‹é¢å±•ç¤ºä¸¤ä¸ªå‡½æ•°ï¼špred å’Œ minustwoï¼Œå€¼å¾—å­¦ä¹ çš„æ˜¯å…¶ä¸­ pattern matching çš„æ–¹æ³•ï¼š\nDefinition pred (n : nat) : nat := match n with: | O =\u0026gt; O | S n' =\u0026gt; n' end. Definition minustwo (n : nat) : nat := match n with: | O =\u0026gt; O | S O =\u0026gt; O | S (S n') =\u0026gt; n' end. ç”±äºè‡ªç„¶æ•°æ˜¯ä¸€ç§éå¸¸æ™®éçš„æ•°æ®ç±»å‹ï¼Œæ‰€ä»¥ Coq å†…ç½®äº†ä¸€äº›è§£æå’Œæ‰“å°è‡ªç„¶æ•°çš„å°é­”æ³•ï¼šO ä¼šè¢«è¾“å‡ºä¸º 0ï¼ŒS O ä¼šè¢«è¾“å‡ºä¸º 1ï¼Œä¾æ¬¡ç±»æ¨ã€‚æ­¤å¤–æˆ‘ä»¬ç»™å‡½æ•°ä¼ é€’å‚æ•°çš„æ—¶å€™ä¹Ÿå¯ä»¥ç›´æ¥ä½¿ç”¨é˜¿æ‹‰ä¼¯æ•°å­—è€Œä¸æ˜¯å½¢å¼åŒ–çš„ S ... S Oï¼š\nCompute (minustwo 4). (* ===\u0026gt; 2 : nat *) Check (S (S (S (S O)))). (* ===\u0026gt; 4 : nat *) æˆ‘ä»¬åœ¨å®šä¹‰è‡ªç„¶æ•°æ—¶ä½¿ç”¨çš„ constructor S å’Œå‡½æ•° pred minustwo åœ¨ç±»å‹ä¸Šæ˜¯ä¸€æ ·çš„ï¼Œ\nCheck S : nat -\u0026gt; nat. Check pred : nat -\u0026gt; nat. Check minustwo : nat -\u0026gt; nat. ä½† S å’Œå…¶ä»–ä¸¤è€…æœ‰ç€æœ¬è´¨çš„åŒºåˆ«ï¼špred å’Œ minustwo æ˜¯é€šè¿‡è®¡ç®—è§„åˆ™çš„æ–¹å¼å®šä¹‰çš„ï¼Œä¾‹å¦‚ pred 4 å’Œ 3 æ²¡æœ‰æœ¬è´¨åŒºåˆ«ï¼›ä½† S åªæ˜¯ä¸€ä¸ªè¡¨ç¤ºæ•°çš„æ–¹å¼ï¼Œæ­£å¦‚åè¿›åˆ¶ç”¨ 0~9 è¿™ 10 ä¸ªå­—ç¬¦è¡¨ç¤ºæ•°å­—ä¸€æ ·ï¼Œåœ¨æˆ‘ä»¬çš„å½’çº³ç³»ç»Ÿä¸­æˆ‘ä»¬ä½¿ç”¨ S å’Œ O è¿™ä¸¤ä¸ªå­—ç¬¦è¡¨ç¤ºæ•°å­—ï¼ŒS æœ¬èº«ä¸åŒ…å«ä»»ä½•çš„è®¡ç®—åŠŸèƒ½ã€‚\næ¥ä¸‹æ¥æˆ‘ä»¬è€ƒè™‘ä¸€äº›æ›´åŠ å¤æ‚çš„å…³äº number çš„å‡½æ•°ã€‚ä¾‹å¦‚åˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯å¦æ˜¯å¶æ•°ï¼šå¯¹äºè¿™ä¸ªé—®é¢˜æˆ‘ä»¬æ— æ³•é€šè¿‡ pattern matching çš„æ–¹æ³•ç›´æ¥ç»™å‡ºç­”æ¡ˆï¼Œå› ä¸ºå¶æ•°æœ‰æ— ç©·å¤šä¸ªã€‚æˆ‘ä»¬åªèƒ½ä½¿ç”¨é€’å½’çš„æ–¹å¼ï¼šé¦–å…ˆè§„å®š O æ˜¯å¶æ•°ï¼Œç„¶åå¯¹äºæ•´æ•° n ä¸æ–­ -2 æ¥åˆ¤æ–­å¥‡å¶æ€§ã€‚è¿™ç±»éœ€è¦ä½¿ç”¨é€’å½’çš„å‡½æ•°åº”å½“ä½¿ç”¨ Fixpoint è€Œä¸æ˜¯ Definitionï¼š\nFixpoint even (n : nat) : bool := match n with | O =\u0026gt; true | S O =\u0026gt; false | S (S n') =\u0026gt; even n' end. ä¸‹é¢æˆ‘ä»¬æ¥å®šä¹‰åŠ æ³•ï¼Œè¿™æ˜¯ä¸€ä¸ªå¤šå‚æ•°çš„å‡½æ•°ï¼š\nFixpoint plus (n : nat) (m : nat) : nat := match n with | O =\u0026gt; m | S n' =\u0026gt; S (plus n' m) end. åŠ æ³•çš„å½’çº³æ€è·¯ååˆ†å·§å¦™ï¼Œå°†ç¬¬ä¸€ä¸ªåŠ æ•°çš„ S æ–½åŠ åˆ°ç»“æœä¸Šï¼Œç›´åˆ°ç¬¬ä¸€ä¸ªåŠ æ•°ä¸º 0ã€‚ä¸‹é¢æ˜¯ Coq è®¡ç®— plus 2 3 çš„åŒ–ç®€æµç¨‹ï¼š\n(* [plus 3 2] i.e. [plus (S (S (S O))) (S (S O))] ==\u0026gt; [S (plus (S (S O)) (S (S O)))] by the second clause of the [match] ==\u0026gt; [S (S (plus (S O) (S (S O))))] by the second clause of the [match] ==\u0026gt; [S (S (S (plus O (S (S O)))))] by the second clause of the [match] ==\u0026gt; [S (S (S (S (S O))))] by the first clause of the [match] i.e. [5] *) å‡½æ•°çš„å¤šä¸ªå‚æ•°å¦‚æœç±»å‹ä¸€æ ·ä¹Ÿå¯ä»¥åˆå¹¶äº†å†™ï¼Œä¾‹å¦‚ä¸‹é¢çš„è¿™ä¸ªå‡æ³•çš„ä¾‹å­\nFixpoint minus (n m : nat) : nat := match n, m with | O , _ =\u0026gt; O | _ , O =\u0026gt; n | S n', S m' =\u0026gt; minus n', m' end. è¿™ä¸ªå‡æ³•çš„æ€è·¯ä¹Ÿååˆ†å·§å¦™ï¼šä¸æ–­å°†è¢«å‡æ•°å’Œå‡æ•°åŒæ—¶å‡å°‘ï¼Œç›´åˆ°æœ‰ä¸€ä¸ªæ˜¯ 0 ä¸ºæ­¢ã€‚\næˆ‘ä»¬å¯ä»¥ä¸ºåŠ æ³•ã€å‡æ³•ã€ä¹˜æ³• (ä»£ç çœç•¥) æ·»åŠ ç¬¦å·ï¼š\nNotation \u0026quot;x + y\u0026quot; := (plus x y) (at level 50, left associativity) : nat_scope. Notation \u0026quot;x - y\u0026quot; := (minus x y) (at level 50, left associativity) : nat_scope. Notation \u0026quot;x * y\u0026quot; := (mult x y) (at level 40, left associativity) : nat_scope. More about Notations\nè¿™é‡Œå‡ºç°äº†ä¸‰ä¸ªæ–°çš„å†…å®¹ï¼š\nlevel åé¢å¯ä»¥è·Ÿä¸€ä¸ª 0~100 çš„æ•°å€¼ï¼Œè¿™ä¸ªæ•°å€¼è§„å®šäº†è¯¥è¿ç®—çš„ä¼˜å…ˆçº§ï¼Œæ•°å­—è¶Šå°ä¼˜å…ˆçº§è¶Šå¤§ã€‚ä¸Šé¢çš„ä¾‹å­ä¸­ + å’Œ - ä¼˜å…ˆçº§ç›¸åŒï¼Œä¹˜æ³•ä¼˜å…ˆçº§æ›´é«˜ï¼Œå› æ­¤ a + b * c ç­‰ä»·äº a + (b * c)ã€‚\nassociativity æœ‰ left, right, no ä¸‰ç§ï¼Œæè¿°äº†è¯¥ç¬¦å·çš„ç»“åˆæ€§ã€‚ä¾‹å¦‚ + æ˜¯å·¦ç»“åˆçš„æ„å‘³ç€ a + b + c ç­‰ä»·äº (a + b) + cã€‚\næ¯ä¸ªç¬¦å·æœ‰å…¶ notation scopeã€‚Coq çš„è§£é‡Šå™¨ä¼šæ ¹æ®ä¸Šä¸‹æ–‡è‡ªåŠ¨åˆ†æç¬¦å·çš„ä½œç”¨åŸŸã€‚æ¯”å¦‚åœ¨ S(0x0) ä¸­ x ä¼šè¢«è®¤å®šä¸º nat_scopeï¼Œè€Œåœ¨ bool x bool ä¸­ x å°±ä¼šè¢«è®¤å®šä¸º type_scopeã€‚æœ‰äº›æƒ…å†µä¸‹æˆ‘ä»¬éœ€è¦æ˜¾å¼åœ°å¸®åŠ© Coq è§£é‡Šå™¨ç¡®å®š scopeï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ % è¯­æ³•ï¼šä¾‹å¦‚ (x+y)%natã€‚\né™¤äº†ç¬¦å·æœ‰ notation scopeï¼Œæ•°å­—ä¹Ÿå¯ä»¥æŒ‡å®š scopeï¼Œä¾‹å¦‚ 0%nat å’Œ 0%Z ä¸€ä¸ªæ˜¯è‡ªç„¶æ•° 0ï¼Œä¸€ä¸ªæ˜¯æ•´æ•° 0ï¼Œå®ƒä»¬æ¥è‡ªä¸åŒçš„æ ‡å‡†åº“ã€‚\næ¥ä¸‹æ¥å†å±•ç¤ºä¸€ä¸ªç»™ä¸¤ä¸ªæ•°æ¯”å¤§å°çš„å‡½æ•° (åœ¨ Coq ä¸­ï¼Œä¸€åˆ‡éƒ½å¾—è‡ªå·±å®šä¹‰)ï¼š\nFixpoint leb (n m : nat) : bool := match n with | O =\u0026gt; true | S n' =\u0026gt; match m with | O =\u0026gt; false | S m' =\u0026gt; leb n' m' end end. å½“ç„¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ç”¨åƒå‡æ³•é‚£æ ·çš„è¯­æ³•ï¼Œè¿™é‡Œä¸»è¦æƒ³å±•ç¤ºçš„æ˜¯ match çš„åµŒå¥—ä½¿ç”¨ã€‚\nNotation \u0026quot;x =? y\u0026quot; := (eqb x y) (at level 70) : nat_scope. Notation \u0026quot;x \u0026lt;=? y\u0026quot; := (leb x y) (at level 70) : nat_scope. è¿™é‡ŒåŒºåˆ†ä¸€ä¸‹ = å’Œ =? ï¼šx = y æ˜¯ä¸€ä¸ªå‘½é¢˜ (proposition)ï¼Œç»™å‡ºè¿™æ ·ä¸€ä¸ª claim æ˜¯éœ€è¦è¯æ˜çš„ï¼›è€Œ x =? y æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå¯ä»¥ç›´æ¥è®¡ç®—å‡º true/falseã€‚\nProof by Simplification æˆ‘ä»¬å·²ç»æœ‰äº†ä¸€ç³»åˆ—å®šä¹‰å’Œå‡½æ•°ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å¯ä»¥è¯æ˜ä¸€äº›å®šç†ã€‚\nTheorem plus_O_n: forall n : nat, 0 + n = n. Proof. intros n. simpl. reflexivity. Qed. æˆ‘ä»¬å¯¹å®šç†å’Œè¯æ˜ä¸­çš„ä¸€äº›å…ƒç´ åšä¸€ç‚¹è¯´æ˜ï¼š\nåœ¨ Coq ä¸­ï¼ŒExample Theorem Lemma Fact Remark æ²¡æœ‰æœ¬è´¨åŒºåˆ«ã€‚ åœ¨å®šç†ä¸­æˆ‘ä»¬ä½¿ç”¨äº†å…¨ç§°é‡è¯ forallã€‚è”æƒ³äººç±»åœ¨è¯æ˜çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯¹äºè¿™ç±»å®šç†é€šå¸¸ä¼šå†™ä¸‹â€œå¯¹äºä»»æ„è‡ªç„¶æ•°n\u0026hellip;â€ ä»è€Œåœ¨æ¥ä¸‹æ¥çš„è¯æ˜ä¸­æŠŠ n å½“ä½œä¸€ä¸ªâ€œå…·ä½“â€çš„æ•°ä½¿ç”¨ã€‚åœ¨ Coq ä¸­æˆ‘ä»¬å¯ä»¥é€šè¿‡ intros æ¥å®Œæˆè¿™ä¸€æ­¥éª¤ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯è¿™é‡Œ intros åé¢å…¶å®å¯ä»¥ä½¿ç”¨ä»»æ„ç¬¦å·ï¼Œä¸ä¸€å®šè¦å’Œå‘½é¢˜ä¸­çš„ n ä¿æŒä¸€è‡´ã€‚ åœ¨æœ¬è¯æ˜ä»¥åŠä¸Šé¢çš„æ‰€æœ‰è¯æ˜ä¸­ï¼Œç”¨äºåŒ–ç®€çš„ simpl å…¶å®éƒ½æ˜¯ä¸éœ€è¦çš„ï¼Œå› ä¸º reflexivity è‡ªå¸¦äº†åŒ–ç®€åŠŸèƒ½ï¼Œè¿™é‡Œæœ‰æ„æ˜¾å¼åœ°å†™å‡º simpl æ˜¯ä¸ºäº†èƒ½æ›´å¥½åœ°çœ‹åˆ°è¯æ˜åŒ–ç®€çš„ä¸­é—´è¿‡ç¨‹ã€‚å€¼å¾—ä¸€æçš„æ˜¯ reflexivity çš„åŒ–ç®€åŠŸèƒ½æ¯” simpl æ›´å¼ºå¤§ï¼šå®ƒè¿˜å¯ä»¥å°†å¤æ‚å®šä¹‰å±•å¼€ã€‚ è¿™é‡Œçš„å…³é”®è¯ intros simpl reflexivity éƒ½æ˜¯ tacticã€‚tactic æŒ‡çš„æ˜¯è¯æ˜è¿‡ç¨‹ä¸­ç”¨äºæ¨è¿›è¯æ˜è¿‡ç¨‹ï¼Œæ£€éªŒç»“æœæ­£ç¡®çš„ä¸€äº›å‘½ä»¤ã€‚\nProof by Rewriting ä¸‹é¢çš„è¿™ä¸ªå®šç†æ¯”ä¹‹å‰çš„è¦æ›´åŠ å¤æ‚å’Œæœ‰è¶£ä¸€äº›ï¼š\nTheorem plus_id_example : forall n m : nat, n = m -\u0026gt; n + n = m + m è¿™ä¸ªå®šç†ä¸­å‡ºç°äº†è•´å«å…³ç³»ç¬¦ã€‚ç”±äº n å’Œ m éƒ½æ˜¯ä»»æ„æ•´æ•°ï¼Œæˆ‘ä»¬æ— æ³•ç›´æ¥é€šè¿‡ç®€å•çš„åŒ–ç®€æ¥è¯æ˜æœ€åçš„ç­‰å¼ã€‚ä½†æˆ‘ä»¬æ³¨æ„åˆ°åœ¨ n = m çš„å‡è®¾ä¸‹æˆ‘ä»¬å¯ä»¥å°†ç­‰å¼ä¸­çš„ n éƒ½ç”¨ m æ¥ä»£æ›¿ã€‚åœ¨ Coq ä¸­ rewrite è¿™ä¸ª tactic è´Ÿè´£è¿›è¡Œè¿™ç§æ›¿æ¢ã€‚\nProof. intros n m. intros H. rewrite -\u0026gt; H. reflexivity. Qed. ç¬¬äºŒè¡Œçš„ intros H è¡¨ç¤ºæˆ‘ä»¬å°† n = m è¿™æ¡å‡è®¾åŠ å…¥åˆ°ä¸Šä¸‹æ–‡ä¸­ï¼Œå¹¶ç»™å…¶å‘½åä¸º Hã€‚ç¬¬ä¸‰æ¡è¯­å¥è¡¨ç¤ºåˆ©ç”¨å‡è®¾ H å°†ç›®æ ‡ä¸­çš„ç­‰å¼å·¦ä¾§çš„å†…å®¹æ›¿æ¢æˆç­‰å¼å³ä¾§çš„å†…å®¹ã€‚rewrite ä¸­çš„ -\u0026gt; è¡¨ç¤ºç”¨ RHS æ›¿æ¢ LHSï¼Œå¦‚æœå†™æˆ \u0026lt;- åˆ™æ˜¯ç”¨ LHS æ›¿æ¢ RHSã€‚\nCheck å‘½ä»¤ä¸ä»…å¯ä»¥æ£€æŸ¥ç±»å‹ï¼Œè¿˜å¯ä»¥æ‰“å°ä¸€ä¸ªå®šç†çš„å†…å®¹ã€‚ä¸‹é¢ä¸¤ä¸ªå®šç†æ˜¯åœ¨æ ‡å‡†åº“ä¸­è¯æ˜è¿‡çš„ï¼š\nCheck mult_n_O. (* ===\u0026gt; forall n : nat, 0 = n * 0 *) Check mult_n_Sm. (* ===\u0026gt; forall n m : nat, n * m + n = n * S m *) rewrite tactic é™¤äº†å¯ä»¥åˆ©ç”¨å‘½é¢˜ä¸­çš„å‡è®¾ç­‰å¼è¿›è¡Œæ›¿æ¢ï¼Œè¿˜å¯ä»¥åˆ©ç”¨å·²ç»è¯æ˜çš„å®šç†è¿›è¡Œæ›¿æ¢ï¼Œä¾‹å¦‚ï¼š\nTheorem mult_n_0_m_0 : forall p q : nat, (p * 0) + (q * 0) = 0. Proof. intros p q. rewrite \u0026lt;- mult_n_O. rewrite \u0026lt;- mult_n_O. reflexivity. Qed. è¯æ˜ä¸­è¿ç»­ä¸¤æ¬¡åˆ©ç”¨ mult_n_O å®šç†è¿›è¡Œæ›¿æ¢ï¼Œæ¯æ¬¡æ‰§è¡Œæ›¿æ¢æ—¶ Coq çš„è§£é‡Šå™¨ä¼šè‡ªåŠ¨åœ¨ç›®æ ‡ç­‰å¼ä¸­å¯»æ‰¾å®šç†çš„ instanceã€‚\nProof by Case Analysis æœ‰çš„æ—¶å€™æˆ‘ä»¬ä¸å¾—ä¸åˆ†æƒ…å†µè®¨è®ºã€‚è¿™é‡Œé¦–å…ˆç»™å‡ºä¸€ä¸ªåˆ†æƒ…å†µè®¨è®ºçš„è¯æ˜è¿‡ç¨‹çš„ä¾‹å­ï¼š\nTheorem negb_involutive : forall b : bool, negb (negb b) = b. Proof. intros b. destruct b eqn:E - reflexivity. - reflexivity. Qed. å‘½é¢˜ä¸­çš„ b ç”±äºæ˜¯ä¸€ä¸ªä¸ç¡®å®šçš„å˜é‡ï¼Œæ— æ³•ç›´æ¥åŒ–ç®€ï¼Œæˆ‘ä»¬éœ€è¦åˆ†æƒ…å†µè®¨è®º b = true å’Œ b = falseã€‚\ndestruct è¿™ä¸ª tactic ç”¨äºåˆ†ç±»è®¨è®ºï¼Œå®ƒå¯ä»¥é’ˆå¯¹æ‰€æœ‰ inductively å®šä¹‰çš„æ•°æ®ç±»å‹ä½¿ç”¨ã€‚ä½¿ç”¨ destruct ç›¸å½“äºåˆ†åˆ«å°† b çœ‹ä½œå®ƒå®šä¹‰ä¸­çš„ç¬¬ä¸€ï¼Œç¬¬äºŒâ€¦â€¦ä¸ª constructorï¼Œä½œå‡º assumption å¹¶åˆ›å»ºè‹¥å¹²ä¸ª subgoalã€‚è¿™é‡Œå¯¹äº bool ç±»å‹ç›¸å½“äºåˆ†åˆ«å‡è®¾ b = true å’Œ b = falseã€‚ä½œå‡ºå‡è®¾åï¼Œdestruct ä¼šé¡ºæ‰‹æŠŠå‡è®¾çš„å†…å®¹ \u0026ldquo;rewrite\u0026rdquo; è¿›å»ã€‚ eqn:E è´Ÿè´£ç»™åšå‡ºçš„å‡è®¾å‘½åï¼Œä¹‹åå¯ä»¥é€šè¿‡ E æ¥ä½¿ç”¨è¿™ä¸ªå‡è®¾ã€‚è¿™ä¸€æ­¥ä¸æ˜¯å¿…è¦çš„ï¼Œä½†è¿™æ˜¯ä¸€ä¸ªå¥½çš„ä¹ æƒ¯ã€‚ - ç§°ä¸º bulletï¼Œè´Ÿè´£åˆ’åˆ†å„ä¸ª subgoal çš„è¯æ˜è¿‡ç¨‹ã€‚bullet ä¸æ˜¯å¿…è¦çš„ï¼Œå¦‚æœçœç•¥ï¼ŒCoq ä¼šå°†ä½ çš„æŒ‰ç…§ subgoal çš„é¡ºåºå°†ä½ çš„è¯æ˜è¿‡ç¨‹ä¸€ä¸€ä»£å…¥ã€‚ä½†ä½¿ç”¨ bullet ä¼šä½¿ä½ çš„è¯æ˜è¿‡ç¨‹ç»“æ„æ›´æ¸…æ™°ã€æ›´å¯è¯»ã€‚ ä¸‹é¢æ˜¯ä¸€ä¸ªç¨å¤æ‚çš„ä¾‹å­ï¼š\nTheorem plus_1_neq_0_firsttry : forall n : nat, (n + 1) =? 0 = false. Proof. intros n. simpl. (* does nothing! *) Abort. æˆ‘ä»¬ç›´æ¥ä½¿ç”¨ simpl æ— æ³•åŒ–ç®€è¿™ä¸ªå¼å­ã€‚è¿™é‡Œå€¼çš„æ³¨æ„çš„ä¸€ç‚¹æ˜¯ï¼šå¦‚æœæˆ‘ä»¬è¦è¯æ˜çš„å‘½é¢˜æ˜¯ (1 + n) =? 0 = falseï¼Œé‚£ä¹ˆ simpl å°±ç®¡ç”¨äº†ï¼Œå› ä¸º 1 + n ä¼šè¢«è®¡ç®—æˆ S nï¼ŒS n =? 0 å¯ä»¥ç›´æ¥åˆ¤å®šä¸º falseã€‚è¿™é‡Œæ— æ³•è®¡ç®—æ˜¯å› ä¸ºæˆ‘ä»¬å®šä¹‰çš„åŠ æ³•æ˜¯é’ˆå¯¹ç¬¬ä¸€ä¸ªå‚æ•°è¿›è¡Œé€’å½’çš„ï¼Œè€Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªæ— æ³•ç¡®å®šå…·ä½“å€¼çš„ nï¼Œæ‰€ä»¥ simpl æ— æ³•åŒ–ç®€ã€‚\næˆ‘ä»¬åˆ†ç±»è®¨è®ºçš„ç­–ç•¥æ˜¯çœ‹ n æ˜¯ O è¿˜æ˜¯ S n'ã€‚è¿™é‡Œç»™å‡ºè¯æ˜è¿‡ç¨‹ï¼š\nTheorem plus_1_neg_0 : forall n : nat, (n + 1) ?= 0 = false. Proof. intros n. destruct n as [| n'] eqn:E. - reflexivity. - reflexivity. Qed. è¿™é‡Œæ–°å‡ºç°äº† [| n']ã€‚å’Œä¸Šä¸€ä¸ªä¾‹å­ä¸åŒï¼Œè‡ªç„¶æ•°çš„å®šä¹‰çš„ç¬¬äºŒä¸ª constructor æ˜¯å¸¦å‚æ•°çš„ï¼Œå› æ­¤æˆ‘ä»¬è¦ç”¨ä¸€å¯¹ä¸­æ‹¬å· [] ç»™å‡ºæ¯ä¸€ä¸ª constructor çš„å‚æ•°åˆ—è¡¨ï¼Œä¸åŒ constructor çš„å‚æ•°åˆ—è¡¨ä¹‹é—´ç”¨ | éš”å¼€ (è‡ªç„¶æ•°çš„ç¬¬ä¸€ä¸ª constructor æ˜¯ O æ²¡æœ‰å‚æ•°ï¼Œå› æ­¤ | å·¦è¾¹ç•™ç©º)ã€‚å¦‚æœæ²¡æœ‰ç”¨ [] æ˜¾å¼åœ°è¯´æ˜å‚æ•°çš„åç§°ï¼ŒCoq ä¼šè‡ªåŠ¨åˆ†é…å‚æ•°åï¼Œä½†è‡ªåŠ¨åˆ†é…çš„å‚æ•°åå¯èƒ½ä¼šå¾ˆå¥‡æ€ªï¼Œä»è€Œå½±å“åç»­çš„è¯æ˜ã€‚\nåˆ†ç±»è®¨è®ºå¯ä»¥åµŒå¥—è¿›è¡Œï¼Œä¾‹å¦‚ä¸‹é¢çš„è¯æ˜ and è¿ç®—æ»¡è¶³äº¤æ¢å¾‹çš„è¿‡ç¨‹ï¼š\nTheorem andb_commutative: forall b c : bool, andb b c = andb c b. Proof. intros b c. destruct b eqn Eb. - destruct c eqn:Ec. + reflexivity. + reflexivity. - destruct c eqn:Ec. + reflexivity. + reflexivity. Qed. ä¸åŒå±‚çº§å¿…é¡»ä½¿ç”¨ä¸åŒçš„ bulletã€‚å¯ä»¥ä½¿ç”¨çš„ bullet æœ‰ - + * ä»¥åŠå®ƒä»¬çš„é‡å¤ç‰ˆæœ¬ (å¦‚ -- *** ç­‰)ã€‚é™¤äº† bullet æˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨å¤§æ‹¬å·æ¥æ¡†å‡ºè¯æ˜çš„å±‚æ¬¡ï¼Œå¤§æ‹¬å·æ˜¯å¯ä»¥åµŒå¥—çš„ï¼Œä¾‹å¦‚\n{ destruct c eqn:Ec. { reflexivity. } { reflexivity. } } å¤§æ‹¬å·å’Œ bullet è¿˜å¯ä»¥æ··åˆä½¿ç”¨ï¼š\n{ destruct c eqn:Ec. - reflexivity. - reflexivity. } å¾ˆå¤šæ—¶å€™æˆ‘ä»¬ä½¿ç”¨å®Œ intros åç«‹åˆ»å°±è¦å¼€å§‹åˆ†æƒ…å†µè®¨è®ºï¼ŒCoq ä¸ºæˆ‘ä»¬å‡†å¤‡äº†æ›´åŠ ç´§å‡‘æ–¹ä¾¿çš„è¯­æ³•ã€‚ä¸‹é¢æ˜¯ä¸¤ä¸ªä¾‹å­ï¼š\nTheorem plus_1_neq_0' : forall n : nat, (n + 1) =? 0 = false. Proof. intros [|n]. - reflexivity. - refiexivity. Qed. Theorem andb_commutative'': forall b c : nat, andb b c = andb c b. Proof. intros [] []. - reflexivity. - reflexivity. - reflexivity. - reflexivity. Qed. è¿™ç§ç®€æ´è¯­æ³•çš„ç¼ºç‚¹åœ¨äºæˆ‘ä»¬æ— æ³•ç»™åˆ†æƒ…å†µè®¨è®ºæ—¶åšå‡ºçš„å‡è®¾ç­‰å¼å‘½å (å³ eqn:E çš„éƒ¨åˆ†)ã€‚\nFixpoints and Structural Recursion (Optional) å›æƒ³åŠ æ³•çš„å®šä¹‰ï¼Œæˆ‘ä»¬å¯¹ç¬¬ä¸€ä¸ªåŠ æ•°ä¸æ–­ -1 é€’å½’ã€‚è¿™æ ·çš„ç»“æ„é€’å½’ä¿è¯äº†æˆ‘ä»¬çš„å‚æ•°ä¼šè¶Šæ¥è¶Šå°ï¼Œå› æ­¤ä¸è®ºè¾“å…¥ä»€ä¹ˆå‚æ•°è®¡ç®—éƒ½ä¸€å®šå¯ä»¥ç»ˆæ­¢ã€‚\nCoq è¦æ±‚æ‰€æœ‰ Fixpoint ç±»å‹çš„å‡½æ•°çš„å‚æ•°éƒ½è¦ä¸æ–­å˜å°ï¼Œä»è€Œä¿è¯å‡½æ•°ä¸€å®šå¯ä»¥ç»ˆæ­¢ã€‚äº‹å®ä¸Šï¼Œæœ‰çš„æ—¶å€™å­˜åœ¨ä¸€äº›å¯ä»¥ç»ˆæ­¢çš„åˆæ³•å‡½æ•°ä¸æ»¡è¶³è¿™ä¸ªæ€§è´¨ (æ¯”å¦‚å¦‚æœæˆ‘ä»¬ä»¥ 5 å’Œ 6 ä¸ºåŸºå‡†å®šä¹‰å¶æ•°ï¼Œé‚£ä¹ˆ 0, 1, 2, 3, 4 å°±å¾—å¾€ä¸ŠåŠ ï¼Œä»è€Œ Coq æŠ¥é”™)ã€‚\nExercises Exercise: 1 star, standard (nandb) Definition nandb (b1:bool) (b2:bool) : bool := match b1, b2 with | true, true =\u0026gt; false | true, false =\u0026gt; true | false, true =\u0026gt; true | false, false =\u0026gt; true end. Example test_nandb1: (nandb true false) = true. Proof. simpl. reflexivity. Qed. Example test_nandb2: (nandb false false) = true. Proof. simpl. reflexivity. Qed. Example test_nandb3: (nandb false true) = true. Proof. simpl. reflexivity. Qed. Example test_nandb4: (nandb true true) = false. Proof. simpl. reflexivity. Qed. Exercise: 1 star, standard (andb3) Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool := (b1 \u0026amp;\u0026amp; b2) \u0026amp;\u0026amp; b3. Example test_andb31: (andb3 true true true) = true. Proof. reflexivity. Qed. Example test_andb32: (andb3 false true true) = false. Proof. reflexivity. Qed. Example test_andb33: (andb3 true false true) = false. Proof. reflexivity. Qed. Example test_andb34: (andb3 true true false) = false. Proof. reflexivity. Qed. æ³¨ï¼šå¦‚æœ definition ä¸­æ²¡æœ‰ä½¿ç”¨ match è¯­æ³•ï¼Œåˆ™è¯æ˜è¿‡ç¨‹ä¸­ä½¿ç”¨ simpl. å¹¶ä¸èƒ½ç®€åŒ–è¯æ˜è¿‡ç¨‹ï¼Œè¿™æ—¶ç›´æ¥ä½¿ç”¨ reflexivity. å³å¯ã€‚\nExercise: 1 star, standard (factorial) Fixpoint factorial (n : nat) : nat := match n with | O =\u0026gt; S O | S n' =\u0026gt; mult n (factorial n') end. Example test_factorial1: (factorial 3) = 6. Proof. simpl. reflexivity. Qed. Example test_factorial2: (factorial 5) = (mult 10 12). Proof. simpl. reflexivity. Qed. Exercise: 1 star, standard (ltb) Definition ltb (n m : nat) : bool := negb (m \u0026lt;=? n). Notation \u0026quot;x \u0026lt;? y\u0026quot; := (ltb x y) (at level 70) : nat_scope. Example test_ltb1: (ltb 2 2) = false. Proof. reflexivity. Qed. Example test_ltb2: (ltb 2 4) = true. Proof. reflexivity. Qed. Example test_ltb3: (ltb 4 2) = false. Proof. reflexivity. Qed. Exercise: 1 star, standard (plus_id_exercise) Theorem plus_id_exercise : forall n m o : nat, n = m -\u0026gt; m = o -\u0026gt; n + m = m + o. Proof. intros n m o. intros H1. intros H2. rewrite -\u0026gt; H1. rewrite -\u0026gt; H2. reflexivity. Qed. è¿™é‡Œéœ€è¦æ³¨æ„ç¬¬ä¸€æ¡å‡è®¾ä½¿ç”¨æ—¶çš„æ›¿æ¢æ–¹å‘ï¼šå¦‚æœåè¿‡æ¥æŠŠç­‰å¼ä¸­çš„ m ç”¨ n ä»£æ›¿ï¼Œç”±äºæ²¡æœ‰ n å’Œ o çš„ç›´æ¥å…³ç³»ï¼Œè¯æ˜å°±è¢«å¡ä½äº†ã€‚\nExercise: 1 star, standard (mult_n_1) Theorem mult_n_1 : forall p : nat, p * 1 = p. Proof. intros p. rewrite \u0026lt;- mult_n_Sm. rewrite \u0026lt;- mult_n_O. reflexivity. Qed. Exercise: 2 stars, standard (andb_true_elim2) Theorem andb_true_elim2 : forall b c : bool, andb b c = true -\u0026gt; c = true. Proof. intros b c. destruct c eqn:Ec. - reflexivity. - destruct b eqn:Eb. + intros H. rewrite \u0026lt;- H. reflexivity. + intros H. rewrite \u0026lt;- H. reflexivity. Qed. æœ¬é¢˜çš„ä¸€ä¸ªæœ‰æ„æ€çš„ç‚¹åœ¨äºå¦‚ä½•å¤„ç† contradictionï¼šæˆ‘ä»¬å¯¹ c åˆ†æƒ…å†µè®¨è®ºçš„æ—¶å€™ä¼šå‘ç°å¦‚æœ c = false é‚£ä¹ˆå‡è®¾æ¡ä»¶ä¸å¯èƒ½æˆç«‹ï¼Œä¼šå¯¼å‡º false = trueã€‚å¯¹äºäººç±»æ¥è¯´è¿™å°±å·²ç»ç»“æŸäº†ï¼Œä½†åœ¨ Coq ä¸­æˆ‘ä»¬éœ€è¦åˆ©ç”¨è¿™æ¡è§„åˆ™ç»§ç»­åš rewrite (false = true çš„æƒ…å†µä¸‹å¤©åœ°å¤§åŒäº†)ï¼Œç›´åˆ°å¯¼å‡ºç­‰å¼ä¸¤è¾¹ç›¸ç­‰ã€‚\nExercise: 1 star, standard (zero_nbeq_plus_1) Theorem zero_nbeq_plus_1 : forall n : nat, 0 =? (n + 1) = false. Proof. intros [|n']. - reflexivity. - reflexivity. Qed. è¿™é‡Œå€¼å¾—ä¸€æçš„æ˜¯ä¸ºä½•åœ¨ n = S n' æ—¶ reflexivity å¯ä»¥ç›´æ¥ç®—å‡ºç»“æœã€‚æ­¤æ—¶æˆ‘ä»¬çš„ subgoal æ˜¯è¯æ˜ 0 =? (S n' + 1) = falseã€‚æ ¹æ®åŠ æ³•çš„ç¬¬äºŒæ¡è§„åˆ™ï¼Œæˆ‘ä»¬æœ‰ S n' + 1 = S (n' + 1)ã€‚æ ¹æ® =? çš„è§„åˆ™åˆæœ‰ç¬¬ä¸€ä¸ªå‚æ•°ä¸º 0 ç¬¬äºŒä¸ªå‚æ•°æ»¡è¶³ S n å½¢å¼æ—¶å¯ä»¥ç›´æ¥åˆ¤å®šä¸º falseã€‚å› æ­¤ false = false å°±è¯å‡ºæ¥äº†ã€‚\nExercise: 2 stars, standard, optional (decreasing) Fixpoint error_func (n : nat) : nat := match n with | O =\u0026gt; error_func (S n) | S O =\u0026gt; S O | S n' =\u0026gt; S (error_func n') end. Exercise: 1 star, standard (identity_fn_applied_twice) Theorem identity_fn_applied_twice : forall (f : bool -\u0026gt; bool), (forall (x : bool), f x = x) -\u0026gt; forall (b : bool), f (f b) = b. Proof. intros f. intros H. intros b. rewrite -\u0026gt; H. rewrite -\u0026gt; H. reflexivity. Qed. Exercise: 1 star, standard (negation_fn_applied_twice) Theorem negation_fn_applied_twice : forall (f : bool -\u0026gt; bool), (forall (x : bool), f x = negb x) -\u0026gt; forall (b : bool), f (f b) = b. Proof. intros f H b. rewrite -\u0026gt; H. rewrite -\u0026gt; H. destruct b eqn:E. - reflexivity. - reflexivity. Qed. Exercise: 3 stars, standard, optional (andb_eq_orb) Theorem andb_eq_orb : forall (b c : bool), (andb b c = orb b c) -\u0026gt; b = c. Proof. intros []. - simpl. intros c H. rewrite -\u0026gt; H. reflexivity. - simpl. intros c H. rewrite \u0026lt;- H. reflexivity. Qed. æœ¬é¢˜æœ€æš´åŠ›çš„åšæ³•å°±æ˜¯å¯¹ b, c çš„å››ç§æƒ…å†µåˆ†ç±»è®¨è®ºã€‚ä½†è¿™æ ·ä¸æ˜¯å¾ˆèªæ˜ï¼Œæ ¹æ® andb å’Œ orb çš„å®šä¹‰ï¼Œä¸€æ—¦ b çš„å€¼ç¡®å®šï¼Œè¡¨è¾¾å¼çš„ç»“æœæ˜¯å¯ä»¥ç”¨ true, false, c æ¥è¡¨ç¤ºçš„ï¼Œå› æ­¤æˆ‘ä»¬åªè¦å¯¹ b è®¨è®ºå°±å¯ä»¥ç›´æ¥å¾—å‡º c çš„å€¼ï¼Œè¿™æ ·åšç®€æ´å¾ˆå¤šã€‚\nExercise: 3 stars, standard (binary) Fixpoint incr (m:bin) : bin := match m with | Z =\u0026gt; B1 Z | B0 m' =\u0026gt; B1 m' | B1 m' =\u0026gt; B0 (incr m') end. Fixpoint bin_to_nat (m : bin) : nat := match m with | Z =\u0026gt; O | B0 m' =\u0026gt; (bin_to_nat m') * 2 | B1 m' =\u0026gt; (bin_to_nat m') * 2 + 1 end. Example test_bin_incr1 : (incr (B1 Z)) = B0 (B1 Z). Proof. reflexivity. Qed. Example test_bin_incr2 : (incr (B0 (B1 Z))) = B1 (B1 Z). Proof. reflexivity. Qed. Example test_bin_incr3 : (incr (B1 (B1 Z))) = B0 (B0 (B1 Z)). Proof. reflexivity. Qed. Example test_bin_incr4 : bin_to_nat (B0 (B1 Z)) = 2. Proof. reflexivity. Qed. Example test_bin_incr5 : bin_to_nat (incr (B1 Z)) = 1 + bin_to_nat (B1 Z). Proof. reflexivity. Qed. Example test_bin_incr6 : bin_to_nat (incr (incr (B1 Z))) = 2 + bin_to_nat (B1 Z). Proof. reflexivity. Qed. ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"7418dec0eee29c1e5eb111ee8f0bf168","permalink":"https://kristoff-starling.github.io/notes/booknotes/softwarefoundations/lf/basics/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/booknotes/softwarefoundations/lf/basics/","section":"notes","summary":"Introduction Data and Functions Enumerated Types Days of the Week Booleans Types New Types from Old Module Tuples Numbers Proof by Simplification Proof by Rewriting Proof by Case Analysis Fixpoints and Structural Recursion (Optional) Exercises Exercise: 1 star, standard (nandb) Exercise: 1 star, standard (andb3) Exercise: 1 star, standard (factorial) Exercise: 1 star, standard (ltb) Exercise: 1 star, standard (plus_id_exercise) Exercise: 1 star, standard (mult_n_1) Exercise: 2 stars, standard (andb_true_elim2) Exercise: 1 star, standard (zero_nbeq_plus_1) Exercise: 2 stars, standard, optional (decreasing) Exercise: 1 star, standard (identity_fn_applied_twice) Exercise: 1 star, standard (negation_fn_applied_twice) Exercise: 3 stars, standard, optional (andb_eq_orb) Exercise: 3 stars, standard (binary) Introduction å‡½æ•°å¼ç¼–ç¨‹ (functional programming) çš„æ€æƒ³æ¥è‡ªäºï¼šå¦‚æœä¸€ä¸ªè¿‡ç¨‹æˆ–æ–¹æ³•æ²¡æœ‰å‰¯ä½œç”¨ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªå…³å¿ƒå®ƒå¦‚ä½•å°†è¾“å…¥æ˜ å°„åˆ°è¾“å‡ºï¼Œå³è¿™ä¸ªè¿‡ç¨‹/æ–¹æ³•æ˜¯ä¸€ä¸ªæ•°å­¦å‡½æ•°çš„å…·ä½“å®ç°ã€‚å‡½æ•°å¼ç¼–ç¨‹çš„å¦ä¸€ä¸ªæƒ³æ³•æ˜¯ï¼šæ‰€æœ‰çš„å‡½æ•°éƒ½åº”å½“è¢«å½“ä½œ first-classs valueï¼šå‡½æ•°å¯ä»¥ä½œä¸ºå‚æ•°ï¼Œå¯ä»¥ä½œä¸ºè¿”å›å€¼ï¼Œå°±åƒæ™®é€šçš„æ•°æ®ä¸€æ ·ã€‚","tags":null,"title":"Functional Programming in Coq","type":"docs"},{"authors":null,"categories":null,"content":"å€¼å¾—ä¸€æçš„æ˜¯ä¸‹é¢ä¸¤é“é¢˜\nQ5: If Function Refactor å‡½æ•°è°ƒç”¨ä¼šå…ˆå°†æ‰€æœ‰çš„å‚æ•°çš„å€¼ç®—å‡ºæ¥å†è°ƒç”¨ï¼Œå› æ­¤ä¼šå‘ç”Ÿ ZeroDivisionErrorã€‚\né¢˜ç›®è¦æ±‚ invert_short() å’Œ change_short() ä½¿ç”¨åŒä¸€å¥— limited() çš„æ¥å£ï¼Œä¸”ä¸èƒ½æ·»åŠ é¢å¤–çš„åˆ¤æ–­è¯­å¥ã€‚å› æ­¤æœ€å¥½çš„å®ç°æ–¹æ³•å°±æ˜¯ä¿®æ”¹ limited() çš„è¯­ä¹‰ï¼Œå‚æ•° z ä¸å†æ˜¯é™¤æ³•çš„ç»“æœè€Œæ˜¯åˆ†å­ï¼Œé™¤ 0 çš„åˆ¤æ–­æ”¾åˆ° limited() é‡Œé¢åšã€‚\nQ7: Quine ä¸‹é¢æä¾›ä¸€ç§ Python çš„ Quine ä»£ç ï¼š\n_='_=%r;print (_%%_)';print (_%_) å†™å…¥åˆ° hw01.py ä¸­è¦æ³¨æ„å¯¹ ' è¿›è¡Œè½¬ä¹‰ï¼Œä»¥åŠæœ€åéœ€è¦é¢å¤–æ·»åŠ ä¸€ä¸ªæ¢è¡Œç¬¦ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"a88e09f3be2b0a5ecaf9fd6c11b59cb6","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/homework/hw01/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/homework/hw01/","section":"notes","summary":"å€¼å¾—ä¸€æçš„æ˜¯ä¸‹é¢ä¸¤é“é¢˜\nQ5: If Function Refactor å‡½æ•°è°ƒç”¨ä¼šå…ˆå°†æ‰€æœ‰çš„å‚æ•°çš„å€¼ç®—å‡ºæ¥å†è°ƒç”¨ï¼Œå› æ­¤ä¼šå‘ç”Ÿ ZeroDivisionErrorã€‚\né¢˜ç›®è¦æ±‚ invert_short() å’Œ change_short() ä½¿ç”¨åŒä¸€å¥— limited() çš„æ¥å£ï¼Œä¸”ä¸èƒ½æ·»åŠ é¢å¤–çš„åˆ¤æ–­è¯­å¥ã€‚å› æ­¤æœ€å¥½çš„å®ç°æ–¹æ³•å°±æ˜¯ä¿®æ”¹ limited() çš„è¯­ä¹‰ï¼Œå‚æ•° z ä¸å†æ˜¯é™¤æ³•çš„ç»“æœè€Œæ˜¯åˆ†å­ï¼Œé™¤ 0 çš„åˆ¤æ–­æ”¾åˆ° limited() é‡Œé¢åšã€‚\nQ7: Quine ä¸‹é¢æä¾›ä¸€ç§ Python çš„ Quine ä»£ç ï¼š\n_='_=%r;print (_%%_)';print (_%_) å†™å…¥åˆ° hw01.","tags":null,"title":"UCB-CS61A Homework 01: Control","type":"docs"},{"authors":null,"categories":null,"content":"Phase 1: Simulator Problem 1 æ¨¡æ‹Ÿæ‰”éª°å­è®¡ç®—å¾—åˆ†ã€‚å”¯ä¸€éœ€è¦æ³¨æ„çš„æ˜¯å³ä½¿ä¸­é—´æ‘‡å‡ºäº† 1 ä¹Ÿè¦å°†ä¼ å…¥çš„æ‘‡éª°å­æ¬¡æ•°åšå®Œã€‚å› ä¸ºæ‘‡éª°å­çš„ index æ˜¯ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œè¿™æ¬¡çš„ä¸æ‘‡å®Œä¼šå½±å“ä¸‹ä¸€æ¬¡çš„ç»“æœã€‚\nProblem 2 æ¨¡æ‹Ÿ picky_piggyï¼Œæœ¬é¢˜ä»£ç ä¸­ä¸å…è®¸ä½¿ç”¨ string å’Œ listï¼Œå› æ­¤è¦ä½¿ç”¨åˆ†ç¦»æ•°ä½çš„æ–¹æ³•è·å¾—ç»“æœ (æˆ–è€…ç”¨å¤§ if)ã€‚\nProblem 3 å®Œæˆ take_turn()ï¼Œè°ƒç”¨ problem 1, 2 ä¸­å†™çš„ä¸¤ä¸ªå‡½æ•°å³å¯ã€‚\nProblem 4 æ¨¡æ‹Ÿ hog_pileï¼Œåˆ¤æ–­ä¸¤äººå¾—åˆ†æ˜¯å¦ç›¸åŒå³å¯ã€‚\nProblem 5 æ¨¡æ‹Ÿä¸¤ä¸ªäººå®Œæ•´çš„æ¸¸æˆæµç¨‹ã€‚æ¯è½®å…ˆè°ƒç”¨å¯¹åº”çš„ strategy è·å¾—æ‘‡éª°å­çš„æ¬¡æ•°ï¼Œç„¶åè°ƒç”¨ take_turn() è·å¾—åˆ†æ•°ï¼Œå†è°ƒç”¨ hog_pile() è·å¾—é™„åŠ å¾—åˆ†ï¼Œæœ€ååˆ‡æ¢ç©å®¶ã€‚\nPhase 2: Commentary Commentary Examples say å‡½æ•°æ˜¯ä¸€ç±»è¿”å›å€¼ä¸ºå‡½æ•°çš„é«˜é˜¶å‡½æ•°ã€‚è°ƒç”¨ say å‡½æ•°ä¼šæ‰“å°å‡ºä¸€äº›ä¿¡æ¯ï¼Œå¹¶è¿”å›ä¸€ä¸ª say å‡½æ•°ç”¨äºä¸‹ä¸€æ¬¡è°ƒç”¨ã€‚æœ€ç®€å•çš„ say å‡½æ•°æ˜¯æ¯æ¬¡é€»è¾‘ä¸å˜çš„å‡½æ•°ï¼š\ndef say(score0, score1): print(score0, score1) return say ç¨å¤æ‚ä¸€äº›çš„ say å‡½æ•°æ¯æ¬¡è¿”å›çš„å‡½æ•°è¡Œä¸ºå¯ä»¥ä¸åŒï¼Œæ¯”å¦‚ä¸‹é¢çš„ä¾‹å­åœ¨ä¸¤äººåˆ†æ•°é¢†å…ˆæƒ…å†µå‘ç”Ÿå˜åŒ–æ—¶ä¼šæ‰“å°ä¿¡æ¯ï¼š\ndef annouce_leader_change(last_leader=None): def say(score0, score1): if score0 \u0026gt; score1: leader = 0 elif: score1 \u0026gt; score0: leader = 1 else: leader = None if leader != None and leader != last_leader: print('Player', leader, 'take the lead by', abs(score0 - score1)) return annouce_leader_change(leader) return say announce_leader_change() è¿”å›çš„ say() å‡½æ•°è¢«å®šä¹‰åœ¨ announce_leader_change()å‡½æ•°ä½“å†…ï¼Œå˜é‡ last_leader ä¼šå½±å“ say() çš„é€»è¾‘ã€‚\nä¸‹é¢å±•ç¤ºæ¯”è¾ƒæœ‰æ„æ€çš„ both() å‡½æ•°ï¼Œå®ƒä¼šä¾æ¬¡æ‰§è¡Œä¸¤ä¸ª say å‡½æ•°ï¼š\ndef both(f, g): def say(score0, score1): return both(f(score0, score1), g(score0, score1)) return say Problem 6 åœ¨ play() çš„æœ€åæ¯æ¬¡è°ƒç”¨ say å‡½æ•°ï¼Œå¹¶ä»¤ say ç­‰äºæ–°çš„ say å‡½æ•°å³å¯ã€‚\nProblem 7 è‡ªå·±ä¹¦å†™ä¸€ä¸ªç¨å¤æ‚çš„ say å‡½æ•° announce_highest()ã€‚è¯¥é—®é¢˜ä¸­éœ€è¦æ³¨æ„çš„æ˜¯ï¼šå¦‚æœæ²¡æœ‰å£°æ˜ non localï¼Œæˆ‘ä»¬ä¸èƒ½åœ¨å­å‡½æ•°ä¸­ç›´æ¥ä¿®æ”¹çˆ¶å‡½æ•°ä¸­çš„å˜é‡ï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹©é€šè¿‡å‚æ•°ä¼ é€’çš„æ–¹å¼æŠŠæ–°çš„ last_score å’Œ running_high ä¼ ç»™çˆ¶å‡½æ•°ã€‚\nPhase 3: Strategy Problem 8 è®¡ç®—è‹¥å¹²æ¬¡è¿è¡Œæ‘‡éª°å­å‡½æ•°çš„ç»“æœçš„å¹³å‡å€¼ã€‚é™¤äº†ç¼–å†™é«˜é˜¶å‡½æ•°å¤–ï¼Œè¯¥ problem çš„ä¸€ä¸ªçŸ¥è¯†ç‚¹åœ¨äºï¼šæˆ‘ä»¬å¯ä»¥ç”¨ *arg æ¥å°†æŸä¸ªå‡½æ•°æ¥æ”¶çš„æ‰€æœ‰å‚æ•°çŒç»™å¦ä¸€ä¸ªè¦æ‰§è¡Œçš„å‡½æ•°ã€‚ä¾‹å¦‚ï¼š\ndef printed(f): def print_and_return(*args): result = f(*args) print('Result:', result) return result return print_and_return éšç€è°ƒç”¨ printed() æ—¶çš„å‡½æ•° f çš„ä¸åŒï¼Œæˆ‘ä»¬åç»­æ‰§è¡Œ print_and_return() æ—¶å¯ä»¥ä½¿ç”¨å„ç§æ•°é‡çš„å‚æ•°ã€‚\nProblem 9 é€šè¿‡å¹³å‡å€¼é€‰å–å½“å‰æœ€ä¼˜çš„æ‘‡éª°å­æ¬¡æ•°ã€‚å°†æ‘‡éª°å­çš„å‡½æ•° roll_dice() å–‚ç»™ä¹‹å‰ç¼–å†™çš„ make_averaged() å³å¯ã€‚æ­¤å¤–ï¼Œä¸ºäº†é€šè¿‡ ok çš„æµ‹è¯•ï¼Œå¾ªç¯å¿…é¡»æŒ‰ç…§ä» 1 åˆ° 10 çš„é¡ºåºå†™ã€‚\nProblem 10 è°ƒç”¨ problem 2 ä¸­ç¼–å†™çš„ picky_piggy() è®¡ç®—æ‘‡ 0 çš„æ”¶ç›Šå¹¶å’Œ cutoff æ¯”è¾ƒå³å¯ã€‚\nProblem 11 å’Œ problem 10 å‡ ä¹æ²¡æœ‰å·®åˆ«ï¼Œé¢å¤–åˆ¤æ–­ä¸€ä¸‹ä¼šä¸ä¼šè§¦å‘ hog_pile è§„åˆ™å³å¯ã€‚\nProblem 12 å¯ä»¥å‚è€ƒçš„ä¸€äº›ç­–ç•¥æœ‰ï¼š\npicky_piggy_strategy() å’Œ hog_pile_strategy()ã€‚ å¦‚æœèƒ½å¤Ÿç¡®ä¿èƒœåˆ©ï¼Œåˆ™åº”è¯¥é€‰æ‹©å°çš„æ‘‡éª°å­æ¬¡æ•°è§„é¿é£é™©ã€‚ â€¦â€¦ ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"ab913ea1f4816291afa4d10836b4c106","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/projects/hog/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/projects/hog/","section":"notes","summary":"Phase 1: Simulator Problem 1 æ¨¡æ‹Ÿæ‰”éª°å­è®¡ç®—å¾—åˆ†ã€‚å”¯ä¸€éœ€è¦æ³¨æ„çš„æ˜¯å³ä½¿ä¸­é—´æ‘‡å‡ºäº† 1 ä¹Ÿè¦å°†ä¼ å…¥çš„æ‘‡éª°å­æ¬¡æ•°åšå®Œã€‚å› ä¸ºæ‘‡éª°å­çš„ index æ˜¯ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œè¿™æ¬¡çš„ä¸æ‘‡å®Œä¼šå½±å“ä¸‹ä¸€æ¬¡çš„ç»“æœã€‚\nProblem 2 æ¨¡æ‹Ÿ picky_piggyï¼Œæœ¬é¢˜ä»£ç ä¸­ä¸å…è®¸ä½¿ç”¨ string å’Œ listï¼Œå› æ­¤è¦ä½¿ç”¨åˆ†ç¦»æ•°ä½çš„æ–¹æ³•è·å¾—ç»“æœ (æˆ–è€…ç”¨å¤§ if)ã€‚\nProblem 3 å®Œæˆ take_turn()ï¼Œè°ƒç”¨ problem 1, 2 ä¸­å†™çš„ä¸¤ä¸ªå‡½æ•°å³å¯ã€‚\nProblem 4 æ¨¡æ‹Ÿ hog_pileï¼Œåˆ¤æ–­ä¸¤äººå¾—åˆ†æ˜¯å¦ç›¸åŒå³å¯ã€‚","tags":null,"title":"UCB-CS61A Project 01: Hog","type":"docs"},{"authors":null,"categories":null,"content":"Purposes of O/S Abstraction of hardware. Higher level interfaces and abstractions that applications can use can enhance convenience and portability (e.g. processes and file systems) Multiplexing. Different applications can execute at the same time. Isolation and sharing. Security. Restrictions on resources applications have access to. (Help applications to get) performance. Range of different uses. O/S Organization User: VIM, CC, SHELL etc. Kernel: File system etc.\nProcesses, Memory allocations, Access control \u0026hellip; Hardware: CPU, RAM, DISK, NET etc. API-Kernel Applications use API-kernel provided by Kernel to jump into Kernel. For example:\nfd = open(\u0026quot;out\u0026quot;, 1);\t// fd is the file descriptor write(fd, \u0026quot;hello\\n\u0026quot;, 6); pid = fork();\t// fork() API returns the descriptor of the newly created process Do high-level programming language like Python directly use system calls?\nSome high-level programming languages focus on portability - its code should be executable on different operating systems so usually they call library functions instead of directly using system calls to ensure its portability. Of course, theses languages provide methods for programmers to directly use system calls.\nHow is jumping to kernel different from ordinary function calls?\nKernel codes have direct access to sensitive information such as disks, so the privilege level should be carefully maintained during kernel jumping to ensure the safety of data.\nWhy hard/interesting? unforgiving environment: different from applications whose environment is provided by O/S, O/S is built directly on the hardware, which is harder.\n(In this course, QEMU is used to simulate CPU and corresponding hardwares.)\nTensions: there are some trade-offs. For example\nwe want high efficiency so O/S should be close to the H/W, but to support applications we need a correct high-level abstraction. We want powerful O/S services, but applications want simple interfaces. We want flexible API, but for security reasons we need to have restraints. Interactions. For example,\nfd = open(); pid = fork(); The semantic of fork() is to create a copy of the current process. The file descriptor fd we acquire at the first line should be accessible by the child process, so interactions between processes are needed.\nApplications using system calls: Examples read() write() This is copy.c, we execute it on xv6:\n// copy.c: copy input to output. #include \u0026quot;kernel/types.h\u0026quot; #include \u0026quot;user/user.h\u0026quot; int main () { char buf[64]; while (1) { int n = read(0, buf, sizeof(buf)); if (n \u0026lt;= 0) break; write(1, buf, n); } exit(0); } copy.c \u0026rsquo;s function is that it prints on the screen whatever you input on the screen. Here 0/1 are the file descriptors of stdin/stdout (pervasive UNIX convention), which, in default, connect to the console input/output. Shell ensures that stdin/stdout have been opened when copy.c is being executed.\nHere copy.c doesn\u0026rsquo;t check the return values of system calls for error (e.g. line 16). We should be more careful when coding.\nWhat if we replace sizeof(buf) by 65?\nO/S will happily read at most 65 bytes from console input, but it may cause unexpected memory error. It\u0026rsquo;s a bug.\nopen() stdin and stdout are automatically opened, but we need a method to open files by ourselves, here\u0026rsquo;s another example program open.c:\n// open.c: create a file, write to it. #include \u0026quot;kernel/types.h\u0026quot; #include \u0026quot;user/user.h\u0026quot; #include \u0026quot;kernel/fcntl.h\u0026quot; int main () { int fd = open(\u0026quot;output.txt\u0026quot;, O_WRONLY | O_CREATE); write(fd, \u0026quot;ooo\\n\u0026quot;, 4); exit(0); } After running open, we use cat output.txt to see the contents and we\u0026rsquo;ll get ooo\\n. Here fd is the file descriptor indexing into a table inside the kernel. The kernel maintains a table for every running process and the table tells the kernel which file each file descriptor refers to. (NOTE: same file descriptor may refer to different files in different processes because the \u0026ldquo;table\u0026rdquo; is different.)\nfork() This is fork.c:\n// fork.c: create a new process #include \u0026quot;kernel/types.h\u0026quot; #include \u0026quot;user/user.h\u0026quot; int main () { int pid; pid = fork(); printf(\u0026quot;fork() returned %d\\n\u0026quot;, pid); if (pid == 0) printf(\u0026quot;child\\n\u0026quot;); else printf(\u0026quot;parent\\n\u0026quot;); exit(0); } fork() returns in both processes. In the original process, fork() returns a value greater than zero representing the pid of the child process. In the new process, fork() returns zero. Even if the two processes have the same memory, we can discriminate the parent from the child according to the return value of fork().\nThe printed message is\nffoorrkk(()) rreettuurrnende d 0 1c9h ilpda rent It seems like messy code, but actually the two processes run at the same time and QEMU simulates a multi-core processor for us, so the two processes alternatively print information on the console.\nexec() When a command is typed into the shell, the shell forks a child process and use exec() system call to run the application in the child process. exec() loads the instructions in the file you specify over the current process, discards its current memory and starts executing those instructions.\nfork() and exec() are always used together to run an application, here is forkexec.c:\n// forkexec.c: fork then exec int main () { int pid, status; pid = fork(); if (pid == 0) { char *argv[] = { \u0026quot;echo\u0026quot;, \u0026quot;THIS\u0026quot;, \u0026quot;IS\u0026quot;, \u0026quot;ECHO\u0026quot;, 0 }; // Note: there should be a null pointer NULL/0 at the end of the array exec(\u0026quot;echo\u0026quot;, argv); printf(\u0026quot;exec failed!\\n\u0026quot;); exit(1); } else { printf(\u0026quot;parent waiting\\n\u0026quot;); wait(\u0026amp;status); // the exit status of the child process will be recorded in variable status printf(\u0026quot;the child exited with status %d\\n\u0026quot;, status); } exit(0); } If echo is executed successfully, it will print the arguments and use exit(0) to exit. If echo returns, which means something goes wrong, the child process will exit by exit(1) to tell the parent process about the error.\nIn lots of cases, fork() and exec() are used together. It seems that a lot of memory space is wasted because after fork() copies the memory of the parent process, exec() immediately discards it. But with the aid of virtual memory, we can use the tricky \u0026ldquo;copy on write\u0026rdquo; technique to solve the issue.\nIs there any way for the child process to wait for the parent process?\nNo.\nWill \u0026ldquo;parent waiting\\n\u0026rdquo; always be printed first?\nNot necessary. The parent process and the child process execute concurrently so there outputs may interweave. However, because it takes a lot of machine instructions to discard the memory, load the memory and start echo, \u0026ldquo;parent waiting\\n\u0026rdquo;, in most cases, will be printed first.\nHow should we use wait() if there are more than one child processes?\nIf there are 2 child processes, the parent process should use 2 wait() to wait for both of them to exit.\nIO Redirection IO redirection can be achieved if we do something sophisticated between fork() and exec(). Here is redirect.c:\n// redirect.c: run a command with output redirected int main() { int pid; pid = fork(); if(pid == 0){ close(1); open(\u0026quot;output.txt\u0026quot;, O_WRONLY|O_CREATE); char *argv[] = { \u0026quot;echo\u0026quot;, \u0026quot;this\u0026quot;, \u0026quot;is\u0026quot;, \u0026quot;redirected\u0026quot;, \u0026quot;echo\u0026quot;, 0 }; exec(\u0026quot;echo\u0026quot;, argv); printf(\u0026quot;exec failed!\\n\u0026quot;); exit(1); } else { wait((int *) 0); } exit(0); } In the child process, we firstly close file descriptor 1 and then open \u0026ldquo;output.txt\u0026rdquo;, the semantic of open() is to allocate the least file descriptor that is not being used to the file. Since 0 is still allocated to the console input, file descriptor 1 is allocated to output.txt and echo will output things into file 1, i.e. output.txt. It should be noticed that only the child process\u0026rsquo;s IO is redirected, the parent process, i.e. the shell process, stays the same.\nThe magical thing is that the application echo doesn\u0026rsquo;t need to know about the redirection - the only thing it knows is that it should output to file descriptor 1. This is abstraction.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"8010e29128eaf6cd51e1db5db7fc8841","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-operating-system/lectures/lec01/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-operating-system/lectures/lec01/","section":"notes","summary":"Purposes of O/S Abstraction of hardware. Higher level interfaces and abstractions that applications can use can enhance convenience and portability (e.g. processes and file systems) Multiplexing. Different applications can execute at the same time.","tags":null,"title":"MIT-6.S081 Lecture 01: Introduction and Examples","type":"docs"},{"authors":null,"categories":null,"content":"Phase 1: Typing Problem 1 å¯»æ‰¾ç¬¬ k ä¸ªæ»¡è¶³æ¡ä»¶çš„å­—ç¬¦ä¸²ï¼Œæ³¨æ„è¿™é‡Œçš„ k æ˜¯ 0-base çš„ã€‚\nProblem 2 å……åˆ†åˆ©ç”¨ utils.py ä¸­æä¾›çš„ split() remove_punctuation() å’Œ lower() å‡½æ•°å¯ä»¥å¤§å¹…ç®€åŒ–ä»£ç çš„éš¾åº¦ã€‚\nProblem 3 æ³¨æ„å•ç‹¬å¤„ç†å‡ ç§åˆ—è¡¨é•¿åº¦ä¸º 0 çš„è¾¹ç•Œæƒ…å†µã€‚ è¿”å›å€¼ 0/100 ä¼šè¢«å½“ä½œä¸€ä¸ªæ•´æ•°ï¼Œæƒ³è¦è¿”å›ä¸€ä¸ªæµ®ç‚¹æ•°åº”å½“å†™ 0.0/100.0ã€‚ Problem 4 ç®€å•æ•°å­¦è®¡ç®—ã€‚\nPhase 2: Autocorrect Problem 5 æœ¬é¢˜æ¯”è¾ƒæ¼‚äº®çš„å†™æ³•æ˜¯å……åˆ†è¿ç”¨ min() å‡½æ•°çš„ keyï¼šç›´æ¥æŠŠ diff_function() çš„å†…å®¹ç”¨ lambda è¡¨è¾¾å¼å¥—èµ·æ¥å–‚ç»™ keyï¼Œå¯ä»¥çœå»ä¹¦å†™ for å¾ªç¯ã€‚\nProblem 6 æœ¬é¢˜çš„éš¾ç‚¹åœ¨äºä¸èƒ½ä½¿ç”¨å¾ªç¯åªèƒ½ç”¨é€’å½’ï¼Œæ­¤å¤–è¿˜è¦ä¿è¯ç­”æ¡ˆè¶…è¿‡ limit çš„æ—¶å€™è¿è¡Œæ•ˆç‡å°½å¯èƒ½ä¸é•¿åº¦æ— å…³ã€‚ç¬”è€…å®ç°çš„æ–¹æ³•æ˜¯å°†ç­”æ¡ˆä½œä¸ºå‚æ•°éšç€é€’å½’ä¼ ä¸‹å»ï¼Œè¿™æ ·ä¸€æ—¦ç­”æ¡ˆè¶…å‡º limit é€’å½’å°±æå‰è¿”å›ã€‚\nProblem 7 è¿™é¢˜é¢‡å…·éš¾åº¦ï¼Œå…¶æ€è·¯ç±»ä¼¼äºåŠ¨æ€è§„åˆ’ã€‚ä¸€ä¸ªæ¯”è¾ƒç®€å•çš„åšæ³•æ˜¯ï¼šæˆ‘ä»¬æ¯æ¬¡è€ƒè™‘å¦‚ä½•è®©ä¸¤ä¸ªå•è¯çš„ç¬¬ä¸€ä¸ªå­—æ¯åŒ¹é…ä¸Šã€‚å¦‚æœå·²ç»ä¸€æ ·å°±è·³è¿‡çœ‹ä¸‹ä¸€ä¸ªå­—æ¯ï¼Œå¦åˆ™å°±ä»åŠ å­—æ¯ (è‚¯å®šä¼šåŠ åŒ¹é…çš„å­—æ¯)ï¼Œåˆ å­—æ¯ (åˆ å­—æ¯åå¹¶ä¸ä¿è¯ç¬¬ä¸€ä¸ªå­—æ¯èƒ½åŒ¹é…ä¸Š)ï¼Œæ¢å­—æ¯ä¸­é€‰ä¸€ç§æ“ä½œã€‚\nPhase 3: Multiplayer Problem 8 æœ¬é¢˜å¯ä»¥å…³æ³¨å­—å…¸çš„åˆå§‹åŒ–æ–¹æ³•ï¼šåœ¨ {} ä¸­ç”¨ 'key': value çš„æ–¹å¼åŒ…æ‹¬è‹¥å¹² key-value pairsã€‚\nProblem 9 æœ¬é¢˜æ²¡æœ‰å¤ªå¤§çš„éš¾åº¦ï¼Œè¿ç”¨ list comprehension å¯ä»¥å°†ä»£ç å†™å¾—ç®€çŸ­æ¼‚äº®ã€‚\nProblem 10 è¯¥é¢˜æœ¬èº«æ²¡æœ‰å¤ªå¤§éš¾åº¦ï¼Œä½†åº”å½“æ³¨æ„å®ç°æ—¶æœ€å¥½ä½¿ç”¨æ¡†æ¶ä»£ç æä¾›çš„å‡ ä¸ªå’Œ match äº’åŠ¨çš„ APIï¼Œå°† match å½“ä½œä¸€ä¸ª abstract data structure è€Œä¸æ˜¯ç›´æ¥å»å®šä½åµŒå¥—åˆ—è¡¨ä¸­çš„å…ƒç´ ã€‚æ‰€è°“çš„ abstract data structure å°±æ˜¯åªå…³æ³¨ API æä¾›çš„æ•°æ®ç»“æ„å¯¹å¤–çš„äº¤äº’åŠŸèƒ½è€Œå¿½ç•¥æ•°æ®ç»“æ„å†…éƒ¨çš„å®ç°æ–¹æ³•ã€‚\nUtils utils.py æä¾›äº†ä¸€äº›è¾…åŠ©å‡½æ•°ã€‚å…¶ä¸­å€¼å¾—æ³¨æ„çš„ API ç”¨æ³•æœ‰ï¼š\ndef remove_punctuation(s): punctuation_remover = str.maketrans('', '', string.punctuation) return s.strip().translate(punctuation_remover) str.maketrans() ä¸º translate() æä¾›å­—ç¬¦è½¬æ¢çš„è§„åˆ™ï¼š\nå¦‚æœ maketrans() æ¥æ”¶ä¸€ä¸ªå‚æ•°ï¼Œé‚£ä¹ˆè¿™ä¸ªå‚æ•°å¿…é¡»æ˜¯ä¸€ä¸ªå­—å…¸ã€‚å­—å…¸çš„æ˜ å°„å°±æ˜¯è½¬æ¢çš„æºå’Œç›®æ ‡ã€‚ å¦‚æœ maketrans() æ¥æ”¶ä¸¤ä¸ªå‚æ•°ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªå‚æ•°å¿…é¡»æ˜¯é•¿åº¦ç›¸åŒçš„å­—ç¬¦ä¸²ï¼Œå¯¹åº”çš„å­—ç¬¦æ„æˆè½¬æ¢è§„åˆ™ã€‚ å¦‚æœ maketrans() æ¥æ”¶ä¸‰ä¸ªå‚æ•°ï¼Œé‚£ä¹ˆç¬¬ä¸‰ä¸ªå‚æ•°çš„å­—ç¬¦ä¸²çš„å†…å®¹ä¼šè¢«æ˜ å°„åˆ° Noneï¼Œå‰ä¸¤ä¸ªåŒ (2)ã€‚ è¿™é‡Œä¸»è¦åˆ©ç”¨äº†ä¸‰ä¸ªå‚æ•°çš„è§„åˆ™å°†æ‰€æœ‰çš„æ ‡ç‚¹ç¬¦å·æ˜ å°„åˆ°äº† Noneã€‚\nstrip(c=' ') æ–¹æ³•ç”¨äºå»é™¤å­—ç¬¦ä¸²é¦–å°¾çš„å­—ç¬¦ cï¼Œå¦‚æœæ²¡æœ‰ä¼ å…¥å‚æ•°åˆ™é»˜è®¤å»é™¤ç©ºæ ¼ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"1ed1ac1846441940df154aa68c4143df","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/projects/cat/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/projects/cat/","section":"notes","summary":"Phase 1: Typing Problem 1 å¯»æ‰¾ç¬¬ k ä¸ªæ»¡è¶³æ¡ä»¶çš„å­—ç¬¦ä¸²ï¼Œæ³¨æ„è¿™é‡Œçš„ k æ˜¯ 0-base çš„ã€‚\nProblem 2 å……åˆ†åˆ©ç”¨ utils.py ä¸­æä¾›çš„ split() remove_punctuation() å’Œ lower() å‡½æ•°å¯ä»¥å¤§å¹…ç®€åŒ–ä»£ç çš„éš¾åº¦ã€‚\nProblem 3 æ³¨æ„å•ç‹¬å¤„ç†å‡ ç§åˆ—è¡¨é•¿åº¦ä¸º 0 çš„è¾¹ç•Œæƒ…å†µã€‚ è¿”å›å€¼ 0/100 ä¼šè¢«å½“ä½œä¸€ä¸ªæ•´æ•°ï¼Œæƒ³è¦è¿”å›ä¸€ä¸ªæµ®ç‚¹æ•°åº”å½“å†™ 0.","tags":null,"title":"UCB-CS61A Project 02: Cat","type":"docs"},{"authors":null,"categories":null,"content":" Separate Compilation Proof by Induction Proofs Within Proofs Formal vs. Informal Proof Exercises Exercise: 2 stars, standard, especially useful (basic_induction) Exercise: 2 stars, standard (double_plus) Exercise: 2 stars, standard (eqb_refl) Exercise: 2 stars, standard, optional (even_S) Exercise: 3 stars, standard, especially useful (mul_comm) Exercise: 2 stars, standard, optional (plus_leb_compat_l) Exercise: 3 stars, standard, optional (more_exercises) Exercise: 2 stars, standard, optional (add_shuffle3\u0026rsquo;) Exercise: 3 stars, standard, especially useful (binary_commute) Exercise: 3 stars, standard (nat_bin_nat) Exercise: 2 stars, advanced (double_bin) Exercise: 4 stars, advanced (bin_nat_bin) Separate Compilation å¦‚æœæƒ³åœ¨æ–°çš„ .v æ–‡ä»¶ä¸­ä½¿ç”¨åˆ«çš„æ–‡ä»¶ä¸­çš„æ‰€æœ‰å®šä¹‰å’Œå®šç† (æ¯”å¦‚ Basics.v)ï¼Œå¯ä»¥ä½¿ç”¨å¦‚ä¸‹è¯­å¥ï¼š\nFrom LF Require Export Basics. ä½¿ç”¨è¿™æ¡è¯­å¥çš„å‰ç½®æ¡ä»¶æ˜¯ Coq å¯ä»¥åœ¨æœ‰ \u0026ldquo;LF\u0026rdquo; å‰ç¼€çš„ç›®å½•ä¸‹æ‰¾åˆ°ç¼–è¯‘è¿‡çš„ Basics.voã€‚.vo æ–‡ä»¶ä¹‹äº .v æ–‡ä»¶å°±å¥½æ¯” .o æ–‡ä»¶ä¹‹äº .c æ–‡ä»¶ã€‚æˆ‘ä»¬åº”å½“åœ¨å½“å‰çš„å·¥ä½œç›®å½•ä¸‹å»ºç«‹ _CoqProject æ–‡ä»¶ï¼Œåœ¨å…¶ä¸­å†™ä¸Š\n-Q . LF è¿™ä¼šå°†å½“å‰ç›®å½•ç»‘å®šåˆ° \u0026ldquo;LF\u0026rdquo; å‰ç¼€ä¸Šã€‚ä¹‹åæˆ‘ä»¬å¯ä»¥ç”¨\ncoq_makefile -f _CoqProject *.v -o Makefile æ¥è‡ªåŠ¨ç”Ÿæˆç”¨äºç¼–è¯‘å·¥ä½œç›®å½•ä¸‹æ‰€æœ‰æºæ–‡ä»¶çš„ Makefileï¼Œå¹¶é€šè¿‡\nmake Basics.vo æ¥ç¼–è¯‘ç”Ÿæˆ .vo æ–‡ä»¶ã€‚\nProof by Induction æˆ‘ä»¬ä¹‹å‰è¯æ˜äº† 0 æ˜¯ \u0026ldquo;+\u0026rdquo; çš„ neutral elementï¼Œä½†æˆ‘ä»¬åªè¯æ˜äº† 0 åœ¨å·¦ä¾§çš„æƒ…å†µï¼Œå³ forall n : nat, 0 + n = n.ã€‚å¦‚æœæˆ‘ä»¬è¦è¯æ˜ n + 0 = nï¼Œäº‹æƒ…ä¾¿å˜å¾—å¤æ‚èµ·æ¥ï¼šå› ä¸ºæˆ‘ä»¬çš„åŠ æ³•æ˜¯é€šè¿‡å¯¹ç¬¬ä¸€ä¸ªåŠ æ•°çš„é€’å½’å®šä¹‰çš„ï¼ŒæœªçŸ¥å¤§å°çš„æ•´æ•° n æ— æ³•é€’å½’ã€‚åœ¨è¿™é‡Œæˆ‘ä»¬å¿…é¡»ä½¿ç”¨å½’çº³æ³• (induction)ã€‚\næˆ‘ä»¬å…ˆç›´æ¥ç»™å‡ºå½’çº³æ³•è¯æ˜ n + 0 = n çš„æ­¥éª¤ï¼š\nTheorem add_0_r: forall n : nat, n + 0 = n. Proof. intros n. induction n as [| n' IHn']. - reflexivity. - simpl. rewrite -\u0026gt; IHn'. reflexivity. Qed. induction å’Œ destruct è¿™ä¸ª tactic ä¸€æ ·ï¼Œä¹Ÿå¯ä»¥åœ¨åé¢è·Ÿä¸€ä¸ª asã€‚ç¬¬ä¸€ç§æƒ…å†µæ˜¯ä»¤ n = 0ï¼Œè¿™ç§æƒ…å†µæ²¡æœ‰å‚æ•°ï¼Œæ‰€ä»¥ | å·¦ä¾§æ²¡æœ‰ä¸œè¥¿ï¼›ç¬¬äºŒç§æƒ…å†µæ˜¯ä»¤ n = S n'ï¼ŒåŸºäºçš„å‡è®¾æ˜¯ n' + 0 = n' ï¼Œæˆ‘ä»¬ç»™è¿™ä¸ªå‡è®¾å‘½åä¸º IHn'ã€‚\nProofs Within Proofs æˆ‘ä»¬è¿›è¡Œå¤§çš„è¯æ˜çš„è¿‡ç¨‹ä¸­æ—¶å¸¸éœ€è¦ä¸€äº›å°çš„ç»“è®ºã€‚æˆ‘ä»¬å¯ä»¥åœ¨è¯æ˜å¤§å®šç†ä¹‹å‰æŠŠå°ç»“è®ºå…ˆè¯æ˜å¥½ï¼Œç„¶ååœ¨å¤§å®šç†ä¸­ rewriteã€‚ä½†æœ‰æ—¶å€™æœ‰ä¸€äº›æ‚é¡¹çš„ã€trivial çš„ç»“è®ºå•ç‹¬æ‹å‡ºæ¥ç»™è¯æ˜ä¼šä½¿è¯æ˜è¿‡ç¨‹å˜å¾—å¾ˆç¹æ‚ï¼Œæ‰€ä»¥ Coq æä¾›äº†åœ¨è¯æ˜å†…éƒ¨è¯æ˜å¦ä¸€ä¸ªå‘½é¢˜çš„è¯­æ³•ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š\nTheorem mult_0_plus' forall n m : nat, (n + 0 + 0) * m = n * m. Proof. intros n m. assert (H: n + 0 + 0 = n). { rewrite add_comm. simpl. rewrite add_comm. reflexivity. } rewrite -\u0026gt; H. reflexivity. Qed. assert è¿™ä¸ª tactic ä¼šå¼•å…¥ä¸¤ä¸ª subgoalï¼š\nç¬¬ä¸€ä¸ª subgoal æ˜¯æ‹¬å·å†…å†™å‡ºçš„å‘½é¢˜ã€‚ä¸Šè¿°çš„å†™æ³•ç»™è¿™ä¸ªå‘½é¢˜å‘½åä¸º Hã€‚æˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨ assert (n + 0 + 0 = n) as H. çš„è¯­æ³•æ¥ä¹¦å†™è¿™ä¸€è¡Œã€‚è¿™ä¸ªå‘½é¢˜çš„è¯æ˜ç”¨ä¸€å¯¹ {} æ¡†èµ·æ¥ã€‚ ç¬¬äºŒä¸ª subgoal å’Œ assert ä¹‹å‰çš„ä¸€åˆ»çš„ goal ç›¸åŒï¼Œä½†å¤šäº† assert è¯æ˜çš„ç»“è®ºä½œä¸ºä¸€æ¡å‡è®¾ã€‚ ä¸‹é¢å±•ç¤ºå¦ä¸€ä¸ªéœ€è¦ä½¿ç”¨ assert çš„æœ‰è¶£çš„åœºæ™¯ï¼š\nTheorem plus_rearrange: forall n m p q : nat, (n + m) + (p + q) = (m + n) + (p + q). Proof. intros n m p q. assert (H: n + m = m + n) { rewrite add_comm. reflexivity. } rewrite H. reflexivity. Qed. å¯ä»¥çœ‹åˆ°è¦è¯æ˜çš„å‘½é¢˜ä¸­åªæœ‰ç¬¬ä¸€ä¸ªæ‹¬å·å†…ä¸¤ä¸ªåŠ æ•°çš„é¡ºåºä¸åŒã€‚ä½†å¯æƒœçš„æ˜¯æˆ‘ä»¬ä¸èƒ½ç›´æ¥åˆ©ç”¨åŠ æ³•çš„äº¤æ¢å¾‹æ¥ rewriteï¼Œå› ä¸º Coq æ ¹æ®åŠ æ³•äº¤æ¢å¾‹åœ¨ goal ä¸­å¯»æ‰¾å®ä¾‹æ—¶ä¼šä¼˜å…ˆæ‰¾åˆ°å¤–å±‚æ‹¬å·çš„å®ä¾‹ï¼Œå³ä¼šæŠŠä¸¤ä¸ªæ‹¬å·çš„å†…å®¹æ•´ä½“è°ƒæ¢ã€‚åœ¨è¿™é‡Œæˆ‘ä»¬ä¸åˆ©ç”¨åŠ æ³•äº¤æ¢å¾‹ rewriteï¼Œè€Œæ˜¯å…ˆè¯æ˜ n + m = m + n ç„¶åç›´æ¥ rewriteã€‚\nFormal vs. Informal Proof Formal proof æŒ‡çš„æ˜¯å†™ç»™ Coq ç­‰è¯æ˜å·¥å…·çœ‹çš„è¯æ˜è¿‡ç¨‹ï¼›Informal proof æŒ‡çš„æ˜¯ç”¨è‡ªç„¶è¯­è¨€å†™ç»™äººçœ‹çš„è¯æ˜è¿‡ç¨‹ã€‚ä¸€ä¸ªå¥½çš„ formal proof åº”å½“é€šè¿‡é€‚å½“çš„æ³¨é‡Šå’Œç¼©è¿›æ¥ä½¿å…¶å¯¹äººç±»ä¹Ÿæ¯”è¾ƒå‹å¥½ã€‚é€šå¸¸æ¥è¯´ï¼Œformal proof åœ¨ç»†èŠ‚å¤„ä¼šå†™å¾—æ¯” informal proof æ›´è¯¦ç»† (ä¾‹å¦‚ reflexivity)ï¼Œinformal proof ä¼šé€šè¿‡ä¸€äº›è¯­è¨€è®©è¯»è€…æ›´å¥½åœ°äº†è§£å½“å‰åœ°è¯æ˜çŠ¶æ€ (è¿™äº›ä¿¡æ¯åªæœ‰ä½¿ç”¨ Coq æ‰§è¡Œä»£ç æ—¶æ‰ä¼šæ˜¾ç¤ºå‡ºæ¥)ã€‚\nExercises Exercise: 2 stars, standard, especially useful (basic_induction) Theorem mul_0_r : forall n:nat, n * 0 = 0. Proof. intros n. induction n as [| n' IHn']. - reflexivity. - simpl. rewrite -\u0026gt; IHn'. reflexivity. Qed. Theorem plus_n_Sm : forall n m : nat, S (n + m) = n + (S m). Proof. intros n m. induction n as [| n' IHn']. - reflexivity. - simpl. rewrite -\u0026gt; IHn'. reflexivity. Qed. Theorem add_comm : forall n m : nat, n + m = m + n. Proof. intros n m. induction n as [| n' IHn']. - rewrite -\u0026gt; add_0_r. reflexivity. - rewrite \u0026lt;- plus_n_Sm. rewrite \u0026lt;- IHn'. reflexivity. Qed. è¿™ä¸ªè¯æ˜ç¨å¾®å¤æ‚ä¸€äº›ï¼Œå½’çº³åŸºç¡€å’Œå½’çº³æ­¥éª¤éƒ½éœ€è¦ä½¿ç”¨ä¹‹å‰è¯æ˜è¿‡çš„å®šç†ã€‚\nTheorem add_assoc : forall n m p : nat, n + (m + p) = (n + m) + p. Proof. intros n m p. induction n as [| n' IHn']. - reflexivity. - simpl. rewrite -\u0026gt; IHn'. reflexivity. Qed. Exercise: 2 stars, standard (double_plus) Lemma double_plus : forall n, double n = n + n . Proof. intros n. induction n as [| n' IHn']. - reflexivity. - simpl. rewrite -\u0026gt; IHn'. rewrite \u0026lt;- plus_n_Sm. reflexivity. Qed. Exercise: 2 stars, standard (eqb_refl) Theorem eqb_refl : forall n : nat, (n =? n) = true. Proof. intros n. induction n as [| n' IHn']. - reflexivity. - simpl. rewrite -\u0026gt; IHn'. reflexivity. Qed. Exercise: 2 stars, standard, optional (even_S) Theorem even_S : forall n : nat, even (S n) = negb (even n). Proof. intros n. induction n as [| n' IHn']. - reflexivity. - rewrite -\u0026gt; IHn'. simpl. rewrite -\u0026gt; negb_involutive. reflexivity. Qed. æœ¬é¢˜éœ€è¦æ³¨æ„çš„ç‚¹æ˜¯ï¼šå½’çº³æ­¥éª¤ä¸­å¦‚æœç›´æ¥ä¸Š simpl åŒ–ç®€ï¼Œä¼šå°†ç­‰å¼å³ä¾§çš„ even n' çš„å®šä¹‰å±•å¼€ï¼Œæ‰€ä»¥è¿™é‡Œç¬”è€…å…ˆ rewrite å† simplã€‚\nExercise: 3 stars, standard, especially useful (mul_comm) Theorem add_shuffle3 : forall n m p : nat, n + (m + p) = m + (n + p). Proof. intros n m p. rewrite add_assoc. rewrite add_assoc. assert (H: n + m = m + n). { rewrite add_comm. reflexivity. } rewrite H. reflexivity. Qed. Lemma mult_n_0: forall n : nat, n * 0 = 0. Proof. induction n as [| n' IHn']. - reflexivity. - simpl. rewrite IHn'. reflexivity. Qed. Lemma mult_n_Sm: forall n m : nat, n * (1 + m) = n + n * m. Proof. intros n m. induction n as [| n' IHn']. - reflexivity. - assert (H1: S n' * (1 + m) = S m + n' * (1 + m)). { reflexivity. } rewrite H1. rewrite IHn'. assert (H2: S n' * m = m + n' * m). { reflexivity. } rewrite H2. simpl. rewrite add_shuffle3. reflexivity. Qed. Theorem mul_comm : forall m n : nat, m * n = n * m. Proof. intros n m. induction n as [| n' IHn']. - rewrite mult_n_0. reflexivity. - simpl. rewrite mult_n_Sm. rewrite IHn'. reflexivity. Qed. è¿™é¢˜ç›¸å½“æœ‰éš¾åº¦ï¼Œéœ€è¦å…ˆè¯æ˜ n * S m = n + n * m è¿™ä¸ªå¼•ç†ï¼Œä¸­é—´åå¤çš„åœ¨å±€éƒ¨ä½¿ç”¨ä¹˜æ³•å®šä¹‰/åŠ æ³•äº¤æ¢å¾‹ç»“åˆå¾‹æ¯”è¾ƒæå¿ƒæ€ã€‚\nExercise: 2 stars, standard, optional (plus_leb_compat_l) Theorem plus_leb_compat_l : forall n m p : nat, n \u0026lt;=? m = true -\u0026gt; (p + n) \u0026lt;=? (p + m) = true. Proof. intros n m p H. induction p as [| p' IHp']. - simpl. rewrite H. reflexivity. - simpl. rewrite IHp'. reflexivity. Qed. Exercise: 3 stars, standard, optional (more_exercises) Theorem leb_refl : forall n:nat, (n \u0026lt;=? n) = true. Proof. intros n. induction n as [| n' IHn']. - reflexivity. - simpl. rewrite IHn'. reflexivity. Qed. Theorem zero_neqb_S : forall n:nat, 0 =? (S n) = false. Proof. intros n. reflexivity. Qed. Theorem andb_false_r : forall b : bool, andb b false = false. Proof. intros b. rewrite andb_commutative. reflexivity. Qed Theorem S_neqb_0 : forall n:nat, (S n) =? 0 = false. Proof. intros n. reflexivity. Qed. Theorem mult_1_l : forall n:nat, 1 * n = n. Proof. intros n. simpl. rewrite add_comm. reflexivity. Qed. Theorem all3_spec : forall b c : bool, orb (andb b c) (orb (negb b) (negb c)) = true. Proof. intros [] []. - reflexivity. - reflexivity. - reflexivity. - reflexivity. Qed. Theorem mult_plus_distr_r : forall n m p : nat, (n + m) * p = (n * p) + (m * p). Proof. intros. rewrite mul_comm. induction p as [| p' IHp']. - rewrite mult_n_0. rewrite mult_n_0. reflexivity. - simpl. rewrite mult_n_Sm. rewrite mult_n_Sm. rewrite IHp'. rewrite add_assoc. rewrite add_assoc. assert (H1: n + m + n * p' = n + (m + n * p')). { rewrite add_assoc. reflexivity. } rewrite H1. assert (H2: m + n * p' = n * p' + m). { rewrite add_comm. reflexivity. } rewrite H2. rewrite add_assoc. reflexivity. Qed. Theorem mult_assoc : forall n m p : nat, n * (m * p) = (n * m) * p. Proof. intros. induction n as [| n' IHn']. - reflexivity. - simpl. rewrite IHn'. rewrite mult_plus_distr_r. reflexivity. Qed. æ³¨ï¼šä¹˜æ³•åˆ†é…å¾‹çš„è¯æ˜ç”±äºæ¶‰åŠè¿‡å¤šç¹ççš„åŠ æ³•äº¤æ¢å¾‹/ç»“åˆå¾‹ï¼Œä¸èƒ½ä¿è¯è¿‡ç¨‹çš„ç®€æ´æ€§ã€‚\nExercise: 2 stars, standard, optional (add_shuffle3') Theorem add_shuffle3' : forall n m p : nat, n + (m + p) = m + (n + p). Proof. intros. rewrite add_assoc. rewrite add_assoc. replace (n + m) with (m + n). - reflexivity. - rewrite add_comm. reflexivity. Qed. ä½¿ç”¨ replace è¿™ä¸ª tactic å¯ä»¥é¿å…æ¯æ¬¡ assert ä¹‹åå† rewrite æ–°å‡è®¾çš„ç¹çè¿‡ç¨‹ã€‚\nExercise: 3 stars, standard, especially useful (binary_commute) Theorem bin_to_nat_pres_incr : forall b : bin, bin_to_nat (incr b) = 1 + bin_to_nat b. Proof. intros b. induction b as [| b' | b' IHb']. - reflexivity. - simpl. rewrite add_comm. reflexivity. - simpl. rewrite IHb'. simpl. rewrite add_comm. reflexivity. Qed. è¿™é‡Œå€¼å¾—ä¸€æçš„æ˜¯ï¼šCoq ä¸­åªæœ‰åŸºäºç»“æ„çš„å½’çº³æ³•ï¼Œåªè¦å˜é‡ç±»å‹æ˜¯ä»¥ inductive çš„å½¢å¼å®šä¹‰çš„ï¼Œæˆ‘ä»¬éƒ½å¯ä»¥ä½¿ç”¨å½’çº³æ³•è¿›è¡Œè¯æ˜ã€‚ä¹‹å‰çš„å½’çº³æ³•éƒ½é’ˆå¯¹è‡ªç„¶æ•°ï¼Œè¿™æ˜¯å› ä¸ºè‡ªç„¶æ•°ä¹Ÿæ˜¯å½’çº³å®šä¹‰çš„ã€‚è¿™é‡Œçš„ bin æœ‰ä¸‰ä¸ªå½’çº³åˆ†æ”¯ï¼Œå†™èµ·æ¥å’Œè‡ªç„¶æ•°å¤§åŒå°å¼‚ã€‚\nExercise: 3 stars, standard (nat_bin_nat) Fixpoint nat_to_bin (n:nat) : bin := match n with | O =\u0026gt; Z | S n' =\u0026gt; incr(nat_to_bin(n')) end. Theorem nat_bin_nat : forall n, bin_to_nat (nat_to_bin n) = n. Proof. intros. induction n as [| n' IHn']. - reflexivity. - simpl. rewrite bin_to_nat_pres_incr. rewrite IHn'. reflexivity. Qed. Exercise: 2 stars, advanced (double_bin) Lemma double_incr : forall n : nat, double (S n) = S (S (double n)). Proof. reflexivity. Qed. Definition double_bin (b:bin) : bin := match b with | Z =\u0026gt; Z | _ =\u0026gt; B0 b end. Example double_bin_zero : double_bin Z = Z. Proof. reflexivity. Qed. Lemma double_incr_bin : forall b, double_bin (incr b) = incr (incr (double_bin b)). Proof. intros b. induction b as [| b' | b' IHb']. - reflexivity. - reflexivity. - reflexivity. Qed. Exercise: 4 stars, advanced (bin_nat_bin) Fixpoint normalize (b:bin) : bin := match b with | Z =\u0026gt; Z | B0 b' =\u0026gt; match bin_to_nat b' with | 0 =\u0026gt; Z | S n' =\u0026gt; B0 (normalize b') end | B1 b' =\u0026gt; B1 (normalize b') end. Example normalize_example : normalize (B1 (B0 Z)) = B1 Z. Proof. reflexivity. Qed. ä¹¦ä¸­æåˆ°çš„ \u0026ldquo;equivalent\u0026rdquo; bin å®è´¨ä¸ŠæŒ‡çš„å°±æ˜¯å‰å¯¼ 0 çš„é—®é¢˜ï¼Œnormalize çš„ä¸»è¦ä»»åŠ¡æ˜¯å»é™¤æ‰ B0 (B0 ... Z) çš„æƒ…å†µï¼Œå› æ­¤å¯¹ B0 b' çš„æƒ…å†µè¿›è¡Œç‰¹æ®Šåˆ¤æ–­ã€‚\nè¿™é‡Œåˆ©ç”¨äº† bin_to_nat b' çš„ç»“æœåˆ¤æ–­æ˜¯å¦æ˜¯ 0 è€Œæ²¡æœ‰ç›´æ¥ç”¨ normalize b' çš„ç»“æœï¼Œæ˜¯ä¸ºäº†ä¸‹é¢è¯æ˜çš„æ–¹ä¾¿ã€‚ä¸‹é¢çš„è¯æ˜ä¸­å¯¹ bin_to_nat b' çš„ç»“æœè¿›è¡Œäº†åˆ†ç±»è®¨è®ºï¼Œè¿™æ ·å®šä¹‰å¯ä»¥è®© simpl ç›´æ¥æ‹†è§£å®šä¹‰ã€‚\nLemma mult_2_plus_1_bin : forall n : nat, nat_to_bin(n * 2 + 1) = B1 (nat_to_bin n). Proof. intros n. induction n as [| n' IHn']. - reflexivity. - simpl. rewrite IHn'. reflexivity. Qed. Lemma mult_2_eq_double : forall n : nat, nat_to_bin (n * 2) = double_bin (nat_to_bin n). Proof. intros n. induction n as [| n' IHn']. - reflexivity. - simpl. rewrite IHn'. rewrite double_incr_bin. reflexivity. Qed. Lemma double_bin_eq_B0 : forall b : bin, double_bin (incr b) = B0 (incr b). Proof. intros b. destruct b as [| b' | b'] eqn:B. - reflexivity. - reflexivity. - reflexivity. Qed. Lemma mult_2_bin : forall n : nat, nat_to_bin (S n * 2) = B0 (nat_to_bin (S n)). Proof. intros n. simpl. rewrite mult_2_eq_double. rewrite \u0026lt;- double_incr_bin. rewrite double_bin_eq_B0. reflexivity. Qed. Theorem bin_nat_bin : forall b, nat_to_bin (bin_to_nat b) = normalize b. Proof. intros b. induction b as [| b' | b' IHb']. - reflexivity. - destruct (bin_to_nat b') as [| n'] eqn:N. + simpl. rewrite N. reflexivity. + simpl. rewrite N. rewrite \u0026lt;- IHb'. rewrite mult_2_bin. reflexivity. - simpl. rewrite \u0026lt;- IHb'. rewrite mult_2_plus_1_bin. reflexivity. Qed. ä¸ºäº†è¯æ˜æœ€ç»ˆçš„å®šç†ï¼Œç¬”è€…å…ˆè¯æ˜äº† 3 ä¸ªå¼•ç†ï¼Œä¸»è¦å›´ç»•ç€ *2/*2+1 å’Œåœ¨ binå‰é¢æ·»åŠ  B0/B1 çš„ä¸€è‡´æ€§è®¨è®ºã€‚æœ€ç»ˆå®šç†çš„è¯æ˜ä¸­æ¯”è¾ƒç²¾å¦™çš„éƒ¨åˆ†æ˜¯å…³äº bin_to_nat b' çš„è®¨è®ºã€‚åœ¨å½’çº³æ­¥éª¤ä¸­ç­‰å¼å³è¾¹æ˜¯ normalize (B0 b')ï¼Œå¦‚æœæˆ‘ä»¬ä¸èƒ½ç¡®å®š b' ä¸æ˜¯ Zï¼Œé‚£ä¹ˆæ‹¬å·é‡Œçš„ B0 å°±æä¸å‡ºæ¥ï¼Œå¯å¦‚æœå¯¹ç€ b\u0026rsquo; çš„ç»“æ„ç›´æ¥è¿›è¡Œè®¨è®ºï¼Œåˆå®¹æ˜“é™·å…¥å¾ªç¯è®ºè¯ (å¦‚æœ b'= B0 b''ï¼Œä»ç„¶è¯´æ˜ä¸äº†é—®é¢˜)ï¼Œå› æ­¤åœ¨è¿™é‡Œé€‰æ‹©å¯¹ b\u0026rsquo; è½¬åŒ–æˆè‡ªç„¶æ•°åçš„ç»“æœè¿›è¡Œè®¨è®ºã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"f7805daf6bd7ae729437592b78c7bc5c","permalink":"https://kristoff-starling.github.io/notes/booknotes/softwarefoundations/lf/induction/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/booknotes/softwarefoundations/lf/induction/","section":"notes","summary":"Separate Compilation Proof by Induction Proofs Within Proofs Formal vs. Informal Proof Exercises Exercise: 2 stars, standard, especially useful (basic_induction) Exercise: 2 stars, standard (double_plus) Exercise: 2 stars, standard (eqb_refl) Exercise: 2 stars, standard, optional (even_S) Exercise: 3 stars, standard, especially useful (mul_comm) Exercise: 2 stars, standard, optional (plus_leb_compat_l) Exercise: 3 stars, standard, optional (more_exercises) Exercise: 2 stars, standard, optional (add_shuffle3\u0026rsquo;) Exercise: 3 stars, standard, especially useful (binary_commute) Exercise: 3 stars, standard (nat_bin_nat) Exercise: 2 stars, advanced (double_bin) Exercise: 4 stars, advanced (bin_nat_bin) Separate Compilation å¦‚æœæƒ³åœ¨æ–°çš„ .","tags":null,"title":"Proof by Indution","type":"docs"},{"authors":null,"categories":null,"content":"å€¼å¾—ä¸€æçš„æ˜¯é™„åŠ çš„æ€è€ƒé¢˜ï¼Œå¯¹ç†è§£ lambda è¡¨è¾¾å¼å’Œå‡½æ•°çš„æœ¬è´¨å¾ˆæœ‰å¸®åŠ©ï¼š\nQ3: Church Numerals def zero(f): return lambda x: x def successor(n): return lambda f: lambda x: f(n(f)(x)) åœ¨ successor() å’Œ zero() çš„åŸºç¡€ä¸Šæˆ‘ä»¬å¯ä»¥ç”¨å‡½æ•°å®šä¹‰å‡ºæ‰€æœ‰çš„è‡ªç„¶æ•°ï¼šzero, one, two\u0026hellip; è¿™äº›ä¸œè¥¿æœ¬è´¨ä¸Šæ˜¯å‡½æ•°ï¼Œå®ƒä»¬é¦–å…ˆæ¥å—ä¸€ä¸ªå‚æ•° fï¼Œf å¯ä»¥æ˜¯ä¸€ä¸ªä»»æ„çš„å‡½æ•°ã€‚æ¥æ”¶å®Œ f ä¹‹å zero(f) one(f) \u0026hellip; è¿™äº›ä¸œè¥¿è¿˜æ˜¯å‡½æ•°ï¼Œå®ƒä»¬å¯ä»¥æ¥æ”¶ä¸€ä¸ªâ€œè‡ªå˜é‡\u0026quot; x å¹¶è¿”å›ç»“æœ (å¯ä»¥ç†è§£ä¸º _(_) å‰é¢å¡«å‡½æ•°åï¼Œåé¢å¡«è‡ªå˜é‡)ã€‚\nè¿™é‡Œä¸¾ä¸€ä¾‹è¯´æ˜ successor() çš„ä½œç”¨ï¼šè€ƒè™‘ successor(zero)ï¼Œä¼ å…¥ f å’Œ x åï¼Œzero(f) å°±æ˜¯ lambda x: x è¿™ä¸ªåŠŸèƒ½ä¸Šæ˜¯ identity çš„åŒ¿åå‡½æ•°ï¼Œä»è€Œ zero(f)(x) çš„ç»“æœæ˜¯ xï¼Œå› æ­¤ one çš„è¿”å›å€¼æ˜¯ f(x)ï¼Œå› æ­¤\ndef one(f): return lambda f: lambda x: f(x) def two(f): return lambda f: lambda x: f(f(x)) å®¹æ˜“ç”¨å½’çº³æ³•è¯æ˜ n(f)(x) å°±æ˜¯ $f(f(\u0026hellip;f(x)))$ï¼Œæˆ–è€…ç†è§£ä¸ºå¯¹ç€ x è¿™ä¸ªä¸œè¥¿å°†æ“ä½œ f åš n æ¬¡åçš„ç»“æœï¼Œåä¸€ç§ç†è§£æ›´ä¸ºå¥½ç”¨ã€‚\næ¥ä¸‹æ¥è€ƒè™‘ church_to_int(n)ï¼Œn è¿™ä¸ªä¸œè¥¿æ˜¯ä¸€ä¸ªåµŒå¥—äº†å¾ˆå¤šå±‚çš„å‡½æ•°ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“å®ƒåµŒå¥—äº†å¤šå°‘å±‚ï¼Œç›´æ¥å»è§£æ„æ˜¾ç„¶æ˜¯ä¸è¡Œçš„ã€‚æœ€å¥½çš„åŠæ³•å°±æ˜¯ç²¾å¿ƒè®¾è®¡ä¼ ç»™ n çš„å‚æ•° f å’Œ xã€‚æˆ‘ä»¬å‘ç°ï¼šå¦‚æœä»¤ f ä¸ºå‡½æ•°â€œå°†ä¸€ä¸ªæ•°+1\u0026quot;ï¼Œä»¤ x ä¸º 0ï¼Œé‚£ä¹ˆ n(f)(x) å°±æ˜¯\u0026quot;å¯¹ç€ 0 å°† +1 æ“ä½œåš n æ¬¡åçš„ç»“æœ\u0026quot;ï¼Œè¿™æ­£å¥½æ˜¯æˆ‘ä»¬éœ€è¦çš„ç­”æ¡ˆã€‚å› æ­¤\ndef church_to_int(n): return n(increment)(0) å†ç„¶åæ˜¯åŠ æ³•ã€‚ä¸€ç§æ¯”è¾ƒæœ´ç´ çš„å†™æ³•æ˜¯å…ˆè§£æå‡º m å’Œ n çš„å…·ä½“æ•°å€¼ï¼Œåˆ©ç”¨æ•°å€¼ç›¸åŠ ï¼Œå†å¾ªç¯è°ƒç”¨ successor è·å¾—å‡½æ•°ï¼š\ndef add_church(m, n): s = church_to_int(m) + church_to_int(n) ans = zero for _ in range(s): ans = successor(ans) return ans ä½†è¿™ç§åšæ³•è¿èƒŒäº†è¿™é“é¢˜å®Œå…¨æ‘†è„±è‡ªç„¶æ•°ä½“ç³»çš„ç¾æ„Ÿï¼Œæˆ‘ä»¬å¯ä»¥ä»æ›´æŠ½è±¡çš„è§’åº¦çœ‹å¾…è¿™ä¸ªé—®é¢˜ï¼šm(f) å’Œ n(f) åˆ†åˆ«è¡¨ç¤º â€œåš m æ¬¡ fâ€ å’Œ â€œåš n æ¬¡ fâ€ï¼Œå› æ­¤ m(f)n(f)(x) å°±æ˜¯å…ˆå¯¹ x åš n æ¬¡ f å†åš m æ¬¡ fï¼Œä¹Ÿå°±æ˜¯åšäº† $m+n$ æ¬¡ fã€‚\ndef add_church(m, n): return m(f)n(f)(x) ä¹˜æ³•ï¼šè€ƒè™‘åˆ° m(f) æ˜¯ â€œåš m æ¬¡ f\u0026quot;ï¼Œé‚£ä¹ˆ n(m(f)) å°±æ˜¯â€œæŠŠåšmæ¬¡fè¿™ä»¶äº‹æƒ…åšnæ¬¡â€œï¼Œä¹Ÿå°±æ˜¯åšäº† $m\\times n$ æ¬¡ fã€‚\ndef mul_church(m, n): return n(m(f))(x) ä¹˜æ–¹æ›´å…·æœ‰æŒ‘æˆ˜æ€§ï¼Œæˆ‘ä»¬ç›´æ¥è§£è¯» n(m)(f)(x) çš„æ„æ€ï¼š é¦–å…ˆ n(m) ç›¸å½“äºæŠŠ m é‡å¤äº† n æ¬¡ï¼Œå®ƒçš„ç»“æ„ç±»ä¼¼äº m(m(m(...m(_))))ï¼Œä¹Ÿå°±æ˜¯æ¯ä¸€ä¸ª m è¿”å›çš„å‡½æ•°ä½œä¸ºä¸‹ä¸€å±‚ m çš„å‚æ•°ã€‚n(m)(f) ç›¸å½“äºæŠŠå‡½æ•° f å¡«åˆ°äº†ä¹‹å‰çš„ä¸‹åˆ’çº¿ä¸­ï¼Œå› æ­¤å±•å¼€åï¼Œç¬¬ä¸€ä¸ª m çš„å‡½æ•°å‚æ•°æ˜¯ä¸€ä¸ª fï¼Œç¬¬äºŒä¸ª m çš„å‡½æ•°å‚æ•°å°±æ˜¯ m ä¸ª fï¼Œç¬¬ä¸‰ä¸ª m çš„å‡½æ•°å‚æ•°å°±æ˜¯ $m^2$ ä¸ª fï¼Œä¾æ¬¡ç±»æ¨ï¼Œå…¨éƒ¨å±•å¼€å°±æ˜¯ $m^n$ ä¸ª fã€‚\ndef pow_church(m, n): return n(m)(f)(x) ä¹˜æ³•å’Œä¹˜æ–¹å†™æ³•çš„ç»†å¾®å·®åˆ«æ˜¯å¾ˆå€¼å¾—ç©å‘³çš„ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"ce27b8a25adf114349b069dc5a217245","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/homework/hw02/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/homework/hw02/","section":"notes","summary":"å€¼å¾—ä¸€æçš„æ˜¯é™„åŠ çš„æ€è€ƒé¢˜ï¼Œå¯¹ç†è§£ lambda è¡¨è¾¾å¼å’Œå‡½æ•°çš„æœ¬è´¨å¾ˆæœ‰å¸®åŠ©ï¼š\nQ3: Church Numerals def zero(f): return lambda x: x def successor(n): return lambda f: lambda x: f(n(f)(x)) åœ¨ successor() å’Œ zero() çš„åŸºç¡€ä¸Šæˆ‘ä»¬å¯ä»¥ç”¨å‡½æ•°å®šä¹‰å‡ºæ‰€æœ‰çš„è‡ªç„¶æ•°ï¼šzero, one, two\u0026hellip; è¿™äº›ä¸œè¥¿æœ¬è´¨ä¸Šæ˜¯å‡½æ•°ï¼Œå®ƒä»¬é¦–å…ˆæ¥å—ä¸€ä¸ªå‚æ•° fï¼Œf å¯ä»¥æ˜¯ä¸€ä¸ªä»»æ„çš„å‡½æ•°ã€‚æ¥æ”¶å®Œ f ä¹‹å zero(f) one(f) \u0026hellip; è¿™äº›ä¸œè¥¿è¿˜æ˜¯å‡½æ•°ï¼Œå®ƒä»¬å¯ä»¥æ¥æ”¶ä¸€ä¸ªâ€œè‡ªå˜é‡\u0026quot; x å¹¶è¿”å›ç»“æœ (å¯ä»¥ç†è§£ä¸º _(_) å‰é¢å¡«å‡½æ•°åï¼Œåé¢å¡«è‡ªå˜é‡)ã€‚","tags":null,"title":"UCB-CS61A Homework 02: Higher-Order Functions","type":"docs"},{"authors":null,"categories":null,"content":"Side Effects ä¸€ä¸ªå‡½æ•°å¦‚æœæ²¡æœ‰æ˜¾å¼åœ°è¿”å›å†…å®¹ï¼Œé‚£ä¹ˆå®ƒçš„è¿”å›å€¼é»˜è®¤ä¸º Noneã€‚æ¯”å¦‚ä¸‹é¢çš„ç¨‹åºä¼šæŠ¥ TypeErrorï¼š\ndef square(x): x * x result = square(4) # result = 'None' print(result + 1) ä¸€ä¸ªå‡½æ•°æœ‰ side-effect æŒ‡çš„æ˜¯å®ƒé™¤äº†è¿”å›å†…å®¹è¿˜åšäº†ä¸€äº›å¯è§çš„äº‹æƒ…ï¼Œæœ€å¸¸è§çš„æœ‰ side-effect çš„å‡½æ•°å°±æ˜¯ print()ã€‚\nä¸€ä¸ªæœ‰è¶£çš„é—®é¢˜ï¼šprint(print(1), print(2)) çš„ç»“æœï¼Ÿ\né¦–å…ˆï¼Œé‡Œé¢çš„ print(1) ä¼š Display \u0026ldquo;1\u0026rdquo;ï¼Œprint(2) ä¼š Display \u0026ldquo;2\u0026rdquo;ã€‚ä¸¤ä¸ª print å‡½æ•°æ²¡æœ‰æ˜¾å¼åœ°è¿”å›ï¼Œæ‰€ä»¥å¤–å±‚çš„ print ä¼š Display \u0026ldquo;None None\u0026rdquo;ã€‚æ•´ä¸ªè¯­å¥çš„è¿”å›å€¼æ˜¯ Noneã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"8e69fc5aa11e2e32e1fea3c17c3ae405","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/lectures/lec03/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/lectures/lec03/","section":"notes","summary":"Side Effects ä¸€ä¸ªå‡½æ•°å¦‚æœæ²¡æœ‰æ˜¾å¼åœ°è¿”å›å†…å®¹ï¼Œé‚£ä¹ˆå®ƒçš„è¿”å›å€¼é»˜è®¤ä¸º Noneã€‚æ¯”å¦‚ä¸‹é¢çš„ç¨‹åºä¼šæŠ¥ TypeErrorï¼š\ndef square(x): x * x result = square(4) # result = 'None' print(result + 1) ä¸€ä¸ªå‡½æ•°æœ‰ side-effect æŒ‡çš„æ˜¯å®ƒé™¤äº†è¿”å›å†…å®¹è¿˜åšäº†ä¸€äº›å¯è§çš„äº‹æƒ…ï¼Œæœ€å¸¸è§çš„æœ‰ side-effect çš„å‡½æ•°å°±æ˜¯ print()ã€‚\nä¸€ä¸ªæœ‰è¶£çš„é—®é¢˜ï¼šprint(print(1), print(2)) çš„ç»“æœï¼Ÿ\né¦–å…ˆï¼Œé‡Œé¢çš„ print(1) ä¼š Display \u0026ldquo;1\u0026rdquo;ï¼Œprint(2) ä¼š Display \u0026ldquo;2\u0026rdquo;ã€‚ä¸¤ä¸ª print å‡½æ•°æ²¡æœ‰æ˜¾å¼åœ°è¿”å›ï¼Œæ‰€ä»¥å¤–å±‚çš„ print ä¼š Display \u0026ldquo;None None\u0026rdquo;ã€‚æ•´ä¸ªè¯­å¥çš„è¿”å›å€¼æ˜¯ Noneã€‚","tags":null,"title":"UCB-CS61A Lecture 03: Control","type":"docs"},{"authors":null,"categories":null,"content":" Pairs of Numbers Lists of Numbers Repeat Length Append Head ant Tail Bags via Lists Reasoning About Lists Induction on Lists Reversing a List Search Options Partial Maps Exercises Exercise: 1 star, standard (snd_fst_is_swap) Exercise: 1 star, standard, optional (fst_swap_is_snd) Exercise: 2 stars, standard, especially useful (list_funs) Exercise: 3 stars, advanced (alternate) Exercise: 3 stars, standard, especially useful (bag_functions) Exercise: 3 stars, standard, optional (bag_more_functions) Exercise: 2 stars, standard, especially useful (add_inc_count) Exercise: 3 stars, standard (list_exercises) Exercise: 2 stars, standard (eqblist) Exercise: 1 star, standard (count_member_nonzero) Exercise: 3 stars, advanced (remove_does_not_increase_count) Exercise: 3 stars, standard, optional (bag_count_sum) Exercise: 3 stars, advanced (involution_injective) Exercise: 2 stars, advanced (rev_injective) Exercise: 2 stars, standard (hd_error) Exercise: 1 star, standard, optional (option_elim_hd) Exercise: 1 star, standard (eqb_id_refl) Exercise: 1 star, standard (update_eq) Exercise: 1 star, standard (update_neq) Pairs of Numbers æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ª pair ç±»å‹ï¼š\nInductive natprod : Type := | pair (n1 n2 : nat). Notation \u0026quot;( x, y )\u0026quot; := (pair x y). ä»¥åŠä¸€äº›è¾…åŠ©å‡½æ•°ï¼š\nDefinition fst (p : natprod) : nat := match p with | (x, y) =\u0026gt; x end. Definition snd (p : natprod) : nat := match p with | (x, y) =\u0026gt; y end. Definition swap_pair(p : natprod) : nat := match p with | (x, y) =\u0026gt; (y, x) end. è¿™é‡Œå€¼å¾—æ³¨æ„çš„æ˜¯åœ¨ pattern matching ä¸­çš„ (x, y) å’Œ x, y æ˜¯ä¸ä¸€æ ·çš„ï¼šå‰è€…åŒ¹é…çš„æ˜¯ä¸€ä¸ª pair ç±»å‹ï¼Œè€Œåè€…åŒ¹é…äº†ä¸¤ä¸ªä¸œè¥¿ã€‚\nä¸‹é¢çœ‹ä¸€ä¸ªæœ‰æ„æ€çš„è¯æ˜é¢˜ï¼š\nTheorem surjective_pairing : forall p : natprod, p = (fst p, snd p). æˆ‘ä»¬æ— æ³•é€šè¿‡ simpl ç›´æ¥è¯æ˜è¯¥é¢˜ï¼Œå› ä¸º p çš„å…·ä½“å†…å®¹ä¸çŸ¥é“ï¼Œfst p snd p æ— æ³•åŒ–ç®€ã€‚ä¸€ä¸ªå¥½çš„æ–¹æ³•æ˜¯ä½¿ç”¨ destructï¼š\nProof. intros p. destruct p as [n m]. simpl. reflexivity. Qed. è¿™é‡Œçš„ destruct ä¸æ˜¯ç”¨æ¥åˆ†ç±»è®¨è®ºï¼Œè€Œæ˜¯å…¶å­—é¢æ„æ€ï¼šç»™ p ä¸€ä¸ªå½¢å¼ï¼Œä»è€Œè§£æ„å®ƒã€‚\nLists of Numbers æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªé“¾è¡¨ç±»å‹ï¼š\nInductive natlist : Type := | nil | cons (n : nat) (l : natlist). ç®€å•æ¥è¯´ï¼Œæ¯ä¸€ä¸ª natlist ç±»å‹çš„å˜é‡è¦ä¹ˆæ˜¯ nilï¼Œè¦ä¹ˆæ˜¯ä¸€ä¸ªè‡ªç„¶æ•°å’Œå¦ä¸€ä¸ª natlistã€‚ä¸‹é¢çš„ä¸€äº› notation è®©è¡¨ç¤ºé“¾è¡¨å˜å¾—ç®€å•ï¼š\nNotation \u0026quot;x :: l\u0026quot; := (cons x l) (at level 60, right associativity). Notation \u0026quot;[ ]\u0026quot; := nil. Notation \u0026quot;[ x ; .. ; y]\u0026quot; := (cons x .. (cons y nil) ..). è¿™é‡Œå€¼å¾—æ³¨æ„ä¸¤ç‚¹ï¼š\n:: åº”å½“æ˜¯å³ç»“åˆçš„ï¼Œå³ 1 :: 2 :: 3 ç­‰ä»·äº 1 :: (2 :: 3)ã€‚ :: çš„ä¼˜å…ˆçº§ä½äºåŠ å‡æ³•ï¼Œå³ 1 + 2 :: 3 ç­‰ä»·äº (1 + 2) :: 3ã€‚ Repeat repeat å‡½æ•°æ¥æ”¶ä¸¤ä¸ªå‚æ•° n å’Œ countï¼Œè¿”å›ä¸€ä¸ªé•¿åº¦ä¸º countï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½æ˜¯ n çš„é“¾è¡¨ï¼š\nFixpoint repeat (n count : nat) -\u0026gt; natlist := match count with | O =\u0026gt; nil | S count' =\u0026gt; n :: (repeat n count') end. Length length å‡½æ•°æ¥æ”¶ä¸€ä¸ªå‚æ•° lï¼Œè¿”å›é“¾è¡¨ l çš„é•¿åº¦ã€‚\nFixpoint length (l : natlist) -\u0026gt; nat := match l with | nil =\u0026gt; 0 | h :: t =\u0026gt; 1 + (length t) end. Append app å‡½æ•°ç”¨äºæŠŠä¸¤ä¸ªé“¾è¡¨è¿æ¥èµ·æ¥ã€‚\nFixpoint app (l1 l2 : natlist) -\u0026gt; natlist := match l1 with | nil =\u0026gt; l2 | h :: t =\u0026gt; h :: (app t l2) end. Notation \u0026quot;x ++ y\u0026quot; := (app x y) (right associativity, at level 60). Head ant Tail hd å‡½æ•°è¿”å›é“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œtl å‡½æ•°è¿”å›é“¾æ¡é™¤äº†ç¬¬ä¸€ä¸ªå…ƒç´ ä»¥å¤–çš„åé¢çš„éƒ¨åˆ†ã€‚\nDefinition hd (default : nat) (l : natlist) -\u0026gt; nat := match hd with | nil =\u0026gt; default | h :: t =\u0026gt; h end. Definition tl (l : natlist) -\u0026gt; natlist := match tl with | nil =\u0026gt; nil | h :: t =\u0026gt; t end. Bags via Lists è¿™é‡Œçš„ bag æŒ‡çš„æ˜¯ multisetã€‚æˆ‘ä»¬å¯ä»¥ç”¨é“¾è¡¨æ¨¡æ‹Ÿ multisetã€‚\nReasoning About Lists List çš„ match å®šä¹‰è®©æˆ‘ä»¬å¯ä»¥å¯¹äºå¾ˆå¤šæ¯”è¾ƒç®€å•çš„å‘½é¢˜ç›´æ¥ä½¿ç”¨ reflexivity æˆ–è€…åˆ†ç±»è®¨è®ºè§£å†³ã€‚ä½†ç¨å¤æ‚çš„é—®é¢˜è¿˜æ˜¯è¦å€ŸåŠ©å½’çº³æ³•ã€‚\nInduction on Lists å¯¹äºé“¾è¡¨çš„å½’çº³æ³•å’Œå¯¹äºè‡ªç„¶æ•°çš„å½’çº³æ³•æ²¡æœ‰æœ¬è´¨åŒºåˆ«ã€‚åªè¦ä½¿ç”¨ Inductive çš„æ–¹å¼å®šä¹‰çš„ç±»å‹éƒ½å¯ä»¥ä½¿ç”¨å½’çº³æ³•è¿›è¡Œè¯æ˜ã€‚ä¸‹é¢æ˜¯ ++ å…·æœ‰ç»“åˆå¾‹çš„ä¸€æ®µè¯æ˜ï¼š\nTheorem app_assoc : forall l1 l2 l3 : natlist, (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3). Proof. intros l1 l2 l3. induction l1 as [| n l1' IHl']. - (* l1 = nil *) reflexivity. - (* l1 = cons n l1' *) simpl. rewrite IHl'. reflexivity. Qed. Reversing a List è€ƒè™‘å¦‚ä¸‹çš„ç¿»è½¬é“¾è¡¨çš„å‡½æ•°ï¼š\nFixpoint rev (l : natlist) : natlist := match l with | nil =\u0026gt; nil | h :: t =\u0026gt; (rev t) ++ [h] end. ä¸‹é¢æˆ‘ä»¬å°è¯•è¯æ˜é“¾è¡¨ç¿»è½¬åé•¿åº¦ä¸å˜ï¼š\nTheorem rev_length : forall l : natlist, length (rev l) = length l. å¦‚æœç›´æ¥ä½¿ç”¨æ•°å­¦å½’çº³æ³•è¯æ˜ï¼Œåœ¨ successor case ä¸­ï¼Œæˆ‘ä»¬ä¼šè¢« length(rev l' ++ [n]) = S (length (rev l')) è¿™ä¸ªç»“è®ºå¡ä½ã€‚å› æ­¤æˆ‘ä»¬éœ€è¦å…ˆè¯æ˜ä¸€ä¸ªå¼•ç†ï¼šé“¾è¡¨ç»“åˆåçš„é•¿åº¦ç­‰äºç»“åˆå‰ä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦ä¹‹å’Œã€‚\nTheorem app_length : forall l1 l2 : natlist, length (l1 ++ l2) = (length l1) + (length l2). Proof. intros l1 l2. induction l1 as [| n l1' IHl1']. - reflexivity. - simpl. rewrite IHl1'. reflexivity. Qed. Theorem rev_length : forall l : natlist, length (rev l) = length l. Proof. intros l. induction l as [| n l' IHl']. - reflexivity. - simpl. rewrite app_length. simpl. rewrite IHl'. rewrite add_comm. reflexivity. Qed. Search æˆ‘ä»¬åœ¨è¯æ˜çš„æ—¶å€™æ—¶å¸¸è¦ä½¿ç”¨ä¹‹å‰è¯æ˜è¿‡çš„å¼•ç†ï¼Œä½†ä½¿ç”¨è¿™äº›å¼•ç†éœ€è¦çŸ¥é“å®ƒä»¬çš„åå­—ï¼Œå¦‚æœç°åœºä¸è®°å¾—åå­—ï¼Œå¯ä»¥ä½¿ç”¨ Search name çš„æ–¹å¼æ¥æŸ¥æ‰¾ï¼ŒCoq ä¼šè¾“å‡ºæ‰€æœ‰åå­—ä¸­å¸¦æœ‰ name çš„å¼•ç†ã€‚\nSearch tactic è¿˜æ”¯æŒæ›´åŠ ä¸°å¯Œçš„æŸ¥æ‰¾åŠŸèƒ½ï¼Œä¾‹å¦‚\nSearch (_ + _ = _ + _) inside Induction. ä¼šåœ¨ Induction æ¨¡å—ä¸­å¯»æ‰¾ç¬¦åˆä¸Šè¿°å½¢å¼çš„å®šç†ã€‚\nSearch (?x + ?y = ?y + ?x). å‡ ä¹å¯ä»¥ç›´æ¥é”å®šåˆ°åŠ æ³•äº¤æ¢å¾‹ã€‚è¿™é‡Œå˜é‡å‰åŠ ä¸€ä¸ª ? è¡¨ç¤ºè¿™æ˜¯æœç´¢æ—¶ä½¿ç”¨çš„ patternï¼Œè€Œä¸æ˜¯åœ¨å½“å‰ç¯å¢ƒä¸­è¦æ±‚å­˜åœ¨çš„å˜é‡ã€‚\nOptions è¿™ä¸€ç« èŠ‚è®²è¿°äº† error handling çš„é‡è¦æ€§ã€‚å‡è®¾æˆ‘ä»¬è¦å†™ä¸€ä¸ªå‡½æ•°è¿”å›é“¾è¡¨çš„ç¬¬ n ä¸ªå…ƒç´ ï¼Œæˆ‘ä»¬å¿…é¡»è¦è€ƒè™‘å¦‚æœé“¾è¡¨çš„é•¿åº¦å°äº n åº”å½“è¿”å›ä»€ä¹ˆï¼Œå¦‚æœæˆ‘ä»¬è¿™æ ·å†™ä»£ç ï¼š\nFixpoint nth_bad (l : natlist) (n : nat) : nat := match l with | nil =\u0026gt; 42 | a :: l' =\u0026gt; match n with | 0 â‡’ a | S n' â‡’ nth_bad l' n' end end. é‚£ä¹ˆå¦‚æœå‡½æ•°è¿”å›äº† 42ï¼Œæˆ‘ä»¬å¿…é¡»å†æ£€æŸ¥ä¸€éé“¾è¡¨æ‰èƒ½ç¡®å®šç©¶ç«Ÿæ˜¯é“¾è¡¨å¤ªçŸ­äº†è¿˜æ˜¯ç¬¬ n ä¸ªå…ƒç´ æ­£å¥½æ˜¯ 42ã€‚ä¸€ä¸ªå¥½çš„æ–¹æ³•æ˜¯é‡æ–°å®šä¹‰è¿”å›ç±»å‹ï¼Œåœ¨ error æ—¶è¿”å›ä¸€ä¸ªç‰¹æ®Šçš„ä¸œè¥¿ï¼š\nInductive natoption : Type := | Some (n : nat) | None. Fixpoint nth_error (l : natlist) (n : nat) : natoption := match l with | nil =\u0026gt; None | a :: l' =\u0026gt; match n with | O â‡’ Some a | S n' â‡’ nth_error l' n' end end. ä¹‹åæˆ‘ä»¬è¿˜å¯ä»¥æ ¹æ®å…·ä½“çš„æƒ…å¢ƒæ¥é€‰æ‹©ä¸åŒçš„ä¸å¯èƒ½å‡ºç°çš„å€¼ä½œä¸ºè¿”å›å€¼ï¼š\nDefinition option_elim (d : nat) (o : natoption) : nat := match o with | Some n' =\u0026gt; n' | None =\u0026gt; d end. Partial Maps è¿™ä¸€ç« ä»‹ç»äº†ç”¨ Coq å®šä¹‰ map è¿™ä¸€æ•°æ®ç»“æ„ã€‚map æœ¬è´¨ä¸Šå°±æ˜¯ key-value pair çš„é›†åˆã€‚è¿™é‡Œæˆ‘ä»¬å…ˆä¸º key å®šä¹‰ä¸€ä¸ªå•ç‹¬çš„ç±»å‹ (æ²¡æœ‰ä»€ä¹ˆç‰¹æ®Šçš„ä½œç”¨ï¼Œåªæ˜¯ä¸ºäº†å°è£…ä¸€ä¸‹å¥½çœ‹)ï¼š\nInductive id : Type := | Id (n : nat) æ¥ä¸‹æ¥æˆ‘ä»¬å®šä¹‰ partial map:\nInductive partial_map : Type := | empty | record (i : id) (v : nat) (m : partial_map) è¯¥å®šä¹‰çš„æ„æ€æ˜¯ï¼špartial map è¦ä¹ˆæ˜¯ empty (ç©ºé›†)ï¼Œè¦ä¹ˆæ˜¯ä¸€ä¸ª key-value pair æ¥ä¸Šå¦ä¸€ä¸ª partial mapã€‚\nä¸‹é¢çš„ update å‡½æ•°å¯ä»¥å®Œæˆå‘ partial map ä¸­æ·»åŠ ä¸€ä¸ª key-value pair çš„åŠŸèƒ½ï¼š\nDefinition update (d : partial_map) (x : id) (value : nat) -\u0026gt; partial_map := record x value d. find å‡½æ•°å¯ä»¥æŸ¥è¯¢ partial map ä¸­æ˜¯å¦å­˜åœ¨æŸä¸ª idï¼Œå¹¶è¿”å›å¯¹åº”çš„ valueï¼š\nFixpoint find (x : id) (d : partial_map) : natoption := match d with | empty =\u0026gt; None. | y v d' =\u0026gt; if eqb_id x y then Some v else find x d' end.s Exercises Exercise: 1 star, standard (snd_fst_is_swap) Theorem snd_fst_is_swap : forall (p : natprod), (snd p, fst p) = swap_pair p. Proof. intros p. destruct p as [n m]. reflexivity. Qed. Exercise: 1 star, standard, optional (fst_swap_is_snd) Theorem fst_swap_is_snd : forall (p : natprod), fst (swap_pair p) = snd p. Proof. intros p. destruct p as [n m]. reflexivity. Qed. Exercise: 2 stars, standard, especially useful (list_funs) Fixpoint nonzeros (l:natlist) : natlist := match l with | nil =\u0026gt; nil | O :: t =\u0026gt; nonzeros t | S n :: t =\u0026gt; S n :: (nonzeros t) end. Example test_nonzeros: nonzeros [0;1;0;2;3;0;0] = [1;2;3]. Proof. reflexivity. Qed. Fixpoint oddmembers (l:natlist) : natlist := match l with | nil =\u0026gt; nil | h :: t =\u0026gt; if (even h) then (oddmembers t) else (h :: (oddmembers t)) end. Example test_oddmembers: oddmembers [0;1;0;2;3;0;0] = [1;3]. Proof. reflexivity. Qed. Definition countoddmembers (l:natlist) : nat := length (oddmembers l). Example test_countoddmembers1: countoddmembers [1;0;3;1;4;5] = 4. Proof. reflexivity. Qed. Example test_countoddmembers2: countoddmembers [0;2;4] = 0. Proof. reflexivity. Qed. Example test_countoddmembers3: countoddmembers nil = 0. Proof. reflexivity. Qed. Exercise: 3 stars, advanced (alternate) Fixpoint alternate (l1 l2 : natlist) : natlist := match l1, l2 with | nil, nil =\u0026gt; nil | nil, _ =\u0026gt; l2 | _, nil =\u0026gt; l1 | h1 :: t1, h2 :: t2 =\u0026gt; h1 :: h2 :: (alternate t1 t2) end. Example test_alternate1: alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6]. Proof. reflexivity. Qed. Example test_alternate2: alternate [1] [4;5;6] = [1;4;5;6]. Proof. reflexivity. Qed. Example test_alternate3: alternate [1;2;3] [4] = [1;4;2;3]. Proof. reflexivity. Qed. Example test_alternate4: alternate [] [20;30] = [20;30]. Proof. reflexivity. Qed. Exercise: 3 stars, standard, especially useful (bag_functions) Fixpoint count (v : nat) (s : bag) : nat := match s with | nil =\u0026gt; 0 | h :: t =\u0026gt; if (v =? h) then 1 + (count v t) else (count v t) end. Example test_count1: count 1 [1;2;3;1;4;1] = 3. Proof. reflexivity. Qed. Example test_count2: count 6 [1;2;3;1;4;1] = 0. Proof. reflexivity. Qed. Definition sum : bag -\u0026gt; bag -\u0026gt; bag := app. Example test_sum1: count 1 (sum [1;2;3] [1;4;1]) = 3. Proof. reflexivity. Qed. è¿™é‡Œå¯ä»¥æ³¨æ„ä¸€ä¸‹ä¸æ˜¾å¼ç»™å‡ºå‚æ•°åç§°çš„å®šä¹‰å‡½æ•°çš„æ–¹æ³•ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬åªèƒ½æŠŠä¸€ä¸ªå‚æ•°ç±»å‹å’Œè¿”å›å€¼ç±»å‹ç›¸åŒçš„å‡½æ•°èµ‹ç»™å½“å‰å‡½æ•°ã€‚\nDefinition add (v : nat) (s : bag) : bag := v :: s. Example test_add1: count 1 (add 1 [1;4;1]) = 3. Proof. reflexivity. Qed. Example test_add2: count 5 (add 1 [1;4;1]) = 0. Proof. reflexivity. Qed. Fixpoint member (v : nat) (s : bag) : bool := match s with | nil =\u0026gt; false | h :: t =\u0026gt; if (v =? h) then true else (member v t) end. Example test_member1: member 1 [1;4;1] = true. Proof. reflexivity. Qed. Example test_member2: member 2 [1;4;1] = false. Proof. reflexivity. Qed. Exercise: 3 stars, standard, optional (bag_more_functions) Fixpoint remove_one (v : nat) (s : bag) : bag := match s with | nil =\u0026gt; nil | h :: t =\u0026gt; if (h =? v) then t else (h :: (remove_one v t)) end. Example test_remove_one1: count 5 (remove_one 5 [2;1;5;4;1]) = 0. Proof. reflexivity. Qed. Example test_remove_one2: count 5 (remove_one 5 [2;1;4;1]) = 0. Proof. reflexivity. Qed. Example test_remove_one3: count 4 (remove_one 5 [2;1;4;5;1;4]) = 2. Proof. reflexivity. Qed. Example test_remove_one4: count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1. Proof. reflexivity. Qed. Fixpoint remove_all (v:nat) (s:bag) : bag := match s with | nil =\u0026gt; nil | h :: t =\u0026gt; if (h =? v) then (remove_all v t) else (h :: (remove_all v t)) end. Example test_remove_all1: count 5 (remove_all 5 [2;1;5;4;1]) = 0. Proof. reflexivity. Qed. Example test_remove_all2: count 5 (remove_all 5 [2;1;4;1]) = 0. Proof. reflexivity. Qed. Example test_remove_all3: count 4 (remove_all 5 [2;1;4;5;1;4]) = 2. Proof. reflexivity. Qed. Example test_remove_all4: count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0. Proof. reflexivity. Qed. Fixpoint included (s1 : bag) (s2 : bag) : bool := match s1 with | nil =\u0026gt; true | h :: t =\u0026gt; if ((count h s2) =? 0) then false else included t (remove_one h s2) end. Example test_included1: included [1;2] [2;1;4;1] = true. Proof. reflexivity. Qed. Example test_included2: included [1;2;2] [2;1;4;1] = false. Proof. reflexivity. Qed. Exercise: 2 stars, standard, especially useful (add_inc_count) Theorem add_inc_count : forall (v : nat) (s : bag), count v (add v s) = 1 + count v s. Proof. intros. simpl. rewrite eqb_refl. (* n =? n = true *) reflexivity. Qed. Exercise: 3 stars, standard (list_exercises) Theorem app_nil_r : forall l : natlist, l ++ [] = l. Proof. intros l. induction l as [| n l' IHl']. - reflexivity. - simpl. rewrite IHl'. reflexivity. Qed. Theorem rev_app_distr: forall l1 l2 : natlist, rev (l1 ++ l2) = rev l2 ++ rev l1. Proof. intros l1 l2. induction l1 as [|n l1' IHl1']. - rewrite app_nil_r. reflexivity. - simpl. rewrite IHl1'. rewrite app_assoc. reflexivity. Qed. Theorem rev_involutive : forall l : natlist, rev (rev l) = l. Proof. intros l. induction l as [| n l' IHl']. - reflexivity. - simpl. rewrite rev_app_distr. rewrite IHl'. reflexivity. Qed. Theorem app_assoc4 : forall l1 l2 l3 l4 : natlist, l1 ++ (l2 ++ (l3 ++ l4)) = ((l1 ++ l2) ++ l3) ++ l4. Proof. intros l1 l2 l3 l4. rewrite app_assoc. rewrite app_assoc. reflexivity. Qed. Lemma nonzeros_app : forall l1 l2 : natlist, nonzeros (l1 ++ l2) = (nonzeros l1) ++ (nonzeros l2). Proof. intros l1 l2. induction l1 as [| n l1' IHl1']. - reflexivity. - destruct n as [| n'] eqn:N. + simpl. rewrite IHl1'. reflexivity. + simpl. rewrite IHl1'. reflexivity. Qed. Exercise: 2 stars, standard (eqblist) Fixpoint eqblist (l1 l2 : natlist) : bool := match l1, l2 with | nil, nil =\u0026gt; true | nil, _ =\u0026gt; false | _, nil =\u0026gt; false | h1 :: t1, h2 :: t2 =\u0026gt; if (h1 =? h2) then (eqblist t1 t2) else false end. Example test_eqblist1 : (eqblist nil nil = true). Proof. reflexivity. Qed. Example test_eqblist2 : eqblist [1;2;3] [1;2;3] = true. Proof. reflexivity. Qed. Example test_eqblist3 : eqblist [1;2;3] [1;2;4] = false. Proof. reflexivity. Qed. Theorem eqblist_refl : forall l:natlist, true = eqblist l l. Proof. intros l. induction l as [| n l' IHl']. - (* l = nil *) reflexivity. - (* l = con n l' *) simpl. rewrite eqb_refl. (* n =? n = true *) rewrite IHl'. reflexivity. Qed. Exercise: 1 star, standard (count_member_nonzero) Theorem count_member_nonzero : forall (s : bag), 1 \u0026lt;=? (count 1 (1 :: s)) = true. Proof. intros s. reflexivity. Qed. Exercise: 3 stars, advanced (remove_does_not_increase_count) Theorem remove_does_not_increase_count: forall (s : bag), (count 0 (remove_one 0 s)) \u0026lt;=? (count 0 s) = true. Proof. intros s. induction s as [| n s' IHs']. - reflexivity. - destruct n as [| n'] eqn:N. + simpl. rewrite leb_n_Sn. reflexivity. + simpl. rewrite IHs'. reflexivity. Qed. Exercise: 3 stars, standard, optional (bag_count_sum) Theorem count_sum : forall (v : nat) (l1 l2 : bag), count v l1 + count v l2 = count v (sum l1 l2). Proof. intros v l1 l2. induction l1 as [| n l1' IHl1']. - reflexivity. - simpl. destruct (v =? n) as []. + simpl. rewrite IHl1'. reflexivity. + rewrite IHl1'. reflexivity. Qed. è¿™é¢˜ä¸€ä¸ªå€¼å¾—æ³¨æ„çš„ç»†èŠ‚æ˜¯ï¼šæˆ‘ä»¬ä¸æ–¹ä¾¿åˆ©ç”¨ destruct ç›´æ¥å»è®¨è®º n æ˜¯å¦ç­‰äº vï¼Œä½†æˆ‘ä»¬å¯ä»¥é€šè¿‡è®¨è®º v =? n æ˜¯ true è¿˜æ˜¯ false æ¥å®ç°è¿™ä¸€éœ€æ±‚ã€‚\nExercise: 3 stars, advanced (involution_injective) Theorem involution_injective : forall (f : nat -\u0026gt; nat), (forall n : nat, n = f (f n)) -\u0026gt; (forall n1 n2 : nat, f n1 = f n2 -\u0026gt; n1 = n2). Proof. intros f H1 n1 n2 H2. rewrite H1. rewrite \u0026lt;- H2. rewrite \u0026lt;- H1. reflexivity. Qed. Exercise: 2 stars, advanced (rev_injective) Theorem rev_injective : forall (l1 l2 : natlist), rev l1 = rev l2 -\u0026gt; l1 = l2. Proof. intros l1 l2 H. rewrite \u0026lt;- rev_involutive. rewrite \u0026lt;- H. rewrite rev_involutive. reflexivity. Qed. è¯¥å®šç†çš„è¯æ˜å…·æœ‰ä¸€å®šçš„æŠ€å·§æ€§ã€‚å¦‚æœç›´æ¥å¯¹æŸä¸ªé“¾è¡¨ä½¿ç”¨å½’çº³æ³•ä¼šæ¯”è¾ƒç¹çã€‚è¿™é‡Œåˆ©ç”¨ involutive å®šç† l = rev (rev l)å…ˆæŠŠ l2 æ¢æˆ rev (rev l2)ï¼Œå†åˆ©ç”¨æ¡ä»¶æŠŠ rev l2 æ¢æˆ rev l1ï¼Œæœ€åæ¢ä¸€ä¸ªæ–¹å‘åˆ©ç”¨ involutive å®Œæˆè¯æ˜ã€‚\nExercise: 2 stars, standard (hd_error) Definition hd_error (l : natlist) : natoption := match l with | nil =\u0026gt; None | h :: t =\u0026gt; (Some h) end. Example test_hd_error1 : hd_error [] = None. Proof. reflexivity. Qed. Example test_hd_error2 : hd_error [1] = Some 1. Proof. reflexivity. Qed. Example test_hd_error3 : hd_error [5;6] = Some 5. Proof. reflexivity. Qed. Exercise: 1 star, standard, optional (option_elim_hd) Theorem option_elim_hd : forall (l:natlist) (default:nat), hd default l = option_elim default (hd_error l). Proof. intros l d. destruct l as [| h l'] eqn:L. - reflexivity. - reflexivity. Qed. Exercise: 1 star, standard (eqb_id_refl) Theorem eqb_id_refl : forall x, eqb_id x x = true. Proof. intros x. destruct x as [n]. simpl. rewrite eqb_refl. reflexivity. Qed. Exercise: 1 star, standard (update_eq) Theorem update_eq : forall (d : partial_map) (x : id) (v: nat), find x (update d x v) = Some v. Proof. intros d x v. simpl. destruct x as [x']. simpl. rewrite eqb_refl. reflexivity. Qed. Exercise: 1 star, standard (update_neq) Theorem update_neq : forall (d : partial_map) (x y : id) (o: nat), eqb_id x y = false -\u0026gt; find x (update d y o) = find x d. Proof. intros d x y o H. simpl. rewrite H. reflexivity. Qed. ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"cc2099b0681a6a05ff595c593a982b4e","permalink":"https://kristoff-starling.github.io/notes/booknotes/softwarefoundations/lf/lists/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/booknotes/softwarefoundations/lf/lists/","section":"notes","summary":"Pairs of Numbers Lists of Numbers Repeat Length Append Head ant Tail Bags via Lists Reasoning About Lists Induction on Lists Reversing a List Search Options Partial Maps Exercises Exercise: 1 star, standard (snd_fst_is_swap) Exercise: 1 star, standard, optional (fst_swap_is_snd) Exercise: 2 stars, standard, especially useful (list_funs) Exercise: 3 stars, advanced (alternate) Exercise: 3 stars, standard, especially useful (bag_functions) Exercise: 3 stars, standard, optional (bag_more_functions) Exercise: 2 stars, standard, especially useful (add_inc_count) Exercise: 3 stars, standard (list_exercises) Exercise: 2 stars, standard (eqblist) Exercise: 1 star, standard (count_member_nonzero) Exercise: 3 stars, advanced (remove_does_not_increase_count) Exercise: 3 stars, standard, optional (bag_count_sum) Exercise: 3 stars, advanced (involution_injective) Exercise: 2 stars, advanced (rev_injective) Exercise: 2 stars, standard (hd_error) Exercise: 1 star, standard, optional (option_elim_hd) Exercise: 1 star, standard (eqb_id_refl) Exercise: 1 star, standard (update_eq) Exercise: 1 star, standard (update_neq) Pairs of Numbers æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ª pair ç±»å‹ï¼š","tags":null,"title":"Working with Structured Data","type":"docs"},{"authors":null,"categories":null,"content":"Isolation We want strong isolation between applications so that if there\u0026rsquo;s a bug in one application, the others will not be damaged. We also want isolation between applications and the operating system so that if weird arguments were passed to the OS, OS wouldn\u0026rsquo;t crash. Let\u0026rsquo;s consider what happens if there\u0026rsquo;s no operating system, a strawman design. In this case, several applications (e.g. shell, echo etc.) run on the hardware, there is no abstraction layer between H/W and applications.\nThere\u0026rsquo;s a demand for switching between applications. Because there\u0026rsquo;s no OS, shell needs to proactively \u0026ldquo;give up\u0026rdquo; and \u0026ldquo;quit\u0026rdquo; the CPU to let others use the hardware. This is the so-called cooperating schedule. However, if there\u0026rsquo;s a dead loop in shell or shell is a malware, it will not quit and the hardware is completely occupied by this application. Therefore, we need a kind of \u0026ldquo;enforced multipliexing\u0026rdquo;: no matter what the application does, it will be forced to give up the CPU once in a while.\nDifferent applications share the same memory space. For example, shell\u0026rsquo;s memory may start at address 1000 and echo\u0026rsquo;s memory may start at address 2000. There\u0026rsquo;s no boundary between their memory space and it\u0026rsquo;s easy for one application to overwrite others\u0026rsquo; memory and cause tricky bugs.\nIn summary, we need operating systems to enforce both multiplexing and strong memory isolation. Strawman design is not very common in today\u0026rsquo;s computer system. Some real-time system doesn\u0026rsquo;t have OS because applications trust each other, but in most cases we need OS to ensure isolation.\nUnix inferfaces are sophisticated design. They abstracts the hardware resources and make isolation possible. For example,\nProcess is the abstraction of CPU. Applications use fork() to create new processes, but it cannot assign a CPU core directly. How to schedule the processes on the CPU and how to arrange different CPU cores are the jobs of OS. Exec is the abstraction of memory. Application use exec() to load a new applications, during which it loads the memory image which describes the text, data segments etc. During execution, applications can use system calls like sbrk() to modify the memory image, but they cannot act directly on the physical memory. OS is responsible for allocating physical memory to the memory image. File is the abstraction of disk blocks. Applications do operations on the files but they don\u0026rsquo;t have direct access to the physical storage device. They don\u0026rsquo;t know where the \u0026ldquo;file\u0026rdquo; is actually stored, which is the job belongs to OS. OS should be defensive: it should treat all the processes as malicious applications written by attackers and ensure that\nApps cannot crash the OS. Apps cannot break out of the isolation. Strong isolation is totally depend on the OS. The kernel is call \u0026ldquo;trusted computing base\u0026rdquo; (TCB). Kernels must have as few bugs as possible because any bug may be taken advantage of and becomes an exploit.\nStrong isolation between applications and the OS are typically implemented by hardware support. Ususally there\u0026rsquo;re two: use/kernel mode and virtual memory.\nUser/Kernel mode When running in kernel mode, CPU can execute privileged instructions which interact directly with CSRs e.g. setting up page table register, disable clock interrupts etc.\nIn user mode, CPU can only execute unprivileged instructions such as add jmp etc. There is a bit in the CSR to let hardware check which mode the current process/thread is in (0 for kernel, 1 for user). If the CPU decode one instruction, find out that it\u0026rsquo;s a privileged one and the mode bit is 1, it will deny executing the instruction. (Of course, the instruction for changing the mode bit is a privileged one.)\nIf a user application wants to execute privileged instructions, it should transfer from user mode to kernel mode first and let the kernel execute the instruction.\nThere is a method for applications to enter the kernel. In RISC-V, the instruction is ecall. The user store ssystem call number in a particular register and ecall, the PC jumps to a specific address in the kernel, and kernel checks the syetem call number, does security checks and jumps to corresponding service functions.\nVirtual Memory Each process has its own page table: it maps virtual addresses to physical addresses. If the OS allocates different memory space to different processes, processes will not be able to access other processes\u0026rsquo;s memory space because those addresses are not in its page table. In this way, the OS provides strong memory isolation.\nKernel Design An instant question is: since kernel should be TCB, what kind of code should be run in kernel mode? Most Unix-like operating system put the whole OS into the kernel mode(including xv6). This style is call monolithic kernel design. Though this design contains more code and increases the risk of having serious bugs, it\u0026rsquo;s helpful for tight integration between different modules (file system, virtual memory, processes etc.) and can achieve better performance.\nAnother style, which aims at running as fewer lines as possible in the kernel to avoid bug risks, is called micro kernel design. The kernel only contains some core modules and other modules like file system are run in user mode and treated like ordinary user applications. The challenge for this design is how to improve performance. For example, if an application wants to access the file system, frequent jumps between kernel mode and user mode are needed to achieve that. (app(u) $\\rightarrow$ IPC(k) $\\rightarrow$ FS(u) $\\rightarrow$ IPC(k) $\\rightarrow$ app(u))\nXv6 Code Details Xv6 uses monolithic kernel design. All the *.c programs in /kernel are run in kernel mode. The Makefile grabs all the C files in /kernel and generates relocatable files: *.c$\\overset{CC}{\\rightarrow}$*.S$\\overset{AS}{\\rightarrow}$*.o. ld is responsible for linking all the *.o files and generate an executable file /kernel/kernel. /kernel/kernel.asm containing disassembled code of the kernel will also be generated for debugging.\nXv6 starts at address 0x80000000. The code is written directly in assembly and is in /kernel/entry.S. /kernel/kernel.ld ensures that the assembly code will be linked to 0x80000000. Currently, xv6 runs in machine mode - no protection, no virtual memory etc. The job for xv6 is to enter supervisor mode(kernel mode) as soon as possible.\nWhen xv6 jumps to main() in /kernel/main.c, it has been in supervisor mode. Here we use make CPUS=1 qemu-gdb to fire up xv6, so there\u0026rsquo;s only one CPU core in our simulated CPU. The code in main() is shown as below:\nif(cpuid() == 0){ consoleinit(); printfinit(); printf(\u0026quot;\\n\u0026quot;); printf(\u0026quot;xv6 kernel is booting\\n\u0026quot;); printf(\u0026quot;\\n\u0026quot;); kinit(); // physical page allocator kvminit(); // create kernel page table kvminithart(); // turn on paging procinit(); // process table trapinit(); // trap vectors trapinithart(); // install kernel trap vector plicinit(); // set up interrupt controller plicinithart(); // ask PLIC for device interrupts binit(); // buffer cache iinit(); // inode cache fileinit(); // file table virtio_disk_init(); // emulated hard disk userinit(); // first user process __sync_synchronize(); started = 1; } Xv6 initializes lots of things and then jumps to userinit() run the first process. userinit() (in /kernel/proc.c) loads the first process. Because currently xv6 hasn\u0026rsquo;t built the file system and cannot load images, the assembly code is statically declared in the array initcode[]. The assembly code of the \u0026ldquo;first process loader\u0026rdquo; is in /user/initcode.S:\n# Initial process that execs /init. # This code runs in user space. #include \u0026quot;syscall.h\u0026quot; # exec(init, argv) .globl start start: la a0, init la a1, argv li a7, SYS_exec ecall # for(;;) exit(); exit: li a7, SYS_exit ecall jal exit # char init[] = \u0026quot;/init\\0\u0026quot;; init: .string \u0026quot;/init\\0\u0026quot; # char *argv[] = { init, 0 }; .p2align 2 argv: .long init .long 0 initcode.S prepares arguments for the SYS_exec system call and uses ecall instruction to go back to kernel space. ecall will lead us to syscall() in /kernel/syscall.c:\nvoid syscall(void) { int num; struct proc *p = myproc(); num = p-\u0026gt;trapframe-\u0026gt;a7; if(num \u0026gt; 0 \u0026amp;\u0026amp; num \u0026lt; NELEM(syscalls) \u0026amp;\u0026amp; syscalls[num]) { p-\u0026gt;trapframe-\u0026gt;a0 = syscalls[num](); } else { printf(\u0026quot;%d %s: unknown sys call %d\\n\u0026quot;, p-\u0026gt;pid, p-\u0026gt;name, num); p-\u0026gt;trapframe-\u0026gt;a0 = -1; } } The variable num\u0026rsquo;s value, after the instruction num = p-\u0026gt;trapframe-\u0026gt;a7, equals 7, which is SYS_exec\u0026rsquo;s value defined in /kernel/syscall.h. The kernel knows that some user program wants to use the exec system call, so it goes to syscalls[num](), which is a function table for providing system call services.\nThe function sys_exec() is in /kernel/sysfile.c. In line 444:\nint ret = exec(path, argv) If we print the value of \u0026ldquo;path\u0026rdquo;, we will find that it equals \u0026ldquo;/init\u0026rdquo;. So xv6 loads user program /user/init.c.\ninit.c mainly forks some child processes and exec sh.c, so xv6 starts the shell and the booting procedure is completed.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"9bac06ec716342b68d249f0d412ff998","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-operating-system/lectures/lec03/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-operating-system/lectures/lec03/","section":"notes","summary":"Isolation We want strong isolation between applications so that if there\u0026rsquo;s a bug in one application, the others will not be damaged. We also want isolation between applications and the operating system so that if weird arguments were passed to the OS, OS wouldn\u0026rsquo;t crash.","tags":null,"title":"MIT-6.S081 Lecture 03: OS Organization and System Calls","type":"docs"},{"authors":null,"categories":null,"content":"å€¼å¾—ä¸€æçš„æ˜¯ä¸‹é¢å‡ é“é¢˜ï¼š\nQ1: Num Eights ä¸€ä¸ªå€¼å¾—æ³¨æ„çš„ python ä¼˜å…ˆçº§é—®é¢˜ï¼šç¬”è€…åˆšå¼€å§‹å†™äº†ä¸€è¡Œ\nreturn num_eights(pos // 10) + 1 if pos % 10 == 8 else 0 ä½†è¿™æ ·å‰é¢çš„ä¸€æ•´ä¸ª num_eights(pos // 10) + 1 éƒ½ä¼šæˆä¸º if æ¡ä»¶æˆç«‹çš„ç»“æœã€‚æ­£ç¡®çš„å†™æ³•åº”å½“åŠ ä¸Šæ‹¬å·ï¼š\nreturn num_eights(pos // 10) + (1 if pos % 10 == 8 else 0) Q4: Count Coins å¦‚ä½•ä¸é‡ä¸æ¼åœ°è®¡æ•°æ˜¯æœ¬é¢˜çš„éš¾ç‚¹ã€‚æˆ‘ä»¬å»é‡çš„æ–¹æ³•æ˜¯ï¼šå¯¹äºæ¯ä¸€ç§ç»„åˆæ–¹æ¡ˆåªè®¡ç®—å°†é’±å¸å‡åºæ’åˆ—çš„é‚£ä¸€ç§ã€‚å› æ­¤æˆ‘ä»¬é€’å½’æ—¶ä¸ä»…è¦è®°å½•å‰©ä½™çš„ changeï¼Œè¿˜è¦è®°å½•å½“å‰å·²ç»è€ƒè™‘åˆ°å“ªç§é¢å€¼çš„é’±å¸ã€‚å‡è®¾å‡½æ•°è®°ä¸º count(change, coin)ï¼Œè½¬ç§»æˆ‘ä»¬è¦è€ƒè™‘ count(change - coin, coin) å’Œ count(change, descending_coin(coin)) ä¸¤ç§ç±»å‹ã€‚\nQ6: Anonymous Factorial è¿™æ˜¯ä¸€é“ç›¸å½“å…·æœ‰æŒ‘æˆ˜æ€§çš„é¢˜ç›®ï¼Œè¦æ±‚åœ¨ä¸ä½¿ç”¨å‡½æ•°åçš„æƒ…å†µä¸‹å®Œæˆé€’å½’ã€‚æ ¹æ® make_anonymous_factorial()(5) çš„å½¢å¼å¯ä»¥çœ‹å‡º make_anonymous_factorial() æ˜¯ä¸€ä¸ªè¿”å›å€¼ä¸ºå‡½æ•°çš„é«˜é˜¶å‡½æ•°ã€‚\næˆ‘ä»¬çš„æ ¸å¿ƒæ€æƒ³æ˜¯ï¼š**æ—¢ç„¶ç”¨äºè®¡ç®—é˜¶ä¹˜çš„å‡½æ•°æ˜¯åŒ¿åå‡½æ•°æ— æ³•ç›´æ¥é€šè¿‡å‡½æ•°åè°ƒç”¨ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å°†è¯¥å‡½æ•°æœ¬èº«ä½œä¸ºå‡½æ•°çš„ä¸€ä¸ªå‚æ•°ä¸€è·¯ä¼ ä¸‹å»ã€‚**æŒ‰ç…§è¿™ä¸ªæ€æƒ³æˆ‘ä»¬å¯ä»¥å†™å‡ºå¦‚ä¸‹çš„ä¸€ä¸ª lambda è¡¨è¾¾å¼ï¼šlambda fact, n: 1 if n == 0 else n * fact(fact, n-1)ã€‚\næˆ‘ä»¬è¦æŠŠè¿™ä¸ªå‡½æ•°æœ¬èº«ä½œä¸ºå‚æ•° fact ä¼ è¿›å»ï¼Œå› æ­¤æˆ‘ä»¬å¤–é¢è¿˜å¾—å†å¥—ä¸€å±‚å£³ã€‚å¤–é¢çš„å£³ä½¿ç”¨ä¸€ä¸‹ function currying å°±å¯ä»¥å†æ¥å—ä¸€ä¸ªå‚æ•° nã€‚æœ€ç»ˆçš„ç»“æœå¦‚ä¸‹ï¼š\nreturn (lambda f: lambda n: f(f, n))(lambda fact, n: 1 if n == 0 else n * fact(fact, n-1)) ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"e3bbdbfb41a15248678b828adf148d5f","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/homework/hw03/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/homework/hw03/","section":"notes","summary":"å€¼å¾—ä¸€æçš„æ˜¯ä¸‹é¢å‡ é“é¢˜ï¼š\nQ1: Num Eights ä¸€ä¸ªå€¼å¾—æ³¨æ„çš„ python ä¼˜å…ˆçº§é—®é¢˜ï¼šç¬”è€…åˆšå¼€å§‹å†™äº†ä¸€è¡Œ\nreturn num_eights(pos // 10) + 1 if pos % 10 == 8 else 0 ä½†è¿™æ ·å‰é¢çš„ä¸€æ•´ä¸ª num_eights(pos // 10) + 1 éƒ½ä¼šæˆä¸º if æ¡ä»¶æˆç«‹çš„ç»“æœã€‚æ­£ç¡®çš„å†™æ³•åº”å½“åŠ ä¸Šæ‹¬å·ï¼š","tags":null,"title":"UCB-CS61A Homework 03: Recursion, Tree Recursion","type":"docs"},{"authors":null,"categories":null,"content":" Polymorphism Polymorphic Lists Type Annotation Inference Type Argument Synthesis Implicit Arguments Supplying Type Arguments Explicitly Polymorphic Pairs Polymorphic Options Functions as Data Higher-Order Functions Filter Anonymous Functions Maps Fold Functions That Construct Functions Exercises Exercise: 2 stars, standard, optional (mumble_grumble) Exercise: 1 star, standard, optional (combine_checks) Exercise: 2 stars, standard, especially useful (split) Exercise: 1 star, standard, optional (hd_error_poly) Exercise: 2 stars, standard (filter_even_gt7) Exercise: 3 stars, standard (partition) Exercise: 3 stars, standard (map_rev) Exercise: 2 stars, standard, especially useful (flat_map) Exercise: 1 star, standard, optional (fold_types_different) Exercise: 2 stars, standard (fold_length) Exercise: 3 stars, standard (fold_map) Exercise: 2 stars, advanced (currying) Church Numerals (Advanced) Exercise: 2 stars, advanced (church_scc) Exercise: 3 stars, advanced (church_plus) Exercise: 3 stars, advanced (church_mult) Exercise: 3 stars, advanced (church_exp) è¿™ä¸€ç« èŠ‚æˆ‘ä»¬ä¸»è¦å…³æ³¨å‡½æ•°å¼ç¼–ç¨‹çš„ä¸¤ä¸ªåŸºæœ¬æ¦‚å¿µï¼šå¤šæ€ (polymorphism)ï¼Œå³å¯¹å‡½æ•°æ“ä½œçš„å¯¹è±¡çš„ç±»å‹è¿›è¡ŒæŠ½è±¡ï¼›é«˜é˜¶å‡½æ•°ï¼Œå³å°†å‡½æ•°æœ¬èº«çœ‹ä½œæ•°æ®ã€‚\nPolymorphism Polymorphic Lists ä¸Šä¸€ç« èŠ‚ä¸­æˆ‘ä»¬å®šä¹‰çš„åˆ—è¡¨åªèƒ½å¤„ç†è‡ªç„¶æ•°ã€‚åœ¨çœŸæ­£çš„ç¨‹åºä¸­åˆ—è¡¨ä¸­çš„å…ƒç´ ç±»å‹æ˜¯ä¸°å¯Œçš„ï¼Œç”šè‡³å¯ä»¥æœ‰ list of listsã€‚æˆ‘ä»¬ä¸å¯èƒ½å¯¹æ¯ç§ç±»å‹éƒ½å®šä¹‰ä¸€ç§åˆ—è¡¨â€”â€”å› ä¸ºæˆ‘ä»¬ä¸ä»…è¦å®šä¹‰ç±»å‹ï¼Œè¿˜è¦å°†åˆ—è¡¨ç›¸å…³çš„æ‰€æœ‰å®šç†å¯¹æ¯ç§ç±»å‹éƒ½è¯æ˜ä¸€éï¼Œè¿™å‡ ä¹æ˜¯ä¸å¯èƒ½çš„ã€‚\nåŸºäºä»¥ä¸Šéœ€æ±‚ï¼ŒCoq æ”¯æŒäº† polymorphic çš„ inductive type definitionã€‚æ¯”å¦‚ä¸‹é¢æ˜¯ä¸€ä¸ªå¤šæ€çš„ list ç±»å‹ï¼š\nInductive list (X : Type) : Type := | nil | cons (x : X) (l : list X). å¤šæ€çš„æœ¬è´¨å¾ˆç®€å•ï¼šæˆ‘ä»¬ä¹‹å‰å®šä¹‰çš„ç±»å‹ä»¥å½’çº³çš„æ–¹å¼æè¿°äº†ä¸€ä¸ªé›†åˆï¼Œç°åœ¨ list æ˜¯ä¸€ä¸ª Type -\u0026gt; Type çš„å‡½æ•°ï¼š\nCheck list: Type -\u0026gt; Type å®ƒæ¥æ”¶ä¸€ä¸ªç±»å‹ X ä½œä¸ºå‚æ•°ï¼Œè¿”å› list X è¿™ä¸ªç±»å‹ï¼Œâ€œlist Xâ€ ç±»å‹æ˜¯ä¸€ä¸ªåŒ…å«äº†æ‰€æœ‰ç”± X ç±»å‹å…ƒç´ æ„æˆçš„é“¾è¡¨çš„é›†åˆã€‚\nlist å®šä¹‰ä¸­çš„ç±»å‹ X ä¼šè‡ªåŠ¨æˆä¸º constructor çš„å‚æ•°â€”â€”å³ç°åœ¨ nil å’Œ con éƒ½æ˜¯å¤šæ€ constructorï¼Œä»¥åä½¿ç”¨å®ƒä»¬æ—¶éœ€è¦åœ¨åé¢å†™ä¸Šç±»å‹ã€‚ä¾‹å¦‚ï¼š\nCheck (cons nat 3 (nil nat)) : list nat. nil å’Œ cons çš„ç±»å‹ä¹Ÿéƒ½æ˜¯ä» Type æ˜ å°„åˆ° list X çš„â€œå‡½æ•°â€ï¼š\nCheck nil : forall X : Type, list X. Check cons: forall X : Type, X -\u0026gt; list X -\u0026gt; list X. æœ‰äº†å¤šæ€çš„åˆ—è¡¨å®šä¹‰åï¼Œæˆ‘ä»¬å¯ä»¥æŠŠä¹‹å‰å†™çš„å‡½æ•°ä¹Ÿæ”¹æˆå¤šæ€çš„ã€‚ä¸‹é¢ä»¥ repeat ä¸ºä¾‹ï¼š\nFixpoint repeat (X : Type) (x : X) (count : nat) : list X := match count with | 0 =\u0026gt; nil X | S count' =\u0026gt; cons X x (repeat X x count') end. Type Annotation Inference å¦‚æœæˆ‘ä»¬åœ¨ä¹¦å†™å‡½æ•°æ—¶ä¸æ˜¾å¼å£°æ˜å‚æ•°çš„ç±»å‹ï¼Œä¾‹å¦‚\nFixpoint repeat' X x count : list X := match count with | 0 =\u0026gt; nil X | S count' =\u0026gt; cons X x (repeat X x count') end. æˆ‘ä»¬ä¼šå‘ç° Check repeat å’Œ Check repeat' çš„ç»“æœæ˜¯å®Œå…¨ä¸€æ ·çš„ã€‚è¿™æ˜¯å› ä¸º Coq å¯ä»¥è‡ªåŠ¨è¿›è¡Œ type inferenceï¼Œä¾‹å¦‚æ ¹æ® count match çš„æ–¹æ³•å¯ä»¥çœ‹å‡º count ä¸€å®šæ˜¯ nat ç±»å‹ç­‰ç­‰ã€‚\nType Argument Synthesis synthesis å’Œ inference çš„åŸç†ç±»ä¼¼ï¼šåœ¨æŸäº›åœ°æ–¹ä½ å¯ä»¥ç›´æ¥ç”¨ _ æ¥ä»£æ›¿ç±»å‹åï¼ŒCoq ä¼šç»“åˆæ‰€æœ‰çš„ä¸Šä¸‹æ–‡ä¿¡æ¯è‡ªåŠ¨åˆ†æå‡ºè¿™é‡Œè¯¥å¡«å†™ä»€ä¹ˆã€‚ä¾‹å¦‚ä¸‹é¢ä¸¤å¥ä»£ç åœ¨åŠŸèƒ½ä¸Šæ˜¯ç­‰ä»·çš„ï¼š\nDefinition list123 := cons nat 1 (cons nat 2 (cons nat 3 (nil nat))). Definition list123' := cons _ 1 (cons _ 2 (cons _ 3 (nil _))). Implicit Arguments åˆ©ç”¨ implicit argument æŠ€æœ¯ï¼Œæˆ‘ä»¬ç”šè‡³å¯ä»¥å°† _ çœç•¥æ‰ã€‚\nç¬¬ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨ Arguments è¯­æ³•ï¼šArguments å¯ä»¥æŒ‡å®šä¸€ä¸ªå‡½æ•°/constructorçš„åå­—ï¼Œä»¥åŠéœ€è¦è¢«å¤„ç†ä¸º implicit çš„ç±»å‹åï¼Œä»¥åå†ä½¿ç”¨è¯¥å‡½æ•°/constructoræ—¶å°±ä¸éœ€è¦å†æ˜¾å¼åœ°ç»™å‡ºç±»å‹åæˆ–ç±»å‹åçš„å ä½ç¬¦ã€‚ä¾‹å¦‚ï¼š\nArguments nil {X}. Arguments cons {X}. Arguments repeat {X}. è¿™æ—¶æˆ‘ä»¬å®šä¹‰ list123 å°±å¯ä»¥ç›´æ¥å†™ï¼š\nDefinition list123'' := cons 1 (cons 2 (cons 3 nil)). ç¬¬äºŒç§æ›´æ–¹ä¾¿çš„è¯­æ³•æ˜¯ï¼šæˆ‘ä»¬åœ¨å®šä¹‰ Type/å‡½æ•°çš„æ—¶å€™ï¼Œå¯ä»¥ç”¨ {} ä»£æ›¿ () æŠŠç”¨äºå¤šæ€çš„ç±»å‹åæ¡†èµ·æ¥ï¼Œè¿™æ ·ä»¥åè‡ªåŠ¨çœç•¥ç±»å‹åå‚æ•°ã€‚ä¸‹é¢æˆ‘ä»¬ç”¨è¿™ç§è¯­æ³•æŠŠ list çš„å…¶ä»–å‡ ä¸ªé‡è¦å‡½æ•°é‡å†™ä¸€ä¸‹ï¼Œå¯ä»¥çœ‹åˆ°ä½¿ç”¨äº† implicit arguments åï¼Œå‡½æ•°ä½“å†…éƒ¨çš„ä»£ç å°±å’Œä¹‹å‰çš„æ²¡æœ‰åŒºåˆ«äº†ï¼š\nFixpoint app {X : Type} (l1 l2 : list X) : list X := match l1 with | nil =\u0026gt; l2 | cons h t =\u0026gt; cons h (app t l2) (* æ³¨æ„æˆ‘ä»¬è¿˜æ²¡æœ‰å¯¹å¤šæ€çš„listå®šä¹‰::ç­‰notationï¼Œæ‰€ä»¥ç°åœ¨è¿˜ä¸èƒ½ ç”¨ h::t çš„æ–¹å¼ä¹¦å†™ï¼Œä¸€ä¼šå„¿å®šä¹‰äº†ä¹‹åå°±å¯ä»¥äº†*) end. Fixpoint rev {X : Type} (l : list X) : list X := match l with | nil =\u0026gt; nil | cons h t =\u0026gt; app (rev t) (cons h nil) end. Fixpoint length {X : Type} (l : list X) : list X := match l with | nil =\u0026gt; 0 | cons h t =\u0026gt; 1 + (length t) end. Supplying Type Arguments Explicitly å°†å‚æ•°å®šä¹‰ä¸ºéšå¼çš„ä¸€ä¸ªåå¤„åœ¨äºï¼ŒæŸäº›ç‰¹æ®Šæƒ…å†µä¸‹ Coq å¯èƒ½æ— æ³•è‡ªåŠ¨è¯†åˆ«å‚æ•°ç±»å‹ã€‚è¿™ç§æƒ…å†µä¸‹æˆ‘ä»¬éœ€è¦ä¸´æ—¶åœ°æ˜¾å¼ç»™å‡ºå‚æ•°ç±»å‹ã€‚ä¾‹å¦‚ï¼š\nFail Definition mynil := nil. ï¼ˆæ³¨ï¼šè¿™é‡Œçš„ Fail å‘½ä»¤è¡¨ç¤ºå¦‚æœåé¢çš„è¯­å¥æ‰§è¡Œå¤±è´¥ï¼ŒCoq ä¼šåœ¨äº¤äº’åŒºæ‰“å°å‡ºé”™è¯¯ä¿¡æ¯ï¼Œä½†ç¨‹åºä»ç„¶å¯ä»¥ç»§ç»­æ‰§è¡Œã€‚ï¼‰\nè¿™æ ·çš„å®šä¹‰æ˜¯ä¸æˆç«‹çš„ï¼Œå› ä¸ºå®Œå…¨æ²¡æœ‰ä¸Šä¸‹æ–‡ä¿¡æ¯å¯ä»¥çœ‹å‡º nil X çš„ X æ˜¯ä»€ä¹ˆç±»å‹ã€‚æˆ‘ä»¬æœ‰ä¸¤ç§è§£å†³æ–¹æ³•ï¼Œä¸€ç§æ˜¯æ˜¾å¼åœ°æŒ‡å®š mynil çš„ç±»å‹ï¼š\nDefinition mynil : list nat := nil. ç¬¬äºŒç§æ˜¯ä½¿ç”¨ @ è®© nil ä¸´æ—¶æ˜¾å¼åœ°æ¥æ”¶ä¸€ä¸ªç±»å‹å‚æ•°ï¼š\nDefinition mynil' := @nil nat. æˆ‘ä»¬å®šä¹‰çš„å¤šæ€ list å’Œä¹‹å‰çš„ list æœ¬è´¨ä¸Šæ˜¯ä¸¤ç§ç±»å‹ï¼Œå› æ­¤æ‰€æœ‰çš„ Notation æˆ‘ä»¬ä¹Ÿè¦é‡æ–°å®šä¹‰ä¸€éï¼š\nNotation \u0026quot;x :: y\u0026quot; := (cons x y) (at level 60, right associativity). Notation \u0026quot;[ ]\u0026quot; := nil. Notation \u0026quot;[ x ; .. ; y ]\u0026quot; := (cons x .. (cons y []) ..). Notation \u0026quot;x ++ y\u0026quot; := (app x y) (at level 60, right associativity). Polymorphic Pairs åœ¨ä¸Šä¸€ç« èŠ‚ä¸­æˆ‘ä»¬å®šä¹‰çš„ä¸¤ä¸ªè‡ªç„¶æ•°çš„ pair ä¹Ÿå¯ä»¥æ‹“å±•æˆå¤šæ€çš„ pairï¼Œè¿™å°±æ˜¯ç¦»æ•£æ•°å­¦ä¸­çš„ç¬›å¡å°”ç§¯ï¼š\nInductive prod (X Y : Type) : Type := | pair (x : X) (y : Y). Argument pair {X} {Y}. Notation \u0026quot;( x, y )\u0026quot; := (pair x y). Notation \u0026quot;X * Y\u0026quot; := (prod X Y) : type_scope. è¿™é‡Œçš„ \u0026ldquo;type_scope\u0026rdquo; è¡¨æ˜äº†ç¬›å¡å°”ç§¯åªä½œç”¨åœ¨ä¸¤ä¸ªç±»å‹ (é›†åˆ) ä¸Šï¼Œé¿å…å’Œè‡ªç„¶æ•°ä¸Šçš„ä¹˜æ³•æ··æ·†ã€‚\n(x, y) å’Œ X * Y åœ¨åˆæœŸå®¹æ˜“æ··æ·†ã€‚ä¸€ä¸ªå¥½çš„ç†è§£æ–¹å¼æ˜¯ï¼šX * Y æ˜¯ä¸€ä¸ªç±»å‹ï¼Œå³ä¸€ä¸ªé›†åˆã€‚å¦‚æœ x çš„ç±»å‹æ˜¯ Xï¼Œy çš„ç±»å‹æ˜¯ Yï¼Œé‚£ä¹ˆ (x, y) æ˜¯ç±»å‹ X * Y çš„ä¸€ä¸ªå®ä¾‹ (é›†åˆ X * Y ä¸­çš„ä¸€ä¸ªå…ƒç´ )ã€‚\nä¸‹é¢çš„å‡½æ•° combine æ¥æ”¶ä¸¤ä¸ª listï¼Œè¿”å›ä¸€ä¸ªæŠŠå¯¹åº” index å…ƒç´ æ‰“åŒ…æˆ pair çš„ listã€‚è¿™ä¸ªå‡½æ•°åœ¨é€šå¸¸çš„ç¼–ç¨‹è¯­è¨€ä¸­ç§°ä¸º zip()ï¼š\nFixpoint combine {X, Y : Type} (l1 : list X) (l2 : list Y) -\u0026gt; list (X * Y) := match lx, ly with | nil, _ =\u0026gt; nil | _, nil =\u0026gt; nil | x :: tx, y :: ty =\u0026gt; (x, y) :: (combine tx ty) end. Polymorphic Options å¯¹äºä¹‹å‰å®šä¹‰çš„ natoptionï¼Œæˆ‘ä»¬ä¹Ÿå°†å…¶è½¬åŒ–ä¸ºå¤šæ€ï¼š\nInductive option (X : Type) : Type := | Some (x : X) | None. Arguments Some {X}. Arguments None {X}. ç„¶åæˆ‘ä»¬å¯ä»¥å°† nth_error å‡½æ•°ä¹Ÿè½¬åŒ–ä¸ºå¤šæ€ï¼š\nFixpoint nth_error {X : Type} (l : list X) (n : nat) : option X := match l with | nil =\u0026gt; None | a :: l' =\u0026gt; match n with | 0 =\u0026gt; a | S n' =\u0026gt; nth_error l' n' end end. Functions as Data å’Œå¤šæ•°å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ä¸€æ ·ï¼ŒCoq å°†å‡½æ•°è§†ä¸º first-class citizenï¼Œå³å‡½æ•°å¯ä»¥ä½œä¸ºå‡½æ•°å‚æ•°ï¼Œå¯ä»¥ä½œä¸ºå‡½æ•°è¿”å›å€¼ï¼Œå¯ä»¥ä½œä¸ºæ•°æ®å­˜å‚¨åœ¨æ•°æ®ç»“æ„ä¸­ã€‚\nHigher-Order Functions ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„æ¥å—å‡½æ•°ä½œä¸ºå‚æ•°çš„é«˜é˜¶å‡½æ•°ï¼š\nDefinition doit3times {X : Type} (f : X -\u0026gt; X) (n : X) : X := f (f (f n)). å‚æ•° f æ˜¯ä¸€ä¸ªä» X æ˜ å°„åˆ° X çš„å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥æ£€æŸ¥ doit3times çš„ç±»å‹ï¼š\nCheck @doit3times : forall X : Type, (X -\u0026gt; X) -\u0026gt; X -\u0026gt; X. Filter ä¸‹é¢å±•ç¤ºä¸€ä¸ªæ›´æœ‰æ„æ€çš„é«˜é˜¶å‡½æ•°ï¼šfilter å‡½æ•°æ¥æ”¶ä¸€ä¸ªå‡½æ•° test å’Œä¸€ä¸ª listï¼Œè¿”å›ä¸€ä¸ªæ–°çš„ listï¼Œå…¶ä¸­åŒ…å«åŸ list ä¸­é€šè¿‡ test æµ‹è¯•çš„å…ƒç´ ï¼š\nFixpoint filter {X : Type} (test : X -\u0026gt; bool) (l : list X) : list X := match l with | nil =\u0026gt; nil | h :: t =\u0026gt; if test h then h :: (filter test t) else filter test t end. å¤šæ€çš„ list å¯ä»¥æ¥æ”¶ä»»ä½•ç±»å‹çš„å…ƒç´ ï¼Œç”šè‡³æ˜¯ list è‡ªå·±ï¼Œå½¢æˆ list of listsï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š\nDefinition length_is_1 {X : Type} (l : list X) : bool := (length l) =? 1. Example test_filter : filter length_is_1 [ [1; 2]; [3]; [4]; [5; 6; 7]; []; [8] ] = [ [3]; [4]; [8]; ]. Proof. reflexivity. Qed. Anonymous Functions æœ‰çš„æ—¶å€™ï¼Œå¿…é¡»ç»™å‡½æ•°å‘½åä»¥æ–¹ä¾¿ä½¿ç”¨æ˜¯ä¸€ä»¶ä»¤äººæ²®ä¸§çš„äº‹æƒ…ï¼Œå› ä¸ºå¾ˆå¤šæ—¶å€™æˆ‘ä»¬åªæ˜¯æƒ³ä¸´æ—¶åˆ›å»ºä¸€ä¸ªå‡½æ•°ä¸¢ç»™é«˜é˜¶å‡½æ•°å½“å‚æ•°ä½¿ç”¨ï¼Œæ¯”å¦‚ä¸Šé¢ä¾‹å­ä¸­çš„ length_is_1ã€‚Coq ä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ç§ä¸´æ—¶åˆ›å»ºå‡½æ•°çš„æ–¹å¼ï¼Œè¿™ç§æ–¹å¼ç±»ä¼¼äº Python ä¸­çš„ lambda è¡¨è¾¾å¼ï¼Œä¸éœ€è¦ç»™å‡½æ•°å‘½åï¼Œè¯¥å‡½æ•°ä¹Ÿä¸ä¼šå‡ºç°åœ¨ top level environment ä¸­ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š\nExample test_filter' : filter (fun l =\u0026gt; (length l) =? 1) [ [1; 2]; [3]; [4]; [5;6;7]; []; [8] ] = [ [3]; [4]; [8] ]. å…¶ä¸­ (fun l =\u0026gt; (length l) =? 1) çš„æ„æ€æ˜¯è¯¥å‡½æ•°æ¥æ”¶ä¸€ä¸ªå‚æ•° lï¼Œè¿”å› (length l) =? 1 (æˆ‘ä»¬å¯ä»¥ä¸æŒ‡æ˜å‚æ•°å’Œè¿”å›å€¼çš„ç±»å‹ï¼ŒCoq ä¼šè‡ªå·±åš type inference)ã€‚\nMaps map ä¹Ÿæ˜¯è®¸å¤šå‡½æ•°å¼è¯­è¨€æ”¯æŒçš„å¸¸ç”¨é«˜é˜¶å‡½æ•°ã€‚å®ƒæ¥æ”¶ä¸€ä¸ªè½¬æ¢å‡½æ•° f å’Œä¸€ä¸ªåˆ—è¡¨ lï¼Œè¿”å›ä¸€ä¸ªæ–°åˆ—è¡¨ï¼Œå…¶å†…å®¹æ˜¯æŠŠ f ä½œç”¨åˆ° l é‡Œçš„æ¯ä¸ªå…ƒç´ åçš„ç»“æœã€‚\nFixpoint map {X Y : Type} (f : X -\u0026gt; Y) (l : list X) : list Y := match l with | nil =\u0026gt; nil | h :: t =\u0026gt; (f h) :: (map f t) end. å€¼å¾—æ³¨æ„çš„æ˜¯ä¼ å…¥çš„åˆ—è¡¨çš„å…ƒç´ ç±»å‹å’Œè¿”å›çš„åˆ—è¡¨çš„å…ƒç´ ç±»å‹ä¸ä¸€å®šä¸€æ ·ã€‚\næˆ‘ä»¬ä¸ä»…å¯ä»¥å¯¹ list åš mapï¼Œä¹Ÿå¯ä»¥å¯¹å…¶ä»–çš„æ•°æ®ç±»å‹åš mapï¼Œæ¯”å¦‚ä¸‹é¢çš„ä¾‹å­å¯¹ option åš mapï¼š\nDefinition option_map {X Y : Type} (f : X -\u0026gt; Y) (xo : option X) : option Y := match xo with | None =\u0026gt; None | Some x =\u0026gt; Some (f x) end. Fold ä¸€ä¸ªæ›´åŠ å¼ºå¤§çš„é«˜é˜¶å‡½æ•°æ˜¯ foldï¼Œå®ƒæ˜¯ Google map-reduced æ¡†æ¶çš„ reduce å‡½æ•°çš„çµæ„Ÿæ¥æºï¼š\nFixpoint fold {X Y : Type} (f : X -\u0026gt; Y -\u0026gt; Y) (l : list X) (b : Y) : Y := match l with | nil =\u0026gt; b | h :: t =\u0026gt; f h (fold f t b) end. ä»ç›´è§‚ä¸Šæ¥ç†è§£ï¼Œè¯¥å‡½æ•°æ¥æ”¶å‡½æ•° fï¼Œåˆ—è¡¨ l å’Œåˆå§‹å€¼ bã€‚ç„¶åä»åˆå§‹å€¼ b å¼€å§‹ï¼ŒæŠŠåˆ—è¡¨ä¸­çš„å…ƒç´ æŒ‰ç…§ä»å³å¾€å·¦çš„é¡ºåºä¾æ¬¡ä¸ type Y çš„ç»“æœåšå‡½æ•° f æ“ä½œã€‚æ¯”å¦‚ fold plus [1; 2; 3; 4] 0 å°±æ„å‘³ç€ 1+(2+(3+(4+0)))ã€‚\nFunctions That Construct Functions æˆ‘ä»¬ä¹‹å‰è®¨è®ºçš„é«˜é˜¶å‡½æ•°éƒ½æ˜¯å°†å‡½æ•°ä½œä¸ºå‚æ•°ä¼ å…¥ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œçœ‹ä¸€äº›å°†å‡½æ•°ä½œä¸ºå‡½æ•°è¿”å›å€¼çš„ä¾‹å­ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªæ¯”è¾ƒ dummy çš„ä¾‹å­ï¼Œconstfun è¿”å›çš„å‡½æ•°ä¸è®ºæ¥æ”¶ä»€ä¹ˆéƒ½ä¼šè¾“å‡ºå›ºå®šå€¼ï¼š\nDefinition constfun {X : Type} (x : X) : nat -\u0026gt; X := fun (k : nat) =\u0026gt; x. äº‹å®ä¸Šï¼Œå‡½æ•°å¼ç¼–ç¨‹æœ¬è´¨ä¸Šä¸æ”¯æŒå¤šå‚æ•°çš„å‡½æ•°ï¼Œæˆ‘ä»¬ä¹‹å‰çœ‹åˆ°çš„å¤šå‚æ•°çš„å‡½æ•°éƒ½æ˜¯é€šè¿‡ currying å®Œæˆçš„ã€‚ä»¥ plus ä¸ºä¾‹ï¼š\nCheck plus : nat -\u0026gt; nat -\u0026gt; nat. è¿™é‡Œçš„ -\u0026gt; å¯ä»¥ç†è§£ä¸ºä½œç”¨åœ¨ type ç±»å‹å…ƒç´ ä¸Šçš„ä¸€ç§äºŒå…ƒè¿ç®—ç¬¦ï¼Œå®ƒæ˜¯ right associative çš„ï¼Œå³ plus çš„ç±»å‹å®é™…ä¸Šæ˜¯ nat -\u0026gt; (nat -\u0026gt; nat)ã€‚æˆ‘ä»¬ä½¿ç”¨ plus æ—¶éƒ½ç»™å®ƒä¼ ä¸¤ä¸ªå‚æ•°ï¼Œä½†å®é™…ä¸Šä¼ ä¸€ä¸ªä¹Ÿæ˜¯å¯ä»¥çš„ï¼ŒæŒ‰ç…§ nat -\u0026gt; (nat -\u0026gt; nat)ï¼Œplus å¯ä»¥è¢«ç†è§£ä¸º â€œè¿™æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒæ¥æ”¶ä¸€ä¸ªåŠ æ•°ï¼Œè¿”å›å¦ä¸€ä¸ªå‡½æ•°ï¼Œè¿™ä¸ªè¿”å›çš„å‡½æ•°æ¥æ”¶å¦ä¸€ä¸ªåŠ æ•°ä½œä¸ºå‚æ•°ï¼Œè¿”å›åŠ æ³•çš„ç»“æœâ€ã€‚\nDefinition plus3 := plus 3 Check plus3 : nat -\u0026gt; nat. Example test_plus3 : plus3 4 = 7. Proof. reflexivity. Qed. è¿™ç§ç»™ currying çš„å‡½æ•°ä¼ ä¸€ä¸ªå‚æ•°çš„æ‰‹æ³•ç§°ä¸º partial applicationã€‚\nExercises Exercise: 2 stars, standard, optional (mumble_grumble) d (b a 5) (* NO, the first argument of d should be a type *) d mumble (b a 5) (* YES, grumble mumble *) d bool (b a 5) (* YES, grumble bool *) e bool true (* YES, grumble bool *) e mumble (b c 0) (* YES, grumble mumble *) e bool (b c 0) (* NO, the second argument shoule be type bool *) c (* YES, mumble *) Exercise: 1 star, standard, optional (combine_checks) Check @combine : forall X Y : Type, list X -\u0026gt; list Y -\u0026gt; list (X * Y). Compute (combine [1; 2] [false; false; true; true]). (* [(1, false); (2, false)] *) Exercise: 2 stars, standard, especially useful (split) Fixpoint split {X Y : Type} (l : list (X*Y)) : (list X) * (list Y) := match l with | nil =\u0026gt; (nil, nil) | (x, y) :: l' =\u0026gt; (x :: fst (split l'), y :: snd (split l')) end. Example test_split: split [(1,false);(2,false)] = ([1;2],[false;false]). Proof. reflexivity. Qed. Exercise: 1 star, standard, optional (hd_error_poly) Definition hd_error {X : Type} (l : list X) : option X := match l with | nil =\u0026gt; None | h :: t =\u0026gt; Some h end. Check @hd_error : forall X : Type, list X -\u0026gt; option X. Example test_hd_error1 : hd_error [1;2] = Some 1. Proof. reflexivity. Qed. Example test_hd_error2 : hd_error [[1];[2]] = Some [1]. Proof. reflexivity. Qed. Exercise: 2 stars, standard (filter_even_gt7) Definition filter_even_gt7 (l : list nat) : list nat := filter (fun n =\u0026gt; (even n) \u0026amp;\u0026amp; (8 \u0026lt;=? n)) l. Example test_filter_even_gt7_1 : filter_even_gt7 [1;2;6;9;10;3;12;8] = [10;12;8]. Proof. reflexivity. Qed. Example test_filter_even_gt7_2 : filter_even_gt7 [5;2;6;19;129] = []. Proof. reflexivity. Qed. Exercise: 3 stars, standard (partition) Definition partition {X : Type} (test : X -\u0026gt; bool) (l : list X) : list X * list X := ((filter test l), (filter (fun x =\u0026gt; negb(test x)) l)). Example test_partition1: partition odd [1;2;3;4;5] = ([1;3;5], [2;4]). Proof. reflexivity. Qed. Example test_partition2: partition (fun x =\u0026gt; false) [5;9;0] = ([], [5;9;0]). Proof. reflexivity. Qed. Exercise: 3 stars, standard (map_rev) Lemma app_map : forall (X Y : Type) (f : X -\u0026gt; Y) (l1 l2 : list X), map f (l1 ++ l2) = (map f l1) ++ (map f l2). Proof. intros X Y f l1 l2. induction l1 as [| n l1' IHl1']. - reflexivity. - simpl. rewrite IHl1'. reflexivity. Qed. Theorem map_rev : forall (X Y : Type) (f : X -\u0026gt; Y) (l : list X), map f (rev l) = rev (map f l). Proof. intros X Y f l. induction l as [| n l' IHl']. - reflexivity. - simpl. rewrite \u0026lt;- IHl'. rewrite app_map. reflexivity. Qed. åœ¨è¯æ˜ä¸»è¦å®šç†ä¹‹å‰ï¼Œéœ€è¦å…ˆè¯æ˜ä¸€ä¸ªå’Œåˆ—è¡¨ append ç›¸å…³çš„å¼•ç†ã€‚\nExercise: 2 stars, standard, especially useful (flat_map) Fixpoint flat_map {X Y: Type} (f: X -\u0026gt; list Y) (l: list X) : list Y := match l with | nil =\u0026gt; nil | h :: t =\u0026gt; (f h) ++ (flat_map f t) end. Example test_flat_map1: flat_map (fun n =\u0026gt; [n;n;n]) [1;5;4] = [1; 1; 1; 5; 5; 5; 4; 4; 4]. Proof. reflexivity. Qed. Exercise: 1 star, standard, optional (fold_types_different) fold å‚æ•°ä¸­çš„å‡½æ•° f çš„ç±»å‹æ˜¯ f : X -\u0026gt; Y -\u0026gt; Yï¼ŒX å’Œ Y ä¸åŒçš„æƒ…å†µä¹Ÿæ˜¯å¾ˆæœ‰ç”¨çš„ï¼Œæ¯”å¦‚ä¼ å…¥çš„ list æ˜¯ä¸€ç³»åˆ—åŠ¨ä½œ (ä¸Šä¸‹å·¦å³)ï¼Œb æ˜¯ä¸€ä¸ªåˆå§‹ä½ç½®ï¼Œé‚£ä¹ˆä½¿ç”¨ fold å‡½æ•°å°±å¯ä»¥å¾—å‡ºåšå®Œè¿™ä¸€ç³»åˆ—ç§»åŠ¨åçš„æœ€ç»ˆä½ç½®ã€‚\nExercise: 2 stars, standard (fold_length) Theorem fold_length_correct : forall X (l : list X), fold_length l = length l. Proof. intros X l. induction l as [|n l' IHl']. - reflexivity. - simpl. rewrite \u0026lt;- IHl'. reflexivity. Qed. è¿™æ®µè¯æ˜æœ‰ä¸€ä¸ªå€¼å¾—å…³æ³¨çš„ç»†èŠ‚ï¼šåœ¨ successor case çš„æœ€åä¸€æ­¥ä¹‹å‰ï¼Œè¯æ˜çš„ goal æ˜¯\nfold_length (n :: l') = S (fold_length l') åœ¨è¿™ä¸€æ­¥ä½¿ç”¨ simpl. æ— æ³•åŒ–ç®€ï¼Œä½†æˆ‘ä»¬çŸ¥é“æ ¹æ® fold_length çš„å®šä¹‰è¿™ä¸€æ­¥æ˜¯å¯ä»¥åŒ–ç®€çš„ï¼Œäº‹å®ä¸Šä½¿ç”¨ reflexivity. å°±å¯ä»¥ç›´æ¥è§£å†³é—®é¢˜ã€‚reflexivity ä½¿ç”¨äº†æ›´åŠ  aggressive çš„åŒ–ç®€æ–¹æ³•ï¼Œæœ‰æ—¶å¡å£³æ—¶å¯ä»¥ä¸€è¯•ã€‚\nExercise: 3 stars, standard (fold_map) Definition fold_map {X Y: Type} (f: X -\u0026gt; Y) (l: list X) : list Y := fold (fun x l =\u0026gt; [f x] ++ l) l nil. Theorem fold_map_correct : forall (X Y : Type) (f : X -\u0026gt; Y) (l : list X), fold_map f l = map f l. Proof. intros X Y f l. induction l as [| n l' IHl']. - reflexivity. - simpl. rewrite \u0026lt;- IHl'. reflexivity. Qed. Exercise: 2 stars, advanced (currying) å°†ä¸€ä¸ª (X * Y) -\u0026gt; Z ç±»å‹çš„å‡½æ•°è½¬æ¢ä¸º X -\u0026gt; (Y -\u0026gt; Z) ç±»å‹çš„å‡½æ•°çš„è¿‡ç¨‹ç§°ä¸º curryingï¼Œåè¿‡æ¥ç§°ä¸º uncurryingã€‚\nDefinition prod_uncurry {X Y Z : Type} (f : X -\u0026gt; Y -\u0026gt; Z) (p : X * Y) : Z := (f (fst p))(snd p). Theorem uncurry_curry : forall (X Y Z : Type) (f : X -\u0026gt; Y -\u0026gt; Z) x y, prod_curry (prod_uncurry f) x y = f x y. Proof. intros X Y Z f x y. reflexivity. Qed. Theorem curry_uncurry : forall (X Y Z : Type) (f : (X * Y) -\u0026gt; Z) (p : X * Y), prod_uncurry (prod_curry f) p = f p. Proof. intros X Y Z f p. destruct p as [n m]. reflexivity. Qed. prod_uncurry f æ¥æ”¶äº†ä¸€ä¸ª X -\u0026gt; Y -\u0026gt; Z ç±»å‹çš„å‡½æ•°å‚æ•°ï¼Œè¿”å›äº†ä¸€ä¸ª (X * Y) -\u0026gt; Z ç±»å‹çš„å‚æ•°ã€‚prod_curry æ­£å¥½ç›¸åã€‚\næ³¨æ„ç¬¬äºŒä¸ªè¯æ˜ä¸­ï¼Œç”±äºæˆ‘ä»¬å®šä¹‰ prod_uncurry æ—¶ä½¿ç”¨äº† fst å’Œ sndï¼Œæ‰€ä»¥ä½¿ç”¨ reflexivity ä¹‹å‰è¦å…ˆç”¨ destruct æŠŠ pair p ç»™å±•å¼€ã€‚\nChurch Numerals (Advanced) Exercise: 2 stars, advanced (church_scc) Definition scc (n : cnat) : cnat := fun (X : Type) (f : X -\u0026gt; X) (x : X) =\u0026gt; n X f (f x). Example scc_1 : scc zero = one. Proof. reflexivity. Qed. Example scc_2 : scc one = two. Proof. reflexivity. Qed. Example scc_3 : scc two = three. Proof. reflexivity. Qed. Exercise: 3 stars, advanced (church_plus) Definition plus (n m : cnat) : cnat := fun (X : Type) (f : X -\u0026gt; X) (x : X) =\u0026gt; m X f (n X f x). Example plus_1 : plus zero one = one. Proof. reflexivity. Qed. Example plus_2 : plus two three = plus three two. Proof. reflexivity. Qed. Example plus_3 : plus (plus two two) three = plus one (plus three three). Proof. reflexivity. Qed. Exercise: 3 stars, advanced (church_mult) Definition mult (n m : cnat) : cnat := fun (X : Type) (f : X -\u0026gt; X) (x : X) =\u0026gt; n X (m X f) x. Example mult_1 : mult one one = one. Proof. reflexivity. Qed. Example mult_2 : mult zero (plus three three) = zero. Proof. reflexivity. Qed. Example mult_3 : mult two three = plus three three. Proof. reflexivity. Qed. Exercise: 3 stars, advanced (church_exp) Definition exp (n m : cnat) : cnat := fun (X : Type) (f : X -\u0026gt; X) (x : X) =\u0026gt; (m (X -\u0026gt; X) (n X) f) x. Example exp_1 : exp two two = plus two two. Proof. reflexivity. Qed. Example exp_2 : exp three zero = one. Proof. reflexivity. Qed. Example exp_3 : exp three two = plus (mult two (mult two two)) one. Proof. reflexivity. Qed. å…³äº church numeral å¯ä»¥å‚è€ƒ UCB CS61A çš„ä½œä¸šã€‚è¿™é‡Œé¢å¤–å†å¯¹ä¹˜æ–¹å‡½æ•°åšä¸€ç‚¹è§£è¯»ï¼Œå› ä¸ºå…¶ç»“æ„æ¯”è¾ƒå¤æ‚ã€‚\nn X çš„ç±»å‹æ˜¯ (X -\u0026gt; X) -\u0026gt; X -\u0026gt; Xï¼Œæ ¹æ® -\u0026gt; right associativity çš„æ€§è´¨ä¹Ÿå¯ä»¥çœ‹ä½œ (X -\u0026gt; X) -\u0026gt; (X -\u0026gt; X)ï¼Œå³ä¼ ç»™å®ƒä¸€ä¸ª X -\u0026gt; X çš„å‡½æ•°ï¼Œå®ƒä¼šè¿”å›å¦ä¸€ä¸ª X -\u0026gt; X çš„å‡½æ•°ã€‚è¿™é‡Œæˆ‘ä»¬å°† f ä½œä¸ºåº•å±‚å‚æ•°ä¼ ç»™ mï¼Œå¯ä»¥è®¤ä¸ºæ•´ä¸ªæ“ä½œæé«˜äº†ä¸€é˜¶ï¼Œæˆ‘ä»¬ä¸æ˜¯å°†ä¸€ä¸ª X -\u0026gt; X çš„å‡½æ•°ä½œç”¨åœ¨å…ƒç´  X ä¸Š m æ¬¡ï¼Œè€Œæ˜¯å°†ä¸€ä¸ª (X -\u0026gt; X) -\u0026gt; (X -\u0026gt; X) çš„å‡½æ•°ä½œç”¨åœ¨å‡½æ•° f ä¸Š m æ¬¡ï¼Œè¿™ä¸ªä½œç”¨å‡½æ•°çš„è¯­ä¹‰åˆæ°å¥½æ˜¯å°†æ¥æ”¶çš„å‡½æ•°å‚æ•°é‡å¤ n æ¬¡ï¼Œæ‰€ä»¥å°±å½¢æˆäº† $1 \\to n \\to n^2 \\to \\cdots \\to n^m $ çš„æ ¼å±€ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"a5be433970509f33d8605860eb69a0f4","permalink":"https://kristoff-starling.github.io/notes/booknotes/softwarefoundations/lf/poly/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/booknotes/softwarefoundations/lf/poly/","section":"notes","summary":"Polymorphism Polymorphic Lists Type Annotation Inference Type Argument Synthesis Implicit Arguments Supplying Type Arguments Explicitly Polymorphic Pairs Polymorphic Options Functions as Data Higher-Order Functions Filter Anonymous Functions Maps Fold Functions That Construct Functions Exercises Exercise: 2 stars, standard, optional (mumble_grumble) Exercise: 1 star, standard, optional (combine_checks) Exercise: 2 stars, standard, especially useful (split) Exercise: 1 star, standard, optional (hd_error_poly) Exercise: 2 stars, standard (filter_even_gt7) Exercise: 3 stars, standard (partition) Exercise: 3 stars, standard (map_rev) Exercise: 2 stars, standard, especially useful (flat_map) Exercise: 1 star, standard, optional (fold_types_different) Exercise: 2 stars, standard (fold_length) Exercise: 3 stars, standard (fold_map) Exercise: 2 stars, advanced (currying) Church Numerals (Advanced) Exercise: 2 stars, advanced (church_scc) Exercise: 3 stars, advanced (church_plus) Exercise: 3 stars, advanced (church_mult) Exercise: 3 stars, advanced (church_exp) è¿™ä¸€ç« èŠ‚æˆ‘ä»¬ä¸»è¦å…³æ³¨å‡½æ•°å¼ç¼–ç¨‹çš„ä¸¤ä¸ªåŸºæœ¬æ¦‚å¿µï¼šå¤šæ€ (polymorphism)ï¼Œå³å¯¹å‡½æ•°æ“ä½œçš„å¯¹è±¡çš„ç±»å‹è¿›è¡ŒæŠ½è±¡ï¼›é«˜é˜¶å‡½æ•°ï¼Œå³å°†å‡½æ•°æœ¬èº«çœ‹ä½œæ•°æ®ã€‚","tags":null,"title":"Polymorphism and Higher-Order Functions","type":"docs"},{"authors":null,"categories":null,"content":"æœ¬ç« æ²¡æœ‰ç‰¹åˆ«å€¼å¾—ä¸€æçš„é¢˜ç›®ï¼Œä¸»è¦å°±æ˜¯ä¸¤ç‚¹ï¼š\nå’Œæ ‘ç›¸å…³çš„æ“ä½œä½¿ç”¨é€’å½’å¯ä»¥è®©ä»£ç å˜å¾—ç®€æ´ã€‚ æ³¨æ„ data abstractionï¼Œä¸è¦è¶Šå±‚ä½¿ç”¨ APIã€‚ ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"a6eb14b27b91789a79916d4aa8e74f04","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/homework/hw04/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/homework/hw04/","section":"notes","summary":"æœ¬ç« æ²¡æœ‰ç‰¹åˆ«å€¼å¾—ä¸€æçš„é¢˜ç›®ï¼Œä¸»è¦å°±æ˜¯ä¸¤ç‚¹ï¼š\nå’Œæ ‘ç›¸å…³çš„æ“ä½œä½¿ç”¨é€’å½’å¯ä»¥è®©ä»£ç å˜å¾—ç®€æ´ã€‚ æ³¨æ„ data abstractionï¼Œä¸è¦è¶Šå±‚ä½¿ç”¨ APIã€‚ ","tags":null,"title":"UCB-CS61A Homework 04: Data Abstraction, Trees","type":"docs"},{"authors":null,"categories":null,"content":"Address Spaces Virtual memory helps realize memory isolation. The basic idea is simple: we want each process to have its own address space. The address spaces are independent.\nPaging Hardware We need a method to maintain the mappings of virtual memory to physical memory. The most common method is to maintain page tables.\nWe should be aware that page table is a hardware mechanism: all the addresses that the CPU gets are virtual addresses. The memory management unit (MMU) is responsible for translating virtual addresses to physical addresses according to the page table and we use the \u0026ldquo;pa\u0026rdquo; to access main memory. The page tables are stored somewhere in the main memory and the satp register in the CPU stores the physical address the current page table.\nIf we maintain the mappings for each virtual address, we will have $2^{64}$ entries and it\u0026rsquo;s obviously unreasonable. Actually we maintain the mappings for pages. The size of each page is 4096 bytes. i.e. The lower 12 bits of va are offset in page. We use 39 bits virtual address - 27 bits for VPN and 12 for offset, and we use 56 bits physical address.\nMaintaining $2^{27}$ entries is also a huge task. If all the processes store their page table in the memory, the physical memory will soon be used up. The real RISC-V design of page table has multi-level page tables. The 27 bits are divided into 9+9+9. We use the top 9 bits to index the page directory, and we get the physical address of the lower level page directory. Then we use the second 9 bits to index the next page directory\u0026hellip; Each page table/directory is stored in a page. Since each page is 4KB in size and each PTE is 8B in size, there are $512=2^9$ entries in a page, that\u0026rsquo;s where the \u0026ldquo;9\u0026rdquo; comes from.\nThe advantage of the page table tree is that we can leave unused page table entry empty. In that case, we don\u0026rsquo;t need to create the lower-level page tables for that entry, and it greatly saves memory space.\nThe hierarchical page tables make the translation very expensive. In modern design there\u0026rsquo;s a kind of \u0026ldquo;cache of PTE entries\u0026rdquo;, called Translation Look-aside Buffer (TLB), that helps accelerate the procedure. It stores the recently used [VA,PA] mappings and before translation you can firstly refer to to TLB to see if the mapping exists.\nIn most architectures, the TLB is transparent to the OS. i.e. OS doesn\u0026rsquo;t care about the implementation details of TLB. It just needs to be aware of the existence of TLB and when switching page tables, it needs to flush the TLB. (In RISC-V, that\u0026rsquo;s the instruction sfence.vma())\nCode: xv6 VMcode \u0026amp; Layout In xv6, physical addresses above 0x80000000 are mapped to the DRAM chips. physical addresses below 0x80000000 are used by I/O devices.\nFor simplicity, the kernel mappings are identity mappings. i.e. va=pa. Pages for kernel stacks and guard pages are exceptions: guard pages are not mapped so they\u0026rsquo;re put in the high address of virtual address space to save physical memory space. Refer to the \u0026ldquo;Xv6-book Notes\u0026rdquo; for details.\nRefer to the \u0026ldquo;Xv6 Source code Manual\u0026rdquo; for details about how the kernel sets up the kernel address space.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"01b90a1c1d1c5cad2d7f3ce2f92f3f79","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-operating-system/lectures/lec04/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-operating-system/lectures/lec04/","section":"notes","summary":"Address Spaces Virtual memory helps realize memory isolation. The basic idea is simple: we want each process to have its own address space. The address spaces are independent.\nPaging Hardware We need a method to maintain the mappings of virtual memory to physical memory.","tags":null,"title":"MIT-6.S081 Lecture 04: Page Tables","type":"docs"},{"authors":null,"categories":null,"content":"Higher-Order Functions ä»¥å‡½æ•°ä½œä¸ºå‚æ•°çš„ï¼Œæˆ–è€…ä»¥å‡½æ•°ä½œä¸ºè¿”å›å€¼çš„å‡½æ•°è¢«ç§°ä¸º higher-order functionã€‚ä¾‹å¦‚\nä»¥å‡½æ•°ä½œä¸ºå‚æ•°ï¼š\ndef cube(k): return k ** 3 def summation(n, term): \u0026quot;\u0026quot;\u0026quot;Sum the first N terms of a sequence \u0026gt;\u0026gt;\u0026gt; summation(5, cube) 225 \u0026quot;\u0026quot;\u0026quot; total, k = 0, 1; while k \u0026lt;= n: total = total + term(k) k += 1 return total ä¼ å…¥çš„ term æ˜¯ä¸€ä¸ªå‡½æ•°ã€‚\nä»¥å‡½æ•°ä¸ºè¿”å›å€¼ï¼š\ndef make_adder(n): \u0026quot;\u0026quot;\u0026quot;Return a function that takes one argument k and returns k + n \u0026gt;\u0026gt;\u0026gt; add_three = make_adder(3) \u0026gt;\u0026gt;\u0026gt; add_three(4) 7 \u0026quot;\u0026quot;\u0026quot; def adder(k): return k + n return adder è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å°†ä¸€ä¸ª call expression ä½œä¸ºä¸€ä¸ª operatorã€‚ä¾‹å¦‚\nmake_adder(1)(2) å…¶ä¸­ make_adder(1) å½¢å¼ä¸Šæ˜¯ call expressionï¼Œä½†è¿”å›ç»“æœæ˜¯ adder è¿™ä¸€ operatorï¼Œå› æ­¤æœ€ç»ˆä¼šè¿”å› 3ã€‚\nLambda Expression lambda è¡¨è¾¾å¼å®šä¹‰äº†ä¸€ä¸ªåŒ¿åå‡½æ•°ï¼Œå…¶æ ¼å¼ä¸º\nlambda \u0026lt;parameters\u0026gt;: \u0026lt;expression\u0026gt; lambda è¡¨è¾¾å¼ä½œä¸ºå‡½æ•°å‚æ•°ä¼ ç»™é«˜é˜¶å‡½æ•°æ˜¯å¾ˆæ–¹ä¾¿çš„ï¼Œä¾‹å¦‚ä¹‹å‰çš„ summation çš„ä¾‹å­ä¸­æˆ‘ä»¬å¯ä»¥å†™\nsummation(5, lambda x: x ** 3) ä»è€Œä¸éœ€è¦é¢å¤–å®šä¹‰ cube è¿™ä¸ªå‡½æ•°ã€‚\nå¸¦æœ‰æ¡ä»¶çš„ lambda è¡¨è¾¾å¼ä¸¾ä¾‹ (å–ç»å¯¹å€¼å‡½æ•°)ï¼š\nlambda x: x if x \u0026gt; 0 else -x ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"611c370cf94bd47faa35c1307ab82bb3","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/lectures/lec04/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/lectures/lec04/","section":"notes","summary":"Higher-Order Functions ä»¥å‡½æ•°ä½œä¸ºå‚æ•°çš„ï¼Œæˆ–è€…ä»¥å‡½æ•°ä½œä¸ºè¿”å›å€¼çš„å‡½æ•°è¢«ç§°ä¸º higher-order functionã€‚ä¾‹å¦‚\nä»¥å‡½æ•°ä½œä¸ºå‚æ•°ï¼š\ndef cube(k): return k ** 3 def summation(n, term): \u0026quot;\u0026quot;\u0026quot;Sum the first N terms of a sequence \u0026gt;\u0026gt;\u0026gt; summation(5, cube) 225 \u0026quot;\u0026quot;\u0026quot; total, k = 0, 1; while k \u0026lt;= n: total = total + term(k) k += 1 return total ä¼ å…¥çš„ term æ˜¯ä¸€ä¸ªå‡½æ•°ã€‚","tags":null,"title":"UCB-CS61A Lecture 04: Higher-Order Functions","type":"docs"},{"authors":null,"categories":null,"content":"C $\\rightarrow$ ASM A C program\nint main () { ... exit(0); } cannot be directly understood by a processor. It should go through a \u0026ldquo;C -\u0026gt; Asm (.s files) -\u0026gt; binary (.o files) \u0026quot; process.\nRISC-V is a reduced instruction set while x86/x86-64, which is common in personal computers, is a complex instruction set. CISC has far more instructions and more complex instruction structure than RISC. CISC has some \u0026ldquo;big\u0026rdquo; instruction that does lots of things, while in RISC we use several \u0026ldquo;small\u0026rdquo; instructions together to achieve that.\nRISC-V has a base integer instruction set, which supports basic functions. A RISC-V processor can also choose to include some extension module to support more complicated functions. For example, if a RISC-V processor includes the \u0026ldquo;F\u0026rdquo; standard extension, it can support instructions about single-precision floating-point. Extension modules make RISC-V processors to have backward compatibility. If one day, a new extension is added, and the compiler will get the message from the processor and it can use new instructions to do the compilation.\nRISC-V Registers Why s1 register is separated from other s-series registers?\nRISC-V has a compressed version of instructions which have only 16 bits. In this version, only 8 registers (x8-x15) are used. (Just a guess)\nWhen function A is calling function B, for register x:\nIf x is a caller-saved register, e.g ra, A is responsible for saving its value on the stack and B can overwrite x without saving it. If x is a callee-saved register, A don\u0026rsquo;t need to save its value before calling B and B should save x\u0026rsquo;s value on the stack before using it, and before returning, B is responsible for restore x\u0026rsquo;s value. Stack Frames return address * previous fp saved registers local variables \u0026hellip; return address fp register previous fp (pointed to *) saved registers local variables \u0026hellip; sp register Stack frames may have different sizes and contents, but the general structure is similar: every stack frame begins with the return value of this function and the value of fp register in the previous function. sp register always points to the bottom of the current stack frame while fp register always points to the top of the current stack frame. When ret instruction is executed, pseudo code below will be implemented to adjust stack pointers and PC:\npc = return address sp = fp + ENTRY_SIZE fp = previous fp To comply with the calling conventions, the assembly of a function usually consists of a \u0026ldquo;prologue\u0026rdquo;, a \u0026ldquo;body part\u0026rdquo; and a \u0026ldquo;epilogue\u0026rdquo;. In the prologue, the function modifies sp fp registers and creates the stack frame (save values of needed registers). In the epilogue, the function modifies sp fp registers and restore values of callee-saved registers.\nFor example, the assembly of a simple function sum_then_double which calls function sum_to is shown below (note: the .global sign means that the function can be fetched at any place):\n.global sum_then_double sum_then_double: addi sp, sp, -16\t# prologue sd ra, 0(sp)\tcall sum_to li t0, 2 mul a0, a0, t0 ld ra, 0(sp)\t# epilogue addi sp, sp, 16 ret ra is a caller-saved register, so before calling sum_to, sum_then_double should firstly save the return address on the stack to avoid ra being overwritten by sum_to. At last, sum_then_double restore the value of ra from the stack.\nIf we delete the prologue and epilogue:\n.global sum_then_double sum_then_double:\tcall sum_to li t0, 2\t(*) mul a0, a0, t0 ret The processor will fall into a dead loop: sum_to modifies ra\u0026rsquo;s value to the address of the next instruction. (*), so when sum_then_double execute ret, it cannot trace back to its caller and will go to li t0, 2.\nGDB Skills Use layout src layout asm layout reg to open a tui window and display source code, assembly code or register values. Use layout split to display source code and assembly code at the same time. Use focus src/asm/reg to switch between different windows.\nUse i frame to display information of the current stack frame.\nUse backtrace/bt to display previous calling functions. Furthermore, use i frame #num to specify a stack frame to print.\nUse p [variable] to print values of variables. Notice that modern compilers have compiling optimization and some variables may be optimized out.\nIf x is a pointer variable, p *x can dereference the pointer and print the value.\nUse i args to print the arguments of the current function. p *argv can print the first argument. If you want to get a complete list of arguments, use p *argv@argc.\nWatchpoints are used to monitor variables and gdb stops running as soon as the values of the expressions of the watchpoints change.\nconditional breakpoint is very powerful. For example, if you want to set a breakpoint in a for-loop but only want to trigger it when i=5, use b ... if i==5.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"6170064ea1c264a75ad25224b55b5756","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-operating-system/lectures/lec05/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-operating-system/lectures/lec05/","section":"notes","summary":"C $\\rightarrow$ ASM A C program\nint main () { ... exit(0); } cannot be directly understood by a processor. It should go through a \u0026ldquo;C -\u0026gt; Asm (.s files) -\u0026gt; binary (.","tags":null,"title":"MIT-6.S081 Lecture 05: RISC-V Calling Convention and Stack Frames","type":"docs"},{"authors":null,"categories":null,"content":" The apply Tactic The apply with Tactic The injection and discriminate Tactics Using Tactics on Hypotheses Varying the Induction Hypothesis Unfolding Definitions Using destruct on Compound Expressions Exercises (tbd) Exercise: 2 stars, standard, optional (silly_ex) Exercise: 2 stars, standard (apply_exercise1) Exercise: 3 stars, standard, optional (trans_eq_exercise) Exercise: 3 stars, standard (injection_ex3) Exercise: 1 star, standard (discriminate_ex3) Exercise: 2 stars, standard (eqb_true) Exercise: 3 stars, standard, especially useful (plus_n_n_injective) Exercise: 3 stars, standard, especially useful (gen_dep_practice) Exercise: 3 stars, standard (combine_split) Exercise: 2 stars, standard (destruct_eqn_practice) Exercise: 3 stars, standard (eqb_sym) Exercise: 3 stars, standard, optional (eqb_trans) The apply Tactic æˆ‘ä»¬åœ¨è¯æ˜è¿‡ç¨‹ä¸­ç»å¸¸é‡åˆ°æŸä¸ª goal æ­£å¥½æ˜¯å‡è®¾/æŸä¸ªä¹‹å‰å·²ç»è¯æ˜è¿‡çš„å®šç†çš„æƒ…å†µã€‚è¿™æ—¶å€™å†™ä¸€æ­¥ rewrite å†å†™ä¸€æ­¥ reflexivity æ˜¾å¾—ç•¥ä¸ºç¹çï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ apply è¿™ä¸ª tactic æ¥ä¸€æ­¥åˆ°ä½ï¼š\nTheorem silly1 : forall n m : nat, n = m -\u0026gt; n = m. Proof. intros n m eq. apply eq. Qed. å½“ apply åº”ç”¨äºä¸€ä¸ªè•´å«å¼æ—¶ï¼ŒCoq ä¼šæŠŠè•´å«å¼çš„æ¡ä»¶è®¾ç½®æˆä¸€ä¸ªæ–°çš„ goalã€‚å¦‚æœ apply åé¢è·Ÿçš„è¡¨è¾¾å¼ä¸­æœ‰å…¨ç§°é‡è¯ï¼ŒCoq å¯ä»¥è‡ªåŠ¨å°†å…¶å®ä¾‹åŒ–ï¼š\nTheorem silly2a : forall (n m : nat), (n,n) = (m,m) -\u0026gt; (forall (q r : nat), (q,q) = (r,r) -\u0026gt; [q] = [r]) -\u0026gt; [n] = [m]. Proof. intros n m eq1 eq2. apply eq2. apply eq1. Qed. åœ¨ä½¿ç”¨ apply æ—¶ï¼Œè¢« applied çš„è¡¨è¾¾å¼å¿…é¡»å’Œ goal å®Œå…¨åŒ¹é…ï¼Œæ¯”å¦‚ n = m å’Œ m = n å°±ä¸ç®—å®Œå…¨åŒ¹é…ã€‚ä½†è¿™ç§æƒ…å†µæˆ‘ä»¬å¯ä»¥é€šè¿‡ symmetry è¿™ä¸ª tactic æ¥è°ƒæ•´ç­‰å·å·¦å³çš„ä½ç½®ï¼š\nTheorem silly3 : forall n m : nat, n = m -\u0026gt; m = n. Proof. intros n m H. symmetry. apply H. Qed. The apply with Tactic è€ƒè™‘å¦‚ä¸‹ä¾‹å­ï¼šå‡è®¾æˆ‘ä»¬å·²ç»æœ‰äº†è¿™æ ·ä¸€ä¸ªå¼•ç†ï¼š\nLemma trans_eq : forall (X : Type) (n m o : X), n = m -\u0026gt; m = o -\u0026gt; n = o. Proof. intros X n m o eq1 eq2. rewrite eq1. rewrite eq2. reflexivity. Qed. ç°åœ¨æˆ‘ä»¬å¸Œæœ›è¯æ˜å¦‚ä¸‹å‘½é¢˜ï¼š\nExample trans_eq_example : forall (a b c d e f : nat), [a;b] = [c;d] -\u0026gt; [c;d] = [e;f] -\u0026gt; [a;b] = [e;f]. å¦‚æœæˆ‘ä»¬æƒ³è¦ç”¨ apply ç›´æ¥ä½¿ç”¨ä¹‹å‰çš„å¼•ç†ï¼ŒCoq ä¼šæ ¹æ® goal è‡ªåŠ¨è¿›è¡Œå®ä¾‹åŒ–ï¼Œä»è€Œå¾—åˆ° X æ˜¯ list natï¼Œn æ˜¯ [a;b]ï¼Œo æ˜¯ [e;f]ï¼Œä½† apply æ— æ³•ä» goal æ¨æ–­å‡º m åº”è¯¥å–ä»€ä¹ˆã€‚æ‰€ä»¥æˆ‘ä»¬è¦ç”¨ apply with tactic æ˜¾å¼åœ°æŠŠ m çš„å€¼æä¾›ç»™ Coqï¼š\nProof. intros a b c d e f eq1 eq2. apply trans_wq with (m:=[c;d]). apply eq1. apply eq2. Qed. äº‹å®ä¸Šæˆ‘ä»¬å¯ä»¥çœç•¥ mï¼Œå³ç›´æ¥å†™ apply trans_eq with [c;d].Coq å¯ä»¥æ™ºèƒ½åœ°åˆ¤å®šæˆ‘ä»¬æä¾›çš„å€¼æ˜¯è°çš„ã€‚\né™¤æ­¤ä¹‹å¤–ï¼ŒCoq æœ‰ä¸€ä¸ªåå« transtivity çš„ tactic ä¸“é—¨è´Ÿè´£åšè¿™é¡¹å·¥ä½œï¼Œæ‰€ä»¥å®é™…ä¸Šæˆ‘ä»¬ä¸éœ€è¦è¯æ˜ trans_eq è¿™ä¸ªå¼•ç†ï¼Œç›´æ¥ç”¨è¿™ä¸ª tacticï¼ŒåŒæ—¶æ˜¾å¼åœ°ç»™å‡ºä¸­é—´å˜é‡çš„å–å€¼å³å¯ï¼š\nProof. intros a b c d e f eq1 eq2. transtivity [c;d]. apply eq1. apply eq2. Qed. The injection and discriminate Tactics è€ƒè™‘è‡ªç„¶æ•°çš„å®šä¹‰ï¼š\nInductive nat : Type := | O | S (n : nat). ä»è¿™ä¸ªå®šä¹‰ä¸­æˆ‘ä»¬é™¤äº†çŸ¥é“è‡ªç„¶æ•°å”¯äºŒä¸¤ç§å¯èƒ½çš„å½¢å¼ï¼Œè¿˜å¯ä»¥çœ‹å‡ºä¸¤æ¡æ€§è´¨ï¼š\nconstructor S æ˜¯ injective (one-to-one) çš„ï¼Œå³è‹¥ S n = S mï¼Œåˆ™æœ‰ n = mã€‚ O å’Œ S è¿™ä¸¤ä¸ª constructor æ˜¯ disjoint çš„ï¼Œå³å¯¹äºä»»æ„ nï¼ŒO ä¸ç­‰äº S nã€‚ ä¸Šé¢ä¸¤æ¡æ€§è´¨å…¶å®å¯ä»¥æ¨å¹¿åˆ°ä»»ä½•å½’çº³å®šä¹‰çš„ç±»å‹ä¸Šï¼Œå³ä¸€ä¸ªç±»å‹ä¸­æ‰€æœ‰çš„ constructor éƒ½æ˜¯ injective çš„ï¼›ä¸åŒçš„ constructor äº§ç”Ÿçš„ value ä¸å¯èƒ½ç›¸ç­‰ã€‚\næˆ‘ä»¬å…ˆè€ƒè™‘å‰è€…ï¼Œforall n m : nat, S n = S m -\u0026gt; n = m. è¿™ä¸ªå®šç†å¯ä»¥é€šè¿‡å½’çº³æ³•è¯æ˜ï¼Œäº‹å®ä¸Šæ‰€æœ‰ constructor çš„ injectivity éƒ½å¯ä»¥é€šè¿‡ç±»ä¼¼çš„å½’çº³æ³•è¯æ˜ï¼Œå› æ­¤ Coq æä¾›äº† injection è¿™ä¸ª tacticã€‚æˆ‘ä»¬çœ‹ä¸€ä¸ªä½¿ç”¨ tactic çš„ä¾‹å­ (æ³¨æ„ï¼šinjection åªèƒ½ç”¨åœ¨ constructor çš„ injectivity ä¸Šï¼Œä¸èƒ½ç”¨äºä¸€èˆ¬çš„å•å°„ï¼)ï¼š\nTheorem injection_ex : forall (n m o : nat), [n;m] = [o;o] -\u0026gt; n = m. Proof. intros n m o H. injective H as H1 H2. rewrite H1. rewrite H2. reflexivity. Qed. injection H as H1 H2. è¡¨ç¤ºå°† H è¿™ä¸ªè¡¨è¾¾å¼ä¸­æ‰€æœ‰å¯ä»¥é€šè¿‡ injectivity å¾—åˆ°çš„ç»“è®ºå…¨éƒ¨åšæˆå½“å‰ä¸Šä¸‹æ–‡çš„ hypothesisï¼Œåˆ†åˆ«å‘½åä¸º H1 H2ã€‚è¿™é‡Œ H : [n;m] = [o;o]ï¼Œå®Œå…¨å±•å¼€å°±æ˜¯ cons n (cons m nil) = cons o (cons o nil)ã€‚æ ¹æ® injectivity æˆ‘ä»¬å¯ä»¥çŸ¥é“ n = o å’Œ cons m nil = cons o nilï¼Œå†æ¬¡åˆ©ç”¨ injectivity å¯çŸ¥ m = oï¼Œå› æ­¤ Coq çš„ injection å¯ä»¥å¸®æˆ‘ä»¬è‡ªåŠ¨åˆ†æå‡ºä¸¤æ¡ç»“è®ºã€‚\næˆ‘ä»¬å†æ¥è®¨è®ºåè€…ã€‚disjointness å‘Šè¯‰æˆ‘ä»¬å¦‚æœæˆ‘ä»¬çš„ hypothesis ä¸­å‡ºç°äº†ä¸€ä¸ªå®šä¹‰ä¸­çš„ä¸¤ä¸ªä¸åŒçš„ constructor çš„ value ç›¸ç­‰ï¼Œé‚£ä¹ˆå°±å¯ä»¥ç”±æ¡ä»¶å‡æ¨å‡ºä¸€åˆ‡çœŸï¼Œè¿™ä¹Ÿè¢«ç§°ä¸º principle of explosionã€‚åœ¨ Coq ä¸­æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ discrimate è¿™ä¸ª tactic æ¥å®Œæˆè¿™ä»¶äº‹ï¼Œåªè¦æˆ‘ä»¬æŒ‡å®šä¸€ä¸ªç¡®å®šæ˜¯é”™è¯¯çš„å‡è®¾ (ä¸ä¸€å®šæ˜¯ disjointness çš„è¿™ç§ï¼Œä»»ä½•é”™è¯¯çš„è¡¨è¾¾å¼éƒ½å¯ä»¥)ï¼Œå°±å¯ä»¥ç›´æ¥è¯å®Œå½“å‰ç»“è®ºã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š\nTheorem discriminate_ex : forall (n : nat), S n = O -\u0026gt; 2 + 2 = 5. Proof. intros n contra. discriminate contra. Qed. injectivity å‘Šè¯‰æˆ‘ä»¬ S n = S m -\u0026gt; n = mã€‚è¿™ä»¶äº‹æƒ…åè¿‡æ¥ä¹Ÿæ˜¯æˆç«‹çš„ï¼Œå³å¦‚ä¸‹å®šç†ï¼š\nTheorem f_equal : forall (A B : Type) (f : A -\u0026gt; B) (x y : A), x = y -\u0026gt; f x = f y. è¯¥å®šç†ç”¨ rewrite å¾ˆå¥½è¯ã€‚äº‹å®ä¸Š Coq ä¸ºæˆ‘ä»¬æä¾›äº† f_equal è¿™ä¸ª tacticï¼Œæˆ‘ä»¬ä¸éœ€è¦è¯æ˜è¯¥å®šç†å°±å¯ä»¥ä½¿ç”¨è¿™ä¸ªç»“è®ºï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š\nTheorem eq_implies_succ_equal : forall (n m : nat), n = m -\u0026gt; S n = S m. Proof. intros n m H. f_equal. apply H. Qed. å¦‚æœå½“å‰çš„ goal å½¢å¦‚ f a1 a2 ... an = g b1 b2 ... bnï¼Œåˆ™ f_goal ä¼šè‡ªåŠ¨å°†å…¶è½¬åŒ–ä¸º f = g a1 = b1 \u0026hellip; an = bn è¿™äº› subgoalï¼Œå¦‚æœå…¶ä¸­æœ‰ trivial çš„ (æ¯”å¦‚ä¸¤ä¸ªå‡½æ•°ç›¸åŒï¼Œå¯¹åº”ä½ç½®çš„ä¸¤ä¸ªå‚æ•°ç›¸åŒ) f_equal è¿˜ä¼šè‡ªåŠ¨è¿‡æ»¤åˆ°å®ƒä»¬ã€‚\nUsing Tactics on Hypotheses é»˜è®¤æƒ…å†µä¸‹ï¼Œå¤§éƒ¨åˆ†çš„ tactic éƒ½æ˜¯åœ¨ä¿æŒ context ä¸å˜çš„æƒ…å†µä¸‹é’ˆå¯¹ goal è¿›è¡Œçš„ã€‚äº‹å®ä¸Š Coq æä¾›äº† \u0026ldquo;in\u0026rdquo; çš„è¯­æ³•ï¼Œå¯ä»¥è®© tactic ä½œç”¨åœ¨ context ä¸­çš„ hypothesis ä¸Šï¼Œä¾‹å¦‚ simplï¼š\nTheorem S_inj : forall (n m : nat) (b : bool), ((S n) =? (S m)) = b -\u0026gt; (n =? m) = b. Proof. intros n m b H. simpl in H. apply H. Qed. å†æ¯”å¦‚ symmetry å’Œ applyï¼š\nTheorem silly4 : forall (n m p q : nat), (n = m -\u0026gt; p = q) -\u0026gt; m = n -\u0026gt; q = p. Proof. intros n m p q EQ H. symmetry in H. apply EQ in H. symmetry in H. apply H. Qed. å€¼å¾—æ³¨æ„çš„æ˜¯ apply å’Œ apply in çš„åŒºåˆ«ï¼š\napply in é‡‡ç”¨çš„æ˜¯ forward reasoningï¼Œå³ apply L in H çš„åŠŸèƒ½æ˜¯ï¼šå¦‚æœ L æ˜¯è•´å«å¼ X -\u0026gt; Yï¼ŒH æ˜¯ Xï¼Œåˆ™æˆ‘ä»¬å¯ä»¥è½¬è€Œå»è¯æ˜ Yã€‚ apply é‡‡ç”¨çš„æ˜¯ backward reasoningï¼Œå³ apply H çš„åŠŸèƒ½æ˜¯ï¼šå¦‚æœ H æ˜¯è•´å«å¼ X -\u0026gt; Yï¼Œå½“å‰çš„ç»“è®ºæ˜¯ Yï¼Œåˆ™æˆ‘ä»¬åªè¦èƒ½è¯æ˜ X å°±è¶³å·²å®Œæˆè¯æ˜ã€‚ äººç±»çš„ informal proof å€¾å‘äº forward reasoningï¼Œä½† Coq ç­‰è¯æ˜å·¥å…·é€šå¸¸æ›´å¤šé‡‡ç”¨ backward reasoningã€‚\nVarying the Induction Hypothesis è¯¥ç« èŠ‚ä»‹ç»äº†ä¸¤æ®µå…·æœ‰ä¸€å®šæŠ€å·§æ€§çš„è¯æ˜ã€‚æœ‰æ—¶å€™ï¼Œä¸ç®¡ä¸‰ä¸ƒäºŒåä¸€æŠŠæ‰€æœ‰çš„å˜é‡å’Œå‡è®¾å…¨éƒ¨éƒ½ intros äº†åè€Œä¼šä½¿è¯æ˜å¡ä½ã€‚è€ƒè™‘å¦‚ä¸‹è¯æ˜ double() æ˜¯å•å°„çš„å®šç†ï¼š\nTheorem double_injective : forall n m, double n = double m -\u0026gt; n = m. å¦‚æœæˆ‘ä»¬å…ˆæŠŠ n m éƒ½ intros äº†å†å¯¹ n è¿›è¡Œå½’çº³ï¼Œåˆ™ä¼šå¾—åˆ°\nProof. intros n m. induction n as [| n' IHn']. - (* n = 0 *) simpl. intros eq. destruct m as [| m'] eqn:E. + reflexivity. + discriminate eq. - (* n = S n' *) intros eq. destruct m as [| m'] eqn:E. + discriminate eq. + apply f_equal. Abort. (æ³¨ï¼šä¸¤æ¬¡ discriminate çš„ç­‰å¼ eq å‡ä¸º double (S n') = double 0ã€‚è¿™é‡Œå¯ä»¥æ ¹æ® disjointment ç›´æ¥ pass çš„åŸå› æ˜¯æˆ‘ä»¬å¯ä»¥æ ¹æ® double çš„å®šä¹‰å°†å¼å­åŒ–ç®€ä¸º S (S (double n')) = 0ï¼Œåœ¨è‡ªç„¶æ•°çš„ä¸¤ä¸ª constructor ä¸‹è§¦å‘ disjointmentã€‚)\nåœ¨ successor case ä¸­ m = S m' çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éœ€è¦è¯æ˜ n' = m'ï¼Œè€Œæˆ‘ä»¬çš„å½’çº³å‡è®¾æ˜¯ double n' = double (S m') -\u0026gt; n' = S m'ï¼Œè¿™å’Œæˆ‘ä»¬è¦è¯æ˜çš„ç»“è®ºæ²¡ä»€ä¹ˆè”ç³»ï¼Œä»è€Œè¯æ˜å¡ä½ã€‚å‡ºç°è¿™ä¸ªé—®é¢˜çš„åŸå› æ˜¯ï¼šåœ¨å½’çº³å‡è®¾å’Œå½’çº³ç›®æ ‡çš„å¼å­ä¸­æˆ‘ä»¬çš„ m éœ€è¦å–åˆ°ä¸åŒçš„å€¼ï¼Œä½†æˆ‘ä»¬åœ¨å¼€å§‹å½’çº³ä¹‹å‰è¿‡æ—©åœ° intros m å¯¼è‡´ m åªèƒ½æ˜¯ä¸€ä¸ªå…·ä½“çš„å€¼ã€‚æ­£ç¡®çš„è¯æ˜è¿‡ç¨‹åº”å½“å…ˆå¯¹ n è¿›è¡Œå½’çº³ï¼Œä¿è¯å½’çº³å‡è®¾ä¸­æ˜¯ forall m è€Œä¸æ˜¯ä¸€ä¸ªå…·ä½“çš„ mï¼Œè¿™æ ·åœ¨ successor case æ—¶æˆ‘ä»¬å°±å¯ä»¥è®©å½’çº³å‡è®¾ä¸­çš„ m å®ä¾‹åŒ–ä¸ºå…·ä½“éœ€è¦çš„å˜é‡ï¼Œä»è€Œå®Œæˆè¯æ˜ã€‚\nTheorem double_injective : forall n m, double n = double m -\u0026gt; n = m. Proof. intros n. induction n as [| n' IHn']. - (* n = 0 *) simpl. intros m eq. destruct m as [| m'] eqn:E. + reflexivity. + discriminate eq. - intros m eq. destruct m as [| m'] eqn:E. + discriminate eq. + apply f_equal. apply IHn' (* IHn'ä¸­æ˜¯forall mï¼Œapplyï¼Œå¯ä»¥å®Œæˆå…³é”®çš„å®ä¾‹åŒ– *) simpl in eq. injection eq as goal. apply goal. Qed. åˆšæ‰çš„ä¾‹å­å±•ç¤ºäº† fewer intros çš„æŠ€å·§ï¼Œä½†æœ‰çš„æ—¶å€™æˆ‘ä»¬å‘ç°æˆ‘ä»¬ä¸å¾—ä¸å¯¹å…¨ç§°é‡è¯ä¸­çš„å˜é‡é¡ºåºè¿›è¡Œè°ƒæ¢ã€‚æ¯”å¦‚åˆšæ‰çš„å®šç†ï¼Œå¦‚æœæˆ‘ä»¬æƒ³å¯¹ m è¿›è¡Œå½’çº³å°±ä¼šé‡åˆ°ä¸€äº›å›°éš¾ï¼š\nProof. intros m. induction m as [| m' IHm']. æˆ‘ä»¬ä¼šå‘ç° intros m. æ—¶å˜é‡ n ä¹Ÿè¢«å®ä¾‹åŒ–äº†ï¼Œå› ä¸ºåœ¨ forall ä¸­ n å‡ºç°åœ¨ m å‰é¢ã€‚åœ¨ä¸ä¿®æ”¹å®šç†æè¿°çš„å‰æä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ generalize dependent è¿™ä¸ª tactic æ¥å°†æŸä¸ªå˜é‡â€œå»å®ä¾‹åŒ–â€ï¼š\nProof. intros n m. generalize dependent n. ... æ‰§è¡Œå®Œ generalize dependent n åï¼Œå˜é‡ n åˆä¼šå›åˆ° forall ä¸­ã€‚\nUnfolding Definitions æœ‰çš„æ—¶å€™æˆ‘ä»¬éœ€è¦æ‰‹åŠ¨å°†æŸä¸ªå‡½æ•°çš„å®šä¹‰å±•å¼€ï¼Œä»è€Œå°†è¯æ˜æ¨è¿›ä¸‹å»ã€‚æ¯”å¦‚æˆ‘ä»¬å®šä¹‰äº†å¹³æ–¹å‡½æ•°ï¼š\nDefinition square n := n * n. å¹¶ä¸”è¯•å›¾è¯æ˜å®šç†\nLemma square_mult : forall n m, square (n * m) = (square n) * (square m) Proof. intros n m. simpl. (* get stuck! *) simpl. å¹¶ä¸èƒ½å¸®åŠ©æˆ‘ä»¬åŒ–ç®€ã€‚è¿™æ—¶å€™æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ unfold square æŠŠå®šä¹‰å±•å¼€ï¼Œè¿™æ ·å†ä½¿ç”¨ä¹˜æ³•çš„äº¤æ¢å¾‹ã€ç»“åˆå¾‹å°±å¯ä»¥å®Œæˆè¯æ˜ã€‚\nè¿™é‡Œæˆ‘ä»¬æŠŠ unfold å’Œ simpl reflexivity çš„å®šä¹‰å±•å¼€åŠŸèƒ½åšä¸€ä¸ªå¯¹æ¯”ã€‚simpl å’Œ reflexivity ä¹Ÿæœ‰ä¸€å®šçš„å®šä¹‰å±•å¼€åŠŸèƒ½ï¼Œä½†ä¸æ˜¯å¾ˆå¼ºã€‚ä¾‹å¦‚ï¼š\nDefinition foo (x : nat) := 5. Fact silly_fact_1 : forall m, foo m + 1 = foo (m + 1) + 1. Proof. intros m. reflexivity. Qed. reflexivity å¯ä»¥å¸®æˆ‘ä»¬è‡ªåŠ¨æŠŠ foo è¿™ä¸ªå¸¸å€¼å‡½æ•°å±•å¼€ï¼Œç›´æ¥å®Œæˆè¯æ˜ã€‚ä½†å¦‚æœå‡½æ•°çš„ç»“æ„ç¨å¾®å¤æ‚ä¸€ç‚¹ simpl å’Œ reflexivity å°±æ— èƒ½ä¸ºåŠ›äº†ï¼š\nDefinition bar x := match x with | O =\u0026gt; 5 | S _ =\u0026gt; 5 end. Fact silly_fact_2_FAILED : forall m, bar m + 1 = bar (m + 1) + 1. Proof. intros m. simpl. Abort. è™½ç„¶æˆ‘ä»¬äººçœ¼å¯ä»¥çœ‹å‡ºæ¥ä¸ç®¡è‡ªç„¶æ•° x èµ°å“ªä¸ªåˆ†æ”¯ bar x çš„ç»“æœéƒ½æ˜¯ 5ï¼Œä½† Coq æ²¡æœ‰è¿™ä¹ˆå¼ºçš„åˆ†æèƒ½åŠ›ã€‚è¿™ç§æƒ…å†µæˆ‘ä»¬åªèƒ½è€è€å®å®å¯¹ç€ x åš destructã€‚\nUsing destruct on Compound Expressions åœ¨ Coq ä¸­ï¼Œdestruct çš„å¯¹è±¡å¯ä»¥æ˜¯ä»»æ„çš„è¡¨è¾¾å¼ï¼Œåªè¦è¯¥è¡¨è¾¾å¼çš„ç»“æœæ˜¯å½’çº³å®šä¹‰çš„ï¼Œdestruct å°±ä¼šå¯¹å…¶æ¯ç§ constructor åˆ†ç±»è®¨è®ºã€‚\nå¦å¤–å€¼å¾—æ³¨æ„çš„ä¸€ç‚¹æ˜¯ï¼šå½“æˆ‘ä»¬å¯¹ä¸€ä¸ªè¡¨è¾¾å¼åš destruct æ—¶ï¼Œé€šå¸¸ eqn æ˜¯å¿…ä¸å¯å°‘çš„ï¼Œå› ä¸ºè¡¨è¾¾å¼çš„å–å€¼åº”å½“ä½œä¸º context çš„ä¸€éƒ¨åˆ†å‚ä¸è¯æ˜ï¼Œå¦‚æœåªæ˜¯è®© Coq åšçº¯ä»£å…¥ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šä¸¢å¤±å¿…è¦çš„ä¿¡æ¯ã€‚\nExercises (tbd) Exercise: 2 stars, standard, optional (silly_ex) Theorem silly_ex : forall p, (forall n, even n = true -\u0026gt; even (S n) = false) -\u0026gt; (forall n, even n = false -\u0026gt; odd n = true) -\u0026gt; even p = true -\u0026gt; odd (S p) = true. Proof. intros p H1 H2 H3. apply H2. apply H1. apply H3. Qed. Exercise: 2 stars, standard (apply_exercise1) Theorem rev_exercise1 : forall (l l' : list nat), l = rev l' -\u0026gt; l' = rev l. Proof. intros l l' H. replace l' with (rev (rev l')). - rewrite H. reflexivity. - apply rev_involutive. Qed. Exercise: 3 stars, standard, optional (trans_eq_exercise) Example trans_eq_exercise : forall (n m o p : nat), m = (minustwo o) -\u0026gt; (n + p) = m -\u0026gt; (n + p) = (minustwo o). Proof. intros n m o p eq1 eq2. transitivity m. apply eq2. apply eq1. Qed. Exercise: 3 stars, standard (injection_ex3) Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X), x :: y :: l = z :: j -\u0026gt; j = z :: l -\u0026gt; x = y. Proof. intros X x y z l j H1. injection H1 as eq1. rewrite \u0026lt;- H. intros H2. injection H2 as eq2. rewrite eq1. rewrite eq2. reflexivity. Qed. Exercise: 1 star, standard (discriminate_ex3) Example discriminate_ex3 : forall (X : Type) (x y z : X) (l j : list X), x :: y :: l = [] -\u0026gt; x = z. Proof. intros X x y z l eq1 eq2. discriminate eq2. Qed. (æ³¨ï¼šä¸çŸ¥ä¸ºä½• Coq è‡ªåŠ¨æŠŠ goal ä¿®æ”¹ä¸ºäº† list X -\u0026gt; ... -\u0026gt; x = zï¼Œå¯¼è‡´å¤šäº†ä¸€ä¸ªæ¡ä»¶ã€‚)\nExercise: 2 stars, standard (eqb_true) Theorem eqb_true : forall n m, n =? m = true -\u0026gt; n = m. Proof. intros n. induction n as [| n' IHn']. - destruct m as [| m'] eqn:E. + reflexivity. + discriminate. - destruct m as [| m'] eqn:E. + discriminate. + intros H. apply IHn' in H. apply f_equal. apply H. Qed. Exercise: 3 stars, standard, especially useful (plus_n_n_injective) Theorem plus_n_n_injective : forall n m, n + n = m + m -\u0026gt; n = m. Proof. intros n. induction n as [| n' IHn']. - destruct m as [| m'] eqn:E. + reflexivity. + discriminate. - destruct m as [| m'] eqn:E. + discriminate. + intros H. simpl in H. injection H as H'. rewrite \u0026lt;- plus_n_Sm in H'. rewrite \u0026lt;- plus_n_Sm in H'. injection H' as H''. apply IHn' in H''. apply f_equal. apply H''. Qed. Exercise: 3 stars, standard, especially useful (gen_dep_practice) Theorem nth_error_after_last: forall (n : nat) (X : Type) (l : list X), length l = n -\u0026gt; nth_error l n = None. Proof. intros n X l. generalize dependent n. induction l as [| h l' IHl']. - reflexivity. - destruct n as [| n'] eqn:E. + discriminate. + simpl. intros H. apply IHl'. injection H as goal. apply goal. Qed. Exercise: 3 stars, standard (combine_split) Theorem combine_split : forall X Y (l : list (X * Y)) l1 l2, split l = (l1, l2) -\u0026gt; combine l1 l2 = l. Proof. intros X Y l. induction l as [| (x, y) l' IHl']. - simpl. intros l1 l2 H. injection H as H1 H2. rewrite \u0026lt;- H1. rewrite \u0026lt;- H2. reflexivity. - intros l1 l2 H. simpl in H. destruct (split l') as [lx ly]. destruct l1 as [| h1 l1']. + discriminate. + destruct l2 as [| h2 l2']. * discriminate. * simpl. injection H as eq1 eq2 eq3 eq4. rewrite eq1. rewrite eq3. apply f_equal. apply IHl'. rewrite eq2. rewrite eq4. reflexivity. Qed. Exercise: 2 stars, standard (destruct_eqn_practice) Theorem bool_fn_applied_thrice : forall (f : bool -\u0026gt; bool) (b : bool), f (f (f b)) = f b. Proof. intros f b. destruct b. - destruct (f true) eqn:ft. + rewrite ft. apply ft. + destruct (f false) eqn:ff. * apply ft. * apply ff. - destruct (f false) eqn:ff. + destruct (f true) eqn:ft. * apply ft. * apply ff. + rewrite ff. apply ff. Qed. Exercise: 3 stars, standard (eqb_sym) Theorem eqb_sym : forall (n m : nat), (n =? m) = (m =? n). Proof. intros n. induction n as [| n' IHn']. - destruct m as [| m']. + reflexivity. + reflexivity. - intros m. destruct m as [| m']. + reflexivity. + simpl. apply IHn'. Qed. Exercise: 3 stars, standard, optional (eqb_trans) Theorem eqb_trans : forall n m p, n =? m = true -\u0026gt; m =? p = true -\u0026gt; n =? p = true. Proof. intros n m p H1 H2. generalize dependent n. generalize dependent p. induction m as [| m' IHm']. - destruct n as [| n']. + destruct p as [| p']. * reflexivity. * discriminate. + discriminate. - intros n Hn p Hp. destruct n as [| n']. + discriminate. + destruct p as [| p']. * discriminate. * simpl. rewrite eqb_sym. simpl in Hn. rewrite eqb_sym in Hn. simpl in Hp. rewrite eqb_sym in Hp. apply IHm'. apply Hp. apply Hn. Qed. ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"c41f037f89413dd46e66345f47fbf3b6","permalink":"https://kristoff-starling.github.io/notes/booknotes/softwarefoundations/lf/tactics/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/booknotes/softwarefoundations/lf/tactics/","section":"notes","summary":"The apply Tactic The apply with Tactic The injection and discriminate Tactics Using Tactics on Hypotheses Varying the Induction Hypothesis Unfolding Definitions Using destruct on Compound Expressions Exercises (tbd) Exercise: 2 stars, standard, optional (silly_ex) Exercise: 2 stars, standard (apply_exercise1) Exercise: 3 stars, standard, optional (trans_eq_exercise) Exercise: 3 stars, standard (injection_ex3) Exercise: 1 star, standard (discriminate_ex3) Exercise: 2 stars, standard (eqb_true) Exercise: 3 stars, standard, especially useful (plus_n_n_injective) Exercise: 3 stars, standard, especially useful (gen_dep_practice) Exercise: 3 stars, standard (combine_split) Exercise: 2 stars, standard (destruct_eqn_practice) Exercise: 3 stars, standard (eqb_sym) Exercise: 3 stars, standard, optional (eqb_trans) The apply Tactic æˆ‘ä»¬åœ¨è¯æ˜è¿‡ç¨‹ä¸­ç»å¸¸é‡åˆ°æŸä¸ª goal æ­£å¥½æ˜¯å‡è®¾/æŸä¸ªä¹‹å‰å·²ç»è¯æ˜è¿‡çš„å®šç†çš„æƒ…å†µã€‚è¿™æ—¶å€™å†™ä¸€æ­¥ rewrite å†å†™ä¸€æ­¥ reflexivity æ˜¾å¾—ç•¥ä¸ºç¹çï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ apply è¿™ä¸ª tactic æ¥ä¸€æ­¥åˆ°ä½ï¼š","tags":null,"title":"More Basic Tactics","type":"docs"},{"authors":null,"categories":null,"content":"Environments åˆšå¼€å§‹æœ‰ä¸€ä¸ª global frameï¼Œæ¯å‘ç”Ÿä¸€æ¬¡å‡½æ•°è°ƒç”¨ï¼Œå°±ä¼šéšä¹‹ç”Ÿæˆä¸€ä¸ª local frameã€‚ æ¯ä¸ªç”¨æˆ·å®šä¹‰çš„ function éƒ½æœ‰ä¸€ä¸ª parent frameã€‚ä¸€ä¸ªå‡½æ•°çš„ parent æŒ‡çš„æ˜¯å‡½æ•°å®šä¹‰æ‰€åœ¨çš„ frameã€‚ æ¯ä¸ª frame ä¹Ÿæœ‰ä¸€ä¸ª parent frameï¼Œä¸€ä¸ª frame çš„ parent æŒ‡çš„æ˜¯ç”Ÿæˆè¿™ä¸ª frame çš„å‡½æ•°çš„ parentã€‚ environment æŒ‡çš„æ˜¯ä¸€ä¸² frame åºåˆ—ã€‚ Environment Diagram å½“ä¸€ä¸ªå‡½æ•°è¢«å®šä¹‰æ—¶ï¼š\nåˆ›å»ºä¸€ä¸ª function valueï¼šfunc \u0026lt;name\u0026gt;(\u0026lt;formal parameters\u0026gt;) [parent=\u0026lt;label\u0026gt;]ï¼Œè¿™é‡Œçš„ parent å°±æ˜¯å½“å‰çš„ frameã€‚ å½“å‰ frame ä¸­çš„ \u0026lt;name\u0026gt; æŒ‡å‘åˆ›å»ºçš„ function valueã€‚ å½“ä¸€ä¸ªå‡½æ•°è¢«è°ƒç”¨æ—¶ï¼š\næ·»åŠ ä¸€ä¸ª local frameï¼Œframe çš„åå­—æ˜¯è¢«è°ƒç”¨çš„å‡½æ•°çš„åå­—ï¼Œframe çš„ parent æ˜¯è¢«è°ƒç”¨çš„å‡½æ•°çš„ parentã€‚ \u0026lt;formal parameters\u0026gt; æŒ‡å‘ä¼ å…¥çš„å‚æ•°ã€‚ Self-Reference é«˜é˜¶å‡½æ•°å¯ä»¥æ‹¿è‡ªå·±ä½œä¸ºè¿”å›å€¼ï¼Œä¾‹å¦‚\ndef print_sums(n): print(n) def next_sum(k): return print_sums(n + k) return next_sum è°ƒç”¨ print_sums(1)(3)(5) åä¼šæ‰“å°å‡º 1\\n 4\\n 9\\nï¼Œä¸”æœ€åçš„è¿”å›å€¼ä»ç„¶æ˜¯ä¸€ä¸ª next_sum() å‡½æ•°ã€‚\nFunction Currying Currying æŒ‡çš„æ˜¯å°†æ¥æ”¶å¤šä¸ªå‚æ•°çš„å‡½æ•°è½¬åŒ–ä¸ºåªæ¥æ”¶ä¸€ä¸ªå‚æ•°çš„é«˜é˜¶å‡½æ•°ã€‚ä¾‹å¦‚æˆ‘ä»¬å¯ä»¥å®ç°ä¸€ä¸ªè¿™æ ·çš„å‡½æ•°ï¼š\ndef curry(f): def g(x): def h(y): return f(x, y) return h return g æˆ–è€…ç”¨ lambda è¡¨è¾¾å¼ï¼š\ncurry = lambda f: lambda x: lambda y: f(x, y) è°ƒç”¨ curry(add)(2, 3) å’Œè°ƒç”¨ add(2, 3) çš„æ•ˆæœä¸€æ ·ã€‚åˆ©ç”¨ Currying åˆ›å»ºä¸€äº›ä¸­é—´çŠ¶æ€çš„è¾…åŠ©å‡½æ•°å¯ä»¥å‡å°‘é‡å¤ä¼ å‚ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"61d134ff6d8902cedf634b4151a14ce0","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/lectures/lec05/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/lectures/lec05/","section":"notes","summary":"Environments åˆšå¼€å§‹æœ‰ä¸€ä¸ª global frameï¼Œæ¯å‘ç”Ÿä¸€æ¬¡å‡½æ•°è°ƒç”¨ï¼Œå°±ä¼šéšä¹‹ç”Ÿæˆä¸€ä¸ª local frameã€‚ æ¯ä¸ªç”¨æˆ·å®šä¹‰çš„ function éƒ½æœ‰ä¸€ä¸ª parent frameã€‚ä¸€ä¸ªå‡½æ•°çš„ parent æŒ‡çš„æ˜¯å‡½æ•°å®šä¹‰æ‰€åœ¨çš„ frameã€‚ æ¯ä¸ª frame ä¹Ÿæœ‰ä¸€ä¸ª parent frameï¼Œä¸€ä¸ª frame çš„ parent æŒ‡çš„æ˜¯ç”Ÿæˆè¿™ä¸ª frame çš„å‡½æ•°çš„ parentã€‚ environment æŒ‡çš„æ˜¯ä¸€ä¸² frame åºåˆ—ã€‚ Environment Diagram å½“ä¸€ä¸ªå‡½æ•°è¢«å®šä¹‰æ—¶ï¼š","tags":null,"title":"UCB-CS61A Lecture 05: Environments","type":"docs"},{"authors":null,"categories":null,"content":"æ²¡æœ‰å€¼çš„ç‰¹åˆ«æ³¨æ„çš„é¢˜ç›®ã€‚é€’å½’åœ°ä½¿ç”¨ generator function æ˜¯ä¸€ä¸ªéš¾ç‚¹ï¼Œä½†åªè¦æŒæ¡äº†æ™®é€šå°±å¯ä»¥è¿›è¡Œç±»æ¯”ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"5122a7ba78d32e8de9438cc725d27a34","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/homework/hw05/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/homework/hw05/","section":"notes","summary":"æ²¡æœ‰å€¼çš„ç‰¹åˆ«æ³¨æ„çš„é¢˜ç›®ã€‚é€’å½’åœ°ä½¿ç”¨ generator function æ˜¯ä¸€ä¸ªéš¾ç‚¹ï¼Œä½†åªè¦æŒæ¡äº†æ™®é€šå°±å¯ä»¥è¿›è¡Œç±»æ¯”ã€‚","tags":null,"title":"UCB-CS61A Homework 05: Iterators and Generators","type":"docs"},{"authors":null,"categories":null,"content":"Introduction When going into traps, we need to carefully change the hardware state so that isolation will not be broken. The hardware state of RISC-V machine includes:\n32 general registers\nWe keep a copy of general registers because we want to resume the user code later transparently, particularly when it\u0026rsquo;s a unexpected device interrupt.\nPC\nMode: we need to switch to supervisor mode.\nSupervisor mode has the following privileges:\nread/write control registers use PTEs without PTE_U sign. Page table (satp): page table currently points to the user page table, which only contains user\u0026rsquo;s code and data. To run kernel code, we need to switch to kernel page table.\nstvec\nsepc\nsscratch\nThere are some high-level principles of trap design:\nWe cannot count on anything in the user space. We can\u0026rsquo;t assume anything about the registers since they are likely to contain malicious values. In xv6, the trap handler just saves them. We want to be transparent to the user code. The high-level procedure of a system call Shell $\\rightarrow$ write() $\\overset{ecall}{\\rightarrow}$ uservec (asm) $\\rightarrow$ usertrap() $\\rightarrow$ syscall() $\\rightarrow$ sys_write() $\\rightarrow$ syscall() $\\rightarrow$ usertrapret() $\\rightarrow$ userret (asm) $\\rightarrow$ the next instruction of ecall.\nSystem call is quite expensive. So can we return some address mappings instead of a file descriptor in open() , so that the user program can directly write to the memory without using system calls?\nYes. Modern operating systems support this mechanism and it\u0026rsquo;s called memory mapped file access. It makes read/write much faster compared with the file descriptor method.\nCode: write() system call Preliminaries The shell program uses write() system call to print a $ to the console.\nstatic void putc(int fd, char c) { write(fd, \u0026amp;c, 1); } write() function is defined in usys.asm\nwrite: li a7, SYS_write ecall ret It loads the system call number \u0026ldquo;SYS_write\u0026rdquo; into register a7. a0 a1 a2 stores the arguments of the system call. In GDB, we can use x/2c $a1 to print the argument strings.\nGDB Tips\nUse b *addr to set a breakpoint at a specific address. This method is useful when we want to set breakpoints at particular instructions.\nBefore switching to kernel, we are using the user page table. We cannot print the page table in GDB, but luckily, QEMU provides functions to print the current page table. Type \u0026lt;c-a\u0026gt; c to get into the QEMU monitor, and type info mem to print the page table:\nvaddr paddr size attr ---------------- ---------------- ---------------- ------- 0000000000000000 0000000087f60000 0000000000001000 rwxu-a- 0000000000001000 0000000087f5d000 0000000000001000 rwxu-a- 0000000000002000 0000000087f5c000 0000000000001000 rwx---- 0000000000003000 0000000087f5b000 0000000000001000 rwxu-ad 0000003fffffe000 0000000087f6f000 0000000000001000 rw---ad 0000003ffffff000 0000000080007000 0000000000001000 r-x--a- The last column shows the privilege flags of PTEs. The first and second PTEs are code and data page of the shell program. The third page, which doesn\u0026rsquo;t have the PTE_U flag, is the guard page below the stack page. The fourth page is the stack page. The last two pages, which have high virtual addresses, are the trap frame and the trampoline page. Those pages also don\u0026rsquo;t have PTE_U flag and can only be accessed by the kernel.\nPTE\u0026rsquo;s PTE_A \u0026amp; PTE_D flags\nxv6 doesn\u0026rsquo;t use these flags. These flags are used for page exchanges when there\u0026rsquo;s a page fault and the physical memory pages are used out.\nTrampoline We\u0026rsquo;re now ready for executing ecall. After executing ecall, our PC register goes to the trampoline page: 0x3fffff000. ecall doesn\u0026rsquo;t switch the page table, which means that the trampoline page must be mapped in the user page table. Although user page table contains this mapping, the corresponding PTE doesn\u0026rsquo;t have PTE_U flag so this page is protected against user code.\necall actually does 3 things:\nSwitch from user mode to supervisor mode. Save the value of PC into sepc. Jump to the address held in stvec register. ecall only does the minimum things. Some hardware does more when triggering a system call: they save the registers, switch the page table and set the stack pointer. RISC-V doesn\u0026rsquo;t choose to include those parts into the hardware because it wants the software to achieve the maximum flexibility. For example:\nIn some system calls the kernel can finish jobs without the help of kernel page table. Also, some operating systems combine the user page table and kernel page table together, which means they don\u0026rsquo;t need to change the page table during system calls. According to the specific function, some system calls won\u0026rsquo;t use all the general registers and some registers\u0026rsquo; values don\u0026rsquo;t need to be saved. Some easy system call may not require a kernel stack. Stack switching is not necessary. Although xv6 doesn\u0026rsquo;t utilize those freedom, modern operating systems care a lot about the performance. There are a lot of sophisticated, clever schemes that make full use of the flexibility and achieve better efficiency.\nIf we check the general registers\u0026rsquo; values, we\u0026rsquo;ll find that they are the same as those in the user space. Currently we cannot modify any register, otherwise the user data would be damaged. We should firstly store them somewhere and restore them before returning.\nSome hardware may switch to the kernel page table and store the 32 values somewhere in a physical page. But now we even don\u0026rsquo;t know the address of the kernel page table! xv6\u0026rsquo;s solution for saving registers includes two parts:\nUse a trap frame. User page table contains the mapping of this per-process trap frame. The trap frame contains 32 slots for register values, and some other useful values such as the address of kernel page table. The (virtual) address of the trap frame is beforehand stored in sscratch register. xv6 utilize csrrw instruction to atomically swap the values in a0 and sscratch. So sscratch temporarily stores the old value of a0 and a0 contains the address of the trap frame. We now can use sd instruction to save register values in the slots. Q: Where does the kernel set the value of sscratch register?\nThe function usertrapret() in /kernel/trap.c sets control registers including stvec, sscratch etc.\nw_stvec(TRAMPOLINE + (uservec - trampoline)); p-\u0026gt;trapframe-\u0026gt;kernel_satp = r_satp(); // kernel page table p-\u0026gt;trapframe-\u0026gt;kernel_sp = p-\u0026gt;kstack + PGSIZE; // process's kernel stack p-\u0026gt;trapframe-\u0026gt;kernel_trap = (uint64)usertrap; p-\u0026gt;trapframe-\u0026gt;kernel_hartid = r_tp(); // hartid for cpuid() unsigned long x = r_sstatus(); x \u0026amp;= ~SSTATUS_SPP; // clear SPP to 0 for user mode x |= SSTATUS_SPIE; // enable interrupts in user mode w_sstatus(x); w_sepc(p-\u0026gt;trapframe-\u0026gt;epc); uint64 satp = MAKE_SATP(p-\u0026gt;pagetable); uint64 fn = TRAMPOLINE + (userret - trampoline); ((void (*)(uint64,uint64))fn)(TRAPFRAME, satp); The last line calls userret() and transmits two arguments including the address of TRAPFRAME, in userrret(), TRAPFRAME is stored into sscratch register.\nQ: Every time after ecall, we have a chance to execute usertrapret() and set the correct value in sscratch, but how do we set it correctly before the first execution?\nWhen xv6 is booting, it firstly goes into the supervisor mode. So the kernel also use usertrapret() to start executing a user program. usertrapret() is the only way xv6 provides to enter into the user program from the kernel.\nQ: Why should we use a particular trap frame instead of saving the values on the user stack?\nNot all the program languages have the same stack structure. Some program languages don\u0026rsquo;t have a stack, and some languages organize stack space in a weird way that kernel cannot understand (e.g. by allocating memory blocks). The principle for trap design is that the kernel cannot count on anything from the user space. The safest way for kernel is to save the values in the trap frame - a frame that belongs to the kernel and is reliable.\n(Author\u0026rsquo;s question: can we use a control register in RISC-V to store the address of kernel stack and save the register values on the kernel stack? In this way we don\u0026rsquo;t need an additional trap frame?)\nAfter saving registers, the kernel use ld sp, 8(a0) to load the address of kernel stack into the sp register. If we type print/x $sp in GDB, we\u0026rsquo;ll see that sp = 0x3fffffc000. Recalling the structure of kernel space mappings, the address is reasonable - just below the trap frame, there\u0026rsquo;s a guard page and the first kernel stack.\nNext, the hart id is stored into tp register. The address of the function to be jumped to (usertrap()) is stored into t0 register. csrw satp, t1 switches to the kernel page table.\nQ: Why doesn\u0026rsquo;t the kernel crash since we keep using user\u0026rsquo;s virtual addresses?\nThat\u0026rsquo;s because we\u0026rsquo;re executing in the trampoline page. The kernel and user page tables both have mappings to the trampoline page. (The same virtual address) The page is named \u0026ldquo;trampoline\u0026rdquo; because xv6 bounces on this page between user code and kernel code.\nAn important thing to remember is that: page table switching can only be implemented in the trampoline because the virtual address in this page maps to the same physical page in kernel and user page tables. Otherwise, the instruction addresses could not be interpreted and the kernel would crash.\nusertrap() After executing jr t0, we jump to the C-code function usertrap(). The first thing we do is\nw_stvec((uint64)kernelvec) which overwrites the stvec register. Xv6 handles traps differently depending on whether they come from user space or the kernel.\nstruct proc *p = myproc(); p-\u0026gt;trapframe-\u0026gt;epc = r_sepc(); These lines save the value of sepc into the trap frame. It\u0026rsquo;s necessary because the kernel may switch to another process. After returning to the user space of that process, the user program may do another system call, and the sepc register will be overwritten. (Note: it\u0026rsquo;s also correct to save sepc in the trampoline assembly code.)\nHere we\u0026rsquo;re doing write() system call, so the value in scause register is 8. We firstly add 4 to the sepc value in the trap frame in order not to re-execute the ecall instruction. Then we call intr_on() to accept interrupts. Interrupts are always turned off by the RISC-V trap hardware, so we need to explicitly open it in the code.\nXv6 enters syscall() in /kernel/syscall.c to handle system calls. In syscall(), xv6 retrieves the value in the a7 register (context in trap frame) to acquire the system call number and uses that to index the syscalls[] function array. After returning from sys_write(), the return value is stored in p-\u0026gt;trapframe-\u0026gt;a0.\nusertrapret()/userret() After handling the system call, xv6 enters usertrapret(). The job for usertrapret() is to set control registers to appropriate states for user mode. At the end, it calls userret() in /kernel/trampoline.S to resume registers. Refer to code details in \u0026ldquo;Xv6 Source Code Manual\u0026rdquo;.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"682bf0eb463ce76984d0a01ac772fcb6","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-operating-system/lectures/lec06/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-operating-system/lectures/lec06/","section":"notes","summary":"Introduction When going into traps, we need to carefully change the hardware state so that isolation will not be broken. The hardware state of RISC-V machine includes:\n32 general registers","tags":null,"title":"MIT-6.S081 Lecture 06: Traps","type":"docs"},{"authors":null,"categories":null,"content":"The Q\u0026amp;A focuses on lab pgtbl. The lab contain few lines of code, but hard-to-debug problems. Harsh environment of kernel programming makes it more difficult.\nTask 01 page table 0x0000000087f6e000 ..0: pte 0x0000000021fda801 pa 0x0000000087f6a000 .. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000 .. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000 .. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000 .. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000 ..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000 .. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000 .. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000 .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000 0-0-0: text and data of the init program. 0-0-1: the guard page (of the user stack) 0-0-2: user stack (tighter privilege can be set: PTE_X flags can be erased, the user stack is not supposed to store instructions.) 255-511-510: trap frame 255-511-511: trampoline One interesting fact is that: the physical pages allocated to the continuous virtual pages are not continuous. That\u0026rsquo;s the magic of virtual memory.\nQ: The trampoline page is at the highest virtual memory address MAXVA, why the first page directory\u0026rsquo;s index is 255 instead of 511?\nRISC-V Sv39 support 39 bits virtual address, but xv6 only uses 38 bits to avoid dealing with sign extension. Therefore, the first page directory\u0026rsquo;s index is only up to 255.\nQ: Why the text page and data page are merged into one page in init?\nGenerally, separate text page and data page can support more careful privilege settings. But in init program, we don\u0026rsquo;t use the exec() system call to load memory image, for simplicity of code in userinit() function, we combine text and data into one page.\nTask 02 One possible approach is to just copy the mappings in the kernel page tables that keep unchanged.\npagetable_t kvmcreate() { pagetable_t pagetable; int i; pagetable = uvmcreate(); for (i = 1; i \u0026lt; 512; i ++) pagetable[i] = kernel_pagetable[i]; kvmmapkern(pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W); kvmmapkern(pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W); kvmmapkern(pagetable, CLINT, CLINT, 0x10000, PTE_R | PTE_W); kvmmapkern(pagetable, PLIC, PLIC, 0x400000, PTE_R | PTE_W); return pagetable; } For the creation of a user kernel page table, we\u0026rsquo;re sure that later we only use the range [0, PLIC) for user memory, so only the first page directory entry may change. We can directly copy the kernel\u0026rsquo;s first level page directory of range [1,512) . Don\u0026rsquo;t forget to map several I/O devices in the first page directory entry.\nvoid kvmfree(pagetable_t kpagetable, uint64 sz) { pte_t pte = kpagetable[0]; pagetable_t level1 = (pagetable_t) PTE2PA(pte); for (int i = 0; i \u0026lt; 512; i ++) { pte_t pte = level1[i]; if (pte \u0026amp; PTE_V) { uint64 level2 = PTE2PA(pte); kfree((void *)level2); level1[i] = 0; } } kfree((void *) level1); kfree((void *) kpagetable); } To free the user page table, we don\u0026rsquo;t need to do anything about the 1~511 page directory entries since they\u0026rsquo;re just copied from the kernel page table. We need to walk through the first page directory entry to free the remaining pages. (Notice: kvmfree() is only responsible for freeing page table pages, the leaf physical pages for user memory should be beforehand freed.)\nIn the function scheduler(), we should switch to user kernel page table before swtch() and switch to kernel page table after swtch():\nkvmswitch(p-\u0026gt;kpagetable); swtch(\u0026amp;c-\u0026gt;context, \u0026amp;p-\u0026gt;context); kvminithart(); Q: Why must we switch back to the kernel page table after going back?\nIf there\u0026rsquo;s no running process, the kernel should have an page table to use. Also, if we want to free a process, we must firstly switch back to the kernel page table before the process \u0026ldquo;disappears\u0026rdquo;.\nTask 03 The advantages of adding user mappings into user kernel page table include:\nduring copyin()/copyout(), we don\u0026rsquo;t need to call walk() in the kernel to translate the user virtual address since now hardware can do the same thing for us, which is a relief to kernel programmers. performance is enhanced since we do less page table walks. kernel has more freedom to manipulate with user space. it can directly read/write data without repeatedly calling copyin()/copyout(). The core function should be responsible for copying mappings from user page table to user kernel page table:\nvoid kvmmapuser(int pid, pagetable_t kpagetable, pagetable_t upagetable, uint64 newsz, uint64 oldsz) { uint64 va; pte_t *upte; pte_t *kpte; if (newsz \u0026gt;= PLIC) panic(\u0026quot;kvmmapuser: news too large\u0026quot;); for (va = oldsz; va \u0026lt; newsz; va += PGSIZE) { upte = walk(upagetabe, va, 0); if (upte == 0) panic(\u0026quot;kvmmapuser: no upte\u0026quot;); if ((*upte \u0026amp; PTE_V) == 0) panic(\u0026quot;kvmmapuser: no valid upte\u0026quot;); kpte = walk(kpagetable, va, 1); if (kpte == 0) panic(\u0026quot;kvmmapuser: no kpte\u0026quot;); *kpte = *upte; *kpte \u0026amp;= ~(PTE_U|PTE_W|PTE_X); } } The line *kpte = *upte means that user physical pages are shared between user space and kernel space although the kernel allocates new pages for page directories/tables.\nThe PTE_U bit is cleared because in RISC-V hardware, kernel doesn\u0026rsquo;t have the privilege to read/write pages with PTE_U flag. The reason for this mechanism is not isolation, but convenience for kernel debugging. Xv6 without modification should never write/execute user memory.\nQ: Currently we require that the user memory space cannot exceed PLIC. What if we want to use all the space below KERNBASE?\nWe can remap the I/O devices: CLINT, PLIC, UART0 etc. Actually there is still much space between PHYSTOP and the kernel stacks. Put I/O devices there in the kernel\u0026rsquo;s virtual address space and map them to low physical addresses. In this case, low virtual addresses are available for user memory.\nQ: Why should we put the kernel stacks high in the virtual address space?\nBelow every kernel stack there is a guard page, which is not mapped to any physical page, in order of detecting stack overflow issue. If the guard pages are put in the range of [KERNBASE, PHYSTOP), physical pages will be wasted.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"5c3d5c835c68bbe43d7721642e9ee5b6","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-operating-system/lectures/lec07/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-operating-system/lectures/lec07/","section":"notes","summary":"The Q\u0026amp;A focuses on lab pgtbl. The lab contain few lines of code, but hard-to-debug problems. Harsh environment of kernel programming makes it more difficult.\nTask 01 page table 0x0000000087f6e000 .","tags":null,"title":"MIT-6.S081 Lecture 07: Q\u0026A for Labs #1","type":"docs"},{"authors":null,"categories":null,"content":"Decorators è€ƒè™‘å¦‚ä¸‹çš„é«˜é˜¶å‡½æ•° trace() ï¼š\ndef square(x): return x * x def trace(f): def traced(x): print(f'arg: {x}') r = f(x) print(f'return: {r}') return r return traced å½“æˆ‘ä»¬è°ƒç”¨ trace(square) æ—¶ï¼Œæˆ‘ä»¬å°±ä¼šè·å¾—ä¸€ä¸ªå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°çš„åŠŸèƒ½å’Œ square() æ˜¯ä¸€æ ·çš„ï¼Œä½†ä¼ å…¥çš„å‚æ•°å’Œè¿”å›å€¼ä¼šè¢«æ‰“å°å‡ºæ¥ã€‚\nå¦‚æœæˆ‘ä»¬æƒ³è¦æ¯æ¬¡è°ƒç”¨ square() æ—¶éƒ½ä½¿ç”¨è¿™ä¸ª traced çš„ç‰ˆæœ¬ï¼Œæ¯æ¬¡éƒ½å†™ trace(square) æœ‰ç‚¹å¤ªéº»çƒ¦äº†ã€‚è¿™æ—¶æˆ‘ä»¬å¯ä»¥ä½¿ç”¨è£…é¥°å™¨ (decorator)ï¼š\n@trace def square(x): return x * x è¿™æ ·è°ƒç”¨ square() æ—¶å°±ä¼šè‡ªåŠ¨ trace å‚æ•°å’Œè¿”å›å€¼ã€‚è£…é¥°å™¨çš„åŸç†æ˜¯ï¼šå¦‚ä¸‹çš„ä»£ç \n@ATTR def func(...): ... ç­‰ä»·äº\ndef func(...): ... func = ATTR(func) ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"326c345390890dbb85f3f045c55f4a27","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/lectures/lec07/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/lectures/lec07/","section":"notes","summary":"Decorators è€ƒè™‘å¦‚ä¸‹çš„é«˜é˜¶å‡½æ•° trace() ï¼š\ndef square(x): return x * x def trace(f): def traced(x): print(f'arg: {x}') r = f(x) print(f'return: {r}') return r return traced å½“æˆ‘ä»¬è°ƒç”¨ trace(square) æ—¶ï¼Œæˆ‘ä»¬å°±ä¼šè·å¾—ä¸€ä¸ªå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°çš„åŠŸèƒ½å’Œ square() æ˜¯ä¸€æ ·çš„ï¼Œä½†ä¼ å…¥çš„å‚æ•°å’Œè¿”å›å€¼ä¼šè¢«æ‰“å°å‡ºæ¥ã€‚","tags":null,"title":"UCB-CS61A Lecture 07: Function Examples","type":"docs"},{"authors":null,"categories":null,"content":"The benefits of virtual memory, besides offering isolation, include levels of indirection. We have already seen some interesting usage of mappings, such as trampoline page and guard page, but these mappings are relatively static. With the aid of page faults, the mappings become dynamic: when page faults occur, the kernel can change page table mappings. Combination of page table and page fault provides enormous amount of flexibility.\nThe kernel needs necessary information to handle with page faults:\nThe faulting virtual address: RISC-V hardware stores it in the stval register.\nThe type of page faults, including instruction page fault, load page fault and store page fault. RISC-V manual specifies each type\u0026rsquo;s scause number:\npage fault type scause number instruction page fault 12 load page fault 13 store page fault 15 the va of instruction that causes the exception. The PC value is stored in sepc register and transferred into the trap frame.\nLazy allocation Xv6 provides sbrk() system call for user program to grow or shrink its heap size. Xv6 uses \u0026ldquo;eager allocation\u0026rdquo; for sbrk(), i.e. it immediately allocates physical memory for the applications. However, it\u0026rsquo;s difficult for applications to estimate the amount of heap space, so they usually ask for more pages than they need. Using page faults, kernel can respond to the system call in a more intelligent manner.\nIn lazy allocation, when sbrk() is called, we only increase p-\u0026gt;sz by n, not allocating any physical pages. When the user program load/store a virtual address later in the heap, page fault exception is triggered. The kernel checks the faulting va in stval register: if p-\u0026gt;stack \u0026lt; faulting va \u0026lt; p-\u0026gt;sz, we call kalloc() to allocate physical page, update the user page table, and re-execute the instruction.\nHere\u0026rsquo;s a simple version of code implementation:\nIn sys_sbrk(), we don\u0026rsquo;t need to call growproc() to allocate physical pages, the only thing we need to do is to modify p-\u0026gt;sz:\nuint64 sys_sbrk(void) { int addr; int n; if(argint(0, \u0026amp;n) \u0026lt; 0) return -1; addr = myproc()-\u0026gt;sz; + p-\u0026gt;sz = p-\u0026gt;sz + n; - if(growproc(n) \u0026lt; 0) - return -1; return addr; } Currently, if we boot xv6 and execute shell instruction echo hello, we\u0026rsquo;ll get a kernel panic:\nusertrap(): unexpected scause 0x000000000000000f pid=3 sepc = 0x00000000000012a4 stval=0x0000000000004008 The instruction at 0x12a4 is a store instruction, so the value in scause is 0xf. User program shell has 4 pages and the faulting va stored in stval register is just above the stack and belongs to the heap area.\nWe need to modify the kernel to let xv6 handle with the page fault instead of directly triggering panic:\nvoid usertrap(void) { ... if(r_scause() == 8){ // system call ... } else if((which_dev = devintr()) != 0){ // ok + } else if (r_scause() = 15){ + uint64 va = r_stval(); + printf(\u0026quot;page fault %p\\n\u0026quot;, va); + uint64 ka = (uint64) kalloc(); + if(ka == 0){ + p-\u0026gt;killed = 1; + } else{ + memset((void *)ka, 0, PGSIZE); + va = PGROUNDDOWN(va); + if (mappages(p-\u0026gt;pagetable, va, PGSIZE, ka, PTE_W|PTE_U|PTE_R) != 0) + { + kfree((void *)ka); + p-\u0026gt;killed = 1; + } + } } else { printf(\u0026quot;usertrap(): unexpected scause %p pid=%d\\n\u0026quot;, r_scause(), p-\u0026gt;pid); printf(\u0026quot; sepc=%p stval=%p\\n\u0026quot;, r_sepc(), r_stval()); p-\u0026gt;killed = 1; } if(p-\u0026gt;killed) exit(-1); // give up the CPU if this is a timer interrupt. if(which_dev == 2) yield(); usertrapret(); } in usertrap(), we insert a branch for handling with page faults. We read stval register to get the faulting virtual address, allocate a new physical page, and call mappages() to insert mappings in the user page table.\nHowever, we cannot let xv6 run correctly by only those modification. There\u0026rsquo;s another kernel panic message:\npanic: uvmunmap: not mapped uvmunmap() doesn\u0026rsquo;t allow us to unmap pages that hasn\u0026rsquo;t benn allocated, but in lazy allocation this is valid. Therefore we need to modify uvmunmap():\nvoid uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free) { uint64 a; pte_t *pte; if((va % PGSIZE) != 0) panic(\u0026quot;uvmunmap: not aligned\u0026quot;); for(a = va; a \u0026lt; va + npages*PGSIZE; a += PGSIZE){ if((pte = walk(pagetable, a, 0)) == 0) panic(\u0026quot;uvmunmap: walk\u0026quot;); if((*pte \u0026amp; PTE_V) == 0) - panic(\u0026quot;uvmunmap: not mapped\u0026quot;); + continue; if(PTE_FLAGS(*pte) == PTE_V) panic(\u0026quot;uvmunmap: not a leaf\u0026quot;); if(do_free){ uint64 pa = PTE2PA(*pte); kfree((void*)pa); } *pte = 0; } } Zero fill in demand Ususally there are lots of zero pages in the user space. For example, in the ELF file there is a .bss segment, in xv6, when we use exec() system call to load a program, the kernel allocate pages for the .bss segment and set the values as zero.\nA clever implementation is: during exec(), we only allocate one zero page in the physical memory and map all the zero pages in the virtual memory space to it. Those mappings should be read only. In the future when one zero page needs to be modified, a page fault exception will be triggered, and the kernel should allocate another zero page in the physical memory and modify page table\u0026rsquo;s PTE to map the virtual page being written to the new page (read-and-write).\nThis \u0026ldquo;lazy zero page allocation\u0026rdquo; has at least 2 advantages:\nIn some cases, only a small part of the .bss segment will be modified and zero-fill-in-demand saves lots of physical space. In exec() we don\u0026rsquo;t need to do lots of allocations, which makes exec() faster and provides better interact performance between users and the kernel. (Of course, we somehow \u0026ldquo;postpone\u0026rdquo; the penalty: a page fault contains hundreds of load/store instructions, which is very expensive.) Copy-on-write (COW) fork An observation is that: when we use fork() system call, xv6 creates physical pages and copies all the memory pages in the parent process into child process. Usually, there\u0026rsquo;s an exec() system call afterwards and xv6 frees the pages that have just be created.\nCopy-on-write fork somehow optimizes it. During a fork() system call, we copy the parent process\u0026rsquo;s page table into the child\u0026rsquo;s page table, i.e. let parent and child map to the same physical pages, instead of making copies of physical pages at once.\nHowever, we should remember that parent and child\u0026rsquo;s modifications cannot be visible to each other. To achieve the isolation, we set the PTEs as read-only PTEs. In the future, when parent/child process makes a modification, a page fault exception will be triggered, and the kernel is responsible for copying the corresponding physical page, updating page tables, changing the PTEs as read-and-write PTEs, and restarting the faulting instruction.\nQ: How can the kernel tells the copy-on-write page fault from other invalid page faults?\nAlmost all the hardware supporting paging, including RISC-V, can address this issue. In RISC-V\u0026rsquo;s PTE format, there are some bits called RSW bits, which are available for kernel use. Kernel can set copy-on-write bit in the RSW area, and when page faults happen, the kernel checks the copy-on-write bit to decide whether it\u0026rsquo;s a valid page fault.\nIf copy-on-write fork is implemented, there\u0026rsquo;s another things worth attention: in unmodified xv6, one physical page belongs to more or less one process except the trampoline page, which will never be freed. However, in copy-on-write-fork situation, there will be pages belonging to multiple processes, so when a process is being freed, it cannot directly free all the corresponding physical pages since other processes may be using them. A reasonable approach is that, we maintain a \u0026ldquo;ref count\u0026rdquo; for each page recording the number of processes using this page, and we free a page when its ref count equals zero.\nDemand paging For unmodified xv6, In exec() system call the kernel loads all the text segment pages and data segment pages into the memory. Accessing files is quite expensive and sometimes the user program doesn\u0026rsquo;t use all its instructions and data.\nIf demand paging is implemented, in exec(), the kernel doesn\u0026rsquo;t load the pages, but set the PTEs as invalid (PTE_V bit removed). So when the user program executes its first instruction, a page fault exception will be triggered. The text/data segment pages are beforehand binded to corresponding files, and in the page fault handler, the kernel copies pages from the file to the memory, updating page tables and restarting the faulting instruction.\nIn some situation, when a page fault happens and the kernel needs to load a new page into memory, there\u0026rsquo;s no free pages - the memory is used up. In this case, the kernel should firstly choose one page and evict it into the file/disk, and then use the just freed physical page to load the new page. After that, it can restart the faulting instruction.\nThere are several strategies for choosing the evicted page. The most commonly used strategy is to evict the least recently used page (LRU strategy). Another useful strategy is that the kernel prefers to choose non-dirty page than dirty page, since evicting non-dirty page only requires disabling the corresponding PTE. In hardware, RISC-V\u0026rsquo;s PTE format includes PTE_A bit representing whether the page has been accessed recently, which is helpful for implementing LRU (of course, the operating system should periodically clear all the PTE_A bits). There\u0026rsquo;s also a PTE_D bit representing whether the page has ever been modified.\nMemory-mapped files Most modern operating system provides mmap() system call, which aims at letting user program use load/store instructions to directly read/write files instead of repeatedly using expensive read() / write() system calls. The declaration of mmap() is\nvoid *mmap(void *va, size_t length, int prot, int flags, int fd, off_t offset); It will map the specified virtual address to the file descriptor. Some operating systems eagerly do the mappings: it loads pages in the files into the memory. However, by utilizing page fault mechanism, we can firstly only maintain a virtual memory area (vma) recording necessary information, and when a paging fault happens, it loads needed pages into memory, and when the file is closed, the kernel should write dirty pages back to the file/disk.\nQ: What if multiple processes share one file page?\nWe don\u0026rsquo;t know the exact order of read/write operations in the two processes, so it\u0026rsquo;s an undefined behavior, we don\u0026rsquo;t need to do extra maintenance. If we implement a file locking in the file system, we can address the synchronizing issue.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"3142d947280f5c082707ef2d0985726f","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-operating-system/lectures/lec08/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-operating-system/lectures/lec08/","section":"notes","summary":"The benefits of virtual memory, besides offering isolation, include levels of indirection. We have already seen some interesting usage of mappings, such as trampoline page and guard page, but these mappings are relatively static.","tags":null,"title":"MIT-6.S081 Lecture 08: Page Faults","type":"docs"},{"authors":null,"categories":null,"content":"Type top in the command line and you can check the memory usage, processes information etc. in the terminal:\ntop - 11:57:33 up 1 day, 1:04, 1 user, load average: 0.21, 0.25, 0.32 Tasks: 354 total, 1 running, 353 sleeping, 0 stopped, 0 zombie %Cpu(s): 0.9 us, 0.7 sy, 0.0 ni, 98.4 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st MiB Mem : 15661.3 total, 586.9 free, 2944.0 used, 12130.4 buff/cache MiB Swap: 19531.0 total, 19528.5 free, 2.5 used. 11403.6 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 840 root 20 0 421340 21428 16712 S 9.0 0.1 3:59.57 Network+ 4461 starling 9 -11 2834104 17456 13760 S 4.0 0.1 32:30.95 pulseau+ 949 root 20 0 10488 6496 4940 S 1.0 0.0 14:10.30 EasyMon+ 962 root 20 0 407004 9836 7688 S 1.0 0.1 8:50.53 ECAgent 113206 starling 20 0 36.3g 67604 51524 S 0.7 0.4 0:17.59 code 4466 starling 20 0 10520 6480 3740 S 0.3 0.0 0:27.20 dbus-da+ 4615 starling 20 0 6096848 442400 163960 S 0.3 2.8 18:26.29 gnome-s+ 5241 starling 20 0 561596 35788 26204 S 0.3 0.2 5:20.81 sogoupi+ 112573 starling 20 0 4934416 716796 396344 S 0.3 4.5 1:10.73 GeckoMa+ 113141 starling 20 0 36.3g 165072 55252 S 0.3 1.0 0:08.28 code 113678 starling 20 0 40.6g 274404 121660 S 0.3 1.7 4:42.63 Typora 116933 starling 20 0 2571540 173676 127868 S 0.3 1.1 0:24.61 Isolate+ 120059 root 20 0 0 0 0 I 0.3 0.0 0:00.03 kworker+ 120151 starling 20 0 21704 4412 3460 R 0.3 0.0 0:00.77 top 1 root 20 0 165108 11200 7684 S 0.0 0.1 0:04.22 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.15 kthreadd 3 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 rcu_gp We can see that there\u0026rsquo;s little free memory left, most memory is used by the buffer cache. That\u0026rsquo;s a very common case in modern operating systems. Leaving too much memory space idle is wasteful, so operating systems usually make full use of the memory space. In this case, handling page fault exception and evicting pages out to the disk is very frequent.\nSometimes the hardware wants attention, so they generate interrupts. The software should save its work, process the interrupts, and afterwards resume its work. The saving and resuming procedures are similar to those of system calls and traps, they all use the same mechanism. But the following features make interrupts different and be worth of a lecture:\nAsynchronous: interrupts can happen at any time. A system call must happen when a user program is running, but when interrupts come, we have no idea which process is being executed, or whether there is a process running. Concurrency. We have to address a lot of issues about concurrency and parallelism. This is the start point of talking about concurrency. The devices and the CPU are independent parts: CPU executes instructions while devices handling I/O events. This is true parallelism. Device programming: devices like ether-net cards and UART needs programming. There may be manual illustrating the function of each control register, but devices are often pool documented. RISC-V Interrupt Structure The first question is: where are interrupts come from? Interrupts come from the various devices. Devices send the interrupts to a device called platform-level interrupt controller (PLIC), CPU cores can access PLIC to see whether there\u0026rsquo;s an pending interrupts. When a CPU core finishes processing an interrupt, it sends a signal to the PLIC and PLIC knows that this interrupts can be forgot.\nQ: Does PLIC has some mechanism to ensure fairness?\nIt\u0026rsquo;s up to the kernel. The kernel programs the PLIC hardware. PLIC doesn\u0026rsquo;t really actively choose service of delivering interrupts. The kernel fetches the interrupts and decides where interrupts should be sent. The kernel can also decide the priority of different kinds of interrupts. There is a huge amount of flexibility.\nOrganization of Drivers Drivers are codes used for managing devices. A typical driver structure includes 2 parts:\nTop part: this part handle system calls related to the device such as read() and write() system calls. It interacts with the user processes, so things like copyin()/copyout() are done in this part. Bottom part: this part serves as the interrupt handler of the corresponding device. When the device raises an interrupt, the kernel catches it and calls functions in the bottom part of its driver to handle the interrupt. It may happen that the current process is not the previous pending process, so the interrupt handler cannot count on any information about the process in the CPU core (e.g. page table). Programming Devices In xv6 we use memory mapped I/O. In this case devices show up at particular addresses in the physical memory space, which are determined by the hardware board manufacturers. The operating systems should know these addresses in order to programming devices. OS can use normal load/store instructions to read/write the control registers of the devices.\nInterrupts on Hardware The PLIC hardware is responsible for receiving interrupts from different devices and routing them to CPU cores. If a CPU core receives an interrupt and the SIE bit of sstatus register is set (i.e. interrupt enabled), the hardware will do the following things:\nClear the SIE bit in sstatus register to temporarily disable interrupts. store PC value into sepc register. save the current mode, and then switch to supervisor mode. copy the address in stvec register into PC. In xv6, it goes to usertrap()/kerneltrap(). Case Study: $ We want to know how the prompt $ shows up in the console. In general, the device puts $ into the UART, and UART generates an interrupt when the char has been sent.\nRISC-V hardware has some supports for interrupts:\nSIE register. The supervisor interrupt enable register has a bit for external interrupt, a bit for software interrupt and a bit for timer interrupt. Here we only focus on external interrupts. SSTATUS register. This control register contains a bit that can enable/disable interrupts. SIP register. The supervisor interrupt pending register, together with SCAUSE register, contain information about what interrupt is coming. In main(), xv6 does a bunch of preparations which get ready for interrupts. The true time when interrupt is able to come in is when scheduler() calls intr_on():\nvoid scheduler(void) { struct proc *p; struct cpu *c = mycpu(); c-\u0026gt;proc = 0; for(;;){ // Avoid deadlock by ensuring that devices can interrupt. intr_on(); ... } } intr_on() is responsible for writing SSTATUS_SIE bit into SSTATUS register:\nstatic inline void intr_on() { w_sstatus(r_sstatus() | SSTATUS_SIE); } Every CPU core runs scheduler() code, and when intr_on() is called, the corresponding core is able to accept interrupts.\nThe first user process, init, opens the console device and assign 0/1/2 to standard input/output/error.\nif(open(\u0026quot;console\u0026quot;, O_RDWR) \u0026lt; 0){ mknod(\u0026quot;console\u0026quot;, CONSOLE, 0); open(\u0026quot;console\u0026quot;, O_RDWR); } dup(0); // stdout dup(0); // stderr Then in user program /user/sh.c, getcmd() function uses fprintf() to print a prompt to stderr. Here fprintf() doesn\u0026rsquo;t know what\u0026rsquo;s behind the file descriptor 2, maybe a file, a pipe or a device.\nint getcmd(char *buf, int nbuf) { fprintf(2, \u0026quot;$ \u0026quot;); memset(buf, 0, nbuf); gets(buf, nbuf); if(buf[0] == 0) // EOF return -1; return 0; } fprintf() will eventually use write() system call to write a character. Refer to the xv6-book notes for the procedure after that.\nCase Study: ls We want to know how the command ls is typed into the console. In general, the keyboard connects to the receive line of UART. When a character is typed, UART generates an interrupt to let the kernel fetches that char.\nWhen a interrupt is received by the kernel, usertrap()/kerneltrap() calls devintr() to check whether there\u0026rsquo;s an interrupt and do corresponding operations. devintr() calls plic_claim() to make the CPU core claim the type of device and call uartintr() to handle UART interrupt. In uartintr(), it calls uartgetc() to get the character l and s, and calls consoleintr() to put them into buffer.\nInterrupts and Concurrency Concurrency issues in interrupts are difficult to tackle with. Here are some common concurrency problems:\nDevices and CPU cores run in parallel. It\u0026rsquo;s called producer-consumer parallelism and needs to be carefully managed. Interrupts can stop the current program. If it stops the user program, the procedure is similar to traps. However, interrupt can also stop the kernel, which means that the instruction sequence in kernel code may not be continuous either now. We have to carefully enable/disable interrupts in kernel code to avoid crashing. The top of drivers and the bottom of drivers may run in parallel. For example, when the shell program use write() system call to put a dollar prompt on the display, i.e. the top of the console driver is running, another CPU core may be handling interrupts from uart. The top and bottom share resources such as the buffer array. To make sure each core can see the correct, up-to-date content, we need a mechanism to ensure that only one core can do operations to shared resources at a time. Xv6 uses locks to realize that. Xv6 uses buffer array to address the producer-consumer parallelism. There are a read pointer and a write pointer for each buffer. The buffer is empty when r==w, the buffer is full when w+1 mod BUFFER_SIZE==r. The producer puts characters at the end of the queue and updates write pointer, while the consumer reads characters at the beginning of the queue and updates read pointer. Buffer array successfully decouple devices and CPU cores, making them able to run separately at high speed.\nQ: Is there multiple buffer arrays, one for each CPU core?\nThe buffer array is an array declared in /kernel/uart.c and is set in RAM. There\u0026rsquo;s only one RAM so there\u0026rsquo;s only one buffer array. There are several CPU cores running processes in parallel, and they may access the UART device at the same time, i.e. access the buffer array in parallel.\nThe main task for locking is to serialize accesses. Only the core that acquires the lock has access to the array and the read/write pointers. After it releases the lock, other cores can acquire the lock.\nInterrupt Evolution Interrupts used to be very fast because hardware is very simple in old times. Nowadays, interrupts are slow because devices are more complicated. They have to do lots of preliminary work before generating an interrupt. On the other hand, kernel design becomes more complicated and it takes longer to handle an interrupt.\nFor some fast devices, e.g. high performing network card, there may be a stream of packets and the period is even shorter than the interrupt handling time. In this case, we have another strategy - polling. The CPU keeps checking a particular control register, once there\u0026rsquo;s data in, the CPU handles it. For slow devices, polling wastes CPU cycles on checking registers, but if devices are fast, polling can save frequent entry/exit cost.\nNowadays, sophisticated devices can dynamically switch between polling and interrupts.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"a8def34e5a1088a10cd924fe625f2d97","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-operating-system/lectures/lec09/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-operating-system/lectures/lec09/","section":"notes","summary":"Type top in the command line and you can check the memory usage, processes information etc. in the terminal:\ntop - 11:57:33 up 1 day, 1:04, 1 user, load average: 0.","tags":null,"title":"MIT-6.S081 Lecture 09: Interrupts","type":"docs"},{"authors":null,"categories":null,"content":"æ²¡æœ‰éœ€è¦ç‰¹åˆ«æ³¨æ„çš„çŸ¥è¯†ç‚¹ã€‚\n(æ³¨ï¼šè¿™é‡Œçš„ tree recursion æŒ‡çš„ä¸æ˜¯åœ¨æ ‘ä¸Šæœç´¢çš„é€’å½’ï¼Œè€Œæ˜¯ä¸€ä¸ªå‡½æ•°åœ¨å‡½æ•°ä½“å†…å¤šæ¬¡è°ƒç”¨è‡ªå·±ï¼Œæ•´ä¸ªè°ƒç”¨æ„æˆäº†ä¸€æ£µæ ‘çš„æƒ…å½¢ï¼Œæœ€ç»å…¸çš„ä¾‹å­å°±æ˜¯ä¸å¸¦è®°å¿†åŒ–åœ°é€’å½’è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—ã€‚)\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"641fcc9bce140509d05ac43ddc833007","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/lectures/lec09/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/lectures/lec09/","section":"notes","summary":"æ²¡æœ‰éœ€è¦ç‰¹åˆ«æ³¨æ„çš„çŸ¥è¯†ç‚¹ã€‚\n(æ³¨ï¼šè¿™é‡Œçš„ tree recursion æŒ‡çš„ä¸æ˜¯åœ¨æ ‘ä¸Šæœç´¢çš„é€’å½’ï¼Œè€Œæ˜¯ä¸€ä¸ªå‡½æ•°åœ¨å‡½æ•°ä½“å†…å¤šæ¬¡è°ƒç”¨è‡ªå·±ï¼Œæ•´ä¸ªè°ƒç”¨æ„æˆäº†ä¸€æ£µæ ‘çš„æƒ…å½¢ï¼Œæœ€ç»å…¸çš„ä¾‹å­å°±æ˜¯ä¸å¸¦è®°å¿†åŒ–åœ°é€’å½’è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—ã€‚)","tags":null,"title":"UCB-CS61a Lecture 09: Tree Recursion","type":"docs"},{"authors":null,"categories":null,"content":"Applications may want multiple CPU cores, so the kernel must handle parallel system calls, e.g. carefully maintain shared data structure in parallel. We use locks to ensure correct sharing, but on the other hand, locks can limit performance.\nThe frequency of CPU clock gradually reaches a limit at 2010, which means that single thread performance cannot be optimized. However, the number of transistors keeps growing, so having multiple cores is our only choice to increase performance.\nWhy Lock? We use lock to avoid race conditions. For example, if we delete the acquire(kmem.lock) and release(kmem.lock) in kfree(), it\u0026rsquo;s possible that pages are lost during freeing.\nLock Abstraction The lock in xv6 is simply a struct:\nstruct lock { int locked; ... }; there are two APIs: acquire(struct lock *lk) and release(struct lock *lk)ï¼Œat one time, only one process can acquire the lock, and other processes have to wait until the first process calls release().\nThe area between acquire() and release() is called critical section. The code in critical sections are executed atomically, i.e. either all or none of the code is executed, it\u0026rsquo;s impossible for codes in the same critical section to interweave.\nPrograms usually have many locks, aiming at more parallelism. If there\u0026rsquo;s only one lock in the kernel, to ensure correctness, the lock must protects all the codes in the kernel (the so called \u0026lsquo;big kernel lock\u0026rsquo;). In this case, the execution of the whole kernel is serialized. If we use multiple locks, it\u0026rsquo;s allowable to let two processes using different locks run in parallel.\nWhen to Lock? A conservative rule (guideline): if 2 processes access a shared data structure and at least one operation is writing, then we have to lock that data structure.\nFrom some aspects, the guideline is too strict: we can use lock-free programming. But lock-free programming is so tricky that we won\u0026rsquo;t cover that. From some aspects, the guideline is too loose: in printf() we use lock to ensure that the printed message is atomic.\nWe may want data structures to automatically acquire and release locks when we\u0026rsquo;re accessing them, but there are cases when we need more flexible lock management. Consider a system call rename() . Suppose now we deal with rename(\u0026quot;d1/x\u0026quot;, \u0026quot;d2/y\u0026quot;), if we act like this:\nlock(d1); erase(\u0026quot;d1/x\u0026quot;); release(d1); (**) lock(d2); add(\u0026quot;d2/y\u0026quot;); release(d2); then at time **, from other processes\u0026rsquo; perspective, the file doesn\u0026rsquo;t exist! - obviously incorrect. The correct implementation is\nlock(d1 and d2); erase(\u0026quot;d1/x\u0026quot;); add(\u0026quot;d2/y\u0026quot;); release(d1 and d2); In this example, we see that sometimes we need multiple locks before doing operations.\nLock Perspectives Locks help avoid lost updates. (e.g. kfree() ) Locks make multi-step operations (critical section) atomic. Locks help maintain invariants. (e.g. in kfree(), the lock protects moments when there are multiple pointers pointing to the head node.) Deadlock Let\u0026rsquo;s look at a case which may lead to deadlock:\nCPU1 CPU2 rename(\u0026quot;d1/x\u0026quot;, \u0026quot;d2/y\u0026quot;) rename(\u0026quot;d2/a\u0026quot;, \u0026quot;d1/b\u0026quot;) acquire(d1) acquire(d2) acquire(d2) \u0026lt;-- blocked acquire(d1) \u0026lt;-- blocked The solution is to always acquire locks in order. (actually, it\u0026rsquo;s OK for CPU2 to acquire d1 and then d2 in this case.) Here the lock ordering is a partial order.\nLock makes modularity more complicated. Suppose a function f() in module 1 calls a function g() in module 2, f() must ensure that locks in g() will not violate global lock ordering, which means that the internals of module 2 (in terms of locks) must be visible to module 1, which somehow violates the module abstraction principle.\nLock Performance Locks lead to serialization, which influences performance. To increase performance, we need to split up data structures and introduce more locks, which require lots of work.\nA general approach is to firstly use coarse-grained locks, and do profiling tests to see whether we need smaller locks to increase parallelism.\nCode: Lock Implementation The most common way to acquire locks is to use the hardware test-and-set support. In RISC-V, we use the amoswap addr, r1, r2 atomic instruction. It can be viewed as the following pseudo instructions:\nlock addr tmp \u0026lt;-- *addr *addr \u0026lt;-- r1 r2 \u0026lt;-- tmp unlock addr Hardware test-and-set support is dependent on memory system. If the memories are sitting on a share bus, a memory controller (bus arbiter) is responsible for sorting the locks in order. If processors have caches, the cache coherence protocol will ensure the consistency.\nIn acquire() in xv6, we use the C function __sync_lock_test_and_set() to do atomic operations. Refer to Xv6 Source Code Manual for more details.\nIn release(), we may wonder that why we still need to use atomic instruction to set the lock: a simple store instruction can finish that. However, the store instruction may be executed differently depending on architecture design. sw may be decomposed to several micro instructions, which leads to lost of atomicity.\nCode: Locks and Interrupts In acquire(), we must firstly turn off the interrupts. That\u0026rsquo;s because unexpected interrupts may cause deadlock. For example, in /kernel/uart.c:\nvoid uartputc(int c) { acquire(\u0026amp;uart_tx_lock); if(panicked){ for(;;) ; } ...... } void uartintr(void) { // read and process incoming characters. while(1){ int c = uartgetc(); if(c == -1) break; consoleintr(c); } // send buffered characters. acquire(\u0026amp;uart_tx_lock); uartstart(); release(\u0026amp;uart_tx_lock); } Suppose that we don\u0026rsquo;t turn off interrupts when holding locks, we acquire the lock uart_tx_lock in uartputc(), and when we\u0026rsquo;re in the critical section, the uart hardware sends an interrupt, leading us to uartintr(). In uartintr() the kernel tries to acquire the lock uart_tx_lock, but the lock is held by the interrupted thread, on the other hand, it\u0026rsquo;s impossible for the interrupted thread to move on unless interrupt handler returns. So a deadlock appears.\nCode: Memory Ordering Modern compilers and processors usually adjust instruction order to increase performance. For example,\nlock = 1; x = x + 1; // ---+ lock = 0; // | // \u0026lt;--+\tIt\u0026rsquo;s possible for compilers/processors to move x = x + 1 to the end of the paragraph. If the code is executed in a single-core, serial mode, it\u0026rsquo;s absolutely OK and correct. But if it\u0026rsquo;s executed on mult-core processors, it\u0026rsquo;s a disaster.\nTo avoid such things, we can build a memory fence. In RISC-V, it\u0026rsquo;s a mfence instruction and it\u0026rsquo;s encapsulated as __sync_synchronize() in libc. We put memory fence at the beginning of acquire() and the end of release() to ensure that no instruction will be unexpectedly moved out of our critical section.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"1c6adea44cdb690c1780a0813b538024","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-operating-system/lectures/lec10/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-operating-system/lectures/lec10/","section":"notes","summary":"Applications may want multiple CPU cores, so the kernel must handle parallel system calls, e.g. carefully maintain shared data structure in parallel. We use locks to ensure correct sharing, but on the other hand, locks can limit performance.","tags":null,"title":"MIT-6.S081 Lecture 10: Multiprocessors and Locks","type":"docs"},{"authors":null,"categories":null,"content":"List Comprehension é€šè¿‡ä¸€ä¸ªå·²ç»å­˜åœ¨çš„ list åˆ›å»ºä¸€ä¸ªæ–°çš„ listã€‚\nå®Œæ•´çš„è¯­æ³•ä¸ºï¼š\n[\u0026lt;map exp\u0026gt; for \u0026lt;name\u0026gt; in \u0026lt;iter exp\u0026gt; if \u0026lt;filter exp\u0026gt;] åœ¨æ‰§è¡Œè¿™æ ·ä¸€æ¡è¯­å¥æ—¶ï¼ŒPython è§£é‡Šå™¨ä¼šåšè¿™æ ·çš„äº‹æƒ…ï¼š\nä¸´æ—¶åˆ›å»ºä¸€ä¸ªæ–°çš„ frameï¼Œè¿™ä¸ª frame çš„ parent frame æ˜¯æ‰§è¡Œè¯¥è¯­å¥çš„å½“å‰ frameã€‚ åˆ›å»ºä¸€ä¸ªç©ºçš„ list ä½œä¸ºå½“å‰è¯­å¥çš„ç»“æœ æ‰§è¡Œ \u0026lt;iter exp\u0026gt;ï¼Œç»“æœå¿…é¡»æ˜¯ä¸€ä¸ª iterable çš„ä¸œè¥¿ã€‚ å¯¹äº \u0026lt;iter exp\u0026gt; ç»“æœä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œå°† \u0026lt;name\u0026gt; ç»‘å®šåˆ°è¯¥å…ƒç´ ä¸Šï¼Œå¹¶æ‰§è¡Œ \u0026lt;filter exp\u0026gt; ä»¥å†³å®šæ˜¯å¦æ”¾å…¥ listã€‚ ä¸´æ—¶ frame çš„è¿”å›å€¼å°±æ˜¯ç»“æœ listã€‚ æ³¨æ„ï¼šlist comprehension ä¸­çš„ if è¯­å¥ä¸èƒ½è·Ÿ elseã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"11c16ecb995a078cbdb4118cf9fdc134","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/lectures/lec10/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/lectures/lec10/","section":"notes","summary":"List Comprehension é€šè¿‡ä¸€ä¸ªå·²ç»å­˜åœ¨çš„ list åˆ›å»ºä¸€ä¸ªæ–°çš„ listã€‚\nå®Œæ•´çš„è¯­æ³•ä¸ºï¼š\n[\u0026lt;map exp\u0026gt; for \u0026lt;name\u0026gt; in \u0026lt;iter exp\u0026gt; if \u0026lt;filter exp\u0026gt;] åœ¨æ‰§è¡Œè¿™æ ·ä¸€æ¡è¯­å¥æ—¶ï¼ŒPython è§£é‡Šå™¨ä¼šåšè¿™æ ·çš„äº‹æƒ…ï¼š\nä¸´æ—¶åˆ›å»ºä¸€ä¸ªæ–°çš„ frameï¼Œè¿™ä¸ª frame çš„ parent frame æ˜¯æ‰§è¡Œè¯¥è¯­å¥çš„å½“å‰ frameã€‚ åˆ›å»ºä¸€ä¸ªç©ºçš„ list ä½œä¸ºå½“å‰è¯­å¥çš„ç»“æœ æ‰§è¡Œ \u0026lt;iter exp\u0026gt;ï¼Œç»“æœå¿…é¡»æ˜¯ä¸€ä¸ª iterable çš„ä¸œè¥¿ã€‚ å¯¹äº \u0026lt;iter exp\u0026gt; ç»“æœä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œå°† \u0026lt;name\u0026gt; ç»‘å®šåˆ°è¯¥å…ƒç´ ä¸Šï¼Œå¹¶æ‰§è¡Œ \u0026lt;filter exp\u0026gt; ä»¥å†³å®šæ˜¯å¦æ”¾å…¥ listã€‚ ä¸´æ—¶ frame çš„è¿”å›å€¼å°±æ˜¯ç»“æœ listã€‚ æ³¨æ„ï¼šlist comprehension ä¸­çš„ if è¯­å¥ä¸èƒ½è·Ÿ elseã€‚","tags":null,"title":"UCB-CS61A Lecture 10: Containers","type":"docs"},{"authors":null,"categories":null,"content":"Copying æˆ‘ä»¬å¹³æ—¶å†™çš„\nlistA = [0, 1, 2, 3] æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªåå« \u0026ldquo;listA\u0026rdquo; çš„æŒ‡é’ˆæŒ‡å‘äº† [0, 1, 2, 3] è¿™ä¸ªå¯¹è±¡ã€‚\næ‹·è´åˆ†æ·±æ‹·è´å’Œæµ…æ‹·è´ä¸¤ç§ã€‚æµ…æ‹·è´åªæ˜¯è®©ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘äº†åŒä¸€ä¸ªå¯¹è±¡ï¼Œè€Œæ·±æ‹·è´ä¼šå°†å¯¹è±¡å¤åˆ¶ä¸€éï¼Œç„¶åè®©æ–°æŒ‡é’ˆæŒ‡å‘æ–°å¤åˆ¶çš„å¯¹è±¡ã€‚ä¾‹å¦‚ï¼š\n\u0026gt;\u0026gt;\u0026gt; listA = [0, 1, 2, 3] \u0026gt;\u0026gt;\u0026gt; listB = listA # æµ…æ‹·è´ \u0026gt;\u0026gt;\u0026gt; listC = list(listA) # æ·±æ‹·è´ \u0026gt;\u0026gt;\u0026gt; listA[0] = 1 \u0026gt;\u0026gt;\u0026gt; listB, listC ([1, 1, 2, 3], [0, 1, 2, 3]) Built-in Functions for Iterables ä¸€äº›å¸¸è§çš„å†…ç½®å‡½æ•°æœ‰ï¼š\nFunction Description sum(iterable) æ±‚å’Œ all(iterable) è¿”å› True å½“ä¸”ä»…å½“ iterable ä¸­æ‰€æœ‰å…ƒç´ å‡ä¸º True any(iterable) è¿”å› True å½“ä¸”ä»…å½“ iterable ä¸­å­˜åœ¨å…ƒç´ ä¸º True max(iterable, key=None) æœ€å¤§å€¼ min(iterable, key=None) æœ€å°å€¼ å…¶ä¸­ max() min() å¯ä»¥é€šè¿‡ç»™ key ä¼ é€’å‡½æ•°çš„æ–¹å¼è‡ªå®šä¹‰æ¯”å¤§å°çš„æ ‡å‡†ï¼Œä¾‹å¦‚ï¼š\n\u0026gt;\u0026gt;\u0026gt; coords = [ [37, -144], [-22, -115], [56, -163] ] \u0026gt;\u0026gt;\u0026gt; max(coords, key=lambda coord: coord[0]) [56, -163] ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"a3b640994d0e1edd854623db9dac91b8","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/lectures/lec11/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/lectures/lec11/","section":"notes","summary":"Copying æˆ‘ä»¬å¹³æ—¶å†™çš„\nlistA = [0, 1, 2, 3] æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªåå« \u0026ldquo;listA\u0026rdquo; çš„æŒ‡é’ˆæŒ‡å‘äº† [0, 1, 2, 3] è¿™ä¸ªå¯¹è±¡ã€‚\næ‹·è´åˆ†æ·±æ‹·è´å’Œæµ…æ‹·è´ä¸¤ç§ã€‚æµ…æ‹·è´åªæ˜¯è®©ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘äº†åŒä¸€ä¸ªå¯¹è±¡ï¼Œè€Œæ·±æ‹·è´ä¼šå°†å¯¹è±¡å¤åˆ¶ä¸€éï¼Œç„¶åè®©æ–°æŒ‡é’ˆæŒ‡å‘æ–°å¤åˆ¶çš„å¯¹è±¡ã€‚ä¾‹å¦‚ï¼š\n\u0026gt;\u0026gt;\u0026gt; listA = [0, 1, 2, 3] \u0026gt;\u0026gt;\u0026gt; listB = listA # æµ…æ‹·è´ \u0026gt;\u0026gt;\u0026gt; listC = list(listA) # æ·±æ‹·è´ \u0026gt;\u0026gt;\u0026gt; listA[0] = 1 \u0026gt;\u0026gt;\u0026gt; listB, listC ([1, 1, 2, 3], [0, 1, 2, 3]) Built-in Functions for Iterables ä¸€äº›å¸¸è§çš„å†…ç½®å‡½æ•°æœ‰ï¼š","tags":null,"title":"UCB-CS61A Lecture 11: Sequences","type":"docs"},{"authors":null,"categories":null,"content":"Introduction People want threads for the following reasons:\nPeople want their computers to \u0026ldquo;seemingly\u0026rdquo; simultaneously do multiple jobs. Programmers can use multiple threads to write simple and elegant code. prime.c in Lab 1 is a good example, it uses multiple processes but the principle is similar. We can utilize multiple threads to speed up our programs on a multi-core machine. A thread is an abstract concept that can be viewed as a serial execution. The state of an execution includes the PC, the registers and a stack. Operating systems interleave the execution of multiple threads, which is implemented in mainly two ways:\nMulti-core machine: a machine with multiple CPU cores can naturally interleave the executions. There are automatically multiple sets of PCs, registers, etc. Thread switching. Even on a multi-core machine, we need to focus on how a single core an execute multiple threads by executing the first one for a while and switching to the second and so forth. An important issue about threads is: does threads have shared memory? If threads have shared memory, then each thread\u0026rsquo;s changes are visible to other threads and we need locks to access shared resources. In xv6, kernel threads do have shared memories while user processes with only one thread don\u0026rsquo;t have shared memory - each thread lives in the address space of its corresponding process. In real OS like Linux, which supports user processes to have multiple threads, threads of the same process share the same address space.\nThere are several challenges for implementing a threading system:\nHow to decide which thread to execute - scheduling. What and where to save/restore the thread state. How to deal with compute bound threads: threads may not voluntarily yield the CPU ,so we need a method to automatically revoking control from some long running compute bound process, setting it aside and running it later. The answer to the third question is timer interrupts. There is a piece of hardware on the CPU that periodically generates interrupt signals and the signals are somehow transferred to the kernel. So even if the process is running in user level, the coming signal will interrupt it and give the control to the kernel. Then the kernel voluntarily yields the CPU.\nThis kind of policy is called preemptive scheduling. Here the \u0026ldquo;preemptive\u0026rdquo; means that even if the user process is unwilling to yield the CPU, our kernel will force it to quit. Correspondingly another policy is called voluntary scheduling, which counts on processes to proactively yield the CPU. An interesting thing is, xv6 implements preemptive scheduling by letting kernel threads voluntarily yield CPU.\nKernel threads have multiple states, some of which are listed below:\nRUNNING: the thread is currently running on one of the core. RUNNABLE: the thread is able to run and wants to be scheduled onto CPU as soon as possible. SLEEPING: the thread cannot run currently (maybe because it\u0026rsquo;s waiting for I/O). Preemptive scheduling is responsible for changing a running thread to a runnable thread. In xv6, since kernel threads share memory, thread state only includes CPU information. A running thread\u0026rsquo;s state is stored in the CPU hardware while a runnable/sleeping thread\u0026rsquo;s state, i.e. PC and registers, is stored elsewhere.\nA Roadmap for Thread Switching Generally, in xv6, a user process cannot directly switch to another user process, it must realize it in an indirect way: the user process first falls into the kernel, during which the user level information is stored in the trapframe, then it saves the context of its kernel thread, switches to another process\u0026rsquo;s kernel thread by restoring the context. At last it goes back to the user space of another process.\nA more detailed picture is described below: suppose we have two processes P1 and P2, P1 is running using its own user stack. Now a timer interrupt comes and the execution of P1 is suspended. In trampoline.S, it stores the user level information in the trapframe, switches to the corresponding kernel stack, and now it\u0026rsquo;s P1\u0026rsquo;s kernel thread running.\nThe kernel thread voluntarily yields the CPU by calling a function swtch(). In swtch(), the context of P1\u0026rsquo;s kernel thread (i.e. values of registers) is saved and a scheduler thread\u0026rsquo;s context is restored. After restoring scheduler thread\u0026rsquo;s context, our execution flow jumps to the return address of an swtch() call in scheduler thread\u0026rsquo;s function scheduler(). Also, the stack is switched to the scheduler\u0026rsquo;s stack (this stack is allocated in entry.S).\nThe scheduler thread is responsible for choosing an runnable thread and switching to it. After deciding which thread to switch to, the scheduler thread does the same procedure again: it calls swtch(), saves the context and restore the context of the target process\u0026rsquo;s kernel thread. Now the execution flow jumps to the return address of an swtch() call in P2\u0026rsquo;s kernel thread. Also the stack is switched to P2\u0026rsquo;s kernel stack. Finally, P2 restores user level information through P2\u0026rsquo;s trapframe and goes back to the user space.\nWhere are the context stored?\nContexts of processes\u0026rsquo;s kernel threads are stored in p-\u0026gt;context. Context of scheduler thread is stored in the CPU struct.\nA process is either running in the user space, or running in the kernel level, or it\u0026rsquo;s not running at all. In the last case the information of the process is stored in the combination of trapframe and thread context.\nCode: spin.c struct cpu { struct proc *proc; // The process running on this cpu, or null. struct context context; // swtch() here to enter scheduler(). int noff; // Depth of push_off() nesting. int intena; // Were interrupts enabled before push_off()? }; struct proc { struct spinlock lock; // p-\u0026gt;lock must be held when using these: enum procstate state; // Process state struct proc *parent; // Parent process void *chan; // If non-zero, sleeping on chan int killed; // If non-zero, have been killed int xstate; // Exit status to be returned to parent's wait int pid; // Process ID // these are private to the process, so p-\u0026gt;lock need not be held. uint64 kstack; // Virtual address of kernel stack uint64 sz; // Size of process memory (bytes) pagetable_t pagetable; // User page table struct trapframe *trapframe; // data page for trampoline.S struct context context; // swtch() here to run process struct file *ofile[NOFILE]; // Open files struct inode *cwd; // Current directory char name[16]; // Process name (debugging) }; process struct and CPU struct are shown above. In struct proc we can see variable state representing the status of the process, kstack representing the address of the process\u0026rsquo;s kernel stack, trapframe storing user level information and context storing kernel thread context. In struct cpu there\u0026rsquo;s also a context storing the context of scheduler thread.\nWe use a demo program, spin.c, to illustrate the complete procedure of thread switching.\n// // spin.c // a demo program illustrating the principle of thread switching. // #include \u0026quot;kernel/types.h\u0026quot; #include \u0026quot;user/user.h\u0026quot; int main (int argc, char *argv[]) { int pid; char c; pid = fork(); if (pid == 0) { c = '/'; } else { printf(\u0026quot;parent pid is %d, child is %d\\n\u0026quot;, getpid(), pid); c = '\\\\'; } for (int i = 0; ; i++) if (i % 1000000 == 0) write(2, \u0026amp;c, 1); exit(0); } In spin.c two processes print / and \\ respectively. Due to timer interrupt, two kinds of slashes are printed alternatively. We use GDB to set a breakpoint at where devintr() recognizes an timer interrupt.\nTip: GDB Usage\nWe can set breakpoints at a particular line in the source code. In this case, we can use b trap.c:207.\nIf we check the trapframe by p/x p-\u0026gt;trapframe:\n$6 = {kernel_satp = 0x8000000000087fff, kernel_sp = 0x3fffff8000, kernel_trap = 0x80002880, epc = 0x62, kernel_hartid = 0x0, ra = 0x62, sp = 0x2fb0, gp = 0x505050505050505, tp = 0x505050505050505, t0 = 0x505050505050505, t1 = 0x505050505050505, t2 = 0x505050505050505, s0 = 0x2fe0, s1 = 0x1c4a4111, a0 = 0x1, a1 = 0x2fbf, a2 = 0x1, a3 = 0x3ea0, a4 = 0x1400, a5 = 0x99691, a6 = 0x505050505050505, a7 = 0x10, s2 = 0xf4240, s3 = 0x20, s4 = 0x146b, s5 = 0x13f0, s6 = 0x505050505050505, s7 = 0x505050505050505, s8 = 0x505050505050505, s9 = 0x505050505050505, s10 = 0x505050505050505, s11 = 0x505050505050505, t3 = 0x505050505050505, t4 = 0x505050505050505, t5 = 0x505050505050505, t6 = 0x505050505050505} The epc points at 0x62, by looking up in spin.asm, this is addiw s1, s1, 1 instruction, which demonstrates that our process is interrupted when doing infinite calculation.\nWe continue and go into the yield() function, which makes the kernel thread voluntarily yield the CPU.\nvoid yield(void) { struct proc *p = myproc(); acquire(\u0026amp;p-\u0026gt;lock); p-\u0026gt;state = RUNNABLE; sched(); release(\u0026amp;p-\u0026gt;lock); } Before doing jobs, yield() firstly acquires the lock of the current process because it\u0026rsquo;s about to change the state of the process to RUNNABLE. We want this procedure to be atomic to other cores because the invariant that p-\u0026gt;state represents the current status of the process is temporarily violated: the process is indeed running, but the status becomes RUNNABLE. If other cores\u0026rsquo; scheduler threads were able to see the change now and decide to execute this process, our current process would be running simultaneously on multiple CPUs, which is a disaster.\nWe go into sched(). After finishing several sanity checks, sched() calls swtch(), which is the core function of thread switching.\nswtch(\u0026amp;p-\u0026gt;context, \u0026amp;c-\u0026gt;context); This line will save the current context into p-\u0026gt;context and restore c-\u0026gt;context. We can use p/x cpus[0].context to check the context we are going to switch to:\n$12 = {ra = 0x80001fce, sp = 0x8000a7c0, s0 = 0x8000a810, s1 = 0x800121a0, s2 = 0x2, s3 = 0x80017768, s4 = 0x80011950, s5 = 0x1, s6 = 0x80011970, s7 = 0x1, s8 = 0x3, s9 = 0x0, s10 = 0x0, s11 = 0x0} We are particularly interested in the ra register because it determines where we\u0026rsquo;ll go to after returning from swtch(). We use x/i cpus[0].context-\u0026gt;ra:\n0x80001fce \u0026lt;scheduler+138\u0026gt;: sd zero,24(s4) We are assured that after executing swtch(), we will be in the scheduler thread.\nswtch.S is written in assembly. It stores and restores values according to a0 and a1, which are registers containing the first and the second argument, i.e. p-\u0026gt;context and c-\u0026gt;context.\nWhy don\u0026rsquo;t we save the PC register? Without saving the PC register, how can we know which instruction to jump to?\nWe use the ra register to indirectly record PC. When swtch() returns by executing ret, the value in ra will be put into PC, which is exactly the next instruction of call swtch in scheduler().\nThere are 32 general registers in RISC-V, why swtch() only saves 14 of them?\nIn C code, swtch() is only a normal function call, according to the calling convention, swtch() only need to carefully manage callee-saved registers. Even if swtch() do nothing with caller-saved registers, the caller will be able to restore the caller-saved registers (from the kernel stack or somewhere). This is ensured by the C compiler.\nAfter executing 28 ld and sd instructions, we now use x $sp to print the stack:\n0x8000a7c0 \u0026lt;stack0+3984\u0026gt;: 0x00000000 our stack pointer now points to stack0, which is the stack we allocate to the scheduler thread during booting. If we use where to unwind the stack information, we\u0026rsquo;ll get\n#0 0x00000000800026b8 in swtch () #1 0x0000000080001fce in scheduler () at kernel/proc.c:489 #2 0x0000000080000f2c in main () at kernel/main.c:44 We\u0026rsquo;re now in scheduler thread, which is created at the last line of main.c during booting. We return from a swtch() call which scheduler() makes a while ago.\nscheduler() loops and tries to find process that is RUNNABLE state. It\u0026rsquo;s worth attention that we need to acquire lock before checking the status and doing subsequent jobs. Generally, after we acquire a process lock, we usually do the following jobs to realize thread switching:\nModify the status of the target process. Call swtch() to save and restore context. Previously we talked about acquiring lock can avoid other cores discovering processes in temporary incorrect state. Another significant point of acquiring lock is that we explicitly turn off interrupts in acquire(), this is important because we don\u0026rsquo;t want to respond to timer interrupts when doing swtch(), otherwise the register values would be damaged.\nAfter scheduler() decides the target process to switch to, it will call swtch() again, save scheduler thread\u0026rsquo;s context into c-\u0026gt;context, restore context in p-\u0026gt;context (another process\u0026rsquo;s kernel thread\u0026rsquo;s context), and resume executing that process.\nHow can a process be switched to at the first time, since it hasn\u0026rsquo;t called swtch() yet?\nIn xv6 there is a function forkret(), it serves as the target address of the first \u0026ldquo;fake\u0026rdquo; context: in allocproc(), we set up a fake context with ra pointing to forkret() and sp pointing to the corresponding kernel stack. We don\u0026rsquo;t care about other registers\u0026rsquo; values before the first execution. The only thing forkret() does is to release the process lock.\nIn addition, there is a situation in which xv6 creates a \u0026ldquo;fake\u0026rdquo; trapframe: in userinit(), xv6 creates a fake trapframe with epc=0 and sp=PGSIZE. In other situations, a new process is created by fork() and fork() copies the trapframe of parent process.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"ccd04d3f08e4a1fc57e8fe2cdb6e35cd","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-operating-system/lectures/lec11/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-operating-system/lectures/lec11/","section":"notes","summary":"Introduction People want threads for the following reasons:\nPeople want their computers to \u0026ldquo;seemingly\u0026rdquo; simultaneously do multiple jobs. Programmers can use multiple threads to write simple and elegant code. prime.c in Lab 1 is a good example, it uses multiple processes but the principle is similar.","tags":null,"title":"MIT-6.S081 Lecture 11: Thread Switching","type":"docs"},{"authors":null,"categories":null,"content":"Abstraction Barriers æŠ½è±¡æ˜¯ä¸€å±‚ä¸€å±‚çš„ï¼Œå¥½çš„ç¨‹åºè®¾è®¡åº”å½“åªä½¿ç”¨ä¸Šä¸€å±‚æŠ½è±¡æä¾›çš„æ¥å£ï¼Œä¸åº”è¯¥è·¨å±‚åœ°å»ä½¿ç”¨åº•å±‚çš„æ¥å£ã€‚\nDictionary Dictionary Selection ä¸€ä¸ªæœ‰ç”¨çš„ APIï¼š\n\u0026gt;\u0026gt;\u0026gt; people = {'alice': 'girl', 'bob': 'boy'} \u0026gt;\u0026gt;\u0026gt; people.get(\u0026quot;eve\u0026quot;, \u0026quot;ğŸ¤”\u0026quot;) ğŸ¤” dict.get(key, default=None) ä¼šè¿”å›å­—å…¸ dict ä¸­ key å¯¹åº”çš„ valueï¼Œå¦‚æœ key ä¸å­˜åœ¨åˆ™ä¼šè¿”å› default çš„å†…å®¹ã€‚\nDictionary Rules å­—å…¸çš„ key ä¸èƒ½æ˜¯ list, dictionary ç­‰ mutable çš„ä¸œè¥¿ï¼Œä¸” key æ˜¯ä¸¤ä¸¤ä¸åŒçš„ï¼Œä½† value å¯ä»¥æ˜¯ä»»æ„å†…å®¹ã€‚\nDictionary Iteration \u0026gt;\u0026gt;\u0026gt; insects = {\u0026quot;spiders\u0026quot;: 8, \u0026quot;centipedes\u0026quot;: 100, \u0026quot;bees\u0026quot;: 6} \u0026gt;\u0026gt;\u0026gt; for name in insects: \u0026gt;\u0026gt;\u0026gt; print(insects[name]) 8 100 6 éå†å­—å…¸æ—¶æŒ‰ç…§ key-value pair è¢«åŠ å…¥å­—å…¸æ—¶çš„é¡ºåºè®¿é—®ã€‚\nDictionary Comprehensions General syntax:\n{key: value for \u0026lt;name\u0026gt; in \u0026lt;iter exp\u0026gt;} Example:\nsquares = {x: x * x for x in range(3, 6)} ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"20c29e429114d75aac7004c4efa7815b","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/lectures/lec12/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/lectures/lec12/","section":"notes","summary":"Abstraction Barriers æŠ½è±¡æ˜¯ä¸€å±‚ä¸€å±‚çš„ï¼Œå¥½çš„ç¨‹åºè®¾è®¡åº”å½“åªä½¿ç”¨ä¸Šä¸€å±‚æŠ½è±¡æä¾›çš„æ¥å£ï¼Œä¸åº”è¯¥è·¨å±‚åœ°å»ä½¿ç”¨åº•å±‚çš„æ¥å£ã€‚\nDictionary Dictionary Selection ä¸€ä¸ªæœ‰ç”¨çš„ APIï¼š\n\u0026gt;\u0026gt;\u0026gt; people = {'alice': 'girl', 'bob': 'boy'} \u0026gt;\u0026gt;\u0026gt; people.get(\u0026quot;eve\u0026quot;, \u0026quot;ğŸ¤”\u0026quot;) ğŸ¤” dict.get(key, default=None) ä¼šè¿”å›å­—å…¸ dict ä¸­ key å¯¹åº”çš„ valueï¼Œå¦‚æœ key ä¸å­˜åœ¨åˆ™ä¼šè¿”å› default çš„å†…å®¹ã€‚","tags":null,"title":"UCB-CS61A Lecture 12: Data Abstraction","type":"docs"},{"authors":null,"categories":null,"content":"Tree: Data Abstraction æˆ‘ä»¬å¸Œæœ› tree è¿™ä¸ªæŠ½è±¡æ•°æ®ç±»å‹æä¾›å¦‚ä¸‹çš„å‡ ä¸ª API:\ntree(label, branches)ï¼šåˆ›å»ºä»¥ label ä¸ºæ ¹ï¼Œbranches ä¸ºå­æ ‘çš„æ ‘ (branches æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œå…¶ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ª tree)ã€‚ label(tree)ï¼šè¿”å›ä¸€ä¸ªæ ‘ tree çš„æ ¹ã€‚ branches(tree) è¿”å›ä¸€ä¸ªæ ‘çš„å­æ ‘çš„åˆ—è¡¨ã€‚ is_leaf(tree) åˆ¤æ–­ tree æ˜¯ä¸æ˜¯ä¸€ä¸ªå¶å­ (æ²¡æœ‰å­æ ‘)ã€‚ Tree: A Simple Implementation ä½¿ç”¨åµŒå¥—çš„åˆ—è¡¨å»å®ç°ï¼š\ndef tree(label, branches=[]): return [label] + list(branches) def label(tree): return tree[0] def branches(tree): return tree[1:] def is_leaf(tree): return len(branches(tree)) == 0 Exercise: List of Leaves def leaves(t): \u0026quot;\u0026quot;\u0026quot;Return a list containing the leaf labels of T. \u0026gt;\u0026gt;\u0026gt; t = tree(20, [tree(12, [tree(9, [tree(7), tree(2)]), tree(3)]), tree(8, [tree(4), tree(4)])]) \u0026gt;\u0026gt;\u0026gt; leaves(t) [7, 2, 3, 4, 4] \u0026quot;\u0026quot;\u0026quot; if is_leaf(t): return [label(t)] else leaf_labels = [leaves(b) for b in branches(t)] return sum(leaf_labels, []) æ³¨ï¼šsum() å‡½æ•°å¦‚æœæ¥å—ä¸¤ä¸ª listï¼Œå…¶ä¸­ç¬¬ä¸€ä¸ª list é‡Œæ˜¯è‹¥å¹²ä¸ª listï¼Œé‚£ä¹ˆå®ƒçš„è¡Œä¸ºæ˜¯å°†ç¬¬ä¸€ä¸ª list ä¸­çš„æ‰€æœ‰ list ä¸­çš„å…ƒç´ æ•´åˆæˆä¸€ä¸ªå¤§ listï¼Œæ¥åœ¨ç¬¬äºŒä¸ªå‚æ•°çš„ list åé¢ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"4626ab633fb0ac2ecd4d6bf3d79e67e8","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/lectures/lec13/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/lectures/lec13/","section":"notes","summary":"Tree: Data Abstraction æˆ‘ä»¬å¸Œæœ› tree è¿™ä¸ªæŠ½è±¡æ•°æ®ç±»å‹æä¾›å¦‚ä¸‹çš„å‡ ä¸ª API:\ntree(label, branches)ï¼šåˆ›å»ºä»¥ label ä¸ºæ ¹ï¼Œbranches ä¸ºå­æ ‘çš„æ ‘ (branches æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œå…¶ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ª tree)ã€‚ label(tree)ï¼šè¿”å›ä¸€ä¸ªæ ‘ tree çš„æ ¹ã€‚ branches(tree) è¿”å›ä¸€ä¸ªæ ‘çš„å­æ ‘çš„åˆ—è¡¨ã€‚ is_leaf(tree) åˆ¤æ–­ tree æ˜¯ä¸æ˜¯ä¸€ä¸ªå¶å­ (æ²¡æœ‰å­æ ‘)ã€‚ Tree: A Simple Implementation ä½¿ç”¨åµŒå¥—çš„åˆ—è¡¨å»å®ç°ï¼š","tags":null,"title":"UCB-CS61A Lecture 13: Trees","type":"docs"},{"authors":null,"categories":null,"content":"Objects å¯¹è±¡ (object) æ˜¯ä¸€ç»„æ•°æ®å’Œè¡Œä¸º (å‡½æ•°) çš„é›†åˆã€‚åœ¨ Python ä¸­æ‰€æœ‰çš„ value éƒ½æ˜¯å¯¹è±¡ï¼Œå¯¹è±¡æœ‰ä¸€ç³»åˆ—å±æ€§ (attribute) ä¹Ÿæœ‰ä¸€ç³»åˆ—æ–¹æ³• (method)ã€‚æ¯”å¦‚ Python ä¸­çš„å­—ç¬¦ä¸²å¯ä»¥é€šè¿‡ç´¢å¼•çš„æ–¹å¼è·å–å…·ä½“ä½ç½®çš„æ•°æ®ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ upper(), lower() ç­‰æ–¹æ³•å¯¹å…¶è¿›è¡Œæ“ä½œã€‚\nList Mutation append() å’Œ extend() è¿™ä¸¤ä¸ªæ–¹æ³•çš„è¡Œä¸ºæ˜¯æœ‰åŒºåˆ«çš„ï¼š\nappend() åªèƒ½å‘ list çš„åé¢æ·»åŠ ä¸€ä¸ªå…ƒç´ ã€‚å¦‚æœ append() çš„å‚æ•°æ˜¯ä¸€ä¸ª listï¼Œé‚£ä¹ˆå®ƒä¼šåœ¨æœ¬ list çš„åé¢æ·»åŠ ä¸€ä¸ªå…ƒç´ ï¼Œè¿™ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ª list (å½¢æˆäº†ä¸€ä¸ªåµŒå¥—çš„ list) extend() çš„å‚æ•°å¿…é¡»æ˜¯ä¸€ä¸ª iterable çš„ä¸œè¥¿ï¼Œå®ƒä¼šå°†è¿™ä¸ªä¸œè¥¿é‡Œçš„æ‰€æœ‰å…ƒç´ æ·»åŠ åˆ°æœ¬ list ä¸­ã€‚ \u0026gt;\u0026gt;\u0026gt; s1, s2 = [2, 3] \u0026gt;\u0026gt;\u0026gt; t = [4, 5] \u0026gt;\u0026gt;\u0026gt; s1.append(t) \u0026gt;\u0026gt;\u0026gt; s2.extend(t) \u0026gt;\u0026gt;\u0026gt; s1 [2, 3, [4, 5]] \u0026gt;\u0026gt;\u0026gt; s2 [2, 3, 4, 5] remove(v) æ–¹æ³•ç”¨äºåˆ é™¤ list ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´  v (å¦‚æœ list ä¸­æ²¡æœ‰ v ä¼šæŠ¥é”™)ã€‚\nTuples tuple å’Œ list åŸºæœ¬ç›¸åŒï¼Œé™¤äº† tuple ä¸­çš„å…ƒç´ ä¸å¯ä¿®æ”¹ã€‚åˆ›å»º tuple åº”ä½¿ç”¨å°æ‹¬å·ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯å¦‚æœè¦åˆ›å»ºåªæœ‰ä¸€ä¸ªå…ƒç´  v çš„ tupleï¼Œåº”å½“å†™æˆ (v,) è€Œä¸æ˜¯ (v)ã€‚\nlist ä¸­ä¸€äº›åªè¯»çš„æ“ä½œ tuple ä¸­åŒæ ·æœ‰ï¼Œæ¯”å¦‚ slicingï¼Œ+ åˆå¹¶ï¼Œin åˆ¤æ–­æŸä¸ªå…ƒç´ æ˜¯å¦å­˜åœ¨ç­‰ç­‰ã€‚\nImmutability vs. Mutability immutable çš„ value ä¸€æ—¦åˆ›å»ºå°±ä¸èƒ½ä¿®æ”¹ã€‚å¸¸è§çš„ immutable çš„ä¾‹å­æœ‰ int, float, string, tuple ç­‰ã€‚æ³¨ï¼šæˆ‘ä»¬å¹³æ—¶å¯ä»¥å†™ a += 2 è¿™ç§æ“ä½œä¿®æ”¹å˜é‡çš„å€¼ï¼Œæœ¬è´¨ä¸Šæ˜¯è®© a è¿™ä¸ªå˜é‡åä¸ä¸€ä¸ªæ–°çš„ int value æ†ç»‘ï¼Œè€Œä¸æ˜¯å¯¹åŸå€¼çš„ä¿®æ”¹ã€‚\nå¦‚æœä¸€ä¸ª imuutable çš„å¯¹è±¡é‡Œçš„å…ƒç´ æ˜¯ mutable çš„ (æ¯”å¦‚ tuple çš„å…ƒç´ æ˜¯ list)ï¼Œé‚£ä¹ˆè¯¥å…ƒç´ æ˜¯å¯ä»¥ä¿®æ”¹çš„ï¼š\n\u0026gt;\u0026gt;\u0026gt; t = (1, [2, 3]) \u0026gt;\u0026gt;\u0026gt; t[1][0] = 99 \u0026gt;\u0026gt;\u0026gt; t[1][1] = \u0026quot;problem\u0026quot; \u0026gt;\u0026gt;\u0026gt; t (1, [99, 'problem']) Equality of contents vs. Identity of objects\n== å’Œ is è¿™ä¸¤ä¸ªæ¯”è¾ƒæ–¹æ³•æ˜¯æœ‰åŒºåˆ«çš„ã€‚== çš„è¿”å›å€¼ä¸º True å½“ä¸”ä»…å½“ä¸¤ä¸ªå¯¹è±¡çš„ value ç›¸åŒã€‚è€Œ is è¦æ±‚ä¸¤ä¸ªå˜é‡åæŒ‡å‘åŒä¸€ä¸ªå¯¹è±¡ã€‚is è¿”å›å€¼ä¸º True çš„ == å¿…å®šä¸º Trueï¼Œåä¹‹åˆ™ä¸ä¸€å®šã€‚\n\u0026gt;\u0026gt;\u0026gt; list1, list2 = [1, 2, 3], [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; list1 == list2 True \u0026gt;\u0026gt;\u0026gt; list1 is list2 False \u0026gt;\u0026gt;\u0026gt; list2 = list1 \u0026gt;\u0026gt;\u0026gt; list1 is list2 True Mutable Functions Python å‡½æ•°å¯ä»¥å¯¹ parent frame ä¸­çš„ mutable çš„å¯¹è±¡è¿›è¡Œä¿®æ”¹ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š\ndef make_withdraw_account(initial): balance = [initial] def withdraw(amount): if balance[0] - amount \u0026lt; 0: return 'Insufficient funds' balance[0] -= amount return balance[0] return withdraw æ³¨ï¼šå¦‚æœæˆ‘ä»¬æƒ³è¦ç”¨ä¸€ä¸ªå˜é‡ balance æ¥å­˜å‚¨é‡‘é¢ï¼Œé‚£ä¹ˆåœ¨ withdraw() å‡½æ•°ä¸­å°±è¦ç”¨ nonlocal balance æ¥å£°æ˜ä¸‹é¢çš„ balance æ˜¯å¯¹ parent frame ä¸­çš„å˜é‡è¿›è¡Œçš„æ“ä½œã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"948f7432f196a1cc7c4ee014a5372b28","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/lectures/lec14/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/lectures/lec14/","section":"notes","summary":"Objects å¯¹è±¡ (object) æ˜¯ä¸€ç»„æ•°æ®å’Œè¡Œä¸º (å‡½æ•°) çš„é›†åˆã€‚åœ¨ Python ä¸­æ‰€æœ‰çš„ value éƒ½æ˜¯å¯¹è±¡ï¼Œå¯¹è±¡æœ‰ä¸€ç³»åˆ—å±æ€§ (attribute) ä¹Ÿæœ‰ä¸€ç³»åˆ—æ–¹æ³• (method)ã€‚æ¯”å¦‚ Python ä¸­çš„å­—ç¬¦ä¸²å¯ä»¥é€šè¿‡ç´¢å¼•çš„æ–¹å¼è·å–å…·ä½“ä½ç½®çš„æ•°æ®ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ upper(), lower() ç­‰æ–¹æ³•å¯¹å…¶è¿›è¡Œæ“ä½œã€‚\nList Mutation append() å’Œ extend() è¿™ä¸¤ä¸ªæ–¹æ³•çš„è¡Œä¸ºæ˜¯æœ‰åŒºåˆ«çš„ï¼š\nappend() åªèƒ½å‘ list çš„åé¢æ·»åŠ ä¸€ä¸ªå…ƒç´ ã€‚å¦‚æœ append() çš„å‚æ•°æ˜¯ä¸€ä¸ª listï¼Œé‚£ä¹ˆå®ƒä¼šåœ¨æœ¬ list çš„åé¢æ·»åŠ ä¸€ä¸ªå…ƒç´ ï¼Œè¿™ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ª list (å½¢æˆäº†ä¸€ä¸ªåµŒå¥—çš„ list) extend() çš„å‚æ•°å¿…é¡»æ˜¯ä¸€ä¸ª iterable çš„ä¸œè¥¿ï¼Œå®ƒä¼šå°†è¿™ä¸ªä¸œè¥¿é‡Œçš„æ‰€æœ‰å…ƒç´ æ·»åŠ åˆ°æœ¬ list ä¸­ã€‚ \u0026gt;\u0026gt;\u0026gt; s1, s2 = [2, 3] \u0026gt;\u0026gt;\u0026gt; t = [4, 5] \u0026gt;\u0026gt;\u0026gt; s1.","tags":null,"title":"UCB-CS61A Lecture 14: Mutability","type":"docs"},{"authors":null,"categories":null,"content":"Syntax Tree ä¸­é—´çš„èŠ‚ç‚¹ç§°ä¸º non-terminalï¼Œå¶å­èŠ‚ç‚¹ç§°ä¸º terminalï¼Œä¸€ä¸ª syntax tree æè¿°äº†ä¸€ä¸ªå¥å­çš„å¥æ³•ç»“æ„ã€‚\næˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸Šä¸€è¯¾ä¸­æåˆ°çš„åµŒå¥—åˆ—è¡¨çš„æ–¹æ³•ä½œä¸º syntax tree è¿™ä¸€æŠ½è±¡çš„å®ç°ï¼š\ndef phrase(tag, branches): return tree(tag, branches) def word(tag, text): return tree([tag, text]) def text(word): return label(word)[1] def tag(t): \u0026quot;\u0026quot;\u0026quot;Return the tag of a phrase or word.\u0026quot;\u0026quot;\u0026quot; if is_leaf(t): return label(t)[0] else: return label(t) Generating Sentences ä¸€ä¸ª language model æè¿°äº†æ¯ç§æ–‡æœ¬å‡ºç°çš„æ¦‚ç‡ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ sampling çš„æ–¹æ³•æ ¹æ®ä¸€ä¸ª language model æ¥ç”Ÿæˆè¯­è¨€ã€‚\nlanguage model ä¸­æœ‰å¾ˆå¤š syntax treeï¼Œæ ‘ä¸Šçš„æ¯ä¸ªèŠ‚ç‚¹éƒ½è¢«æ‰“äº†æ ‡ç­¾ã€‚æˆ‘ä»¬é¦–å…ˆéå†æ‰€æœ‰çš„æ ‘æ¥è·å–æ¯ç§ tag çš„èŠ‚ç‚¹åˆ—è¡¨ï¼š\ndef index_trees(trees): index = {} for t in trees: for tag, node in nodes(t): if tag not in index: index[tag] = [] index[tag].append(node) return index trees = [tokens_to_parse_tree(s) for s in all_sentences()] tree_index = index_trees(trees) æ¥ä¸‹æ¥æˆ‘ä»¬å¯ä»¥æ ¹æ® index åˆ—è¡¨æ¥ç”Ÿæˆä¸€å¥æ–°çš„è¯ï¼šæˆ‘ä»¬ä»ä¸€æ£µå·²æœ‰çš„ syntax tree å¼€å§‹ï¼Œæ¯æ¬¡éšæœºå†³å®šæ˜¯å¦å°†ä¸€ä¸ªå­æ ‘æ¢æˆ tag ç›¸åŒçš„å¦ä¸€ä¸ªå­æ ‘ï¼š\ndef gen_tree(t, tree_index, flip): new_branches = [] if is_leaf(t): return t for b in branches(t): if flip(): b = random.choice(tree_index[tag(b)]) new_branches.append(gen_tree(b, tree_index, flip)) return phrase(tag(t), new_branches) ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"a004330317bd69dd88815ec7909d5a36","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/lectures/lec15/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/lectures/lec15/","section":"notes","summary":"Syntax Tree ä¸­é—´çš„èŠ‚ç‚¹ç§°ä¸º non-terminalï¼Œå¶å­èŠ‚ç‚¹ç§°ä¸º terminalï¼Œä¸€ä¸ª syntax tree æè¿°äº†ä¸€ä¸ªå¥å­çš„å¥æ³•ç»“æ„ã€‚\næˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸Šä¸€è¯¾ä¸­æåˆ°çš„åµŒå¥—åˆ—è¡¨çš„æ–¹æ³•ä½œä¸º syntax tree è¿™ä¸€æŠ½è±¡çš„å®ç°ï¼š\ndef phrase(tag, branches): return tree(tag, branches) def word(tag, text): return tree([tag, text]) def text(word): return label(word)[1] def tag(t): \u0026quot;\u0026quot;\u0026quot;Return the tag of a phrase or word.","tags":null,"title":"UCB-CS61A Lecture 15: Syntax","type":"docs"},{"authors":null,"categories":null,"content":"Iterators è¿­ä»£å™¨ (iterator) æ˜¯ä¸€ç§å¯¹è±¡ï¼Œæä¾›äº†å¯¹æŸä¸ª itarable çš„ sequential accessã€‚iter(iterable) ä¼šè¿”å›ä¸€ä¸ªæŒ‡å‘ iterable ç¬¬ä¸€ä¸ªå…ƒç´ çš„ iteratorï¼Œä¹‹åå¯ä»¥ç”¨ next() å‡½æ•°æ¥æŸ¥çœ‹åç»­çš„å…ƒç´ ã€‚\ntoppings = [\u0026quot;pineapple\u0026quot;, \u0026quot;pepper\u0026quot;, \u0026quot;mushroom\u0026quot;, \u0026quot;roasted red pepper\u0026quot;] topperator = iter(toppings) next(topperator) # 'pineapple' next(topperator) # 'pepper' next(topperator) # 'mushroom' next(topperator) # 'roasted red pepper' next(topperator) # âŒ StopIteration exception æ³¨ï¼šå¦‚æœç»™ iter() ä¼ å…¥çš„å‚æ•°æ˜¯ iteratorï¼Œé‚£ä¹ˆå®ƒä¼šè¿”å›ä¸€ä¸ªä¸€æ ·çš„ iteratorã€‚\n\u0026gt;\u0026gt;\u0026gt; topperator2 = iter(topperator) \u0026gt;\u0026gt;\u0026gt; topperator is topperator2 True list, tuple, dictionary, string, range éƒ½å±äº iterableï¼Œè¿™é‡Œæä¸€ä¸‹å¯¹äºå­—å…¸çš„è®¿é—®ï¼šä» Python 3.6 å¼€å§‹ï¼Œå­—å…¸ä¸­çš„å…ƒç´ æŒ‰ç…§å®ƒä»¬æ’å…¥çš„é¡ºåºæ’åˆ—ï¼Œä½¿ç”¨ iter(dic.keys()) å¯ä»¥è·å¾— key çš„ iteratorï¼›ä½¿ç”¨ iter(dic.values()) å¯ä»¥è·å¾— value çš„ iteratorï¼›ä½¿ç”¨ iter(dic.items)) å¯ä»¥è·å¾— key-value pair çš„ iteratorã€‚\nå¦‚æœåœ¨ for å¾ªç¯ä¸­ä½¿ç”¨ iteratorï¼Œé‚£ä¹ˆæ¯æ¬¡æ‰§è¡Œå®Œå¾ªç¯ä½“å Python éƒ½ä¼šè°ƒç”¨ next() è®© iterator æŒ‡å‘ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œç›´åˆ°æ²¡æœ‰æ›´å¤šå…ƒç´ ï¼š\nnums = range(1, 4) num_iter = iter(nums) first = iter(num_iter) # 1 for num in num_iter: print(num) # 2 # 3 # 4 Useful Bulit-in Functions ä¸€äº›æ¯”è¾ƒå¥½ç”¨çš„è¿”å› iterable çš„å‡½æ•°ï¼š\nlist(iterable)ï¼šè¿”å›ä¸€ä¸ª listï¼Œè¯¥ list ä¸­çš„å…ƒç´ æ˜¯ iterable ä¸­çš„å…ƒç´  (è¿™é‡Œä¼ å…¥çš„ä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ª iterator)ã€‚ tuple(iterable)ï¼šç±»ä¼¼ï¼Œè¿”å›ä¸€ä¸ª tupleã€‚ sorted(iterable) ï¼šè¿”å›ä¸€ä¸ª listï¼Œé‡Œé¢çš„å…ƒç´ æ˜¯æ’å¥½åºçš„ã€‚ ä¸€äº›æ¯”è¾ƒå¥½ç”¨çš„è¿”å› iterator çš„å‡½æ•°ï¼š\nmap(func, iterable) ä¼šå¯¹ iterable ä¸­çš„æ¯ä¸ªå…ƒç´  x æ‰§è¡Œ func(x)ï¼Œå¹¶è¿”å›ä¸€ä¸ª iteratorã€‚æˆ‘ä»¬å¯ä»¥ç”¨ list(map(func, iterable)) çš„æ–¹å¼æ¥è·å¾—åˆ—è¡¨ï¼Œè¿™å¥è¯çš„åŠŸèƒ½å’Œ [func(x) for x in iterable] ç­‰ä»·ã€‚\nfilter(func, iterable) ä¼šä¿ç•™ iterable ä¸­é‚£äº›æ»¡è¶³ func(x) ä¸º True çš„å…ƒç´  xï¼Œå¹¶è¿”å›ä¸€ä¸ª iteratorã€‚list(filter(func, iterable)) çš„åŠŸèƒ½å’Œ [x for x in iterable if func(x)] ç­‰ä»·ã€‚\nzip(*iterables) æ¥æ”¶ä¸¤ä¸ª iterableï¼Œå°†è¿™ä¸ª iterable å¤„äºç›¸åŒä¸‹æ ‡çš„å…ƒç´ ç»„æˆ pairï¼Œè¿”å›ä¸€ä¸ª pair list çš„ iteratorã€‚ä¾‹å¦‚ï¼š\nnum1, num2 = [1, 2, 3], [4, 5, 6] num_pairs = list(zip(num1, num2)) for n1, n2 in num_pairs: print(n1, n2) # 1 4 # 2 5 # 3 6 ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"e489955486c6134286b2e4e3049e7e9b","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/lectures/lec16/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/lectures/lec16/","section":"notes","summary":"Iterators è¿­ä»£å™¨ (iterator) æ˜¯ä¸€ç§å¯¹è±¡ï¼Œæä¾›äº†å¯¹æŸä¸ª itarable çš„ sequential accessã€‚iter(iterable) ä¼šè¿”å›ä¸€ä¸ªæŒ‡å‘ iterable ç¬¬ä¸€ä¸ªå…ƒç´ çš„ iteratorï¼Œä¹‹åå¯ä»¥ç”¨ next() å‡½æ•°æ¥æŸ¥çœ‹åç»­çš„å…ƒç´ ã€‚\ntoppings = [\u0026quot;pineapple\u0026quot;, \u0026quot;pepper\u0026quot;, \u0026quot;mushroom\u0026quot;, \u0026quot;roasted red pepper\u0026quot;] topperator = iter(toppings) next(topperator) # 'pineapple' next(topperator) # 'pepper' next(topperator) # 'mushroom' next(topperator) # 'roasted red pepper' next(topperator) # âŒ StopIteration exception æ³¨ï¼šå¦‚æœç»™ iter() ä¼ å…¥çš„å‚æ•°æ˜¯ iteratorï¼Œé‚£ä¹ˆå®ƒä¼šè¿”å›ä¸€ä¸ªä¸€æ ·çš„ iteratorã€‚","tags":null,"title":"UCB-CS61A Lecture 16: Iterators","type":"docs"},{"authors":null,"categories":null,"content":"Generators generator function ä¸­ä¸ä½¿ç”¨ return è¿”å›ç»“æœï¼Œè€Œä½¿ç”¨ yieldã€‚generator æ˜¯ä¸€ç§ iteratorï¼Œå®ƒé€šè¿‡ generator function æ¥é€ä¸ªåœ°è·å¾—ç»“æœã€‚è¿™é‡Œ generator function å¯ä»¥ç†è§£ä¸ºä¸€ä¸ªçŠ¶æ€æœºï¼Œå½“é‡åˆ° yield è¯­å¥æ—¶ï¼Œå®ƒä¼šå°†è‡ªå·±çš„æ‰§è¡ŒçŠ¶æ€æš‚æ—¶å°å­˜èµ·æ¥å¹¶è¿”å›ç»“æœã€‚ä¸‹ä¸€æ¬¡ generator å†æ¬¡è°ƒç”¨è¯¥å‡½æ•°æ—¶ï¼Œgenerator function å°†ä¼šä»ä¸Šä¸€æ¬¡ yield åçš„ç¬¬ä¸€æ¡è¯­å¥å¼€å§‹ç»§ç»­æ‰§è¡Œï¼Œç›´åˆ°é‡åˆ°ä¸‹ä¸€ä¸ª yieldã€‚å¦‚æœæ²¡æœ‰é‡åˆ° yield è€Œæ˜¯å‡½æ•°ä¸€ç›´æ‰§è¡Œåˆ°ç»“æŸï¼Œgenerator function ä¼šè¿”å›ä¸€ä¸ª StopIteration exceptionã€‚\nä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š\ndef evens(start, end): num = start + (start % 2) while num \u0026lt; end: yield num num += 2 for num in evens(55, 61): print(num) # 56 # 58 # 60 è¿™ä¸ªä¾‹å­çš„åŠŸèƒ½å’Œ\nevens = [num for num in range(55, 61) if num % 2 == 0] ç›¸åŒã€‚ä½¿ç”¨ generator çš„å¥½å¤„æ—¶ generator function æ¯æ¬¡åªç”Ÿæˆä¸‹ä¸€ä¸ªå…ƒç´ ã€‚å¦‚æœåˆ—è¡¨å¾ˆé•¿ï¼Œç›´æ¥ç”Ÿæˆå‡ºæ•´ä¸ªåˆ—è¡¨å†éå†çš„æ–¹å¼ä¼šæ¶ˆè€—å¾ˆå¤šå†…å­˜ã€‚\nYield From yield from è¯­å¥å¯ä»¥å°†ä¸€ä¸ª iterable ä¸­çš„å…ƒç´ é€ä¸ª yield å‡ºå»ã€‚ä¾‹å¦‚ä¸‹é¢ä¸¤æ®µç¨‹åºçš„åŠŸèƒ½ç­‰ä»·ï¼š\ndef yield_list(a): for item in a: yield item def yield_list(a): yield from a æ›´æœ‰è¶£çš„ç”¨æ³•æ˜¯ï¼šyield from åé¢è·Ÿçš„ä¸œè¥¿å¯ä»¥æ˜¯ generator functionï¼Œç”šè‡³æ˜¯è‡ªå·±æœ¬èº«è¿™ä¸ª generator functionï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨è¿™ä¸ªæ€§è´¨å†™å‡ºä¸€äº›ç±»ä¼¼äºâ€é€’å½’â€œ çš„ generator functionã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªâ€é€’å½’â€œç‰ˆæœ¬çš„ countdownï¼š\ndef countdown(k): if k \u0026gt; 0: yield k yield from countdown(k - 1) Generator Functions with Returns å¦‚æœ generator function æ‰§è¡Œè¿‡ç¨‹ä¸­é‡åˆ° returnï¼Œé‚£ä¹ˆå³ä½¿ä¸‹æ¬¡å†è°ƒç”¨åé¢çš„å†…å®¹ä¹Ÿä¸ä¼šå†æ‰§è¡Œï¼Œreturn value ä¸ä¼šä½œä¸º yield çš„ä¸€éƒ¨åˆ†ã€‚å¦‚æœä½ ç¡®å®æƒ³è¦å°†è¿”å›å€¼ä¹Ÿ yield å‡ºæ¥ï¼Œå¯ä»¥è¿™æ ·å†™ï¼š\ndef g(x): yield x yield x + 1 return x + 2 def h(x): r = yield from g(x) yield r list(h(2)) # [2, 3, 4] Example ä¸‹é¢å±•ç¤ºä¸€ä¸ªç”¨ generator function æ¥ç”Ÿæˆæ‰€æœ‰æ•´æ•° partition çš„ä¾‹å­ï¼š\ndef partitions(n, m): \u0026quot;\u0026quot;\u0026quot;List partitions. \u0026gt;\u0026gt;\u0026gt; for p in partitions(6, 4): print(p) 4 + 2 4 + 1 + 1 3 + 3 3 + 2 + 1 3 + 1 + 1 + 1 2 + 2 + 2 2 + 2 + 1 + 1 2 + 1 + 1 + 1 + 1 1 + 1 + 1 + 1 + 1 + 1 \u0026quot;\u0026quot;\u0026quot; if n \u0026lt; 0 or m == 0: return else: if n == m: yield str(m) for p in partitions(n-m, m): yield str(m) + \u0026quot; + \u0026quot; + p yield from partitions(n, m - 1) ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"bf94f134ad362c3f707f7c5f5159e4d2","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/lectures/lec17/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/lectures/lec17/","section":"notes","summary":"Generators generator function ä¸­ä¸ä½¿ç”¨ return è¿”å›ç»“æœï¼Œè€Œä½¿ç”¨ yieldã€‚generator æ˜¯ä¸€ç§ iteratorï¼Œå®ƒé€šè¿‡ generator function æ¥é€ä¸ªåœ°è·å¾—ç»“æœã€‚è¿™é‡Œ generator function å¯ä»¥ç†è§£ä¸ºä¸€ä¸ªçŠ¶æ€æœºï¼Œå½“é‡åˆ° yield è¯­å¥æ—¶ï¼Œå®ƒä¼šå°†è‡ªå·±çš„æ‰§è¡ŒçŠ¶æ€æš‚æ—¶å°å­˜èµ·æ¥å¹¶è¿”å›ç»“æœã€‚ä¸‹ä¸€æ¬¡ generator å†æ¬¡è°ƒç”¨è¯¥å‡½æ•°æ—¶ï¼Œgenerator function å°†ä¼šä»ä¸Šä¸€æ¬¡ yield åçš„ç¬¬ä¸€æ¡è¯­å¥å¼€å§‹ç»§ç»­æ‰§è¡Œï¼Œç›´åˆ°é‡åˆ°ä¸‹ä¸€ä¸ª yieldã€‚å¦‚æœæ²¡æœ‰é‡åˆ° yield è€Œæ˜¯å‡½æ•°ä¸€ç›´æ‰§è¡Œåˆ°ç»“æŸï¼Œgenerator function ä¼šè¿”å›ä¸€ä¸ª StopIteration exceptionã€‚","tags":null,"title":"UCB-CS61A Lecture 17: Generators","type":"docs"},{"authors":null,"categories":null,"content":"Python OOP Terminology ç±» (class) æ˜¯ä¸€ä¸ªå®šä¹‰æ–°çš„æ•°æ®ç±»å‹çš„æ¨¡æ¿ã€‚ class çš„ä¸€ä¸ªå…·ä½“çš„å®ä¾‹ (instance) è¢«ç§°ä¸ºå¯¹è±¡ (object)ã€‚ æ¯ä¸ªå¯¹è±¡æœ‰ä¸€äº› data attributeï¼Œç§°ä¸º instance variableï¼›æ¯ä¸ªå¯¹è±¡ä¹Ÿæœ‰ä¸€äº› function attributeï¼Œç§°ä¸º methodã€‚ Classes Class Instantiation pina_bar = Product('PiÃ±a Chocolotta\u0026quot;, 7.99, [\u0026quot;200 calories\u0026quot;, \u0026quot;24 g sugar\u0026quot;]') è¿™é‡Œçš„ Product(args) ç§°ä¸º constructorï¼Œconstructor è¢«è°ƒç”¨æ—¶ï¼ŒPython ä¼šåˆ›å»º class çš„ä¸€ä¸ªå®ä¾‹å¹¶è°ƒç”¨ class ä¸­çš„ __init__() å‡½æ•°ï¼Œè¯¥å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å¯¹è±¡è‡ªå·±ï¼Œç”¨ self è¡¨ç¤ºã€‚\nclass Product: def __init__(self, name, price, nutrition_info): self.name = name self.price = price self.nutrition_info = nutrition_info self.inventory = 0 åœ¨ __init__() ä¸­ï¼Œä½ å¯ä»¥å®šä¹‰ instance variable å¹¶èµ‹äºˆå®ƒä»¬åˆå§‹å€¼ã€‚è¯¥ class çš„å…¶ä»– method å¯ä»¥ä½¿ç”¨å’Œä¿®æ”¹è¿™äº› instance variableã€‚\nMethod Invocation pina_bar.increase_inventory(2) è°ƒç”¨äº†è¯¥ class ä¸­çš„ä¸€ä¸ª methodã€‚\nclass Product: def increase_inventory(self, amount): self.invetory += amount è¿™é‡Œçš„ pina_bar.increase_inventory() æ˜¯ä¸€ä¸ª bound methodï¼šç¬¬ä¸€ä¸ªå‚æ•°è¢«é¢„å…ˆç»‘å®šä¸ºäº† selfï¼Œä¹‹åä¼ å‚æ•°åªéœ€è¦ä¼ ä¸€ä¸ªå°±è¡Œã€‚pina_bar.increase_inventory(2) å’Œ Product.increase_inventory(pina_bar, 2) æ˜¯ç­‰ä»·çš„ã€‚\nClass Variables class variable æ˜¯æŒ‡ä¸åœ¨ä»»ä½•ä¸€ä¸ª method ä¸­èµ‹å€¼çš„å˜é‡ï¼Œä¾‹å¦‚ï¼š\nclass Product: sales_tax = 0.07 class variable çš„ç‰¹ç‚¹åœ¨äºæ‰€æœ‰è¯¥ class çš„ instance éƒ½æœ‰è¿™ä¸ªå˜é‡ (æ³¨ï¼šä¸åŒ instance å¯¹è¯¥å˜é‡çš„ä¿®æ”¹æ˜¯å½¼æ­¤ä¸å¯è§çš„)ã€‚\nAccessing Attributes getattr() å‡½æ•°å…è®¸æˆ‘ä»¬é€šè¿‡ string çš„æ–¹å¼æ¥æŸ¥è¯¢ä¸€ä¸ª attribute çš„å€¼ã€‚hasattr() å¯ä»¥æŸ¥è¯¢æŸä¸ª attribute æ˜¯å¦å­˜åœ¨ï¼š\ngetattr(pina_bar, 'inventory') # 1 hasattr(pina_bar, 'reduce_inventory') # True Private v.s. Public Python çš„æ‰€æœ‰ attribute éƒ½æ˜¯ public çš„ã€‚ä¸€ä¸ªå¸¸è§çš„çº¦å®šæ˜¯ï¼šå¦‚æœæŸä¸ª attribute çš„åå­—ä»¥ä¸‹åˆ’çº¿å¼€å¤´ï¼Œé‚£ä¹ˆè¯¥ attritube è¢«è®¤ä¸ºæ˜¯ private çš„ï¼Œè™½ç„¶ä»è¯­æ³•ä¸Šä½ ä»ç„¶å¯ä»¥ç›´æ¥è®¿é—®å®ƒï¼Œä½†ä½ åº”å½“é€šè¿‡ public method call å¯¹å…¶è¿›è¡Œæ“ä½œã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"1691d72ac2f1ee07628772a267bd9ab4","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/lectures/lec18/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/lectures/lec18/","section":"notes","summary":"Python OOP Terminology ç±» (class) æ˜¯ä¸€ä¸ªå®šä¹‰æ–°çš„æ•°æ®ç±»å‹çš„æ¨¡æ¿ã€‚ class çš„ä¸€ä¸ªå…·ä½“çš„å®ä¾‹ (instance) è¢«ç§°ä¸ºå¯¹è±¡ (object)ã€‚ æ¯ä¸ªå¯¹è±¡æœ‰ä¸€äº› data attributeï¼Œç§°ä¸º instance variableï¼›æ¯ä¸ªå¯¹è±¡ä¹Ÿæœ‰ä¸€äº› function attributeï¼Œç§°ä¸º methodã€‚ Classes Class Instantiation pina_bar = Product('PiÃ±a Chocolotta\u0026quot;, 7.99, [\u0026quot;200 calories\u0026quot;, \u0026quot;24 g sugar\u0026quot;]') è¿™é‡Œçš„ Product(args) ç§°ä¸º constructorï¼Œconstructor è¢«è°ƒç”¨æ—¶ï¼ŒPython ä¼šåˆ›å»º class çš„ä¸€ä¸ªå®ä¾‹å¹¶è°ƒç”¨ class ä¸­çš„ __init__() å‡½æ•°ï¼Œè¯¥å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å¯¹è±¡è‡ªå·±ï¼Œç”¨ self è¡¨ç¤ºã€‚","tags":null,"title":"UCB-CS61A Lecture 18: Objects","type":"docs"},{"authors":null,"categories":null,"content":"Motivation æ¯”å¦‚æˆ‘ä»¬æƒ³è¦å®šä¹‰ä¸€äº›åŠ¨ç‰©çš„ classï¼šrabbit, elephant, lion\u0026hellip; å®ƒä»¬ä½œä¸ºåŠ¨ç‰©æœ‰ä¸€äº›å…±åŒçš„å±æ€§å’Œæ–¹æ³•ï¼Œå„è‡ªä¹Ÿæœ‰ç‹¬ç‰¹çš„å±æ€§å’Œæ–¹æ³•ã€‚é‚£ä¹ˆä¸å…¶åœ¨å„è‡ªçš„ class ä¸­é‡å¤ä¹¦å†™ä»£ç ï¼Œæˆ‘ä»¬ä¸å¦‚å®šä¹‰ä¸€ä¸ªåŠ¨ç‰© classï¼Œåœ¨è¿™ä¸ª class ä¸­å®šä¹‰åŠ¨ç‰©å…±æœ‰çš„å±æ€§å’Œæ–¹æ³•ï¼Œç„¶åä¸ºå„ä¸ªåŠ¨ç‰©å»ºç«‹ subclassï¼Œè®©è¿™äº› subclass ç»§æ‰¿ (inherit) åŠ¨ç‰© classã€‚\nInheritance ä¸Šæ–‡ä¸­çš„åŠ¨ç‰© class ç§°ä¸º base classï¼Œæˆ–è€… superclassã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š\nclass Animal: species_name = \u0026quot;Animal\u0026quot; scientific_name = \u0026quot;Animalia\u0026quot; play_multiplier = 2 interact_increment = 1 def __init__(self, name, age=0): self.name = name self.age = age self.calories_eaten = 0 self.happiness = 0 def eat(self, food): self.calories_eaten += food.calories print(f\u0026quot;Om nom nom yummy {food.name}\u0026quot;) if self.calories_eaten \u0026gt; self.calories_needed: self.happiness -= 1 print(\u0026quot;Ugh so full\u0026quot;) class AmorphousBlob(Animal): # åœ¨æ‹¬å·ä¸­å†™ä¸Šsuperclassçš„åå­—ï¼ pass subclass ä¸­å¯ä»¥å®šä¹‰å·²ç»å­˜åœ¨çš„å˜é‡å’Œæ–¹æ³•ï¼Œè¿™è¢«ç§°ä¸º overridingã€‚\nåœ¨ subclass çš„ method ä¸­å¦‚æœæƒ³è¦ä½¿ç”¨ superclass ä¸­çš„å†…å®¹ï¼Œå¯ä»¥ç”¨ super().xxx çš„æ–¹å¼è®¿é—®ã€‚\nMultiple Inheritance ä¸€ä¸ª class å¯ä»¥ç»§æ‰¿å¤šä¸ª class çš„å†…å®¹ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š\nclass Predator(Animal): def interact_with(self, other): if other.type == \u0026quot;meat\u0026quot;: self.eat(other) print(\u0026quot;om nom nom, I'm a predator\u0026quot;) else: super().interact_with(other) class Prey(Animal): type = \u0026quot;meat\u0026quot; calories = 200 æ¥ä¸‹æ¥æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€äº›åŠ¨ç‰© classï¼ŒåŒæ—¶ç»§æ‰¿ Animal å’Œ Predator/Preyï¼š\nclass Rabbit(Prey, Animal): pass class Lion(Predator, Animal): pass Python ä¼šåœ¨æ‰€æœ‰çš„ superclass ä¸­å¯»æ‰¾å¯¹åº”çš„å±æ€§å’Œæ–¹æ³•ã€‚\nComposition ä¸€ä¸ªå¯¹è±¡ä¸­å¯ä»¥åŒ…å«å…¶ä»– class å¯¹è±¡çš„ refenrenceã€‚ä¾‹å¦‚æˆ‘ä»¬å¯ä»¥åœ¨ animal ç±»ä¸­æ·»åŠ ä¸€ä¸ª mate å±æ€§ï¼š\nclass Animal: def mate_with(self, other): if other is not self and other.species_name == self.species_name: self.mate = other other.mate = self Composition v.s. Inheritance Inheritance é€‚åˆè¡¨ç¤º \u0026ldquo;is-a\u0026rdquo; å…³ç³»ï¼š\nRabbit is a specific type of animal, so Rabbit inherits from Animal. Composition é€‚åˆè¡¨ç¤º \u0026ldquo;has-a\u0026rdquo; å…³ç³»ï¼š\nAn animal has a mate, so Animal has mate as an instance variable. Quiz class Parent: def f(s): print(\u0026quot;Parent.f\u0026quot;) def g(s): s.f() class Child(Parent): def f(me): print(\u0026quot;Child.f\u0026quot;) a_child = Child() a_child.g() æœ‰ä¸¤ç‚¹éœ€è¦æ³¨æ„ï¼š\nclass ä¸­çš„ method éƒ½æ˜¯ bound methodï¼Œç¬¬ä¸€ä¸ªå‚æ•°ä»£è¡¨çš„æ˜¯è‡ªå·±ï¼Œä¸è®ºè¿™ä¸ªå‚æ•°åå­—æ˜¯ self s è¿˜æ˜¯ me æ•ˆæœéƒ½æ˜¯ä¸€æ ·çš„ã€‚ åœ¨æ‰§è¡Œåˆ° Parent ä¸­çš„ g() æ—¶ï¼Œç”±äº Child override äº† f() æ–¹æ³•ï¼Œæ‰€ä»¥ g() è°ƒç”¨çš„æ˜¯ Child ä¸­çš„ f è€Œä¸æ˜¯ Parent ä¸­çš„ fã€‚ ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"ff9757993a01ee2038bc79df60f0f2de","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/lectures/lec19/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/lectures/lec19/","section":"notes","summary":"Motivation æ¯”å¦‚æˆ‘ä»¬æƒ³è¦å®šä¹‰ä¸€äº›åŠ¨ç‰©çš„ classï¼šrabbit, elephant, lion\u0026hellip; å®ƒä»¬ä½œä¸ºåŠ¨ç‰©æœ‰ä¸€äº›å…±åŒçš„å±æ€§å’Œæ–¹æ³•ï¼Œå„è‡ªä¹Ÿæœ‰ç‹¬ç‰¹çš„å±æ€§å’Œæ–¹æ³•ã€‚é‚£ä¹ˆä¸å…¶åœ¨å„è‡ªçš„ class ä¸­é‡å¤ä¹¦å†™ä»£ç ï¼Œæˆ‘ä»¬ä¸å¦‚å®šä¹‰ä¸€ä¸ªåŠ¨ç‰© classï¼Œåœ¨è¿™ä¸ª class ä¸­å®šä¹‰åŠ¨ç‰©å…±æœ‰çš„å±æ€§å’Œæ–¹æ³•ï¼Œç„¶åä¸ºå„ä¸ªåŠ¨ç‰©å»ºç«‹ subclassï¼Œè®©è¿™äº› subclass ç»§æ‰¿ (inherit) åŠ¨ç‰© classã€‚\nInheritance ä¸Šæ–‡ä¸­çš„åŠ¨ç‰© class ç§°ä¸º base classï¼Œæˆ–è€… superclassã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š\nclass Animal: species_name = \u0026quot;Animal\u0026quot; scientific_name = \u0026quot;Animalia\u0026quot; play_multiplier = 2 interact_increment = 1 def __init__(self, name, age=0): self.","tags":null,"title":"UCB-CS61A Lecture 19: Inheritance","type":"docs"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"9cc9f8289f6afe1e6717121be0e13469","permalink":"https://kristoff-starling.github.io/publication/test-paper/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/publication/test-paper/","section":"publication","summary":"testing","tags":null,"title":"A testing paper","type":"publication"},{"authors":null,"categories":null,"content":"éšç€ç§‘å­¦æŠ€æœ¯çš„å‘å±•, åœ¨å›½é™…å­¦æœ¯äº¤æµä¸­ä½¿ç”¨è‹±è¯­å·²ç»æˆä¸ºå¸¸æ€: é¡¶å°–çš„è®ºæ–‡æ— ä¸€ä¸ä½¿ç”¨è‹±æ–‡æ¥ä¹¦å†™, åœ¨å›½é™…ä¸Šå…¬è®¤çš„è®¡ç®—æœºé¢†åŸŸç»å…¸ä¹¦ç±ä¹Ÿæ˜¯ä½¿ç”¨è‹±æ–‡ç¼–è‘—ã€‚é¡¶å°–çš„è®ºæ–‡æ²¡æœ‰ä¸­æ–‡ç¿»è¯‘ç‰ˆ; å¦‚æœéœ€è¦è·å–ä¿¡æ¯, ä¹Ÿåº”è¯¥ä¸»åŠ¨å»é˜…è¯»è‹±æ–‡ææ–™, è€Œä¸æ˜¯ç­‰ç¿»è¯‘ç‰ˆå‡ºç‰ˆã€‚\u0026ldquo;æˆ‘æ˜¯ä¸­å›½äºº, æˆ‘åªçœ‹ä¸­æ–‡\u0026quot;è¿™ç±»è§‚ç‚¹å·²ç»ä¸ç¬¦åˆæ—¶ä»£å‘å±•çš„æ½®æµ, è¦ç«™åœ¨æ—¶ä»£çš„æœ€å‰æ²¿, é˜…è¯»è‹±æ–‡ææ–™çš„èƒ½åŠ›æ˜¯ä¸å¯æˆ–ç¼ºçš„ã€‚\næƒ³è¦å­¦å¥½è®¡ç®—æœºï¼Œå¤§å®¶ä¸€å®šè¦è¶æ—©â€œé€¼è¿«â€è‡ªå·±ç†Ÿæ‚‰è‹±è¯­ç¯å¢ƒï¼Œå°¤å…¶å¼ºåŒ–è‡ªå·±çš„è‹±è¯­é˜…è¯»èƒ½åŠ› (å°†æ¥å¿«é€Ÿç•¥è¯»å¤§æ®µçš„è‹±æ–‡æ‰‹å†Œå¾ˆå¯èƒ½æ˜¯ä½ çš„å·¥ä½œ/å­¦ä¹ å¸¸æ€)ã€‚æˆ‘ä»¬å¼ºçƒˆå»ºè®®ä½ æ³¨æ„ä»¥ä¸‹å‡ ä¸ªæ–¹é¢ï¼š\nä¸è¦ä¾èµ–æ•™æçš„ä¸­æ–‡ç¿»è¯‘ç‰ˆæœ¬ã€‚ å°†æ¥å¤§å®¶å­¦ä¹ çš„ã€Šç®—æ³•å¯¼è®ºã€‹ç­‰æ•™ææ˜¯æ¯”è¾ƒå®¹æ˜“æ‰¾åˆ°ä¸­æ–‡ç¿»è¯‘ç‰ˆæœ¬çš„ï¼Œä½†æ­£å¦‚åè‘—çš„ç¿»è¯‘ç‰ˆæ—¶å¸¸ä½“ç°ä¸å‡ºåè‘—æœ¬èº«çš„æ„å¢ƒï¼Œç¿»è¯‘ç‰ˆçš„æ•™æåœ¨å¾ˆå¤šç»†èŠ‚ä¸Šå¯èƒ½ä¸åŸç‰ˆæœ‰å‡ºå…¥ï¼Œå½±å“å¤§å®¶çš„ç†è§£ï¼Œä¹Ÿä¸åˆ©äºå¤§å®¶ç†Ÿæ‚‰ä¸€äº›è‹±æ–‡æœ¯è¯­ã€‚æˆ‘ä»¬è®¤ä¸ºï¼Œè‹±æ–‡é˜…è¯»èƒ½åŠ›åˆæ ¼çš„æ ‡å‡†ä¹‹ä¸€ä¾¿æ˜¯é˜…è¯»å­¦æœ¯æ–¹é¢çš„è‹±æ–‡ææ–™å’Œä¸­æ–‡ææ–™åº”è¯¥åŸºæœ¬ä¸å­˜åœ¨é€Ÿåº¦å·®å¼‚ã€‚è¿™ä¸ªè¿‡ç¨‹åˆšå¼€å§‹å¯èƒ½ä¼šæ¯”è¾ƒç—›è‹¦ï¼Œä½†éšç€å­¦æœŸæ·±å…¥å¤§å®¶ä¸€å®šèƒ½å…‹æœéšœç¢ã€‚å¤§å®¶ä¹Ÿä¸å¿…å¯¹è¿™ä¸ªæ ‡å‡†æ„Ÿåˆ°è¿‡äºæƒŠæ…Œï¼Œå› ä¸ºåŠ©æ•™è®¤ä¸ºè‡ªå·±çš„è‹±è¯­é˜…è¯»èƒ½åŠ›ä¹Ÿä¸åˆæ ¼ ä¸è¦ä¾èµ–ç™¾åº¦ç­‰ä¸­æ–‡ç½‘ç«™è§£å†³é—®é¢˜ã€‚ åœ¨åˆšåˆšæ¥è§¦è®¡ç®—æœºä»¥åŠå­¦ä¹ ç®—æ³•çš„åˆçº§é˜¶æ®µï¼Œä¸­æ–‡çš„åšå®¢ (ä»¥CSDNä¸ºä¸») å¯ä»¥å¸®åŠ©å¤§å®¶è§£å†³ä¸€éƒ¨åˆ†é—®é¢˜ã€‚ä½†éšç€å¤§å®¶æ°´å¹³çš„æé«˜ï¼Œå¾ˆå¤šå¤æ‚çš„é—®é¢˜ (å°¤å…¶æ˜¯ä¸ç³»ç»Ÿé…ç½®ï¼Œç¯å¢ƒé…ç½®ç›¸å…³çš„é—®é¢˜) åœ¨ä¸­æ–‡ç¯å¢ƒä¸‹å¾ˆéš¾æ‰¾åˆ°å¥‘åˆçš„å›ç­”ã€‚è¿™æ—¶æ¨èå¤§å®¶ä½¿ç”¨å¯¹åº”çš„è‹±æ–‡å…³é”®å­—åœ¨ google/bing/stackoverflow ä¸Šæœç´¢å›ç­”ã€‚ (å¦‚æœæˆ‘æƒ³åˆ°äº†ä¼šå†æ·»åŠ ) è‹±è¯­çš„å­¦ä¹ å’Œå¼ºåŒ–æ–¹æ³•æ˜¯ä¸€ä¸ªè§ä»è§æ™ºçš„é—®é¢˜ã€‚æˆ‘ä»¬çš„å»ºè®®æ˜¯ä¸è¦æœŸå¾… å¤§å­¦è‹±è¯­è¯»å†™/å¤§å­¦è‹±è¯­è§†å¬è¯´ èƒ½ç»™ä½ å¸¦æ¥è´¨çš„æ”¹å˜ã€‚æå‡è¯­è¨€èƒ½åŠ›çš„æ ¸å¿ƒè¿˜æ˜¯å¤šè¯»å¤šå¬å¤šè¯´å¤šå†™ã€‚å¼•ç”¨é™ˆé“è“„è€å¸ˆçš„è¯: â€œåšæŒä¸€å¹´, ä½ å°±ä¼šå‘ç°æœ‰ä¸åŒ; åšæŒä¸¤å¹´, ä½ å°±ä¼šå‘ç°å¤§æœ‰ä¸åŒã€‚â€\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"bae75e576fd11fe5715aec4b63cf2228","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/cser0/english/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/problemsolving22/cser0/english/","section":"courses","summary":"éšç€ç§‘å­¦æŠ€æœ¯çš„å‘å±•, åœ¨å›½é™…å­¦æœ¯äº¤æµä¸­ä½¿ç”¨è‹±è¯­å·²ç»æˆä¸ºå¸¸æ€: é¡¶å°–çš„è®ºæ–‡æ— ä¸€ä¸ä½¿ç”¨è‹±æ–‡æ¥ä¹¦å†™, åœ¨å›½é™…ä¸Šå…¬è®¤çš„è®¡ç®—æœºé¢†åŸŸç»å…¸ä¹¦ç±ä¹Ÿæ˜¯ä½¿ç”¨è‹±æ–‡ç¼–è‘—ã€‚é¡¶å°–çš„è®ºæ–‡æ²¡æœ‰ä¸­æ–‡ç¿»è¯‘ç‰ˆ; å¦‚æœéœ€è¦è·å–ä¿¡æ¯, ä¹Ÿåº”è¯¥ä¸»åŠ¨å»é˜…è¯»è‹±æ–‡ææ–™, è€Œä¸æ˜¯ç­‰ç¿»è¯‘ç‰ˆå‡ºç‰ˆã€‚\u0026ldquo;æˆ‘æ˜¯ä¸­å›½äºº, æˆ‘åªçœ‹ä¸­æ–‡\u0026quot;è¿™ç±»è§‚ç‚¹å·²ç»ä¸ç¬¦åˆæ—¶ä»£å‘å±•çš„æ½®æµ, è¦ç«™åœ¨æ—¶ä»£çš„æœ€å‰æ²¿, é˜…è¯»è‹±æ–‡ææ–™çš„èƒ½åŠ›æ˜¯ä¸å¯æˆ–ç¼ºçš„ã€‚\næƒ³è¦å­¦å¥½è®¡ç®—æœºï¼Œå¤§å®¶ä¸€å®šè¦è¶æ—©â€œé€¼è¿«â€è‡ªå·±ç†Ÿæ‚‰è‹±è¯­ç¯å¢ƒï¼Œå°¤å…¶å¼ºåŒ–è‡ªå·±çš„è‹±è¯­é˜…è¯»èƒ½åŠ› (å°†æ¥å¿«é€Ÿç•¥è¯»å¤§æ®µçš„è‹±æ–‡æ‰‹å†Œå¾ˆå¯èƒ½æ˜¯ä½ çš„å·¥ä½œ/å­¦ä¹ å¸¸æ€)ã€‚æˆ‘ä»¬å¼ºçƒˆå»ºè®®ä½ æ³¨æ„ä»¥ä¸‹å‡ ä¸ªæ–¹é¢ï¼š\nä¸è¦ä¾èµ–æ•™æçš„ä¸­æ–‡ç¿»è¯‘ç‰ˆæœ¬ã€‚ å°†æ¥å¤§å®¶å­¦ä¹ çš„ã€Šç®—æ³•å¯¼è®ºã€‹ç­‰æ•™ææ˜¯æ¯”è¾ƒå®¹æ˜“æ‰¾åˆ°ä¸­æ–‡ç¿»è¯‘ç‰ˆæœ¬çš„ï¼Œä½†æ­£å¦‚åè‘—çš„ç¿»è¯‘ç‰ˆæ—¶å¸¸ä½“ç°ä¸å‡ºåè‘—æœ¬èº«çš„æ„å¢ƒï¼Œç¿»è¯‘ç‰ˆçš„æ•™æåœ¨å¾ˆå¤šç»†èŠ‚ä¸Šå¯èƒ½ä¸åŸç‰ˆæœ‰å‡ºå…¥ï¼Œå½±å“å¤§å®¶çš„ç†è§£ï¼Œä¹Ÿä¸åˆ©äºå¤§å®¶ç†Ÿæ‚‰ä¸€äº›è‹±æ–‡æœ¯è¯­ã€‚æˆ‘ä»¬è®¤ä¸ºï¼Œè‹±æ–‡é˜…è¯»èƒ½åŠ›åˆæ ¼çš„æ ‡å‡†ä¹‹ä¸€ä¾¿æ˜¯é˜…è¯»å­¦æœ¯æ–¹é¢çš„è‹±æ–‡ææ–™å’Œä¸­æ–‡ææ–™åº”è¯¥åŸºæœ¬ä¸å­˜åœ¨é€Ÿåº¦å·®å¼‚ã€‚è¿™ä¸ªè¿‡ç¨‹åˆšå¼€å§‹å¯èƒ½ä¼šæ¯”è¾ƒç—›è‹¦ï¼Œä½†éšç€å­¦æœŸæ·±å…¥å¤§å®¶ä¸€å®šèƒ½å…‹æœéšœç¢ã€‚å¤§å®¶ä¹Ÿä¸å¿…å¯¹è¿™ä¸ªæ ‡å‡†æ„Ÿåˆ°è¿‡äºæƒŠæ…Œï¼Œå› ä¸ºåŠ©æ•™è®¤ä¸ºè‡ªå·±çš„è‹±è¯­é˜…è¯»èƒ½åŠ›ä¹Ÿä¸åˆæ ¼ ä¸è¦ä¾èµ–ç™¾åº¦ç­‰ä¸­æ–‡ç½‘ç«™è§£å†³é—®é¢˜ã€‚ åœ¨åˆšåˆšæ¥è§¦è®¡ç®—æœºä»¥åŠå­¦ä¹ ç®—æ³•çš„åˆçº§é˜¶æ®µï¼Œä¸­æ–‡çš„åšå®¢ (ä»¥CSDNä¸ºä¸») å¯ä»¥å¸®åŠ©å¤§å®¶è§£å†³ä¸€éƒ¨åˆ†é—®é¢˜ã€‚ä½†éšç€å¤§å®¶æ°´å¹³çš„æé«˜ï¼Œå¾ˆå¤šå¤æ‚çš„é—®é¢˜ (å°¤å…¶æ˜¯ä¸ç³»ç»Ÿé…ç½®ï¼Œç¯å¢ƒé…ç½®ç›¸å…³çš„é—®é¢˜) åœ¨ä¸­æ–‡ç¯å¢ƒä¸‹å¾ˆéš¾æ‰¾åˆ°å¥‘åˆçš„å›ç­”ã€‚è¿™æ—¶æ¨èå¤§å®¶ä½¿ç”¨å¯¹åº”çš„è‹±æ–‡å…³é”®å­—åœ¨ google/bing/stackoverflow ä¸Šæœç´¢å›ç­”ã€‚ (å¦‚æœæˆ‘æƒ³åˆ°äº†ä¼šå†æ·»åŠ ) è‹±è¯­çš„å­¦ä¹ å’Œå¼ºåŒ–æ–¹æ³•æ˜¯ä¸€ä¸ªè§ä»è§æ™ºçš„é—®é¢˜ã€‚æˆ‘ä»¬çš„å»ºè®®æ˜¯ä¸è¦æœŸå¾… å¤§å­¦è‹±è¯­è¯»å†™/å¤§å­¦è‹±è¯­è§†å¬è¯´ èƒ½ç»™ä½ å¸¦æ¥è´¨çš„æ”¹å˜ã€‚æå‡è¯­è¨€èƒ½åŠ›çš„æ ¸å¿ƒè¿˜æ˜¯å¤šè¯»å¤šå¬å¤šè¯´å¤šå†™ã€‚å¼•ç”¨é™ˆé“è“„è€å¸ˆçš„è¯: â€œåšæŒä¸€å¹´, ä½ å°±ä¼šå‘ç°æœ‰ä¸åŒ; åšæŒä¸¤å¹´, ä½ å°±ä¼šå‘ç°å¤§æœ‰ä¸åŒã€‚â€","tags":null,"title":"English","type":"docs"},{"authors":null,"categories":null,"content":"æ­£æ‰€è°“â€œå·¥æ¬²å–„å…¶äº‹ï¼Œå¿…å…ˆåˆ©å…¶å™¨â€ï¼Œæƒ³è¦æ‹¥æœ‰è‰¯å¥½çš„ä»£ç ä¹¦å†™ä½“éªŒå°±åº”å½“é…ç½®å¥½ä¸€å¥—èˆ’é€‚çš„ä»£ç ç¼–å†™ç¯å¢ƒã€‚æ‰“å¼€ Windows çš„â€œè®°äº‹æœ¬â€ç¼–å†™ä»£ç å¯ä¸æ˜¯ä»€ä¹ˆå¥½çš„é€‰æ‹©â€”â€”ä¸€æ–¹é¢è®°äº‹æœ¬æ— æ³•æä¾›ä»£ç é«˜äº®ã€è‡ªåŠ¨è¡¥å…¨ã€æ™ºèƒ½ç¼©è¿›ç­‰åŠŸèƒ½ï¼Œç›¯ç€ç™½çº¸é»‘å­—å†™ä»£ç é¢‡ä¸ºå¿ƒç´¯ï¼›å¦ä¸€æ–¹é¢å³ä½¿ä½ å†™å®Œäº†ä»£ç ï¼Œè®°äº‹æœ¬ä¹Ÿæ²¡æœ‰é›†æˆå¥½é…å¥—çš„ç¼–è¯‘ã€è°ƒè¯•å·¥å…·å¸®åŠ©ä½ ç¡®å®šä»£ç çš„æ­£ç¡®æ€§ã€‚\nå¾ˆå¤šä¼˜ç§€çš„ç¨‹åºå‘˜éƒ½ä¼šé€‰æ‹© IDE (Integrated Development Environmentï¼Œä¸­æ–‡ç¿»è¯‘ä¸ºé›†æˆå¼€å‘ç¯å¢ƒï¼‰æ¥ä¹¦å†™ä»£ç ã€‚æ‰€è°“é›†æˆå¼€å‘ç¯å¢ƒï¼Œå°±æ˜¯å°†å†™ä»£ç æ‰€éœ€è¦çš„ä¸€ç³»åˆ—å·¥å…·éƒ½é›†æˆåœ¨äº†ä¸€ä¸ªè½¯ä»¶é‡Œï¼Œä»ä¹¦å†™ä»£ç æ‰€éœ€çš„ç¼–è¾‘å™¨ï¼Œåˆ°ç¼–è¯‘è¿è¡Œä»£ç æ‰€éœ€çš„ç¼–è¯‘å™¨ã€é“¾æ¥å™¨ï¼Œåˆ°è°ƒè¯•ä»£ç æ‰€éœ€çš„è°ƒè¯•å™¨â€¦â€¦IDEé‡Œåº”æœ‰å°½æœ‰ï¼Œä¸”å¾ˆå¤šåŠŸèƒ½éƒ½å¯ä»¥â€œä¸€é”®è¿è¡Œâ€ï¼Œæå¥½åœ°å°†ç¨‹åºå‘˜çš„ç²¾åŠ›è§£æ”¾äº†å‡ºæ¥ã€‚\nç”±äºæœ¬è¯¾ç¨‹ä¸»è¦å¸Œæœ›åŸ¹å…»å¤§å®¶æŒæ¡ C/C++ è¿™é—¨è¯­è¨€ï¼Œæ‰€ä»¥æˆ‘ä»¬ç€é‡ä»‹ç»äº†å‡ ä¸ªå’Œ C/C++ é…åˆä½“éªŒè‰¯å¥½çš„ IDEï¼ŒåŒ…æ‹¬ Dev-C++ (æå…¶æ¨èæ–°æ‰‹å…¥é—¨ä½¿ç”¨ï¼Œå…¥é—¨é—¨æ§›ä½)ï¼ŒVisual Studio (å·¥ä¸šçº§çš„é‡å‹IDEï¼ŒåŠŸèƒ½å¼ºå¤§ä½†èº«æç•¥æ˜¾è‡ƒè‚¿), Visual Studio Code (å®‡å®™æœ€å¼ºç¼–è¾‘å™¨) ç­‰ï¼Œå¤§å®¶å¯ä»¥å‚è€ƒæœæ˜Ÿå®‡åŠ©æ•™æ’°å†™çš„ è¿™ç¯‡æ–‡æ¡£ æ¥å­¦ä¹ ã€‚\nå¦‚æœä½ å·²ç»æ˜¯æ¯”è¾ƒæœ‰ç»éªŒçš„ä»£ç ä¹¦å†™è€…ï¼Œä½ å¯èƒ½å¹¶ä¸éœ€è¦ IDEã€‚ä½ ä¹Ÿè®¸ä¼šä¹ æƒ¯ä½¿ç”¨ Vim/Emacs ç­‰è€ç‰Œç¼–è¾‘å™¨ï¼Œè‡ªå·±å†™è„šæœ¬ç¼–è¯‘å’Œè¿è¡Œä»£ç ï¼Œä½¿ç”¨ GDB è¿›è¡Œè°ƒè¯•â€¦â€¦å¦‚æœä½ èƒ½é©¾é©­è¿™äº›ï¼Œæˆ‘ä»¬å½“ç„¶ä¹Ÿé¼“åŠ±ä½ å……åˆ†åœ°ä½¿ç”¨è¿™äº›å‘½ä»¤è¡Œå·¥å…·ã€‚ä¸è¿‡æˆ‘ä»¬è¿˜æ˜¯æåŠ›åœ°æ¨èä½ å°è¯•ä¸€ä¸‹ VS Code (è¿™ä¸æ˜¯ä¸ºå¾®è½¯æ‰“å¹¿å‘Š)ï¼Œå…¶ä¸°å¯Œçš„ç¬¬ä¸‰æ–¹æ’ä»¶åº“ï¼Œå¼ºå¤§çš„è¿œç¨‹è¿æ¥åŠŸèƒ½ï¼Œè‡ªç”±çš„ä»£ç è·³è½¬ã€è¡¥å…¨ã€çº é”™ä½¿å…¶æˆä¸ºç¼–è¾‘å™¨ç•Œçš„ killer applicationã€‚æ¯•ç«Ÿå†™ä»£ç æ€ä¹ˆèˆ’æœæ€ä¹ˆæ¥ï¼Œèƒ½æ‹¥æœ‰ä¸€ä¸ª è¿™æ · ç‚«é…·çš„ç•Œé¢ä½•ä¹è€Œä¸ä¸ºå‘¢ï¼Ÿ\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"b5ddf09ec14c22b1ab33962aeaa17411","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/cser0/ide/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/problemsolving22/cser0/ide/","section":"courses","summary":"æ­£æ‰€è°“â€œå·¥æ¬²å–„å…¶äº‹ï¼Œå¿…å…ˆåˆ©å…¶å™¨â€ï¼Œæƒ³è¦æ‹¥æœ‰è‰¯å¥½çš„ä»£ç ä¹¦å†™ä½“éªŒå°±åº”å½“é…ç½®å¥½ä¸€å¥—èˆ’é€‚çš„ä»£ç ç¼–å†™ç¯å¢ƒã€‚æ‰“å¼€ Windows çš„â€œè®°äº‹æœ¬â€ç¼–å†™ä»£ç å¯ä¸æ˜¯ä»€ä¹ˆå¥½çš„é€‰æ‹©â€”â€”ä¸€æ–¹é¢è®°äº‹æœ¬æ— æ³•æä¾›ä»£ç é«˜äº®ã€è‡ªåŠ¨è¡¥å…¨ã€æ™ºèƒ½ç¼©è¿›ç­‰åŠŸèƒ½ï¼Œç›¯ç€ç™½çº¸é»‘å­—å†™ä»£ç é¢‡ä¸ºå¿ƒç´¯ï¼›å¦ä¸€æ–¹é¢å³ä½¿ä½ å†™å®Œäº†ä»£ç ï¼Œè®°äº‹æœ¬ä¹Ÿæ²¡æœ‰é›†æˆå¥½é…å¥—çš„ç¼–è¯‘ã€è°ƒè¯•å·¥å…·å¸®åŠ©ä½ ç¡®å®šä»£ç çš„æ­£ç¡®æ€§ã€‚\nå¾ˆå¤šä¼˜ç§€çš„ç¨‹åºå‘˜éƒ½ä¼šé€‰æ‹© IDE (Integrated Development Environmentï¼Œä¸­æ–‡ç¿»è¯‘ä¸ºé›†æˆå¼€å‘ç¯å¢ƒï¼‰æ¥ä¹¦å†™ä»£ç ã€‚æ‰€è°“é›†æˆå¼€å‘ç¯å¢ƒï¼Œå°±æ˜¯å°†å†™ä»£ç æ‰€éœ€è¦çš„ä¸€ç³»åˆ—å·¥å…·éƒ½é›†æˆåœ¨äº†ä¸€ä¸ªè½¯ä»¶é‡Œï¼Œä»ä¹¦å†™ä»£ç æ‰€éœ€çš„ç¼–è¾‘å™¨ï¼Œåˆ°ç¼–è¯‘è¿è¡Œä»£ç æ‰€éœ€çš„ç¼–è¯‘å™¨ã€é“¾æ¥å™¨ï¼Œåˆ°è°ƒè¯•ä»£ç æ‰€éœ€çš„è°ƒè¯•å™¨â€¦â€¦IDEé‡Œåº”æœ‰å°½æœ‰ï¼Œä¸”å¾ˆå¤šåŠŸèƒ½éƒ½å¯ä»¥â€œä¸€é”®è¿è¡Œâ€ï¼Œæå¥½åœ°å°†ç¨‹åºå‘˜çš„ç²¾åŠ›è§£æ”¾äº†å‡ºæ¥ã€‚\nç”±äºæœ¬è¯¾ç¨‹ä¸»è¦å¸Œæœ›åŸ¹å…»å¤§å®¶æŒæ¡ C/C++ è¿™é—¨è¯­è¨€ï¼Œæ‰€ä»¥æˆ‘ä»¬ç€é‡ä»‹ç»äº†å‡ ä¸ªå’Œ C/C++ é…åˆä½“éªŒè‰¯å¥½çš„ IDEï¼ŒåŒ…æ‹¬ Dev-C++ (æå…¶æ¨èæ–°æ‰‹å…¥é—¨ä½¿ç”¨ï¼Œå…¥é—¨é—¨æ§›ä½)ï¼ŒVisual Studio (å·¥ä¸šçº§çš„é‡å‹IDEï¼ŒåŠŸèƒ½å¼ºå¤§ä½†èº«æç•¥æ˜¾è‡ƒè‚¿), Visual Studio Code (å®‡å®™æœ€å¼ºç¼–è¾‘å™¨) ç­‰ï¼Œå¤§å®¶å¯ä»¥å‚è€ƒæœæ˜Ÿå®‡åŠ©æ•™æ’°å†™çš„ è¿™ç¯‡æ–‡æ¡£ æ¥å­¦ä¹ ã€‚\nå¦‚æœä½ å·²ç»æ˜¯æ¯”è¾ƒæœ‰ç»éªŒçš„ä»£ç ä¹¦å†™è€…ï¼Œä½ å¯èƒ½å¹¶ä¸éœ€è¦ IDEã€‚ä½ ä¹Ÿè®¸ä¼šä¹ æƒ¯ä½¿ç”¨ Vim/Emacs ç­‰è€ç‰Œç¼–è¾‘å™¨ï¼Œè‡ªå·±å†™è„šæœ¬ç¼–è¯‘å’Œè¿è¡Œä»£ç ï¼Œä½¿ç”¨ GDB è¿›è¡Œè°ƒè¯•â€¦â€¦å¦‚æœä½ èƒ½é©¾é©­è¿™äº›ï¼Œæˆ‘ä»¬å½“ç„¶ä¹Ÿé¼“åŠ±ä½ å……åˆ†åœ°ä½¿ç”¨è¿™äº›å‘½ä»¤è¡Œå·¥å…·ã€‚ä¸è¿‡æˆ‘ä»¬è¿˜æ˜¯æåŠ›åœ°æ¨èä½ å°è¯•ä¸€ä¸‹ VS Code (è¿™ä¸æ˜¯ä¸ºå¾®è½¯æ‰“å¹¿å‘Š)ï¼Œå…¶ä¸°å¯Œçš„ç¬¬ä¸‰æ–¹æ’ä»¶åº“ï¼Œå¼ºå¤§çš„è¿œç¨‹è¿æ¥åŠŸèƒ½ï¼Œè‡ªç”±çš„ä»£ç è·³è½¬ã€è¡¥å…¨ã€çº é”™ä½¿å…¶æˆä¸ºç¼–è¾‘å™¨ç•Œçš„ killer applicationã€‚æ¯•ç«Ÿå†™ä»£ç æ€ä¹ˆèˆ’æœæ€ä¹ˆæ¥ï¼Œèƒ½æ‹¥æœ‰ä¸€ä¸ª è¿™æ · ç‚«é…·çš„ç•Œé¢ä½•ä¹è€Œä¸ä¸ºå‘¢ï¼Ÿ","tags":null,"title":"Coding Environment","type":"docs"},{"authors":null,"categories":null,"content":"A. æœ€çŸ­è·¯1 é¢˜é¢æè¿° ç»™ä¸€å¼  $n$ ä¸ªç‚¹ $m$ æ¡è¾¹çš„æœ‰å‘å¸¦æƒå›¾ï¼Œæ±‚ $1$ å·ç‚¹åˆ°æ‰€æœ‰ç‚¹çš„æœ€çŸ­è·¯é•¿åº¦ã€‚ $n\\leq 10^5,m\\leq 2\\times 10^5,1\\leq w_i\\leq 10^9$â€‹ã€‚ é¢˜è§£ ç›´æ¥ä½¿ç”¨ Dijkstra ç®—æ³•æ±‚å•æºæœ€çŸ­è·¯å³å¯ï¼Œæ³¨æ„å¼€ long longã€‚\nB. æœ€çŸ­è·¯2 é¢˜é¢æè¿° ç»™ä¸€å¼  $n$ ä¸ªç‚¹ $m$ æ¡è¾¹çš„æœ‰å‘å¸¦æƒå›¾ï¼Œæ±‚ $1$ å·ç‚¹åˆ°æ‰€æœ‰ç‚¹çš„æœ€çŸ­è·¯é•¿åº¦ã€‚\n$n\\leq 2000,m\\leq 5000,-10^9\\leq w_i\\leq 10^9$â€‹ã€‚\né¢˜è§£ æœ¬é¢˜å›¾ä¸­æœ‰è´Ÿæƒè¾¹ï¼Œå› æ­¤åº”è¯¥ä½¿ç”¨ Bellman-Ford ç®—æ³•æ±‚æœ€çŸ­è·¯ã€‚æ€»æ—¶é—´å¤æ‚åº¦ $O(nm)$ã€‚\nC. æœ€çŸ­è·¯è®¡æ•° é¢˜é¢æè¿° ç»™ä¸€å¼  $n$ ä¸ªç‚¹ $m$ æ¡è¾¹çš„æœ‰å‘å¸¦æƒå›¾ï¼Œæ±‚ $1$ å·ç‚¹åˆ°æ‰€æœ‰ç‚¹çš„æœ€çŸ­è·¯çš„æ¡æ•°ã€‚ $n\\leq 10^6,m\\leq 2\\times 10^6,1\\leq w_i\\leq 10^9$â€‹ã€‚ é¢˜è§£ å…ˆç”¨ Dijkstra ç®—æ³•æ±‚å‡ºæœ€çŸ­è·¯ï¼Œç„¶åä»¥æœ€çŸ­è·¯é•¿åº¦ä¸ºé¡ºåºè¿›è¡Œ dpï¼Œå¯¹äºæ»¡è¶³ $dist[u]+w(u,v)=dist[v]$ çš„è¾¹ $(u,v)$ è¿›è¡Œè½¬ç§»ã€‚\næ€»æ—¶é—´å¤æ‚åº¦ $O(mlogm+n)$ã€‚\nD. Le Mythe De Acesrc é¢˜é¢æè¿° ç»™å®šä¸€ä¸ª $n$ ä¸ªæ•°çš„é›†åˆ ${a_1,a_2,\u0026hellip;,a_n}$ï¼Œæœ‰ $q$ ä¸ªè¯¢é—®ï¼Œæ¯æ¬¡ç»™å®šä¸€ä¸ª $x$ ï¼Œé—® $x$ æ˜¯å¦èƒ½ç”¨é›†åˆä¸­çš„è‹¥å¹²ä¸ªæ•°ç›¸åŠ å¾—åˆ°ï¼ˆä¸€ä¸ªæ•°å¯ä»¥ç”¨å¤šæ¬¡ï¼‰ã€‚ $n\\leq 10000,1\\leq a_i\\leq 20000,x\\leq 10^9$â€‹â€‹ï¼Œ$a_i$ æŒ‰ç…§é€’å¢åºç»™å‡ºã€‚ é¢˜è§£ è€ƒè™‘æœ€çŸ­è·¯å¯¹ $a_n$â€‹ å–æ¨¡çš„å€¼ï¼Œä»¤ $f[i]=argmin_{x}[(x\\cdot a_n+i)$â€‹å¯ä»¥æ„é€ å‡ºæ¥$]$ã€‚å¦‚æœæ±‚å‡ºäº†æ•°ç»„ $f$ ï¼Œå¯¹äºä¸€ä¸ªè¯¢é—® $x$ ï¼Œåªè¦ $\\left\\lfloor x/a_n\\right\\rfloor\u0026gt;f[x\\space mod \\space a_n]$ï¼Œå°±å¯ä»¥æ„é€ å‡ºæ¥ï¼ˆå› ä¸ºæœ‰æ— é™ä¸ª $a_n$â€‹â€‹ å¯ç”¨ï¼‰ï¼Œå¦åˆ™ä¸è¡Œã€‚\nç°è€ƒè™‘å¦‚ä½•è®¡ç®— $f[i]$ã€‚å»ºå›¾ï¼Œå¯¹äº $i$ å’Œ $j$ï¼Œå¦‚æœå­˜åœ¨ä¸€ä¸ª $a_k$ ä½¿å¾— $i+a_k=j$â€‹ ï¼Œåˆ™å»ºä¸€æ¡ä» $i$ åˆ° $j$ ï¼Œè¾¹æƒä¸º $0$ çš„æœ‰å‘è¾¹ï¼›å¦‚æœå­˜åœ¨ä¸€ä¸ª $a_k$ ä½¿å¾— $i+a_k=a_n+j$ï¼Œåˆ™å»ºä¸€æ¡ä» $i$ åˆ° $j$ ï¼Œè¾¹æƒä¸º $1$ çš„è¾¹ã€‚è¿™æ ·åªè¦åœ¨å›¾ä¸Šè·‘ä¸€ä¸ª 01bfs å³å¯ã€‚\næ€»æ—¶é—´å¤æ‚åº¦ $O(na_n+q)$ã€‚\nè¡¥å……é¢˜1. [Luogu1462] é€šå¾€å¥¥æ ¼ç‘ç›çš„é“è·¯ é¢˜é¢æè¿° ä¼ é€é—¨ ç»™ä¸€ä¸ª $n$ ä¸ªç‚¹ $m$ æ¡è¾¹çš„æ— å‘å›¾ã€‚æ¯æ¡è¾¹æœ‰ä¸€ä¸ªæƒå€¼ $w_i$ è¡¨ç¤ºç»è¿‡è¿™æ¡è¾¹éœ€è¦è€—è´¹çš„è¡€é‡ã€‚æ¯ä¸ªé¡¶ç‚¹æœ‰ä¸€ä¸ªæƒå€¼ $f_i$ è¡¨ç¤ºç»è¿‡è¿™ä¸ªç‚¹éœ€è¦è€—è´¹çš„é’±ã€‚ç°ä» $1$ å·ç‚¹å‡ºå‘åˆ° $n$ å·ç‚¹ï¼Œå¯¹äºä¸€æ¡è·¯å¾„ï¼Œå…¶è€—è´¹è¡€é‡å®šä¹‰ä¸ºç»è¿‡çš„æ‰€æœ‰è¾¹çš„è€—è´¹ä¹‹å’Œï¼Œå…¶è€—è´¹çš„é’±å®šä¹‰ä¸ºç»è¿‡çš„æ‰€æœ‰èŠ‚ç‚¹çš„è€—è´¹çš„æœ€å¤§å€¼ã€‚ç»™å®šåˆå§‹è¡€é‡ $b$ï¼Œé—®åœ¨èƒ½å¤Ÿåˆ°è¾¾ç»ˆç‚¹çš„æƒ…å†µä¸‹è€—è´¹é’±çš„æœ€å°å€¼ã€‚ $n\\leq 10000,m\\leq 500000$ã€‚ é¢˜è§£ äºŒåˆ†ç­”æ¡ˆï¼Œè¿™æ ·æˆ‘ä»¬æ¯æ¬¡åªè¦å°†å¤§äºç­”æ¡ˆçš„ç‚¹ä»¥åŠä¸ä¹‹ç›¸å…³çš„è¾¹ä»å›¾ä¸­å»æ‰ï¼Œåœ¨å‰©ä¸‹çš„å›¾ä¸­è·‘æœ€çŸ­è·¯å³å¯ã€‚\nè¡¥å……é¢˜2. [Luogu2371] å¢¨å¢¨çš„ç­‰å¼ é¢˜é¢æè¿° ä¼ é€é—¨ ç»™å®š $a_1,a_2,\u0026hellip;,a_n$ å’Œ $[l,r]$ ï¼Œå¯¹äºæ–¹ç¨‹ç»„ $\\sum_{i=1}^na_ix_i=b$â€‹â€‹ï¼Œæ±‚æœ‰å¤šå°‘ä¸ª $b\\in [l,r]$ ä½¿å¾—åŸæ–¹ç¨‹ç»„æœ‰éè´Ÿæ•´æ•°è§£ã€‚ $n\\leq 12,1\\leq a_i\\leq 5\\times 10^5,1\\leq l\\leq r\\leq 10^{12}$ã€‚ é¢˜è§£ Dé¢˜æ˜¯æœ¬é¢˜çš„å¼±åŒ–ç‰ˆã€‚æ¬²è§£å†³æœ¬é¢˜ï¼Œåœ¨æ±‚å‡º dist æ•°ç»„ä¹‹åï¼Œåªéœ€è¦åˆ†ç±»æšä¸¾ $a_n$ çš„æ‰€æœ‰ä½™æ•°ï¼Œç„¶åè®¡ç®—æœ‰å¤šå°‘ä¸ªæ•°è½åœ¨äº† $[l,r]$ åŒºé—´å†…å³å¯ã€‚\næ€»æ—¶é—´å¤æ‚åº¦ $O(na_n)$ã€‚\nè¡¥å……é¢˜3. [Luogu4822] å†»ç»“ é¢˜é¢æè¿° ä¼ é€é—¨ ç»™å®šä¸€å¼  $n$ ä¸ªç‚¹ $m$ æ¡è¾¹çš„å›¾ã€‚æ¯æ¡è¾¹æœ‰ä¸€ä¸ªæƒå€¼ï¼Œä¿è¯æ˜¯å¶æ•°ã€‚ç°åœ¨å¯ä»¥ä½¿ç”¨ä¸è¶…è¿‡ $k$ æ¬¡é­”æ³•ï¼Œä½¿ç”¨ä¸€æ¬¡é­”æ³•å¯ä»¥ä½¿å¾—ä¸€æ¡è¾¹çš„æƒå€¼å˜ä¸ºåŸæ¥çš„ä¸€åŠï¼Œæ¯æ¡è¾¹è‡³å¤šåªèƒ½è¢«ä½¿ç”¨ä¸€æ¬¡é­”æ³•ã€‚æ±‚æœ€çŸ­è·¯ã€‚ $n\\leq 50,m\\leq 1000$ã€‚ é¢˜è§£ ç”±äºæœ€çŸ­è·¯ç»è¿‡çš„è¾¹æ•°ä¸ä¼šè¶…è¿‡ $n$ ï¼Œå› æ­¤å®é™…ä¸Š $k$ å¯ä»¥å’Œ $n$ å– minï¼ˆåœ¨æœ¬é¢˜çš„åŸé™åˆ¶ä¸­ $k$ å·²ç»æ»¡è¶³è¯¥æ¡ä»¶ï¼‰ã€‚\nè€ƒè™‘é‡æ–°å»ºå›¾ã€‚ä»¤ $dist[u][i]$ è¡¨ç¤ºåˆ°ç‚¹ $u$ ï¼Œæ°å¥½ä½¿ç”¨äº† $i$ æ¬¡é­”æ³•çš„æƒ…å†µä¸‹çš„æœ€å°ä»£ä»·ã€‚å¯¹äºåŸå›¾ä¸­çš„æ¯ä¸€æ¡è¾¹ $(u,v,w)$ï¼Œåœ¨æ–°å›¾ä¸­è¿è¾¹ $((u,i),(v,i),w)$ å’Œ $((u,i),(v,i+1),w/2)$ã€‚\næ–°å›¾å…±æœ‰ $n\\times k$ ä¸ªèŠ‚ç‚¹ï¼Œ$m\\times k$ æ¡è¾¹ï¼Œåœ¨è¿™å¼ å›¾ä¸Šè·‘ Dijkstra å³å¯ã€‚\næ€»æ—¶é—´å¤æ‚åº¦ $O(mklog(mk))$ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"c7d59cc55e7755cfc3a8089fd47c061b","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-problem-solving/oj-solutions/iii-01/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/nju-problem-solving/oj-solutions/iii-01/","section":"notes","summary":"A. æœ€çŸ­è·¯1 é¢˜é¢æè¿° ç»™ä¸€å¼  $n$ ä¸ªç‚¹ $m$ æ¡è¾¹çš„æœ‰å‘å¸¦æƒå›¾ï¼Œæ±‚ $1$ å·ç‚¹åˆ°æ‰€æœ‰ç‚¹çš„æœ€çŸ­è·¯é•¿åº¦ã€‚ $n\\leq 10^5,m\\leq 2\\times 10^5,1\\leq w_i\\leq 10^9$â€‹ã€‚ é¢˜è§£ ç›´æ¥ä½¿ç”¨ Dijkstra ç®—æ³•æ±‚å•æºæœ€çŸ­è·¯å³å¯ï¼Œæ³¨æ„å¼€ long longã€‚\nB. æœ€çŸ­è·¯2 é¢˜é¢æè¿° ç»™ä¸€å¼  $n$ ä¸ªç‚¹ $m$ æ¡è¾¹çš„æœ‰å‘å¸¦æƒå›¾ï¼Œæ±‚ $1$ å·ç‚¹åˆ°æ‰€æœ‰ç‚¹çš„æœ€çŸ­è·¯é•¿åº¦ã€‚","tags":null,"title":"é—®é¢˜æ±‚è§£ III - 01 é¢˜è§£","type":"docs"},{"authors":null,"categories":null,"content":"A. æœ€é•¿è·¯ é¢˜é¢æè¿° ç»™å®šä¸€ä¸ª $n$ ä¸ªç‚¹ $m$ æ¡è¾¹çš„æœ‰å‘æ— ç¯å›¾ï¼Œæ±‚å›¾ä¸­æœ€é•¿è·¯çš„é•¿åº¦ã€‚ $1\\leq n\\leq 2\\times 10^{5},1\\leq m\\leq min\\{\\frac{n(n-1)}{2},5\\times 10^5\\}$ã€‚ é¢˜è§£ ä»¤ $dp[u]$ è¡¨ç¤ºä»èŠ‚ç‚¹ $u$ å‡ºå‘çš„æœ€é•¿è·¯é•¿åº¦ï¼Œåˆ™ $dp[u]=max_{(u,v)\\in E} dp[v]+w(u,v)$ã€‚\næ€»æ—¶é—´å¤æ‚åº¦ $O(n+m)$ã€‚\nB. æ—…è¡Œé—®é¢˜ é¢˜é¢æè¿° ç»™å®šä¸€ä¸ª $n$ ä¸ªç‚¹çš„å®Œå…¨å›¾ï¼Œ$A_{ij}$ è¡¨ç¤ºä» $i$ åˆ° $j$ çš„è¾¹æƒã€‚ç°è¦æ±‚ä»ä»»æ„ä¸€ç‚¹å‡ºå‘ï¼Œè‡³å°‘ç»è¿‡æ¯ä¸ªç‚¹ä¸€æ¬¡ï¼Œåˆ°ä»»æ„ä¸€ç‚¹ç»“æŸï¼Œæ±‚æœ€å°è·¯å¾„é•¿åº¦ã€‚ $n\\leq 20$ã€‚ é¢˜è§£ å…ˆç”¨ Floyd é¢„å¤„ç†ä¸¤ä¸¤ä¹‹é—´çš„æœ€çŸ­è·¯ $dist[i][j]$ã€‚ç„¶åè€ƒè™‘çŠ¶å‹ dp: ä»¤ $dp[Mask][i]$ è¡¨ç¤ºå½“å‰åœ¨èŠ‚ç‚¹ $i$ ï¼Œå·²ç»ç»è¿‡çš„ç‚¹çš„çŠ¶æ€ä¸º $Mask$ çš„æƒ…å†µä¸‹çš„æœ€å°è·ç¦»ï¼Œè½¬ç§»è€ƒè™‘æšä¸¾ä¸Šä¸€ä¸ªèŠ‚ç‚¹ $j$ å³å¯ã€‚å³ $$ dp[Mask][i]=\\min_{j\\in Mask,j\\neq i}dp[Mask-j][j]+dist[i][j] $$ æ³¨æ„æˆ‘ä»¬æ— éœ€æ‹…å¿ƒåœ¨ä» $i$ åˆ° $j$ çš„æœ€çŸ­è·¯ä¸Šç»è¿‡çš„å…¶ä»–ç‚¹æ²¡æœ‰è¢«æ ‡æ³¨è¿› $Mask$ï¼Œå› ä¸ºå¦‚æœæ²¡æœ‰è¢«æ ‡æ³¨è¿›æ˜¯å¯¹ç­”æ¡ˆçš„æŸå¤±ï¼Œè€Œäº‹å®ä¸Šä¸€å®šæœ‰ä¸€ç§è½¬ç§»æ–¹å¼æ˜¯æ­£ç¡®çš„ã€‚\næ€»æ—¶é—´å¤æ‚åº¦ $O(2^nn^2)$ã€‚\nC. ä¿®å»ºå…¬è·¯ é¢˜é¢æè¿° ç»™å®šä¸€ä¸ª $n$ ä¸ªç‚¹ï¼Œæ²¡æœ‰è¾¹çš„å›¾ã€‚å†ç»™å®š $m$ æ¡æœ‰å‘è¾¹ï¼Œå°†å…¶ä¸€ä¸€åŠ å…¥å›¾ä¸­ã€‚é—®å¯¹äºæ¯ä¸€ä¸ª $1\\leq i\\leq m$ï¼Œåœ¨ç¬¬ $i$ æ¡è¾¹è¢«åŠ å…¥åï¼Œæœ‰å¤šå°‘ä¸ªæœ‰åºå¯¹ $(u,v),u\\neq v$ æ»¡è¶³æœ‰ä» $u$ åˆ° $v$ çš„è·¯å¾„ã€‚ $n\\leq 400$ã€‚ é¢˜è§£1 è€ƒè™‘ç»™æ¯æ¡è¾¹ä¸€ä¸ªæƒå€¼ï¼šå®ƒè¢«åŠ å…¥å›¾çš„æ—¶é—´ã€‚å®šä¹‰ä¸€æ¡è·¯å¾„çš„é•¿åº¦ä¸ºç»è¿‡çš„æ‰€æœ‰è¾¹çš„æƒå€¼çš„æœ€å¤§å€¼ã€‚åˆ™æˆ‘ä»¬ç”¨ Floyd-Warshall ç®—æ³•å¯ä»¥æ±‚å‡ºå¤šæºæœ€çŸ­è·¯ï¼ˆè€ƒè™‘ Floyd çš„åŠ¨æ€è§„åˆ’è¿‡ç¨‹æ˜“è¯å…¶æ­£ç¡®æ€§ï¼‰ï¼Œè¿™ä¸ªæœ€çŸ­è·¯é•¿åº¦ $d(u,v)$ çš„æ„ä¹‰æ˜¯ä»æ—¶åˆ» $d(u,v)$ å¼€å§‹ï¼Œä»¥åä¸€ç›´å­˜åœ¨ä» $u$ åˆ° $v$ çš„è·¯å¾„ã€‚å› æ­¤æˆ‘ä»¬æšä¸¾æ¯ä¸ªç‚¹å¯¹ï¼Œæ ¹æ® $d$ å€¼çœ‹å®ƒå¯¹ç­”æ¡ˆçš„è´¡çŒ®å³å¯ã€‚\næ€»æ—¶é—´å¤æ‚åº¦ $O(n^3)$ã€‚\né¢˜è§£2 å¯¹äºæ¯æ¡æ–°åŠ çš„è¾¹ $(u,v)$ ï¼Œå¦‚æœåœ¨æ­¤ä¹‹å‰ $u$ å·²ç»å¯ä»¥åˆ° $v$ ï¼Œåˆ™è¿™æ¡è¾¹åŠ çš„æ²¡æœ‰æ„ä¹‰ã€‚å¦åˆ™æˆ‘ä»¬è€ƒè™‘è¿™æ¡è¾¹çš„åŠ å…¥ä¼šç»™ä¼ é€’é—­åŒ…å¸¦æ¥ä»€ä¹ˆå½±å“ã€‚\nè€ƒè™‘å¯¹æ¯ä¸ªèŠ‚ç‚¹ç»´æŠ¤ä¸¤ä¸ª bitsetï¼Œ$b_1(u)$ è¡¨ç¤º $u$ ç›®å‰å¯è¾¾çš„ç‚¹ï¼Œ$b_2(u)$ è¡¨ç¤ºç›®å‰å¯è¾¾ $u$ çš„ç‚¹ã€‚é‚£ä¹ˆå¯¹äº $(u,v)$ï¼Œæˆ‘ä»¬è€ƒè™‘ $b_2(u)$ ä¸­çš„æ‰€æœ‰ç‚¹ï¼Œç»™å®ƒä»¬çš„ $b_1$ bitset æˆ–ä¸Š $b_1(v)$ å³å¯ï¼ŒåŒç†å¯¹äº$b_1(v)$ ä¸­çš„æ‰€æœ‰ç‚¹ç»™å®ƒä»¬çš„ $b_2$ bitset æˆ–ä¸Š $b_2(u)$ã€‚è¿™æ ·çš„å¤æ‚åº¦ä¸º $O(\\frac{mn^2}{w})$ï¼Œä¸èƒ½é€šè¿‡ã€‚\nè€ƒè™‘åšä¸€ä¸ªç®€å•çš„ä¼˜åŒ–ï¼šå¯¹äº $b_2(u)$ ä¸­çš„ç‚¹ï¼Œå¦‚æœå®ƒä»¬å¯ä»¥åœ¨åŠ å…¥ $(u,v)$ ä¹‹å‰å°±å¯ä»¥åˆ°è¾¾ $v$ ï¼Œé‚£ä¹ˆæ˜¾ç„¶è¿™æ¬¡æˆ–æ“ä½œæ˜¯æ— æ•ˆçš„ï¼Œå› æ­¤æˆ‘ä»¬åªå¯¹é‚£äº› å¯ä»¥åˆ° $u$ ä½†ä¸èƒ½åˆ° $v$ çš„èŠ‚ç‚¹ è¿›è¡Œæˆ–æ“ä½œï¼ˆè¿™äº›èŠ‚ç‚¹å¯ä»¥é€šè¿‡ä½è¿ç®—å¿«é€Ÿå¾—å‡ºï¼‰ã€‚æˆ‘ä»¬å¯ä»¥è¯æ˜è¿™æ ·è¿›è¡Œæˆ–æ“ä½œçš„æ¬¡æ•°æœ€å¤š $O(n^2)$ æ¬¡ï¼š\n$n$ ä¸ªç‚¹çš„ bitset ä¸­ä¸€å…±æœ‰ $O(n^2)$ ä¸ªä½ç½®ï¼Œæ¯æ¬¡æˆ–æ“ä½œè‡³å°‘å¯ä»¥ä½¿ bitset ä¸­åˆ° $v$ çš„é‚£ä¸ªä½ç½®ä» 0 å˜æˆ 1ï¼Œå› æ­¤æ¯æ¬¡æˆ–æ“ä½œéƒ½ä¼šä½¿ 1 çš„ä¸ªæ•°å¢åŠ ï¼Œæ‰€ä»¥æœ€å¤šæœ‰ $O(n^2)$ æ¬¡æˆ–æ“ä½œã€‚\nå¯¹äº $v$ å¯åˆ°ä½† $u$ ä¸èƒ½åˆ° çš„èŠ‚ç‚¹ä¹Ÿæ˜¯åŒç†ã€‚é€šè¿‡å¤æ‚åº¦åˆ†æï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°è¯¥ç®—æ³•çš„å¤æ‚åº¦é™åˆ° $O(\\frac{n^3}{w})$ã€‚\nD. å€æ•° é¢˜é¢æè¿° ç»™å®šæ•´æ•° $n$ ï¼Œé—®æ‰€æœ‰çš„ $n\\times k (k\u0026gt;0)$ åœ¨äºŒè¿›åˆ¶è¡¨ç¤ºä¸‹ $1$â€‹ çš„ä¸ªæ•°æœ€å°‘æ˜¯å¤šå°‘ã€‚ $n\\leq 10^6$ã€‚ é¢˜è§£ ä»»ä½•ä¸€ä¸ª $n$ çš„å€æ•°éƒ½å¯ä»¥é€šè¿‡è¿™ä¸ªæ–¹å¼ç”Ÿæˆï¼š\nè¿›è¡Œä»¥ä¸‹æ“ä½œæœ‰é™æ¬¡ï¼š\nç»™å½“å‰æ•° $+n$ å¹¶ $\\times 2$ ï¼Œæˆ–è€…ç»™å½“å‰æ•° $+0$ å¹¶ $\\times 2$ã€‚\nè¿™æ ·ç”Ÿæˆçš„æ•°å¿…å®šå¯ä»¥è¢«è¡¨ç¤ºä¸º $\\sum n\\times 2^k$ çš„å½¢å¼ï¼Œå› æ­¤å¯ä»¥è¡¨ç¤ºæ‰€æœ‰çš„ $n$ çš„å€æ•°ã€‚\nè€ƒè™‘å¦‚ä¸‹åŠ¨æ€è§„åˆ’ï¼šä»¤ $dp[i]$ è¡¨ç¤ºç”Ÿæˆä¸€ä¸ªå‰ç¼€ä¸º $i$ çš„æ•°ï¼Œåœ¨ $i$ ä¹‹åçš„éƒ¨åˆ†æœ€å°‘æœ‰å¤šå°‘ä¸ª $1$ ã€‚è€ƒè™‘å‘åè½¬ç§»ï¼šè¿›è¡Œä¸€æ¬¡ä¸Šè¿°çš„æ“ä½œå¯ä»¥ç¡®å®šäºŒè¿›åˆ¶ä¸‹çš„ä¸€ä½ï¼Œæ‰€ä»¥ $$ \\begin{align} dp[i\u0026gt;\u0026gt;1] \u0026amp;\\leftarrow dp[i]+(i\\\u0026amp;1) \\\\ dp[(i+n)\u0026gt;\u0026gt;1]\\ \u0026amp;\\leftarrow dp[i]+((i+n)\\\u0026amp;1) \\end{align} $$ ç”±äºæˆ‘ä»¬ä¸èƒ½ç¡®å®šè½¬ç§»çš„é¡ºåºï¼Œæ‰€ä»¥å¯ä»¥å»ºå›¾ä¹‹åè·‘æœ€çŸ­è·¯ã€‚æ³¨æ„åˆ°è¾¹æƒåªæœ‰ $0$ å’Œ $1$ ä¸¤ç§ï¼Œæ‰€ä»¥ç”¨ 01bfs å³å¯ã€‚\næ€»æ—¶é—´å¤æ‚åº¦ $O(n)$ã€‚\nè¡¥å……é¢˜1. [POJ1734] Sightseeing Trip é¢˜é¢æè¿° ä¼ é€é—¨ ç»™å®šä¸€ä¸ª $n$ ä¸ªç‚¹ $m$ æ¡è¾¹çš„æ— å‘å›¾ï¼Œè¦æ±‚åœ¨å…¶ä¸­æ‰¾åˆ°ä¸€ä¸ªç‚¹æ•°å¤§äº $2$ çš„ç¯ï¼Œä½¿å…¶è¾¹æƒä¹‹å’Œæœ€å°ï¼Œè¾“å‡ºè¿™ä¸ªåœˆæˆ–è€…è¾“å‡º No solution. ã€‚ $n\\leq 100,m\\leq 10000$ã€‚ é¢˜è§£ å¯¹ Floyd-Warshall ç®—æ³•çš„åº”ç”¨ã€‚è€ƒè™‘ Floyd åŸå¼çš„åŠ¨æ€è§„åˆ’æ€æƒ³ï¼Œåœ¨ç¬¬ $k$ è½®å¾ªç¯å¼€å§‹æ—¶ï¼Œ$dist[i][j]$ ä¿å­˜çš„æ˜¯ä» $i$ åˆ° $j$ ä¸”ä¸­é—´åªç»è¿‡äº† $1$~$k-1$ çš„æœ€çŸ­è·ç¦»ã€‚å› æ­¤åœ¨ç¬¬ $k$ è½®å¾ªç¯å¼€å§‹æ—¶ï¼Œæˆ‘ä»¬è€ƒè™‘æ‰€æœ‰ç¼–å·æœ€å¤§çš„ç‚¹æ˜¯ $k$ çš„ç¯ï¼Œæˆ‘ä»¬æšä¸¾ä¸ $k$ ç›¸é‚»çš„ä¸¤ä¸ªç‚¹ $i$ å’Œ $j$ $(i,j\u0026lt;k)$ï¼Œç”¨ $dist[i][j]$ å’Œ $k$ ä¸ $i$ ï¼Œ$k$ ä¸ $j$ çš„è¾¹æƒä¹‹å’Œæ¥æ›´æ–°ç­”æ¡ˆã€‚\næ¬²æ‰“å°è¿™ä¸ªåœˆï¼Œæˆ‘ä»¬å¯¹æ¯ä¸ª $dist[i][j]$ é¢å¤–è®°å½•ä¸€ä¸ª $mid[i][j]$ è¡¨ç¤ºæœ€çŸ­è·¯ä¸­æƒå€¼æœ€å¤§çš„ç‚¹æ˜¯å“ªä¸ªã€‚è¿™æ ·å¯ä»¥å°†è·¯å¾„åˆ†æˆ $i\\rightsquigarrow mid[i][j]$ å’Œ $mid[i][j]\\rightsquigarrow j$ ä¸¤éƒ¨åˆ†ï¼Œé€’å½’æ±‚è§£ã€‚é¡»è¦æ³¨æ„çš„æ˜¯ï¼Œè·¯å¾„å¿…é¡»åœ¨æ‰¾åˆ°æ›´çŸ­è·¯å¾„çš„åŒæ—¶å°±å‡ºæ¥ï¼Œå¦åˆ™åœ¨åç»­å¾ªç¯ä¸­ $mid[i][j]$ ä¼šè¢«æ›´æ–°ã€‚\næ€»æ—¶é—´å¤æ‚åº¦ $O(n^3)$ã€‚\nè¡¥å……é¢˜2. [Luogu1119] ç¾åé‡å»º é¢˜é¢æè¿° ä¼ é€é—¨ ç»™å®šä¸€ä¸ª $n$ ä¸ªç‚¹ $m$ æ¡è¾¹çš„å›¾ï¼Œç¬¬ $i$ ä¸ªç‚¹ä¼šåœ¨ $t_i$ æ—¶åˆ»ä»¥åŠä¹‹åå¼€æ”¾ã€‚æœ‰ $q$ ä¸ªè¯¢é—®ï¼Œæ¯ä¸ªè¯¢é—®ç»™å®š $x,y,t$ ï¼Œé—®åœ¨ $t$ æ—¶åˆ»ä» $x$ åˆ° $y$ çš„æœ€çŸ­è·ç¦»ã€‚ $n\\leq 200,q\\leq 50000$ã€‚ é¢˜è§£ ä»ç„¶æ˜¯å¯¹ Floyd-Warshall ç®—æ³•çš„åº”ç”¨ã€‚æˆ‘ä»¬æŒ‰ç…§èŠ‚ç‚¹å¼€æ”¾çš„æ—¶é—´é¡ºåºä½œä¸ºä¸­è½¬ç‚¹è¿›è¡Œ floyd å¹¶å®æ—¶è®¡ç®—å½“å‰åº”è¯¥è®¡ç®—çš„è¯¢é—®å³å¯ã€‚æ€»æ—¶é—´å¤æ‚åº¦ $O(n^3)$ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"707b9626961771a76325b7433c68b736","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-problem-solving/oj-solutions/iii-02/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/nju-problem-solving/oj-solutions/iii-02/","section":"notes","summary":"A. æœ€é•¿è·¯ é¢˜é¢æè¿° ç»™å®šä¸€ä¸ª $n$ ä¸ªç‚¹ $m$ æ¡è¾¹çš„æœ‰å‘æ— ç¯å›¾ï¼Œæ±‚å›¾ä¸­æœ€é•¿è·¯çš„é•¿åº¦ã€‚ $1\\leq n\\leq 2\\times 10^{5},1\\leq m\\leq min\\{\\frac{n(n-1)}{2},5\\times 10^5\\}$ã€‚ é¢˜è§£ ä»¤ $dp[u]$ è¡¨ç¤ºä»èŠ‚ç‚¹ $u$ å‡ºå‘çš„æœ€é•¿è·¯é•¿åº¦ï¼Œåˆ™ $dp[u]=max_{(u,v)\\in E} dp[v]+w(u,v)$ã€‚\næ€»æ—¶é—´å¤æ‚åº¦ $O(n+m)$ã€‚\nB. æ—…è¡Œé—®é¢˜ é¢˜é¢æè¿° ç»™å®šä¸€ä¸ª $n$ ä¸ªç‚¹çš„å®Œå…¨å›¾ï¼Œ$A_{ij}$ è¡¨ç¤ºä» $i$ åˆ° $j$ çš„è¾¹æƒã€‚ç°è¦æ±‚ä»ä»»æ„ä¸€ç‚¹å‡ºå‘ï¼Œè‡³å°‘ç»è¿‡æ¯ä¸ªç‚¹ä¸€æ¬¡ï¼Œåˆ°ä»»æ„ä¸€ç‚¹ç»“æŸï¼Œæ±‚æœ€å°è·¯å¾„é•¿åº¦ã€‚ $n\\leq 20$ã€‚ é¢˜è§£ å…ˆç”¨ Floyd é¢„å¤„ç†ä¸¤ä¸¤ä¹‹é—´çš„æœ€çŸ­è·¯ $dist[i][j]$ã€‚ç„¶åè€ƒè™‘çŠ¶å‹ dp: ä»¤ $dp[Mask][i]$ è¡¨ç¤ºå½“å‰åœ¨èŠ‚ç‚¹ $i$ ï¼Œå·²ç»ç»è¿‡çš„ç‚¹çš„çŠ¶æ€ä¸º $Mask$ çš„æƒ…å†µä¸‹çš„æœ€å°è·ç¦»ï¼Œè½¬ç§»è€ƒè™‘æšä¸¾ä¸Šä¸€ä¸ªèŠ‚ç‚¹ $j$ å³å¯ã€‚å³ $$ dp[Mask][i]=\\min_{j\\in Mask,j\\neq i}dp[Mask-j][j]+dist[i][j] $$ æ³¨æ„æˆ‘ä»¬æ— éœ€æ‹…å¿ƒåœ¨ä» $i$ åˆ° $j$ çš„æœ€çŸ­è·¯ä¸Šç»è¿‡çš„å…¶ä»–ç‚¹æ²¡æœ‰è¢«æ ‡æ³¨è¿› $Mask$ï¼Œå› ä¸ºå¦‚æœæ²¡æœ‰è¢«æ ‡æ³¨è¿›æ˜¯å¯¹ç­”æ¡ˆçš„æŸå¤±ï¼Œè€Œäº‹å®ä¸Šä¸€å®šæœ‰ä¸€ç§è½¬ç§»æ–¹å¼æ˜¯æ­£ç¡®çš„ã€‚","tags":null,"title":"é—®é¢˜æ±‚è§£ III - 02 é¢˜è§£","type":"docs"},{"authors":null,"categories":null,"content":"A. æ‹“æ‰‘æ’åº é¢˜é¢æè¿° ç»™å®š $n$ ä¸ªç‚¹ $m$ æ¡è¾¹çš„æœ‰å‘æ— ç¯å›¾ï¼Œæ±‚å­—å…¸åºæœ€å°çš„æ‹“æ‰‘åºã€‚ $n,m\\leq 10^5$ã€‚ é¢˜è§£ å°†æ‰€æœ‰å…¥åº¦ä¸º 0 çš„ç‚¹åŠ å…¥å°æ ¹å †ï¼Œæ¯æ¬¡å–å †é¡¶å…ƒç´ ï¼Œæ›´æ–°å…¶ç›¸é‚»èŠ‚ç‚¹çš„å…¥åº¦ï¼Œå¹¶å°†æ–°äº§ç”Ÿçš„å…¥åº¦ä¸º 0 çš„ç‚¹å…¥å †å³å¯ã€‚æ€»æ—¶é—´å¤æ‚åº¦ $O(m+nlogn)$ã€‚\nB. Acesrc Riding the Fences é¢˜é¢æè¿° ç»™å®š $n$ ä¸ªç‚¹ $m$ æ¡è¾¹çš„æ— å‘å›¾ï¼Œä¿è¯å­˜åœ¨æ¬§æ‹‰è·¯å¾„/æ¬§æ‹‰å›è·¯ã€‚æ±‚å­—å…¸åºæœ€å°çš„æ¬§æ‹‰å›è·¯/è·¯å¾„ã€‚ $n\\leq 500,m\\leq 1024$ã€‚ é¢˜è§£ åŸºäº Fleury ç®—æ³•çš„åŸºæœ¬æ€æƒ³ï¼Œç»™å‡ºå¦‚ä¸‹çš„æ ¸å¿ƒä»£ç ã€‚è¯¥ç®—æ³•ç›´æ¥è´ªå¿ƒåœ°èµ°å°½å¯èƒ½å°çš„é‚»è¾¹ï¼Œä¸å»è¯¦ç»†åˆ†ææŸæ¡è¾¹æ˜¯å¦æ˜¯æ¡¥ï¼Œå¦‚æœåœ¨æœ‰å…¶ä»–é€‰æ‹©çš„æ—¶å€™èµ°äº†æ¡¥ï¼Œé‚£ä¹ˆåœ¨å›æº¯çš„æ—¶å€™ä¼šè¢«è‡ªåŠ¨è§†ä¸ºæœ€åèµ°äº†æ¡¥ã€‚\nvoid fleury(int cur)\r{\rsta[++stot]=cur;\rrep(i,1,500) if (ga[cur][i])\r{\rga[cur][i]--;ga[i][cur]--;\rfleury(i);\r}\rans[++tot]=sta[stot--];\r}\ræ—¶é—´å¤æ‚åº¦ $O(nm)$ï¼Œä½¿ç”¨é‚»æ¥è¡¨å­˜å‚¨å›¾å¯ä»¥åšåˆ° $O(n+m)$ã€‚\nC. æ—…è¡Œå®¶ é¢˜é¢æè¿° ç»™å®šä¸€å¼  $n$ ä¸ªç‚¹ $m$ æ¡è¾¹çš„å¸¦æƒæ— å‘å›¾ã€‚ä¸€æ¡è·¯å¾„çš„ä»£ä»·æ˜¯æ‰€æœ‰è¾¹çš„è¾¹æƒä¾æ¬¡è¿æ¥èµ·æ¥ç»„æˆçš„æ•°çš„å¤§å°ã€‚æ±‚ 1 å·èŠ‚ç‚¹åˆ°æ¯ä¸ªèŠ‚ç‚¹çš„ä»£ä»·çš„æœ€å°å€¼å¯¹ $1e9+7$ å–æ¨¡çš„ç»“æœã€‚ $n,m\\leq 10^5,1\\leq w\\leq 10^9$ã€‚ é¢˜è§£ å°†æ¯æ¡è¾¹æ‹†æˆä½æ•°æ¡è¾¹ï¼Œæ¯æ¡è¾¹çš„æƒå€¼éƒ½æ˜¯ä¸€ä½æ•°ï¼Œè¿™æ ·å¯¹è¿™å¹…å›¾åšå®½æœï¼Œè¾¹æ•°æœ€å°‘çš„è·¯å¾„ä¸€å®šä¹Ÿæ˜¯ç»„æˆçš„æ•°ä½æ•°æœ€å°çš„è·¯å¾„ã€‚\nä¸€ä¸ªå›°éš¾ç‚¹æ˜¯å¦‚ä½•å¤„ç†æƒå€¼ç›¸åŒçš„ç‚¹ã€‚ä¾‹å¦‚ $x$ å’Œ $y$ çš„æƒå€¼éƒ½æ˜¯ 123ï¼Œ$x$ å…ˆå‡ºé˜Ÿå¹¶æ›´æ–° $z$ çš„æƒå€¼ä¸º 1234 å…¥é˜Ÿï¼Œ$y$ å†å‡ºé˜Ÿå¹¶æ›´æ–° $w$ çš„æƒå€¼ä¸º 1231 å…¥é˜Ÿï¼Œè¿™æ—¶é˜Ÿåˆ—ä¸­çš„å•è°ƒæ€§å°±è¢«æ‰“ç ´äº†ã€‚\nå› æ­¤æˆ‘ä»¬åº”è¯¥å°†æƒå€¼ç›¸åŒçš„ç‚¹ä¸€å¹¶è€ƒè™‘ï¼Œå¯¹äºæŸç§æƒå€¼ï¼Œå¯¹äºæ‰€æœ‰æ»¡è¶³è¯¥æƒå€¼çš„ç‚¹ï¼Œä»å°åˆ°å¤§æšä¸¾é‚»è¾¹ï¼Œå¹¶å°†æ‰€æœ‰æ»¡è¶³æ¡ä»¶çš„ç›¸é‚»ç‚¹æ‰“åŒ…èµ·æ¥æ”¾è¿›é˜Ÿåˆ—ã€‚\næ–°å»ºçš„å›¾ä¸­å°†æœ‰ $10m$ çº§åˆ«çš„è¾¹ï¼Œå¯¹äºå®½æœæ¥è¯´é‡çº§æ˜¯å¯ä»¥æ¥å—çš„ã€‚\næ€»æ—¶é—´å¤æ‚åº¦ $O(\\mid w\\mid (n+m))$ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"79c867386851a111623785ff9e972d9b","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-problem-solving/oj-solutions/iii-03/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/nju-problem-solving/oj-solutions/iii-03/","section":"notes","summary":"A. æ‹“æ‰‘æ’åº é¢˜é¢æè¿° ç»™å®š $n$ ä¸ªç‚¹ $m$ æ¡è¾¹çš„æœ‰å‘æ— ç¯å›¾ï¼Œæ±‚å­—å…¸åºæœ€å°çš„æ‹“æ‰‘åºã€‚ $n,m\\leq 10^5$ã€‚ é¢˜è§£ å°†æ‰€æœ‰å…¥åº¦ä¸º 0 çš„ç‚¹åŠ å…¥å°æ ¹å †ï¼Œæ¯æ¬¡å–å †é¡¶å…ƒç´ ï¼Œæ›´æ–°å…¶ç›¸é‚»èŠ‚ç‚¹çš„å…¥åº¦ï¼Œå¹¶å°†æ–°äº§ç”Ÿçš„å…¥åº¦ä¸º 0 çš„ç‚¹å…¥å †å³å¯ã€‚æ€»æ—¶é—´å¤æ‚åº¦ $O(m+nlogn)$ã€‚\nB. Acesrc Riding the Fences é¢˜é¢æè¿° ç»™å®š $n$ ä¸ªç‚¹ $m$ æ¡è¾¹çš„æ— å‘å›¾ï¼Œä¿è¯å­˜åœ¨æ¬§æ‹‰è·¯å¾„/æ¬§æ‹‰å›è·¯ã€‚æ±‚å­—å…¸åºæœ€å°çš„æ¬§æ‹‰å›è·¯/è·¯å¾„ã€‚ $n\\leq 500,m\\leq 1024$ã€‚ é¢˜è§£ åŸºäº Fleury ç®—æ³•çš„åŸºæœ¬æ€æƒ³ï¼Œç»™å‡ºå¦‚ä¸‹çš„æ ¸å¿ƒä»£ç ã€‚è¯¥ç®—æ³•ç›´æ¥è´ªå¿ƒåœ°èµ°å°½å¯èƒ½å°çš„é‚»è¾¹ï¼Œä¸å»è¯¦ç»†åˆ†ææŸæ¡è¾¹æ˜¯å¦æ˜¯æ¡¥ï¼Œå¦‚æœåœ¨æœ‰å…¶ä»–é€‰æ‹©çš„æ—¶å€™èµ°äº†æ¡¥ï¼Œé‚£ä¹ˆåœ¨å›æº¯çš„æ—¶å€™ä¼šè¢«è‡ªåŠ¨è§†ä¸ºæœ€åèµ°äº†æ¡¥ã€‚","tags":null,"title":"é—®é¢˜æ±‚è§£ III - 03 é¢˜è§£","type":"docs"},{"authors":null,"categories":null,"content":"A. Acesrc\u0026rsquo;s Bizarre Adventure é¢˜é¢æè¿° ç»™å®š $n$ ä¸ªçº¢è‰²çš„ç‚¹å’Œ $n$ ä¸ªè“è‰²çš„ç‚¹ï¼Œæ¯ä¸ªç‚¹æœ‰åæ ‡ $(x,y)$ã€‚å¦‚æœä¸€ä¸ªè“è‰²çš„ç‚¹æ»¡è¶³ä¸¤ä¸ªåæ ‡éƒ½æ˜¯æŸä¸ªçº¢è‰²ç‚¹åæ ‡çš„ä¸¤å€ä»¥ä¸Šï¼Œåˆ™è¯¥è“ç‚¹å’Œçº¢ç‚¹å¯ä»¥é…å¯¹ã€‚é—®æœ€å¤šèƒ½é…æˆå¤šå°‘å¯¹ã€‚ $n\\leq 100$ã€‚ é¢˜è§£ åœ¨å¯ä»¥é…å¯¹çš„è“ç‚¹å’Œçº¢ç‚¹ä¹‹é—´è¿è¾¹ï¼Œè¯¥é—®é¢˜å³è½¬åŒ–ä¸ºäºŒåˆ†å›¾æœ€å¤§åŒ¹é…ã€‚å¯ä»¥åˆ©ç”¨åŒˆç‰™åˆ©ç®—æ³•æ±‚è§£ï¼Œä¹Ÿå¯ä»¥å»ºç«‹è¶…çº§æºç‚¹ã€è¶…çº§æ±‡ç‚¹åæ±‚æœ€å¤§æµã€‚\nB. Acesrc Doesn\u0026rsquo;t Want To Bite The Dust é¢˜é¢æè¿° æœ‰ $n$ ä¸ªäºŒæ¬¡å‡½æ•°ï¼Œç¬¬ $i$ ä¸ªå½¢å¦‚ $f_i(x)=a_ix^2+b_ix+c_i$ï¼Œè¦æ±‚ $x_i\\in [L_i,R_i]$ã€‚æœ‰ $m$ ä¸ªé¢å¤–çš„é™åˆ¶ï¼Œæ¯ä¸ªé™åˆ¶æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(u,v,d)$ï¼Œè¡¨ç¤ºè¦æ±‚ $x_u\\leq x_v+d$ã€‚æ±‚åœ¨æ»¡è¶³æ‰€æœ‰é™åˆ¶çš„æƒ…å†µä¸‹ï¼Œ$\\sum_{i=1}^nf_i(x_i)$ çš„æœ€å¤§å€¼ã€‚ $n\\leq 50,m\\leq 100,-100\\leq L_i,R_i\\leq 100$ã€‚ é¢˜è§£ åŸå‹æ˜¯æ´›è°·3227åˆ‡ç³•ï¼Œæ¯”è¾ƒéš¾æƒ³çš„æœ€å°å‰²å»ºæ¨¡ã€‚\nå¦‚æœæ²¡æœ‰é¢å¤–é™åˆ¶ï¼Œé‚£ä¹ˆä¸€ä¸ªæœ€å°å‰²æ¨¡å‹æ˜¯æ˜¾ç„¶çš„ï¼šå¯¹äºæ¯ä¸ªå‡½æ•°ï¼Œå»ºä¸€æ¡æœ‰ $R-L+1$ æ¡è¾¹çš„é“¾ã€‚æ¯æ¡è¾¹çš„å®¹é‡æ˜¯äºŒæ¬¡å‡½æ•°è‡ªå˜é‡åœ¨è¯¥å¤„å–å€¼æ—¶çš„å‡½æ•°å€¼ã€‚å°† $n$ æ¡é“¾çš„é¦–å°¾åˆ†åˆ«ä¸è¶…çº§æºç‚¹ï¼Œè¶…çº§æ±‡ç‚¹è¿æ¥å³å¯ã€‚\nç°åœ¨è€ƒè™‘å¦‚ä½•æ»¡è¶³é¢å¤–é™åˆ¶ã€‚æœ€å°å‰²å»ºæ¨¡æ¨¡æ‹Ÿé™åˆ¶çš„æ ¸å¿ƒæ€æƒ³åœ¨äºä½¿ç½‘ç»œåœ¨çº¦æŸä¸æ»¡è¶³æ—¶æœ‰æ— æ³•å‰²å»çš„ $s-t$ é€šè·¯ã€‚ å¯¹äºä¸€ä¸ª $x_u\\leq x_v+d$ï¼Œå½“ $x_v=x$ æ—¶ï¼Œæˆ‘ä»¬åœ¨ $v$ çš„å‡½æ•°ä¸Šå‰²å»çš„æ˜¯å¯¹åº” $x$ çš„è¾¹ï¼Œé‚£ä¹ˆ $x+1$ å³ä»¥ä¸Šçš„è¾¹éƒ½å±äº $T$ é›†åˆã€‚å¦‚æœæ­¤æ—¶ $x_u\\geq x+d+1$ï¼Œé‚£ä¹ˆè¾¹ $x+d+1$ å·¦è¾¹çš„èŠ‚ç‚¹ä¸€å®šåœ¨ $S$ é›†åˆä¸­ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åªè¦å¯¹äºæ¯ä¸ª $x$ï¼Œä» $u$ å‡½æ•°çš„ $x+d+1$ è¾¹å·¦ç«¯ç‚¹å‘ $v$ å‡½æ•°çš„ $x+1$ è¾¹å·¦ç«¯ç‚¹è¿å®¹é‡ä¸º $\\infty$ çš„è¾¹å³å¯ã€‚\nè¿˜æœ‰ä¸€ä¸ªå¾®å°çš„é—®é¢˜æ˜¯è¿™æ ·æ±‚å‡ºçš„æ˜¯ç›®æ ‡å‡½æ•°çš„æœ€å°å€¼ï¼Œè€Œæˆ‘ä»¬è¦æ±‚çš„æ˜¯æœ€å¤§å€¼ã€‚æˆ‘ä»¬å¯ä»¥è®¾å®šä¸€ä¸ªå¾ˆå¤§çš„é˜ˆå€¼ $M$ï¼Œç„¶åä»¤ $f\u0026rsquo;(x)=M-f(x)$ï¼Œè¿™æ ·æœ€å°åŒ– $\\sum_{i=1}^nf\u0026rsquo;(x_i)$ å°±æ˜¯æœ€å¤§åŒ– $\\sum_{i=1}^nf(x_i)$ã€‚\nC. æœ€å°åŒ– é¢˜é¢æè¿° æœ‰ $n$ ä¸ªå˜é‡ï¼Œæ¯ä¸ªå–å€¼å¯ä»¥æ˜¯ $-w$ æˆ– $w$ã€‚æœ‰ $q$ ä¸ªé™åˆ¶å’Œä¸€äº›ç›®æ ‡å‡½æ•°ï¼Œæ±‚ç›®æ ‡å‡½æ•°æœ€å°å€¼ã€‚ $n\\leq 1000ï¼Œq\\leq 3000$ã€‚ é¢˜è§£ æ¯ä¸ªå˜é‡åªæœ‰ä¸¤ç§å–å€¼ï¼Œè¿™ç§ç»™ä¸€äº›å˜é‡è¿›è¡ŒäºŒåˆ†ç±»çš„éœ€æ±‚æ˜¯æœ€å°å‰²æ¨¡å‹çš„å…¸å‹ç‰¹å¾ã€‚\næˆ‘ä»¬å»ºç«‹è¶…çº§æºç‚¹ã€è¶…çº§æ±‡ç‚¹ï¼Œå¹¶ç»™æ¯ä¸ªå˜é‡å»ºä¸€ä¸ªç‚¹ã€‚åœ¨æœ€ç»ˆå®Œæˆæœ€å°å‰²çš„æ®‹ä½™ç½‘ç»œä¸­ï¼Œå¦‚æœä¸€ä¸ªç‚¹è¿å‘ $s$ è¡¨ç¤ºå®ƒæœ€ç»ˆçš„å–å€¼æ˜¯ $-w$ï¼Œè¿å‘ $t$ è¡¨ç¤ºå®ƒæœ€ç»ˆçš„å–å€¼æ˜¯ $w$ã€‚è€ƒè™‘å¦‚ä½•å»ºè¾¹ä»¥æ»¡è¶³çº¦æŸã€‚\næ¯ä¸ªèŠ‚ç‚¹å‘ $s$ è¿å®¹é‡ä¸º $w$ çš„è¾¹ï¼Œè¡¨ç¤ºå‰²å»è¿™æ¡è¾¹æ„å‘³ç€è¯¥ç‚¹å»äº† $T$ï¼Œä¼šä»˜å‡º $w$ çš„ä»£ä»·ã€‚ç±»ä¼¼åœ°ï¼Œæ¯ä¸ªèŠ‚ç‚¹å‘ $t$ è¿å®¹é‡ä¸º $-w$ çš„è¾¹ã€‚ å¯¹äºé™åˆ¶ $w_x\\leq w_y$ï¼Œå»ºç«‹ä» $y$ åˆ° $x$ ï¼Œå®¹é‡ä¸º $\\infty$ çš„è¾¹ã€‚è¿™æ ·å¦‚æœ $y\\in S,x\\in T$ï¼Œå°†ä¼šå­˜åœ¨æ— æ³•å‰²å»çš„ $s-t$ é€šè·¯ã€‚ å¯¹äºé™åˆ¶ $w_x=w_y$ ï¼Œåˆ†åˆ«å»ºç«‹ä» $x$ åˆ° $y$ å’Œä» $y$ åˆ° $x$ï¼Œå®¹é‡ä¸º $\\infty$ çš„è¾¹ã€‚ä¸€æ—¦è¿™ä¸¤ä¸ªç‚¹åˆ†å±äºä¸åŒçš„é›†åˆï¼Œå°†ä¼šå­˜åœ¨æ— æ³•å‰²å»çš„ $s-t$ é€šè·¯ã€‚ å¯¹äºé™åˆ¶ $w_x\u0026lt;w_y$ï¼Œç›¸å½“äºè§„å®šäº† $w_x=-w,w_y=w$ï¼Œæˆ‘ä»¬åœ¨ç¬¬ä¸€æ­¥çš„çº¦æŸä¸­ä¿®æ”¹ $(s,x)$ å’Œ $(y,t)$ çš„å®¹é‡ä¸º $\\infty$ å³å¯ã€‚ å¯¹äºä»£ä»·å‡½æ•°ä¸­çš„ $c|w_x-w_y|$ éƒ¨åˆ†ï¼Œå½“ $w_x\\neq w_y$ æ—¶ä¼šäº§ç”Ÿ $2cw$ çš„ä»£ä»·ï¼Œå¦åˆ™æ²¡æœ‰ä»£ä»·ã€‚å› æ­¤åˆ†åˆ«å»ºç«‹ä» $x$ åˆ° $y$ å’Œä» $y$ åˆ° $x$ï¼Œå®¹é‡ä¸º $2cw$ çš„è¾¹ã€‚ä¸€æ—¦è¿™ä¸¤ä¸ªç‚¹åˆ†å±äºä¸åŒçš„é›†åˆï¼Œå°±å¿…é¡»å‰²æ‰è¿™æ¡è¾¹ä»˜å‡ºç›¸åº”çš„ä»£ä»·ã€‚ å¯¹äºä»£ä»·å‡½æ•°ä¸­çš„ $c(w_x-w_y)$ éƒ¨åˆ†ï¼Œå¯ä»¥æ‹†æ‹¬å·å°†ç³»æ•°åˆ†åˆ°æ¯ä¸ªå˜é‡è‡ªå·±å¤´ä¸Šã€‚æˆ‘ä»¬å†æ¬¡ä¿®æ”¹ç¬¬ä¸€æ­¥ä¸­çš„æƒå€¼ï¼Œæå‰è®¡ç®—å¥½æ¯ä¸ªå˜é‡åœ¨ç›®æ ‡å‡½æ•°ä¸­è¢«ç´¯åŠ çš„æ¬¡æ•°ï¼Œè¾¹æƒä¹˜ä¸Šè¯¥ç³»æ•°å³å¯ã€‚ è¯¥ç½‘ç»œå·²ç»å¯ä»¥æ¨¡æ‹ŸåŸé¢˜ï¼Œä½†è¿˜æœ‰ä¸€ä¸ªé—®é¢˜åœ¨äºè¯¥ç½‘ç»œä¸­å­˜åœ¨è´Ÿæƒï¼Œä¸æ–¹ä¾¿ä½¿ç”¨æœ€å¤§æµç®—æ³•æ±‚è§£ã€‚è§£å†³è´Ÿæƒçš„å¸¸ç”¨æ‰‹æ³•æ˜¯å…ˆé¢„è®¡ç®—ä¸€ä¸ªå°çš„ä»£ä»·ï¼Œå¦‚æœæœ€ç»ˆé€‰æ‹©äº†å¤§çš„å†è¡¥å·®ä»·ã€‚ä»¥ç¬¬ä¸€ç§å»ºè¾¹ä¸ºä¾‹ï¼Œæˆ‘ä»¬å…ˆé¢„å…ˆåœ¨ç­”æ¡ˆä¸­åŠ ä¸Š $-w\\cdot n$ï¼Œè¡¨ç¤ºå…ˆè®¤ä¸ºæ¯ä¸ªå˜é‡çš„å–å€¼éƒ½æ˜¯ $-w$ï¼Œè¿™æ ·å»ºè¾¹æ—¶å¦‚æœå®ƒç¡®å®æ˜¯ $-w$ï¼Œåˆ™ä»£ä»·ä¸º0ï¼Œå¦‚æœæ˜¯ $w$ åˆ™ä»£ä»·ä¸º $2w$ï¼Œä»è€Œè½¬ä¸ºéè´Ÿæƒã€‚å…¶ä»–éƒ¨åˆ†çš„å¤„ç†æ‰‹æ³•ç±»ä¼¼ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"b85029f35294061639dc9309cd688ca8","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-problem-solving/oj-solutions/iii-04/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/nju-problem-solving/oj-solutions/iii-04/","section":"notes","summary":"A. Acesrc\u0026rsquo;s Bizarre Adventure é¢˜é¢æè¿° ç»™å®š $n$ ä¸ªçº¢è‰²çš„ç‚¹å’Œ $n$ ä¸ªè“è‰²çš„ç‚¹ï¼Œæ¯ä¸ªç‚¹æœ‰åæ ‡ $(x,y)$ã€‚å¦‚æœä¸€ä¸ªè“è‰²çš„ç‚¹æ»¡è¶³ä¸¤ä¸ªåæ ‡éƒ½æ˜¯æŸä¸ªçº¢è‰²ç‚¹åæ ‡çš„ä¸¤å€ä»¥ä¸Šï¼Œåˆ™è¯¥è“ç‚¹å’Œçº¢ç‚¹å¯ä»¥é…å¯¹ã€‚é—®æœ€å¤šèƒ½é…æˆå¤šå°‘å¯¹ã€‚ $n\\leq 100$ã€‚ é¢˜è§£ åœ¨å¯ä»¥é…å¯¹çš„è“ç‚¹å’Œçº¢ç‚¹ä¹‹é—´è¿è¾¹ï¼Œè¯¥é—®é¢˜å³è½¬åŒ–ä¸ºäºŒåˆ†å›¾æœ€å¤§åŒ¹é…ã€‚å¯ä»¥åˆ©ç”¨åŒˆç‰™åˆ©ç®—æ³•æ±‚è§£ï¼Œä¹Ÿå¯ä»¥å»ºç«‹è¶…çº§æºç‚¹ã€è¶…çº§æ±‡ç‚¹åæ±‚æœ€å¤§æµã€‚\nB. Acesrc Doesn\u0026rsquo;t Want To Bite The Dust é¢˜é¢æè¿° æœ‰ $n$ ä¸ªäºŒæ¬¡å‡½æ•°ï¼Œç¬¬ $i$ ä¸ªå½¢å¦‚ $f_i(x)=a_ix^2+b_ix+c_i$ï¼Œè¦æ±‚ $x_i\\in [L_i,R_i]$ã€‚æœ‰ $m$ ä¸ªé¢å¤–çš„é™åˆ¶ï¼Œæ¯ä¸ªé™åˆ¶æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(u,v,d)$ï¼Œè¡¨ç¤ºè¦æ±‚ $x_u\\leq x_v+d$ã€‚æ±‚åœ¨æ»¡è¶³æ‰€æœ‰é™åˆ¶çš„æƒ…å†µä¸‹ï¼Œ$\\sum_{i=1}^nf_i(x_i)$ çš„æœ€å¤§å€¼ã€‚ $n\\leq 50,m\\leq 100,-100\\leq L_i,R_i\\leq 100$ã€‚ é¢˜è§£ åŸå‹æ˜¯æ´›è°·3227åˆ‡ç³•ï¼Œæ¯”è¾ƒéš¾æƒ³çš„æœ€å°å‰²å»ºæ¨¡ã€‚","tags":null,"title":"é—®é¢˜æ±‚è§£ III - 04 é¢˜è§£","type":"docs"},{"authors":null,"categories":null,"content":"A. å¸¸ç³»æ•°çº¿æ€§é€’æ¨ é¢˜é¢æè¿° ç»™å®šé€’æ¨å¼ $a_n=x_0+\\sum_{i=1}^kx_ia_{n-i}$ï¼Œæ±‚ $a_p$ã€‚ $k\\leq 60,p\\leq 2\\times 10^9$ã€‚ é¢˜è§£ ä»¤å‘é‡ $$ x_{n}= \\left( \\begin{matrix} a_n\\\\a_{n+1}\\\\ \\vdots\\\\a_{n+k-1}\\\\x_0 \\end{matrix} \\right) $$ åˆ™ä»¤ $$ A=\\left[\\begin{matrix}1 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; 0\\\\0 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; 0\\\\ \\vdots \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots \u0026amp; \\vdots\\\\0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 1 \u0026amp; 0\\\\ x_k \u0026amp; x_{k-1} \u0026amp; \\dots \u0026amp; x_1 \u0026amp; 1\\\\0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; 1\\end{matrix}\\right] $$ æœ‰ $$ Ax_n=x_{n+1} $$ å› æ­¤åªè¦æ±‚ $A^{p-k+1}x_0$ï¼Œå³å¯æ±‚å¾— $a_p$ã€‚çŸ©é˜µä¹˜æ³•å¯ä»¥ç”¨å¿«é€Ÿå¹‚åŠ é€Ÿã€‚æ€»æ—¶é—´å¤æ‚åº¦ $O(k^3logp)$ã€‚\nB. éª¨ç‰Œè¦†ç›– é¢˜é¢æè¿° ç»™å®šä¸€ä¸ª $m$ è¡Œ $n$ åˆ—çš„æ£‹ç›˜ï¼Œè¦æ±‚ç”¨ $1\\times 2$ çš„éª¨ç‰Œé“ºæ»¡ï¼Œæ±‚æ–¹æ¡ˆæ•°ã€‚ $n\\leq 3,m\\leq 10^{18}$ã€‚ é¢˜è§£ å½“ $n=1$ æ—¶ï¼Œæ˜¾ç„¶å½“ $m$ ä¸ºå¶æ•°æ—¶æœ‰ 1 ç§æ–¹æ¡ˆï¼Œ$m$ ä¸ºå¥‡æ•°æ—¶æ²¡æœ‰æ–¹æ¡ˆã€‚\nå½“ $n=2$ æ—¶ï¼Œå®¹æ˜“å‘ç°ç­”æ¡ˆæ˜¯ Fibonacci æ•°åˆ—çš„ç¬¬ $m$ é¡¹ï¼Œä½¿ç”¨çŸ©é˜µå¿«é€Ÿå¹‚è®¡ç®—ç­”æ¡ˆå³å¯ã€‚\nå½“ $n=3$ æ—¶ï¼Œé¦–å…ˆè€ƒè™‘ä¸€ä¸ªçŠ¶å‹ dp çš„æ€è·¯ï¼šä»¤ $dp[i][Mask]$ è¡¨ç¤ºå½“å‰çœ‹åˆ°ç¬¬ $i$ è¡Œï¼Œç¬¬ $i$ è¡Œå·²ç»è¢«è¦†ç›–çš„çŠ¶æ€ä¸º $Mask$ çš„æ–¹æ¡ˆæ•°ã€‚ç”±äºéª¨ç‰Œçš„é•¿åº¦ä¸è¶…è¿‡ 2ï¼Œæ‰€ä»¥åœ¨ç¬¬ $i$ è¡Œæ”¾éª¨ç‰Œåªä¼šå½±å“ç¬¬ $i$ è¡Œå’Œç¬¬ $i+1$ è¡Œï¼Œä» $dp[i][Mask]$ å¯ä»¥è½»æ¾è½¬ç§»åˆ° $dp[i+1][Mask\u0026rsquo;]$ã€‚\nä½†æ­¤é¢˜ $m$ è¿‡å¤§ï¼Œéœ€è¦ä¼˜åŒ–è¯¥ dp æ€è·¯ã€‚æˆ‘ä»¬å¯ä»¥æŠŠ $dp[i][Mask]\\rightarrow dp[i+1][Mask\u0026rsquo;]$ çš„è½¬ç§»æ–¹å¼å†™æˆä¸€ä¸ª $8\\times 8$ çš„çŸ©é˜µï¼Œå°† $dp[i]$ å†™æˆä¸€ä¸ª $8$ ç»´å‘é‡ï¼Œä½¿å¾—ä¹˜ä¸Šè¯¥çŸ©é˜µå³å¯ä» $i$ è½¬ç§»åˆ° $i+1$ ï¼Œè¿™æ ·å°±å¯ä»¥ç”¨çŸ©é˜µå¿«é€Ÿå¹‚ä¼˜åŒ–äº†ã€‚\næ€»æ—¶é—´å¤æ‚åº¦ $O(2^nlogm)$ã€‚\nC. ç®€å•çš„é¢˜ é¢˜é¢æè¿° ç»™å®šæœ‰ $t$ æ¡è¾¹çš„æ— å‘å›¾ï¼Œæ±‚ä» $s$ åˆ° $t$ æ°å¥½ç»è¿‡äº† $n$ æ¡è¾¹çš„æœ€çŸ­è·¯ã€‚ $n\\leq 10^6,t\\leq 100$ã€‚ é¢˜è§£ ç”±äºè¾¹æ•°ä¸å¤šï¼Œæ‰€ä»¥å›¾ä¸­çš„ç‚¹æ•°è‡³å¤šæ˜¯ç™¾çº§ã€‚è®¾è¯¥å›¾çš„é‚»æ¥çŸ©é˜µä¸º $A$ï¼Œè€ƒè™‘ $A^n$ï¼Œå…¶ä¸­é‡æ–°å®šä¹‰çŸ©é˜µä¹˜æ³•çš„è¿ç®—ï¼Œç”¨ $+$ ä»£æ›¿ $\\times$ï¼Œç”¨ $\\min$ ä»£æ›¿ $+$ï¼Œå¯ä»¥è¯æ˜è¿™ç§æ–°å¼çŸ©é˜µä¹˜æ³•ä»ç„¶æ»¡è¶³ç»“åˆå¾‹ï¼Œæ‰€ä»¥ä»ç„¶å¯ä»¥çŸ©é˜µå¿«é€Ÿå¹‚ã€‚$A^n$ ä¸­ä¿å­˜çš„å³ä¸ºæ°å¥½ç»è¿‡ $n$ æ¡è¾¹çš„æœ€çŸ­è·¯ã€‚\næ€»æ—¶é—´å¤æ‚åº¦ $O(t^3logn)$ã€‚\nD. çº¿æ®µè¦†ç›– é¢˜é¢æè¿° ç»™å®š $n$ æ¡çº¿æ®µï¼Œç¬¬ $i$ æ¡çº¿æ®µä¸º $[l_i,r_i]$ã€‚æ¯æ¡çº¿æ®µæœ‰ä¸€ä¸ªä»£ä»· $c_i$ï¼Œè¡¨ç¤ºå¯ä»¥èŠ±è´¹ $c_i$ çš„ä»£ä»·ä½¿çº¿æ®µå‘å·¦æˆ–å‘å³å»¶é•¿ä¸€ä¸ªå•ä½é•¿åº¦ã€‚é—®è¦ä½¿å¾—è¿™äº›çº¿æ®µè¦†ç›–å…¨éƒ¨ $[0,m]$ è‡³å°‘éœ€è¦å¤šå°‘ä»£ä»·ã€‚ $n\\leq 1000,m\\leq 10^6$ã€‚ é¢˜è§£ è€ƒè™‘ $[0,m]$ ä¸Šæœ‰å¤šå°‘æ®µè¿˜æ²¡æœ‰è¢«çº¿æ®µè¦†ç›–ï¼Œæ˜¾ç„¶â€œç©ºç™½æ®µâ€çš„æ•°é‡æ˜¯ $O(n)$ çº§åˆ«çš„ã€‚æˆ‘ä»¬å‘ç°æœ‰å¦‚ä¸‹é‡è¦æ€§è´¨ï¼šåœ¨æœ€ä¼˜çš„è¦†ç›–æ–¹æ¡ˆä¸­ï¼Œä¸€ä¸ªç©ºç™½æ®µä¸ä¼šè¢«å¤šä¸ªçº¿æ®µè¦†ç›–ã€‚\nå¦‚æœä¸¤ä¸ªçº¿æ®µäº¤æ±‡åœ¨ä¸€ä¸ªç©ºç™½æ®µçš„ä¸­é—´ï¼Œé‚£æˆ‘ä»¬æ€»å¯ä»¥ç¼©çŸ­ä»£ä»·é•¿çš„é‚£ä¸ªçº¿æ®µï¼Œå¢é•¿ä»£ä»·å°çš„çº¿æ®µï¼Œä½¿å¾—ä»£ä»·å˜å°ã€‚ å¦‚æœä¸¤ä¸ªçº¿æ®µåŒæ—¶è¦†ç›–äº†ä¸€æ•´ä¸ªç©ºç™½æ®µï¼Œå¯ä»¥å‘ç°ä»£ä»·å°çš„çº¿æ®µä¸€å®šèƒ½ä»¥ç›¸åŒæˆ–æ›´å°çš„ä»£ä»·å®Œæˆä¸¤ä¸ªçº¿æ®µè¦è¦†ç›–çš„çº¿æ®µï¼Œå› æ­¤ä¸éœ€è¦å¤§ä»£ä»·çº¿æ®µä»˜å‡ºã€‚ åŸºäºä»¥ä¸Šé‡è¦æ€§è´¨ï¼Œæˆ‘ä»¬å¯ä»¥è¿›è¡ŒåŠ¨æ€è§„åˆ’ã€‚ä»¤ $dp[i][j]$ è¡¨ç¤ºå½“å‰è€ƒè™‘åˆ°ç¬¬ $i$ ä¸ªç©ºç™½æ®µï¼Œç¬¬ $i$ ä¸ªç©ºç™½æ®µæ˜¯è¢«ç¬¬ $j$ ä¸ªçº¿æ®µè¦†ç›–çš„æƒ…å†µä¸‹çš„æœ€å°ä»£ä»·ã€‚è½¬ç§»åˆ†ä¸ºä¸¤ç§æƒ…å†µï¼š\nç¬¬ $i-1$ æ®µç©ºç™½æ®µä¹Ÿæ˜¯è¢«ç¬¬ $j$ ä¸ªçº¿æ®µè¦†ç›–çš„ï¼Œæ­¤æ—¶åªéœ€è¦æ ¹æ®ç¬¬ $i-1$ ä¸ªç©ºç™½æ®µï¼Œç¬¬ $i$ ä¸ªç©ºç™½æ®µå’Œç¬¬ $j$ ä¸ªçº¿æ®µçš„ä½ç½®å…³ç³»è®¡ç®—ç¬¬ $j$ ä¸ªçº¿æ®µè¦å®Œæ•´è¦†ç›–ä½ç¬¬ $i$ ä¸ªç©ºç™½æ®µæ‰€éœ€çš„é¢å¤–ä»£ä»·å³å¯ã€‚ ç¬¬ $i-1$ æ®µç©ºç™½æ®µä¸æ˜¯è¢«ç¬¬ $j$ ä¸ªçº¿æ®µè¦†ç›–çš„ã€‚æ ¹æ®ä¹‹å‰åˆ†æçš„æ€§è´¨ï¼Œæˆ‘ä»¬åªéœ€è¦è€ƒè™‘ç¬¬ $i-1$ æ®µç©ºç™½æ®µè¢« $min(j,i)$ ä¹‹å‰çš„çº¿æ®µè¦†ç›–ï¼Œå› æ­¤åªéœ€è¦ç»´æŠ¤ä¸€ä¸ª dp æ•°ç»„çš„å‰ç¼€ min å³å¯ã€‚äº‹å®ä¸Šåœ¨å†™ä»£ç æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥ç”¨ $i-1$ çš„å…¨å±€æœ€å°å€¼æ¥æ›´æ–°ç­”æ¡ˆï¼Œå› ä¸ºè¿™æ ·åªä¼šè¯¯è®¡ç®—ä¸€äº›éæœ€ä¼˜è§£çš„å€¼ï¼Œä»ç„¶å¯ä»¥ä¿è¯æˆ‘ä»¬ç®—å‡ºæœ€ä¼˜è§£çš„ä»£ä»·ã€‚ï¼ˆå½“ç„¶ç»´æŠ¤å‰ç¼€ minä¹Ÿæ˜¯å¯ä»¥çš„ï¼‰ã€‚ æ€»æ—¶é—´å¤æ‚åº¦ $O(n^2)$ã€‚\næ­¤å¤–åœ¨å‘ç°æ€§è´¨ä¹‹åä¹Ÿå¯ä»¥å»ºå›¾è·‘æœ€çŸ­è·¯ï¼šä¸ºæ¯æ¡çº¿æ®µå»ºä¸€ä¸ªç‚¹ï¼Œä¸ºèµ·ç‚¹ 0 å’Œ ç»ˆç‚¹ $m$ ä¹Ÿå„å»ºç«‹ä¸€ä¸ªç‚¹ã€‚ä¹‹å‰çš„æ€§è´¨å¯ä»¥è¢«ç¿»è¯‘ä¸ºï¼šä¸¤æ¡çº¿æ®µåœ¨å»¶ä¼¸ä¹‹åçš„ç›¸äº¤å¤„å¿…ç„¶åœ¨æŸæ¡çº¿æ®µçš„ç«¯ç‚¹å¤„ã€‚å¯¹äºä¸¤æ¡çº¿æ®µä»£è¡¨çš„ç‚¹ï¼Œæˆ‘ä»¬åªéœ€è¦å»ºä»ä¸€æ¡çº¿æ®µåˆ°å¦ä¸€æ¡çº¿æ®µï¼ˆå·¦ç«¯ç‚¹å’Œå³ç«¯ç‚¹ä¸­è¾ƒè¿‘çš„ä¸€ä¸ªï¼Œå–å†³äºçº¿æ®µä¹‹é—´çš„ç›¸å¯¹ä½ç½®ï¼‰å»¶ä¼¸æ‰€éœ€çš„ä»£ä»·å³å¯ã€‚è¯¥å›¾æ˜¯ä¸€ä¸ªé˜¶æ•°ä¸º $n$ çš„ç¨ å¯†å›¾ï¼Œåœ¨ä¸Šé¢è·‘ä¸å¸¦å †ä¼˜åŒ–çš„ Dijkstra ç®—æ³•ï¼Œä¹Ÿå¯åœ¨ $O(n^2)$ å†…å¾—åˆ°ç»“æœã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"697ba896a561de32a972d6c53a25a3c6","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-problem-solving/oj-solutions/iii-05/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/nju-problem-solving/oj-solutions/iii-05/","section":"notes","summary":"A. å¸¸ç³»æ•°çº¿æ€§é€’æ¨ é¢˜é¢æè¿° ç»™å®šé€’æ¨å¼ $a_n=x_0+\\sum_{i=1}^kx_ia_{n-i}$ï¼Œæ±‚ $a_p$ã€‚ $k\\leq 60,p\\leq 2\\times 10^9$ã€‚ é¢˜è§£ ä»¤å‘é‡ $$ x_{n}= \\left( \\begin{matrix} a_n\\\\a_{n+1}\\\\ \\vdots\\\\a_{n+k-1}\\\\x_0 \\end{matrix} \\right) $$ åˆ™ä»¤ $$ A=\\left[\\begin{matrix}1 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; 0\\\\0 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; 0\\\\ \\vdots \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots \u0026amp; \\vdots\\\\0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 1 \u0026amp; 0\\\\ x_k \u0026amp; x_{k-1} \u0026amp; \\dots \u0026amp; x_1 \u0026amp; 1\\\\0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; 1\\end{matrix}\\right] $$ æœ‰ $$ Ax_n=x_{n+1} $$ å› æ­¤åªè¦æ±‚ $A^{p-k+1}x_0$ï¼Œå³å¯æ±‚å¾— $a_p$ã€‚çŸ©é˜µä¹˜æ³•å¯ä»¥ç”¨å¿«é€Ÿå¹‚åŠ é€Ÿã€‚æ€»æ—¶é—´å¤æ‚åº¦ $O(k^3logp)$ã€‚","tags":null,"title":"é—®é¢˜æ±‚è§£ III - 05 é¢˜è§£","type":"docs"},{"authors":null,"categories":null,"content":"A. æœ€å¤§å†…åˆ‡çƒ é¢˜é¢æè¿° ç»™å®š $n$ ä¸ªåŠå¹³é¢ï¼Œæ±‚åŠå¹³é¢å›´å‡ºçš„ä¸‰ç»´å‡¸åŒ…çš„æœ€å¤§å†…åˆ‡çƒçš„åŠå¾„ã€‚ $\\sum n\\leq 2500$ã€‚ é¢˜è§£ è®¾çƒçš„åŠå¾„ä¸º $r$ï¼Œåˆ™æˆ‘ä»¬çš„çº¦æŸæ˜¯çƒå¿ƒåˆ°æ¯ä¸ªå¹³é¢çš„è·ç¦»ä¸å°äº $r$ã€‚æ­¤å¤„æ ¹æ®ç©ºé—´è§£æå‡ ä½•çš„çŸ¥è¯†ï¼Œå¦‚æœä¸€ä¸ªåŠå¹³é¢å½¢å¦‚ $ax+by+cz+d\\leq 0$ï¼Œé‚£ä¹ˆå°†å…¶å•ä½åŒ–ä¹‹åï¼ˆå³ä»¤ $cos\\alpha=\\frac{a}{\\sqrt{a^2+b^2+c^2}},cos\\beta=\\frac{b}{\\sqrt{a^2+b^2+c^2}},$$cos\\gamma=\\frac{c}{\\sqrt{a^2+b^2+c^2}}$ï¼Œå°†æ–¹ç¨‹æ”¹å†™ä¸º $cos\\alpha\\cdot x+cos\\beta\\cdot y+cos\\gamma\\cdot z+\\rho=0$çš„å½¢å¼ï¼‰ï¼Œç›´æ¥å°†ç‚¹çš„åæ ‡ä»£å…¥å³å¯å¾—åˆ°ç‚¹åˆ°å¹³é¢çš„è·ç¦»ï¼Œå› æ­¤æ¯ä¸ªçº¦æŸéƒ½æ˜¯ä¸€ä¸ªçº¿æ€§ä¸ç­‰å¼ï¼Œå…±æœ‰ 4 ä¸ªå˜é‡ï¼Œæˆ‘ä»¬è¦æœ€å¤§åŒ–çš„å¼å­å°±æ˜¯ $r$ï¼Œç”¨å•çº¯å½¢æ±‚è§£å³å¯ã€‚\nB. æ–‡ç†åˆ†ç§‘ é¢˜é¢æè¿° ç»™å®šæ’æˆçŸ©é˜µçš„ $n\\times m$ ä¸ªå­¦ç”Ÿï¼Œæ¯ä¸ªå­¦ç”Ÿå­¦æ–‡æœ‰ $a_{ij}$ çš„æ”¶ç›Šï¼Œå­¦ç†æœ‰ $b_{ij}$ çš„æ”¶ç›Šã€‚å¦‚æœä¸€ä¸ªå­¦ç”Ÿå’Œä»–ç›¸é‚»çš„æ‰€æœ‰å­¦ç”Ÿéƒ½å­¦æ–‡/ç†ï¼Œå¯ä»¥é¢å¤–è·å¾— $sa_{ij}/sb_{ij}$ çš„æ”¶ç›Šã€‚æ±‚æœ€å¤§æ”¶ç›Šã€‚ $n,m\\leq 100$ã€‚ é¢˜è§£ è€ƒè™‘æœ€å°å‰²ï¼Œæˆ‘ä»¬å…ˆå‡è®¾æ‰€æœ‰äººæ‹¿æ»¡äº†å­¦æ–‡å­¦ç†çš„æ”¶ç›Šå’ŒåŒºåŸŸç›¸åŒçš„æ”¶ç›Šï¼Œè€ƒè™‘æœ€å°‘éœ€è¦æ‰£é™¤å¤šå°‘æ”¶ç›Šã€‚\nå»ºç«‹è¶…çº§æºç‚¹ $S$ å’Œè¶…çº§æ±‡ç‚¹ $T$ã€‚\nå¯¹äºæ¯ä¸ªå­¦ç”Ÿï¼Œä» $S$ å‘ä»–è¿å®¹é‡ä¸º $a_{ij}$ çš„è¾¹ï¼Œè¡¨ç¤ºå¦‚æœå‰²å»ï¼Œä»–å»å­¦ç†ï¼Œåˆ™ä¼šæŸå¤±è¯¥éƒ¨åˆ†æ”¶ç›Šã€‚ç›¸ä¼¼åœ°ï¼Œä»ä»–å‘ $T$ è¿å®¹é‡ä¸º $b_{ij}$ çš„è¾¹ã€‚\nå¯¹äºæ¯ä¸ªå­¦ç”Ÿå’Œå…¶ç›¸é‚»äººåŒæ—¶å­¦æ–‡çš„æƒ…å†µï¼Œæˆ‘ä»¬éœ€è¦æ‰£é™¤è¯¥éƒ¨åˆ†æ”¶ç›Šå½“ä¸”ä»…å½“è¿™äº›äººä¸­è‡³å°‘æœ‰ä¸€ä¸ªå­¦ç†ã€‚å› æ­¤æˆ‘ä»¬ä» $S$ å‘è¯¥å­¦ç”Ÿçš„ä¸€ä¸ªâ€œå‰¯æœ¬ç‚¹â€è¿å®¹é‡ä¸º $sa_{ij}$ çš„è¾¹ï¼Œå†ä»è¯¥å‰¯æœ¬ç‚¹å‘è¯¥å­¦ç”ŸåŠå…¶ç›¸é‚»äººè¿å®¹é‡ä¸º $\\infty$ çš„è¾¹ã€‚è¿™æ ·è¿™äº›äººä¸­ä¸€æ—¦æœ‰ä¸€ä¸ªäººå­¦ç†ï¼Œå°±ä¸å¾—ä¸å‰²å»å®¹é‡ä¸º $sa_{ij}$ çš„è¾¹ã€‚$sb$ çš„å¤„ç†æ–¹æ³•ç±»ä¼¼ã€‚\nC. Did You Just Say \u0026hellip;\u0026hellip; Acesrc? é¢˜é¢æè¿° ç»™å®šä¸€ä¸ª $2\\times n$ çš„â€œæ¢¯å­â€å›¾ï¼Œæ±‚è¯¥å›¾æœ‰å¤šå°‘ä¸ªè¿é€šçš„å­å›¾ã€‚ $n\\leq 10^{18}$ã€‚ é¢˜è§£ è€ƒè™‘åŠ¨æ€è§„åˆ’ã€‚å¦‚æœä»å·¦å‘å³è€ƒè™‘ï¼Œæˆ‘ä»¬å‘ç°ä¸€ä¸ªæ€§è´¨ï¼šåˆ°ç¬¬ $i$ åˆ—æ—¶ï¼Œä¹‹å‰çš„ç‚¹è¦ä¹ˆæ˜¯è¿é€šçš„ï¼Œè¦ä¹ˆåˆ†å±ä¸¤ä¸ªè¿é€šå—ï¼Œä¸”ç¬¬ $i$ åˆ—çš„ä¸¤ä¸ªç‚¹ä¸è¿é€šã€‚ä»¤ $f(i)$ è¡¨ç¤ºå½“å‰è€ƒè™‘åˆ°ç¬¬ $i$ åˆ—ï¼Œåªæœ‰ä¸€ä¸ªè¿é€šå—çš„æ–¹æ¡ˆæ•°ï¼Œ$g(i)$ è¡¨ç¤ºå½“å‰è€ƒè™‘åˆ°ç¬¬ $i$ åˆ—ï¼Œæœ‰ä¸¤ä¸ªè¿é€šå—çš„æ–¹æ¡ˆæ•°ã€‚ç¨å¾®è€ƒè™‘ä»¥ä¸‹ç¬¬ $i$ ä¸ªâ€œæ¢¯å­æ ¼å­â€ä¸­çš„ä¸‰æ¡è¾¹ï¼Œè½¬ç§»æ˜¯å®¹æ˜“çš„ï¼š $$ \\begin{align} f(i)=4f(i-1)+g(i-1)\\\\ g(i)=2f(i-1)+g(i-1) \\end{align} $$æ³¨æ„åˆ°è¯¥åŠ¨æ€è§„åˆ’æ˜¯çº¿æ€§é€’æ¨ï¼Œå› æ­¤å¯ä»¥å°† $f$ å’Œ $g$ å†™æˆä¸€ä¸ªåˆ—å‘é‡ï¼Œç”¨çŸ©é˜µè¡¨ç¤ºè½¬ç§»ï¼Œä»è€Œç”¨çŸ©é˜µå¿«é€Ÿå¹‚ä¼˜åŒ–è½¬ç§»ã€‚æ€»æ—¶é—´å¤æ‚åº¦ $O(logn)$ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"782ad36ec18577cf361989707c22d812","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-problem-solving/oj-solutions/iii-06/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/nju-problem-solving/oj-solutions/iii-06/","section":"notes","summary":"A. æœ€å¤§å†…åˆ‡çƒ é¢˜é¢æè¿° ç»™å®š $n$ ä¸ªåŠå¹³é¢ï¼Œæ±‚åŠå¹³é¢å›´å‡ºçš„ä¸‰ç»´å‡¸åŒ…çš„æœ€å¤§å†…åˆ‡çƒçš„åŠå¾„ã€‚ $\\sum n\\leq 2500$ã€‚ é¢˜è§£ è®¾çƒçš„åŠå¾„ä¸º $r$ï¼Œåˆ™æˆ‘ä»¬çš„çº¦æŸæ˜¯çƒå¿ƒåˆ°æ¯ä¸ªå¹³é¢çš„è·ç¦»ä¸å°äº $r$ã€‚æ­¤å¤„æ ¹æ®ç©ºé—´è§£æå‡ ä½•çš„çŸ¥è¯†ï¼Œå¦‚æœä¸€ä¸ªåŠå¹³é¢å½¢å¦‚ $ax+by+cz+d\\leq 0$ï¼Œé‚£ä¹ˆå°†å…¶å•ä½åŒ–ä¹‹åï¼ˆå³ä»¤ $cos\\alpha=\\frac{a}{\\sqrt{a^2+b^2+c^2}},cos\\beta=\\frac{b}{\\sqrt{a^2+b^2+c^2}},$$cos\\gamma=\\frac{c}{\\sqrt{a^2+b^2+c^2}}$ï¼Œå°†æ–¹ç¨‹æ”¹å†™ä¸º $cos\\alpha\\cdot x+cos\\beta\\cdot y+cos\\gamma\\cdot z+\\rho=0$çš„å½¢å¼ï¼‰ï¼Œç›´æ¥å°†ç‚¹çš„åæ ‡ä»£å…¥å³å¯å¾—åˆ°ç‚¹åˆ°å¹³é¢çš„è·ç¦»ï¼Œå› æ­¤æ¯ä¸ªçº¦æŸéƒ½æ˜¯ä¸€ä¸ªçº¿æ€§ä¸ç­‰å¼ï¼Œå…±æœ‰ 4 ä¸ªå˜é‡ï¼Œæˆ‘ä»¬è¦æœ€å¤§åŒ–çš„å¼å­å°±æ˜¯ $r$ï¼Œç”¨å•çº¯å½¢æ±‚è§£å³å¯ã€‚\nB. æ–‡ç†åˆ†ç§‘ é¢˜é¢æè¿° ç»™å®šæ’æˆçŸ©é˜µçš„ $n\\times m$ ä¸ªå­¦ç”Ÿï¼Œæ¯ä¸ªå­¦ç”Ÿå­¦æ–‡æœ‰ $a_{ij}$ çš„æ”¶ç›Šï¼Œå­¦ç†æœ‰ $b_{ij}$ çš„æ”¶ç›Šã€‚å¦‚æœä¸€ä¸ªå­¦ç”Ÿå’Œä»–ç›¸é‚»çš„æ‰€æœ‰å­¦ç”Ÿéƒ½å­¦æ–‡/ç†ï¼Œå¯ä»¥é¢å¤–è·å¾— $sa_{ij}/sb_{ij}$ çš„æ”¶ç›Šã€‚æ±‚æœ€å¤§æ”¶ç›Šã€‚ $n,m\\leq 100$ã€‚ é¢˜è§£ è€ƒè™‘æœ€å°å‰²ï¼Œæˆ‘ä»¬å…ˆå‡è®¾æ‰€æœ‰äººæ‹¿æ»¡äº†å­¦æ–‡å­¦ç†çš„æ”¶ç›Šå’ŒåŒºåŸŸç›¸åŒçš„æ”¶ç›Šï¼Œè€ƒè™‘æœ€å°‘éœ€è¦æ‰£é™¤å¤šå°‘æ”¶ç›Šã€‚","tags":null,"title":"é—®é¢˜æ±‚è§£ III - 06 é¢˜è§£","type":"docs"},{"authors":null,"categories":null,"content":"A. å¤šé¡¹å¼ä¹˜æ³•æ¨¡æ¿ é¢˜é¢æè¿° ç»™å®šä¸€ä¸ª $n$ æ¬¡å¤šé¡¹å¼ $A$ å’Œä¸€ä¸ª $m$ æ¬¡å¤šé¡¹å¼ $B$ï¼Œæ±‚ä¹˜ç§¯ã€‚ $1\\leq n,m\\leq 10^5$ã€‚ é¢˜è§£ å¯ä»¥ä½¿ç”¨ FFTï¼Œä»‹äºå¤šé¡¹å¼çš„ç³»æ•°ä¸ä¼šå¤ªå¤§ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ NTTã€‚\nB. ä¸€ä¸ªå«yjherçš„åŒå­¦å†³å®šå»åšA*B Problem é¢˜é¢æè¿° ç»™å®šä¸¤ä¸ªå¤§æ•´æ•° $a,b$ï¼Œæ±‚ä¹˜ç§¯ã€‚ $1\\leq a,b\\leq 10^{200000}$ã€‚ é¢˜è§£ è®¾ $a=\\overline{a_na_{n-1}\\cdots a_1a_0}$ï¼Œè€ƒè™‘ç”Ÿæˆå‡½æ•° $A(x)=a_0+a_1x+\\cdots+a_nx^n$â€‹ï¼Œåˆ™ $a=A(10)$ï¼Œ$b$ ä¹Ÿæ˜¯åŒç†ã€‚å› æ­¤åªè¦æ±‚ä¸¤ä¸ªç”Ÿæˆå‡½æ•°çš„ä¹˜ç§¯å†å°† 10 ä»£å…¥å³å¯ã€‚\nC. æ–¹ç¨‹æ±‚è§£ é¢˜é¢æè¿° $T$ ç»„æ•°æ®ï¼Œæ¯æ¬¡ç»™å®šæ­£æ•´æ•° $n$ï¼Œæ±‚å››å…ƒä¸å®šæ–¹ç¨‹ $ab+cd=n$ çš„è§£çš„ä¸ªæ•°ã€‚ $T\\leq 10000,n\\leq 5\\times 10^5$ã€‚ é¢˜è§£ è®¾ $ab=n$ çš„è§£çš„ä¸ªæ•°ä¸º $f(n)$ï¼Œæ˜¾ç„¶æœ‰ $f(n)=\\sigma(n)$ï¼Œå…¶ä¸­ $\\sigma(n)$ è¡¨ç¤º $n$ çš„çº¦æ•°ä¸ªæ•°ã€‚é‚£ä¹ˆåŸä¸å®šæ–¹ç¨‹è§£çš„ä¸ªæ•°ä¸º $$ F(n)=\\sum_{i=1}^{n-1}f(i)f(n-i) $$ è¯¥è¡¨è¾¾å¼æ˜¯å·ç§¯å½¢å¼ï¼Œå¯ä»¥ç”¨ FFT ä¼˜åŒ–ã€‚\nè‡³äºå¦‚ä½•æ±‚ $\\sigma(n)$ ï¼Œå¯ä»¥åœ¨çº¿æ€§ç­›ç´ æ•°çš„åŒæ—¶ä¿å­˜æ¯ä¸ªæ•°çš„æœ€å°è´¨å› å­ï¼Œè¿™æ ·ä¾¿å¯åœ¨ $O(nlogn)$ çš„æ—¶é—´å†…å®Œæˆ 1-n æ‰€æœ‰æ•°çš„æ ‡å‡†åˆ†è§£ï¼Œä»è€Œç¡®å®šæ¯ä¸ªæ•°çš„çº¦æ•°ä¸ªæ•°ã€‚\næ€»æ—¶é—´å¤æ‚åº¦ $O(nlogn+T)$ã€‚\nD. è®¨åŒè´¨æ•°çš„äºº é¢˜é¢æè¿° ç»™å®š $n$ ä¸ªæ•°çš„é›†åˆï¼Œæ±‚å…¶æœ€å¤§çš„ä¸€ä¸ªå­é›†ï¼Œä½¿å¾—å­é›†ä¸­çš„æ•°ä¸¤ä¸¤ä¹‹å’Œéƒ½ä¸æ˜¯è´¨æ•°ã€‚ $n\\leq 3000,1\\leq a_i\\leq 10^5$ã€‚ é¢˜è§£ å¯¹äºä»»æ„ä¸¤ä¸ªæ•°ï¼Œå¦‚æœå®ƒä»¬çš„å’Œæ˜¯è´¨æ•°ï¼Œå°±åœ¨å®ƒä»¬ä¹‹é—´è¿ä¸€æ¡è¾¹ã€‚é‚£ä¹ˆè¯¥é—®é¢˜å°±è½¬åŒ–ä¸ºäº†æ±‚å›¾çš„æœ€å¤§ç‹¬ç«‹é›†ã€‚\nå¦‚æœä¸è€ƒè™‘ 1 çš„å‚ä¸ï¼Œé‚£ä¹ˆæœ‰è¾¹çš„ä¸¤ä¸ªæ•°ä¸€å®šæ˜¯ä¸€ä¸ªå¥‡æ•°ä¸€ä¸ªå¶æ•°ï¼Œæ‰€ä»¥è¿™ä¸ªå›¾æ˜¯ä¸€ä¸ªäºŒåˆ†å›¾ã€‚æ­¤æ—¶å†è€ƒè™‘ 1ï¼Œæ˜¾ç„¶æœ€ç»ˆçš„é›†åˆé‡Œä¸ä¼šæœ‰ä¸¤ä¸ª1ï¼Œå› æ­¤å¦‚æœæœ‰å¤šä¸ª 1ï¼Œåªä¿ç•™ä¸€ä¸ªå‚ä¸æœ€å¤§ç‹¬ç«‹é›†çš„è®¡ç®—å³å¯ã€‚\näºŒåˆ†å›¾çš„æœ€å¤§ç‹¬ç«‹é›†ç­‰äºæ€»ç‚¹æ•°å‡å»æœ€å¤§åŒ¹é…ï¼Œç”¨ç½‘ç»œæµæ±‚è§£å³å¯ã€‚ä¸€ä¸ªä¸å¤ªç´§çš„æ—¶é—´å¤æ‚åº¦çš„ä¸Šç•Œæ˜¯ $O(n^{2.5})$ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"0584b9e163432def731fa2011adde170","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-problem-solving/oj-solutions/iii-07/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/nju-problem-solving/oj-solutions/iii-07/","section":"notes","summary":"A. å¤šé¡¹å¼ä¹˜æ³•æ¨¡æ¿ é¢˜é¢æè¿° ç»™å®šä¸€ä¸ª $n$ æ¬¡å¤šé¡¹å¼ $A$ å’Œä¸€ä¸ª $m$ æ¬¡å¤šé¡¹å¼ $B$ï¼Œæ±‚ä¹˜ç§¯ã€‚ $1\\leq n,m\\leq 10^5$ã€‚ é¢˜è§£ å¯ä»¥ä½¿ç”¨ FFTï¼Œä»‹äºå¤šé¡¹å¼çš„ç³»æ•°ä¸ä¼šå¤ªå¤§ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ NTTã€‚\nB. ä¸€ä¸ªå«yjherçš„åŒå­¦å†³å®šå»åšA*B Problem é¢˜é¢æè¿° ç»™å®šä¸¤ä¸ªå¤§æ•´æ•° $a,b$ï¼Œæ±‚ä¹˜ç§¯ã€‚ $1\\leq a,b\\leq 10^{200000}$ã€‚ é¢˜è§£ è®¾ $a=\\overline{a_na_{n-1}\\cdots a_1a_0}$ï¼Œè€ƒè™‘ç”Ÿæˆå‡½æ•° $A(x)=a_0+a_1x+\\cdots+a_nx^n$â€‹ï¼Œåˆ™ $a=A(10)$ï¼Œ$b$ ä¹Ÿæ˜¯åŒç†ã€‚å› æ­¤åªè¦æ±‚ä¸¤ä¸ªç”Ÿæˆå‡½æ•°çš„ä¹˜ç§¯å†å°† 10 ä»£å…¥å³å¯ã€‚","tags":null,"title":"é—®é¢˜æ±‚è§£ III - 07 é¢˜è§£","type":"docs"},{"authors":null,"categories":null,"content":"A. åŠ å¯† é¢˜é¢æè¿° ä½¿ç”¨é¢˜ç›®ä¸­ç»™å®šçš„ä¸€å¥—ç±» RSA ç®—æ³•åŠ å¯†ï¼Œå…¬é’¥ $E=2^{30}+3$ã€‚å·²çŸ¥å¯†æ–‡ $w^E\\equiv C(mod\\space n)$ï¼Œç»™å®š $n,C$ï¼Œæ±‚åŸæ–‡ $w$ã€‚ $T\\leq 10^5,n\\leq 10^{18}$ã€‚ é¢˜è§£ æ ¹æ®é¢˜ç›®ä¸­ $n$ çš„ç”Ÿæˆæ–¹å¼å¯çŸ¥ï¼Œ$n=pq$ ä¸” $p,q$ çš„å·®éå¸¸å°ï¼Œå› æ­¤å¯ä»¥ä» $\\sqrt n$ å¼€å§‹å¾€ä¸Šå¾€ä¸‹æšä¸¾ç¬¬ä¸€ä¸ª $n$ çš„å› å­ï¼Œå³å¯å¾—åˆ° $p$ å’Œ $q$ã€‚é‚£ä¹ˆ $\\phi(n)=(p-1)(q-1)$ï¼Œä»è€Œå¯ä»¥ç”¨æ‰©å±•æ¬§å‡ é‡Œå¾—æ±‚å‡º $E$ å…³äº $\\phi(n)$ çš„é€†å…ƒ $D$ï¼ˆå¯†é’¥ï¼‰ã€‚\næ ¹æ®æ•°è®ºçŸ¥è¯†ï¼Œæˆ‘ä»¬æœ‰ $C^{DE}\\equiv w^{DE}\\equiv w(mod\\space n)$ã€‚å› æ­¤ä½¿ç”¨å¿«é€Ÿå¹‚æ±‚è§£ $C^{DE}$ å³å¯ã€‚\næ³¨ï¼šå¦‚æœä½¿ç”¨åµŒå¥—å¿«é€Ÿä¹˜çš„å¿«é€Ÿå¹‚ï¼Œæ—¶é—´å¤æ‚åº¦å°†è¾¾åˆ° $O(T\\log^2n)$ï¼Œå¯èƒ½ä¼šè¶…æ—¶ã€‚ä½¿ç”¨ __int128 ç±»å‹å¯ä»¥é¿å…è¿™ä¸ªé—®é¢˜ã€‚\nB. å¯ä»¥çœ‹è§çš„ç‚¹ é¢˜é¢æè¿° ç»™å®š $n\\times n$ çš„æ–¹æ ¼çº¸ï¼Œé—®ä» $(0,0)$ å‡ºå‘å¯ä»¥ç”»å‡ºå¤šå°‘ç§ä¸åŒæ–œç‡çš„ç›´çº¿ï¼ˆç›´çº¿å¿…é¡»ç»è¿‡è‡³å°‘ä¸¤ä¸ªæ ¼ç‚¹ï¼‰ã€‚ $n\\leq 10^5$ã€‚ é¢˜è§£ è®¾ç›´çº¿ç»è¿‡çš„å¦ä¸€ä¸ªæ ¼ç‚¹æ˜¯ $(a,b)$ ï¼Œé‚£ä¹ˆæ˜¾ç„¶åªæœ‰ $a,b$ äº’è´¨æˆ‘ä»¬æ‰åº”è¯¥å°†å…¶è®¡å…¥ç­”æ¡ˆï¼Œå¦åˆ™ä¼šå¯¼è‡´é‡å¤è®¡æ•°ã€‚å› æ­¤ $$ \\begin{align} ans\u0026amp;=\\sum_{i=1}^n\\sum_{j=1}^n[\\gcd(i,j)=1]\\\\ \u0026amp;=1+2\\sum_{i=1}^n\\sum_{j=1}^{i-1}[\\gcd(i,j)=1]\\\\ \u0026amp;=1+2\\sum_{i=1}^n\\varphi(i) \\end{align} $$å› ä¸ºæ­¤é¢˜ $n$ åªæœ‰ 1e5ï¼Œæ‰€ä»¥ $O(\\log n)$ åœ°æ±‚æ¯ä¸ªæ•°çš„æ¬§æ‹‰å‡½æ•°å€¼å†æ±‚å’Œå³å¯ã€‚å½“ $n$ æ›´å¤§æ—¶å¯ä»¥å€ŸåŠ©çº¿æ€§ç­›æˆ–æ•°è®ºç­›æ³•æ¥è§£å†³ã€‚\nC. POWERMOD é¢˜é¢æè¿° ç»™å®š $a,b,m$ï¼Œæ±‚ $a^b(mod\\space m)$ã€‚ $a,b,m\\leq 10^{18}$ã€‚ é¢˜è§£ æ­¤é¢˜çš„éš¾ç‚¹åœ¨äºæ™®é€šçš„å¿«é€Ÿå¹‚åœ¨æ‰§è¡Œä¹˜æ³•æ—¶ä¼šçˆ† long longï¼Œæ‰€ä»¥æˆ‘ä»¬åº”å½“ç”¨â€œå¿«é€Ÿä¹˜â€æ¥ä»£æ›¿æ™®é€šçš„ä¹˜æ³•ã€‚å¿«é€Ÿä¹˜ç”¨ $O(\\log n)$ æ¬¡åŠ æ³•æ¥ä»£æ›¿ä¸€æ¬¡ä¹˜æ³•ï¼Œå…¶åŸç†å’Œå¿«é€Ÿå¹‚å®Œå…¨ä¸€æ ·ï¼Œå¤§è‡´çš„ä»£ç å¦‚ä¸‹ï¼š\n#define LL long long LL quick_mul(LL x, LL y, LL m) { LL res = 0; while (y) { if (y \u0026amp; 1) res = (res + x) % m; x = (x + x) % m; y \u0026gt;\u0026gt;= 1; } return res; } è¿™æ ·æˆ‘ä»¬å¯ä»¥åœ¨ $O(\\log ^2n)$ çš„æ—¶é—´å¤æ‚åº¦å†…å®Œæˆå¿«é€Ÿå¹‚ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"0c6b208e2177a3df68e374ee40d44af7","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-problem-solving/oj-solutions/iii-10/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/nju-problem-solving/oj-solutions/iii-10/","section":"notes","summary":"A. åŠ å¯† é¢˜é¢æè¿° ä½¿ç”¨é¢˜ç›®ä¸­ç»™å®šçš„ä¸€å¥—ç±» RSA ç®—æ³•åŠ å¯†ï¼Œå…¬é’¥ $E=2^{30}+3$ã€‚å·²çŸ¥å¯†æ–‡ $w^E\\equiv C(mod\\space n)$ï¼Œç»™å®š $n,C$ï¼Œæ±‚åŸæ–‡ $w$ã€‚ $T\\leq 10^5,n\\leq 10^{18}$ã€‚ é¢˜è§£ æ ¹æ®é¢˜ç›®ä¸­ $n$ çš„ç”Ÿæˆæ–¹å¼å¯çŸ¥ï¼Œ$n=pq$ ä¸” $p,q$ çš„å·®éå¸¸å°ï¼Œå› æ­¤å¯ä»¥ä» $\\sqrt n$ å¼€å§‹å¾€ä¸Šå¾€ä¸‹æšä¸¾ç¬¬ä¸€ä¸ª $n$ çš„å› å­ï¼Œå³å¯å¾—åˆ° $p$ å’Œ $q$ã€‚é‚£ä¹ˆ $\\phi(n)=(p-1)(q-1)$ï¼Œä»è€Œå¯ä»¥ç”¨æ‰©å±•æ¬§å‡ é‡Œå¾—æ±‚å‡º $E$ å…³äº $\\phi(n)$ çš„é€†å…ƒ $D$ï¼ˆå¯†é’¥ï¼‰ã€‚","tags":null,"title":"é—®é¢˜æ±‚è§£ III - 10 é¢˜è§£","type":"docs"},{"authors":null,"categories":null,"content":"A. Majority 3-SAT é¢˜é¢æè¿° ç°æœ‰ $k$ ä¸ªé€»è¾‘å˜é‡ $x_1,\\cdots, x_k$ï¼Œç»™å‡º $n$ ä¸ªä¸‰å…ƒç»„ $(a_i,b_i,c_i)$ï¼Œå…¶ä¸­æ¯ä¸ªé€»è¾‘å¼å¯ä»¥å–ä»»æ„ä¸€ä¸ªé€»è¾‘å˜é‡æˆ–å…¶å¦å®šï¼Œæ¯ä¸ªä¸‰å…ƒç»„è¡¨ç¤ºä¸‰ä¸ªé€»è¾‘å¼è‡³å°‘ä¸¤ä¸ªä¸ºçœŸï¼Œé—®æ˜¯å¦èƒ½æ‰¾åˆ°ä¸€ç§èµ‹å€¼æ³•ï¼Œæ»¡è¶³æ‰€æœ‰ $n$ ä¸ªä¸‰å…ƒç»„ã€‚\n$k, n\\leq 10^4$ã€‚\né¢˜è§£ å¯¹äºä¸€ä¸ªä¸‰å…ƒç»„ $(a_i,b_i,c_i)$ï¼Œç”±äºè‡³å°‘è¦æœ‰ä¸¤ä¸ªè¡¨è¾¾å¼ä¸º trueï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å°†å…¶ç¿»è¯‘æˆå¦‚ä¸‹çš„ä¸€äº›è•´å«å¼ï¼šå¦‚æœ $a_i$ ä¸ºå‡ï¼Œåˆ™ $b_i$ ä¸ºçœŸï¼›å¦‚æœ $a_i$ ä¸ºå‡ï¼Œåˆ™ $c_i$ ä¸ºçœŸâ€¦â€¦è¿™äº›é€»è¾‘å¼ä¸Šçš„è•´å«å¼æœ€ç»ˆå¯ä»¥è½¬åŒ–æˆé€»è¾‘å˜é‡ä¸Šçš„è•´å«å¼ï¼Œæ¯ä¸ªè•´å«å¼å½¢å¦‚â€œå¦‚æœ $x_i$ ä¸ºçœŸ/å‡ï¼Œåˆ™ $x_j$ ä¸ºçœŸ/å‡â€ã€‚äºæ˜¯è¿™ä¸ªé—®é¢˜è¢«è½¬åŒ–ä¸ºäº†ä¸€ä¸ª 2-SAT é—®é¢˜ï¼Œä»¥ä¸‹ç»™å‡º 2-SAT é—®é¢˜çš„é€šç”¨è§£æ³•ï¼š\næˆ‘ä»¬ä¸ºæ¯ä¸ªé€»è¾‘å˜é‡å»ºç«‹ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œä¸€ä¸ªè¡¨ç¤ºè¯¥é€»è¾‘å˜é‡å– trueï¼Œä¸€ä¸ªè¡¨ç¤ºè¯¥é€»è¾‘å˜é‡å– falseã€‚è¿™æ ·æˆ‘ä»¬å¯ä»¥å°†ä¹‹å‰å¾—åˆ°çš„æ‰€æœ‰è•´å«å¼é€šè¿‡æœ‰å‘è¾¹è¡¨è¾¾åœ¨è¿™å¼ å›¾ä¸Šã€‚æˆ‘ä»¬æ±‚å‡ºè¿™å¼ å›¾ä¸­æ‰€æœ‰çš„å¼ºè¿é€šåˆ†é‡ï¼Œä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ä¸­çš„ç‚¹çš„æ„ä¹‰æ˜¯ï¼šåªè¦æœ‰ä¸€ä¸ªæˆç«‹ï¼Œåˆ™å‰©ä¸‹çš„æ‰€æœ‰çš„éƒ½æˆç«‹ã€‚å› æ­¤å¦‚æœä¸€ä¸ªé€»è¾‘å˜é‡çš„ true èŠ‚ç‚¹å’Œ false èŠ‚ç‚¹åœ¨åŒä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ä¸­ï¼Œåˆ™åŸé—®é¢˜æ— è§£ï¼›å¦åˆ™æˆ‘ä»¬ä¸€å®šèƒ½æ‰¾åˆ°ä¸€ç§å®‰æ’æ–¹æ¡ˆæ»¡è¶³æ‰€æœ‰è•´å«å¼ï¼Œä»è€Œæ»¡è¶³æ‰€æœ‰ä¸‰å…ƒç»„çš„è¦æ±‚ã€‚\nB. æ—…è¡Œé—®é¢˜ é¢˜é¢æè¿° ç»™å®šä¸€ä¸ª $n$ ä¸ªç‚¹çš„å¸¦æƒå›¾ï¼Œæ±‚ä»ä»»æ„ç‚¹å‡ºå‘ï¼Œéå†æ‰€æœ‰èŠ‚ç‚¹è‡³å°‘ä¸€æ¬¡å¹¶åœ¨ä»»æ„ç‚¹ç»“æŸçš„æœ€å°è·ç¦»ã€‚ $n\\leq 20$ã€‚ é¢˜è§£ è€ƒè™‘çŠ¶æ€å‹ç¼©åŠ¨æ€è§„åˆ’ã€‚ä»¤ $dp(Mask, i)$ è¡¨ç¤ºå½“å‰åœ¨èŠ‚ç‚¹ $i$ï¼Œå·²ç»ç»å†è¿‡çš„ç‚¹ä¸º $Mask$ çš„æœ€å°è·ç¦»ã€‚è½¬ç§»æ˜¯å®¹æ˜“çš„ï¼šæšä¸¾ä¸‹ä¸€ä¸ªå»çš„èŠ‚ç‚¹ $j$ï¼Œåˆ™ $$ dp(Mask+j, j)=\\min(dp(Mask\\cup j,j),dp(Mask, i)+w_{ij}) $$ æ€»æ—¶é—´å¤æ‚åº¦ $O(n^2\\cdot 2^n)$ã€‚\nC. æå¤§å›¢ é¢˜é¢æè¿° ç»™å®š $n$ ä¸ªç‚¹ $m$ æ¡è¾¹çš„å›¾ï¼Œæ±‚å›¾ä¸­æå¤§å›¢çš„ä¸ªæ•°ã€‚ $n\\leq 18$ã€‚ é¢˜è§£ æˆ‘ä»¬æšä¸¾æ‰€æœ‰å¯èƒ½çš„ç‚¹é›† $S$ï¼Œç„¶åæ£€æŸ¥å›¾ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹ $v$ï¼šå¯¹äºä»»æ„ $v\\in S$ï¼Œåº”å½“æœ‰ $S\\subseteq neigh(v)$ï¼›å¯¹äºä»»æ„ $v\\notin S$ï¼Œåº”å½“æœ‰ $S-neigh(v)\\neq \\emptyset$ã€‚æå‰é¢„å¤„ç†æ¯ä¸ªç‚¹ $v$ çš„ $neigh(v)$ï¼Œæ£€æŸ¥å¯ä»¥åœ¨çº¿æ€§æ—¶é—´å†…å®Œæˆã€‚\næ€»æ—¶é—´å¤æ‚åº¦ $O(n\\cdot 2^n)$ã€‚\nD. æ‰«åœ°æœºå™¨äºº é¢˜é¢æè¿° ç»™å®šä¸€ä¸ª $n\\times m$ çš„æ–¹æ ¼çº¸ï¼Œæ±‚ä¸€æ¡ä» $(x,y)$ å‡ºå‘ï¼Œå°†æ‰€æœ‰æ ¼å­ç»è¿‡æ°å¥½ä¸€æ¬¡ï¼Œåœ¨ä»»æ„æ ¼å­ç»“æŸçš„è·¯å¾„ã€‚ $n,m\\leq 500$ï¼Œä¸” $n,m$ ä¸­è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯å¶æ•°ã€‚ é¢˜è§£ ä¸‹é¢çš„è®¨è®ºä¸­æˆ‘ä»¬å‡è®¾ $m$ æ˜¯å¶æ•°ã€‚å¶æ•°ç»™äº†æˆ‘ä»¬è¿™æ ·ä¸€ä¸ªå¥½çš„æ€§è´¨ï¼šè¦ä¹ˆ $y$ å’Œ $m-y$ éƒ½æ˜¯å¶æ•°ï¼Œè¦ä¹ˆ $y-1$ å’Œ $m+1-y$ éƒ½æ˜¯å¶æ•°ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç»™å‡ºä¸€ä¸ªå½¢å¦‚è¿™æ ·çš„å“ˆå¯†å°”é¡¿å›è·¯æ„é€ æ–¹æ³•ï¼š\nï¼ˆæ³¨ï¼šä¸Šå›¾æ˜¯ $y$ æ˜¯å¶æ•°çš„æƒ…å†µï¼›å¦‚æœ $y$ æ˜¯å¥‡æ•°åˆ™å…ˆå‘å³èµ°ã€‚ï¼‰\nä¸ºäº†ä»£ç ä¹¦å†™çš„ç®€ä¾¿ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆåœ¨æ—‹è½¬/ç¿»è½¬çš„åœ°å›¾ä¸Šèµ°å‡ºè·¯å¾„ï¼Œç„¶åå†å°†è·¯å¾„é€†æ—‹è½¬/ç¿»è½¬å›å»ã€‚è¿™æ ·ä»£ç é‡ä¼šå‡å°å¾ˆå¤šã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"2bdddfe53f7837930fb880c63ad05105","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-problem-solving/oj-solutions/iv-02/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/nju-problem-solving/oj-solutions/iv-02/","section":"notes","summary":"A. Majority 3-SAT é¢˜é¢æè¿° ç°æœ‰ $k$ ä¸ªé€»è¾‘å˜é‡ $x_1,\\cdots, x_k$ï¼Œç»™å‡º $n$ ä¸ªä¸‰å…ƒç»„ $(a_i,b_i,c_i)$ï¼Œå…¶ä¸­æ¯ä¸ªé€»è¾‘å¼å¯ä»¥å–ä»»æ„ä¸€ä¸ªé€»è¾‘å˜é‡æˆ–å…¶å¦å®šï¼Œæ¯ä¸ªä¸‰å…ƒç»„è¡¨ç¤ºä¸‰ä¸ªé€»è¾‘å¼è‡³å°‘ä¸¤ä¸ªä¸ºçœŸï¼Œé—®æ˜¯å¦èƒ½æ‰¾åˆ°ä¸€ç§èµ‹å€¼æ³•ï¼Œæ»¡è¶³æ‰€æœ‰ $n$ ä¸ªä¸‰å…ƒç»„ã€‚\n$k, n\\leq 10^4$ã€‚\né¢˜è§£ å¯¹äºä¸€ä¸ªä¸‰å…ƒç»„ $(a_i,b_i,c_i)$ï¼Œç”±äºè‡³å°‘è¦æœ‰ä¸¤ä¸ªè¡¨è¾¾å¼ä¸º trueï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å°†å…¶ç¿»è¯‘æˆå¦‚ä¸‹çš„ä¸€äº›è•´å«å¼ï¼šå¦‚æœ $a_i$ ä¸ºå‡ï¼Œåˆ™ $b_i$ ä¸ºçœŸï¼›å¦‚æœ $a_i$ ä¸ºå‡ï¼Œåˆ™ $c_i$ ä¸ºçœŸâ€¦â€¦è¿™äº›é€»è¾‘å¼ä¸Šçš„è•´å«å¼æœ€ç»ˆå¯ä»¥è½¬åŒ–æˆé€»è¾‘å˜é‡ä¸Šçš„è•´å«å¼ï¼Œæ¯ä¸ªè•´å«å¼å½¢å¦‚â€œå¦‚æœ $x_i$ ä¸ºçœŸ/å‡ï¼Œåˆ™ $x_j$ ä¸ºçœŸ/å‡â€ã€‚äºæ˜¯è¿™ä¸ªé—®é¢˜è¢«è½¬åŒ–ä¸ºäº†ä¸€ä¸ª 2-SAT é—®é¢˜ï¼Œä»¥ä¸‹ç»™å‡º 2-SAT é—®é¢˜çš„é€šç”¨è§£æ³•ï¼š","tags":null,"title":"é—®é¢˜æ±‚è§£ IV - 02 é¢˜è§£","type":"docs"},{"authors":null,"categories":null,"content":"A. Game é¢˜é¢æè¿° ç»™å®šä¸€ä¸ª $n$ ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œç°è¦æ±‚å°†ä¸€äº›èŠ‚ç‚¹æ¶‚é»‘ï¼Œä½¿å¾—æ¯æ¡è¾¹çš„ä¸¤ä¸ªç«¯ç‚¹éƒ½è‡³å°‘æœ‰ä¸€ä¸ªè¢«æ¶‚é»‘ã€‚æ±‚æ¶‚é»‘èŠ‚ç‚¹çš„æœ€å°ä¸ªæ•°ã€‚ $n\\leq 1500$ã€‚ é¢˜è§£ è€ƒè™‘æ ‘ä¸ŠåŠ¨æ€è§„åˆ’ï¼šä»¤ $dp(u,0/1)$ è¡¨ç¤ºå½“å‰è€ƒè™‘ä»¥ $u$ ä¸ºæ ¹çš„å­æ ‘ï¼Œ$u$ è¿™ä¸ªèŠ‚ç‚¹ä¸æ¶‚é»‘/æ¶‚é»‘çš„æƒ…å†µä¸‹å­æ ‘å†…æœ€å°éœ€è¦æ¶‚é»‘çš„èŠ‚ç‚¹ä¸ªæ•°ï¼Œè½¬ç§»æ˜¯ç®€å•çš„ï¼š $$ \\begin{align} dp(u,0)\u0026amp;=\\sum_{v\\in son(u)}dp(v,1)\\\\ dp(u,1)\u0026amp;=1+\\sum_{v\\in son(u)}\\min(dp(v,0),dp(v,1)) \\end{align} $$ æ€»æ—¶é—´å¤æ‚åº¦ $O(n)$ã€‚\nB. 01èƒŒåŒ…é—®é¢˜ é¢˜é¢æè¿° ç»™å®š $n$ ä¸ªç‰©å“ï¼Œç¬¬ $i$ ä¸ªç‰©å“çš„ä½“ç§¯æ˜¯ $v_i$ï¼Œä»·å€¼æ˜¯ $c_i$ã€‚ç°ç»™å®šèƒŒåŒ…å®¹é‡ $V$ï¼Œé—®èƒŒåŒ…å®¹é‡é™åˆ¶ä¸‹å¯ä»¥å–åˆ°çš„æœ€å¤§ä»·å€¼æ˜¯å¤šå°‘ã€‚ $n\\leq 40,v_i,c_i\\leq 10^9$ã€‚ é¢˜è§£ è¯¥é¢˜çš„é¢˜é¢æ˜¯ç»å…¸çš„01èƒŒåŒ…é—®é¢˜ï¼Œä½†ç”±äºä½“ç§¯å’Œä»·å€¼éƒ½è¿‡å¤§ï¼Œæ‰€ä»¥æ— æ³•ä½¿ç”¨åŠ¨æ€è§„åˆ’æ±‚è§£ã€‚\nè€ƒè™‘æŠ˜åŠæœç´¢ï¼šå°†ç‰©å“åˆ†æˆå‰ $n/2$ ä¸ªå’Œå $n/2$ ä¸ªä¸¤éƒ¨åˆ†ï¼Œå¯¹äºæ¯ä¸€éƒ¨åˆ†éƒ½æšä¸¾æ‰€æœ‰å¯èƒ½çš„é€‰å–å­é›†ï¼Œä»è€Œå¾—åˆ°ä¸¤å † (ä½“ç§¯,ä»·å€¼) å¯¹ã€‚æˆ‘ä»¬ç°åœ¨çš„ç›®æ ‡æ˜¯ä»ç¬¬ä¸€ä¸ªå †å’Œç¬¬äºŒä¸ªå †é‡Œå„é€‰å‡ºä¸€ä¸ª pairï¼Œä½¿å¾—å®ƒä»¬çš„ä½“ç§¯ä¹‹å’Œä¸è¶…è¿‡ä¸Šé™ä¸”ä»·å€¼ä¹‹å’Œæœ€å¤§ã€‚\næˆ‘ä»¬å°†ä¸¤å †æ•°å¯¹éƒ½æŒ‰ç…§ä½“ç§¯ä»å°åˆ°å¤§æ’åºï¼Œç„¶åå€’åºæšä¸¾ç¬¬ä¸€å †é‡Œçš„æ¯ä¸ª pairï¼Œéšç€ç¬¬ä¸€ä¸ªå †é‡Œä½“ç§¯çš„å‡å°ï¼Œç¬¬äºŒä¸ªå †é‡Œå¯è¡Œçš„ä½“ç§¯ä¸Šé™é€æ¸å¢å¤§ï¼Œè¿™ä¸ªè¿‡ç¨‹æ˜¯å•è°ƒçš„ï¼Œå› æ­¤æˆ‘ä»¬æšä¸¾çš„è¿‡ç¨‹ä¸­åŠ¨æ€ç»´æŠ¤ç¬¬äºŒä¸ªå †ä¸­å¯è¡Œ pair çš„ä»·å€¼çš„æœ€å¤§å€¼å³å¯ã€‚\næ€»æ—¶é—´å¤æ‚åº¦ $O(\\frac{n}{2}\\cdot 2^{\\frac{n}{2}})$ã€‚\nC. è™«é£Ÿç®— é¢˜é¢æè¿° ç»™å®šä¸€ä¸ªå­—æ¯ç«–å¼ï¼Œæ±‚å‡ºä¸€ä¸ªå­—æ¯-æ•°å­—çš„æ˜ å°„ï¼Œä½¿å¾—ç«–å¼æˆç«‹ã€‚ ç«–å¼ä¸­æ•°çš„ä½æ•° $\\leq 21$ã€‚ é¢˜è§£ æŒ‰ç…§ç«–å¼ä»å³åˆ°å·¦çš„é¡ºåºæœç´¢+å‰ªæã€‚å‰ªæä¸»è¦å…³æ³¨æ•°å­—ä¸èƒ½é‡å¤ä½¿ç”¨ï¼Œä»¥åŠæ¯ä¸€åˆ—æšä¸¾äº†ä¸¤ä¸ªæ•°å­—ç¬¬ä¸‰ä¸ªæ•°å­—å°±å¯ä»¥ç›´æ¥ç®—å‡ºæ¥è¿™ä¸¤ä¸ªç‰¹æ€§ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"a2958c32e58ea96e9ba1f265ac26dbc1","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-problem-solving/oj-solutions/iv-03/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/nju-problem-solving/oj-solutions/iv-03/","section":"notes","summary":"A. Game é¢˜é¢æè¿° ç»™å®šä¸€ä¸ª $n$ ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œç°è¦æ±‚å°†ä¸€äº›èŠ‚ç‚¹æ¶‚é»‘ï¼Œä½¿å¾—æ¯æ¡è¾¹çš„ä¸¤ä¸ªç«¯ç‚¹éƒ½è‡³å°‘æœ‰ä¸€ä¸ªè¢«æ¶‚é»‘ã€‚æ±‚æ¶‚é»‘èŠ‚ç‚¹çš„æœ€å°ä¸ªæ•°ã€‚ $n\\leq 1500$ã€‚ é¢˜è§£ è€ƒè™‘æ ‘ä¸ŠåŠ¨æ€è§„åˆ’ï¼šä»¤ $dp(u,0/1)$ è¡¨ç¤ºå½“å‰è€ƒè™‘ä»¥ $u$ ä¸ºæ ¹çš„å­æ ‘ï¼Œ$u$ è¿™ä¸ªèŠ‚ç‚¹ä¸æ¶‚é»‘/æ¶‚é»‘çš„æƒ…å†µä¸‹å­æ ‘å†…æœ€å°éœ€è¦æ¶‚é»‘çš„èŠ‚ç‚¹ä¸ªæ•°ï¼Œè½¬ç§»æ˜¯ç®€å•çš„ï¼š $$ \\begin{align} dp(u,0)\u0026amp;=\\sum_{v\\in son(u)}dp(v,1)\\\\ dp(u,1)\u0026amp;=1+\\sum_{v\\in son(u)}\\min(dp(v,0),dp(v,1)) \\end{align} $$ æ€»æ—¶é—´å¤æ‚åº¦ $O(n)$ã€‚\nB. 01èƒŒåŒ…é—®é¢˜ é¢˜é¢æè¿° ç»™å®š $n$ ä¸ªç‰©å“ï¼Œç¬¬ $i$ ä¸ªç‰©å“çš„ä½“ç§¯æ˜¯ $v_i$ï¼Œä»·å€¼æ˜¯ $c_i$ã€‚ç°ç»™å®šèƒŒåŒ…å®¹é‡ $V$ï¼Œé—®èƒŒåŒ…å®¹é‡é™åˆ¶ä¸‹å¯ä»¥å–åˆ°çš„æœ€å¤§ä»·å€¼æ˜¯å¤šå°‘ã€‚ $n\\leq 40,v_i,c_i\\leq 10^9$ã€‚ é¢˜è§£ è¯¥é¢˜çš„é¢˜é¢æ˜¯ç»å…¸çš„01èƒŒåŒ…é—®é¢˜ï¼Œä½†ç”±äºä½“ç§¯å’Œä»·å€¼éƒ½è¿‡å¤§ï¼Œæ‰€ä»¥æ— æ³•ä½¿ç”¨åŠ¨æ€è§„åˆ’æ±‚è§£ã€‚","tags":null,"title":"é—®é¢˜æ±‚è§£ IV - 03 é¢˜è§£","type":"docs"},{"authors":null,"categories":null,"content":"return and print def what_prints(): print('Hello World!') return 'Exiting this function.' print('61A is awesome!') è¯¥ç¨‹åºçš„è¿è¡Œç»“æœæ˜¯\n\u0026gt;\u0026gt;\u0026gt; what_prints() Hello World! 'Exiting this function.' æ³¨æ„ print çš„ç»“æœæ˜¯ä¸å¸¦å¼•å·çš„ï¼Œreturn çš„ç»“æœæ˜¯å¸¦å¼•å·çš„ã€‚\nBoolean Operators å¦‚æœå¤šä¸ªè¯­å¥ç”¨ AND è¿æ¥ï¼Œé‚£ä¹ˆ python ä¼šæ‰§è¡Œåˆ°ç¬¬ä¸€ä¸ªä¸ºå‡çš„è¡¨è¾¾å¼ï¼Œåé¢çš„ä¸å†æ‰§è¡Œï¼Œè¿™å°±æ˜¯çŸ­è·¯ (short circuiting)ã€‚æ­¤æ—¶å³ä½¿åé¢å†™äº†æ‰§è¡Œä¼šå¯¼è‡´ Error çš„è¯­å¥ä¹Ÿä¸ä¼š crashã€‚OR åŒç†ã€‚\n\u0026gt;\u0026gt;\u0026gt; 1 / 0 ZeroDivisionError \u0026gt;\u0026gt;\u0026gt; True or (1 / 0) True é€»è¾‘è¡¨è¾¾å¼æ€»æ˜¯ä¼šè¿”å›æœ€åä¸€ä¸ªå…ƒç´ ï¼Œè¯¥è§„åˆ™åœ¨çŸ­è·¯æƒ…å†µä¸‹åŒæ ·é€‚ç”¨ï¼Œä¸‹é¢æ˜¯ä¸€äº›ä¾‹å­ï¼š\n\u0026gt;\u0026gt;\u0026gt; True and 13 13 \u0026gt;\u0026gt;\u0026gt; not 10 False \u0026gt;\u0026gt;\u0026gt; False or [] [] \u0026gt;\u0026gt;\u0026gt; 0 or False or 2 or 1 / 0 2 0 [] None ä¹Ÿä¼šè¢«è§†ä¸º Falseï¼Œä½†å¦‚æœå¯¹ä¸€ä¸ª True çš„ä¸œè¥¿å– notï¼Œè¿”å›ç»“æœåªå¯èƒ½æ˜¯ Falseã€‚\nDebugging Traceback Message Traceback Message ç±»ä¼¼äº GDB çš„å›æº¯é¡ºåºï¼Œå®é™…çš„å‡½æ•°è°ƒç”¨é¡ºåºæ˜¯ä»ä¸‹å¾€ä¸Šçš„ã€‚\nDebugging Techniques Running doctests python3 çš„ -m é€‰é¡¹æä¾› doctest åŠŸèƒ½ï¼šæˆ‘ä»¬å¯ä»¥æŠŠç®€å•çš„æµ‹è¯•ç”¨ä¾‹å†™åœ¨æºä»£ç ä¸­ã€‚ä¾‹å¦‚\n# square.py def square(x): \u0026quot;\u0026quot;\u0026quot; \u0026gt;\u0026gt;\u0026gt; square(4) 16 \u0026quot;\u0026quot;\u0026quot; return x * x ç”¨ä¸€å¯¹ \u0026quot;\u0026quot;\u0026quot; æ‹¬èµ·æ¥çš„æ³¨é‡Šå†…å®¹ä¸­å¯ä»¥ä¹¦å†™æµ‹è¯•ç”¨ä¾‹ï¼Œæµ‹è¯•ç”¨ä¾‹çš„å†™æ³•ç±»ä¼¼äº python çš„äº¤äº’ç•Œé¢ï¼Œåœ¨ \u0026gt;\u0026gt;\u0026gt; åå†™ä¸‹è¦æ‰§è¡Œçš„è¯­å¥ï¼Œå¹¶å¦èµ·ä¸€è¡Œå†™ä¸‹æœŸæœ›çš„ç»“æœã€‚ä½¿ç”¨\npython3 -m doctest square.py è¿›è¡Œæµ‹è¯•ï¼Œå¦‚æœç¨‹åºè¿è¡Œçš„ç»“æœå’ŒæœŸæœ›ç»“æœä¸åŒ python ä¼šæŠ¥é”™ã€‚\nå¦‚æœä½¿ç”¨ -v é€‰é¡¹ï¼Œpython ä¸ä»…ä¼šæŠ¥é”™ï¼Œè¿˜ä¼šå°†é€šè¿‡çš„æµ‹è¯•ç”¨ä¾‹çš„ä¿¡æ¯ä¹Ÿæ˜¾ç¤ºå‡ºæ¥ã€‚\nInteractive Debugging ä½¿ç”¨ä¸€ä¸ªäº¤äº’å¼çš„ REPL æ˜¯ debug çš„å¥½æ–¹å¼ã€‚å‡è®¾å½“å‰æˆ‘ä»¬è¦ debug file.py è¿™ä¸ªç¨‹åºï¼Œä½¿ç”¨å‘½ä»¤\npython3 -i file.py å¯ä»¥æ‰“å¼€ä¸€ä¸ª python çš„ REPLï¼Œå®ƒå·²ç»æ‰§è¡Œäº† file.py ä¸­çš„æ‰€æœ‰å®šä¹‰ï¼Œæˆ‘ä»¬å¯ä»¥è¾“å…¥ä»»æ„çš„å‘½ä»¤è¿›è¡Œæµ‹è¯•ã€‚\nUsing ok python3 ok -q MODULE_NAME -i å¯ä»¥æ‰“å¼€ REPLã€‚\npython3 ok q MODULE_NAME --trace å¯ä»¥æ‰“å¼€ç¨‹åºçš„å¯è§†åŒ–çª—å£ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"6e980681fe611328119c91feb69f3392","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/labs/lab01/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/labs/lab01/","section":"notes","summary":"return and print def what_prints(): print('Hello World!') return 'Exiting this function.' print('61A is awesome!') è¯¥ç¨‹åºçš„è¿è¡Œç»“æœæ˜¯\n\u0026gt;\u0026gt;\u0026gt; what_prints() Hello World! 'Exiting this function.' æ³¨æ„ print çš„ç»“æœæ˜¯ä¸å¸¦å¼•å·çš„ï¼Œreturn çš„ç»“æœæ˜¯å¸¦å¼•å·çš„ã€‚\nBoolean Operators å¦‚æœå¤šä¸ªè¯­å¥ç”¨ AND è¿æ¥ï¼Œé‚£ä¹ˆ python ä¼šæ‰§è¡Œåˆ°ç¬¬ä¸€ä¸ªä¸ºå‡çš„è¡¨è¾¾å¼ï¼Œåé¢çš„ä¸å†æ‰§è¡Œï¼Œè¿™å°±æ˜¯çŸ­è·¯ (short circuiting)ã€‚æ­¤æ—¶å³ä½¿åé¢å†™äº†æ‰§è¡Œä¼šå¯¼è‡´ Error çš„è¯­å¥ä¹Ÿä¸ä¼š crashã€‚OR åŒç†ã€‚","tags":null,"title":"UCB-CS61A Lab 01: Variables \u0026 Functions, Control","type":"docs"},{"authors":null,"categories":null,"content":"æ²¡æœ‰éœ€è¦ç‰¹åˆ«æ³¨æ„çš„çŸ¥è¯†ç‚¹å’Œé¢˜ç›®ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"683422e3076539dceeff0e01566b6862","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/labs/lab02/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/labs/lab02/","section":"notes","summary":"æ²¡æœ‰éœ€è¦ç‰¹åˆ«æ³¨æ„çš„çŸ¥è¯†ç‚¹å’Œé¢˜ç›®ã€‚","tags":null,"title":"UCB-CS61A Lab 02: Higher-Order Functions, Lambda Expressions","type":"docs"},{"authors":null,"categories":null,"content":"ä¸‹é¢çš„ä¸¤é“é¢˜æ˜¯æ¯”è¾ƒæœ‰æ„æ€çš„ï¼š\nQ1: WWPD: Journey to the Center of the Earch \u0026gt;\u0026gt;\u0026gt; def crust(): ... print(\u0026quot;70km\u0026quot;) ... def mantle(): ... print(\u0026quot;2900km\u0026quot;) ... def core(): ... print(\u0026quot;5300km\u0026quot;) ... return mantle() ... return core ... return mantle \u0026gt;\u0026gt;\u0026gt; drill = crust \u0026gt;\u0026gt;\u0026gt; drill = drill() ______ \u0026gt;\u0026gt;\u0026gt; drill = drill() ______ \u0026gt;\u0026gt;\u0026gt; drill = drill() ______ \u0026gt;\u0026gt;\u0026gt; drill() ______ å€¼å¾—æ³¨æ„çš„æ˜¯ç¬¬ä¸‰æ¬¡å’Œç¬¬å››æ¬¡è°ƒç”¨ drill() çš„åŒºåˆ«ã€‚ä¸¤æ¬¡è°ƒç”¨çš„ drill() éƒ½æ˜¯ core() è¿™ä¸ªå‡½æ•°ï¼Œå®ƒä»¬é¦–å…ˆä¼šè¾“å‡º \u0026ldquo;5300km\u0026rdquo;ï¼Œç„¶åè°ƒç”¨ mantle() ä¹‹åè¾“å‡º \u0026ldquo;2900km\u0026rdquo;ï¼Œæœ€åè¿”å›å‡½æ•° core()ã€‚ä½†ç¬¬ä¸€æ¬¡çš„è¯­å¥æ˜¯ä¸€ä¸ªèµ‹å€¼è¯­å¥ï¼Œèµ‹å€¼è¯­å¥çš„è¿”å›å€¼æ˜¯ Noneï¼Œç¬¬äºŒæ¬¡çš„è¯­å¥æ˜¯ä¸€ä¸ªå•çº¯çš„è°ƒç”¨ï¼Œæ‰€ä»¥æœ€åå‡½æ•°çš„è¿”å›å€¼ \u0026ldquo;Function\u0026hellip;\u0026rdquo; ä¹Ÿä¼šè¢«æ‰“å°å‡ºæ¥ã€‚\nQ7: Riffle Shuffle è¿™é“é¢˜æœ‰ä¸€ç‚¹å°éš¾åº¦ï¼Œå› ä¸º list comprehension ä¸­ä¸èƒ½å¸¦æœ‰ elseï¼Œæ‰€ä»¥æˆ‘ä»¬è¦æƒ³å‡ºä¸€ç§ç»Ÿä¸€çš„æ–¹æ³•æ¥æ ¹æ®ä¸‹æ ‡ä»æ•°ç»„ä¸­å–æ•°ã€‚æˆ‘ä»¬å¯ä»¥åˆ©ç”¨ i % 2 çš„ç»“æœå‚ä¸è¿ç®—ï¼š\nreturn [deck[i // 2 + (i % 2) * len(deck) // 2] for i in range(len(deck))] ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"81b95f0635a031ea02a6d40096fadca1","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/labs/lab04/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/labs/lab04/","section":"notes","summary":"ä¸‹é¢çš„ä¸¤é“é¢˜æ˜¯æ¯”è¾ƒæœ‰æ„æ€çš„ï¼š\nQ1: WWPD: Journey to the Center of the Earch \u0026gt;\u0026gt;\u0026gt; def crust(): ... print(\u0026quot;70km\u0026quot;) ... def mantle(): ... print(\u0026quot;2900km\u0026quot;) ... def core(): ... print(\u0026quot;5300km\u0026quot;) ... return mantle() ... return core .","tags":null,"title":"UCB-CS61A Lab 04: Recursion, Tree Recursion, Python Lists","type":"docs"},{"authors":null,"categories":null,"content":"Data Abstraction data abstraction ä¸­é€šå¸¸åŒ…æ‹¬ä»¥ä¸‹ä¸¤ç±»å‡½æ•°ï¼š\nconstructors: ç”¨äºæ„å»ºæ•°æ®ç»“æ„ã€‚ selectors: ç”¨äºä»æ•°æ®ç»“æ„ä¸­æå–ä¿¡æ¯ã€‚ æœ¬å®éªŒçš„é¢˜ç›®ä¸ç®—å¤ªéš¾ï¼Œå……åˆ†åˆ©ç”¨æ ‘çš„é€’å½’æ€§å¯ä»¥å†™å‡ºæ—¢ç®€æ´åˆæ»¡è¶³ abstraction barrier çš„ä»£ç ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"186f42bcc65e301874d7591cd74258b9","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/labs/lab05/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/labs/lab05/","section":"notes","summary":"Data Abstraction data abstraction ä¸­é€šå¸¸åŒ…æ‹¬ä»¥ä¸‹ä¸¤ç±»å‡½æ•°ï¼š\nconstructors: ç”¨äºæ„å»ºæ•°æ®ç»“æ„ã€‚ selectors: ç”¨äºä»æ•°æ®ç»“æ„ä¸­æå–ä¿¡æ¯ã€‚ æœ¬å®éªŒçš„é¢˜ç›®ä¸ç®—å¤ªéš¾ï¼Œå……åˆ†åˆ©ç”¨æ ‘çš„é€’å½’æ€§å¯ä»¥å†™å‡ºæ—¢ç®€æ´åˆæ»¡è¶³ abstraction barrier çš„ä»£ç ã€‚","tags":null,"title":"UCB-CS61A Lab 05: Python Lists, Trees","type":"docs"},{"authors":null,"categories":null,"content":"List API ä¸€äº›é‡è¦çš„ API çš„è¡¥å……è¯´æ˜ï¼š\nlist.pop(index=-1) çš„ä½œç”¨æ˜¯å¼¹å‡º list[index] è¿™ä¸ªå…ƒç´ ï¼Œæ²¡æœ‰å¡«å†™å‚æ•°é»˜è®¤ä¸º -1ã€‚è¯¥ method çš„è¿”å›å€¼æ˜¯å¼¹å‡ºçš„å…ƒç´ çš„å€¼ã€‚\nlist.remove(x) åˆ é™¤ list ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´  xã€‚\nlist.insert(index, obj) çš„ä½œç”¨æ˜¯åœ¨ index ä¸º index çš„å…ƒç´ å‰é¢æ·»åŠ å…ƒç´  obj (å³æ’å…¥å®Œå…ƒç´ å obj çš„ä¸‹æ ‡æ˜¯ index)\nlist.append() çš„è¿”å›å€¼æ˜¯ Noneã€‚ ä¸€é“ä¾‹é¢˜å¾ˆå¥½åœ°å±•ç°äº†è¿™ä¸ªç‰¹æ€§ï¼š\n\u0026gt;\u0026gt;\u0026gt; lst = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; lst.extend(lst.append(4), list.append(5)) \u0026gt;\u0026gt;\u0026gt; lst [1, 2, 3, None, None] Iterators ä¸¤ä¸ªå€¼å¾—æ³¨æ„çš„ç»†èŠ‚ï¼š\nå¦‚æœä¸€ä¸ª iterater iter åœ¨ for å¾ªç¯ä¸­è¢«ä½¿ç”¨ï¼Œä¾‹å¦‚ for x in iterï¼Œé‚£ä¹ˆ for å¾ªç¯ç»“æŸæ—¶ iter çš„å€¼æ˜¯è¢«æ”¹å˜äº†çš„ï¼Œå†è°ƒç”¨ next() ä¼šå¾—åˆ° StopIterationã€‚ ä½¿ç”¨ list(iter) è·å¾—åˆ—è¡¨çš„è¯ä¼šä¿®æ”¹ iter çš„ä½ç½®ï¼Œæ‰€ä»¥å¦‚æœåªæƒ³å–å‰ n ä¸ªå…ƒç´ ä¸”ä¿è¯ iter çš„ä½ç½®ï¼Œä¸èƒ½ä½¿ç”¨ list(iter)[:n] çš„æ–¹å¼ã€‚ ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"7f56745a8b05117d35d0f49f1318d416","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/labs/lab06/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/labs/lab06/","section":"notes","summary":"List API ä¸€äº›é‡è¦çš„ API çš„è¡¥å……è¯´æ˜ï¼š\nlist.pop(index=-1) çš„ä½œç”¨æ˜¯å¼¹å‡º list[index] è¿™ä¸ªå…ƒç´ ï¼Œæ²¡æœ‰å¡«å†™å‚æ•°é»˜è®¤ä¸º -1ã€‚è¯¥ method çš„è¿”å›å€¼æ˜¯å¼¹å‡ºçš„å…ƒç´ çš„å€¼ã€‚\nlist.remove(x) åˆ é™¤ list ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´  xã€‚\nlist.insert(index, obj) çš„ä½œç”¨æ˜¯åœ¨ index ä¸º index çš„å…ƒç´ å‰é¢æ·»åŠ å…ƒç´  obj (å³æ’å…¥å®Œå…ƒç´ å obj çš„ä¸‹æ ‡æ˜¯ index)\nlist.append() çš„è¿”å›å€¼æ˜¯ Noneã€‚ ä¸€é“ä¾‹é¢˜å¾ˆå¥½åœ°å±•ç°äº†è¿™ä¸ªç‰¹æ€§ï¼š","tags":null,"title":"UCB-CS61A Lab 06: Mutability and Iterators","type":"docs"},{"authors":null,"categories":null,"content":"æœ¬å®éªŒä¸­æ¯”è¾ƒæœ‰æ„æ€çš„é¢˜ç›®æ˜¯å®ç°å¡ç‰Œæ¸¸æˆçš„â€œå°é¡¹ç›®â€ã€‚æˆ‘ä»¬åœ¨å¡«å†™ä»£ç ä¹‹å‰å°±å¯ä»¥æ€è€ƒä¸€ä¸‹å¦‚ä½•ç”¨ oop çš„æ€æƒ³æ¥è®¾è®¡ç¨‹åºæ¡†æ¶ï¼šå¡ç‰Œã€ç©å®¶ã€å¡ç‰Œæ± åº”å½“è¢«è®¾è®¡ä¸ºå¯¹è±¡ï¼Œå¯¹è±¡ä¹‹é—´å¯ä»¥äº¤äº’ï¼›æ™®é€šå¡ç‰Œæ˜¯ä¸€ä¸ªå¤§ç±»ï¼Œæ‹¥æœ‰ç‰¹æ®Šæ•ˆæœçš„å¡ç‰Œå¯ä»¥ä½¿ç”¨ç»§æ‰¿æœºåˆ¶ä½¿ç”¨å¤§ç±»çš„å±æ€§å¹¶æ·»åŠ è‡ªå·±çš„ç‹¬ç‰¹å±æ€§ï¼›ç©å®¶æ‰‹ä¸Šæœ‰ 5 å¼ æ‰‹ç‰Œï¼Œè¿™æ˜¯ä¸€ä¸ª \u0026ldquo;has a\u0026rdquo; çš„å…³ç³»ï¼Œåº”å½“ä½¿ç”¨ composition ç»´æŠ¤ä¸€ä¸ªå¡ç‰Œå¯¹è±¡çš„åˆ—è¡¨â€¦â€¦\nPass by Value v.s. Pass by Reference\nPython ä¸åƒ C è¯­è¨€é‚£æ ·å¯ä»¥æ˜ç¡®ç»™å‡½æ•°ä¼ é€’çš„å‚æ•°æ˜¯æŒ‡é’ˆè¿˜æ˜¯æ™®é€šå˜é‡ï¼Œä½† Python æœ‰è‡ªå·±çš„ specificationï¼šå¦‚æœä¼ é€’çš„æ˜¯ä¸€ä¸ª immutable çš„ä¸œè¥¿ (å¦‚ string, int)ï¼Œé‚£ä¹ˆæ˜¯æŒ‰å€¼ä¼ é€’çš„ï¼›å¦‚æœä¼ é€’çš„æ˜¯ mutable çš„ä¸œè¥¿ (å¦‚ list, object)ï¼Œé‚£ä¹ˆæ˜¯æŒ‰å¼•ç”¨ä¼ é€’çš„ã€‚å› æ­¤åœ¨è¯¥å®éªŒä¸­ï¼Œå°†å¯¹è±¡ä¼ ç»™å¦ä¸€ä¸ªå¯¹è±¡çš„ methodï¼Œmethod å¯¹å‚æ•°å¯¹è±¡çš„ä¿®æ”¹å¯ä»¥ç›´æ¥å½±å“åŸå¯¹è±¡çš„çŠ¶æ€ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"cfe3657abd25ad41f1772f65a8d8b6b0","permalink":"https://kristoff-starling.github.io/notes/coursenotes/ucb-cs61a/labs/lab07/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/ucb-cs61a/labs/lab07/","section":"notes","summary":"æœ¬å®éªŒä¸­æ¯”è¾ƒæœ‰æ„æ€çš„é¢˜ç›®æ˜¯å®ç°å¡ç‰Œæ¸¸æˆçš„â€œå°é¡¹ç›®â€ã€‚æˆ‘ä»¬åœ¨å¡«å†™ä»£ç ä¹‹å‰å°±å¯ä»¥æ€è€ƒä¸€ä¸‹å¦‚ä½•ç”¨ oop çš„æ€æƒ³æ¥è®¾è®¡ç¨‹åºæ¡†æ¶ï¼šå¡ç‰Œã€ç©å®¶ã€å¡ç‰Œæ± åº”å½“è¢«è®¾è®¡ä¸ºå¯¹è±¡ï¼Œå¯¹è±¡ä¹‹é—´å¯ä»¥äº¤äº’ï¼›æ™®é€šå¡ç‰Œæ˜¯ä¸€ä¸ªå¤§ç±»ï¼Œæ‹¥æœ‰ç‰¹æ®Šæ•ˆæœçš„å¡ç‰Œå¯ä»¥ä½¿ç”¨ç»§æ‰¿æœºåˆ¶ä½¿ç”¨å¤§ç±»çš„å±æ€§å¹¶æ·»åŠ è‡ªå·±çš„ç‹¬ç‰¹å±æ€§ï¼›ç©å®¶æ‰‹ä¸Šæœ‰ 5 å¼ æ‰‹ç‰Œï¼Œè¿™æ˜¯ä¸€ä¸ª \u0026ldquo;has a\u0026rdquo; çš„å…³ç³»ï¼Œåº”å½“ä½¿ç”¨ composition ç»´æŠ¤ä¸€ä¸ªå¡ç‰Œå¯¹è±¡çš„åˆ—è¡¨â€¦â€¦\nPass by Value v.s. Pass by Reference\nPython ä¸åƒ C è¯­è¨€é‚£æ ·å¯ä»¥æ˜ç¡®ç»™å‡½æ•°ä¼ é€’çš„å‚æ•°æ˜¯æŒ‡é’ˆè¿˜æ˜¯æ™®é€šå˜é‡ï¼Œä½† Python æœ‰è‡ªå·±çš„ specificationï¼šå¦‚æœä¼ é€’çš„æ˜¯ä¸€ä¸ª immutable çš„ä¸œè¥¿ (å¦‚ string, int)ï¼Œé‚£ä¹ˆæ˜¯æŒ‰å€¼ä¼ é€’çš„ï¼›å¦‚æœä¼ é€’çš„æ˜¯ mutable çš„ä¸œè¥¿ (å¦‚ list, object)ï¼Œé‚£ä¹ˆæ˜¯æŒ‰å¼•ç”¨ä¼ é€’çš„ã€‚å› æ­¤åœ¨è¯¥å®éªŒä¸­ï¼Œå°†å¯¹è±¡ä¼ ç»™å¦ä¸€ä¸ªå¯¹è±¡çš„ methodï¼Œmethod å¯¹å‚æ•°å¯¹è±¡çš„ä¿®æ”¹å¯ä»¥ç›´æ¥å½±å“åŸå¯¹è±¡çš„çŠ¶æ€ã€‚","tags":null,"title":"UCB-CS61a Lab 07: Object-Oriented Programming","type":"docs"},{"authors":null,"categories":null,"content":"Progress Implement copy-on write (hard) Implement Copy-on Write å†™æ—¶æ‹·è´ fork çš„å¤§ä½“æ€è·¯æ˜¯ï¼šåœ¨ fork æ—¶ä¸ä¸ºå­è¿›ç¨‹åˆ›å»ºæ–°çš„é¡µé¢ï¼Œè€Œæ˜¯è®©å­è¿›ç¨‹æŒ‡å‘çˆ¶è¿›ç¨‹çš„æ‰€æœ‰é¡µé¢ï¼Œå¹¶å°†é¡µé¢çš„æƒé™æ”¹ä¸ºåªè¯»ã€‚å°†æ¥å¦‚æœæŸä¸ªè¿›ç¨‹ (çˆ¶/å­) éœ€è¦ä¿®æ”¹é¡µé¢ï¼Œä¼šå‘ç”Ÿ page fault exceptionï¼Œåœ¨ kernel çš„å¤„ç†ç¨‹åºä¸­ï¼Œå¦‚æœæ˜¯ COW pageï¼Œåˆ™æ–°åˆ†é…ä¸€ä¸ªé¡µé¢ï¼Œå°†å½“å‰çš„åªè¯»é¡µé¢å†…å®¹å¤åˆ¶è¿‡å»ï¼Œè®©å½“å‰è¿›ç¨‹çš„é¡µè¡¨æŒ‡å‘è¿™ä¸ªæ–°çš„é¡µé¢å¹¶å°†æƒé™è®¾ç½®ä¸ºå¯è¯»å¯å†™ã€‚\nkalloc()/kfree() å¼•å…¥äº† copy-on write ä¹‹åï¼Œä¸€ä¸ªç‰©ç†é¡µé¢å¯èƒ½ä¼šè¢«å¤šä¸ªè¿›ç¨‹çš„é¡µè¡¨æŒ‡å‘ï¼Œè¿™ä½¿å¾— kfree() å˜å¾—å›°éš¾ï¼šæŸä¸ªè¿›ç¨‹è¢«é‡Šæ”¾æ—¶ï¼Œå®ƒæ‹¥æœ‰çš„ç‰©ç†é¡µé¢ä¸èƒ½è¢«ç›´æ¥é‡Šæ”¾ï¼Œå¦åˆ™åˆ«çš„è¿›ç¨‹å°±ç”¨ä¸äº†è¿™ä¸ªé¡µé¢äº†ã€‚æˆ‘ä»¬éœ€è¦ä¸ºæ¯ä¸ªé¡µé¢ç»´æŠ¤ä¸€ä¸ª reference countï¼Œåªæœ‰ä¸€ä¸ªé¡µé¢çš„ reference count ä¸º 0 äº†æ‰èƒ½é‡Šæ”¾å®ƒã€‚\nç»´æŠ¤ reference count çš„æ—¶æœºå¾ˆæœ‰è®²ç©¶ã€‚ç¬”è€…æœ€åˆä½¿ç”¨çš„æ–¹æ¡ˆæ˜¯åœ¨â€œæ˜ å°„â€œå’Œâ€œè§£é™¤æ˜ å°„â€çš„æ—¶å€™ä¿®æ”¹ reference countï¼Œå³åœ¨ mappages() å‡½æ•°ã€ uvmunmap() å‡½æ•°å’Œ COW ç›¸å…³å‡½æ•°ä¸­ä¿®æ”¹ reference countã€‚ä½† xv6 ä¸­å¯¹ mappages() çš„ç”¨æ³•æ¯”è¾ƒçµæ´»ï¼Œä¾‹å¦‚\nvoid kvminit() { ...... // map kernel data and the physical RAM we'll make use of. kvmmap((uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W); ...... } ä¸Šè¿° kvmmap() ä¼šå¯¹æ‰€æœ‰çš„ç‰©ç†é¡µé¢åšä¸€ä¸ªæ’ç­‰æ˜ å°„ã€‚å…¶å®å†…æ ¸å¹¶æ²¡æœ‰çœŸæ­£æ‹¥æœ‰è¿™äº›é¡µé¢ï¼Œåš mappages() æ—¶ï¼ŒçœŸå®åˆ†é…å¥½çš„é¡µé¢æ˜¯ä¸å­˜åœ¨çš„ï¼Œåœ¨ kvmmap() ä¸­åšè¿™ä¸€æ­¥åªæ˜¯ä¸ºäº†ç®€åŒ–å†…æ ¸ä»£ç çš„ä¹¦å†™ (å¦‚åœ¨è°ƒç”¨ memmove() æ—¶ä¸éœ€è¦åœ¨è½¯ä»¶ä¸­è·‘ä¸€éå†…æ ¸é¡µè¡¨)ã€‚å› æ­¤å¦‚æœåœ¨ mappages() çš„æ—¶å€™ç»´æŠ¤ reference countï¼Œä¼šå¾—åˆ°ä¸æ­£ç¡®çš„ç»“æœã€‚\nä¸€ä¸ªåˆç†çš„è§£å†³æ–¹æ¡ˆæ˜¯åœ¨ COW ç›¸å…³å‡½æ•°ä¸­å¢åŠ  reference countï¼Œåœ¨ kfree() ä¸­å‡å°‘ reference countã€‚kalloc() ä¸­æ–°å‡ºå‚çš„é¡µé¢é»˜è®¤ reference count ä¸º 1ã€‚\nuvmcopy()/uvmcow() æˆ‘ä»¬éœ€è¦ä¿®æ”¹ uvmcopy() çš„å®ç°ï¼Œä¸ä¸ºå­è¿›ç¨‹åˆ†é…æ–°çš„é¡µé¢ï¼Œè€Œæ˜¯è®©å­è¿›ç¨‹æŒ‡å‘çˆ¶è¿›ç¨‹çš„é¡µé¢ï¼Œæ›´æ–°çˆ¶è¿›ç¨‹çš„ reference countï¼Œå¹¶è®¾ç½®é¡µè¡¨é¡¹çš„æ ‡å¿—ä½ã€‚è¿™é‡Œè¦æ³¨æ„çš„æ˜¯ï¼Œé™¤äº†å–æ¶ˆé¡µé¢çš„ PTE_Wï¼Œä¸ºäº†å°† cow page çš„å¼‚å¸¸å’Œæ™®é€šçš„è¶Šæƒä¿®æ”¹å¼‚å¸¸åŒºåˆ†å¼€æ¥ï¼Œæˆ‘ä»¬åº”å½“åœ¨é¡µè¡¨é¡¹ä¸­æ ‡å¿—ä¸€ä¸ª PTE_COW ä½ã€‚RISC-V ISA çš„é¡µè¡¨é¡¹æ ¼å¼ä¸­ï¼Œ8ï¼Œ9,10 ä¸‰ä½æ˜¯ RSW ä½ï¼Œç•™ç»™è½¯ä»¶è‡ªç”±ä½¿ç”¨ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨è¿™äº›ä½æ¥æ ‡è®° PTE_COWã€‚\nuvmcow() æ˜¯ COW å¯¼è‡´çš„ page fault exception çš„å¤„ç†å‡½æ•°ã€‚æˆ‘ä»¬åº”å½“åˆ†é…ä¸€ä¸ªæ–°é¡µé¢ï¼Œæ–°é¡µé¢æ²¡æœ‰ PTE_COW ä½ï¼Œæœ‰ PTE_W ä½ï¼Œå°†åŸå§‹é¡µé¢çš„å†…å®¹å¤åˆ¶è¿‡æ¥ï¼Œå¹¶ä¿®æ”¹å½“å‰è¿›ç¨‹çš„é¡µè¡¨ã€‚\nConcurrency è¯¥å®éªŒä¸­æˆ‘ä»¬è¦å¼€å§‹é¢å¯¹å¹¶å‘ bugã€‚/kernel/kalloc.c ä¸­çš„ç©ºé—²é¡µé¢é“¾è¡¨æ˜¯ç”¨ kmem.lock ä¿æŠ¤èµ·æ¥çš„ã€‚ä¸æ­¤åŒç†ï¼Œæˆ‘ä»¬ç»´æŠ¤ reference count çš„æ•°ç»„ä¹Ÿåº”è¯¥ç”¨ä¸€æŠŠé”ä¿æŠ¤èµ·æ¥ã€‚æˆ‘ä»¬å½“ç„¶å¯ä»¥ä½¿ç”¨ kmem.lockï¼Œä½†å¦‚æœæ–°å»ºä¸€æŠŠé”ä¸“é—¨ç”¨äºä¿æŠ¤ reference count æ•°ç»„ (ç”šè‡³æ˜¯æ¯ä¸ª referenct count çš„å•å…ƒæ ¼) å¯ä»¥è·å¾—æ›´å¥½çš„å¹¶è¡Œåº¦ã€‚\nConcurrency bug ä¸­å¸¸è§çš„ä¸€ç§æ˜¯ TOCTTOU (time to check to time to use)ã€‚ç¬”è€…æ›¾ç»é‡åˆ°è¿‡ xv6 åœ¨å•æ ¸æƒ…å†µä¸‹å¯ä»¥æ­£å¸¸è¿è¡Œï¼Œåœ¨å¤šæ ¸æƒ…å†µä¸‹å†…å­˜ä¸å¤Ÿç”¨çš„é—®é¢˜ã€‚ç»è¿‡æ’æŸ¥å‘ç°é—®é¢˜å‡ºåœ¨å¦‚ä¸‹ä»£ç ï¼š\nif (krref(pa) == 1) { *pte |= PTE_W; *pte \u0026amp;= (~PTE_COW); } else { if ((mem = kalloc()) == 0) return -2; flags \u0026amp;= (~PTE_COW); flags |= (PTE_W); memmove(mem, (void *)pa, PGSIZE); kmref(pa, -1); if (mappages(pagetable, va, PGSIZE, (uint64)mem, flags) != 0) return -1; } è¿™æ®µä»£ç çš„é€»è¾‘æ˜¯ï¼šå¦‚æœå½“å‰é¡µé¢åªå‰©ä¸€ä¸ª referenceï¼Œå°±ä¸å¿…å†ç”³è¯·æ–°é¡µé¢ï¼Œè€Œæ˜¯ç›´æ¥ä¿®æ”¹ä¸€ä¸‹æœ¬é¡µé¢é¡µè¡¨é¡¹çš„æ ‡å¿—ä¿¡æ¯ã€‚å¦åˆ™å½“å‰é¡µé¢æœ‰å¤šä¸ª referenceï¼Œç”³è¯·ä¸€ä¸ªæ–°é¡µé¢å¹¶è®©å½“å‰è¿›ç¨‹æŒ‡å‘å®ƒï¼Œè°ƒç”¨ kmref(pa,-1) æ›´æ–°åŸé¡µé¢çš„ reference countã€‚\nè¿™æ®µä»£ç çš„ bug åœ¨äºè¿›å…¥ else åˆ†æ”¯åï¼Œkrref(pa)\u0026gt;=2 çš„å‡è®¾ä¸ä¸€å®šæˆç«‹ã€‚å‡è®¾æœ‰ä¸¤ä¸ªè¿›ç¨‹å¹¶å‘åœ°æ‰§è¡Œè¯¥ç¨‹åºæ®µä¸” pa æœ‰ä¸”ä»…æœ‰ä¸¤ä¸ª referenceï¼Œé‚£ä¹ˆä¸¤ä¸ªè¿›ç¨‹éƒ½ä¼šé€šè¿‡ if åˆ¤æ–­è¿›å…¥ else åˆ†æ”¯ï¼Œç„¶åä½¿ç”¨ kmref() æ›´æ–° reference countï¼Œè¿™æ · pa é¡µé¢çš„ reference count å˜æˆäº† 0 ä½†æ²¡æœ‰è¿›ç¨‹å» free å®ƒï¼Œæˆ‘ä»¬ä¸¢å¤±äº†ä¸€ä¸ªé¡µé¢ã€‚è¿™ä¸ª bug è§¦å‘æ¬¡æ•°è¶Šå¤šï¼Œç³»ç»Ÿå†…å¯ç”¨çš„å†…å­˜å°±è¶Šå°‘ã€‚\næƒ³è¦ä¿®å¤è¿™ä¸ª bugï¼Œä¸€ç§é€‰æ‹©æ˜¯ç»™æ•´ä¸ª if è¯­å¥ä¸Šé”ï¼Œå¦ä¸€ç§é€‰æ‹©æ˜¯ä¸ä½¿ç”¨ if å¹¶æŠŠ kmref() æ”¹æˆ kfree() æˆ– uvmunmap()ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"f347a4d886bd40ee780cbc1319c03546","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-operating-system/labs/lab06/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-operating-system/labs/lab06/","section":"notes","summary":"Progress Implement copy-on write (hard) Implement Copy-on Write å†™æ—¶æ‹·è´ fork çš„å¤§ä½“æ€è·¯æ˜¯ï¼šåœ¨ fork æ—¶ä¸ä¸ºå­è¿›ç¨‹åˆ›å»ºæ–°çš„é¡µé¢ï¼Œè€Œæ˜¯è®©å­è¿›ç¨‹æŒ‡å‘çˆ¶è¿›ç¨‹çš„æ‰€æœ‰é¡µé¢ï¼Œå¹¶å°†é¡µé¢çš„æƒé™æ”¹ä¸ºåªè¯»ã€‚å°†æ¥å¦‚æœæŸä¸ªè¿›ç¨‹ (çˆ¶/å­) éœ€è¦ä¿®æ”¹é¡µé¢ï¼Œä¼šå‘ç”Ÿ page fault exceptionï¼Œåœ¨ kernel çš„å¤„ç†ç¨‹åºä¸­ï¼Œå¦‚æœæ˜¯ COW pageï¼Œåˆ™æ–°åˆ†é…ä¸€ä¸ªé¡µé¢ï¼Œå°†å½“å‰çš„åªè¯»é¡µé¢å†…å®¹å¤åˆ¶è¿‡å»ï¼Œè®©å½“å‰è¿›ç¨‹çš„é¡µè¡¨æŒ‡å‘è¿™ä¸ªæ–°çš„é¡µé¢å¹¶å°†æƒé™è®¾ç½®ä¸ºå¯è¯»å¯å†™ã€‚\nkalloc()/kfree() å¼•å…¥äº† copy-on write ä¹‹åï¼Œä¸€ä¸ªç‰©ç†é¡µé¢å¯èƒ½ä¼šè¢«å¤šä¸ªè¿›ç¨‹çš„é¡µè¡¨æŒ‡å‘ï¼Œè¿™ä½¿å¾— kfree() å˜å¾—å›°éš¾ï¼šæŸä¸ªè¿›ç¨‹è¢«é‡Šæ”¾æ—¶ï¼Œå®ƒæ‹¥æœ‰çš„ç‰©ç†é¡µé¢ä¸èƒ½è¢«ç›´æ¥é‡Šæ”¾ï¼Œå¦åˆ™åˆ«çš„è¿›ç¨‹å°±ç”¨ä¸äº†è¿™ä¸ªé¡µé¢äº†ã€‚æˆ‘ä»¬éœ€è¦ä¸ºæ¯ä¸ªé¡µé¢ç»´æŠ¤ä¸€ä¸ª reference countï¼Œåªæœ‰ä¸€ä¸ªé¡µé¢çš„ reference count ä¸º 0 äº†æ‰èƒ½é‡Šæ”¾å®ƒã€‚","tags":null,"title":"MIT-6.S081 Lab 06: Copy-on-write fork","type":"docs"},{"authors":null,"categories":null,"content":"Progress Eliminate allocation from sbrk() (easy) Lazy allocation (moderate) Lazytests and Usertests (moderate) Eliminate allocation from sbrk() (easy) è¯¥éƒ¨åˆ†è¦åšçš„äº‹æƒ…å¾ˆç®€å•ï¼šåœ¨ sbrk() ç³»ç»Ÿè°ƒç”¨çš„å¤„ç†å‡½æ•°ä¸­ï¼Œä¸è¦åˆ†é…å†…å­˜ï¼Œåªä¿®æ”¹è¿›ç¨‹çš„ sz å³å¯ã€‚ç”±äºæˆ‘ä»¬åªä¿®æ”¹äº† sz è€Œæ²¡æœ‰ä¸ºæ–°ç”³è¯·çš„ç©ºé—´ç»‘å®šé¡µé¢ï¼Œæ‰€ä»¥å½“ç”¨æˆ·ç¨‹åºä½¿ç”¨è¿™å—å†…å­˜çš„æ—¶å€™ (load/storeæŒ‡ä»¤)ï¼Œå°±ä¼šå› ä¸ºé¡µè¡¨æ— æ³•ç¿»è¯‘è™šæ‹Ÿåœ°å€è€ŒæŠ¥ kernel panicã€‚\nLazy allocation (moderate) åœ¨è¯¥éƒ¨åˆ†éœ€è¦åšçš„ä¿®æ”¹å’Œæ³¨æ„äº‹é¡¹åœ¨è¯¾ä¸ŠåŸºæœ¬è®²è¿‡ï¼Œå¯ä»¥å‚è€ƒ Lecture 08 çš„è¯¾å ‚ç¬”è®°ã€‚æ€»ä½“æ¥è¯´ï¼Œæˆ‘ä»¬éœ€è¦åœ¨ usertrap() ä¸­è¯†åˆ«å‡ºç¼ºé¡µå¼‚å¸¸å¹¶å†™ä¸€ä¸ªç¼ºé¡µå¼‚å¸¸çš„å¤„ç†å‡½æ•°ï¼šç”³è¯·ä¸€ä¸ªç‰©ç†é¡µé¢ï¼Œå°†å¯¼è‡´é”™è¯¯çš„è™šæ‹Ÿåœ°å€æ‰€åœ¨çš„è™šæ‹Ÿé¡µé¢æ˜ å°„è¿‡å»ã€‚æ­¤å¤–ï¼Œç”±äºå»¶è¿Ÿåˆ†é…çš„å­˜åœ¨ï¼Œæˆ‘ä»¬åœ¨ uvmunmap() æ—¶é‡Šæ”¾çš„ä¸ä¸€å®šæ˜¯å·²ç»æ˜ å°„è¿‡çš„åœ°å€ï¼Œåº”å½“å–æ¶ˆå…¶ä¸­çš„ä¸€äº› panic è¯­å¥ã€‚\nLazytests and Usertests (moderate) åœ¨è¯¥éƒ¨åˆ†æˆ‘ä»¬è¦é¢å¤–å¤„ç† sbrk() ç³»ç»Ÿè°ƒç”¨çš„ä¸€äº›ç»†èŠ‚ï¼š\nå½“ sbrk() ä¼ å…¥çš„å‚æ•°æ˜¯è´Ÿæ•°æ—¶ï¼Œæˆ‘ä»¬åº”å½“è°ƒç”¨ uvmdealloc() æ­£å¸¸è¿›è¡Œé‡Šæ”¾ã€‚uvmdealloc() é‡Šæ”¾çš„è™šæ‹Ÿé¡µé¢å¯èƒ½å·²ç»æ˜ å°„äº†ç‰©ç†é¡µé¢ï¼Œå¯èƒ½è¿˜æ²¡æœ‰æ˜ å°„ç‰©ç†é¡µé¢ã€‚æˆ‘ä»¬åœ¨ä¸Šä¸€ä¸ªéƒ¨åˆ†ä¸­å·²ç»å–æ¶ˆäº† uvmunmap() å‡½æ•°ä¸­å¯¹è¯¥å†…å®¹çš„æ£€æŸ¥ï¼Œæ‰€ä»¥æ²¡æœ‰é—®é¢˜ã€‚\nå½“ sbrk() è¿›è¡Œäº†éæ³•çš„æ“ä½œï¼Œå¦‚å¼•èµ·é”™è¯¯çš„è™šæ‹Ÿåœ°å€ä¸åœ¨å †åŒºèŒƒå›´å†…ï¼Œæˆ–è€…å†…å­˜ä¸è¶³ã€æ— æ³•åˆ†é…æ–°ç‰©ç†é¡µé¢ï¼Œåˆ™æ€æ­»å½“å‰è¿›ç¨‹ã€‚\né™¤äº†ç¼ºé¡µå¼‚å¸¸ä¸­éœ€è¦å¤„ç†å»¶è¿Ÿåˆ†é…çš„é—®é¢˜ï¼Œread() / write() ç³»ç»Ÿè°ƒç”¨ä¸­ä¹Ÿè¦å¤„ç†å»¶è¿Ÿåˆ†é…é—®é¢˜ã€‚è¯¥ç³»ç»Ÿè°ƒç”¨çš„å‡½æ•°è°ƒç”¨è·¯å¾„ (ä»¥ write() ä¸ºä¾‹) ä¸º sys_write() $\\rightarrow$ filewrite() $\\rightarrow$ writei() $\\rightarrow$ either_copyin() $\\rightarrow$ copyin() $\\rightarrow$ walkaddr()ã€‚å†…æ ¸ä¸ºäº†åœ¨å†…æ ¸ç©ºé—´å’Œç”¨æˆ·ç©ºé—´ä¹‹é—´ä¼ é€’æ•°æ®ï¼Œä¼šè°ƒç”¨ copyin()/copyout()/copyinstr()ã€‚è¿™äº›å‡½æ•°ä¼šæŠ“ç€ç”¨æˆ·è™šæ‹Ÿåœ°å€åœ¨ç”¨æˆ·é¡µè¡¨ä¸­è¿›è¡Œä¸€æ¬¡ page table walkï¼Œä»¥ç¿»è¯‘å‡ºå…¶ç‰©ç†åœ°å€ã€‚è¯¥è¿‡ç¨‹ä¸­å¯èƒ½ä¼šå› ä¸ºå»¶è¿Ÿåˆ†é…çš„é—®é¢˜ç¿»è¯‘å¤±è´¥ï¼Œæˆ‘ä»¬è¦åˆ¤æ–­è¿™ç§æƒ…å†µï¼Œå¹¶è¿›è¡Œåˆ†é…ï¼Œä»£ç ç»†èŠ‚å’Œ usertrap() ä¸­çš„éå¸¸ç±»ä¼¼ï¼Œä½†éœ€è¦æ³¨æ„çš„æ˜¯ç”±äº usertests çš„è®¾ç½®é—®é¢˜ï¼Œåœ¨ walkaddr() ä¸­é‡åˆ°éæ³•æƒ…å†µä¸èƒ½ç›´æ¥æ€æ­»è¿›ç¨‹ã€‚\n(æ³¨ï¼šäº‹å®ä¸Šï¼Œå¦‚æœå°† lab pgtbl ä¸­çš„ä»£ç æ·»åŠ è¿›æ¥ï¼Œç”¨æˆ·è¿›ç¨‹å’Œå†…æ ¸å…±ç”¨ä¸€ä»½é¡µè¡¨ï¼Œå°±å¯ä»¥ç”±ç¡¬ä»¶å®Œæˆæ‰€æœ‰çš„ page table walkï¼Œå»¶è¿Ÿåˆ†é…çš„å¤„ç†å‡½æ•°ä¹Ÿåªéœ€è¦å†™ä¸€éã€‚)\nè¯¥å®éªŒä¸­è¿˜æœ‰å¦‚ä¸‹çš„å‡ ä¸ªç»†èŠ‚ï¼š\nç¬”è€…æŸ¥é˜…äº†ä¸€äº›ç½‘ä¸Šçš„ä»£ç ï¼Œå‘ç°å®ƒä»¬å¤„ç† â€œç”¨æˆ·æ ˆåœ°å€â€ çš„æ–¹å¼å„ä¸ç›¸åŒï¼šæœ‰çš„äººä½¿ç”¨ p-\u0026gt;kernel_spï¼Œè¿™å®é™…ä¸Šæ˜¯è¿›ç¨‹çš„å†…æ ¸æ ˆçš„æ ˆé¡¶åœ°å€ã€‚æœ‰çš„äººä½¿ç”¨ p-\u0026gt;trapframe-\u0026gt;spï¼Œè¿™æ˜¯ç”¨æˆ·è¿›ç¨‹åœ¨é™·å…¥å†…æ ¸æ—¶çš„ç”¨æˆ·æ ˆæŒ‡é’ˆï¼Œç”±äºç”¨æˆ·æ ˆæ­¤æ—¶ä¸ä¸€å®šç©ºï¼Œæ‰€ä»¥ p-\u0026gt;trapframe-\u0026gt;sp å¹¶ä¸ä¸€å®šæŒ‡å‘æ ˆåº•ã€‚ä»ä¸¥è°¨çš„è§’åº¦æ¥è¯´ï¼Œè·å–æ ˆåº•åœ°å€åº”è¯¥ä½¿ç”¨ PGROUNDUP(p-\u0026gt;trapframe-\u0026gt;sp)ã€‚ç¬”è€…é‡‡ç”¨çš„å¦ä¸€ç§ç¨æ„šç¬¨ä¸€äº›çš„æ–¹æ³•ä¸ºï¼šåœ¨ proc ç»“æ„ä½“ä¸­æ–°å»ºä¸€ä¸ª ustack å˜é‡ï¼Œåœ¨ exec() ç³»ç»Ÿè°ƒç”¨ä¸­æŠŠç”¨æˆ·æ ˆåº•çš„åœ°å€ä¿å­˜åœ¨å…¶ä¸­ã€‚ è¯¥å®éªŒä¸­å¯¹äºè¾¹ç•Œæƒ…å†µçš„åˆ¤æ–­è¦æ ¼å¤–å°å¿ƒï¼Œusertest ä¸­æœ‰å¾ˆå¤šé’ˆå¯¹è¾¹ç•Œæƒ…å†µçš„æµ‹è¯•ã€‚p-\u0026gt;szï¼Œå³ program breakï¼ŒæŒ‡å‘çš„æ˜¯ç”¨æˆ·å†…å­˜é¡¶éƒ¨çš„ä¸‹ä¸€ä¸ªåœ°å€ï¼Œç¬¬ä¸€ä¸ªæœªè¢«ä½¿ç”¨çš„åœ°å€ï¼Œå› æ­¤åˆ¤æ–­åˆæ³•èŒƒå›´æ—¶ä¸€å®šæ˜¯ va \u0026lt; p-\u0026gt;szã€‚æ­¤å¤– PGROUNDUP(p-\u0026gt;trapframe-\u0026gt;sp) å¾—åˆ°çš„åœ°å€ä¸ºç”¨æˆ·æ ˆåº•åœ°å€çš„ä¸‹ä¸€ä½ï¼Œå› æ­¤ä¸‹ç•Œä¸€å®šæ˜¯ PGROUNDUP(p-\u0026gt;trapframe-\u0026gt;sp) \u0026lt;= va ã€‚(usertest ä¸­çš„ copyinstr3 æµ‹è¯•äº†å½“å‚æ•°å­—ç¬¦ä¸²çš„ç»“æŸç¬¦å¤„äºæœªåˆ†é…ç©ºé—´æ—¶ç¨‹åºæ˜¯å¦èƒ½è¿”å› -1) ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"5c2c035ff3198fd1725504385c9401b6","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-operating-system/labs/lab05/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-operating-system/labs/lab05/","section":"notes","summary":"Progress Eliminate allocation from sbrk() (easy) Lazy allocation (moderate) Lazytests and Usertests (moderate) Eliminate allocation from sbrk() (easy) è¯¥éƒ¨åˆ†è¦åšçš„äº‹æƒ…å¾ˆç®€å•ï¼šåœ¨ sbrk() ç³»ç»Ÿè°ƒç”¨çš„å¤„ç†å‡½æ•°ä¸­ï¼Œä¸è¦åˆ†é…å†…å­˜ï¼Œåªä¿®æ”¹è¿›ç¨‹çš„ sz å³å¯ã€‚ç”±äºæˆ‘ä»¬åªä¿®æ”¹äº† sz è€Œæ²¡æœ‰ä¸ºæ–°ç”³è¯·çš„ç©ºé—´ç»‘å®šé¡µé¢ï¼Œæ‰€ä»¥å½“ç”¨æˆ·ç¨‹åºä½¿ç”¨è¿™å—å†…å­˜çš„æ—¶å€™ (load/storeæŒ‡ä»¤)ï¼Œå°±ä¼šå› ä¸ºé¡µè¡¨æ— æ³•ç¿»è¯‘è™šæ‹Ÿåœ°å€è€ŒæŠ¥ kernel panicã€‚\nLazy allocation (moderate) åœ¨è¯¥éƒ¨åˆ†éœ€è¦åšçš„ä¿®æ”¹å’Œæ³¨æ„äº‹é¡¹åœ¨è¯¾ä¸ŠåŸºæœ¬è®²è¿‡ï¼Œå¯ä»¥å‚è€ƒ Lecture 08 çš„è¯¾å ‚ç¬”è®°ã€‚æ€»ä½“æ¥è¯´ï¼Œæˆ‘ä»¬éœ€è¦åœ¨ usertrap() ä¸­è¯†åˆ«å‡ºç¼ºé¡µå¼‚å¸¸å¹¶å†™ä¸€ä¸ªç¼ºé¡µå¼‚å¸¸çš„å¤„ç†å‡½æ•°ï¼šç”³è¯·ä¸€ä¸ªç‰©ç†é¡µé¢ï¼Œå°†å¯¼è‡´é”™è¯¯çš„è™šæ‹Ÿåœ°å€æ‰€åœ¨çš„è™šæ‹Ÿé¡µé¢æ˜ å°„è¿‡å»ã€‚æ­¤å¤–ï¼Œç”±äºå»¶è¿Ÿåˆ†é…çš„å­˜åœ¨ï¼Œæˆ‘ä»¬åœ¨ uvmunmap() æ—¶é‡Šæ”¾çš„ä¸ä¸€å®šæ˜¯å·²ç»æ˜ å°„è¿‡çš„åœ°å€ï¼Œåº”å½“å–æ¶ˆå…¶ä¸­çš„ä¸€äº› panic è¯­å¥ã€‚","tags":null,"title":"MIT-6.S081 Lab 05: Lazy allocation","type":"docs"},{"authors":null,"categories":null,"content":"Progress Print a page table (easy) A kernel page table per process (hard) Simplify copyin/copyinstr (hard) Print a page table (easy) åœ¨ /kernel/vm.c ä¸­æ–°å»ºä¸€ä¸ªå‡½æ•° vmprint() ç”¨äºæ‰“å°é¡µè¡¨ä¿¡æ¯ã€‚ä¸ºäº†æ–¹ä¾¿ç¼–ç ï¼Œç¬”è€…åœ¨ /kernel/vm.c ä¸­åˆå®šä¹‰äº†ä¸€ä¸ªå‡½æ•° vmprint_recursive()ï¼Œè¯¥å‡½æ•°ä¸ä»…æ¥æ”¶é¡µè¡¨åœ°å€ï¼Œè¿˜æ¥æ”¶ä¸€ä¸ª layer å‚æ•°ï¼Œç”¨äºç¡®å®šæ‰“å°ä¿¡æ¯æ—¶åœ¨å‰é¢åŠ å¤šå°‘ç»„ ..ã€‚vmprint_recursive() éå†ä¼ å…¥é¡µè¡¨çš„ 512 ä¸ªé¡µè¡¨é¡¹ï¼Œå¦‚æœé¡µè¡¨é¡¹çš„ PTE_V ä½ä¸º 1 (é¡µè¡¨å­˜åœ¨) ï¼Œåˆ™æ‰“å°é¡µè¡¨é¡¹çš„å€¼å’Œå…¶å¯¹åº”çš„ç‰©ç†åœ°å€ã€‚å¦‚æœå½“å‰é¡µè¡¨é¡¹ä¸æ˜¯åº•å±‚é¡µè¡¨é¡¹ (å¶å­èŠ‚ç‚¹)ï¼Œå°±é€’å½’åœ°ç»§ç»­æ‰“å°ã€‚æˆ‘ä»¬å¯ä»¥æ ¹æ®é¡µè¡¨é¡¹çš„æ ‡å¿—ä¿¡æ¯æ¥åˆ¤æ–­å®ƒæ˜¯ä¸æ˜¯å¶å­èŠ‚ç‚¹ï¼šå¶å­èŠ‚ç‚¹çš„é¡µè¡¨é¡¹é™¤äº† PTE_V è¿˜ä¼šæœ‰å…¶ä»–çš„ RWXU ç­‰æƒé™ä½ï¼Œè€Œå„çº§é¡µç›®å½•é¡µè¡¨é¡¹åªæœ‰ PTE_V ä¸º 1ã€‚\nExplain the output of vmprint in terms of Fig 3-4 from the text. What does page 0 contain? What is in page 2? When running in user mode, could the process read/write the memory mapped by page 1?\nç¬¬ 0 ä¸ªé¡µé¢å­˜å‚¨äº†ç”¨æˆ·çš„ä»£ç æ®µå’Œæ•°æ®æ®µï¼Œç¬¬ 2 ä¸ªé¡µé¢æ˜¯ç”¨æˆ·æ ˆã€‚åœ¨ç”¨æˆ·æ€ä¸‹ï¼Œè¿›ç¨‹ä¸èƒ½è¯»å†™ç¬¬ 1 ä¸ªé¡µé¢ï¼Œå› ä¸ºæ ¹æ®ç¬¬ä¸€ä¸ªé¡µé¢çš„é¡µè¡¨é¡¹ï¼Œå…¶ PTE_U ä½ä¸º 0ï¼Œç”¨æˆ·æ€æ— è®¿é—®æƒé™ (ç¬¬ 1 ä¸ªé¡µé¢æ˜¯ç”¨æˆ·æ ˆä¸‹æ–¹çš„ä¿æŠ¤é¡µé¢ï¼Œåœ¨åˆ›å»ºåé€šè¿‡ uvmclear() å‡½æ•°æ¸…é™¤äº† PTE_U ä½)ã€‚\nA kernel page table per process (hard) æ ¹æ® RISC-V æ¶æ„çš„çº¦å®šï¼Œpage table walk çš„å·¥ä½œç†åº”äº¤ç»™ç¡¬ä»¶å®Œæˆï¼Œé‚£ä¹ˆä¸ºä»€ä¹ˆ xv6 ä¸­è¦æœ‰ walkaddr() è¿™æ ·çš„å‡½æ•°æ¥åœ¨è½¯ä»¶å±‚é¢è¿›è¡Œ page table walkå‘¢ï¼Ÿ\nxv6 ä¸­å½“ç”¨æˆ·é™·å…¥å†…æ ¸æ€æ—¶ï¼Œsatp å¯„å­˜å™¨ä¼šåˆ‡æ¢åˆ°å†…æ ¸é¡µè¡¨ã€‚å†…æ ¸é¡µè¡¨ä¸­åªæœ‰å†…æ ¸éƒ¨åˆ†çš„æ˜ å°„ï¼Œå› æ­¤åœ¨å†…æ ¸æ€ä¸­å¦‚æœæƒ³è¦è®¿é—®ç”¨æˆ·å†…å­˜ä¸­çš„æ•°æ®ï¼Œå°±å¿…é¡»åœ¨è½¯ä»¶å±‚é¢è¿›è¡Œè™šæ‹Ÿåœ°å€çš„ç¿»è¯‘ï¼šæŠ“ç€ç”¨æˆ·é¡µè¡¨å’Œç”¨æˆ·è™šæ‹Ÿåœ°å€è°ƒç”¨ walkaddr() å‡½æ•°è·å¾—ç‰©ç†åœ°å€ï¼Œå†æ‹¿ç€ç‰©ç†åœ°å€è¿›è¡Œæ“ä½œ (å†…æ ¸é¡µè¡¨æ˜¯æ’ç­‰æ˜ å°„ï¼Œå› æ­¤è¿™ä¸ªç‰©ç†åœ°å€ä¹Ÿå¯ä»¥å½“åš \u0026ldquo;è™šæ‹Ÿåœ°å€\u0026rdquo; ä½¿ç”¨)ã€‚\nè¯¥å®éªŒéƒ¨åˆ†å’Œä¸‹ä¸€ä¸ªå®éªŒéƒ¨åˆ†çš„ç›®çš„æ˜¯ï¼šä¸ºæ¯ä¸€ä¸ªè¿›ç¨‹åˆ›å»ºä¸€ä¸ªâ€œç”¨æˆ·å†…æ ¸é¡µè¡¨â€ã€‚è¯¥é¡µè¡¨çš„å†…æ ¸éƒ¨åˆ†æ˜ å°„ä¸å†…æ ¸é¡µè¡¨ç›¸åŒï¼Œç”¨æˆ·éƒ¨åˆ†æ˜ å°„ä¸ç”¨æˆ·é¡µè¡¨ç›¸åŒã€‚è¿™æ ·ç”¨æˆ·è¿›ç¨‹ä»ç”¨æˆ·æ€é™·å…¥å†…æ ¸æ€æ—¶ï¼Œä¸å†åˆ‡æ¢åˆ°å†…æ ¸é¡µè¡¨ï¼Œè€Œæ˜¯åˆ‡æ¢åˆ°æœ¬è¿›ç¨‹çš„â€œç”¨æˆ·å†…æ ¸é¡µè¡¨â€ï¼Œè¿™æ ·åœ¨å†…æ ¸ä¸­æ‰§è¡Œæ“ä½œæ—¶ï¼Œé¡µè¡¨ä¸­åŒ…å«ç”¨æˆ·éƒ¨åˆ†çš„æ˜ å°„ï¼Œç”¨æˆ·éƒ¨åˆ†è™šæ‹Ÿåœ°å€çš„ç¿»è¯‘å°±å¯ä»¥äº¤ç»™ç¡¬ä»¶åšäº†ã€‚\nè¯¥å®éªŒéƒ¨åˆ†ä¸»è¦è´Ÿè´£å®Œæˆç”¨æˆ·å†…æ ¸é¡µè¡¨çš„å†…æ ¸éƒ¨åˆ†çš„æ˜ å°„ã€‚æ ¹æ®æç¤ºå†…å®¹ï¼Œ\nAdd a field to struct proc for the process\u0026rsquo;s kernel page table.\nåœ¨ struct proc ä¸­æ·»åŠ ä¸€ä¸ª pagetable_t ç±»å‹çš„å˜é‡ k_pagetable æ¥å­˜å‚¨ç”¨æˆ·å†…æ ¸é¡µè¡¨ã€‚\nA reasonable way to produce a kernel page table for a new process is to implement a modified version of kvminit that makes a new page table instead of modifying kernel_pagetable. You\u0026rsquo;ll want to call this function from allocproc.\nç¬”è€…èµ·åˆè®¤ä¸ºï¼šä¸ºä»€ä¹ˆä¸è®©æ¯ä¸ªè¿›ç¨‹çš„ k_pagetable ç›´æ¥æŒ‡å‘ kernel_pagetable å‘¢ï¼Ÿè¿™æ ·å°±çœå»äº†ä¸ºæ¯ä¸ªè¿›ç¨‹åšæ˜ å°„çš„å·¥ä½œï¼Ÿå¦‚æœç†è§£äº†æ•´ä¸ªå®éªŒçš„ç›®çš„ï¼Œæˆ‘ä»¬å°±ä¼šæ˜ç™½è¿™æ˜¯ä¸åˆç†çš„ã€‚æˆ‘ä»¬çš„ç›®çš„ä¸ä»…æ˜¯å®Œæˆå†…æ ¸æ˜ å°„ï¼Œè¿˜è¦è®©è¿™ä»½é¡µè¡¨åŒæ—¶æ‹¥æœ‰è¯¥è¿›ç¨‹çš„ç”¨æˆ·æ˜ å°„ï¼Œå†…æ ¸ä¸­çš„åŸå§‹ä»½å†…æ ¸é¡µè¡¨æ— æ³•å°†å„ä¸ªè¿›ç¨‹çš„ç”¨æˆ·æ˜ å°„éƒ½å­˜ä¸‹æ¥ (å½¼æ­¤å†²çª)ã€‚è¿™æ ·åšä¹Ÿè®¸å¯ä»¥é€šè¿‡è¿™ä¸ªå®éªŒéƒ¨åˆ†ï¼Œä½†å°†åœ¨ä¸‹ä¸€ä¸ªå®éªŒéƒ¨åˆ†èµ°å…¥æ­»èƒ¡åŒã€‚\næ­£ç¡®çš„åšæ³•æ˜¯ä»¿ç…§ kvminit() å‡½æ•°å†™ä¸€ä»½åˆå§‹åŒ–æ˜ å°„ï¼Œå°†é¡µè¡¨åŸºåœ°å€ä¿å­˜åœ¨ p-\u0026gt;k_pagetable ä¸­ã€‚allocproc() å‡½æ•°åœ¨ userinit() å’Œ fork() ä¸­è¢«è°ƒç”¨ï¼Œè´Ÿè´£åˆ›å»ºä¸€ä¸ªæ–°è¿›ç¨‹ã€‚æˆ‘ä»¬åœ¨ allocproc() ä¸­è°ƒç”¨ç”¨æˆ·å†…æ ¸é¡µè¡¨çš„åˆå§‹åŒ–æ˜ å°„å‡½æ•°å³å¯ã€‚\nMake sure that each process\u0026rsquo;s kernel page table has a mapping for that process\u0026rsquo;s kernel stack. In unmodified xv6, all the kernel stacks are set up in procinit. You will need to move some or all of this functionality to allocproc.\nç¬”è€…æ²¡æœ‰åŠ¨ procinit() çš„ä»£ç ï¼Œå³å†…æ ¸é¡µè¡¨ä¸­æœ‰æ‰€æœ‰è¿›ç¨‹å†…æ ¸æ ˆçš„æ˜ å°„ï¼Œå¹¶å‡†å¤‡åœ¨æ¯ä¸ªè¿›ç¨‹çš„ç”¨æˆ·å†…æ ¸é¡µè¡¨ä¸­æ˜ å°„è‡ªå·±è¿›ç¨‹çš„å†…æ ¸æ ˆåœ°å€ã€‚è¿™é‡Œç¬”è€…çŠ¯çš„é”™è¯¯æ˜¯ï¼šåœ¨ allocproc() ä¸­åˆ kalloc() äº†ä¸€ä¸ªæ–°çš„é¡µé¢ä½œä¸ºç”¨æˆ·æ ˆã€‚è¿™æ ·ç”¨æˆ·å†…æ ¸é¡µè¡¨ä¸­çš„ç”¨æˆ·æ ˆå’Œå†…æ ¸é¡µè¡¨ä¸­çš„ç”¨æˆ·æ ˆå®é™…ä¸ŠæŒ‡å‘äº†ä¸åŒçš„ç‰©ç†é¡µé¢å®ä½“ã€‚æˆ‘ä»¬è¦æ—¶åˆ»è®°ä½ç”¨æˆ·å†…æ ¸é¡µè¡¨åªåº”è¯¥å¤åˆ¶æ˜ å°„ï¼Œæ˜ å°„åº”è¯¥æŒ‡å‘ç›¸åŒçš„å®ä½“ï¼Œè¿™æ ·é™·å…¥å†…æ ¸æ€ä¹‹åæ‰èƒ½çœ‹åˆ°é¡µé¢ä¸­çš„æ”¹å˜ã€‚\nModify scheduler() to load the process\u0026rsquo;s kernel page table into the core\u0026rsquo;s satp register (see kvminithart for inspiration). Don\u0026rsquo;t forget to call sfence_vma() after calling w_satp().\nscheduler() should use kernel_pagetable when no process is running.\nè¿™æ˜¯ç¬”è€…æ„Ÿåˆ°è¿·èŒ«çš„éƒ¨åˆ†ï¼Œå› ä¸ºæ ¹æ®è¯¾ç¨‹ schedule çš„è¿›åº¦ï¼Œåšè¯¥å®éªŒæ—¶ç†åº”è¿˜æ²¡æœ‰çœ‹ä¸­æ–­éƒ¨åˆ†çš„å†…å®¹ï¼Œæ‰€ä»¥ç¬”è€…å¯¹ scheduler() å‡½æ•°çš„æ„ä¹‰å¾ˆä¸äº†è§£ã€‚ç»è¿‡å¤§è‡´çš„æ‘¸ç´¢ï¼Œæ ¸å¿ƒå¾ªç¯\nfor(p = proc; p \u0026lt; \u0026amp;proc[NPROC]; p++) { acquire(\u0026amp;p-\u0026gt;lock); if(p-\u0026gt;state == RUNNABLE) { // Switch to chosen process. It is the process's job // to release its lock and then reacquire it // before jumping back to us. p-\u0026gt;state = RUNNING; c-\u0026gt;proc = p; swtch(\u0026amp;c-\u0026gt;context, \u0026amp;p-\u0026gt;context); // Process is done running for now. // It should have changed its p-\u0026gt;state before coming back. c-\u0026gt;proc = 0; found = 1; } release(\u0026amp;p-\u0026gt;lock); } è´Ÿè´£æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤„äº RUNNABLE çŠ¶æ€çš„è¿›ç¨‹ï¼Œç„¶åå°†å…¶çŠ¶æ€è®¾ç½®ä¸º RUNNINGï¼Œå¹¶é€šè¿‡ swtch() å‡½æ•°åˆ‡æ¢è¿‡å»ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ‰§è¡Œå®Œ swtch ä¹‹åï¼Œxv6 å°±ä¼šè½¬å»æ‰§è¡Œè¿›ç¨‹ p (æ­¤æ—¶ä»ç„¶åœ¨å†…æ ¸æ€ä¸­)ï¼Œå› æ­¤åº”è¯¥åœ¨ swtch() ä¹‹å‰å°† satp å¯„å­˜å™¨æ”¹å†™ä¸º p è¿›ç¨‹çš„ç”¨æˆ·å†…æ ¸é¡µè¡¨ã€‚\nä¸€ä¸ªè¿›ç¨‹è¿è¡Œå®Œæ¯•åï¼Œä¼šè¿”å›åˆ° swtch çš„ä¸‹ä¸€æ¡è¯­å¥æ‰§è¡Œï¼Œè¿™æ—¶å€™ CPU æ ¸å¤„äºæ²¡æœ‰è¿›ç¨‹è¿è¡Œçš„çŠ¶æ€ã€‚å› æ­¤åº”è¯¥åœ¨ swtch() ä¹‹åè°ƒç”¨ kvminithart() å‡½æ•°å°† satp å¯„å­˜å™¨æ”¹å†™ä¸ºå†…æ ¸é¡µè¡¨ã€‚\nFree a process\u0026rsquo;s kernel page table in freeproc.\nYou\u0026rsquo;ll need a way to free a page table without also freeing the leaf physical memory pages.\nfreeproc() å‡½æ•°è´Ÿè´£è¿›ç¨‹çš„é‡Šæ”¾ã€‚å…¶ä¸­ proc_freepagetable() å‡½æ•°è´Ÿè´£å°†è¯¥è¿›ç¨‹çš„ç”¨æˆ·é¡µè¡¨é‡Šæ”¾ã€‚æˆ‘ä»¬éœ€è¦å†å†™ä¸€ä¸ªå‡½æ•°å°†ç”¨æˆ·å†…æ ¸é¡µè¡¨ä¹Ÿé‡Šæ”¾ã€‚æ³¨æ„ç”¨æˆ·å†…æ ¸é¡µè¡¨çš„å®ä½“æ˜¯é‚£äº›å†…æ ¸ç‰©ç†é¡µé¢å’Œè¯¥è¿›ç¨‹çš„ç”¨æˆ·ç‰©ç†é¡µé¢ã€‚è¯¥è¿›ç¨‹çš„ç”¨æˆ·ç‰©ç†é¡µé¢å·²ç»éšç€ç”¨æˆ·é¡µè¡¨çš„é‡Šæ”¾è€Œé‡Šæ”¾äº†ï¼Œè€Œå†…æ ¸ç‰©ç†é¡µé¢ä¸èƒ½è¢«é‡Šæ”¾ï¼Œå¦åˆ™å†…æ ¸ä»£ç å°±æ¶ˆå¤±äº†ã€‚å› æ­¤æˆ‘ä»¬ä¸èƒ½ç›´æ¥è°ƒç”¨ proc_freepagetable()ï¼Œè€Œè¦å†å†™ä¸€ä¸ª proc_freekpagetable()ã€‚\næ­¤å¤–ï¼Œproc_freepagetable() ä¸­è°ƒç”¨çš„ freewalk() å‡½æ•°è´Ÿè´£é€’å½’åœ°é‡Šæ”¾æ‰€æœ‰çš„é¡µè¡¨é¡µé¢ï¼Œè¯¥å‡½æ•°é»˜è®¤åº•å±‚çš„ç‰©ç†é¡µé¢å·²ç»è¢«é‡Šæ”¾ï¼Œå¦‚æœä¸ç¬¦åˆè¦æ±‚ä¼šè§¦å‘ kernel panicã€‚ä½†åœ¨ç”¨æˆ·å†…æ ¸é¡µè¡¨é¡µé¢çš„é‡Šæ”¾è¿‡ç¨‹ä¸­åº•å±‚çš„ (å†…æ ¸) ç‰©ç†é¡µé¢æ˜¯æ²¡æœ‰è¢«é‡Šæ”¾çš„ï¼Œå› æ­¤ä¸èƒ½ç›´æ¥è°ƒç”¨ freewalk() å‡½æ•°ï¼Œè€Œè¦ä»¿ç…§å®ƒå†å†™ä¸€ä¸ªä¸ä¼šå¯¹åº•å±‚ç‰©ç†é¡µé¢å­˜åœ¨æŠ¥é”™çš„ kfreewalk()ã€‚\nSimplify copyin/copyinstr (hard) è¯¥å®éªŒéƒ¨åˆ†æ‰¿æ¥ä¸Šä¸€ä¸ªå®éªŒéƒ¨åˆ†ï¼Œè¦è¡¥å…¨ç”¨æˆ·å†…æ ¸é¡µè¡¨çš„ç”¨æˆ·éƒ¨åˆ†çš„æ˜ å°„ã€‚æˆ‘ä»¬åªè¦åšåˆ° xv6 ä¸­ä»»ä½•å¯¹ç”¨æˆ·é¡µè¡¨æœ‰ä¿®æ”¹çš„åœ°æ–¹ï¼Œæˆ‘ä»¬åœ¨ç”¨æˆ·å†…æ ¸é¡µè¡¨ä¸­å°†è¿™äº›ä¿®æ”¹çš„æ˜ å°„æŠ„ä¸€ä»½å³å¯ã€‚è¿™é‡ŒåŠ¡å¿…è¦æ³¨æ„çš„ä¸€ç‚¹æ˜¯ï¼šç”¨æˆ·é¡µè¡¨ä¸­ä¼šç”³è¯·æ–°çš„ç‰©ç†é¡µé¢ï¼Œä½†æˆ‘ä»¬ä¸åº”è¯¥åœ¨ç”¨æˆ·å†…æ ¸é¡µè¡¨ä¸­ä¹Ÿç”³è¯·æ–°çš„é¡µé¢ï¼Œè€Œæ˜¯åº”è¯¥æ˜ å°„åˆ°ç”¨æˆ·é¡µè¡¨ç”³è¯·çš„ç‰©ç†é¡µé¢ã€‚åªæœ‰è¿™æ ·æˆ‘ä»¬æ‰èƒ½åœ¨é™·å…¥å†…æ ¸æ€æ—¶è®¿é—®åˆ°ç”¨æˆ·æ€æ—¶ä¿å­˜çš„æ•°æ®ã€‚\nxv6 æ¶‰åŠç”¨æˆ·é¡µè¡¨ä¿®æ”¹çš„æœ‰ä¸‰å¤„ï¼šfork()ï¼Œexec()ï¼Œå’Œ growproc()ã€‚\nfork() å‡½æ•°ä¼šç”³è¯·ä¸€ä¸ªæ–°çš„è¿›ç¨‹ï¼Œè°ƒç”¨ uvmcopy() å‡½æ•°å°†çˆ¶è¿›ç¨‹çš„ç”¨æˆ·é¡µè¡¨å¤åˆ¶ç»™å­è¿›ç¨‹çš„ç”¨æˆ·é¡µè¡¨ã€‚æ³¨æ„ï¼šæˆ‘ä»¬ä¸èƒ½è°ƒç”¨ uvmcopy() æ¥å°†çˆ¶è¿›ç¨‹çš„ç”¨æˆ·é¡µè¡¨å†…å®¹å¤åˆ¶åˆ°å­è¿›ç¨‹çš„ç”¨æˆ·å†…æ ¸é¡µè¡¨ã€‚å› ä¸ºçˆ¶è¿›ç¨‹å’Œå­è¿›ç¨‹äº’ç›¸ç‹¬ç«‹ï¼Œæ‰€ä»¥ uvmcopy() åœ¨å¤åˆ¶çš„æ—¶å€™ä¸ä»…å¤åˆ¶é¡µè¡¨å†…å®¹ï¼Œæ‰€æœ‰åº•å±‚çš„ç‰©ç†é¡µé¢ä¹Ÿç”³è¯·äº†æ–°çš„å¹¶å¤åˆ¶äº†ä¸€é (åœ¨ copy-on-write fork ä¸­è¿™ä¸€ç‚¹ä¼šå¾—åˆ°æ”¹å–„)ã€‚æˆ‘ä»¬çš„ç”¨æˆ·å†…æ ¸é¡µè¡¨æ˜¯ä¸åº”è¯¥å°†åº•å±‚ç‰©ç†é¡µé¢å¤åˆ¶çš„ã€‚å­è¿›ç¨‹çš„ç”¨æˆ·å†…æ ¸é¡µè¡¨ä¸€å®šè¦æŠ„å­è¿›ç¨‹çš„ç”¨æˆ·é¡µè¡¨ï¼Œæ˜ å°„åˆ°å­è¿›ç¨‹çš„ç”¨æˆ·é¡µè¡¨çš„ç‰©ç†é¡µé¢ä¸Šã€‚\nexec() å‡½æ•°æ ¹æ® ELF æ–‡ä»¶åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„å†…å­˜é•œåƒï¼Œå¹¶ç”¨æ–°çš„é¡µè¡¨æ›¿æ¢æ—§çš„é¡µè¡¨ã€‚åœ¨ç”¨æˆ·è¿›ç¨‹é¡µè¡¨ä¸­æˆ‘ä»¬ä¹Ÿåº”è¯¥è¿›è¡Œç›¸å¯¹åº”çš„æ›´æ–°ï¼šé¦–å…ˆå°†æ—§é¡µè¡¨ç›¸å…³çš„æ˜ å°„åˆ é™¤ (è¿™é‡Œéœ€è¦æ ¼å¤–å°å¿ƒçš„ä¸€ç‚¹æ˜¯ï¼šexec() è°ƒç”¨ proc_freepagetable() é‡Šæ”¾æ—§é¡µè¡¨æ—¶ï¼Œå·²ç»å°†æ—§é¡µè¡¨çš„åº•å±‚ç‰©ç†é¡µé¢ä¸€å¹¶é‡Šæ”¾äº†ï¼Œæˆ‘ä»¬åœ¨åˆ é™¤ç”¨æˆ·å†…æ ¸é¡µè¡¨ä¸­çš„æ—§é¡µè¡¨å†…å®¹æ—¶ï¼Œä¸éœ€è¦å†é‡Šæ”¾ä¸€éåº•å±‚ç‰©ç†é¡µé¢ï¼Œåªéœ€è¦æ¸…é™¤ç›¸å…³çš„é¡µè¡¨é¡¹å³å¯ã€‚)ï¼Œç„¶åå°†æ–°é¡µè¡¨çš„æ˜ å°„æŠ„è¿›ç”¨æˆ·å†…æ ¸é¡µè¡¨ã€‚\ngrowproc() å‡½æ•°æ ¹æ® n çš„æ­£è´Ÿåˆ†åˆ«è°ƒç”¨ uvmalloc() å’Œ uvmdealloc() æ¥è°ƒæ•´ç”¨æˆ·å†…å­˜çš„å¤§å°ã€‚æˆ‘ä»¬åœ¨ç”¨æˆ·å†…æ ¸é¡µè¡¨ä¸­ä¹Ÿåº”è¯¥è¿›è¡Œç›¸å¯¹åº”çš„æ›´æ–°ã€‚å¯¹äº uvmalloc() æ¥è¯´ï¼Œè¦æ³¨æ„ç”¨æˆ·å†…æ ¸é¡µè¡¨è¦æ˜ å°„åˆ°ç”¨æˆ·é¡µè¡¨åˆ›å»ºçš„é‚£äº›ç‰©ç†é¡µé¢ä¸­ï¼Œä¸ºæ­¤ç¬”è€…å†™äº†ä¸€ä¸ªç±»ä¼¼äº uvmcopy() çš„å‡½æ•°æ¥è¿›è¡Œå¤åˆ¶ã€‚å¯¹äº uvmdealloc() æ¥è¯´ï¼Œè¦æ³¨æ„ç”¨æˆ·é¡µè¡¨è´Ÿè´£é‡Šæ”¾åº•å±‚ç‰©ç†é¡µé¢ï¼Œç”¨æˆ·å†…æ ¸é¡µè¡¨ä¸èƒ½åšé‡å¤çš„äº‹ã€‚\n(æ³¨ï¼šå†…æ ¸éƒ¨åˆ†æ˜ å°„å’Œç”¨æˆ·éƒ¨åˆ†æ˜ å°„å¯ä»¥åˆäºŒä¸ºä¸€çš„é‡è¦å‰ç½®æ¡ä»¶æ˜¯ä¸¤è€…æ²¡æœ‰é‡å¤çš„æ˜ å°„ã€‚æ ¹æ® xv6 æ‰‹å†Œï¼Œä½äº 0x80000000 çš„å¾ˆå¤šéƒ¨åˆ†çš„å†…å­˜æ˜¯ä½œä¸ºå¤–è®¾åœ°å€çš„ã€‚å› æ­¤ç”¨æˆ·å®é™…å¯ç”¨çš„å†…å­˜ç©ºé—´å…¶å®è¿œå°äº MAXVAã€‚å¼æ ·è®²ä¹‰è§„å®šç”¨æˆ·åªèƒ½ä½¿ç”¨ PLIC ä»¥ä¸‹çš„åœ°å€ã€‚ä½†äº‹å®ä¸Š CLINT æ˜ å°„çš„åœ°å€æ¯” PLIC è¿˜è¦ä½ï¼Œå®éªŒè¯æ˜å¦‚æœä¸å–æ¶ˆ CLINT çš„æ˜ å°„ï¼Œç”¨æˆ·å†…å­˜ä¼šè¦†ç›–åˆ°è¿™éƒ¨åˆ†ï¼Œè§¦å‘ \u0026lsquo;remap\u0026rsquo; kernel panicã€‚å› æ­¤ç¬”è€…åªèƒ½åœ¨ç”¨æˆ·å†…æ ¸é¡µè¡¨çš„æ˜ å°„ä¸­å°† CLINT ç§»é™¤ã€‚)\nWhat permissions do the PTEs for user addresses need in a process\u0026rsquo;s kernel page table? (A page with PTE_U set cannot be accessed in kernel mode.)\nç”¨æˆ·å†…æ ¸é¡µè¡¨çš„é¡µè¡¨é¡¹ä¸èƒ½ç…§æŠ„ç”¨æˆ·é¡µè¡¨ï¼Œå› ä¸º QEMU æ¨¡æ‹Ÿçš„ RISC-V ç¡¬ä»¶åœ¨å†…æ ¸æ€ä¸‹æ˜¯ä¸èƒ½è®¿é—®å¸¦æœ‰ PTE_U ä½çš„é¡µé¢çš„ã€‚å› æ­¤ç”¨æˆ·å†…æ ¸é¡µè¡¨çš„åº•å±‚é¡µè¡¨é¡¹éƒ½è¦å°† PTE_U æŒ–å»ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"0674a379007869bec887a4df9cefc548","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-operating-system/labs/lab03/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-operating-system/labs/lab03/","section":"notes","summary":"Progress Print a page table (easy) A kernel page table per process (hard) Simplify copyin/copyinstr (hard) Print a page table (easy) åœ¨ /kernel/vm.c ä¸­æ–°å»ºä¸€ä¸ªå‡½æ•° vmprint() ç”¨äºæ‰“å°é¡µè¡¨ä¿¡æ¯ã€‚ä¸ºäº†æ–¹ä¾¿ç¼–ç ï¼Œç¬”è€…åœ¨ /kernel/vm.c ä¸­åˆå®šä¹‰äº†ä¸€ä¸ªå‡½æ•° vmprint_recursive()ï¼Œè¯¥å‡½æ•°ä¸ä»…æ¥æ”¶é¡µè¡¨åœ°å€ï¼Œè¿˜æ¥æ”¶ä¸€ä¸ª layer å‚æ•°ï¼Œç”¨äºç¡®å®šæ‰“å°ä¿¡æ¯æ—¶åœ¨å‰é¢åŠ å¤šå°‘ç»„ .","tags":null,"title":"MIT-6.S081 Lab 03: Page tables","type":"docs"},{"authors":null,"categories":null,"content":"Progress System call tracing (moderate) Sysinfo (moderate) System call tracing (moderate) è¯¥å®éªŒå¯ä»¥å¯¹ xv6 ä¸­ç³»ç»Ÿè°ƒç”¨çš„è¿‡ç¨‹æœ‰ä¸€ä¸ªå¤§è‡´çš„äº†è§£ã€‚\nåœ¨ /user/trace.c ä¸­ï¼Œç¨‹åºè§£æäº† trace() åçš„æ‰€æœ‰ï¼Œå°† trace ä¹‹åçš„é‚£ä¸€ä¸ªæ•°å­—ä½œä¸º trace çš„å‚æ•°ï¼Œå‰©ä¸‹çš„ä½œä¸ºå¦å¤–çš„ä¸€æ¡å‘½ä»¤è°ƒç”¨ exec()ã€‚\ntrace() å‡½æ•°æ˜¯ç”¨ assembly å†™çš„ï¼Œç”± /user/usys.pl ç”Ÿæˆã€‚/user/usys.pl æ˜¯ä¸€ä¸ªè„šæœ¬ï¼Œå†…å®¹å¦‚ä¸‹ï¼š\n#!/usr/bin/perl -w # Generate usys.S, the stubs for syscalls. print \u0026quot;# generated by usys.pl - do not edit\\n\u0026quot;; print \u0026quot;#include \\\u0026quot;kernel/syscall.h\\\u0026quot;\\n\u0026quot;; sub entry { my $name = shift; print \u0026quot;.global $name\\n\u0026quot;; print \u0026quot;${name}:\\n\u0026quot;; print \u0026quot; li a7, SYS_${name}\\n\u0026quot;; print \u0026quot; ecall\\n\u0026quot;; print \u0026quot; ret\\n\u0026quot;; } entry(\u0026quot;fork\u0026quot;); entry(\u0026quot;exit\u0026quot;); ... å¯¹äºæ¯ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œå®ƒä¼šç”Ÿæˆä¸€ä¸ªå‡½æ•°ï¼Œå°†ç³»ç»Ÿè°ƒç”¨å· SYS_name æ”¾åˆ° a7 å¯„å­˜å™¨ä¸­ï¼Œç„¶åä½¿ç”¨ ecall é™·å…¥å†…æ ¸ã€‚æ ¹æ® calling conventionï¼Œå‰©ä¸‹çš„ç³»ç»Ÿè°ƒç”¨å‚æ•°æ”¾åœ¨ a0 a1 â€¦â€¦ å¯„å­˜å™¨ä¸­ï¼Œå› ä¸ºå’Œ trace.c ä¸­å‡†å¤‡å‚æ•°çš„è¿‡ç¨‹ç›¸åŒï¼Œæ‰€ä»¥ä¸éœ€è¦é¢å¤–å†åšä¸€æ¬¡å‚æ•°å‡†å¤‡ã€‚\nç¡¬ä»¶æå‡å®Œç‰¹æƒçº§åï¼Œæ ¹æ® stvec å¯„å­˜å™¨çš„å€¼è¿›è¡Œåœ°å€è·³è½¬ï¼Œstvec å†…ä¿å­˜çš„åœ°å€æ˜¯ /kernel/trampoline.S ä¸­çš„ uservecã€‚uservec æ˜¯ç”¨ assembly å†™çš„ï¼Œä¿å­˜äº†ä¸Šä¸‹æ–‡ï¼Œå¹¶è·³è½¬åˆ° /kernel/trap.c ä¸­çš„å‡½æ•° usertrapã€‚usertrap æ ¹æ® scause å¯„å­˜å™¨çš„å€¼ï¼Œè®¤å®šè¿™æ˜¯ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œäºæ˜¯è½¬åˆ° /kernel/syscall.c ä¸­çš„å‡½æ•° syscallã€‚\nsyscall æ ¹æ® a7 å¯„å­˜å™¨çš„å€¼è·å–ç³»ç»Ÿè°ƒç”¨å·ï¼Œå¹¶æ‰§è¡Œç›¸åº”çš„ç³»ç»Ÿè°ƒç”¨æœåŠ¡ç¨‹åºï¼ˆæ‰€æœ‰çš„æœåŠ¡ç¨‹åºéƒ½å­˜åœ¨ syscalls[] æ•°ç»„ä¸­ï¼‰ã€‚\nå¯¹äº trace() ç³»ç»Ÿè°ƒç”¨æ¥è¯´ï¼Œæˆ‘ä»¬éœ€è¦æ³¨å†Œä¸€ä¸ªå‡½æ•° sys_trace() ã€‚xv6 æä¾›äº†ä¸€ç³»åˆ—å‡½æ•°æ¥è·å–ç³»ç»Ÿè°ƒç”¨çš„å‚æ•°ï¼ˆæœ¬è´¨ä¸Šæ˜¯æ ¹æ® calling convention æå–å¯„å­˜å™¨çš„å€¼ï¼‰ï¼Œargint() ç”¨äºè·å–å€¼ï¼Œargaddr() ç”¨äºè·å–åœ°å€ï¼Œargstr() ç”¨äºè·å–å­—ç¬¦ä¸²ï¼ˆæœ¬è´¨ä¸Šæ˜¯å¯¹å¯„å­˜å™¨çš„å€¼è¿›è¡Œäº†ä¸åŒçš„ç±»å‹è§£é‡Šï¼‰ã€‚æˆ‘ä»¬éœ€è¦åœ¨ proc ç»“æ„ä½“ä¸­æ–°å®šä¹‰ä¸€ä¸ªå˜é‡æ¥å­˜å‚¨ trace maskï¼Œå°†å‚æ•°å–å‡ºæ”¾è¿›è¿™ä¸ªå˜é‡å³å¯ã€‚\næ­¤å¤–ï¼Œåœ¨ syscall ä¸­ï¼Œæ¯æ‰§è¡Œå®Œä¸€ä¸ªç³»ç»Ÿè°ƒç”¨å‡†å¤‡è¿”å›æ—¶ï¼Œæˆ‘ä»¬è¦æ ¹æ® trace mask å†³å®šæ˜¯å¦å°†å…¶ç›¸å…³çš„ä¿¡æ¯æ‰“å°ã€‚æˆ‘ä»¬éœ€è¦é¢å¤–å‡†å¤‡ä¸€ä¸ªæ•°ç»„å­˜å‚¨æ‰€æœ‰ç³»ç»Ÿè°ƒç”¨çš„åå­—ï¼Œè¿›ç¨‹å·å¯ä»¥é€šè¿‡ p-\u0026gt;pid è·å¾—ã€‚\næ ¹æ®è®²ä¹‰çš„å®šä¹‰ï¼Œçˆ¶è¿›ç¨‹ fork å‡ºçš„å­è¿›ç¨‹è¦ç»§æ‰¿ trace maskï¼Œå› æ­¤éœ€è¦ä¿®æ”¹ä¸€ä¸‹ fork å‡½æ•°çš„ä»£ç ï¼Œå°† p-\u0026gt;tMask å¤åˆ¶ç»™ np-\u0026gt;tMask å³å¯ã€‚\nSysinfo (moderate) è¯¥å®éªŒä¸ä¸Šä¸€ä¸ªå®éªŒçš„ä¸»è¦ä¸åŒåœ¨äºï¼š\nsysinfo(struct sysinfo *) ç³»ç»Ÿè°ƒç”¨éœ€è¦å°†ä¿¡æ¯å†™å›åˆ° user space çš„ç»“æ„ä½“ä¸­ï¼Œå› æ­¤éœ€è¦ä» kernel space å‘ user space å¤åˆ¶ä¿¡æ¯ï¼Œå¯ä»¥å‚è€ƒ fstat() ç³»ç»Ÿè°ƒç”¨çš„å®ç°æ¥è¿ç”¨ copyout() å‡½æ•°ï¼Œç”±äºç›®å‰è¿˜æœªå®ç°è™šæ‹Ÿå­˜å‚¨ç›¸å…³ç»†èŠ‚ï¼Œæ•…ä¸æ·±ç©¶ copyout() çš„å…·ä½“åŸç†ã€‚\nå½“å‰è¿›ç¨‹çš„ä¸ªæ•°å¾ˆå¥½ç»Ÿè®¡ï¼Œè¿›ç¨‹ä¿¡æ¯ä¿å­˜åœ¨ /kernel/proc.c çš„ proc[] æ•°ç»„é‡Œï¼Œproc[] æ•°ç»„çš„æ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ª proc ç»“æ„ä½“ï¼Œåªè¦ç»“æ„ä½“çš„ state å˜é‡ä¸æ˜¯ UNUSED å°±æ˜¯ä¸€ä¸ªå½“å‰çš„è¿›ç¨‹ã€‚\nå½“å‰å‰©ä½™çš„å†…å­˜ç»Ÿè®¡ç¨ä¸ºå¤æ‚ã€‚xv6 å®ç°äº†åˆ†é¡µæœºåˆ¶ï¼Œ/kernel/kalloc.c è´Ÿè´£ç‰©ç†å†…å­˜çš„åˆ†é…å’Œé‡Šæ”¾ã€‚å…·ä½“çš„ç»„ç»‡å½¢å¼å’Œå„ä¸ªå‡½æ•°çš„æ„ä¹‰è§ Xv6 æºç è§£è¯»æ‰‹å†Œã€‚\nè¦å®ç°å‰©ä½™å†…å­˜çš„ç»Ÿè®¡ï¼Œæˆ‘ä»¬åªè¦æ•°ä¸€æ•° freelist é“¾è¡¨ä¸­æœ‰å¤šå°‘ä¸ªé¡µé¢å³å¯ã€‚å¯ä»¥æ¯æ¬¡ç°åœºæ•°ä¸€éï¼Œä¹Ÿå¯ä»¥ç»´æŠ¤ä¸€ä¸ªå˜é‡ï¼Œåœ¨ kalloc() å’Œ kfree() çš„æ—¶å€™åŠ¨æ€ç»Ÿè®¡ç©ºé—²é¡µé¢çš„ä¸ªæ•°ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"a6b7f8e440123ba78e40a6fcf8bbb616","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-operating-system/labs/lab02/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-operating-system/labs/lab02/","section":"notes","summary":"Progress System call tracing (moderate) Sysinfo (moderate) System call tracing (moderate) è¯¥å®éªŒå¯ä»¥å¯¹ xv6 ä¸­ç³»ç»Ÿè°ƒç”¨çš„è¿‡ç¨‹æœ‰ä¸€ä¸ªå¤§è‡´çš„äº†è§£ã€‚\nåœ¨ /user/trace.c ä¸­ï¼Œç¨‹åºè§£æäº† trace() åçš„æ‰€æœ‰ï¼Œå°† trace ä¹‹åçš„é‚£ä¸€ä¸ªæ•°å­—ä½œä¸º trace çš„å‚æ•°ï¼Œå‰©ä¸‹çš„ä½œä¸ºå¦å¤–çš„ä¸€æ¡å‘½ä»¤è°ƒç”¨ exec()ã€‚\ntrace() å‡½æ•°æ˜¯ç”¨ assembly å†™çš„ï¼Œç”± /user/usys.pl ç”Ÿæˆã€‚/user/usys.pl æ˜¯ä¸€ä¸ªè„šæœ¬ï¼Œå†…å®¹å¦‚ä¸‹ï¼š","tags":null,"title":"MIT-6.S081 Lab 02: System calls","type":"docs"},{"authors":null,"categories":null,"content":"Progress Uthread: switching between threads (moderate) Using threads (moderate) Barrier (moderate) Uthread: Switching Between Threads (moderate) è¯¥å®éªŒè¦å®ç°ä¸€ä¸ªâ€œç”¨æˆ·æ€åç¨‹åº“â€ï¼Œæ¯ä¸ªåç¨‹é€šè¿‡ yield() å‡½æ•°ä¸»åŠ¨è®©å‡º CPU æ¥è®©å…¶ä»–åç¨‹è¿è¡Œã€‚ç¬”è€…å®šä¹‰äº†å¦‚ä¸‹çš„ç»“æ„ä½“ï¼š\nstruct thread { char stack[STACK_SIZE]; /* the thread's stack */ int state; /* FREE, RUNNING, RUNNABLE */ struct context *context; }; å…¶ä¸­ context æŒ‡é’ˆæŒ‡å‘çš„åœ°æ–¹ç”¨äºå­˜å‚¨å’Œæ¢å¤å¯„å­˜å™¨ç°åœºï¼Œç¬”è€…çš„ä»£ç ä¼šåˆ©ç”¨å †æ ˆä½åœ°å€å¤„çš„ sizeof(struct context) çš„ç©ºé—´æ¥å­˜æ”¾è¿™ä¸ª contextã€‚\nthread_create() ç±»ä¼¼äº xv6 ä¸­çš„è®¾è®¡ï¼Œåˆ›å»ºçº¿ç¨‹æ—¶æˆ‘ä»¬è¦åœ¨ context ä¸­ä¼ªé€ ä¸€ä¸ªç”¨äºè¿”å›çš„å¯„å­˜å™¨ç°åœºï¼šè®¾ç½® ra ä¸ºç›®æ ‡å‡½æ•°åœ°å€ï¼Œsp ä¸ºæ”¹çº¿ç¨‹çš„æ ˆçš„åœ°å€å³å¯ã€‚\nç¬”è€…æ›¾ç»é‡åˆ°ä¸€ä¸ªéå¸¸éš¾ä»¥ç†è§£çš„ bugï¼šæŸå‡½æ•°çš„ä»£ç åœ¨è¿è¡Œè¿‡ç¨‹ä¸­è¢«ä¿®æ”¹ï¼Œå¯¼è‡´æ®µé”™è¯¯ã€‚ç»è¿‡æ’æŸ¥å‘ç°ï¼šç¬”è€…å¿˜äº†ä¸º main() å‡½æ•°å¯¹åº”çš„çº¿ç¨‹è®¾ç½® context æŒ‡é’ˆï¼Œcontext æŒ‡é’ˆé»˜è®¤åˆå§‹å€¼ä¸º 0ï¼Œä»è€Œåœ¨ç¬¬ä¸€æ¬¡ä¸Šä¸‹æ–‡åˆ‡æ¢æ—¶ï¼Œmain() çš„ä¸Šä¸‹æ–‡è¦†ç›–äº†ä»£ç æ®µã€‚æˆ‘ä»¬åº”è¯¥åœ¨ thread_init() ä¸­ä¸º main() çš„çº¿ç¨‹åšå¥½åˆå§‹åŒ–ã€‚\nxv6 çš„ç”¨æˆ·è¿›ç¨‹ä¸­ä»£ç æ®µæ˜¯ä» 0 åœ°å€å¼€å§‹ä¿å­˜çš„ï¼ŒæŸ¥çœ‹ /kernel/exec.c å¯çŸ¥ xv6 é€šè¿‡ uvmalloc() ç”³è¯·é¡µé¢å¹¶å°†ä»£ç æ”¾å…¥ï¼Œuvmalloc() ä¹Ÿæ˜¯ sbrk() ç³»ç»Ÿè°ƒç”¨åº•å±‚çš„å‡½æ•°ï¼Œç”³è¯·çš„é¡µé¢é»˜è®¤æ˜¯ R/W/X/U çš„ï¼Œæ‰€ä»¥ç”¨æˆ·è¿›ç¨‹æœ‰ä¿®æ”¹çš„æƒåˆ© (åŠ è½½æ—¶å°†ä»£ç æ®µè®¾ç½®ä¸ºä¸å¯å†™æˆ–è®¸æ›´å®¹æ˜“æš´éœ² bug)ã€‚\nthread_switch() è¿™éƒ¨åˆ†ä»£ç ç”¨æ±‡ç¼–å®ç°ï¼Œå¯ä»¥å®Œå…¨å‚è€ƒ /kernel/swtch.S çš„å®ç°ã€‚ç±»ä¼¼åœ°ï¼Œå› ä¸º thread_switch() åœ¨ C ä»£ç ä¸­è¢«å½“ä½œä¸€ä¸ªæ™®é€šå‡½æ•°è°ƒç”¨ï¼Œç¼–è¯‘å™¨ä¼šå¸®æˆ‘ä»¬ä¿è¯ caller-saved registers çš„å°å­˜ (æ ˆä¸Š)ï¼Œæˆ‘ä»¬åªéœ€è¦ä¿å­˜ callee-saved registers å³å¯ã€‚\nthread_schedue() è¯¥å‡½æ•°è´Ÿè´£æŒ‘é€‰ä¸€ä¸ª RUNNABLE çš„çº¿ç¨‹ï¼Œç„¶åé€šè¿‡ thread_switch() è·³è¿‡å»ã€‚\nthread_yield() è¯¥å‡½æ•°åªéœ€è¦å°†å½“å‰çº¿ç¨‹çš„çŠ¶æ€æ”¹ä¸º RUNNABLEï¼Œç„¶åè°ƒç”¨ thread_schedule() å³å¯ã€‚\nUsing Threads (moderate) è¯¥å®éªŒä½¿ç”¨ Linux çš„ pthread çº¿ç¨‹åº“ï¼Œæ˜¯éå¸¸åŸºç¡€çš„å¸¦é”å¹¶å‘ç¼–ç¨‹å®éªŒã€‚ä¸ºå“ˆå¸Œè¡¨çš„æ¯ä¸ª bucket ä¸Šä¸€æŠŠé”å°±å¯ä»¥æ—¢ä¿è¯æ­£ç¡®æ€§åˆé€šè¿‡é€Ÿåº¦æµ‹è¯•ã€‚\nBarrier (moderate) è¯¥å®éªŒä½¿ç”¨ Linux çš„ pthread çº¿ç¨‹åº“ï¼Œæ˜¯éå¸¸åŸºç¡€çš„æ¡ä»¶å˜é‡ç¼–ç¨‹å®éªŒã€‚æˆ‘ä»¬ç”šè‡³ä¸éœ€è¦ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹â€”â€”æˆ‘ä»¬åªè¦è®©å…ˆæ¥çš„çº¿ç¨‹åœ¨æ¡ä»¶å˜é‡ä¸Šç¡çœ ï¼Œæœ€åä¸€ä¸ªåˆ°æ¥çš„çº¿ç¨‹ broadcast ä¸€ä¸‹å³å¯ã€‚\nä¸€ä¸ªå°ç»†èŠ‚æ˜¯æˆ‘ä»¬è¦åœ¨ barrier() ä¸­ä¿®æ”¹ roundï¼Œä½† round åªèƒ½è¢«ä¿®æ”¹ä¸€æ¬¡ã€‚æˆ‘ä»¬å¯ä»¥è®©æ¯ä¸ªçº¿ç¨‹ä¸Šæ¥å…ˆä¿å­˜ä¸€ä¸ªæ—§çš„ round å€¼ï¼Œç„¶åè¢«å”¤é†’åæ¯ä¸ªçº¿ç¨‹ä¸Šé”æ£€æŸ¥ roundï¼Œåªæœ‰çœ‹åˆ° old == new çš„çº¿ç¨‹å¯ä»¥ +1ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"e972b9cd051cc27851a7de3b8b2c679e","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-operating-system/labs/lab07/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-operating-system/labs/lab07/","section":"notes","summary":"Progress Uthread: switching between threads (moderate) Using threads (moderate) Barrier (moderate) Uthread: Switching Between Threads (moderate) è¯¥å®éªŒè¦å®ç°ä¸€ä¸ªâ€œç”¨æˆ·æ€åç¨‹åº“â€ï¼Œæ¯ä¸ªåç¨‹é€šè¿‡ yield() å‡½æ•°ä¸»åŠ¨è®©å‡º CPU æ¥è®©å…¶ä»–åç¨‹è¿è¡Œã€‚ç¬”è€…å®šä¹‰äº†å¦‚ä¸‹çš„ç»“æ„ä½“ï¼š\nstruct thread { char stack[STACK_SIZE]; /* the thread's stack */ int state; /* FREE, RUNNING, RUNNABLE */ struct context *context; }; å…¶ä¸­ context æŒ‡é’ˆæŒ‡å‘çš„åœ°æ–¹ç”¨äºå­˜å‚¨å’Œæ¢å¤å¯„å­˜å™¨ç°åœºï¼Œç¬”è€…çš„ä»£ç ä¼šåˆ©ç”¨å †æ ˆä½åœ°å€å¤„çš„ sizeof(struct context) çš„ç©ºé—´æ¥å­˜æ”¾è¿™ä¸ª contextã€‚","tags":null,"title":"MIT-6.S081 Lab 07: Multithreading","type":"docs"},{"authors":null,"categories":null,"content":"Progress RISC-V assembly (easy) Backtrace (moderate) Alarm (hard) RISC-V assembly (easy) Q: Which registers contain arguments to functions? For example, which register holds 13 in main\u0026rsquo;s call to printf?\nRISC-V ä¸­ï¼Œå‡½æ•°è°ƒç”¨çš„å‚æ•°æŒ‰é¡ºåºå­˜æ”¾åœ¨ a0 a1 a2 a3 â€¦â€¦ ä¸­ã€‚ä»¥ printf() ä¸ºä¾‹ï¼Œ13 æ˜¯å®ƒçš„ç¬¬ä¸‰ä¸ªå‚æ•°ï¼Œæ‰€ä»¥å­˜æ”¾åœ¨ a2 å¯„å­˜å™¨ä¸­ã€‚\nQ: Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)\næ±‡ç¼–ä»£ç ä¸­æ²¡æœ‰ç›´æ¥è°ƒç”¨å‡½æ•° f() å’Œ g()ï¼Œå› ä¸º f() å’Œ g() æ˜¯éå¸¸ç®€å•çš„å‡½æ•°ï¼Œç¼–è¯‘å™¨å¯¹å…¶åšäº†ä¼˜åŒ–ï¼Œç›´æ¥å°† f(8)+1 çš„ç»“æœ 12 å†™å…¥äº†å¯„å­˜å™¨ a1ã€‚\nQ: At what address is the function printf located?\nprintf() å‡½æ•°çš„åœ°å€ä¸º 0x628ã€‚å¯ä»¥åœ¨ call.asm ä¸­ç›´æ¥æœç´¢åˆ°ï¼Œä¹Ÿå¯ä»¥é€šè¿‡ main() å‡½æ•°çš„æ±‡ç¼–ä»£ç \n30:\t00000097 auipc\tra,0x0 34:\t5f8080e7 jalr\t1528(ra) # 628 \u0026lt;printf\u0026gt; çœ‹å‡º printf() å‡½æ•°çš„åœ°å€ã€‚\nQ: What value is in the register ra just after the jalr to printf in main?\nra å¯„å­˜å™¨ä¸­å­˜å‚¨çš„åº”è¯¥æ˜¯ printf() å‡½æ•°çš„è¿”å›åœ°å€ã€‚æ ¹æ® RISC-V æ‰‹å†Œä¸­ jalr æŒ‡ä»¤çš„å®šä¹‰ï¼Œpc+4 çš„å€¼ä¼šè¢«å†™å…¥ ra å¯„å­˜å™¨ã€‚å› æ­¤å½“å‰ ra çš„å€¼ä¸º 0x38ã€‚\nQ: Run the following code.\nunsigned int i = 0x00646c72; printf(\u0026quot;H%x Wo%s\u0026quot;, 57616, \u0026amp;i); What is the output? Here\u0026rsquo;s an ASCII table that maps bytes to characters.\nThe output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?\nHere\u0026rsquo;s a description of little- and big-endian and a more whimsical description.\nè¾“å‡ºçš„ç»“æœæ˜¯ï¼š\nHe110 World ç¬¬ä¸€ï¼Œåè¿›åˆ¶æ•° 57616 è½¬æ¢æˆåå…­è¿›åˆ¶æ˜¯ E110Hã€‚ä½¿ç”¨ \u0026ldquo;%x\u0026rdquo; æ‰“å°æ—¶ï¼Œåå…­è¿›åˆ¶ä¸­çš„å­—æ¯éƒ½æ˜¯å°å†™å­—æ¯ï¼Œæ‰€ä»¥ç¬¬ä¸€å¤„æ‰“å°ç»“æœä¸º e110ã€‚\nç¬¬äºŒï¼Œå˜é‡ i çš„åœ°å€è¢«ä¼ ç»™äº† printf()ï¼Œprintf() ä¼šå°†è¯¥åœ°å€å¤„çš„æ•°æ®æŒ‰ç…§å­—ç¬¦ä¸²ç±»å‹è¿›è¡Œè§£è¯»ï¼Œå³æ¯ä¸ªå­—èŠ‚æŒ‰ç…§ ASCII ç ç¿»è¯‘æˆå­—ç¬¦è¿›è¡Œè¾“å‡ºã€‚RISC-V æ˜¯å°ç«¯æœºå™¨ï¼Œå› æ­¤åœ°å€ \u0026amp;i å¤„å¾€åè‹¥å¹²ä¸ªå­—èŠ‚çš„å†…å®¹ä¸º\n\u0026amp;i \u0026amp;i + 1 \u0026amp;i + 2 \u0026amp;i + 3 72 $\\rightarrow$ \u0026lsquo;r\u0026rsquo; 6c $\\rightarrow$ \u0026rsquo;l' 64 $\\rightarrow$ \u0026rsquo;d' 00 $\\rightarrow$ \u0026lsquo;\\0\u0026rsquo; é‡åˆ°ç»“æŸç¬¦å³åœæ­¢è¾“å‡ºï¼Œå› æ­¤ç¬¬äºŒå¤„æ‰“å°ç»“æœä¸º rldã€‚\nå¦‚æœ RISC-V æ˜¯å¤§ç«¯æœºå™¨ï¼Œä¸ºäº†ä½¿ç¬¬äºŒå¤„è¾“å‡ºç»“æœä¸å˜ï¼Œi çš„å€¼åº”è¯¥ä¿®æ”¹ä¸º 0x726c6400ã€‚ç¬¬ä¸€å¤„çš„ 57616 ä¸éœ€è¦ä¿®æ”¹ï¼Œå› ä¸ºåªè¦å­˜å’Œå–éƒ½éµå¾ªå¤§ç«¯æ–¹å¼ï¼Œæ•°æ®çš„å€¼å°±ä¸ä¼šæ”¹å˜ã€‚\nQ: In the following code, what is going to be printed after 'y='? (note: the answer is not a specific value.) Why does this happen?\nprintf(\u0026quot;x=%d y=%d\u0026quot;, 3); y= åçš„å†…å®¹æ˜¯è¿›å…¥ printf() å‡½æ•°å a2 å¯„å­˜å™¨ä¸­çš„å€¼ã€‚ç”±äºè¿™é‡Œçš„ printf() å‡½æ•°å°‘äº†ä¸€ä¸ªå‚æ•°ï¼Œa2 å¯„å­˜å™¨ä¸­çš„å€¼æ˜¯ UBï¼Œè¾“å‡ºç»“æœä¼šæ˜¯ä¸€ä¸ªæ— æ³•é¢„æ–™çš„éšæœºæ•°ã€‚\nBacktrace (moderate) è¦å®ç°çš„ Backtrace åŠŸèƒ½å’Œ GDB ä¸­çš„ backtrace åŸºæœ¬ç›¸åŒï¼šæ ¹æ®æ ˆå¸§å†…å®¹å›æº¯å‡½æ•°è°ƒç”¨çš„è¿‡ç¨‹ã€‚\né¦–å…ˆéœ€è¦è·å–å½“å‰å‡½æ•°çš„æ ˆå¸§ã€‚sp å¯„å­˜å™¨æŒ‡å‘æ ˆé¡¶ï¼Œä½†æ ˆå¸§çš„å¤§å°æ˜¯ä¸ç¡®å®šçš„ï¼Œæˆ‘ä»¬éœ€è¦çš„æ˜¯æ ˆåº•æŒ‡é’ˆ fp (å³ s0 å¯„å­˜å™¨)ã€‚å¯ä»¥é€šè¿‡å†…è”æ±‡ç¼–çš„æ–¹å¼æ¥è¯»å– fp å¯„å­˜å™¨çš„å€¼ã€‚\nstatic inline uint64 r_fp() { uint64 x; asm volatile(\u0026quot;mv %0, s0\u0026quot; : (=r) (x)); return x; } ç”±äºç°åœ¨å¤„åœ¨å†…æ ¸æ€ï¼Œå½“å‰çš„æ ˆå¸§å­˜å‚¨åœ¨ä¸Šä¸€ä¸ªç”¨æˆ·è¿›ç¨‹çš„å†…æ ¸æ ˆä¸Šã€‚å†…æ ¸æ ˆå¤§å°ä¸ºä¸€ä¸ªé¡µé¢ï¼Œå¯ä»¥é€šè¿‡ PGROUNDDOWN(fp) å’Œ PGROUNDUP(fp) æ¥åˆ†åˆ«è·å¾—å†…æ ¸æ ˆçš„æ ˆé¡¶åœ°å€å’Œæ ˆåº•åœ°å€ã€‚æˆ‘ä»¬çš„å‡½æ•°å›æº¯è¿½è¸ªåªåœ¨å†…æ ¸æ ˆèŒƒå›´å†…ï¼Œå› ä¸ºæ›´è¿œçš„å›æº¯ä¼šåˆ°ç”¨æˆ·æ ˆä¸Šã€‚\næ ¹æ® RISC-V çš„æ ˆå¸§æ ¼å¼ï¼Œfp æŒ‡é’ˆå®é™…ä¸ŠæŒ‡å‘çš„æ˜¯ä¸Šä¸€ä¸ªæ ˆå¸§çš„åº•éƒ¨ (è¯¾ç¨‹ä¸­ TA çš„è¯´æ³•æœ‰è¯¯)ã€‚åœ¨ RV64 ä¸­ï¼Œfp-8 çš„ä½ç½®å­˜å‚¨äº†å½“å‰å‡½æ•°çš„è¿”å›åœ°å€ï¼Œè¿™ä¸ªåœ°å€ç†åº”åœ¨å½“å‰å‡½æ•°çš„ caller å‡½æ•°èŒƒå›´å†…ï¼Œæ‰“å°è¿™ä¸ªåœ°å€å°±ç›¸å½“äºè¿½è¸ªåˆ°äº†ä¸Šä¸€ä¸ªå‡½æ•°ã€‚fp-16 çš„ä½ç½®å­˜å‚¨äº†ä¸Šä¸€ä¸ªæ ˆå¸§çš„ fp çš„å†…å®¹ã€‚å°†è¿™ä¸ªå€¼èµ‹ç»™ fp å³å¯å®ç°é¡ºç€æ ˆå¸§å‘ä¸Šçˆ¬çš„åŠŸèƒ½ã€‚\nå…³äº printf() çš„è¾“å‡ºä¸èƒ½å¾—åˆ°æ­£ç¡®çš„ç»“æœ\nç¬”è€…èµ·åˆä½¿ç”¨ printf() çš„ %x æ¥è¾“å‡ºè¿”å›åœ°å€ï¼Œä½†å¾—åˆ°çš„ç»“æœå‡ºå…¥å¾ˆå¤§ã€‚xv6 ä¸­çš„ printf() ä¸æ˜¯è°ƒç”¨çš„ C åº“å‡½æ•°ï¼Œè€Œæ˜¯è‡ªå·±å®ç°çš„ã€‚é˜…è¯» printf() çš„æºç å¯ä»¥çœ‹åˆ°ï¼Œ%x è¾“å‡ºåå…­è¿›åˆ¶æ•°åªèƒ½è¾“å‡º int èŒƒå›´å†…çš„ã€‚è¦æ‰“å°ä¸€ä¸ªåœ°å€åº”è¯¥ä½¿ç”¨ %p æ¨¡å¼æ¥è¾“å‡ºã€‚\nAlarm (hard) æˆ‘ä»¬éœ€è¦å®ç°ä¸¤ä¸ªç³»ç»Ÿè°ƒç”¨\nint sigalarm(int ticks, void (*handler)()); int sigreturn(void); sigalarm() è´Ÿè´£åœ¨å½“å‰è¿›ç¨‹ä¸­æ‰“å¼€ä¸€ä¸ªå®šæ—¶å™¨ï¼Œæ¯è¿‡ ticks ä¸ªå‘¨æœŸå°±æ‰§è¡Œä¸€æ¬¡ handler å‡½æ•°ã€‚ä¸ºäº†å®ç°è¿™ä¸ªåŠŸèƒ½ï¼Œæˆ‘ä»¬éœ€è¦åœ¨ proc ç»“æ„ä½“ä¸­æ·»åŠ ä¸€äº›å­—æ®µï¼šnticks è´Ÿè´£å­˜å‚¨å½“å‰çš„å‘¨æœŸï¼Œhandler è´Ÿè´£å­˜å‚¨å›è°ƒå‡½æ•°çš„åœ°å€ (ç”¨æˆ·è™šæ‹Ÿåœ°å€)ï¼Œcurticks è´Ÿè´£è®°å½•è‡ªä¸Šä¸€æ¬¡è°ƒç”¨ handler ä¹‹åï¼Œå·²ç»è¿‡äº†å¤šå°‘ä¸ªå‘¨æœŸã€‚åœ¨ sys_sigalarm() å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬åº”å½“æ›´æ–°è¿™äº›å­—æ®µã€‚\næ­¤å¤„çš„å‘¨æœŸæŒ‡çš„ä¸æ˜¯ CPU çš„æ—¶é’Ÿå‘¨æœŸï¼Œè€Œæ˜¯æŒ‡æ—¶é’Ÿä¸­æ–­çš„å‘¨æœŸã€‚å› æ­¤åœ¨ usertrap() å‡½æ•°ä¸­ï¼Œæ¯æ¬¡åˆ¤æ–­åˆ° which_dev == 2 ï¼Œå³æ—¶é’Ÿä¸­æ–­åˆ°æ¥ï¼Œåˆ™ curticks++ï¼Œè‹¥ curticks è¾¾åˆ°äº† nticksï¼Œåˆ™ä¸‹ä¸€æ¬¡è¿”å›ç”¨æˆ·æ€åº”è½¬ç§»åˆ°å›è°ƒå‡½æ•°ã€‚sepc å¯„å­˜å™¨å†³å®šäº†è¿”å›ç”¨æˆ·æ€æ—¶çš„åœ°å€ï¼Œå› æ­¤åªè¦å°† handler èµ‹ç»™ p-\u0026gt;trapframe-\u0026gt;epc å³å¯ã€‚\nå›è°ƒå‡½æ•°çš„æœ€åä¸€å®šä¼šä½¿ç”¨ sigreturn() ç³»ç»Ÿè°ƒç”¨ï¼Œè¯¥ç³»ç»Ÿè°ƒç”¨è´Ÿè´£å›åˆ°åŸæœ¬ç”¨æˆ·ç¨‹åºçš„ä¸­æ–­å¤„ç»§ç»­æ‰§è¡Œã€‚è§¦å‘äº†å›è°ƒå‡½æ•°çš„è¿™æ¬¡ä¸­æ–­èµ°è¿‡çš„è·¯ç¨‹åº”è¯¥æ˜¯è¿™æ ·çš„ï¼š\nâ€‹\tç”¨æˆ·ç¨‹åº $\\overset{æ—¶é’Ÿä¸­æ–­}{\\rightarrow}$ å†…æ ¸ $\\rightarrow$ å›è°ƒå‡½æ•° $\\overset{ç³»ç»Ÿè°ƒç”¨}{\\rightarrow}$ å†…æ ¸ $\\rightarrow$ ç”¨æˆ·ç¨‹åº\nåœ¨è§¦å‘æ—¶é’Ÿä¸­æ–­æ—¶ï¼Œç”¨æˆ·ç¨‹åºçš„ä¸Šä¸‹æ–‡ä¼šè¢«ä¿å­˜åœ¨ p-\u0026gt;trapframe ä¸­ï¼Œä½†ä»å›è°ƒå‡½æ•°å†è¿›å…¥å†…æ ¸çš„æ—¶å€™ï¼Œtrapframe é‡Œçš„ä¸Šä¸‹æ–‡ä¼šè¢«è¦†ç›–ã€‚è¦æƒ³å¯¹ç”¨æˆ·ç¨‹åºå®Œå…¨é€æ˜åœ°æ‰§è¡Œè¿™ä¸ªè¿‡ç¨‹ï¼Œæˆ‘ä»¬è¦åœ¨æ‰§è¡Œå›è°ƒå‡½æ•°ä¹‹å‰å°†åŸå§‹ä¸Šä¸‹æ–‡ä¿å­˜èµ·æ¥ã€‚å› æ­¤æˆ‘ä»¬éœ€è¦åœ¨ proc ç»“æ„ä½“ä¸­å†å®šä¹‰ä¸€äº›å˜é‡ç”¨æ¥ä¿å­˜åŸå§‹ä¸Šä¸‹æ–‡ã€‚ç¬”è€…ä½¿ç”¨çš„ä¸€ç§ç®€å•çš„æ–¹æ³•æ˜¯å®šä¹‰ä¸€ä¸ª trapframe ç»“æ„ä½“ u_trapframeï¼Œåœ¨è¿›å…¥å›è°ƒå‡½æ•°ä¹‹å‰å°† p-\u0026gt;trapframe é‡Œçš„å†…å®¹å†™åˆ° u_trapframe é‡Œã€‚\næ­¤å¤– test2 ä¸­è¿˜æµ‹è¯•äº†ä¸€ç§é—®é¢˜ï¼šæˆ‘ä»¬åœ¨è¿›å…¥å›è°ƒå‡½æ•°çš„æ—¶å€™ï¼Œåº”è¯¥å…³é—­ sigalarm() è®¾ç½®çš„å®šæ—¶å™¨ã€‚å¦åˆ™å¦‚æœå›è°ƒå‡½æ•°æ‰§è¡Œæ—¶é—´è¿‡é•¿ï¼Œåœ¨æ‰§è¡Œå›è°ƒå‡½æ•°çš„è¿‡ç¨‹ä¸­æŸä¸€æ¬¡æ—¶é’Ÿä¸­æ–­åˆè§¦å‘å®šæ—¶å™¨è°ƒç”¨å›è°ƒå‡½æ•°ï¼Œå°±ä¼šé™·å…¥æ­»é€’å½’ã€‚å› æ­¤æˆ‘ä»¬åœ¨ proc ç»“æ„ä½“ä¸­è¿˜éœ€è¦ä¸€ä¸ªå˜é‡æ¥è®°å½•å½“å‰æ˜¯å¦æ˜¯ä»å›è°ƒå‡½æ•°ä¸­é™·å…¥å†…æ ¸æ€çš„ã€‚è¿™ä¸ªçŠ¶æ€åº”è¯¥åœ¨å‰ä¸€æ¬¡å‡†å¤‡è¿›å…¥å›è°ƒå‡½æ•°æ—¶ç½® 1ï¼Œåœ¨ sigreturn() ä¸­æ¸…é›¶ã€‚å½“è¯¥å˜é‡ç½® 1 æ—¶ï¼Œæ—¶é’Ÿä¸­æ–­ä¸å¯¹è®¡æ—¶å™¨è¿›è¡Œæ£€æŸ¥ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"163b71a2d152c535be564e57c9c0ca55","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-operating-system/labs/lab04/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-operating-system/labs/lab04/","section":"notes","summary":"Progress RISC-V assembly (easy) Backtrace (moderate) Alarm (hard) RISC-V assembly (easy) Q: Which registers contain arguments to functions? For example, which register holds 13 in main\u0026rsquo;s call to printf?\nRISC-V ä¸­ï¼Œå‡½æ•°è°ƒç”¨çš„å‚æ•°æŒ‰é¡ºåºå­˜æ”¾åœ¨ a0 a1 a2 a3 â€¦â€¦ ä¸­ã€‚ä»¥ printf() ä¸ºä¾‹ï¼Œ13 æ˜¯å®ƒçš„ç¬¬ä¸‰ä¸ªå‚æ•°ï¼Œæ‰€ä»¥å­˜æ”¾åœ¨ a2 å¯„å­˜å™¨ä¸­ã€‚","tags":null,"title":"MIT-6.S081 Lab 04: Traps","type":"docs"},{"authors":null,"categories":null,"content":"Progress boot xv6 (easy) sleep (easy) pingpong (easy) primes (medium)/(hard) find (medium) xargs (medium) Boot xv6 (easy) åˆšåˆšå…‹éš†å®Œé¡¹ç›®åæ–‡ä»¶å¤¹é‡Œæ²¡æœ‰ä¸œè¥¿ï¼Œè¿™æ˜¯æ­£å¸¸çš„ã€‚åˆ‡æ¢åˆ° util åˆ†æ”¯ä¹‹åå³å¯çœ‹åˆ°å†…å®¹ã€‚\nä½¿ç”¨ make grade å‘½ä»¤è¿›è¡Œå°è¯•æ—¶å‘ç°æŠ¥é”™ï¼š\n/usr/bin/env: python: No such file or directory ç¬”è€…æ ¹æ® stakoverflow ä¸Šçš„ è¿™ä¸ªå›ç­”è¿›è¡Œäº†ä¿®å¤ï¼šé¦–å…ˆæ£€æŸ¥äº†ä¸€ä¸‹ python3 æ˜¯å¦å®‰è£…ï¼Œå‘ç°å·²ç»å®‰è£…ã€‚å‡ºç°ä¸Šè¿°æŠ¥é”™çš„åŸå› æ˜¯ç³»ç»Ÿå†…åªæœ‰ python3 è¿™ä¸ªç¨‹åºã€‚å› æ­¤åªè¦åˆ›å»ºä¸€ä¸ªåä¸º python çš„æŒ‡å‘ python3 çš„è½¯é“¾æ¥å³å¯ã€‚\nsudo ln -s /usr/bin/python3 /usr/bin/python æƒ³è¦ä½¿ç”¨ gdb è°ƒè¯• xv6 çš„è¯ï¼Œå¯ä»¥å…ˆåœ¨ä¸€ä¸ªçª—å£å·¥ä½œç›®å½•ä¸‹æ‰§è¡Œ\nmake CPUS=1 qemu-gdb ç„¶åæ–°å¼€ä¸€ä¸ªçª—å£ï¼Œåœ¨å·¥ä½œç›®å½•ä¸‹æ‰§è¡Œ riscv64-linux-gnu-gdb æˆ– gdb-multiarchï¼Œåè€…ä¼šè‡ªè¡Œåˆ¤æ–­æ¶æ„ã€‚åˆæ¬¡è¿è¡Œå¯èƒ½ä¼šé‡åˆ° .gdbinit ç›¸å…³çš„é—®é¢˜ã€‚æ­¤æ—¶éœ€è¦åˆ›å»ºæ–‡ä»¶ ~/.gdbinitï¼Œå¹¶åœ¨å…¶ä¸­å†™\nadd-auto-load-safe-path ~/xv6-labs-2020/.gdbinit sleep (easy) C è¯­è¨€ç¼–ç¨‹ç»ƒä¹ ï¼Œåªéœ€è¦ä½¿ç”¨ sleep() ç³»ç»Ÿè°ƒç”¨å³å¯ã€‚ä¸è¿‡éœ€è¦æ³¨æ„ sleep çš„å‚æ•°è§„åˆ™ï¼š\nå¦‚æœ sleep æ²¡æœ‰å‚æ•°ï¼Œåº”å½“ç»™å‡ºé”™è¯¯æç¤ºã€‚ sleep å¯ä»¥æœ‰å¤šä¸ªå‚æ•°ï¼Œåº”è¯¥å°†å¤šä¸ªå‚æ•°ç›¸åŠ çš„å€¼ä¼ ç»™ sleep() ç³»ç»Ÿè°ƒç”¨ã€‚ sleep çš„ä»»ä½•ä¸€ä¸ªå‚æ•°ä¸­æœ‰éæ•°å­—å­—ç¬¦æ—¶ï¼Œåº”å½“ç»™å‡ºé”™è¯¯æç¤ºã€‚ pingpong (easy) ç¬”è€…æœ€åˆåªæ˜¯ç”¨äº†ä¸€ä¸ªç®¡é“ï¼Œåœ¨çˆ¶è¿›ç¨‹ä¸­ write(p[1], \u0026quot;a\u0026quot;, 1) ååˆ read(p[0], buf, sizeof(buf))ï¼Œä½†è¿™æ ·ç›¸å½“äºçˆ¶è¿›ç¨‹ä»ç®¡é“é‡Œè¯»åˆ°äº†è‡ªå·±çš„è¾“å‡ºï¼Œæ²¡æœ‰å®Œæˆå’Œå­è¿›ç¨‹çš„äº’åŠ¨ã€‚\nå› æ­¤éœ€è¦ä½¿ç”¨ä¸¤ä¸ªç®¡é“ï¼Œç¬¬ä¸€ä¸ªç®¡é“ç”¨äºçˆ¶è¿›ç¨‹è¾“å‡ºï¼Œå­è¿›ç¨‹è¯»å…¥ï¼Œç¬¬äºŒä¸ªç®¡é“ç”¨äºå­è¿›ç¨‹è¾“å‡ºï¼Œçˆ¶è¿›ç¨‹è¯»å…¥ã€‚\nprimes (moderate)/(hard) ç¬”è€…çš„åˆä»£å®ç°å¦‚ä¸‹ï¼š\nä»¥ç¬¬ä¸€å±‚ä¸ºä¾‹ï¼Œçˆ¶è¿›ç¨‹åˆ›å»ºä¸€ä¸ªç®¡é“ä¹‹å fork å‡ºä¸€ä¸ªå­è¿›ç¨‹ï¼Œç„¶åå°† $2,3,\\cdots,35$ å–‚ç»™ç®¡é“çš„è¾“å‡ºç«¯ã€‚å­è¿›ç¨‹ä»ç®¡é“çš„è¾“å…¥ç«¯æ¥æ”¶è¿™äº›æ•°ã€‚å­è¿›ç¨‹æ”¶åˆ°çš„ç¬¬ä¸€ä¸ªæ•°ä¸€å®šæ˜¯è´¨æ•°ï¼Œå®ƒå¯ä»¥ç”¨è¿™ä¸ªæ•°å°†å‰©ä¸‹çš„æ•°ä¸­è¿™ä¸ªè´¨æ•°çš„å€æ•°ç­›é™¤ã€‚ä¹‹åå­è¿›ç¨‹è‡ªå·±å˜æˆä¸€ä¸ªâ€œçˆ¶è¿›ç¨‹â€ï¼Œå°†æ”¶åˆ°çš„æ•°ä¸­é™¤äº†æœ€å°è´¨æ•°å’Œè¢«ç­›é™¤çš„æ•°çš„å…¶ä»–æ•°ä¼ ç»™è‡ªå·±çš„å­è¿›ç¨‹ã€‚è¯¥è¿‡ç¨‹ä¸€ç›´æŒç»­ï¼Œç›´åˆ°æ²¡æœ‰æ•°ä¸ºæ­¢ã€‚\næ ¸å¿ƒä»£ç ï¼š\nwhile (tot \u0026gt; 0) { pipe(p); int pid = fork(); if (pid \u0026lt; 0) exit_error(); else if (pid == 0) { close(p[1]); int cur, curp; tot = -1; while (read(p[0], \u0026amp;cur, sizeof(cur)) \u0026gt; 0) { if (tot == -1) { printf(\u0026quot;prime %d\\n\u0026quot;, cur); tot ++; curp = cur; } else { if (cur % curp != 0) a[tot ++] = cur; } } close(p[0]); } else { close(p[0]); for (int i = 0; i \u0026lt; tot; i ++) write(p[1], a + i, sizeof(int)); close(p[1]); int status; wait(\u0026amp;status); if (status != 0) exit_error(); exit(0); } } è¿™æ ·åšæœ‰ä¸€ä¸ªå…³é”®çš„é—®é¢˜ï¼šæ¯ä¸€å±‚è¿›ç¨‹éƒ½æ˜¯å®Œå…¨æ¥æ”¶äº†ä¸Šä¸€å±‚çš„æ•°ï¼Œåšå®Œç­›æ³•iï¼Œå†æŠŠæ‰€æœ‰çš„æ•°ä¼ ç»™ä¸‹ä¸€å±‚è¿›ç¨‹ï¼Œæ²¡æœ‰ä½¿ç­›æ³•å……åˆ†å¹¶è¡Œèµ·æ¥ã€‚\nçœŸæ­£å¹¶å‘/å¹¶è¡Œçš„åšæ³•æ˜¯ï¼šæ¯ä¸ªè¿›ç¨‹æœ‰ä¸€ä¸ªç®¡é“å’Œçˆ¶äº²é€šä¿¡ï¼Œå¦å¼€ä¸€ä¸ªç®¡é“å’Œè‡ªå·±çš„å­è¿›ç¨‹é€šä¿¡ã€‚æ¯ä»è‡ªå·±çš„çˆ¶è¿›ç¨‹æ¥æ”¶åˆ°ä¸€ä¸ªæ•°å°±ç«‹åˆ»ä¼ ç»™è‡ªå·±çš„å­è¿›ç¨‹ã€‚è¿™æ ·çš„è¯ï¼Œæ¯”å¦‚åœ¨ç¬¬ä¸€å±‚è¿›ç¨‹ä¸­ 5 é€šè¿‡äº† 2 çš„ç­›æŸ¥ï¼Œè¢«ä¼ å…¥äº†ç¬¬äºŒå±‚ï¼Œç„¶åç¬¬ä¸€å±‚è¿›ç¨‹åœ¨ç­›æŸ¥ 6ï¼Œ7ï¼Œ8ï¼Œ9\u0026hellip; çš„æ—¶å€™ï¼Œç¬¬äºŒå±‚è¿›ç¨‹å·²ç»åœ¨ç”¨ 3 ç­›æŸ¥ 5 äº†ï¼Œè¿™æ ·çœŸæ­£åšåˆ°äº†å¹¶è¡Œã€‚å°†é€’å½’ä¸è¿™ä¸ªè¿‡ç¨‹ç»“åˆèµ·æ¥å†™ä»£ç ä¼šéå¸¸èˆ’æœï¼Œå¦åˆ™éœ€è¦ç»´æŠ¤ä¸€å¤§å †ç®¡é“çš„ç¼–å·ï¼Œä½¿ç¼–ç å˜å¤æ‚ã€‚\néœ€è¦æ³¨æ„çš„ä¸€ç‚¹æ˜¯ç®¡é“çš„ä½¿ç”¨ã€‚çˆ¶è¿›ç¨‹åœ¨ç»™å­è¿›ç¨‹ä¼ é€’å®Œæ•°æ®åï¼Œä¸€å®šè¦å…ˆå…³é—­ç®¡é“çš„è¾“å‡ºç«¯å†è°ƒç”¨ wait() ï¼Œå¦åˆ™å­è¿›ç¨‹çš„ read() åœ¨ç®¡é“è¾“å‡ºæ²¡æœ‰è¢«å…¨éƒ¨å…³é—­çš„æƒ…å†µä¸‹æ˜¯ä¸ä¼šé€€å‡ºçš„ã€‚\nfind (moderate) å‚è€ƒ ls ç¨‹åºçš„å®ç°å¯ä»¥å¯¹ find çš„å®ç°èµ·åˆ°å¾ˆå¤§çš„å¸®åŠ©ã€‚\nfind çš„å®ç°éœ€è¦å¯¹ xv6 çš„æ–‡ä»¶ç³»ç»Ÿæœ‰ä¸€ä¸ªç²—æµ…çš„äº†è§£ã€‚ä»¥ä¸‹çŸ¥è¯†æ˜¯å¯¹è¯¥ä»»åŠ¡çš„å®ç°æœ‰å¸®åŠ©çš„ï¼š\nå½“æˆ‘ä»¬æ‹¿åˆ°ä¸€ä¸ªæ–‡ä»¶æ—¶ï¼Œå¯ä»¥ç”¨ fstat() ç³»ç»Ÿè°ƒç”¨æ¥è·å–å®ƒçš„ä¿¡æ¯ã€‚fstat() ç³»ç»Ÿè°ƒç”¨å°†æ–‡ä»¶ä¿¡æ¯å†™åˆ°ä½œä¸ºå‚æ•°çš„ stat ç»“æ„ä½“ä¸­ï¼Œstat ç»“æ„ä½“çš„ type å‚æ•°åˆ»ç”»äº†è¿™æ˜¯ä¸€ä¸ªæ–‡ä»¶ï¼Œæ–‡ä»¶å¤¹è¿˜æ˜¯è®¾å¤‡ã€‚\nåœ¨é€šä¿—çš„è§‚å¿µä¸­ï¼Œæ–‡ä»¶å¤¹æ˜¯ä¸€ä¸ªâ€œå®¹å™¨â€ï¼Œé‡Œé¢æ”¾äº†å¾ˆå¤šçš„æ–‡ä»¶ã€‚ä½†äº‹å®ä¸Šæ–‡ä»¶å¤¹æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªæ–‡ä»¶ã€‚æŒ‰ç…§ xv6 çš„ /kernel/fs.h ä¸­æ‰€è¯´ï¼Œ\u0026ldquo;Directory is a file containing a sequence of dirent structures.\u0026rdquo; dirent ç»“æ„ä½“çš„å®šä¹‰å¦‚ä¸‹ï¼š\n#define DIRSIZ 14 struct dirent { int inum; char name[DIRSIZ]; } inum æ˜¯è¯¥æ–‡ä»¶å æ®çš„ inode çš„ä¸ªæ•°ï¼Œæˆ‘ä»¬ä¸å¿…è®¿é—®é‚£äº› inum ä¸º 0 çš„æ–‡ä»¶ã€‚name æ˜¯æ–‡ä»¶åï¼Œåœ¨ xv6 ä¸­ï¼Œæˆ‘ä»¬é»˜è®¤æ–‡ä»¶åä¸è¶…è¿‡ 14 ä¸ªå­—èŠ‚ã€‚å› æ­¤åœ¨ open äº†ä¸€ä¸ªæ–‡ä»¶å¤¹æ–‡ä»¶åï¼Œæˆ‘ä»¬åªè¦ä¸æ–­ç”¨ read(fd, \u0026amp;de, sizeof(dirent)) å‘½ä»¤æ¥è¯»å–ä¿¡æ¯ï¼Œå°±å¯ä»¥è·å¾—æ–‡ä»¶å¤¹å†…æ‰€æœ‰æ–‡ä»¶çš„æ–‡ä»¶åã€‚å°†æ–‡ä»¶åå’Œä¹‹å‰çš„è·¯å¾„æ‹¼æ¥èµ·æ¥ï¼Œå°±å¯ä»¥è®¿é—®æ–‡ä»¶å¤¹å†…éƒ¨çš„æ–‡ä»¶ã€‚\nå¯ä»¥ç”¨é€’å½’æ¥å®ç°æ–‡ä»¶å¤¹å†…éƒ¨æ–‡ä»¶çš„è®¿é—®ï¼Œä½†ä¸è¦å¯¹ . å’Œ .. é€’å½’ï¼Œå¦åˆ™ä¼šé€ æˆæ­»é€’å½’ã€‚\nç¬”è€…æœ€åˆå®ç°å®Œå‘ç°æ–‡ä»¶ç³»ç»Ÿåé¢çš„è‹¥å¹²çš„æ–‡ä»¶éƒ½æ˜¾ç¤º find: cannot open ...ï¼Œç»è¿‡ç­›æŸ¥å‘ç°è¿™æ˜¯å› ä¸ºæ²¡æœ‰å¤šä½™çš„æ–‡ä»¶æè¿°ç¬¦å¯ä»¥ä½¿ç”¨äº†ã€‚åœ¨ xv6 ä¸­ï¼Œèµ„æºæ¯”è¾ƒæœ‰é™ï¼Œæˆ‘ä»¬åº”è¯¥å…»æˆæ‰“å¼€ä¸€ä¸ªæ–‡ä»¶ï¼Œè¯»å–å®Œç›¸å…³ä¿¡æ¯å°±å…³é—­å®ƒçš„å¥½ä¹ æƒ¯ã€‚\nxargs (moderate) æœ‰ä¸€äº›å‘½ä»¤ä¸æ”¯æŒä»ç®¡é“è¯»å–è¾“å…¥ï¼Œè€Œ xargs å‘½ä»¤å¯ä»¥å¸®åŠ©è¿™äº›å‘½ä»¤ä»ç®¡é“è¯»å–ä¿¡æ¯ã€‚æ³¨æ„ï¼šç®¡é“çš„åˆ›å»ºå’Œè¾“å‡ºè¾“å…¥çš„é‡å®šå‘æ˜¯ç”± shell æ¥å®Œæˆçš„ï¼Œæˆ‘ä»¬çš„ xargs ç¨‹åºæ— éœ€å…³å¿ƒè¾“å…¥çš„æ¥æºï¼Œåªéœ€è¦ä»æ ‡å‡†è¾“å…¥ (æ–‡ä»¶æè¿°ç¬¦ 1) è¯»å–ä¿¡æ¯å³å¯ã€‚\nä¸ºæ–°å‘½ä»¤å‡†å¤‡å‚æ•°çš„ç¯èŠ‚æ˜¯è¾ƒå¥½çš„ C è¯­è¨€æŒ‡é’ˆç»ƒä¹ ã€‚ç¬”è€…æ–°å»ºäº†ä¸€ä¸ª char *child_args[MAXARG] æ•°ç»„æ¥ä¸ºå­è¿›ç¨‹ä¼ é€’å‚æ•°ã€‚xargs åç´§è·Ÿçš„é‚£å‡ ä¸ªå‚æ•°æ˜¯ç¡®å®šçš„ï¼Œå†åé¢çš„å‚æ•°éœ€è¦è¯»å…¥ï¼Œç›®å‰è¿˜ä¸èƒ½ç¡®å®šé•¿åº¦ï¼Œæ‰€ä»¥åº”è¯¥åœ¨è¯»å–å®Œä¹‹åç”¨ malloc() æ¥ç”³è¯·å†…å­˜ç©ºé—´ï¼Œå¹¶åœ¨å­è¿›ç¨‹æ‰§è¡Œå®Œæˆåç”¨ free() é‡Šæ”¾ç©ºé—´é˜²æ­¢å†…å­˜æ³„æ¼ã€‚ä¸ºäº†èƒ½å¤Ÿå‡†ç¡®è¯†åˆ«åˆ° \\n ä»¥æ‰§è¡Œå¤šæ¡æŒ‡ä»¤ï¼Œç¬”è€…é‡‡å–äº†ä¸€ä¸ªå­—ç¬¦ä¸€ä¸ªå­—ç¬¦åœ°ä»æ ‡å‡†è¾“å…¥è¯»å–ä¿¡æ¯çš„æ–¹å¼ã€‚è¯»å–åˆ°çš„å­—ç¬¦æš‚å­˜åœ¨å±€éƒ¨æ•°ç»„ buf ä¸­ï¼Œä¸€æ—¦é‡åˆ° \u0026rsquo; \u0026rsquo; æˆ– \u0026lsquo;\\n\u0026rsquo; å°±æ ¹æ® buf çš„é•¿åº¦ç”³è¯·å†…å­˜ï¼Œå°† buf å¤åˆ¶åˆ°å‚æ•°æ•°ç»„é‡Œã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"7c83806135a053abf683e15255399146","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-operating-system/labs/lab01/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-operating-system/labs/lab01/","section":"notes","summary":"Progress boot xv6 (easy) sleep (easy) pingpong (easy) primes (medium)/(hard) find (medium) xargs (medium) Boot xv6 (easy) åˆšåˆšå…‹éš†å®Œé¡¹ç›®åæ–‡ä»¶å¤¹é‡Œæ²¡æœ‰ä¸œè¥¿ï¼Œè¿™æ˜¯æ­£å¸¸çš„ã€‚åˆ‡æ¢åˆ° util åˆ†æ”¯ä¹‹åå³å¯çœ‹åˆ°å†…å®¹ã€‚\nä½¿ç”¨ make grade å‘½ä»¤è¿›è¡Œå°è¯•æ—¶å‘ç°æŠ¥é”™ï¼š\n/usr/bin/env: python: No such file or directory ç¬”è€…æ ¹æ® stakoverflow ä¸Šçš„ è¿™ä¸ªå›ç­”è¿›è¡Œäº†ä¿®å¤ï¼šé¦–å…ˆæ£€æŸ¥äº†ä¸€ä¸‹ python3 æ˜¯å¦å®‰è£…ï¼Œå‘ç°å·²ç»å®‰è£…ã€‚å‡ºç°ä¸Šè¿°æŠ¥é”™çš„åŸå› æ˜¯ç³»ç»Ÿå†…åªæœ‰ python3 è¿™ä¸ªç¨‹åºã€‚å› æ­¤åªè¦åˆ›å»ºä¸€ä¸ªåä¸º python çš„æŒ‡å‘ python3 çš„è½¯é“¾æ¥å³å¯ã€‚","tags":null,"title":"MIT-6.S081 Lab 01: Xv6 and Unix utilities","type":"docs"},{"authors":null,"categories":null,"content":"Consider 2 equations with 2 unknowns. Here\u0026rsquo;s an example: $$ \\begin{cases} 2x-y=0\\\\ -x+2y=3 \\end{cases} $$ In linear algebra, we have $A=\\left [\\begin{matrix}2 \u0026amp; -1\\\\-1 \u0026amp; 2\\end{matrix}\\right ]$ the coefficient matrix, vector $\\mathbf{x}=\\left(\\begin{matrix}x\\\\y\\end{matrix}\\right)$, $\\mathbf{b}=\\left(\\begin{matrix}0\\\\3\\end{matrix}\\right)$. Then the equations can be written in the form $$ A\\mathbf{x}=\\mathbf{b} $$ If we focus on the \u0026ldquo;column picture\u0026rdquo;, the equations can be regarded as linear combinations of vectors $$ x\\begin{bmatrix}2 \\\\-1\\end{bmatrix}+y\\begin{bmatrix}-1\\\\2\\end{bmatrix}=\\begin{bmatrix}0\\\\3\\end{bmatrix} $$ The column picture of the solution to the equations is shown below:\nUnder the idea of linear combinations, the question\nCan I solve $A\\mathbf{x}=\\mathbf{b}$ for every $\\mathbf{b}\\in \\mathbb{R}^n$ ?\nis equivalent to the question\nDo the combinations of the columns fill the n-dimensional space?\nThe answer is not always \u0026ldquo;yes\u0026rdquo;. For instance, if one vector is the combination of another 2 vectors, the combinations of the columns cannot fill the whole space. This case is called a singular case and the coefficient matrix $A$ is not invertible.\nThe product of a matrix and a vector $$ \\left [\\begin{matrix}a \u0026amp; b\\\\c \u0026amp; d\\end{matrix}\\right]\\left (\\begin{matrix}x\\\\y\\end{matrix}\\right)=\\left (\\begin{matrix}ax+by\\\\cx+dy\\end{matrix}\\right) $$ can be understood as $$ \\left [\\begin{matrix}a \u0026amp; b\\\\c \u0026amp; d\\end{matrix}\\right]\\left (\\begin{matrix}x\\\\y\\end{matrix}\\right)=x\\left(\\begin{matrix}a\\\\c\\end{matrix}\\right)+y\\left(\\begin{matrix}b\\\\d\\end{matrix}\\right) $$ which means that $A\\mathbf{x}$ can be interpreted as the linear combinations of vectors.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"241e3bbd367c61013bf2bfd9f497981d","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-linearalgebra/lectures/lec01/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-linearalgebra/lectures/lec01/","section":"notes","summary":"Consider 2 equations with 2 unknowns. Here\u0026rsquo;s an example: $$ \\begin{cases} 2x-y=0\\\\ -x+2y=3 \\end{cases} $$ In linear algebra, we have $A=\\left [\\begin{matrix}2 \u0026amp; -1\\\\-1 \u0026amp; 2\\end{matrix}\\right ]$ the coefficient matrix, vector $\\mathbf{x}=\\left(\\begin{matrix}x\\\\y\\end{matrix}\\right)$, $\\mathbf{b}=\\left(\\begin{matrix}0\\\\3\\end{matrix}\\right)$.","tags":null,"title":"MIT-18.06 Lecture 01: The Geometric Interpretation of Equations","type":"docs"},{"authors":null,"categories":null,"content":"Consider the 3 equations with 3 unknowns: $$ \\begin{cases} x+2y+z = 2\\\\ 3x+8y+z = 12\\\\ 4y+z = 2 \\end{cases} $$ The coefficient matrix $$ A=\\left[ \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 1\\\\ 3 \u0026amp; 8 \u0026amp; 1\\\\ 0 \u0026amp; 4 \u0026amp; 1 \\end{matrix} \\right] $$ The process of elimination is $$ \\left[ \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 1\\\\ 3 \u0026amp; 8 \u0026amp; 1\\\\ 0 \u0026amp; 4 \u0026amp; 1 \\end{matrix} \\right] \\overset{(2,1)}{\\rightarrow} \\left[ \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 1\\\\ 0 \u0026amp; 2 \u0026amp; -2\\\\ 0 \u0026amp; 4 \u0026amp; 1 \\end{matrix} \\right] \\overset{(3,2)}{\\rightarrow} \\left[ \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 1\\\\ 0 \u0026amp; 2 \u0026amp; -2\\\\ 0 \u0026amp; 0 \u0026amp; 5 \\end{matrix} \\right] $$ The basic procedure is repeatedly choosing pivots (Pivots cannot be zero) and using the pivot to eliminate other lines. The final target is the upper triangle matrix $U$.\nWhen a non-zero pivot cannot be chosen from the currently available equations, the elimination failed.\nTo find the solution to the equations, we need to apply the elimination steps on the augmented matrix. Augmented matrix means the coefficient matrix with an extra column. $$ \\left[ \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 1 \u0026amp; 2\\\\ 3 \u0026amp; 8 \u0026amp; 1 \u0026amp; 12\\\\ 0 \u0026amp; 4 \u0026amp; 1 \u0026amp; 2 \\end{matrix} \\right] \\overset{(2,1)}{\\rightarrow} \\left[ \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 1 \u0026amp; 2\\\\ 0 \u0026amp; 2 \u0026amp; -2 \u0026amp; 6\\\\ 0 \u0026amp; 4 \u0026amp; 1 \u0026amp; 2 \\end{matrix} \\right] \\overset{(3,2)}{\\rightarrow} \\left[ \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 1 \u0026amp; 2\\\\ 0 \u0026amp; 2 \u0026amp; -2 \u0026amp; 6\\\\ 0 \u0026amp; 0 \u0026amp; 5 \u0026amp; -10 \\end{matrix} \\right] $$\nTypically, we call the target of $\\mathbf{b}$â€‹â€‹â€‹ the vector $\\mathbf{c}$â€‹â€‹â€‹. The target of elimination is to transform $A\\mathbf{x}=\\mathbf{b}$â€‹ into $U\\mathbf{x}=\\mathbf{c}$. After back substitution, the solution is $x=2, y=1,z=-2$â€‹â€‹â€‹.\nIn the last lecture we mentioned that a matrix multiplying a column vector can be interpreted as linear combinations of the column vectors of the matrix. In the same way,\n$$ (x,y,z)\\begin{bmatrix}a_1 \u0026amp; a_2 \u0026amp; a_3\\\\b_1 \u0026amp; b_2 \u0026amp; b_3\\\\c_1 \u0026amp; c_2 \u0026amp; c_3\\end{bmatrix}=x\\cdot (a_1,a_2,a_3)+y\\cdot (b_1,b_2,b_3)+z\\cdot (c_1,c_2,c_3) $$\na row vector multiplying a matrix can be interpreted as linear combinations of the row vectors of the matrix.\nSo we can use â€œmatrix languageâ€ to explain the above elimination steps.\nStep 1: Subtract $3\\times row_1$ from $row_2$â€‹ (the target is to eliminate (2,1), so we call it $E_{2,1}$, here $E$ means elementary or elimination) $$ E_{2,1}=\\left[\\begin{matrix}1 \u0026amp; 0 \u0026amp; 0\\\\-3 \u0026amp; 1 \u0026amp; 0\\\\0 \u0026amp; 0 \u0026amp; 1\\end{matrix}\\right] $$ Step 2: Subtract $2\\times row_2$ from $row_3$ $$ E_{3,2}=\\left[\\begin{matrix}1 \u0026amp; 0 \u0026amp; 0\\\\0 \u0026amp; 1 \u0026amp; 0\\\\0 \u0026amp; -2 \u0026amp; 1\\end{matrix}\\right] $$ So in matrix language, the above elimination steps can be written as $$ E_{3,2}\\cdot (E_{2,1}\\cdot A)=U $$ which is extremely simple. Notice that matrix multiplication satisfies the associative law, so we can use an $E=E_{3,2}\\cdot E_{2,1}$ to directly achieve the goal.\nIn this case we only need one type of elementary matrix: subtract $x\\times row_i$ from $row_j$. But in some cases we need to do row exchanges, and we need another type of elementary matrix: the permutation matrix.\nUnder the idea of linear combinations of row vectors, itâ€™s super-easy to construct a permutation matrix. Take the $2\\times 2$ matrix as an example: $$ \\left[\\begin{matrix}0 \u0026amp; 1\\\\1 \u0026amp; 0\\end{matrix}\\right] \\left[\\begin{matrix}a \u0026amp; b\\\\c \u0026amp; d\\end{matrix}\\right]= \\left[\\begin{matrix}c \u0026amp; d\\\\a \u0026amp; b\\end{matrix}\\right] $$\nPermutation matrices that do column exchanges have the similar principle. But notice that matrices multiplied on the left are responsible for row transformation, if we want to do column transformation we need to multiply the matrix on the right, that is\n$$ \\begin{bmatrix}a \u0026amp; b\\\\c \u0026amp; d\\end{bmatrix}\\begin{bmatrix}0 \u0026amp; 1\\\\1 \u0026amp; 0\\end{bmatrix}=\\begin{bmatrix}b \u0026amp; a\\\\d \u0026amp; c\\end{bmatrix} $$\nTake the elementary matrix from the last lecture as an example to talk a little about inverse: $$ \\left[\\begin{matrix}1 \u0026amp; 0 \u0026amp; 0\\\\-3 \u0026amp; 1 \u0026amp; 0\\\\0 \u0026amp; 0 \u0026amp; 1\\end{matrix}\\right] $$ the function of the matrix is to subtract $3\\times row_1$ from $row_2$. So if thereâ€™s a matrix that can â€œundoâ€ the operation, its function is to add $3\\times row_1$ to $row_2$, which leads to $$ \\left[\\begin{matrix}1 \u0026amp; 0 \u0026amp; 0\\\\3 \u0026amp; 1 \u0026amp; 0\\\\0 \u0026amp; 0 \u0026amp; 1\\end{matrix}\\right] \\left[\\begin{matrix}1 \u0026amp; 0 \u0026amp; 0\\\\-3 \u0026amp; 1 \u0026amp; 0\\\\0 \u0026amp; 0 \u0026amp; 1\\end{matrix}\\right]= \\left[\\begin{matrix}1 \u0026amp; 0 \u0026amp; 0\\\\0 \u0026amp; 1 \u0026amp; 0\\\\0 \u0026amp; 0 \u0026amp; 1\\end{matrix}\\right] $$ we can simply write it as $E^{-1}\\cdot E=I$. The matrix on the left is the inverse matrix of the matrix on the right.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"278b3d7cb736166575c55a1209755ffe","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-linearalgebra/lectures/lec02/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-linearalgebra/lectures/lec02/","section":"notes","summary":"Consider the 3 equations with 3 unknowns: $$ \\begin{cases} x+2y+z = 2\\\\ 3x+8y+z = 12\\\\ 4y+z = 2 \\end{cases} $$ The coefficient matrix $$ A=\\left[ \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 1\\\\ 3 \u0026amp; 8 \u0026amp; 1\\\\ 0 \u0026amp; 4 \u0026amp; 1 \\end{matrix} \\right] $$ The process of elimination is $$ \\left[ \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 1\\\\ 3 \u0026amp; 8 \u0026amp; 1\\\\ 0 \u0026amp; 4 \u0026amp; 1 \\end{matrix} \\right] \\overset{(2,1)}{\\rightarrow} \\left[ \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 1\\\\ 0 \u0026amp; 2 \u0026amp; -2\\\\ 0 \u0026amp; 4 \u0026amp; 1 \\end{matrix} \\right] \\overset{(3,2)}{\\rightarrow} \\left[ \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 1\\\\ 0 \u0026amp; 2 \u0026amp; -2\\\\ 0 \u0026amp; 0 \u0026amp; 5 \\end{matrix} \\right] $$ The basic procedure is repeatedly choosing pivots (Pivots cannot be zero) and using the pivot to eliminate other lines.","tags":null,"title":"MIT-18.06 Lecture 02: Elimination Matrices","type":"docs"},{"authors":null,"categories":null,"content":"Suppose $AB=C$ and $A,B,C$ are matrices, the formula for calculating a single entry of $C$ is $$ C_{i,j}=(row_i\\space of\\space A)\\cdot(col_j\\space of\\space B)=\\sum_{k=1}^nA_{i,k}B_{k,j} $$ To apply matrix multiplication, we must ensure that the number of columns of $A$â€‹ equals the number of row s of $B$â€‹. If $A$â€‹ is $m\\times n$â€‹ in size and $B$â€‹ is $n\\times p$â€‹ in size, then C is $m\\times p$â€‹ in size.\nAccording to what weâ€™ve covered in the last two lectures, if we divide $B$ into several columns, then $C$ can be interpreted as several linear combinations of column vectors of $A$ sitting together. Similarly, if we divide $A$ into several rows, $C$â€‹ can be interpreted as several linear combinations of row vectors of $B$ sitting together.\nThe fourth way of doing matrix multiplication is $$ C=\\sum_{k=1}^n(col_i\\space of A)\\times (row_i\\space of\\space B) $$ notice that here we use the cross product. The matrix produced by $(col_i\\space of\\space A)\\times (row_i\\space of\\space B)$ has some good properties: each column of the result matrix is multiples of $(col_i\\space of\\space A)$ and each row of the result matrix is multiples of $(row_i\\space of\\space B)$. In other words, the row space and column space of the result matrix are both a single line.\nThe fifth way is block multiplication. For example, if $A$ and $B$ are square matrices, we divide $A$ and $B$ into four blocks, then $$ C=\\left[\\begin{matrix}C_1 \u0026amp; C_2\\\\C_3 \u0026amp; C_4\\end{matrix}\\right] =\\left[\\begin{matrix}A_1 \u0026amp; A_2\\\\A_3 \u0026amp; A_4\\end{matrix}\\right] \\left[\\begin{matrix}B_1 \u0026amp; B_2\\\\B_3 \u0026amp; B_4\\end{matrix}\\right] $$ $C_1=A_1B_1+A_2B_3$ ,here the multiplication are all matrix multiplication. Other blocks follow the same rule.\nFor convenience, letâ€™s focus on the inverses of square matrices.\nIf a square matrix $A$ has an inverse, then $A^{-1}A=I$. Here for square matrices, the left inverse equals to the right inverse, so $AA^{-1}$ will also give $I$â€‹.\nLetâ€™s consider the cases that a square matrix has no inverse, which we call it singular or non-invertible. $$ A=\\left[\\begin{matrix}1 \u0026amp; 3\\\\2 \u0026amp; 6\\end{matrix}\\right] $$ Why doesnâ€™t it have an inverse? Suppose it has an inverse matrix, consider the linear combinations of the row vectors of $A$. The two vectors are collinear, so itâ€™s impossible to make the linear combinations equals $(1,0)$ and $(0,1)$.\nWe can consider it in another way: We can find a non-zero vector $\\mathbf{x}$ such that $A\\mathbf{x}=0$â€‹. For this example, $\\mathbf{x}=\\left(\\begin{matrix}3\\\\-1\\end{matrix}\\right)$ is a suitable column vector. If there exists a non-zero vector $\\mathbf{x}$ such that $A\\mathbf{x}=0$, then suppose $A$â€‹ has an inverse, then $A^{-1}(A\\mathbf{x})=(A^{-1}A)\\mathbf{x}=I\\mathbf{x}=\\mathbf{x}\\neq 0$ï¼Œhowever, $A^{-1}\\cdot 0=0$, which leads to a contradiction.\nThe two ways describe the same thing: If one of the row/column is useless, i.e. it can be constructed by other rows/columns, the matrix is non-invertible.\nFor the invertible/non-singular matrices, how to calculate the inverse? Here we introduce the Gauss-Jordan method.\nConsider an invertible $2\\times 2$ square matrix $$ \\left[\\begin{matrix}1 \u0026amp; 3\\\\2 \u0026amp; 7\\end{matrix}\\right] $$ letâ€™s put the identity matrix besides it to make it an augmented matrix. $$ \\left[\\begin{matrix}1 \u0026amp; 3 \u0026amp; 1 \u0026amp; 0\\\\2 \u0026amp; 7 \u0026amp; 0 \u0026amp; 1\\end{matrix}\\right] $$ Letâ€™s do eliminations on the left matrix. Different from the classic Gauss elimination whose target is to get the upper triangle matrix,here we need to get the identity matrix. To implement that, after we choose a pivot, we should eliminate all the elements that are in the same column and not in the current row, including the elements above. $$ \\left[\\begin{matrix}1 \u0026amp; 3 \u0026amp; 1 \u0026amp; 0\\\\2 \u0026amp; 7 \u0026amp; 0 \u0026amp; 1\\end{matrix}\\right]\\overset{(2,1)}{\\rightarrow}\\left[\\begin{matrix}1 \u0026amp; 3 \u0026amp; 1 \u0026amp; 0\\\\0 \u0026amp; 1 \u0026amp; -2 \u0026amp; 1\\end{matrix}\\right] \\overset{(1,2)}{\\rightarrow}\\left[\\begin{matrix}1 \u0026amp; 0 \u0026amp; 7 \u0026amp; -3\\\\0 \u0026amp; 1 \u0026amp; -2 \u0026amp; 1\\end{matrix}\\right] $$ The matrix on the right $\\left[\\begin{matrix}7 \u0026amp; -3\\\\-2 \u0026amp; 1\\end{matrix}\\right]$ is the inverse.\nThe principle is easy: according to the last lectures, elimination steps can be interpreted as several elimination matrices. Consider all the elimination steps give us $E$, then $EA=I$, which means that $E=A^{-1}$. The right matrix is $EI=E=A^{-1}$, so we get the right solution.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"d7d4833b581dd513bfb000c49dbb0201","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-linearalgebra/lectures/lec03/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-linearalgebra/lectures/lec03/","section":"notes","summary":"Suppose $AB=C$ and $A,B,C$ are matrices, the formula for calculating a single entry of $C$ is $$ C_{i,j}=(row_i\\space of\\space A)\\cdot(col_j\\space of\\space B)=\\sum_{k=1}^nA_{i,k}B_{k,j} $$ To apply matrix multiplication, we must ensure that the number of columns of $A$â€‹ equals the number of row s of $B$â€‹.","tags":null,"title":"MIT-18.06 Lecture 03: Multiplication and Inverse Matrix","type":"docs"},{"authors":null,"categories":null,"content":"Whatâ€™s the inverse of $AB$, supposing $A$ and $B$â€‹ are both invertible matrices? We can use $B^{-1}A^{-1}$ to check: $$ \\begin{align} (B^{-1}A^{-1})AB=B^{-1}(A^{-1}A)B=B^{-1}B=I\\\\ AB(B^{-1}A^{-1})=A(BB^{-1})A^{-1}=AA^{-1}=I \\end{align} $$ So $(AB)^{-1}=B^{-1}A^{-1}$.\nWhatâ€™s the inverse of $A^T$? Consider $AA^{-1}=I$. Transpose both sides and we get $$ (AA^{-1})^T=(A^{-1})^TA^T=(I)^T=I $$ so $(A^T)^{-1}=(A^{-1})^T$. In other words, you can change the order of inversing and transposing.\nConsider a $2\\times 2$ matrix $$ A=\\left[ \\begin{matrix} 2 \u0026amp; 1\\\\ 8 \u0026amp; 7 \\end{matrix} \\right] $$ To eliminate it to an upper triangle matrix $U$ï¼Œ we use the elementary matrix $$ E_{2,1}=\\left[\\begin{matrix}1 \u0026amp; 0\\\\-4 \u0026amp; 1\\end{matrix}\\right],E_{2,1}A=U=\\left[\\begin{matrix}2 \u0026amp; 1\\\\0 \u0026amp; 3\\end{matrix}\\right] $$ To write it in the form of $A=LU$ï¼Œwe can easily find that $L=E^{-1}$ and for elementary matrices, the inverse is easy to calculate - just add a negative sign \u0026lsquo;-\u0026rsquo;. So $L=\\left[\\begin{matrix}1 \u0026amp; 0\\\\4 \u0026amp; 1\\end{matrix}\\right]$. Here $L$ represents lower triangle matrix. $$ A=LU=\\left[\\begin{matrix}1 \u0026amp; 0\\\\4 \u0026amp; 1\\end{matrix}\\right]\\left[\\begin{matrix}2 \u0026amp; 1\\\\0 \u0026amp; 3\\end{matrix}\\right] $$\nIn some cases, we write $$ A=LDU=\\left[\\begin{matrix}1 \u0026amp; 0\\\\4 \u0026amp; 1\\end{matrix}\\right]\\left[\\begin{matrix}2 \u0026amp; 0\\\\0 \u0026amp; 3\\end{matrix}\\right]\\left[\\begin{matrix}1 \u0026amp; \\frac{1}{2}\\\\0 \u0026amp; 1\\end{matrix}\\right] $$ We extract the diagonal matrix $D$ from $U$ to makes it cleaner.\nHere we cannot see differences between $EA=U$ and $A=LU$. Let\u0026rsquo;s consider a $3\\times 3$ example. Say there\u0026rsquo;s no row exchanges, $E_{3,2}E_{3,1}E_{2,1}A=U$ï¼Œ$E_{3,1}$ is an identity matrix and $$ E_{3,1}=\\left[\\begin{matrix}1 \u0026amp; 0 \u0026amp; 0\\\\-2 \u0026amp; 1 \u0026amp; 0\\\\0 \u0026amp; 0 \u0026amp; 1\\end{matrix}\\right] , E_{3,2}=\\left[\\begin{matrix}1 \u0026amp; 0 \u0026amp; 0\\\\0 \u0026amp; 1 \u0026amp; 0\\\\0 \u0026amp; -5 \u0026amp; 1\\end{matrix}\\right] $$ so $$ E=E_{3,2}E_{3,1}E_{2,1}= \\left[\\begin{matrix}1 \u0026amp; 0 \u0026amp; 0\\\\-2 \u0026amp; 1 \u0026amp; 0\\\\0 \u0026amp; 0 \u0026amp; 1\\end{matrix}\\right] \\left[\\begin{matrix}1 \u0026amp; 0 \u0026amp; 0\\\\0 \u0026amp; 1 \u0026amp; 0\\\\0 \u0026amp; -5 \u0026amp; 1\\end{matrix}\\right] = \\left[\\begin{matrix}1 \u0026amp; 0 \u0026amp; 0\\\\-2 \u0026amp; 1 \u0026amp; 0\\\\10 \u0026amp; -5 \u0026amp; 1\\end{matrix}\\right] $$ It\u0026rsquo;s not obvious to tell why the number $10$ appears. Actually it\u0026rsquo;s because that we firstly subtract $2\\times row_1$ from $row_2$ï¼Œthen we subtract $5\\times (new)row_2$ from $row_3$, and in total we add $10\\times row_1$ to $row_3$.\nIf we use the $A=LU$ form, then $$ L=E_{2,1}^{-1}E_{3,1}^{-1}E_{3,2}^{-1}=\\left[\\begin{matrix}1 \u0026amp; 0 \u0026amp; 0\\\\2 \u0026amp; 1 \u0026amp; 0\\\\0 \u0026amp; 0 \u0026amp; 1\\end{matrix}\\right]\\left[\\begin{matrix}1 \u0026amp; 0 \u0026amp; 0\\\\0 \u0026amp; 1 \u0026amp; 0\\\\0 \u0026amp; 5 \u0026amp; 1\\end{matrix}\\right]=\\left[\\begin{matrix}1 \u0026amp; 0 \u0026amp; 0\\\\2 \u0026amp; 1 \u0026amp; 0\\\\0 \u0026amp; 5 \u0026amp; 1\\end{matrix}\\right] $$ We can see that due to the elaborate order, operations will not interfere with each other. If there\u0026rsquo;s no row exchange, the multipliers during eliminations will go directly into $L$.\nThat\u0026rsquo;s the advantage of $A=LU$. With $L$ and $U$ we can completely forget about $A$ since $LU$ contains all the information about $A$. What\u0026rsquo;s more, $L$ , the inverse of $E$, has the beautiful property that it contains the complete information about elimination steps.\nHow many operations on $A$ during elimination?\nFor a $n\\times n$ matrix, it takes us approximately $n^2$ operations to tackle with the first row and the first column, then the problem becomes a $(n-1)\\times (n-1)$ one. So the cost is $$ \\sum_{k=1}^nk^2\\sim \\int_1^nx^2\\mathrm{d}x\\sim \\frac{1}{3}n^3 $$ And for a column vector, say $\\mathbf{b}$, the cost is approximately $n^2$.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"435eefd52bd42d6ea46456561cda3c0f","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-linearalgebra/lectures/lec04/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-linearalgebra/lectures/lec04/","section":"notes","summary":"Whatâ€™s the inverse of $AB$, supposing $A$ and $B$â€‹ are both invertible matrices? We can use $B^{-1}A^{-1}$ to check: $$ \\begin{align} (B^{-1}A^{-1})AB=B^{-1}(A^{-1}A)B=B^{-1}B=I\\\\ AB(B^{-1}A^{-1})=A(BB^{-1})A^{-1}=AA^{-1}=I \\end{align} $$ So $(AB)^{-1}=B^{-1}A^{-1}$.\nWhatâ€™s the inverse of $A^T$?","tags":null,"title":"MIT-18.06 Lecture 04 - Aâ€™s LU Decomposition","type":"docs"},{"authors":null,"categories":null,"content":"Now let\u0026rsquo;s allow row exchanges to come in during elimination, so we need permutation matrices.\nPermutation matrices can be regarded as identity matrices with some rows exchanged. For $n\\times n$ matrix, there are $n!$ kinds of permutation matrices (the identity matrix is a special permutation matrix).\nAn important property of permutation matrices is that $$ P^{-1}=P^T $$ The property is easy to understand: only the $i_{th}$ row and the $i_{th}$ column have $1$ in the same position, so $P^TP=I$.\nIf we take row exchanges into consideration, the formula will be $$ PA=LU $$ where $P$ is one of the permutation matrices to make the pivots at the right positions.\nTranspose is defined as follows: $$ (A^T){ij}=A{ji} $$ Symmetric matrices are those satisfying $A^T=A$. It\u0026rsquo;s easy to construct a symmetric matrix because for any matrix $R$, $R^TR$ is a symmetric matrix. ($(R^TR)^T=R^T(R^T)^{T}=R^TR$)\nVector spaces are bunches of vectors. There are two basic operations: vector addition and multiplying a scalar to a vector. There are some rules for these two operations (refer to the textbook). The most important one is:\nThe result of addition and multiplication (i.e. linear combinations of vectors) should stay in the vector space.\nWe can easily check that $\\mathbb{R}^n$ is a vector space, it contains all the column vectors with $n$ real components, while the first quadrant of $\\mathbb{R}^2$ is not a vector space because it\u0026rsquo;s not closed under multiplication by all real numbers.\nLet consider subspaces of $\\mathbb{R}^2$. There are three types of subspaces:\n$\\mathbb{R}^2$ itself Any line that crosses through $\\left(\\begin{matrix}0\\\\0\\end{matrix}\\right)$ (we call it $L$) Zero vector only (we call it $Z$) The conclusion can be easily extended to $\\mathbb{R}^n$.\nLet\u0026rsquo;s see how we can use matrices to produce vector spaces. Take the $3\\times 2$ matrix $$ \\left[\\begin{matrix}1 \u0026amp; 3\\\\2 \u0026amp; 3\\\\4 \u0026amp; 1\\end{matrix}\\right] $$ as an example, the columns of the matrix (i.e. two column vectors $\\left(\\begin{matrix}1\\\\2\\\\4\\end{matrix}\\right)$ and $\\left(\\begin{matrix}3\\\\3\\\\1\\end{matrix}\\right)$) span a subspace in $\\mathbb{R}^3$. In geometry, the subspace is a plane going through the origin in $\\mathbb{R}^3$.\nIn general, all the linear combinations of the column vectors of a matrix $A$ form a subspace called column space, denoted as $C(A)$.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"5c702eef13da4fca3b081dec5e1ff577","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-linearalgebra/lectures/lec05/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-linearalgebra/lectures/lec05/","section":"notes","summary":"Now let\u0026rsquo;s allow row exchanges to come in during elimination, so we need permutation matrices.\nPermutation matrices can be regarded as identity matrices with some rows exchanged. For $n\\times n$ matrix, there are $n!","tags":null,"title":"MIT-18.06 Lecture 05: Permutation, Transpose and Vector Spaces","type":"docs"},{"authors":null,"categories":null,"content":"Suppose there are two vector spaces $S$ and $T$, their intersection $S\\cap T$ is also a subspace.\nProof: suppose $v,w\\in S\\cap T$ are vectors, then consider a linear combination $av+bw$, since $v,w\\in S$, $av+bw\\in S$ , also we have $av+bw\\in T$, so $av+bw\\in S\\cap T$, which proves the theorem.\nConsider $$ A=\\left[\\begin{matrix}1 \u0026amp; 1 \u0026amp; 2\\\\2 \u0026amp; 1 \u0026amp; 3\\\\3 \u0026amp; 1 \u0026amp; 4\\\\4 \u0026amp; 1 \u0026amp; 5\\end{matrix}\\right] $$ all the linear combinations of the three column vectors of $A$ forms a column space $C(A)$. It\u0026rsquo;s a subspace of $\\mathbb{R}^4$ since all the vectors have 4 dimensions.\nWe can find that the subspace cannot fill the whole $\\mathbb{R}^4$. Let\u0026rsquo;s consider the linear equations $$ A\\mathbf{x}= \\left[\\begin{matrix}1 \u0026amp; 1 \u0026amp; 2\\\\2 \u0026amp; 1 \u0026amp; 3\\\\3 \u0026amp; 1 \u0026amp; 4\\\\4 \u0026amp; 1 \u0026amp; 5\\end{matrix}\\right] \\left(\\begin{matrix}x_1\\\\x_2\\\\x_3\\end{matrix}\\right) =\\left(\\begin{matrix}b_1\\\\b_2\\\\b_3\\\\b_4\\end{matrix}\\right)=\\mathbf{b} $$ There are four equations with three unknowns. The equations don\u0026rsquo;t necessarily have solutions. We care about what b\u0026rsquo;s allow the equations to be solved.\nIf we use linear combinations to understand matrix multiplications, we can find that $A\\mathbf{x}$ is the linear combinations of the column vectors of $A$, so $\\mathbf{b}$ allows the equations to be solved exactly when $\\mathbf{b}\\in C(A)$.\nWhat\u0026rsquo;s more, we can find that the third column vector makes no contribution: $col_1+col_2=col_3$. If we delete the third column vector, the column space won\u0026rsquo;t be changed. So actually $C(A)$ is a 2-dimensional subspace of $\\mathbb{R}^4$. We call the first two columns pivot columns.\n(Actually we can choose any column and discard it, but by convention we choose the first several columns that are independent.)\nThe null space of a matrix $A$, denoted as $N(A)$, contains all the solutions to $A\\mathbf{x}=\\mathbf{0}$. For the example $A$, all the vectors $\\left(\\begin{matrix}c\\\\c\\\\-c\\end{matrix}\\right)$ are in the null space, $N(A)$ is a line in $\\mathbb{R}^3$.\nThe null space is really a subspace because for any $A\\mathbf{v}=\\mathbf{0}$ and $A\\mathbf{w}=\\mathbf{0}$, $A\\mathbf{(v+w)}=A\\mathbf{v}+A\\mathbf{w}=\\mathbf{0}$.\nFrom column spaces and null spaces we can see that there are two ways to construct a subspace:\nuse the linear combinations of several vectors to form a subspace. add constraints to linear equations to form a subspace. ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"d64b1723ca009db30b2b7dc3b3d694b4","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-linearalgebra/lectures/lec06/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-linearalgebra/lectures/lec06/","section":"notes","summary":"Suppose there are two vector spaces $S$ and $T$, their intersection $S\\cap T$ is also a subspace.\nProof: suppose $v,w\\in S\\cap T$ are vectors, then consider a linear combination $av+bw$, since $v,w\\in S$, $av+bw\\in S$ , also we have $av+bw\\in T$, so $av+bw\\in S\\cap T$, which proves the theorem.","tags":null,"title":"MIT-18.06 Lecture 06: Column Space, Null space","type":"docs"},{"authors":null,"categories":null,"content":"We solve the equation $A\\mathbf{x}=\\mathbf{0}$ through elimination. Obviously, elimination won\u0026rsquo;t change the null space of $A$. For example, let $$ A=\\left[\\begin{matrix}1 \u0026amp; 2 \u0026amp; 2 \u0026amp; 2\\\\2 \u0026amp; 4 \u0026amp; 6 \u0026amp; 8\\\\3 \u0026amp; 6 \u0026amp; 8 \u0026amp; 10\\end{matrix}\\right] $$ through elimination we get the echelon matrix $U$: $$ A=\\left[\\begin{matrix}1 \u0026amp; 2 \u0026amp; 2 \u0026amp; 2\\\\2 \u0026amp; 4 \u0026amp; 6 \u0026amp; 8\\\\3 \u0026amp; 6 \u0026amp; 8 \u0026amp; 10\\end{matrix}\\right]\\overset{(2,1),(3,1)}{\\longrightarrow}\\left[\\begin{matrix}1 \u0026amp; 2 \u0026amp; 2 \u0026amp; 2\\\\0 \u0026amp; 0 \u0026amp; 2 \u0026amp; 4\\\\0 \u0026amp; 0 \u0026amp; 2 \u0026amp; 4\\end{matrix}\\right]\\overset{(3,3)}{\\longrightarrow}\\left[\\begin{matrix}1 \u0026amp; 2 \u0026amp; 2 \u0026amp; 2\\\\0 \u0026amp; 0 \u0026amp; 2 \u0026amp; 4\\\\0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\end{matrix}\\right]=U $$ The number of pivots is call the rank of $A$. There are two pivots, so $rank(A)=2$.\nBy convention, we choose 1st and 3rd column as pivot columns, and the rest are free columns. Accordingly, $x_1$ and $x_3$ are pivot variables, $x_2$ and $x_4$ are free variables. We can assign values to free variables freely, and for every set of values, there\u0026rsquo;s a unique solution to the pivot variables.\nIn particular, if we assign $x_2=1,x_4=0$ , and $x_2=0,x_4=1$, we can get two solutions: $$ \\mathbf{x_1}= \\left(\\begin{matrix}-2\\\\1\\\\0\\\\0\\end{matrix}\\right) \\qquad \\mathbf{x_2}= \\left(\\begin{matrix}2\\\\0\\\\-2\\\\1\\end{matrix}\\right) $$ These solutions are called special solutions. The linear combinations of the special solutions forms the null space. That is $$ N(A)=c\\left(\\begin{matrix}-2\\\\1\\\\0\\\\0\\end{matrix}\\right)+d\\left(\\begin{matrix}2\\\\0\\\\-2\\\\1\\end{matrix}\\right),c,d\\in \\mathbb{R} $$ And for a matrix $A$ with size $m\\times n$, the number of special solutions is $(n-rank(A))$.\nWe can work harder on $U$ to get the reduced row echelon form, denoted as $R$ or $rref(A)$. It eliminates values both above and below the pivots, and transform pivots to 1: $$ U=\\left[\\begin{matrix}1 \u0026amp; 2 \u0026amp; 2 \u0026amp; 2\\\\0 \u0026amp; 0 \u0026amp; 2 \u0026amp; 4\\\\0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\end{matrix}\\right]\\overset{(1,3)}{\\longrightarrow}\\left[\\begin{matrix}1 \u0026amp; 2 \u0026amp; 0 \u0026amp; -2\\\\0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 2\\\\0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\end{matrix}\\right]=R $$ To make it clear, we do column exchanges so that we put pivots columns together on the left and free columns together on the right: $$ \\left[\\begin{matrix}1 \u0026amp; 2 \u0026amp; 0 \u0026amp; -2\\\\0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 2\\\\0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\end{matrix}\\right]\\overset{2\\leftrightarrow 3}{\\longrightarrow}\\left[\\begin{matrix}1 \u0026amp; 0 \u0026amp; 2 \u0026amp; -2\\\\0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 2\\\\0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\end{matrix}\\right] $$ The advantage of $R$ is that we can directly see the special solutions from the matrix. If we ignore the rows with all 0s, we find that $R=\\left[\\begin{matrix}I \\mid F\\end{matrix}\\right]$. $I$ is an identity matrix with size $r\\times r$ ( $r$ means the rank) and $F$ is $r\\times (n-r)$ in size. We can construct all the $(n-r)$ special solutions as a matrix: $$ N=\\left[\\begin{matrix}-F\\\\I\\end{matrix}\\right]=\\left[\\begin{matrix}-2 \u0026amp; 2\\\\0 \u0026amp; -2\\\\1 \u0026amp; 0\\\\0 \u0026amp; 1\\end{matrix}\\right] $$ $N$ is $n\\times (n-r)$ in size. (Here the $I$ may have the different size from the $I$ in $R$) If we use block multiplication of matrices, we can find out that $RN$ gives a matrix with all 0s.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"1b186f2a96b718da10ab8bcb3c479d60","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-linearalgebra/lectures/lec07/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-linearalgebra/lectures/lec07/","section":"notes","summary":"We solve the equation $A\\mathbf{x}=\\mathbf{0}$ through elimination. Obviously, elimination won\u0026rsquo;t change the null space of $A$. For example, let $$ A=\\left[\\begin{matrix}1 \u0026amp; 2 \u0026amp; 2 \u0026amp; 2\\\\2 \u0026amp; 4 \u0026amp; 6 \u0026amp; 8\\\\3 \u0026amp; 6 \u0026amp; 8 \u0026amp; 10\\end{matrix}\\right] $$ through elimination we get the echelon matrix $U$: $$ A=\\left[\\begin{matrix}1 \u0026amp; 2 \u0026amp; 2 \u0026amp; 2\\\\2 \u0026amp; 4 \u0026amp; 6 \u0026amp; 8\\\\3 \u0026amp; 6 \u0026amp; 8 \u0026amp; 10\\end{matrix}\\right]\\overset{(2,1),(3,1)}{\\longrightarrow}\\left[\\begin{matrix}1 \u0026amp; 2 \u0026amp; 2 \u0026amp; 2\\\\0 \u0026amp; 0 \u0026amp; 2 \u0026amp; 4\\\\0 \u0026amp; 0 \u0026amp; 2 \u0026amp; 4\\end{matrix}\\right]\\overset{(3,3)}{\\longrightarrow}\\left[\\begin{matrix}1 \u0026amp; 2 \u0026amp; 2 \u0026amp; 2\\\\0 \u0026amp; 0 \u0026amp; 2 \u0026amp; 4\\\\0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\end{matrix}\\right]=U $$ The number of pivots is call the rank of $A$.","tags":null,"title":"MIT-18.06 Lecture 07: Computing Null Space, Pivot Variables and Special Solutions","type":"docs"},{"authors":null,"categories":null,"content":"Take an example: $$ A\\mathbf{x}=\\left[\\begin{matrix}1 \u0026amp; 2 \u0026amp; 2 \u0026amp; 2\\\\2 \u0026amp; 4 \u0026amp; 6 \u0026amp; 8\\\\3 \u0026amp; 6 \u0026amp; 8 \u0026amp; 10\\end{matrix}\\right]\\left(\\begin{matrix}x_1\\\\x_2\\\\x_3\\end{matrix}\\right)\\left(\\begin{matrix}b_1\\\\b_2\\\\b_3\\end{matrix}\\right)=\\mathbf{b} $$\n$$ \\left[\\begin{matrix}1 \u0026amp; 2 \u0026amp; 2 \u0026amp; 2 \u0026amp; b_1\\\\2 \u0026amp; 4 \u0026amp; 6 \u0026amp; 8 \u0026amp; b_2\\\\3 \u0026amp; 6 \u0026amp; 8 \u0026amp; 10 \u0026amp; b_3\\end{matrix}\\right] \\overset{elimination}{\\longrightarrow} \\left[\\begin{matrix}1 \u0026amp; 2 \u0026amp; 2 \u0026amp; 2 \u0026amp; b_1\\\\0 \u0026amp; 0 \u0026amp; 2 \u0026amp; 4 \u0026amp; b_2-2b_1\\\\0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; b_3-b_2-b_1\\end{matrix}\\right] $$\nSo the equations have solutions exactly when $b_3=b_1+b_2$.\nLet\u0026rsquo;s talk about the solvability. $A\\mathbf{x}=\\mathbf{b}$ is solvable exactly when $b\\in C(A)$. Another equivalent description is that: If a combination of rows of $A$ gives zero row, then the same combination of components of $\\mathbf{b}$ must give 0.\nTo find the complete solutions to $A\\mathbf{x}=\\mathbf{b}$:\nEnsure that the zero rows = 0. Find a particular solution $\\mathbf{x_p}$: set all free variables to 0 and solve $A\\mathbf{x}=\\mathbf{b}$ for pivot variables. Find $N(A)$, then the complete solution set is $X_c={\\mathbf{x}=\\mathbf{x_p}+\\mathbf{x_n}:\\mathbf{x_n}\\in N(A)}$ Let\u0026rsquo;s focus on a bigger picture: an $m\\times n$ matrix with rank $r$ (it\u0026rsquo;s obvious that $r\\leq m,r\\leq n$):\nCase 1: Full column rank $(r=n\u0026lt;m)$\nNo free variable, so $N(A)={\\mathbf{0}}$. The reduced row echelon form $R=\\left[\\begin{matrix}I\\\\0\\end{matrix}\\right]$.\nIf the particular solution $\\mathbf{x_p}$ exists, then it\u0026rsquo;s the unique solution. The equations have 0 or 1 solutions.\nCase 2: Full row rank $(r=m\u0026lt;n)$\nWe can solve $A\\mathbf{x}=\\mathbf{b}$ for arbitrary $\\mathbf{b}$. The reduced row echelon form $R=\\left[\\begin{matrix}I \u0026amp; F\\end{matrix}\\right]$. (Notice that the columns of $I$ and $F$ may mix together)\nSince $F$ exists, $N(A)$ contains more than $\\mathbf{0}$, the equations have $\\infty$ solutions.\nCase 3: $r=n=m$\nIn this case $R=I$, which indicates that $A$ is invertible. And the equations have a unique solution.\nCase 4: $r\u0026lt;n,r\u0026lt;m$\nThe row reduced echelon form $R=\\left[\\begin{matrix}I \u0026amp; F\\\\0 \u0026amp; 0\\end{matrix}\\right]$. The equations have either no solution (zero rows don\u0026rsquo;t match $\\mathbf{b}$) or $\\infty$ solutions.\nOne sentence to summarize: the rank $r$ tells you all the information about the number of solutions.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"522f401f6f9a904357de9377671757d0","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-linearalgebra/lectures/lec08/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-linearalgebra/lectures/lec08/","section":"notes","summary":"Take an example: $$ A\\mathbf{x}=\\left[\\begin{matrix}1 \u0026amp; 2 \u0026amp; 2 \u0026amp; 2\\\\2 \u0026amp; 4 \u0026amp; 6 \u0026amp; 8\\\\3 \u0026amp; 6 \u0026amp; 8 \u0026amp; 10\\end{matrix}\\right]\\left(\\begin{matrix}x_1\\\\x_2\\\\x_3\\end{matrix}\\right)\\left(\\begin{matrix}b_1\\\\b_2\\\\b_3\\end{matrix}\\right)=\\mathbf{b} $$\n$$ \\left[\\begin{matrix}1 \u0026amp; 2 \u0026amp; 2 \u0026amp; 2 \u0026amp; b_1\\\\2 \u0026amp; 4 \u0026amp; 6 \u0026amp; 8 \u0026amp; b_2\\\\3 \u0026amp; 6 \u0026amp; 8 \u0026amp; 10 \u0026amp; b_3\\end{matrix}\\right] \\overset{elimination}{\\longrightarrow} \\left[\\begin{matrix}1 \u0026amp; 2 \u0026amp; 2 \u0026amp; 2 \u0026amp; b_1\\\\0 \u0026amp; 0 \u0026amp; 2 \u0026amp; 4 \u0026amp; b_2-2b_1\\\\0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; b_3-b_2-b_1\\end{matrix}\\right] $$","tags":null,"title":"MIT-18.06 Lecture 08: Complete Solutions of Equations","type":"docs"},{"authors":null,"categories":null,"content":"suppose $A$ is $m\\times n$ in size $(m\u0026lt;n)$, then the equation $A\\mathbf{x}=\\mathbf{0}$ has nonzero solutions because there will be at least one free variable.\nVectors $\\mathbf{x_1},\\mathbf{x_2},\u0026hellip;,\\mathbf{x_n}$ are independent if no combination gives zero vector. (except the zero combination)\ni.e. for any $c_1,c_2,\u0026hellip;,c_n$, $\\sum_{i=1}^n c_i\\mathbf{x_i}\\neq \\mathbf{0}$ ($c_i$ are not all 0s). Otherwise they\u0026rsquo;re dependent.\nIf $\\mathbf{v_1},\\mathbf{v_2},\u0026hellip;,\\mathbf{v_n}$ are column vectors of matrix $A$\nThey\u0026rsquo;re independent if $N(A)={\\mathbf{0}}$. In this case $rank(A)=n$. (No free variable, the essence of free columns is that it belongs to the linear combinations of previous pivot columns) They\u0026rsquo;re dependent if for some nonzero vector $\\mathbf{c}$, $A\\mathbf{c}=\\mathbf{0}$. In this case $rank(A)\u0026lt;n$. $n$ m-dimensional vectors $\\mathbf{x_1},\u0026hellip;,\\mathbf{x_n}$ $(m\u0026lt;n)$ is absolutely dependent. That\u0026rsquo;s because if we put the vectors together to form a matrix $A=\\left[\\mathbf{x_1}\\space \\mathbf{x_2} \\cdots \\mathbf{x_m}\\right]$, $A\\mathbf{x}=\\mathbf{0}$ has nonzero solutions.\nVectors $v_1,v_2,..,v_l$ span a space means that the space consists of all the combinations of those vectors.\nBasis for a vector space is a sequence of vectors $\\mathbf{v_1},\\mathbf{v_2},\u0026hellip;,\\mathbf{v_d}$ satisfying\nThey\u0026rsquo;re independent. They span the whole space. (In other words, the number of vectors is exactly \u0026ldquo;right\u0026rdquo;.)\n$n$ vectors in $\\mathbb{R}^n$ give basis if the $n\\times n$ matrix with those columns is invertible.\nif they\u0026rsquo;re independent, then every column is pivot column, so the reduced echelon form $R=I$. And eliminations can be represented as matrices. So the original matrix is invertible.\nGiven a space, every basis for the space has the same number of vectors, and we call this number the dimension of the space.\nTake an example, $$ A=\\left[\\begin{matrix}1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 1\\\\1 \u0026amp; 1 \u0026amp; 2 \u0026amp; 1\\\\1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 1\\end{matrix}\\right] $$ The column vectors are dependent because $\\left(\\begin{matrix}-1\\\\-1\\\\1\\\\0\\end{matrix}\\right)\\in N(A)$. $rank(A)=2$ and $dimC(A)=2$. We find a important property: the rank of a matrix $A$ equals the dimension of $C(A)$, $dimC(A)=r$.\nColumn vectors 1 and 2 gives a basis of $C(A)$ and 1 and 3, 2 and 3 are basis too.\nThe two special solutions in $N(A)$ are $$ \\mathbf{x_1}=\\left(\\begin{matrix}-1\\\\-1\\\\1\\\\0\\end{matrix}\\right)\\qquad\\mathbf{x_2}=\\left(\\begin{matrix}-1\\\\0\\\\0\\\\1\\end{matrix}\\right) $$ In fact, $span{\\mathbf{x_1},\\mathbf{x_2}}=N(A)$. We see that the dimension of $N(A)$ equals the number of free variables. That is $dimN(A)=n-r$.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"6a38c6e5aac93ecb2fb3d9746776e2b1","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-linearalgebra/lectures/lec09/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-linearalgebra/lectures/lec09/","section":"notes","summary":"suppose $A$ is $m\\times n$ in size $(m\u0026lt;n)$, then the equation $A\\mathbf{x}=\\mathbf{0}$ has nonzero solutions because there will be at least one free variable.\nVectors $\\mathbf{x_1},\\mathbf{x_2},\u0026hellip;,\\mathbf{x_n}$ are independent if no combination gives zero vector.","tags":null,"title":"MIT-18.06 Lecture 09: Linear Dependence, Basis and Dimension","type":"docs"},{"authors":null,"categories":null,"content":"4 fundamental subspaces:\ncolumn space $C(A)$. null space $N(A)$. row space. It contains all the combinations of the row vectors of $A$. In other words, it contains all the combinations of the column vectors of $A^T$, so the notation is $C(A^T)$. left null space. It\u0026rsquo;s the null space of $A^T$, denoted as $N(A^T)$. If $A$ is a matrix with size $m\\times n$, then $C(A),N(A^T)\\subseteq \\mathbb{R}^m$ while $C(A^T),N(A)\\subseteq \\mathbb{R}^n$. We\u0026rsquo;ve known that $\\dim C(A)=r,\\dim N(A)=n-r$. Here an amazing fact is that $\\dim C(A)=\\dim C(A^T)=r$. Thus $\\dim N(A^T)=m-r$. The beautiful property is that $\\dim C(A)+\\dim N(A^T)=m$ and $\\dim C(A^T)+\\dim N(A)=n$, which corresponds to the fact that the number of pivot variables pluses the number of free variables equals $n$.\nAbout basis, the pivot columns are a set of basis of $C(A)$ and the special solutions of $A\\mathbf{x}=\\mathbf{0}$ form a basis of $N(A)$.\nOf course we can transpose $A$ and do row operations on $A^T$ to get a basis of $C(A^T)$. But here\u0026rsquo;s an easier way: we can get a basis of $C(A^T)$ through the reduced row echelon form. Let\u0026rsquo;s take an example: $$ A=\\left[\\begin{matrix}1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 1\\\\1 \u0026amp; 1 \u0026amp; 2 \u0026amp; 1\\\\1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 1\\end{matrix}\\right] \\rightarrow U=\\left[\\begin{matrix}1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 1\\\\0 \u0026amp; -1 \u0026amp; -1 \u0026amp; 0\\\\0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\end{matrix}\\right] \\rightarrow R=\\left[\\begin{matrix}1 \u0026amp; 0 \u0026amp; 1 \u0026amp; 1\\\\ 0 \u0026amp; 1 \u0026amp; 1 \u0026amp; 0\\\\0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\end{matrix}\\right] $$ Through $R$, we can see that the first two columns are pivot columns, so the first two columns of $A$ are basis of $C(A)$. Here we do row operations on $A$, so $C(A)\\neq C(R)$ of course, but considering the fact that doing row operations is just doing linear combinations of row vectors of $A$, $C(A^T)=C(R^T)$. And we can easily tell that $\\dim R^T=2=r$ and the first $r$ row vectors of $R$ are basis of $C(A^T)$. (They\u0026rsquo;re independent and if we do the row operations inversely, we can get all the rows of $A$)\nTo find out a basis for $N(A^T)$. Firstly we want to figure out the matrix that represents the row operations of $A\\rightarrow R$, i.e. we want to find a matrix $E$ such that $EA=R$.\nAccording to Gauss-Jordan, we put a identity matrix besides $A$, i.e. $A\u0026rsquo;=[A_{m\\times n}\\quad I_{m\\times m}]$. Suppose $EA\u0026rsquo;=$\n$E[A\\quad I]=[R\\quad E\u0026rsquo;]$, then we have $E=E\u0026rsquo;$, so by applying all the row operations on $I$, we can get $E$. In the above example, we can get $$ E=\\left[\\begin{matrix}-1 \u0026amp; 2 \u0026amp; 0\\\\1 \u0026amp; -1 \u0026amp; 0\\\\-1 \u0026amp; 0 \u0026amp; 1\\end{matrix}\\right] $$ We claim that the last $m-r$ row vectors of $E$ form a basis of $N(A^T)$ because the last $m-r$ lines of $R$ are zero lines.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"97c748de9d4d6987ed97ba48c0bdd53d","permalink":"https://kristoff-starling.github.io/notes/coursenotes/mit-linearalgebra/lectures/lec10/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/mit-linearalgebra/lectures/lec10/","section":"notes","summary":"4 fundamental subspaces:\ncolumn space $C(A)$. null space $N(A)$. row space. It contains all the combinations of the row vectors of $A$. In other words, it contains all the combinations of the column vectors of $A^T$, so the notation is $C(A^T)$.","tags":null,"title":"MIT-18.06 Lecture 10: 4 Fundamental Subspaces","type":"docs"},{"authors":null,"categories":null,"content":"å®éªŒè¿›åº¦ æˆ‘å®Œæˆäº†æ‰€æœ‰å®‰è£…ä»»åŠ¡ï¼Œå®Œæˆäº†å¿…ç­”é¢˜ï¼Œå¹¶é’ˆå¯¹æ€è€ƒé¢˜å’Œé‡åˆ°çš„å…¶ä»–é—®é¢˜è¿›è¡Œäº†èµ„æ–™æœç´¢å’Œæ€è€ƒã€‚\nå¿…ç­”é¢˜ æˆ‘æŒ‰ç…§å®éªŒè¦æ±‚ç¼–å†™äº† hello.c å¹¶ç¼–å†™ Makefile æ–‡ä»¶è¿›è¡Œç¼–è¯‘ï¼Œå¹¶ä¸”å­¦ä¹ äº† GDB çš„ä½¿ç”¨ã€‚è¿™äº›å†…å®¹æ— æ³•ç›´æ¥å‘ˆç°ï¼Œæ•…çœç•¥ã€‚\nå…³äºã€Šæé—®çš„æ™ºæ…§ã€‹ æˆ‘ä»¬ä»å°è¢«è¦æ±‚å…»æˆæé—®çš„ä¹ æƒ¯ï¼Œæé—®è¢«è®¤ä¸ºæ˜¯æœ‰å¥½å¥‡å¿ƒæˆ–è€…å–„äºæ¢ç´¢çš„è±¡å¾ï¼Œä½†æˆ‘è®¤ä¸ºèƒŒåæœ‰æ€è€ƒçš„æé—®æ‰æ˜¯çœŸæ­£æœ‰ä»·å€¼çš„ã€‚ã€Šæé—®çš„æ™ºæ…§ã€‹ä¸­æåŠäº†å¤§é‡çš„æé—®ç›¸å…³çš„ convention å’ŒæŠ€å·§ï¼Œå…¶æ ¸å¿ƒåŸç†éƒ½æ˜¯æ€è€ƒã€‚\næˆ‘æ›¾åœ¨çŸ¥ä¹ä¸Šçœ‹åˆ°ä¸€å¥è¯ï¼šâ€œé“å¾·æ˜¯ç”¨æ¥çº¦æŸè‡ªå·±çš„ï¼Œä¸æ˜¯ç”¨æ¥çº¦æŸåˆ«äººçš„ã€‚â€è¿™å¥è¯å½“æ—¶è¢«ç”¨æ¥è¯´æ˜ä½ ä¸èƒ½å¼ºæ±‚åˆ«äººå†™ç»™ä½ çœ‹çš„é¢˜è§£åƒå–‚é¥­ä¸€æ ·æ·±å…¥æµ…å‡ºã€‚æˆ‘è§‰å¾—è¿™å¥è¯ç”¨åœ¨æé—®ä¸Šä¹Ÿä¸€æ ·åˆé€‚ã€‚é™¤éä½ èŠ±é’±é›‡äº†ä¸€ä¸ªäººä¸“èŒä¸ºä½ è§£ç­”é—®é¢˜ï¼Œå¦åˆ™åˆ«äººè§£ç­”ä½ çš„é—®é¢˜æ˜¯ä¸€ç§ä¹‰åŠ¡åŠ³åŠ¨ã€‚ä½ æ²¡æœ‰æƒåˆ©æµªè´¹åˆ«äººçš„æ—¶é—´ï¼Œåˆ«äººä¹Ÿæ²¡æœ‰ä¹‰åŠ¡å»å›ç­”ä¸€äº›æ„šè ¢çš„é—®é¢˜æˆ–è€…ç»™ä½ ä¿å§†çº§çš„æ•™ç¨‹ã€‚æˆ‘æ€»ç»“äº†ä¸€äº›ã€Šæé—®çš„æ™ºæ…§ã€‹ä¸­æˆ‘è§‰å¾—æ¯”è¾ƒç²¾åçš„å†…å®¹ç½—åˆ—å¦‚ä¸‹ï¼š\nä¸è¦é—®ä¸€äº›ç›´æ¥ STFW/RTFM å°±èƒ½è½»æ¾è·å¾—ç­”æ¡ˆçš„çŸ¥è¯†æ€§é—®é¢˜ï¼Œä»–ä»¬é€šå¸¸å…·æœ‰ \u0026ldquo;xxxæ˜¯ä»€ä¹ˆï¼Ÿ\u0026quot;â€œxxxæ€ä¹ˆç”¨â€ ç­‰æ ¼å¼ã€‚ ä½œä¸ºä¸€ä¸ªè®¡ç®—æœºç•Œçš„åè¾ˆï¼Œä½ é‡åˆ°çš„é—®é¢˜æœ‰æå¤§çš„æ¦‚ç‡æ˜¯å·²ç»æœ‰æ— æ•°äººé‡åˆ°è¿‡çš„é—®é¢˜ã€‚ä¸€äº›ç»å…¸çš„é—®é¢˜é€šå¸¸å¯ä»¥åœ¨ Stack Overflow ç­‰çŸ¥åå¹³å°ä¸Šæ‰¾åˆ°è§£ç­”ï¼Œæ‰€ä»¥ä½ åº”è¯¥ç¡®ä¿ä½ çš„é—®é¢˜æ²¡æœ‰ç°æˆå¯æŸ¥çš„è§£å†³æ–¹æ¡ˆã€‚ ä½ åº”è¯¥å°½å¯èƒ½è¯¦ç»†åœ°åˆ»ç”»ä½ çš„é—®é¢˜ï¼Œæ¯”å¦‚å†™ä¸‹ä½ å·²ç»ç”¨è¿‡å“ªäº›æ–¹æ³•ä½†å¤±è´¥äº†ï¼Œä¹Ÿå¯ä»¥è´´ä¸€äº›æˆªå›¾ã€‚ä¸€æ–¹é¢ï¼Œæ›´è¯¦ç»†çš„ä¿¡æ¯å¯ä»¥è®©åˆ«äººæ›´å¥½åœ°äº†è§£ä½ çš„æƒ…å†µï¼Œæä¾›å¸®åŠ©ï¼›å¦ä¸€æ–¹é¢ï¼Œè¿™å¯ä»¥ä½“ç°ä½ ä¸ºäº†è§£å†³é—®é¢˜å·²ç»ä»˜å‡ºè¿‡ä½ èƒ½åŠ›èŒƒå›´å†…çš„åŠªåŠ›ã€‚ æœºå™¨æ°¸è¿œæ˜¯å¯¹çš„ï¼Œä¸è¦è¯´â€œæˆ‘è§‰å¾—æˆ‘çš„gccæœ‰é—®é¢˜/æˆ‘è§‰å¾—æˆ‘çš„ç”µè„‘åäº†â€ä¹‹ç±»çš„è¯ï¼ˆè¿™æ˜¯æˆ‘åœ¨å¸®åŠ©ä¸Šâ€œç¨‹åºè®¾è®¡åŸºç¡€â€è¯¾çš„åŒå­¦è§£å†³é—®é¢˜æ—¶ç»å¸¸å¬åˆ°çš„è¯ï¼‰ã€‚å¦å¤–ï¼Œä½ æ‰‹ä¸Šçš„æºç æœ‰å¾ˆå¤§æ¦‚ç‡ç»è¿‡äº†å¾ˆå¤šäººçš„éªŒè¯ï¼Œæ‰€ä»¥ä¸è¦è½»æ˜“å®£å¸ƒè‡ªå·±å‘ç°äº† bugã€‚ ä½œä¸ºä¸€ä¸ªæé—®è€…ä½ ä¸èƒ½æ˜¾å¾—è¶¾é«˜æ°”æ˜‚ï¼Œåœ¨æé—®ä¸­é€‚å½“ä½¿ç”¨å§”å©‰çš„è¯æ±‡å¯ä»¥ä½¿ä½ çš„æ€åº¦æ›´åŠ è¯šæ³ï¼Œä½†ä¹Ÿä¸ç”¨è¿‡åº¦ä½¿ç”¨ä»¥è‡³äºè¯­å¥å†—ä½™ã€‚ å¯¹äºæˆ‘ä»¬è¿™æ ·çš„åˆå­¦è€…æ¥è¯´é—®é¢˜å¯èƒ½è¿˜æ²¡æœ‰é¢†åŸŸä¹‹åˆ†ï¼Œä½†åœ¨æ—¥åå¦‚æœæå‡ºä¸€äº›åˆ†ç±»è¾ƒç»†çš„é—®é¢˜ï¼Œéœ€è¦æ³¨æ„æé—®çš„å¹³å°æ˜¯å¦åˆé€‚ã€‚ æ€»ä¹‹ï¼Œæƒ³è¦æå‡ºä¸€ä¸ªå¥½çš„é—®é¢˜ï¼Œä½ éœ€è¦åœ¨é‡åˆ°å›°éš¾æ—¶å…ˆä¸»åŠ¨è‡ªå·±è§£å†³ï¼Œå°è¯•èƒ½åŠ›èŒƒå›´å†…å¯ä»¥ä½¿ç”¨çš„æ–¹æ³•ï¼Œå¹¶ä¸”åœ¨ä½ çš„æé—®ä¸­å±•ç°è¿™ä¸ªè¿‡ç¨‹ã€‚è¿™æ ·è•´å«äº†ä½ çš„æ€è€ƒçš„é—®é¢˜æ‰æ˜¯æœ‰ä»·å€¼çš„ã€‚\nä»¥ä¸‹æ˜¯æˆ‘çš„è‡ªç”±æŠ¥å‘Šå†…å®¹ï¼Œæˆ‘åœ¨åšå®éªŒçš„è¿‡ç¨‹ä¸­è¯¦ç»†è®°å½•äº†è‡ªå·±é‡åˆ°çš„æ‰€æœ‰é—®é¢˜å’ŒæŸ¥é˜…çš„æ‰€æœ‰èµ„æ–™ã€‚è¿™äº›ç¬”è®°æŒ‰ç…§ç« èŠ‚æ’åˆ—ï¼Œæ¯ç« é€šå¸¸æœ‰ä¸¤ä¸ªéƒ¨åˆ†ï¼š\næ€è€ƒé¢˜ï¼šåŒ…å«ç¬”è€…é’ˆå¯¹æ€è€ƒé¢˜æŸ¥é˜…çš„èµ„æ–™å’Œæˆ‘å°è¯•ç»™å‡ºçš„ç­”æ¡ˆã€‚ è¡¥å……ï¼šè¿™é‡Œçš„å†…å®¹æ˜¯æ²¡æœ‰åœ¨è®²ä¹‰ä¸­æåŠçš„é—®é¢˜ï¼Œä»¥åŠè®²ä¹‰ä¸­å»ºè®®è‡ªå­¦çš„ä¸œè¥¿ã€‚ Installing GNU/Linux è¡¥å…… åœ¨å®‰è£…ç³»ç»Ÿæ—¶é‡åˆ°é—®é¢˜ï¼š\nExecuting grub_install failed. This is a fatal error.\né‡å¯åç›´æ¥è¿›å…¥ GNU/grub å‘½ä»¤è¡Œï¼Œè¯´æ˜ç³»ç»Ÿå¼•å¯¼å‡ºç°äº†é—®é¢˜ã€‚ç»è¿‡æ’æŸ¥å‘ç°ä½¿ç”¨äº†ä¸ç¡¬ç›˜ä¸åŒ¹é…çš„å¼•å¯¼æ–¹å¼ã€‚\nç¡¬ç›˜åˆ†åŒºä¸€èˆ¬æœ‰ä¸¤ç§æ ¼å¼ï¼šMBR å’Œ GPTã€‚å‰è€…æ˜¯ä¼ ç»Ÿçš„æ¨¡å¼ï¼Œåè€…è¾ƒæ–°ã€‚ç¬”è€…å› ä¸ºåœ¨ä¸€å¥—è€å¼ç”µè„‘ä¸­å®‰è£…ç³»ç»Ÿæ‰€ä»¥é‡åˆ°äº†è¿™ç§æ ¼å¼çš„ç¡¬ç›˜ã€‚\nMBR+LegacyBIOS MBRåˆ†åŒºæ ¼å¼ä¸‹æœ€å¤šæ”¯æŒå››ä¸ªä¸»åˆ†åŒºã€‚å¦‚æœæƒ³åˆ’åˆ†æ›´å¤šçš„åˆ†åŒºï¼Œå¯ä»¥å°†å…¶ä¸­ä¸€ä¸ªä¸»åˆ†åŒºå˜ä¸ºæ‰©å±•åˆ†åŒºï¼Œç„¶ååœ¨æ‰©å±•åˆ†åŒºä¸­å»ºç«‹é€»è¾‘åˆ†åŒºã€‚é€»è¾‘åˆ†åŒºä¸€èˆ¬ä» 5 å¼€å§‹ç¼–å·ã€‚å¦å¤– MBR åˆ†åŒºè¡¨å¯¹ç¡¬ç›˜çš„å®¹é‡å¤§å°æœ‰é™åˆ¶ã€‚\nMBR ï¼ˆMaster Boot Recordï¼Œä¸»å¼•å¯¼è®°å½•ï¼‰å­˜æ”¾åœ¨ç¬¬ä¸€ä¸ªæ‰‡åŒºï¼ˆä¸€ä¸ªæ‰‡åŒº512å­—èŠ‚ï¼‰ä¸­ï¼Œè¿™ä¸ªæ‰‡åŒºä¸å±äºä»»ä½•ä¸€ä¸ªåˆ†åŒºã€‚è¿™ä¸ªæ‰‡åŒºä¸­åŒ…å«å¦‚ä¸‹å†…å®¹ï¼š\nBootloaderï¼š446å­—èŠ‚ï¼Œå†…å«å¼•å¯¼ç¨‹åºï¼Œä¸»è¦è´Ÿè´£è¯†åˆ«æ´»åŠ¨åˆ†åŒºå¹¶å¼•å¯¼ç³»ç»Ÿ DPT (Partition Tableï¼Œåˆ†åŒºè¡¨)ï¼š64å­—èŠ‚ï¼Œå­˜å‚¨äº†åˆ†åŒºä¿¡æ¯ Magic Number: 2å­—èŠ‚ï¼Œå›ºå®šä¸º0x55AAï¼Œç»“æŸæ ‡å¿—å­—ã€‚ åˆ†åŒºè¡¨çš„64ä¸ªå­—èŠ‚åˆ†æˆ4ç»„æ¯ç»„16ä¸ªå­—èŠ‚ï¼Œåˆ†åˆ«è®°å½•äº†4ä¸ªä¸»åˆ†åŒºçš„ä¿¡æ¯ã€‚\nPartition Flag (00) Start CHS (01~03) Partition Bytes (04) End CHS (05~07) Start LBA (08~11) Size (12~15) 00: ä¸å¯å¼•å¯¼ 80: å¯ä»¥å¼•å¯¼ åˆ†åŒºå¼€å§‹çš„ CHS å€¼ åˆ†åŒºç±»å‹\n83/linux 82/swap 8e/LVM etc. åˆ†åŒºç»“æŸçš„ CHS å€¼ ç›¸å¯¹çš„èµ·å§‹æ‰‡åŒºå· è¯¥åˆ†åŒºæ‹¥æœ‰çš„æ‰‡åŒºæ•°é‡ CHS å’Œ LBA æ˜¯ä¸¤ç§ä¸åŒçš„ç¡¬ç›˜å¯»å€æ–¹å¼ã€‚\nCHSå¯»å€æ¨¡å¼å°†ç¡¬ç›˜åˆ’åˆ†ä¸ºç£å¤´ (Heads)ï¼ŒæŸ±é¢ (Cylinder) å’Œæ‰‡åŒº (Sector) ã€‚\nç£å¤´ï¼šæ¯å¼ ç£ç›˜çš„æ­£åé¢å„æœ‰ä¸€ä¸ªç£å¤´ï¼Œä¸€ä¸ªç£å¤´å¯¹åº”äº†ä¸€ä¸ªç£é¢ã€‚ æŸ±é¢ï¼šæ‰€æœ‰ç£ç‰‡ä¸­åŠå¾„ç›¸åŒçš„åŒå¿ƒåœ†ç£é“æ„æˆæŸ±é¢ã€‚ æ‰‡åŒºï¼šå°†åœ†ç¯å½¢ç£é“åˆ’åˆ†æˆè‹¥å¹²ä¸ªåŒºæ®µï¼Œå°±æ˜¯æ‰‡åŒºã€‚æ¯ä¸ªæ‰‡åŒºçš„å®¹é‡ä¸º 512 å­—èŠ‚ã€‚ CHS éƒ¨åˆ†å…±ä½¿ç”¨äº† 3 ä¸ªå­—èŠ‚ 24 ä¸ªäºŒè¿›åˆ¶ä½ï¼Œå› æ­¤å¯»å€èŒƒå›´æ˜¯ $2^{24} bit$ ï¼Œçº¦ä¸º 8Gã€‚è¿™ç§æ–¹å¼è¾ƒä¸ºå¤è€ç°åœ¨å·²ç»å‡ ä¹ä¸ç”¨ã€‚\nLBA (Logic Block Addressing) æ¨¡å¼ä¸­åœ°å€ä¸å†è¡¨ç¤ºå®é™…çš„ç‰©ç†åœ°å€ï¼Œè€Œæ˜¯å°† CHS åœ°å€è½¬æ¢æˆä¸€ç§å”¯ä¸€çš„çº¿æ€§åœ°å€ã€‚ç”±äº LBA éƒ¨åˆ†å…±æœ‰ 32 ä¸ªäºŒè¿›åˆ¶ä½ï¼Œå› æ­¤å¯»å€èŒƒå›´æ‰©å¤§åˆ°çº¦ 2.2TBã€‚è¿™å°±æ˜¯å‰æ–‡æ‰€è¯´çš„ MBR ç¡¬ç›˜åˆ†åŒºçš„å®¹é‡é™åˆ¶ï¼Œå¯¹äºæ›´å¤§çš„ç¡¬ç›˜ï¼ŒLBAå¯»å€æ–¹å¼å¹¶ä¸èƒ½è¡¨ç¤ºå…¶åœ°å€ã€‚\nMBRåˆ†åŒºæ ¼å¼çš„ç¡¬ç›˜ä½¿ç”¨ Legacy BIOS æ¥å¼•å¯¼æ“ä½œç³»ç»Ÿã€‚å®‰è£…ç³»ç»Ÿæ—¶åº”å½“åœ¨ BIOS ä¸­è°ƒæ•´å¼•å¯¼æ–¹å¼ä¸º Legacy only æˆ–å°† Legacy æ¨¡å¼çš„ä¼˜å…ˆçº§æ”¾åœ¨ UEFIä¹‹å‰ã€‚\nä»¥ Windows ç³»ç»Ÿä¸ºä¾‹ï¼Œä¼ ç»Ÿ Legacy å¼•å¯¼æ“ä½œç³»ç»Ÿæ—¶ï¼Œä¼šé€šè¿‡æ´»åŠ¨åˆ†åŒºï¼ˆMBRåªå…è®¸æœ‰ä¸€ä¸ªæ´»åŠ¨åˆ†åŒºï¼‰ä¸‹çš„ bootmgrï¼ˆå¯åŠ¨ç®¡ç†å™¨ï¼‰æ–‡ä»¶å¯¼å…¥æ ¹ç›®å½•ä¸‹ boot æ–‡ä»¶å¤¹å†…çš„ BCD æ–‡ä»¶ï¼Œç„¶å BCD æ–‡ä»¶æ ¹æ®è‡ªèº«çš„é…ç½®å†…å®¹åŠ è½½ç³»ç»Ÿå¯åŠ¨æ–‡ä»¶ æ ¹ç›®å½•\\Windows\\system32\\winload.exeæ¥å¯åŠ¨ç³»ç»Ÿã€‚\nLinux ä½¿ç”¨çš„å¼•å¯¼ç¨‹åºæ˜¯ GRUBã€‚\nGPT+UEFI GPTåˆ†åŒºæ ¼å¼æ²¡æœ‰4ä¸ªä¸»åˆ†åŒºçš„é™åˆ¶ï¼Œä¸”æ²¡æœ‰ä¸»åˆ†åŒºã€æ‰©å±•åˆ†åŒºã€é€»è¾‘åˆ†åŒºè¿™äº›æ¦‚å¿µçš„åŒºåˆ†ï¼Œå¯¹äºç¡¬ç›˜çš„å®¹é‡ä¹Ÿï¼ˆå‡ ä¹ï¼‰æ²¡æœ‰é™åˆ¶ã€‚ä¸GPTå¯¹åº”çš„UEFIå¯åŠ¨æ–¹å¼ç›¸è¾ƒäºLegacyBIOSï¼Œçœå»äº†åŠ ç”µè‡ªæ£€çš„ç¯èŠ‚ï¼Œå¯ä»¥æ›´å¿«åœ°å¼•å¯¼ç³»ç»Ÿå¯åŠ¨ï¼Œä¸”ç•Œé¢æ”¯æŒé¼ æ ‡ç”šè‡³è“ç‰™ç­‰ã€‚è¿™éƒ½æ˜¯GPT+UEFIç›¸è¾ƒäºä¼ ç»Ÿçš„æ–¹å¼ä¼˜ç§€çš„åœ°æ–¹ã€‚\nGPTæ ¼å¼çš„ç¡¬ç›˜æœ‰å¦‚ä¸‹éƒ¨åˆ†ï¼š\nPMBR (Protective MBR)ï¼šå æ®ç¬¬ä¸€ä¸ªæ‰‡åŒºï¼Œå…¶ç›®çš„æ˜¯é˜²æ­¢åªèƒ½è¯†åˆ«MBRæ ¼å¼çš„å·¥å…·è¯¯è¯†åˆ«å¹¶å†™å…¥ç¡¬ç›˜ã€‚ Primary GPT Headerï¼šå æ®ç¬¬äºŒä¸ªæ‰‡åŒº Partition Entriesï¼šå æ®ç¬¬ä¸‰ã€ç¬¬å››ä¸ªæ‰‡åŒº Partitions Backup Partition Entries/Primary GPT Headerï¼šå¯¹ä¹‹å‰çš„ä¿¡æ¯è¿›è¡Œå¤‡ä»½ã€‚å¦‚æœè¡¨å¤´é­åˆ°äº†è¯¯åˆ ç­‰æ“ä½œå¯ä»¥åˆ©ç”¨å¤‡ä»½è¿›è¡Œæ¢å¤ï¼Œå¢åŠ äº†å®‰å…¨æ€§ã€‚ UEFIå¼•å¯¼éœ€è¦ç¡¬ç›˜ä¸­æœ‰ä¸€ä¸ª EFI åˆ†åŒºã€‚EFI åˆ†åŒºä¸­å­˜æ”¾äº†å¼•å¯¼ç¨‹åºï¼Œå¦‚ Windows çš„ bootmgfw.efiï¼ŒLinux çš„ grubx64.efi ç­‰ã€‚\nè£…æœºæ³¨æ„äº‹é¡¹ ä¸ºäº†åŒæ—¶å…¼å®¹ MBR å’Œ GPT å‹çš„ç¡¬ç›˜ï¼Œç°åœ¨çš„ BIOS åŒæ—¶æä¾› Legacy å’Œ UEFI ä¸¤ç§å¯åŠ¨æ–¹å¼ï¼Œå› æ­¤éœ€è¦æ ¹æ®ç¡¬ç›˜å°† BIOS/UEFI è°ƒæ•´åˆ°æ­£ç¡®çš„æ¨¡å¼ã€‚å¯¹äº MBR å‹çš„ç¡¬ç›˜ï¼Œä¸éœ€è¦åˆ›å»º EFI åˆ†åŒºï¼ˆå®‰è£… Linux çš„æ—¶å€™ä¼šè­¦å‘Šä½ æ²¡æœ‰åˆ›å»º EFIï¼Œä½†æ²¡å…³ç³»ï¼‰ï¼Œæœ€åçš„å¯åŠ¨åˆ†åŒºé»˜è®¤å³å¯ã€‚å¯¹äº GPT å‹çš„ç¡¬ç›˜ï¼Œå¯ä»¥ä¸ºæ–°ç³»ç»Ÿåˆ›å»ºå•ç‹¬çš„ EFI åˆ†åŒºï¼Œä¹Ÿå¯ä»¥ä¸è€ç³»ç»Ÿå…±ç”¨ EFI åˆ†åŒºï¼Œä½†å¾—ä¿è¯æœ‰ EFI åˆ†åŒºã€‚å¦‚æœå¯åŠ¨åˆ†åŒºé€‰æ‹©äº† Linux çš„ EFI åˆ†åŒºï¼Œå°†ç”± Linux å¼•å¯¼ Windowsï¼Œåœ¨ GNU/GRUB ç•Œé¢ä¸Šå¯ä»¥é€‰æ‹© Ubuntu æˆ–è€… Windows Boot Managerã€‚\nFirst Exploration with GNU/Linux æ€è€ƒé¢˜ Why executing the poweroff command requires superuser privilege?\nCan you provide a scene where bad things will happen if the poweroff command does not require superuser privilege?\nä¾‹å¦‚æˆ‘æœ‰ä¸€å°æœåŠ¡å™¨ï¼Œæˆ‘ä½œä¸ºæœåŠ¡å™¨çš„ç®¡ç†è€…å¯ä»¥ç”¨rootçš„æƒé™å¯¹ç½‘ç«™è¿›è¡Œä¿®æ”¹æ“ä½œã€‚ç½‘ç«™çš„ä½¿ç”¨è€…æ³¨å†Œè´¦å·ä¹‹åå¯ä»¥ç”¨æ™®é€šè´¦æˆ·æ¥è®¿é—®å…è®¸èŒƒå›´å†…çš„èµ„æºã€‚å¦‚æœæ™®é€šè´¦æˆ·æ‹¥æœ‰è¿‡å¤§çš„æƒé™ä»¥è‡³äºå¯ä»¥ä¿®æ”¹æœåŠ¡å™¨çš„ç³»ç»Ÿæ–‡ä»¶ç”šè‡³ç›´æ¥å…³æœºï¼Œé‚£ä¹ˆç½‘ç«™å°†ç›´æ¥å´©æºƒã€‚\nInstalling Tools è¡¥å…… åœ¨å®‰è£…è½¯ä»¶åŒ…çš„è¿‡ç¨‹ä¸­é‡åˆ°ä¾èµ–é—®é¢˜æ— æ³•å®‰è£…ï¼Œè¿™æ˜¯å› ä¸ºå½“å‰éœ€è¦å®‰è£…çš„è½¯ä»¶åŒ…ä¾èµ–å…¶ä»–è½¯ä»¶åŒ…ï¼Œè€Œå…¶ä»–è½¯ä»¶åŒ…åœ¨å½“å‰çš„æºä¸Šæ‰¾ä¸åˆ°ã€‚æˆ‘ä»¬å¯ä»¥æ·»åŠ æ›´å¤šçš„ Ubuntu æºï¼Œä»è€Œæä¾›å…¶ä»–è½¯ä»¶åŒ…çš„èµ„æºã€‚\nä¾‹å¦‚ä½¿ç”¨æ¸…åå¤§å­¦çš„æºï¼Œåœ¨ /etc/apt/sources.list ä¸­æ·»åŠ å¦‚ä¸‹è¯­å¥ï¼š\ndeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ hirsute main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ hirsute-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ hirsute-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ hirsute-security main restricted universe multiverse æ‰§è¡Œ sudo apt-get update ä¹‹åå†ä¸‹è½½è½¯ä»¶åŒ…ï¼Œå³å¯æ­£å¸¸è¿›è¡Œã€‚\nConfiguring Vim Vim çš„ Recording åŠŸèƒ½ Recording åŠŸèƒ½å¯ä»¥å¸®åŠ©æˆ‘ä»¬å®Œæˆé‡å¤å·¥ä½œã€‚ä»¥è®²ä¹‰ä¸­çš„ç¤ºä¾‹ä¸ºä¾‹ï¼Œæ¬²è¾“å‡º\n1 2 ... 100 åªéœ€ä¾æ¬¡æŒ‰ä¸‹ i1\u0026lt;ESC\u0026gt;q1yyp\u0026lt;C-a\u0026gt;q98@1 å³å¯ã€‚\næŒ‰ q å†æŒ‰ä¸‹ä»»æ„ä¸€ä¸ªå­—ç¬¦ä¹‹åè¿›å…¥ Recording æ¨¡å¼ã€‚è¿™é‡Œçš„å­—ç¬¦ç›¸å½“äºä¸€ä¸ªç¼“å†²å™¨åï¼Œè¡¨ç¤ºæ¥ä¸‹æ¥å½•åˆ¶çš„è¿™æ®µåŠ¨ä½œå°†ä¿å­˜åœ¨è¿™ä¸ªç¼“å†²å™¨ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ä¸åŒçš„ç¼“å†²å™¨ä¸­å½•åˆ¶ä¸åŒçš„åŠ¨ä½œã€‚åœ¨ç¤ºä¾‹ä¸­ï¼ŒåŠ¨ä½œè¢«å­˜å…¥äº†ç¼“å†²å™¨ 1 ä¸­ã€‚\næ¥ä¸‹æ¥ yy å‘½ä»¤æ˜¯å¤åˆ¶å…‰æ ‡æ‰€åœ¨è¡Œæ•´è¡Œï¼Œp å‘½ä»¤æ˜¯å°†å‰ªè´´æ¿å†…å®¹ç²˜è´´åˆ°å½“å‰å…‰æ ‡ä¸‹ä¸€è¡Œå¹¶ä¸”å°†å…‰æ ‡ç§»åŠ¨åˆ°ä¸‹ä¸€è¡Œã€‚\u0026lt;C-a\u0026gt;/\u0026lt;C-x\u0026gt; æ“ä½œå¯ä»¥è¿›è¡Œç®€å•çš„ç®—æ•°è¿ç®—ï¼Œå¯¹æ•´æ•°è¿›è¡Œ+1/-1ã€‚\nå†æŒ‰ä¸€æ¬¡ q ç»“æŸå½“å‰å½•åˆ¶ã€‚æƒ³è¦ä½¿ç”¨ä¹‹å‰çš„åŠ¨ä½œåºåˆ—æ—¶ï¼Œå…ˆç›´æ¥æŒ‰ä¸‹éœ€è¦æ‰§è¡Œçš„æ¬¡æ•°ï¼Œç„¶åæŒ‰ä¸‹ @ ï¼Œå†æŒ‰ä¸‹æŒ‡å®šçš„ç¼“å†²å™¨åå³å¯ã€‚æœ¬ä¾‹ä¸­æˆ‘ä»¬ç›´æ¥è¾“å…¥äº†1ï¼Œåœ¨å½•åˆ¶å®çš„è¿‡ç¨‹ä¸­å®Œæˆäº†2ï¼Œå› æ­¤åªéœ€è¦å†æ‰§è¡Œ98æ¬¡ã€‚\nVim çš„ Visual Block æ¨¡å¼ Visual Block æ¨¡å¼å¯ä»¥å¸®åŠ©æˆ‘ä»¬å¯¹æ–‡æœ¬è¿›è¡Œæ‰¹é‡æ“ä½œã€‚ä»¥è®²ä¹‰ä¸­çš„ç¤ºä¾‹ä¸ºä¾‹ï¼Œæ¬²å°†ä¸‹é¢ç‰‡æ®µæ¯è¡Œå·¦å³å¯¹è°ƒ\naaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbb cccccccccccccccccccccccccddddddddddddddddddddddddd eeeeeeeeeeeeeeeeeeeeeeeeefffffffffffffffffffffffff ggggggggggggggggggggggggghhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiijjjjjjjjjjjjjjjjjjjjjjjjj åªéœ€ä¾æ¬¡è¾“å…¥ gg\u0026lt;C-v\u0026gt;24l4jd$p å³å¯ã€‚\ngg å‘½ä»¤å¯ä»¥å°†å…‰æ ‡ç§»åŠ¨åˆ°æ–‡æœ¬å¼€å¤´ã€‚æŒ‰ä¸‹ \u0026lt;C-v\u0026gt; è¿›å…¥ Visual Block æ¨¡å¼ã€‚ 24l4j å°†å…‰æ ‡å‘å³ç§»åŠ¨24æ ¼ä¹‹åå†å‘ä¸‹ç§»åŠ¨4æ ¼ï¼Œä»è€Œé€‰ä¸­äº†å·¦è¾¹ä¸€æ•´å—æ‰€æœ‰å­—ç¬¦ã€‚d æ“ä½œåˆ é™¤é€‰ä¸­çš„éƒ¨åˆ†ï¼Œå¹¶å°†åˆ é™¤çš„å†…å®¹æ”¾å…¥å‰ªè´´æ¿ã€‚$ å‘½ä»¤å°†å…‰æ ‡ç§»åŠ¨åˆ°è¡Œæœ«ï¼ˆä¸æ”¹å˜å½“å‰çš„ normal æ¨¡å¼ï¼‰,p ç²˜è´´ï¼Œä»è€Œå®Œæˆä»»åŠ¡ã€‚\nGNU Diff Format å¯ä»¥å‚ç…§ è¿™ä¸ªæ–‡æ¡£ æ¥è¯¦ç»†äº†è§£ GNU diff formatã€‚\næ³¨æ„ï¼šè¿™ç§æ ¼å¼åªæ˜¯ä¸€ç§ä¸¥è°¨è§„èŒƒåœ°å‘ä»–äººæè¿°ä¿®æ”¹å†…å®¹çš„æ–¹æ³•ï¼Œå¹¶ä¸æ˜¯è¦å°†è¿™äº›å†…å®¹ç›´æ¥å†™å…¥è¦ä¿®æ”¹çš„æ–‡ä»¶ï¼\nè¡¥å…… è‹¥ä½¿ç”¨è®²ä¹‰ä¸­çš„æ–¹æ³•ç›´æ¥å°† /etc/vim/vimrc å¤åˆ¶åˆ° ~/.vimrcï¼Œæˆ‘ä»¬åœ¨ç¼–è¾‘ä¿å­˜çš„æ—¶å€™ä¼šé‡åˆ°ä¸€äº›æƒé™é—®é¢˜ã€‚\nä½¿ç”¨ ls -l -a | grep vimrc å‘½ä»¤æŸ¥çœ‹ ~/.vimrc çš„è¯¦ç»†ä¿¡æ¯ï¼Œå¯ä»¥çœ‹åˆ°å…¶æƒé™ä¿¡æ¯ä¸º -rw-r--r--ï¼Œè¿™è¯´æ˜é™¤äº†åˆ›å»ºè€… root ä¹‹å¤–åˆ«çš„ç”¨æˆ·å¯¹è¯¥æ–‡ä»¶æ²¡æœ‰å†™å…¥çš„æƒé™ã€‚æˆ‘ä»¬å¯ä»¥ç”¨ sudo chmod 664 ~/.vimrc å‘½ä»¤å°†å…¶æƒé™ä¿®æ”¹ä¸º -rw-rw-r-- æ¥è§£å†³é—®é¢˜ã€‚\nMore Exploration æ€è€ƒé¢˜ æ¶ˆå¤±çš„cd\nä¸ºä»€ä¹ˆä¸Šè¿°åŸºæœ¬å‘½ä»¤é™¤äº† cd ä¹‹å¤–éƒ½èƒ½æ‰¾åˆ°å®ƒä»¬çš„ manpage?\ncd å¹¶ä¸æ˜¯ä¸€æ¡æŒ‡ä»¤ï¼Œå¦‚æœåœ¨ç»ˆç«¯ä¸­è¾“å…¥ type cd æˆ‘ä»¬ä¼šå¾—åˆ° â€œcd is a shell builtinâ€ã€‚\nThings Behind Scrolling\nWhy the original terminal cannot be scrolled? How does tmux make the terminals scrollable? How to implement a scroll bar?\nç•™å‘ã€‚ç›²çŒœæœ€åŸºæœ¬çš„æ»šè½®åŠŸèƒ½æ˜¯æ»šä¸€æ ¼å‘ä¸Š/ä¸‹ç§»åŠ¨ $x$ è¡Œï¼Œæ¬²å®ç°æ»šè½®éœ€è¦å°†ç»ˆç«¯å†…çš„å†å²å‘½ä»¤å’Œè¾“å‡ºä¿å­˜ä¸‹æ¥ã€‚\nè¡¥å…… æ­£åˆ™è¡¨è¾¾å¼çš„æœ€åŸºæœ¬è¯­æ³• [] è¯­æ³•\næ­£åˆ™è¡¨è¾¾å¼ å«ä¹‰åŠå…¶è¯´æ˜ oo oo [abcd]oo aoo/boo/coo/doo\n[] è¡¨ç¤ºåŒ¹é…ä¸€ä¸ªå­—ç¬¦ [^ef]oo xooï¼Œxä¸ä¸ºeå’Œf\n^ æ˜¯å–åç¬¦å·ï¼Œä¸”å–åä¸­æ‹¬å·å†…æ‰€æœ‰åˆ—å‡ºçš„å­—ç¬¦ã€‚ è¡Œé¦–è¡Œæœ«åŒ¹é… ^ $\næ­£åˆ™è¡¨è¾¾å¼ å«ä¹‰åŠå…¶è¯´æ˜ ^[^A-Z] é¦–å­—ç¬¦ä¸æ˜¯å¤§å†™å­—æ¯çš„è¡Œ\næ³¨æ„ ^ åœ¨ä¸­æ‹¬å·ä¸­è¡¨ç¤ºå–åï¼Œä¸åœ¨ä¸­æ‹¬å·ä¸­è¡¨ç¤ºè¡Œé¦– \\.$ ä»¥ . ç»“å°¾çš„è¡Œ\næ³¨æ„ . æœ‰ç‰¹æ®Šå«ä¹‰ï¼Œè¦ç”¨ \\ è½¬ä¹‰ã€‚ ^$ ç©ºç™½è¡Œ ä»»æ„å­—ç¬¦ .ï¼Œé‡å¤å­—ç¬¦ *\næ­£åˆ™è¡¨è¾¾å¼ å«ä¹‰åŠå…¶è¯´æ˜ g..d é•¿åº¦ä¸º4çš„ä»¥gå¼€å¤´dç»“å°¾çš„ä¸²\n. è¡¨ç¤ºâ€œä¸€å®šè¦æœ‰ä¸€ä¸ªå­—ç¬¦â€ ooo* ä¸¤ä¸ªä»¥åŠæ›´å¤šçš„o\n* è¡¨ç¤ºå°†ä¹‹å‰çš„ä¸€ä¸ªå­—ç¬¦é‡å¤é›¶æ¬¡æˆ–è‹¥å¹²æ¬¡ go.*g ä»¥goå¼€å¤´gç»“å°¾çš„å•è¯ï¼Œä¸­é—´å¯ä»¥æœ‰ä»»æ„çš„å­—ç¬¦ï¼ˆä¹Ÿå¯ä»¥ä¸ºç©ºï¼‰ [0-9][0-9]* ä»»æ„æ•°å­— é™å®šæ¬¡æ•° {}\næ­£åˆ™è¡¨è¾¾å¼ å«ä¹‰åŠå…¶è¯´æ˜ o\\{2\\} oè¿ç»­å‡ºç°ä¸¤æ¬¡ï¼Œå³oo\næ³¨æ„ä½¿ç”¨ {} ä¸€å®šè¦è½¬ä¹‰ o\\{2,5\\} oå‡ºç°ä¸¤æ¬¡åˆ°äº”æ¬¡ä¹‹é—´ï¼Œå³oo/ooo/oooo/ooooo go\\{2,\\}d å¼€å¤´æ˜¯gç»“å°¾æ˜¯d,ä¸­é—´å‡ºç°äº†ä¸¤æ¬¡åŠä»¥ä¸Šçš„o æ‰©å±•æ­£åˆ™è¡¨è¾¾å¼è¯­æ³•\næ­£åˆ™è¡¨è¾¾å¼ å«ä¹‰åŠå…¶è¯´æ˜ go+d å¼€å¤´æ˜¯gç»“å°¾æ˜¯dï¼Œä¸­é—´å‡ºç°äº†ä¸€æ¬¡åŠä»¥ä¸Šçš„o\n+ è¡¨ç¤ºå‰ä¸€ä¸ªå­—ç¬¦å‡ºç°äº†è‹¥å¹²æ¬¡ï¼ˆä¸ * çš„åŒºåˆ«æ˜¯éé›¶ï¼‰ go?d gdæˆ–god\n? è¡¨ç¤ºå‰ä¸€ä¸ªå­—ç¬¦é‡å¤é›¶æ¬¡æˆ–ä¸€æ¬¡ gd|god gdæˆ–god\n| è¡¨ç¤ºæˆ– g(la|oo)d glad/good\n() é‡Œå¯ä»¥ç½—åˆ—è‹¥å¹²ä¸ªä¸²å¹¶ç”¨ | åˆ†éš”å¼€ A(xyz)+B å¼€å¤´æ˜¯Aç»“å°¾æ˜¯Bä¸­é—´æœ‰ä¸€ä¸ªæˆ–å¤šä¸ªxyz\n()+ è¡¨ç¤ºæ‹¬å·ä¸­çš„ç¾¤ç»„é‡å¤ä¸€æ¬¡æˆ–å¤šæ¬¡ Standard Streams In Computer Programming, standard streams are interconnected input and ouput communication channel between a computer program and its environment when it begins execution. (From Wikipedia)\næ ‡å‡†æµåŒ…æ‹¬ä¸‰ä¸ªï¼šæ ‡å‡†è¾“å…¥ (stdin, 0)ï¼Œæ ‡å‡†è¾“å‡º (stdout, 1) å’Œæ ‡å‡†é”™è¯¯ (stderr, 2)ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œæ ‡å‡†è¾“å…¥æ˜¯é€šè¿‡é”®ç›˜è¾“å…¥ï¼Œæ ‡å‡†è¾“å‡ºå’Œæ ‡å‡†é”™è¯¯éƒ½æ˜¯ç›´æ¥æ‰“å°åœ¨ç»ˆç«¯ä¸Šé€šè¿‡å±å¹•æ˜¾ç¤ºã€‚å¯ä»¥é€šè¿‡é‡å®šå‘ (redirection) æˆ–ç®¡é“ ï¼ˆpipelineï¼‰æ¥ä¿®æ”¹æ ‡å‡†æµã€‚æ­¤å¤–ï¼Œå­è¿›ç¨‹ç»§æ‰¿çˆ¶è¿›ç¨‹çš„æ ‡å‡†æµã€‚\nå…³äº find å’Œ xargs å‘½ä»¤ åœ¨ Linux å…¥é—¨æ•™ç¨‹ä¸­æåˆ°ä½¿ç”¨ find . | grep '\\.c$|\\.h$' | xargs wc -l æ¥ç»Ÿè®¡ä»£ç çš„è¡Œæ•°ã€‚ç¬”è€…åœ¨æœ¬åœ°ç›´æ¥ä½¿ç”¨è¯¥å‘½ä»¤æ—¶æŠ¥é”™ï¼šxargs: unmatched single quoteã€‚æŸ¥é˜…èµ„æ–™å¾—çŸ¥è¿™æ˜¯å› ä¸ºæ–‡ä»¶åä¸­æœ‰å¥‡æ•°ä¸ªå•å¼•å·ã€‚ä¸æ­¤åŒæ—¶ï¼Œæ–‡ä»¶åä¸­çš„ç©ºæ ¼ã€æ–œæ ç­‰ç‰¹æ®Šå­—ç¬¦ä¹Ÿä¼šå¯¼è‡´è¯†åˆ«é”™è¯¯ã€‚\né…åˆä½¿ç”¨ find å‘½ä»¤çš„ -print0 å‚æ•°å’Œ xargs å‘½ä»¤çš„ -0 å‚æ•°å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚å®ƒä»¬çš„ä½œç”¨æ˜¯ç”¨ä¸€ä¸ª null character æ¥ä»£æ›¿ç©ºæ ¼åˆ†éš”æ–‡ä»¶åï¼ŒåŒæ—¶å¯ä»¥è§£å†³æ–‡ä»¶åä¸­çš„ç©ºæ ¼ï¼Œæ–œæ ç­‰é—®é¢˜ã€‚ä½†æˆ‘ä»¬å‘ç° find . -print0 çš„ç»“æœé€ç»™ grep æ— æ³•æ­£å¸¸åœ°å®Œæˆç­›é€‰ã€‚\næˆ‘ä»¬å‘ç° find å‘½ä»¤è‡ªå¸¦æ–‡ä»¶åç­›é€‰åŠŸèƒ½ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ -name '*.cpp' è¿™ä¸ªé€‰é¡¹æ¥ç­›é€‰å‡ºæ‰€æœ‰ .cpp æ–‡ä»¶ï¼Œè¿™æ ·ä½¿ç”¨å‘½ä»¤\nfind . -name '*.cpp' -print0 | xargs -0 wc -l å¯ä»¥å®Œæˆæ‰€æœ‰ .cpp æ–‡ä»¶çš„ä»£ç è¡Œæ•°ç»Ÿè®¡ï¼Œè¦æ³¨æ„ -name é€‰é¡¹åçš„æ–‡ä»¶åå¹¶ä¸æ”¯æŒå®Œæ•´çš„æ­£åˆ™è¡¨è¾¾å¼è¯­æ³•ï¼Œæ ¹æ®æ‰‹å†Œï¼Œå®ƒåªæ”¯æŒ * ? å’Œ [] è¯­æ³•ã€‚\nå¦‚æœæ‰§æ„æƒ³ä½¿ç”¨ grep å‘½ä»¤çš„è¯ï¼Œæˆ‘ä»¬å¯ä»¥æ¢ä¸€ä¸ªæ€è·¯æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼šç»™æ–‡ä»¶ååŠ ä¸ŠåŒå¼•å·æ¥è§£å†³ç‰¹æ®Šå­—ç¬¦ã€‚\nfind . -printf '\u0026quot;%p\u0026quot;\\n' | grep '\\.cpp\u0026quot;$' | xargs wc -l -printf å‚æ•°åè·Ÿ %p å¯ä»¥è¾“å‡ºæ–‡ä»¶åï¼Œæˆ‘ä»¬å°†æ‰€æœ‰çš„æ–‡ä»¶åç”¨åŒå¼•å·æ‹¬èµ·æ¥ï¼ŒåŠ ä¸€ä¸ªæ¢è¡Œç¬¦ï¼Œå°±å¯ä»¥è®© find åœ¨æ ‡å‡†è¾“å‡ºä¸­å°†æ–‡ä»¶åå¸¦å¼•å·åœ°åˆ†è¡Œè¾“å‡ºï¼Œæ³¨æ„æ­¤æ—¶ grep æŒ‡ä»¤éœ€è¦åŒ¹é…è¡Œå°¾çš„ \u0026quot; ã€‚\n/dev/null , /dev/zero å’Œ /dev/random /dev/null æ˜¯ä¸€ä¸ªåªå†™æ–‡ä»¶ã€‚å¦‚æœä½¿ç”¨ cat /dev/null æŸ¥çœ‹æ–‡ä»¶å†…å®¹ä¼šå¾—åˆ°ç©ºã€‚é€šå¸¸å¯ä»¥é€šè¿‡å°†æ ‡å‡†è¾“å‡ºé‡å®šå‘åˆ° /dev/null çš„æ–¹æ³•æ¥åƒæ‰ä½ ä¸æƒ³è¦çš„è¾“å‡ºå†…å®¹ã€‚è™½ç„¶æ— æ³•å†™å…¥ï¼Œä½†åœ¨å†™å…¥æ—¶å®ƒä¼šè¿”å›ç»™ä½ å†™å…¥æˆåŠŸã€‚\n/dev/zero åœ¨è¯»å–æ—¶ä¼šæä¾›æ— é™çš„ç©ºå­—ç¬¦ã€‚å¯ä»¥ç”¨æ¥è¦†ç›–æ–‡ä»¶å†…å®¹æˆ–äº§ç”Ÿç‰¹å®šå¤§å°çš„ç©ºæ–‡ä»¶ã€‚\ndev/random åœ¨è¯»å–æ—¶ä¼šäº§ç”Ÿæ°¸ä¸ä¸ºç©ºçš„éšæœºå­—èŠ‚æ•°æ®æµã€‚\nå¯¹äºè¿™äº›ç‰¹æ®Šæ–‡ä»¶å®ç°æ–¹å¼çš„ä¸€ä¸ªç®€å•è§£é‡Šæ˜¯ï¼Œä¾‹å¦‚ /dev/null ,å½“å†…æ ¸æ¥æ”¶åˆ°å¯¹è¿™ä¸ªæ–‡ä»¶çš„è¯·æ±‚æ—¶ï¼Œä¸éœ€è¦è¿›è¡Œä»»ä½•çœŸå®çš„ç¡¬ä»¶æ“ä½œï¼Œç›´æ¥æŒ‰ç…§APIè¿”å›å†™å…¥æˆåŠŸå³å¯ã€‚\nMakefile Makefileæœ€ç®€å•çš„ä¸€ç‚¹è¯­æ³•ï¼š\nè¦ç”Ÿæˆçš„æ–‡ä»¶å:ä¾èµ–æ–‡ä»¶åˆ—è¡¨ ç”¨äºç”Ÿæˆç›®æ ‡æ–‡ä»¶çš„å‘½ä»¤åºåˆ— å¦‚æœè¿ç»­å¤šæ¬¡æ‰§è¡Œ make ï¼Œä¼šå¾—åˆ°ä¿¡æ¯ \u0026lsquo;xxx is up to date\u0026rsquo;ã€‚è¿™æ˜¯ make ç¨‹åºæ™ºèƒ½ç®¡ç†çš„åŠŸèƒ½ï¼Œå¦‚æœç›®æ ‡æ–‡ä»¶å·²ç»å­˜åœ¨ä¸”ä¿®æ”¹æ—¶é—´åäºå…¶ä¾èµ–çš„æ‰€æœ‰æ–‡ä»¶ï¼Œmake ä¼šè®¤ä¸ºè¿™ä¸ªæ–‡ä»¶å·²ç»ç¼–è¯‘è¿‡äº†ï¼Œä¸éœ€è¦é‡æ–°ç¼–è¯‘ã€‚\nï¼ˆå³ä½¿è¿™ä¸ªæ–‡ä»¶å¹¶ä¸æ˜¯æŒ‰ç…§å‘½ä»¤è¦æ±‚ç”Ÿæˆçš„ï¼Œå¦‚åœ¨å½“å‰ç›®å½•ä¸‹æœ‰æ–‡ä»¶ hello.c å’Œ Makefileã€‚Makefile çš„å†…å®¹å¦‚ä¸‹ï¼š\nhello:hello.c gcc hello.c -o hello æ­¤æ—¶ç”¨ touch hello æŒ‡ä»¤åˆ›å»ºä¸€ä¸ªä¿®æ”¹æ—¶é—´æœ€æ–°çš„ hello ç©ºæ–‡ä»¶å†æ‰§è¡Œ make ï¼Œä»ç„¶æ˜¾ç¤º â€˜hello is up to dateâ€™ã€‚ï¼‰\nä½¿ç”¨è¯­å¥ :PHONY xxx å¯ä»¥å°† xxx å˜æˆä¸€ä¸ªä¼ªç›®æ ‡ï¼Œè¿™æ ·ä»¥ååœ¨æ‰§è¡Œ make xxx æ—¶ä¸ä¼šå†æ£€æŸ¥æ–‡ä»¶ xxx çš„æ–°æ—§ï¼Œè€Œæ˜¯ç›´æ¥æ‰§è¡Œ xxx è§„åˆ™ä¸‹çš„å‘½ä»¤ã€‚\nGetting Source Code for PAs æ€è€ƒé¢˜ What happened? You should know how a program is generated in the ç¨‹åºè®¾è®¡åŸºç¡€ course. But do you have any idea about what happened when a bunch of information is output to the screen during make is executed?\nç•™å‘ã€‚\nè¡¥å…… Gitä½¿ç”¨ - å…³äº SSH Key çš„è®¾ç½® å¦‚æœæƒ³è¦å‘è¿œç¨‹ä»“åº“æäº¤ä¿®æ”¹ï¼Œå¿…é¡»å°†æœ¬æœºçš„ SSH Key æ·»åŠ åˆ°å—ä¿¡ä»»çš„ SSH Key åˆ—è¡¨ä¸­ã€‚\nå¦‚æœæœ¬åœ°æ²¡æœ‰ SSH Keyï¼Œå¯ä»¥ä½¿ç”¨å‘½ä»¤ ssh-keygen -t rsa -C \u0026quot;email\u0026quot; å‘½ä»¤æ¥ç”Ÿæˆ SSH Keyï¼Œå…¶ä¸­ email æ˜¯åœ¨ git config --global user.email ä¸­å¡«å†™çš„é‚®ç®±ã€‚é»˜è®¤ç”Ÿæˆä½ç½®åœ¨ ~/.ssh ä¸­ã€‚ç”Ÿæˆåå°†å…¬é’¥ ~/.ssh/id_rsa.pub ä¸­çš„å†…å®¹å¡«å†™åˆ°å—ä¿¡ä»» SSH Key åˆ—è¡¨ä¸­å³å¯ã€‚\nå…³äº make menuconfig çš„æŠ¥é”™ åœ¨ ics2021/nemu ä¸‹ä½¿ç”¨å‘½ä»¤ï¼šmake menuconfigï¼ŒæŠ¥é”™ bison: No such file or directory ã€‚\næŠ¥é”™æ˜¯å› ä¸ºç¼ºå°‘ bison å·¥å…·ï¼Œå®‰è£…å³å¯ã€‚å¯¹äºä¹‹åçš„ flex å·¥å…·ä¹Ÿæ˜¯äº¦ç„¶ã€‚\næ³¨ï¼šå½“ä½ ç¼ºå°‘æŸé¡¹å·¥å…·æ—¶ï¼Œä¸ä¸€å®šä¼šè¿”å› command not foundï¼Œä¹Ÿå¯èƒ½ä¼šè¿”å› No such file or directory!\nå…³äºè½¯ä»¶å®‰è£…çš„æŠ¥é”™ åœ¨ä½¿ç”¨ apt-get install å®‰è£…è½¯ä»¶æ—¶è‹¥å‡ºç°å½¢å¦‚ä»¥ä¸‹çš„é”™è¯¯ï¼š\nE: Failed to fetch http://mirrors.tuna.tsinghua.edu.cn/ubuntu/pool/main/f/flex/flex_2.6.4-8_amd64.deb Connection timed out [IP: 2402:f000:1:400::2 80] E: Unable to fetch some archives, maybe run apt-get update or try with --fix-missing? è™½ç„¶å¯èƒ½æ˜¯æºä¸­æ²¡æœ‰å¯¹åº”çš„ packageï¼Œä½† Connection timed out ä¹Ÿå¯èƒ½æ˜¯å› ä¸ºç½‘é€Ÿä¸è¡Œï¼Œé‡æ–°å®‰è£…ä¸€æ¬¡ä¹Ÿè®¸å°±å¯ä»¥è§£å†³ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"aade78eb8532dd9428d8481a01e9babc","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-ics/pa/pa0/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/nju-ics/pa/pa0/","section":"notes","summary":"å®éªŒè¿›åº¦ æˆ‘å®Œæˆäº†æ‰€æœ‰å®‰è£…ä»»åŠ¡ï¼Œå®Œæˆäº†å¿…ç­”é¢˜ï¼Œå¹¶é’ˆå¯¹æ€è€ƒé¢˜å’Œé‡åˆ°çš„å…¶ä»–é—®é¢˜è¿›è¡Œäº†èµ„æ–™æœç´¢å’Œæ€è€ƒã€‚\nå¿…ç­”é¢˜ æˆ‘æŒ‰ç…§å®éªŒè¦æ±‚ç¼–å†™äº† hello.c å¹¶ç¼–å†™ Makefile æ–‡ä»¶è¿›è¡Œç¼–è¯‘ï¼Œå¹¶ä¸”å­¦ä¹ äº† GDB çš„ä½¿ç”¨ã€‚è¿™äº›å†…å®¹æ— æ³•ç›´æ¥å‘ˆç°ï¼Œæ•…çœç•¥ã€‚\nå…³äºã€Šæé—®çš„æ™ºæ…§ã€‹ æˆ‘ä»¬ä»å°è¢«è¦æ±‚å…»æˆæé—®çš„ä¹ æƒ¯ï¼Œæé—®è¢«è®¤ä¸ºæ˜¯æœ‰å¥½å¥‡å¿ƒæˆ–è€…å–„äºæ¢ç´¢çš„è±¡å¾ï¼Œä½†æˆ‘è®¤ä¸ºèƒŒåæœ‰æ€è€ƒçš„æé—®æ‰æ˜¯çœŸæ­£æœ‰ä»·å€¼çš„ã€‚ã€Šæé—®çš„æ™ºæ…§ã€‹ä¸­æåŠäº†å¤§é‡çš„æé—®ç›¸å…³çš„ convention å’ŒæŠ€å·§ï¼Œå…¶æ ¸å¿ƒåŸç†éƒ½æ˜¯æ€è€ƒã€‚\næˆ‘æ›¾åœ¨çŸ¥ä¹ä¸Šçœ‹åˆ°ä¸€å¥è¯ï¼šâ€œé“å¾·æ˜¯ç”¨æ¥çº¦æŸè‡ªå·±çš„ï¼Œä¸æ˜¯ç”¨æ¥çº¦æŸåˆ«äººçš„ã€‚â€è¿™å¥è¯å½“æ—¶è¢«ç”¨æ¥è¯´æ˜ä½ ä¸èƒ½å¼ºæ±‚åˆ«äººå†™ç»™ä½ çœ‹çš„é¢˜è§£åƒå–‚é¥­ä¸€æ ·æ·±å…¥æµ…å‡ºã€‚æˆ‘è§‰å¾—è¿™å¥è¯ç”¨åœ¨æé—®ä¸Šä¹Ÿä¸€æ ·åˆé€‚ã€‚é™¤éä½ èŠ±é’±é›‡äº†ä¸€ä¸ªäººä¸“èŒä¸ºä½ è§£ç­”é—®é¢˜ï¼Œå¦åˆ™åˆ«äººè§£ç­”ä½ çš„é—®é¢˜æ˜¯ä¸€ç§ä¹‰åŠ¡åŠ³åŠ¨ã€‚ä½ æ²¡æœ‰æƒåˆ©æµªè´¹åˆ«äººçš„æ—¶é—´ï¼Œåˆ«äººä¹Ÿæ²¡æœ‰ä¹‰åŠ¡å»å›ç­”ä¸€äº›æ„šè ¢çš„é—®é¢˜æˆ–è€…ç»™ä½ ä¿å§†çº§çš„æ•™ç¨‹ã€‚æˆ‘æ€»ç»“äº†ä¸€äº›ã€Šæé—®çš„æ™ºæ…§ã€‹ä¸­æˆ‘è§‰å¾—æ¯”è¾ƒç²¾åçš„å†…å®¹ç½—åˆ—å¦‚ä¸‹ï¼š\nä¸è¦é—®ä¸€äº›ç›´æ¥ STFW/RTFM å°±èƒ½è½»æ¾è·å¾—ç­”æ¡ˆçš„çŸ¥è¯†æ€§é—®é¢˜ï¼Œä»–ä»¬é€šå¸¸å…·æœ‰ \u0026ldquo;xxxæ˜¯ä»€ä¹ˆï¼Ÿ\u0026quot;â€œxxxæ€ä¹ˆç”¨â€ ç­‰æ ¼å¼ã€‚ ä½œä¸ºä¸€ä¸ªè®¡ç®—æœºç•Œçš„åè¾ˆï¼Œä½ é‡åˆ°çš„é—®é¢˜æœ‰æå¤§çš„æ¦‚ç‡æ˜¯å·²ç»æœ‰æ— æ•°äººé‡åˆ°è¿‡çš„é—®é¢˜ã€‚ä¸€äº›ç»å…¸çš„é—®é¢˜é€šå¸¸å¯ä»¥åœ¨ Stack Overflow ç­‰çŸ¥åå¹³å°ä¸Šæ‰¾åˆ°è§£ç­”ï¼Œæ‰€ä»¥ä½ åº”è¯¥ç¡®ä¿ä½ çš„é—®é¢˜æ²¡æœ‰ç°æˆå¯æŸ¥çš„è§£å†³æ–¹æ¡ˆã€‚ ä½ åº”è¯¥å°½å¯èƒ½è¯¦ç»†åœ°åˆ»ç”»ä½ çš„é—®é¢˜ï¼Œæ¯”å¦‚å†™ä¸‹ä½ å·²ç»ç”¨è¿‡å“ªäº›æ–¹æ³•ä½†å¤±è´¥äº†ï¼Œä¹Ÿå¯ä»¥è´´ä¸€äº›æˆªå›¾ã€‚ä¸€æ–¹é¢ï¼Œæ›´è¯¦ç»†çš„ä¿¡æ¯å¯ä»¥è®©åˆ«äººæ›´å¥½åœ°äº†è§£ä½ çš„æƒ…å†µï¼Œæä¾›å¸®åŠ©ï¼›å¦ä¸€æ–¹é¢ï¼Œè¿™å¯ä»¥ä½“ç°ä½ ä¸ºäº†è§£å†³é—®é¢˜å·²ç»ä»˜å‡ºè¿‡ä½ èƒ½åŠ›èŒƒå›´å†…çš„åŠªåŠ›ã€‚ æœºå™¨æ°¸è¿œæ˜¯å¯¹çš„ï¼Œä¸è¦è¯´â€œæˆ‘è§‰å¾—æˆ‘çš„gccæœ‰é—®é¢˜/æˆ‘è§‰å¾—æˆ‘çš„ç”µè„‘åäº†â€ä¹‹ç±»çš„è¯ï¼ˆè¿™æ˜¯æˆ‘åœ¨å¸®åŠ©ä¸Šâ€œç¨‹åºè®¾è®¡åŸºç¡€â€è¯¾çš„åŒå­¦è§£å†³é—®é¢˜æ—¶ç»å¸¸å¬åˆ°çš„è¯ï¼‰ã€‚å¦å¤–ï¼Œä½ æ‰‹ä¸Šçš„æºç æœ‰å¾ˆå¤§æ¦‚ç‡ç»è¿‡äº†å¾ˆå¤šäººçš„éªŒè¯ï¼Œæ‰€ä»¥ä¸è¦è½»æ˜“å®£å¸ƒè‡ªå·±å‘ç°äº† bugã€‚ ä½œä¸ºä¸€ä¸ªæé—®è€…ä½ ä¸èƒ½æ˜¾å¾—è¶¾é«˜æ°”æ˜‚ï¼Œåœ¨æé—®ä¸­é€‚å½“ä½¿ç”¨å§”å©‰çš„è¯æ±‡å¯ä»¥ä½¿ä½ çš„æ€åº¦æ›´åŠ è¯šæ³ï¼Œä½†ä¹Ÿä¸ç”¨è¿‡åº¦ä½¿ç”¨ä»¥è‡³äºè¯­å¥å†—ä½™ã€‚ å¯¹äºæˆ‘ä»¬è¿™æ ·çš„åˆå­¦è€…æ¥è¯´é—®é¢˜å¯èƒ½è¿˜æ²¡æœ‰é¢†åŸŸä¹‹åˆ†ï¼Œä½†åœ¨æ—¥åå¦‚æœæå‡ºä¸€äº›åˆ†ç±»è¾ƒç»†çš„é—®é¢˜ï¼Œéœ€è¦æ³¨æ„æé—®çš„å¹³å°æ˜¯å¦åˆé€‚ã€‚ æ€»ä¹‹ï¼Œæƒ³è¦æå‡ºä¸€ä¸ªå¥½çš„é—®é¢˜ï¼Œä½ éœ€è¦åœ¨é‡åˆ°å›°éš¾æ—¶å…ˆä¸»åŠ¨è‡ªå·±è§£å†³ï¼Œå°è¯•èƒ½åŠ›èŒƒå›´å†…å¯ä»¥ä½¿ç”¨çš„æ–¹æ³•ï¼Œå¹¶ä¸”åœ¨ä½ çš„æé—®ä¸­å±•ç°è¿™ä¸ªè¿‡ç¨‹ã€‚è¿™æ ·è•´å«äº†ä½ çš„æ€è€ƒçš„é—®é¢˜æ‰æ˜¯æœ‰ä»·å€¼çš„ã€‚","tags":null,"title":"PA0 - ä¸–ç•Œè¯ç”Ÿçš„å‰å¤œï¼šå¼€å‘ç¯å¢ƒé…ç½®","type":"docs"},{"authors":null,"categories":null,"content":"è¯¥å…¥é—¨å®éªŒçš„ä¸»è¦ç›®çš„æ˜¯ç†Ÿæ‚‰ cool è¯­è¨€çš„è¯­æ³•ï¼Œä¸ºç¼–è¯‘å™¨ç¼–å†™æ‰“ä¸‹åŸºç¡€ã€‚æœ¬å®éªŒçš„ä»»åŠ¡æ˜¯ç”¨ cool è¯­è¨€å†™ä¸€ä¸ªç®€å•çš„ stack machineï¼Œæ”¯æŒ int + s e d äº”ç§æ“ä½œã€‚\nDesignation ç”±äº cool è¯­è¨€ä¸­æ²¡æœ‰å¼€æ•°ç»„çš„åŠŸèƒ½ï¼Œæ‰€ä»¥ç¬”è€…ä½¿ç”¨é“¾è¡¨æ¥æ¨¡æ‹Ÿè¿™ä¸ªæ ˆæ•°æ®ç»“æ„ã€‚æ’å…¥æ“ä½œæ˜¯æ–°å»ºä¸€ä¸ªé“¾è¡¨èŠ‚ç‚¹æ’åœ¨ head å‰é¢ï¼Œe æ“ä½œåˆ™æ˜¯æŸ¥çœ‹é“¾è¡¨å¼€å¤´çš„è‹¥å¹²ä¸ªå…ƒç´ å¹¶æ‰§è¡Œç›¸åº”æ“ä½œã€‚\nInteresting Bugs cool æ˜¯ä¸€ä¸ªé¢å‘å¯¹è±¡é£æ ¼çš„è¯­è¨€ï¼Œä¸€å¼€å§‹ç¬”è€…åƒäº†ä¸å°‘è‹¦å¤´ï¼›è€Œä¸” PA æä¾›çš„ cool ç¼–è¯‘å™¨æŠ¥é”™ä¿¡æ¯å¾ˆå°‘ï¼Œä¸æ–¹ä¾¿çŸ¥é“åˆ°åº•å‘ç”Ÿäº†ä»€ä¹ˆï¼Œåªèƒ½è‡ªå·±çŒœæµ‹å’Œæ‘¸ç´¢ã€‚\nç¬”è€…é‡åˆ°çš„ä¸€ä¸ªæœ‰æ„æ€çš„ bug æ˜¯åœ¨å®ç° class List çš„æŸä¸ª method æ—¶ï¼Œæ— æ³•ç›´æ¥ä½¿ç”¨å¦ä¸€ä¸ª List å˜é‡çš„ attributeã€‚è¿™æ˜¯å› ä¸º cool è¦æ±‚æ‰€æœ‰çš„ attribute éƒ½æ˜¯ private çš„ï¼Œmethod æ˜¯ public çš„ï¼Œå› æ­¤å¦‚æœæƒ³è¦è®¿é—®æŸä¸ªå˜é‡çš„ attribute è¦è¿™æ ·å†™ï¼š\nclass CLASS { attribute : Object; attribute() : Object { attribute }; }; è¿™æ ·å°±å¯ä»¥é€šè¿‡ attribute() æ–¹æ³•æ¥è®¿é—® attribute å±æ€§ã€‚\nMiscellaneous å…³äº cool çš„ä¸€ç‚¹åæ§½ (README è¦æ±‚çš„ä½œä¸šä¹‹ä¸€)ï¼š\næ— æ³•æŒ‡å®š private/public çš„ attributeï¼›\næ²¡æœ‰é€»è¾‘è¿ç®—ç¬¦ (and/or) å¯¼è‡´æœ‰ä¸€äº› if-else è¯­å¥ä¸å¾—ä¸æ‹†æˆä¸¤ä¸ªå†™ï¼›\nif ç»“æ„å¿…é¡»æ˜¯ if-then-else-fiï¼Œä¸èƒ½çœç•¥ else åˆ†æ”¯ï¼›\nå¤šè¡Œä»£ç å¿…é¡»ç”¨å¤§æ‹¬å·æ¡†èµ·æ¥ï¼Œæœ‰ä¸€ç‚¹ä¸‘ (ä¸è¿‡è¿™åº”è¯¥å¯ä»¥ç®€åŒ– parser çš„è®¾è®¡)ï¼›\nâ€¦â€¦\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"0d9180175f76fea706c40970ce8845ab","permalink":"https://kristoff-starling.github.io/notes/coursenotes/stanford-compiler/pa/pa0/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/stanford-compiler/pa/pa0/","section":"notes","summary":"è¯¥å…¥é—¨å®éªŒçš„ä¸»è¦ç›®çš„æ˜¯ç†Ÿæ‚‰ cool è¯­è¨€çš„è¯­æ³•ï¼Œä¸ºç¼–è¯‘å™¨ç¼–å†™æ‰“ä¸‹åŸºç¡€ã€‚æœ¬å®éªŒçš„ä»»åŠ¡æ˜¯ç”¨ cool è¯­è¨€å†™ä¸€ä¸ªç®€å•çš„ stack machineï¼Œæ”¯æŒ int + s e d äº”ç§æ“ä½œã€‚\nDesignation ç”±äº cool è¯­è¨€ä¸­æ²¡æœ‰å¼€æ•°ç»„çš„åŠŸèƒ½ï¼Œæ‰€ä»¥ç¬”è€…ä½¿ç”¨é“¾è¡¨æ¥æ¨¡æ‹Ÿè¿™ä¸ªæ ˆæ•°æ®ç»“æ„ã€‚æ’å…¥æ“ä½œæ˜¯æ–°å»ºä¸€ä¸ªé“¾è¡¨èŠ‚ç‚¹æ’åœ¨ head å‰é¢ï¼Œe æ“ä½œåˆ™æ˜¯æŸ¥çœ‹é“¾è¡¨å¼€å¤´çš„è‹¥å¹²ä¸ªå…ƒç´ å¹¶æ‰§è¡Œç›¸åº”æ“ä½œã€‚\nInteresting Bugs cool æ˜¯ä¸€ä¸ªé¢å‘å¯¹è±¡é£æ ¼çš„è¯­è¨€ï¼Œä¸€å¼€å§‹ç¬”è€…åƒäº†ä¸å°‘è‹¦å¤´ï¼›è€Œä¸” PA æä¾›çš„ cool ç¼–è¯‘å™¨æŠ¥é”™ä¿¡æ¯å¾ˆå°‘ï¼Œä¸æ–¹ä¾¿çŸ¥é“åˆ°åº•å‘ç”Ÿäº†ä»€ä¹ˆï¼Œåªèƒ½è‡ªå·±çŒœæµ‹å’Œæ‘¸ç´¢ã€‚\nç¬”è€…é‡åˆ°çš„ä¸€ä¸ªæœ‰æ„æ€çš„ bug æ˜¯åœ¨å®ç° class List çš„æŸä¸ª method æ—¶ï¼Œæ— æ³•ç›´æ¥ä½¿ç”¨å¦ä¸€ä¸ª List å˜é‡çš„ attributeã€‚è¿™æ˜¯å› ä¸º cool è¦æ±‚æ‰€æœ‰çš„ attribute éƒ½æ˜¯ private çš„ï¼Œmethod æ˜¯ public çš„ï¼Œå› æ­¤å¦‚æœæƒ³è¦è®¿é—®æŸä¸ªå˜é‡çš„ attribute è¦è¿™æ ·å†™ï¼š","tags":null,"title":"Stanford-CS143 PA0: Cool Programming","type":"docs"},{"authors":null,"categories":null,"content":"å®éªŒè¿›åº¦ æˆ‘å®Œæˆäº†æ‰€æœ‰çš„å¿…ç­”é¢˜ï¼Œå¹¶é’ˆå¯¹é€‰åšé¢˜å’Œæ€è€ƒé¢˜ç»™å‡ºäº†è‡ªå·±çš„æƒ³æ³•ã€‚\nå¿…ç­”é¢˜ ç¨‹åºæ˜¯ä¸ªçŠ¶æ€æœº ç‚¹å‡» è¿™é‡Œ è·³è½¬åˆ°è§£ç­”ã€‚\nç†è§£åŸºç¡€è®¾æ–½ æœ‰ 450 æ¬¡ç¼–è¯‘ç”¨äºè°ƒè¯•ï¼Œå‡è®¾åªæœ‰ 450 ä¸ª bugï¼Œé‚£ä¹ˆæ€»å…±éœ€è¦ 4500min = 75h ã€‚ç®€æ˜“è°ƒè¯•å™¨å¯ä»¥èŠ‚çº¦ 50h çš„æ—¶é—´ã€‚\nRTFM riscv32æœ‰å“ªå‡ ç§æŒ‡ä»¤æ ¼å¼?\nåœ¨ Volume I - 2.2 èŠ‚å¯ä»¥æŸ¥åˆ° Base Instruction Formats, åœ¨ Volume I -17.2 èŠ‚ä¸­å¯ä»¥æŸ¥åˆ° Compressed Instruction Formatsã€‚åœ¨ Volume I - 26.3 èŠ‚å¯ä»¥æŸ¥åˆ°æ‰©å±• RISCV çš„æŒ‡ä»¤æ ¼å¼ã€‚\nLUIæŒ‡ä»¤çš„è¡Œä¸ºæ˜¯ä»€ä¹ˆ?\nåœ¨ Volume I ç¬¬ 19 é¡µå¯ä»¥æŸ¥åˆ° LUI æŒ‡ä»¤çš„è¡Œä¸ºã€‚\nmstatuså¯„å­˜å™¨çš„ç»“æ„æ˜¯æ€ä¹ˆæ ·çš„?\nåœ¨ Volume II - 3.1.6 èŠ‚å¯ä»¥æŸ¥åˆ° machine status register çš„ç»“æ„ã€‚\nShellå‘½ä»¤ ç¬”è€…ä½¿ç”¨äº†å¦‚ä¸‹å‘½ä»¤æ¥ç»Ÿè®¡æ‰€æœ‰éç©ºè¡Œçš„ä»£ç è¡Œæ•°ï¼š\nfind . -name \u0026quot;*[.c|.h]\u0026quot; | xargs grep ^. | wc -l å…¶ä¸­çš„æ­£åˆ™è¡¨è¾¾å¼ ^. ç”¨æ¥è¯†åˆ«å¼€å¤´è‡³å°‘æœ‰ä¸€ä¸ªå­—ç¬¦çš„è¡Œã€‚\npa0ç»“æŸæ—¶å…±æœ‰ä»£ç  19868 è¡Œï¼Œpa1ç»“æŸæ—¶å…±æœ‰ä»£ç  20272 è¡Œã€‚\nRTFM -Wall é€‰é¡¹ä¼šæ˜¾ç¤ºæ‰€æœ‰çš„ warning ä¿¡æ¯ï¼Œ-Werror ä¼šå°†æ‰€æœ‰ warning è§†ä½œ error æŠ¥é”™ã€‚ä½¿ç”¨è¿™äº›ç¼–è¯‘é€‰é¡¹å¯ä»¥å°½æ—©å‘ç°æ½œåœ¨çš„é”™è¯¯å¹¶å¼ºåˆ¶æŠ¥é”™ï¼Œå°† bug æ¶ˆç­åœ¨ fault çš„é˜¶æ®µã€‚\nä»¥ä¸‹æ˜¯æˆ‘çš„è‡ªç”±æŠ¥å‘Šå†…å®¹ï¼Œæˆ‘åœ¨åšå®éªŒçš„è¿‡ç¨‹ä¸­è¯¦ç»†è®°å½•äº†è‡ªå·±é‡åˆ°çš„æ‰€æœ‰é—®é¢˜å’ŒæŸ¥é˜…çš„æ‰€æœ‰èµ„æ–™ã€‚è¿™äº›ç¬”è®°æŒ‰ç…§ç« èŠ‚æ’åˆ—ï¼Œæ¯ç« é€šå¸¸æœ‰ä¸¤ä¸ªéƒ¨åˆ†ï¼š\næ€è€ƒé¢˜ï¼šåŒ…å«ç¬”è€…é’ˆå¯¹æ€è€ƒé¢˜æŸ¥é˜…çš„èµ„æ–™å’Œæˆ‘å°è¯•ç»™å‡ºçš„ç­”æ¡ˆã€‚ è¡¥å……ï¼šè¿™é‡Œçš„å†…å®¹æ˜¯æ²¡æœ‰åœ¨è®²ä¹‰ä¸­æåŠçš„é—®é¢˜ï¼Œä»¥åŠè®²ä¹‰ä¸­å»ºè®®è‡ªå­¦çš„ä¸œè¥¿ã€‚ åœ¨å¼€å§‹æ„‰å¿«çš„PAä¹‹æ—…ä¹‹å‰ è¡¥å…… å…³äº git status è¿½è¸ªä¸åˆ°ä¿®æ”¹ åœ¨ ics2021 æ ¹ç›®å½•ä¸‹æ–°å»ºæ–‡ä»¶ touch test.cpp åä½¿ç”¨ git status æŸ¥çœ‹å˜åŒ–ï¼Œå‘ç° git å¹¶æ²¡æœ‰è¿½è¸ªåˆ°è¿™æ¡å˜åŒ–ã€‚ä½¿ç”¨ git add a.cpp å‘½ä»¤åæ˜¾ç¤ºï¼š\nThe following paths are ignored by one of your .gitignore files è¿™è¯´æ˜æ ¹ç›®å½•çš„ .gitignore æ–‡ä»¶å¿½ç•¥äº†è¯¥æ–‡ä»¶ï¼Œæ‰“å¼€ .gitignore æŸ¥çœ‹ï¼š\n*.* * !*/ !/nemu/* !/nexus-am/* !/nanos-lite/* !/navy-apps/* !Makefile !README.md !.gitignore !init.sh /fceux-am /am-kernels æŸ¥é˜…èµ„æ–™å¾—çŸ¥ï¼Œ.gitignore æ–‡ä»¶çš„æœ€åŸºç¡€è¯­æ³•åŒ…æ‹¬ï¼š\nå¯ä»¥ç”¨æ­£åˆ™è¡¨è¾¾å¼ [] ? * ç­‰æ¥åŒ¹é…æ–‡ä»¶å è¡Œå¼€å¤´ä½¿ç”¨ ! è¡¨ç¤ºä¸å¿½ç•¥è¯¥è¡ŒåŒ¹é…çš„æ–‡ä»¶ ics2001/a.cpp è¢« *.* æ•æ‰ï¼Œå› æ­¤è¢« git å¿½ç•¥äº†ã€‚ä¸ºäº†éªŒè¯æˆ‘çš„æ€è€ƒï¼Œæˆ‘åœ¨ ics2001/nemu ä¸‹åˆ›å»ºäº† a.cpp ï¼Œæ ¹æ®æ ¹ç›®å½•ä¸‹çš„ .gitignore æ–‡ä»¶ /nemu ä¸‹çš„æ–‡ä»¶æ²¡æœ‰è¢«å¿½ç•¥ï¼Œä½† git ä»ç„¶æ²¡æœ‰è¿½è¸ªåˆ° a.cppã€‚\næˆ‘å‘ç° /nemu ä¸‹ä¹Ÿæœ‰ .gitignore æ–‡ä»¶ï¼Œè¯¥æ–‡ä»¶ä¸­çš„ *.* æ•æ‰äº† a.cppã€‚æŸ¥é˜…èµ„æ–™å¾—çŸ¥ï¼Œå½“å¤šä¸ª .gitignore æ–‡ä»¶å‘ç”Ÿå†²çªæ—¶ï¼Œgit ä¼˜å…ˆæœä»æœ¬åœ°çš„æ–‡ä»¶è€Œä¸æ˜¯çˆ¶æ–‡ä»¶å¤¹çš„æ–‡ä»¶ã€‚\nå…³äºæ·»åŠ ç¯å¢ƒå˜é‡ ccache å·¥å…·è¦æ±‚å°† /usr/lib/ccache æ·»åŠ åˆ° PATH ä¸­ã€‚ç¬”è€…ä¸€å¼€å§‹ç›´æ¥åœ¨ ~/.bashrc ä¸­æ·»åŠ äº†å¦‚ä¸‹ä¸€è¡Œï¼š\nexport PATH=/usr/lib/ccache ä¹‹åå‘ç°å…¶ä»–æ‰€æœ‰çš„å‘½ä»¤éƒ½ç”¨ä¸äº†äº†ã€‚äº‹å®ä¸Šå¤§éƒ¨åˆ†å‘½ä»¤éƒ½æ”¾åœ¨ /usr/bin ä¹‹ä¸‹ï¼Œè¿™ä¸ªè·¯å¾„é»˜è®¤ä¿å­˜åœ¨ PATH ä¸­ã€‚å¦‚æœå‘ä¸Šæ–‡é‚£æ ·ç›´æ¥ä¿®æ”¹ PATHï¼Œä¼šå¯¼è‡´å…¶ä»–å‘½ä»¤æ— æ³•ä½¿ç”¨ã€‚\nåœ¨å‘½ä»¤è¡Œä¸­è¾“å…¥ export PATH=\u0026quot;/usr/bin:$PATH\u0026quot; å¯ä»¥æš‚æ—¶å°† /usr/bin æ·»åŠ å› PATHï¼Œä½†ç»ˆç«¯å…³é—­åä¼šå¤±æ•ˆã€‚æ­¤æ—¶æ‰“å¼€ ~/.bashrc å°†å‘½ä»¤ä¿®æ”¹ä¸º\nexport PATH=/usr/lib/ccache:$PATH åä¸€åˆ‡æ­£å¸¸ã€‚è¿™é‡Œçš„ : æ˜¯å¤šä¸ªè·¯å¾„ä¹‹é—´çš„åˆ†éš”ç¬¦ï¼Œè¿™æ¡è¯­å¥ç›¸å½“äºåœ¨åŸæœ¬çš„ $PATH å†…å®¹ä¹‹å‰åŠ ä¸Š /usr/lib/ccacheã€‚\nï¼ˆäº‹å®ä¸Šä»”ç»†é˜…è¯» ccache çš„æ–‡æ¡£å¯ä»¥å‘ç°å®ƒè®©ä½ å°†è·¯å¾„ â€œperpendâ€ åˆ° PATH ä¸­ï¼Œæ²¡è®©ä½ ç›´æ¥ä¿®æ”¹â€¦â€¦ï¼‰\nå¼€å¤©è¾Ÿåœ°çš„ç¯‡ç«  å¿…ç­”é¢˜ ä»çŠ¶æ€æœºè§†è§’ç†è§£ç¨‹åºè¿è¡Œ ä»¥ä¸Šä¸€å°èŠ‚ä¸­1+2+...+100çš„æŒ‡ä»¤åºåˆ—ä¸ºä¾‹, å°è¯•ç”»å‡ºè¿™ä¸ªç¨‹åºçš„çŠ¶æ€æœº.\nè¿™ä¸ªç¨‹åºæ¯”è¾ƒç®€å•, éœ€è¦æ›´æ–°çš„çŠ¶æ€åªåŒ…æ‹¬PCå’Œr1, r2è¿™ä¸¤ä¸ªå¯„å­˜å™¨, å› æ­¤æˆ‘ä»¬ç”¨ä¸€ä¸ªä¸‰å…ƒç»„(PC, r1, r2)å°±å¯ä»¥è¡¨ç¤ºç¨‹åºçš„æ‰€æœ‰çŠ¶æ€, è€Œæ— éœ€ç”»å‡ºå†…å­˜çš„å…·ä½“çŠ¶æ€. åˆå§‹çŠ¶æ€æ˜¯(0, x, x), æ­¤å¤„çš„xè¡¨ç¤ºæœªåˆå§‹åŒ–. ç¨‹åºPC=0å¤„çš„æŒ‡ä»¤æ˜¯mov r1, 0, æ‰§è¡Œå®Œä¹‹åPCä¼šæŒ‡å‘ä¸‹ä¸€æ¡æŒ‡ä»¤, å› æ­¤ä¸‹ä¸€ä¸ªçŠ¶æ€æ˜¯(1, 0, x). å¦‚æ­¤ç±»æ¨, æˆ‘ä»¬å¯ä»¥ç”»å‡ºæ‰§è¡Œå‰3æ¡æŒ‡ä»¤çš„çŠ¶æ€è½¬ç§»è¿‡ç¨‹:\n(0, x, x) -\u0026gt; (1, 0, x) -\u0026gt; (2, 0, 0) -\u0026gt; (3, 0, 1) è¯·ä½ å°è¯•ç»§ç»­ç”»å‡ºè¿™ä¸ªçŠ¶æ€æœº, å…¶ä¸­ç¨‹åºä¸­çš„å¾ªç¯åªéœ€è¦ç”»å‡ºå‰ä¸¤æ¬¡å¾ªç¯å’Œæœ€åä¸¤æ¬¡å¾ªç¯å³å¯.\nå®Œæ•´çš„çŠ¶æ€æœºå¦‚ä¸‹ï¼š\n(0,x,x) -\u0026gt; (1,0,x) -\u0026gt; (2,0,0) -\u0026gt; (3,0,1) -\u0026gt; (4,1,1) -\u0026gt; (2,1,1) -\u0026gt; (3,1,2) -\u0026gt; (4,3,2) -\u0026gt; (2,3,2) -\u0026gt; ... -\u0026gt; (2,4851,98) -\u0026gt; (3,4851,99) -\u0026gt; (4,4950,99) -\u0026gt; (2,4950,99) -\u0026gt; (3,4950,100) -\u0026gt; (4,5050,100) -\u0026gt; (5,5050,100) -\u0026gt; (5,5050,100) -\u0026gt; ... æ€è€ƒé¢˜ [äºŒå‘¨ç›®] è®¡ç®—æœºå¯ä»¥æ²¡æœ‰å¯„å­˜å™¨å—ï¼Ÿ å¦‚æœæ²¡æœ‰å¯„å­˜å™¨, è®¡ç®—æœºè¿˜å¯ä»¥å·¥ä½œå—? å¦‚æœå¯ä»¥, è¿™ä¼šå¯¹ç¡¬ä»¶æä¾›çš„ç¼–ç¨‹æ¨¡å‹æœ‰ä»€ä¹ˆå½±å“å‘¢?\nå°±ç®—ä½ æ˜¯äºŒå‘¨ç›®æ¥æ€è€ƒè¿™ä¸ªé—®é¢˜, ä½ ä¹Ÿæœ‰å¯èƒ½æ˜¯ç¬¬ä¸€æ¬¡å¬åˆ°\u0026quot;ç¼–ç¨‹æ¨¡å‹\u0026quot;è¿™ä¸ªæ¦‚å¿µ. ä¸è¿‡å¦‚æœä¸€å‘¨ç›®çš„æ—¶å€™ä½ å·²ç»ä»”ç»†åœ°é˜…è¯»è¿‡ISAæ‰‹å†Œ, ä½ ä¼šè®°å¾—ç¡®å®æœ‰è¿™ä¹ˆä¸ªæ¦‚å¿µ. æ‰€ä»¥, å¦‚æœæƒ³çŸ¥é“ä»€ä¹ˆæ˜¯ç¼–ç¨‹æ¨¡å‹, RTFMå§.\nç•™å‘ï¼ŒäºŒå‘¨ç›®å†åšã€‚\nRTFSC æ€è€ƒé¢˜ kconfigç”Ÿæˆçš„å®ä¸æ¡ä»¶ç¼–è¯‘ æˆ‘ä»¬å·²ç»åœ¨ä¸Šæ–‡æåˆ°è¿‡, kconfigä¼šæ ¹æ®é…ç½®é€‰é¡¹çš„ç»“æœåœ¨ nemu/include/generated/autoconf.hä¸­å®šä¹‰ä¸€äº›å½¢å¦‚CONFIG_xxxçš„å®, æˆ‘ä»¬å¯ä»¥åœ¨Cä»£ç ä¸­é€šè¿‡æ¡ä»¶ç¼–è¯‘çš„åŠŸèƒ½å¯¹è¿™äº›å®è¿›è¡Œæµ‹è¯•, æ¥åˆ¤æ–­æ˜¯å¦ç¼–è¯‘æŸäº›ä»£ç . ä¾‹å¦‚, å½“CONFIG_DEBUGè¿™ä¸ªå®æ²¡æœ‰å®šä¹‰æ—¶, è°ƒè¯•ç›¸å…³çš„ä»£ç å°±æ— éœ€è¿›è¡Œç¼–è¯‘.\nä¸ºäº†ç¼–å†™æ›´ç´§å‡‘çš„ä»£ç , æˆ‘ä»¬åœ¨nemu/include/debug.hä¸­å®šä¹‰äº†ä¸€äº›ä¸“é—¨ç”¨æ¥å¯¹å®è¿›è¡Œæµ‹è¯•çš„å®. ä¾‹å¦‚IFDEF(CONFIG_DEVICE, init_device());è¡¨ç¤º, å¦‚æœå®šä¹‰äº†CONFIG_DEVICE, æ‰ä¼šè°ƒç”¨init_device()å‡½æ•°; è€ŒMUXDEF(CONFIG_DEBUG, \u0026quot;ON\u0026quot;, \u0026quot;OFF\u0026quot;)åˆ™è¡¨ç¤º, å¦‚æœå®šä¹‰äº†CONFIG_DEBUG, åˆ™é¢„å¤„ç†ç»“æœä¸º\u0026quot;ON\u0026quot;(\u0026quot;OFF\u0026quot;åœ¨é¢„å¤„ç†åä¼šæ¶ˆå¤±), å¦åˆ™é¢„å¤„ç†ç»“æœä¸º\u0026quot;OFF\u0026quot;.\nè¿™äº›å®çš„åŠŸèƒ½éå¸¸ç¥å¥‡, ä½ çŸ¥é“è¿™äº›å®æ˜¯å¦‚ä½•å·¥ä½œçš„å—?\nå®å®šä¹‰çš„åŸºæœ¬æ ¼å¼ä¸º #define A Bï¼Œè¿™é‡Œçš„ A å¯ä»¥åŒ…å«å‚æ•°ä¹Ÿå¯ä»¥ä¸åŒ…å«ã€‚åœ¨ç¼–è¯‘çš„è¿‡ç¨‹ä¸­ï¼Œç¨‹åºä¸­çš„ A ä¼šè¢«æ›¿æ¢æˆ Bã€‚\næ¡ä»¶ç¼–è¯‘æŒ‡ç±»ä¼¼äº #idef A #ifndef A ç­‰ï¼Œè¡¨ç¤ºå¦‚æœå® A æœ‰å®šä¹‰/æ— å®šä¹‰æ‰ä¼šç¼–è¯‘ä¸‹é¢çš„ä»£ç ï¼Œä»¥ #endif ç»“å°¾ã€‚\nä¸ºä»€ä¹ˆå…¨éƒ¨éƒ½æ˜¯å‡½æ•°? é˜…è¯»init_monitor()å‡½æ•°çš„ä»£ç , ä½ ä¼šå‘ç°é‡Œé¢å…¨éƒ¨éƒ½æ˜¯å‡½æ•°è°ƒç”¨. æŒ‰é“ç†, æŠŠç›¸åº”çš„å‡½æ•°ä½“åœ¨init_monitor()ä¸­å±•å¼€ä¹Ÿä¸å½±å“ä»£ç çš„æ­£ç¡®æ€§. ç›¸æ¯”ä¹‹ä¸‹, åœ¨è¿™é‡Œä½¿ç”¨å‡½æ•°æœ‰ä»€ä¹ˆå¥½å¤„å‘¢?\näº‹å®ä¸Šï¼Œå¦‚æœèƒ½ç¡®å®šè¿™äº›ä»£ç å—åªä¼šä½¿ç”¨ä¸€æ¬¡ï¼Œé‚£ä¹ˆå°†è¿™äº›ä»£ç æ”¾è¿›å‡½æ•°ä½“ï¼Œå¹¶åœ¨æ¯å—çš„å¼€å¤´ç”¨æ³¨é‡Šå†™ä¸Šè¯¥éƒ¨åˆ†çš„ä½œç”¨ï¼Œä¹Ÿå¯ä»¥è¾¾åˆ°ä»£ç æ˜“é˜…è¯»çš„æ•ˆæœï¼›ä½†é˜…è¯»ä»£ç å‘ç°è¿™äº›ä»£ç å—åœ¨å…¶ä»–çš„å‡½æ•°ä½“ä¸­ä¹Ÿæœ‰ä½¿ç”¨ï¼Œå› æ­¤å°è£…æˆå‡½æ•°å¯ä»¥å‡å°‘ä»£ç é‡ã€‚ä»å¦ä¸€ç§è§’åº¦ï¼Œè¿™æ ·å†™ init_monitor() å‡½æ•°å†…å®¹æ›´åŠ æ¸…çˆ½ï¼Œå¯ä»¥æ›´å¥½åœ°ä½“ç°åˆ†å±‚æŠ½è±¡ã€‚\nç©¶ç«Ÿè¦æ‰§è¡Œå¤šä¹…ï¼Ÿ åœ¨cmd_c()å‡½æ•°ä¸­, è°ƒç”¨cpu_exec()çš„æ—¶å€™ä¼ å…¥äº†å‚æ•°-1, ä½ çŸ¥é“è¿™æ˜¯ä»€ä¹ˆæ„æ€å—?\ncpu_exec() ä¸­çš„å‚æ•° n ä»£è¡¨çš„æ˜¯ cpu æ‰§è¡ŒæŒ‡ä»¤çš„æ¬¡æ•°ã€‚åœ¨ /nemu/src/cpu/cpu_exec.c çš„æºç ä¸­æ˜¯è¿™æ ·å†™çš„\nfor (;n\u0026gt;0;n--) { ... } å› æ­¤ä¼ å…¥å‚æ•° -1 å¯ä»¥ä½¿ cpu ä¸åœåœ°æ‰§è¡ŒæŒ‡ä»¤ï¼Œç›´åˆ°é‡åˆ° nemu_trap æŒ‡ä»¤ã€‚\nå‚æ•°çš„å¤„ç†è¿‡ç¨‹ å¦å¤–çš„ä¸€ä¸ªé—®é¢˜æ˜¯, è¿™äº›å‚æ•°æ˜¯ä»å“ªé‡Œæ¥çš„å‘¢?\nè¿™äº›å‚æ•°æ¥è‡ªå‘½ä»¤è¡Œï¼Œæ˜¯ç”¨æˆ·é”®å…¥çš„ã€‚main() å‡½æ•°è‡ªå¸¦çš„ä¸¤ä¸ªå‚æ•° int argc å’Œ char *argv[] å¤„ç†ç”¨æˆ·åœ¨å‘½ä»¤è¡Œä¸­é”®å…¥çš„å‚æ•°ã€‚argc æ˜¯å‚æ•°çš„ä¸ªæ•°ï¼Œchar *argv[] æ˜¯æŒ‡å‘å‚æ•°çš„æŒ‡é’ˆæ•°ç»„ã€‚parse_args() ä¸­ä¼ é€’çš„å‚æ•°å°±æ˜¯è¿™ä¸¤ä¸ªã€‚\n[äºŒå‘¨ç›®] æ½œåœ¨çš„å¨èƒ \u0026ldquo;è°ƒç”¨cpu_exec()çš„æ—¶å€™ä¼ å…¥äº†å‚æ•°-1\u0026rdquo;, è¿™ä¸€åšæ³•å±äºæœªå®šä¹‰è¡Œä¸ºå—? è¯·æŸ¥é˜…C99æ‰‹å†Œç¡®è®¤ä½ çš„æƒ³æ³•.\nç•™å‘ï¼ŒäºŒå‘¨ç›®å†åšã€‚\nè°æ¥æŒ‡ç¤ºç¨‹åºçš„ç»“æŸï¼Ÿ åœ¨ç¨‹åºè®¾è®¡è¯¾ä¸Šè€å¸ˆå‘Šè¯‰ä½ , å½“ç¨‹åºæ‰§è¡Œåˆ°main()å‡½æ•°è¿”å›å¤„çš„æ—¶å€™, ç¨‹åºå°±é€€å‡ºäº†, ä½ å¯¹æ­¤æ·±ä¿¡ä¸ç–‘. ä½†ä½ æ˜¯å¦æ€€ç–‘è¿‡, å‡­ä»€ä¹ˆç¨‹åºæ‰§è¡Œåˆ°main()å‡½æ•°çš„è¿”å›å¤„å°±ç»“æŸäº†? å¦‚æœæœ‰äººå‘Šè¯‰ä½ , ç¨‹åºè®¾è®¡è¯¾ä¸Šè€å¸ˆçš„è¯´æ³•æ˜¯é”™çš„, ä½ æœ‰åŠæ³•æ¥è¯æ˜/åé©³å—? å¦‚æœä½ å¯¹æ­¤æ„Ÿå…´è¶£, è¯·åœ¨äº’è”ç½‘ä¸Šæœç´¢ç›¸å…³å†…å®¹.\nmain() å‡½æ•°æ˜¯ç¨‹åºçš„å…¥å£ï¼Œä½† main () å‡½æ•°ä¹Ÿæ˜¯è¢«å…¶ä»–ç¨‹åºè°ƒç”¨çš„ã€‚ä¾‹å¦‚æœ‰ä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶ testï¼Œåœ¨ shell ä¸­è¾“å…¥ ./test ä¹‹åï¼Œshell ä¼š clone ä¸€ä¸ªå­è¿›ç¨‹ï¼Œæ‰§è¡Œ\nexecve(\u0026quot;./test\u0026quot;,char * const argv[], char * const envp[]) execve åŠ è½½ ./test å¹¶å°†å‚æ•°ä¸€æ­¥æ­¥ä¼ é€’ä¸‹å»ã€‚ä» ./test çš„å…¥å£å¼€å§‹æ‰§è¡Œï¼ˆELFæ–‡ä»¶ä¸­çš„ _start()ï¼‰, _start() è°ƒç”¨ __libc_start_main()ã€‚__libc_start_main() ä¸­æœ‰ä¸€æ¡\nint result = main (argc, argv, __environ MAIN_AUXVEC_PARAM); ä»è¿™é‡Œè¿›å…¥ main() å‡½æ•°ï¼Œmain() å‡½æ•°çš„è¿”å›å€¼ä¼šå­˜åœ¨ result ä¸­ï¼Œ__libc_start_main() ä¼šç›´æ¥ exit(result) ï¼Œä»è€Œ main() å‡½æ•°çš„è¿”å›å€¼ä¼šè¢«çˆ¶è¿›ç¨‹æ•æ‰åˆ°ã€‚\næ‰§è¡Œå®Œ ./test åç”¨ echo $\u0026gt; æŒ‡ä»¤å¯ä»¥æ‰“å° main() å‡½æ•°çš„è¿”å›å€¼ã€‚\n[äºŒå‘¨ç›®] æœ‰å§‹æœ‰ç»ˆ å¯¹äºGNU/Linuxä¸Šçš„ä¸€ä¸ªç¨‹åº, æ€ä¹ˆæ ·æ‰ç®—å¼€å§‹? æ€ä¹ˆæ ·æ‰ç®—æ˜¯ç»“æŸ? å¯¹äºåœ¨NEMUä¸­è¿è¡Œçš„ç¨‹åº, é—®é¢˜çš„ç­”æ¡ˆåˆæ˜¯ä»€ä¹ˆå‘¢?\nä¸æ­¤ç›¸å…³çš„é—®é¢˜è¿˜æœ‰: NEMUä¸­ä¸ºä»€ä¹ˆè¦æœ‰nemu_trap? ä¸ºä»€ä¹ˆè¦æœ‰monitor?\nç•™å‘ï¼ŒäºŒå‘¨ç›®å†åšã€‚\nè¡¥å…… å…³äº $@ å’Œ $\u0026lt; $@ ä»£è¡¨ç›®æ ‡æ–‡ä»¶ï¼Œ$\u0026lt; ä»£è¡¨ç¬¬ä¸€ä¸ªä¾èµ–æ–‡ä»¶ï¼Œæ­¤å¤–ç±»ä¼¼çš„å­—ç¬¦è¿˜æœ‰ $^ ä»£è¡¨æ‰€æœ‰çš„ä¾èµ–æ–‡ä»¶ã€‚\nå…³äº getopt å’Œ getopt_long ä¸¤è€…éƒ½æ˜¯ç”¨äºåˆ†æå‚æ•°ï¼Œä¸åŒçš„æ˜¯ getopt ä¼šå¿½ç•¥é•¿å‚æ•°ï¼ˆå³ç”± -- å¼€å¤´çš„å‚æ•°ï¼Œå‚æ•°åå­—å¯ä»¥ä¸æ­¢ä¸€ä¸ªå­—ç¬¦ï¼‰è€Œ getopt_long ä¸ä¼šã€‚\nmonitor.c ä¸­çš„æºç å¦‚ä¸‹\nconst struct option table[] = { {\u0026quot;batch\u0026quot; , no_argument , NULL, 'b'}, {\u0026quot;log\u0026quot; , required_argument, NULL, 'l'}, {\u0026quot;diff\u0026quot; , required_argument, NULL, 'd'}, {\u0026quot;port\u0026quot; , required_argument, NULL, 'p'}, {\u0026quot;help\u0026quot; , no_argument , NULL, 'h'}, {0 , 0 , NULL, 0 }, }; int o; while ( (o = getopt_long(argc, argv, \u0026quot;-bhl:d:p:\u0026quot;, table, NULL)) != -1) { switch (o) { case 'b': sdb_set_batch_mode(); break; case 'p': sscanf(optarg, \u0026quot;%d\u0026quot;, \u0026amp;difftest_port); break; case 'l': log_file = optarg; break; case 'd': diff_so_file = optarg; break; case 1: img_file = optarg; return optind - 1; default: printf(\u0026quot;Usage: %s [OPTION...] IMAGE [args]\\n\\n\u0026quot;, argv[0]); printf(\u0026quot;\\t-b,--batch run with batch mode\\n\u0026quot;); printf(\u0026quot;\\t-l,--log=FILE output log to FILE\\n\u0026quot;); printf(\u0026quot;\\t-d,--diff=REF_SO run DiffTest with reference REF_SO\\n\u0026quot;); printf(\u0026quot;\\t-p,--port=PORT run DiffTest with port PORT\\n\u0026quot;); printf(\u0026quot;\\n\u0026quot;); exit(0); } } getopt() é‡Œæœ‰å¦‚ä¸‹å‚æ•°ï¼šint argc è¡¨ç¤ºè¦åˆ†æçš„é€‰é¡¹ä¸ªæ•°ï¼Œchar *argv[] æ˜¯æŒ‡å‘å‚æ•°çš„é€‰é¡¹æ•°ç»„ã€‚getopt() æœ‰ä¸€ä¸ªé¢å¤–çš„å˜é‡ optind è®°å½•å½“å‰å·²ç»åˆ†æåˆ°ç¬¬å‡ ä¸ªé€‰é¡¹ã€‚æ¯è°ƒç”¨ä¸€æ¬¡ï¼Œgetopt() ä¼šè¿”å›ä¸‹ä¸€ä¸ªé€‰é¡¹å‰¥å»äº† - çš„ç»“æœ (optional character)ï¼Œå¦‚æœå·²ç»æ²¡æœ‰ä¸‹ä¸€ä¸ªé€‰é¡¹åˆ™è¿”å› -1ã€‚\ngetopt() çš„å‚æ•° optstring è¡¨ç¤ºè¯†åˆ«å“ªäº›é€‰é¡¹ã€‚å¦‚æœé€‰é¡¹å­—ç¬¦å‰æœ‰ : çš„è¯è¡¨ç¤ºè¯¥é€‰é¡¹è¿˜æœ‰å‚æ•°ï¼Œgetopt() åˆ†ææ—¶ä¼šå°†è¯¥é€‰é¡¹çš„å‚æ•°ä¿å­˜åœ¨ optarg å˜é‡ä¸­ã€‚\ngetopt() åœ¨é»˜è®¤æƒ…å†µä¸‹ä¼šå°† argv æ•°ç»„ä¸­çš„é€‰é¡¹é‡æ’ï¼Œå°†é‚£äº›ä¸æ˜¯é€‰é¡¹çš„ args æ”¾åˆ°æ•°ç»„çš„æœ€åã€‚æœ‰ä¸¤ç§ç‰¹æ®Šçš„æ‰«ææ–¹å¼å¯ä»¥æ— è§†è¿™ç§é»˜è®¤ï¼š\noptstring çš„é¦–å­—æ¯æ˜¯ + ï¼Œè¡¨ç¤ºé‡åˆ°ç¬¬ä¸€ä¸ªéé€‰é¡¹çš„ args å°±é€€å‡º optstring çš„é¦–å­—æ¯æ˜¯ - ï¼Œè¡¨ç¤ºå¤„ç†æ‰€æœ‰çš„ argsï¼Œå¦‚æœé‡åˆ°éé€‰é¡¹çš„ argsï¼Œè¿”å›çš„ optional character æ˜¯ 1ã€‚å¯ä»¥çœ‹åˆ°ä»£ç ä¸­å¯¹äºéé€‰é¡¹çš„éƒ¨åˆ† (Case 1) è¿”å›äº† optind-1 ï¼Œè½¬åˆ°å¼‚å¸¸å¤„ç†ã€‚ switch è¯­å¥ä¸­æ²¡æœ‰åˆ¤æ–­ h ï¼Œå› ä¸º h æ˜¯ default çš„æƒ…å†µã€‚\nåŸºç¡€è®¾æ–½ æ€è€ƒé¢˜ å¦‚ä½•æµ‹è¯•å­—ç¬¦ä¸²å¤„ç†å‡½æ•°ï¼Ÿ ä½ å¯èƒ½ä¼šæŠ‘åˆ¶ä¸ä½ç¼–ç çš„å†²åŠ¨: ä¸å…¶RTFM, è¿˜ä¸å¦‚è‡ªå·±å†™. å¦‚æœçœŸæ˜¯è¿™æ ·, ä½ å¯ä»¥è€ƒè™‘ä¸€ä¸‹, ä½ ä¼šå¦‚ä½•æµ‹è¯•è‡ªå·±ç¼–å†™çš„å­—ç¬¦ä¸²å¤„ç†å‡½æ•°?\nå¦‚æœä½ æ„¿æ„RTFM, ä¹Ÿä¸å¦¨æ€è€ƒä¸€ä¸‹è¿™ä¸ªé—®é¢˜, å› ä¸ºä½ ä¼šåœ¨PA2ä¸­é‡åˆ°ç±»ä¼¼çš„é—®é¢˜.\nç¬”è€…çš„ä¸€ç‚¹æ€è€ƒæ˜¯ï¼Œåœ¨æµ‹è¯•çš„æ—¶å€™ä¸€å®šè¦ä»”ç»†è€ƒè™‘å­—ç¬¦ä¸²è¡Œæœ«çš„ \u0026lsquo;\\0\u0026rsquo; é—®é¢˜ã€‚ç¬”è€…åœ¨å®ç°ç®€æ˜“çš„è¡¨è¾¾å¼æ±‚å€¼å‡½æ•°æ—¶ï¼Œåœ¨ make_token å‡½æ•°ä¸­ä½¿ç”¨ Cè¯­è¨€è‡ªå¸¦çš„ strncpy å‡½æ•°æ¥å°†ä¸€ä¸ªå­—ç¬¦ä¸²çš„ä¸€éƒ¨åˆ†æ‹·è´è¿› tokens æ•°ç»„ä¸­ï¼Œä½†åœ¨æµ‹è¯•æ—¶å‘ç°å¦‚æœ p è¿‡ä¹‹å x å† p ä¼šæ‰“å°æ„æƒ³ä¸åˆ°çš„ç»“æœã€‚\nä»”ç»†é˜…è¯» strncpy çš„æ‰‹å†Œï¼Œå‘ç°å…¶ä¸­æœ‰è¿™æ ·ä¸€å¥è¯ï¼š\nWarning: If there is no null byte among the first n bytes of src, the string placed in dest will not be null-terminated. è¿™æ­£å¥½æ˜¯ç¬”è€…åœ¨å¤åˆ¶ tokens è¿‡ç¨‹ä¸­é‡åˆ°çš„æƒ…å†µã€‚å› ä¸ºå¤åˆ¶è¿‡æ¥çš„å­—ç¬¦ä¸²ä¸å¸¦ç»“æŸç¬¦ï¼Œæ‰€ä»¥ strlen å‡½æ•°ä¸èƒ½å‡†ç¡®ç»™å‡ºå­—ç¬¦ä¸²é•¿åº¦ï¼Œä»è€Œå‡ºç°é”™è¯¯ã€‚\nè¡¥å…… RTFSC æŠ€å·§ å¦‚æœé‡åˆ°ä¸€ä¸ªå®æˆ–è€…ä¸€ä¸ªå‡½æ•°ä¸çŸ¥é“è¯¥åˆ°å“ªé‡Œå»æ‰¾æ¥æºï¼Œå¯ä»¥ä½¿ç”¨ grep xxx -r å‘½ä»¤æ¥å¯»æ‰¾æ‰€æœ‰åŒ…å«å…³é”®å­— xxx çš„æ–‡ä»¶ã€‚å½“ç„¶åœ¨ä½¿ç”¨äº†ç°ä»£çš„IDEï¼ˆå¦‚ vscodeï¼‰åè¿™æ–¹é¢çš„ç„¦è™‘ä¼šå°‘å¾ˆå¤šã€‚\nå…³äºåœ¨ nemu ä¸­ç›´æ¥ç”¨ q é€€å‡ºä¼šæŠ¥é”™ Error 1 åœ¨ nemu çš„ä¸»ç¨‹åº /nemu/src/nemu-main.c ä¸­æœ€åè°ƒç”¨äº†å‡½æ•° is_exit_status_bad()ï¼Œè¯¥å‡½æ•°åœ¨ /nemu/src/utils/state.c ä¸­ï¼Œæºç å¦‚ä¸‹ï¼š\nint is_exit_status_bad() { int good = (nemu_state.state == NEMU_END \u0026amp;\u0026amp; nemu_state.halt_ret == 0) || (nemu_state.state == NEMU_QUIT); return !good; } å¯ä»¥çœ‹åˆ°æ­£å¸¸é€€å‡ºçš„ä¸¤ä¸ªæ¡ä»¶\nç¨‹åºè¿è¡Œç»“æŸä¸”æ²¡æœ‰é‡åˆ°ä»»ä½•éæ­£å¸¸æƒ…å†µ æ‰§è¡Œäº† quit æ“ä½œ åˆ¤æ–­æ‰§è¡Œ quit æ“ä½œçš„æ–¹æ³•æ˜¯ nemu_state.state == NEMU_QUITï¼Œç„¶è€Œåœ¨æ¡†æ¶ä»£ç ä¸­çš„ cmd_q() ä¸­åªæœ‰ä¸€è¡Œ return -1ã€‚è¿™é‡Œçš„ return -1 åªæ˜¯ç”¨äºç»™ sdb_mainloop() ä¼ é€’ä¿¡æ¯ä½¿å…¶ç»“æŸï¼Œä½†æ²¡æœ‰åšå¥½æ ‡å¿—ä¿¡æ¯çš„è®¾ç½®ã€‚æ‰€ä»¥ä¿®æ”¹ cmd_q() ä¸º\nstatic int cmd_q() { nemu_state.state = NEMU_QUIT; return -1; } å†æ¬¡ç¼–è¯‘åï¼Œå³ä½¿åœ¨ç¨‹åºæœªè¿è¡Œç»“æŸæ—¶ quit ä¹Ÿä¸ä¼šæ”¶åˆ°æŠ¥é”™ã€‚\nå…³äºåœ¨ sdb.c ä¸­ä½¿ç”¨è®¿é—®å†…å­˜å‡½æ•°æŠ¥é”™ åœ¨æ‰«æå†…å­˜å‡½æ•°ä¸­ï¼Œç¬”è€…ä½¿ç”¨ paddr.c ä¸­å®šä¹‰çš„å‡½æ•° guest_to_host() å‡½æ•°æ¥è®¿é—®å†…å­˜ï¼Œä½†è¿è¡Œåæ˜¾ç¤º\nerror: implicit declaration of function 'guest_to_host' è¿™æ˜¯å› ä¸ºç¨‹åºæ‰¾ä¸åˆ°è¯¥å‡½æ•°çš„å®šä¹‰ï¼Œæˆ‘ä»¬å¯ä»¥ #include \u0026lt;memory/paddr.c\u0026gt; æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚\nå†…ç½®å®¢æˆ·ä»£ç æ”¾åœ¨äº†å“ªé‡Œï¼Ÿ è·Ÿç€ç¨‹åºè¿è¡Œçš„è¿‡ç¨‹ RTFSC æ˜¯ä¸€ä¸ªä¸é”™çš„æ–¹æ³•ï¼Œä¸è¿‡æ›´ç®€å•çš„æ˜¯æˆ‘ä»¬å¯ä»¥å……åˆ†ç›¸ä¿¡è‡ªå·±å†™çš„ç¨‹åºçš„æ­£ç¡®æ€§ï¼šç›´æ¥åœ¨ nemu æ–‡ä»¶å¤¹å†…æœç´¢æ‰“å°å‡ºçš„å†…å­˜ä¿¡æ¯ã€‚è¿…é€Ÿå®šä½åˆ°åœ¨ /nemu/src/isa/init.c ä¸­çš„ä»£ç ï¼š\n0x800002b7, // lui t0,0x80000 0x0002a023, // sw zero,0(t0) 0x0002a503, // lw a0,0(t0) 0x0000006b, // nemu_trap å’Œæ‰“å°å¾—åˆ°çš„ä¿¡æ¯æ¯”å¯¹ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ° riscv æ˜¯ä¸€ä¸ªå°ç«¯æœºå™¨ã€‚åœ¨ init_isa å‡½æ•°ä¸­æ˜¯é€šè¿‡\nmemcpy(gueset_to_host(RESET_VECTOR), img, sizeof(img)) çš„æ–¹å¼å°† img ä¸­çš„ä»£ç æ‹·è´è¿›å†…å­˜çš„ã€‚å¦å¤–æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼šå†…å­˜ä¸­æœªåˆå§‹åŒ–çš„éƒ¨åˆ†æ˜¯ä¹±ç ã€‚\nè¡¨è¾¾å¼æ±‚å€¼ æ€è€ƒé¢˜ ä¸ºä»€ä¹ˆprintf()çš„è¾“å‡ºè¦æ¢è¡Œ? å¦‚æœä¸æ¢è¡Œ, å¯èƒ½ä¼šå‘ç”Ÿä»€ä¹ˆ? ä½ å¯ä»¥åœ¨ä»£ç ä¸­å°è¯•ä¸€ä¸‹, å¹¶æ€è€ƒåŸå› , ç„¶åSTFWå¯¹æ¯”ä½ çš„æƒ³æ³•.\nç•™å‘ã€‚\n[äºŒå‘¨ç›®] ä¸ºä»€ä¹ˆè¦ä½¿ç”¨æ— ç¬¦å·ç±»å‹? æˆ‘ä»¬åœ¨è¡¨è¾¾å¼æ±‚å€¼ä¸­çº¦å®š, æ‰€æœ‰è¿ç®—éƒ½æ˜¯æ— ç¬¦å·è¿ç®—. ä½ çŸ¥é“ä¸ºä»€ä¹ˆè¦è¿™æ ·çº¦å®šå—? å¦‚æœè¿›è¡Œæœ‰ç¬¦å·è¿ç®—, æœ‰å¯èƒ½ä¼šå‘ç”Ÿä»€ä¹ˆé—®é¢˜?\nç•™å‘ã€‚ä¸€ä¸ªæƒ³æ³•æ˜¯å¼•å…¥è´Ÿæ•°å¯èƒ½ä¼šåœ¨è®¿å­˜æ—¶å‘ç”Ÿæ„æƒ³ä¸åˆ°çš„é—®é¢˜ï¼Œä½†è¿™ä¸ªé—®é¢˜ä¼¼ä¹å¯ä»¥é€šè¿‡è®¿å­˜å‰çš„åˆ¤æ–­æ¥ç­›é™¤ã€‚\nè¡¨è¾¾å¼ç”Ÿæˆå™¨å¦‚ä½•è·å¾—Cç¨‹åºçš„æ‰“å°ç»“æœ? ä»£ç ä¸­è¿™éƒ¨åˆ†çš„å†…å®¹æ²¡æœ‰ä»»ä½•æ³¨é‡Š, èªæ˜çš„ä½ ä¹Ÿè®¸é©¬ä¸Šå°±ååº”è¿‡æ¥: ç«Ÿç„¶æ˜¯ä¸ªRTFMçš„åœˆå¥—! é˜…è¯»æ‰‹å†Œäº†è§£APIçš„å…·ä½“è¡Œä¸ºå¯æ˜¯ç¨‹åºå‘˜çš„åŸºæœ¬åŠŸ. å¦‚æœè§‰å¾—å»å¹´ä¸€æ•´å¹´çš„ç¨‹åºå‘˜éƒ½ç™½å½“äº†, å°±ä»ç°åœ¨å¼€å§‹å¥½å¥½é”»ç‚¼å§.\ngen-expr.c ä¸­ä½¿ç”¨äº†å¦‚ä¸‹å‡ ä¸ªå€¼å¾—å€Ÿé‰´çš„å‡½æ•°ï¼š\nsprintf(code_buf, code_format, buf) ï¼Œè¯¥å‡½æ•°ç”¨äºå°† buf çš„å†…å®¹å¡«å…¥åˆ° code_format çš„ \u0026ldquo;%s\u0026rdquo; ä¸­ï¼Œå¹¶å°†æ•´æ®µcè¯­è¨€ä»£ç çš„å­—ç¬¦ä¸²æ”¾è¿› code_bufã€‚ system()ï¼Œç”¨äºæ‰§è¡Œä¸€ä¸ªå‘½ä»¤ï¼Œè¿”å›å€¼æ˜¯ä¸ºè¯¥å‘½ä»¤åˆ›å»ºçš„å­è¿›ç¨‹çš„è¿”å›å€¼ï¼Œå¦‚æœä¸æ˜¯ 0 è¯´æ˜æŒ‡ä»¤æ‰§è¡Œå¤±è´¥ã€‚ fopen/popen (\u0026quot;file\u0026quot;, \u0026quot;r\u0026quot;/\u0026quot;w\u0026quot;) ç”¨äºæ‰“å¼€æ–‡ä»¶ï¼Œåé¢çš„ r/w æŒ‡æ˜æ˜¯è¯»å–è¿˜æ˜¯å†™å…¥ã€‚æ ¹æ® STFW çš„ç»“æœï¼Œä¸¤è€…çš„åŒºåˆ«åœ¨äº popen() ä¼š fork ä¸€ä¸ªå­è¿›ç¨‹å¹¶å»ºç«‹ç®¡é“è¿æ¥ï¼ˆä¸æ‡‚ï¼Œç•™å‘ï¼‰ã€‚ç»æµ‹è¯•ï¼Œç¬¬ä¸€å¤„ fopen å¦‚æœæ¢æˆ popen ä¼šåœ¨å†™å…¥æ—¶æŠ¥é”™ Permission deniedï¼›ç¬¬äºŒå¤„ popen å¦‚æœæ¢æˆ fopen åˆ™æ— æ³•è¯»åˆ°ç¨‹åºçš„è¾“å‡ºç»“æœã€‚ è¡¥å…… å…³äºè¡¨è¾¾å¼ç”Ÿæˆ å¦‚æœç›´æ¥å°†ç”Ÿæˆçš„è¡¨è¾¾å¼å–‚ç»™Cè¯­è¨€ï¼ŒCè¯­è¨€ä¼šæŠŠå¸¸é‡å½“åšæ•´å‹å‚ä¸è¿ç®—ï¼Œä»è€Œå¾—åˆ°ä¸æ­£ç¡®çš„ç»“æœï¼Œå¦‚åœ¨ä¸‹é¢çš„ä¾‹å­ä¸­\n(0 - 1) / 10 åœ¨ int è§„åˆ™ä¸‹ç»“æœä¸º 0ï¼Œèµ‹ç»™ unsigned å˜é‡ä¹‹åç»“æœä»æ˜¯0ï¼Œè€Œåœ¨ unsigned è§„åˆ™ä¸‹ç»“æœæ˜¾ç„¶ä¸ä¸º0ã€‚unsigned å¯ä»¥çœ‹åš int çš„ä¸€ä¸ªå€¼åŸŸå³ç§»çš„ç‰ˆæœ¬ï¼Œåœ¨è¿™ä¸ªç‰ˆæœ¬ä¸‹åšä»»ä½•åŠ å‡æ“ä½œä¸ä¼šå½±å“æ­£ç¡®æ€§ï¼Œä½†åšä¹˜é™¤æ“ä½œæ—¶ä¼šå‘ç”Ÿé—®é¢˜ã€‚\nç¬”è€…çš„è§£å†³æ–¹æ¡ˆæ˜¯ï¼šç”Ÿæˆä¸¤ä¸ªè¡¨è¾¾å¼ï¼Œä¸€ä¸ªæ­£å¸¸çš„è¡¨è¾¾å¼ç”¨äºå–‚ç»™ nemuï¼Œå¦ä¸€ä¸ªè¡¨è¾¾å¼åœ¨æ¯ä¸ªå¸¸é‡åé¢æ·»åŠ ä¸€ä¸ª uï¼Œå°†å¸¸é‡è½¬åŒ–ä¸º unsigned ç±»å‹åå†å–‚ç»™Cè¯­è¨€ã€‚\nç¬”è€…å¹¶ä¸å¸Œæœ›é€šè¿‡è®¡ç®—çš„æ–¹å¼æ¥è¿‡æ»¤é™¤0çš„è¡¨è¾¾å¼ï¼Œå› æ­¤ä½¿ç”¨äº†ä¸€ç§æ¯”è¾ƒæ— è„‘çš„æš´åŠ›æ–¹æ³•ï¼š\nç¬”è€…ä¿®æ”¹äº†ç”Ÿæˆè¡¨è¾¾å¼çš„ BNF è§„èŒƒï¼Œåœ¨æ–°è§„èŒƒä¸­æ²¡æœ‰ \u0026lt;expr\u0026gt; / \u0026lt;expr\u0026gt; ï¼Œè€Œæ˜¯ \u0026lt;expr\u0026gt; / ((\u0026lt;expr\u0026gt;)*2+ 1)ã€‚æ— ç¬¦å·æ•°å¯ä»¥çœ‹ä½œåšå®Œæ‰€æœ‰æ“ä½œä»¥åå¯¹ $2^{32}$ å–æ¨¡ï¼Œç”±äºæ¨¡æ•°æ˜¯å¶æ•°ï¼Œå› æ­¤ \u0026lt;expr\u0026gt;*2+1 å–æ¨¡è¿‡åå¿…ç„¶æ˜¯ä¸€ä¸ªå¥‡æ•°ï¼Œè¿™æ ·å¯ä»¥ä¿è¯é™¤æ•°éé›¶ã€‚è¿™æ ·åšçš„å”¯ä¸€ç¼ºé™·æ˜¯ç”Ÿæˆçš„é™¤æ•°ä¸å†æ˜¯ç­‰æ¦‚ç‡åˆ†å¸ƒçš„ï¼Œä¸è¿‡åœ¨æµ‹è¯•æ­£ç¡®æ€§çš„è¿‡ç¨‹ä¸­é™¤æ•°åˆ†å¸ƒçš„å‡åŒ€æ— å…³ç´§è¦ã€‚\nç©ºæ ¼çš„æ’å…¥æ˜¯å®¹æ˜“çš„ï¼Œåªéœ€è¦åœ¨ BNF è§„èŒƒä¸­æ·»åŠ ä¸€æ¡ï¼š\u0026lt;expr\u0026gt; ::= \u0026quot; \u0026quot;\u0026lt;expr\u0026gt; å³å¯ã€‚\nåœ¨å½“å‰çš„éšæœºç”Ÿæˆæ–¹å¼ä¸‹ï¼Œç”Ÿæˆé•¿è¡¨è¾¾å¼çš„æ¦‚ç‡è¾ƒå°ã€‚å¦‚æœæƒ³ç”Ÿæˆæ›´å¤šçš„è¡¨è¾¾å¼ï¼Œå¯ä»¥ä¿®æ”¹éšæœºåˆ°å„ä¸ªéƒ¨åˆ†çš„æ¦‚ç‡ï¼Œä½¿ \u0026lt;expr\u0026gt; ::= \u0026lt;decimal number\u0026gt; | \u0026lt;heximal number\u0026gt; çš„æ¦‚ç‡å˜å°ã€‚æˆ–è€…è®¾ç½®ä¸€ä¸ªä¸‹ç•Œï¼Œå½“è¡¨è¾¾å¼æ€»é•¿å°äºä¸‹ç•Œæ—¶ä¸å…è®¸ç”Ÿæˆ \u0026lt;number\u0026gt;ã€‚\næ§åˆ¶è¡¨è¾¾å¼çš„é•¿åº¦ä¸è¶…è¿‡ buffer çš„é™åˆ¶æ˜¯å®¹æ˜“çš„ï¼šæˆ‘ä»¬åœ¨ç”Ÿæˆè¡¨è¾¾å¼çš„åŒæ—¶è®°å½•å½“å‰è¡¨è¾¾å¼çš„æ€»é•¿ï¼Œå½“æ€»é•¿è¶…è¿‡ä¸€ä¸ªé¢„è­¦å€¼æ—¶ï¼Œå¼ºåˆ¶æ–°è¡¨è¾¾å¼åªèƒ½ç”Ÿæˆå¸¸æ•°å³å¯ã€‚\nå…³äºè´Ÿæ•°åŠŸèƒ½ ç¬”è€…åœ¨ PA1 ä¸­å®ç°äº†è´Ÿæ•°åŠŸèƒ½ã€‚è´Ÿå·çš„è¯†åˆ«å’ŒæŒ‡é’ˆè§£å¼•ç”¨æ˜¯ç±»ä¼¼çš„ï¼šå¦‚æœä¸€ä¸ª - çš„å‰é¢æ˜¯åŒç›®è¿ç®—ç¬¦ï¼Œè´Ÿå·æˆ–è€… ( çš„è¯ï¼Œé‚£ä¹ˆå½“å‰çš„ - å°±æ˜¯è´Ÿå·ï¼ˆå•ç›®è¿ç®—ç¬¦ï¼‰ã€‚\nåœ¨è®¡ç®—çš„è¿‡ç¨‹ä¸­ï¼Œå¦‚æœä¸€ä¸ªè¡¨è¾¾å¼ç”±è´Ÿå·å¼€å¤´ï¼Œä¸”åé¢çš„éƒ¨åˆ†ä¸­æ²¡æœ‰â€œè£¸éœ²åœ¨å¤–â€ï¼ˆå³ä¸è¢«ä»»ä½•ä¸€å¯¹æ‹¬å·åŒ…è£¹ï¼‰çš„åŒç›®è¿ç®—ç¬¦ï¼Œåˆ™å¯ä»¥å‰¥ç¦»è¿™ä¸ªè´Ÿå·é€’å½’è®¡ç®—ï¼Œå°†å¾—åˆ°çš„ç­”æ¡ˆå–è´Ÿä¹‹åè¿”å›ã€‚\nç›‘è§†ç‚¹ æ€è€ƒé¢˜ æ¸©æ•…è€ŒçŸ¥æ–° æ¡†æ¶ä»£ç ä¸­å®šä¹‰wp_poolç­‰å˜é‡çš„æ—¶å€™ä½¿ç”¨äº†å…³é”®å­—static, staticåœ¨æ­¤å¤„çš„å«ä¹‰æ˜¯ä»€ä¹ˆ? ä¸ºä»€ä¹ˆè¦åœ¨æ­¤å¤„ä½¿ç”¨å®ƒ?\nstatic æœ€é‡è¦çš„ä½œç”¨åœ¨äºéšè—ã€‚å¸¦æœ‰ static çš„å˜é‡ä»¥åŠå‡½æ•°ä¸èƒ½åœ¨è¯¥æ–‡ä»¶ä»¥å¤–çš„åœ°æ–¹è®¿é—®å’Œä½¿ç”¨ã€‚ä¾‹å¦‚åœ¨ cpu-exec.c æ–‡ä»¶ä¸­ï¼Œæˆ‘ä»¬è¦å®ç°å¯¹æ‰€æœ‰ç›‘è§†ç‚¹çš„æ‰«æï¼Œä½†åˆä¸èƒ½ç›´æ¥è®¿é—® watchpoint.c ä¸­çš„ç›‘è§†ç‚¹æ± ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åœ¨ watchpoint.c ä¸­å†™ä¸€ä¸ªå‡½æ•°å®ç°è¿™ä¸ªåŠŸèƒ½ï¼Œå†é€šè¿‡åœ¨ cpu-exec.c ä¸­è°ƒç”¨è¿™ä¸ªé static çš„å‡½æ•°æ¥å®Œæˆä»»åŠ¡ã€‚ä½¿ç”¨ static å¯ä»¥ä¿è¯æœ¬æ–‡ä»¶ä¸­çš„ä¸œè¥¿ä¸ä¼šè¢«å¤–ç•Œæ±¡æŸ“ï¼Œå¦‚æœå‡ºç°é—®é¢˜ï¼Œå¯ä»¥åœ¨æœ¬æ–‡ä»¶ä¸­å¯»æ‰¾ bugï¼Œé™ä½äº†è°ƒè¯•éš¾åº¦ã€‚\nä½ ä¼šå¦‚ä½•æµ‹è¯•ä½ çš„ç›‘è§†ç‚¹å®ç°? æˆ‘ä»¬æ²¡æœ‰æä¾›ç›‘è§†ç‚¹ç›¸å…³çš„æµ‹è¯•, æ€è€ƒä¸€ä¸‹, ä½ ä¼šå¦‚ä½•æµ‹è¯•?\nå½“ç„¶, å¯¹äºå®éªŒæ¥è¯´, å°†æ¥è¾¹ç”¨è¾¹æµ‹ä¹Ÿæ˜¯ä¸€ç§è¯´å¾—è¿‡å»çš„æ–¹æ³•, å°±çœ‹ä½ å¯¹è‡ªå·±ä»£ç çš„ä¿¡å¿ƒäº†.\nç¬”è€…æ²¡æœ‰æ‰¹é‡ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹ï¼Œè€Œæ˜¯é’ˆå¯¹ç›‘è§†ç‚¹çš„å„ä¸ªåŠŸèƒ½è®¾è®¡äº†å‡ ç§æµ‹è¯•æ‰‹æ®µï¼š\næ¯æ‰§è¡Œå®Œä¸€æ¬¡æ“ä½œéƒ½ä½¿ç”¨å‘½ä»¤ info w æ£€æŸ¥æ‰€æœ‰ç›‘è§†ç‚¹æ˜¯å¦æ­£å¸¸ã€‚ ä½¿ç”¨è¡¨è¾¾å¼ w *0x80000000+1 ï¼Œæ£€æŸ¥æŒ‡é’ˆè§£å¼•ç”¨éƒ¨åˆ†çš„æ­£ç¡®æ€§ï¼Œ ä»¥åŠç›‘è§†ç‚¹é‡åˆ°å˜åŒ–æ˜¯å¦èƒ½æš‚åœç¨‹åºã€‚ ä½¿ç”¨è¡¨è¾¾å¼ w $t0 / 5ï¼Œæ£€æŸ¥å¯„å­˜å™¨è®¿é—®éƒ¨åˆ†çš„æ­£ç¡®æ€§ï¼ˆt0 æ˜¯å†…ç½®å®¢æˆ·ç¨‹åºä¸­å”¯ä¸€ä¿®æ”¹è¿‡çš„å¯„å­˜å™¨ï¼‰ã€‚ æ£€æµ‹ d å‘½ä»¤æ˜¯å¦èƒ½å®ç°ï¼Œä»¥åŠåˆ é™¤ä¸å­˜åœ¨çš„ç›‘è§†ç‚¹æ˜¯å¦å¯ä»¥æŠ¥é”™ã€‚ å°è¯•æ·»åŠ å¤§äºç›‘è§†ç‚¹æ± å®¹é‡çš„ç›‘è§†ç‚¹ï¼Œæ£€æŸ¥æ˜¯å¦èƒ½è§¦å‘ assertion failã€‚ å¼ºå¤§çš„GDB å¦‚æœä½ é‡åˆ°äº†æ®µé”™è¯¯, ä½ å¾ˆå¯èƒ½ä¼šæƒ³çŸ¥é“ç©¶ç«Ÿæ˜¯å“ªä¸€è¡Œä»£ç è§¦å‘äº†æ®µé”™è¯¯. å°è¯•ç¼–å†™ä¸€ä¸ªè§¦å‘æ®µé”™è¯¯çš„ç¨‹åº, ç„¶ååœ¨GDBä¸­è¿è¡Œå®ƒ. ä½ å‘ç°GDBèƒ½ä¸ºä½ æä¾›å“ªäº›æœ‰ç”¨çš„ä¿¡æ¯å—?\nç¬”è€…å°è¯•åœ¨ nemu ä¸­è¾“å…¥æŒ‡ä»¤ x 10 0x0ã€‚ç”±äº riscv32 çš„åœ°å€ä» 0x80000000 å¼€å§‹ï¼Œè¯¥å‘½ä»¤åœ¨è®¡ç®—åœ°å€æ—¶ä¼šå¾—åˆ°è´Ÿæ•°ä»è€Œå¼•å‘æ®µé”™è¯¯ã€‚GDB è¾“å‡ºäº†ä»¥ä¸‹ä¿¡æ¯ï¼š\nProgram received signal SIGSEGV, Segmentation fault. 0x0000555555562cfd in cmd_x () GDB å¯ä»¥å®šä½åˆ°å¼•å‘æ®µé”™è¯¯çš„å‡½æ•° cmd_x()ã€‚\n[äºŒå‘¨ç›®] å¦‚ä½•æé«˜æ–­ç‚¹çš„æ•ˆç‡ å¦‚æœä½ åœ¨è¿è¡Œç¨å¤§ä¸€äº›çš„ç¨‹åº(å¦‚microbench)çš„æ—¶å€™ä½¿ç”¨æ–­ç‚¹, ä½ ä¼šå‘ç°è®¾ç½®æ–­ç‚¹ä¹‹åä¼šæ˜æ˜¾åœ°é™ä½NEMUæ‰§è¡Œç¨‹åºçš„æ•ˆç‡. æ€è€ƒä¸€ä¸‹è¿™æ˜¯ä¸ºä»€ä¹ˆ? æœ‰ä»€ä¹ˆæ–¹æ³•è§£å†³è¿™ä¸ªé—®é¢˜å—?\nç•™å‘ã€‚\nä¸€ç‚¹ä¹Ÿä¸èƒ½é•¿? x86çš„int3æŒ‡ä»¤ä¸å¸¦ä»»ä½•æ“ä½œæ•°, æ“ä½œç ä¸º1ä¸ªå­—èŠ‚, å› æ­¤æŒ‡ä»¤çš„é•¿åº¦æ˜¯1ä¸ªå­—èŠ‚. è¿™æ˜¯å¿…é¡»çš„å—? å‡è®¾æœ‰ä¸€ç§x86ä½“ç³»ç»“æ„çš„å˜ç§my-x86, é™¤äº†int3æŒ‡ä»¤çš„é•¿åº¦å˜æˆäº†2ä¸ªå­—èŠ‚ä¹‹å¤–, å…¶ä½™æŒ‡ä»¤å’Œx86ç›¸åŒ. åœ¨my-x86ä¸­, ä¸Šè¿°æ–‡ç« ä¸­çš„æ–­ç‚¹æœºåˆ¶è¿˜å¯ä»¥æ­£å¸¸å·¥ä½œå—? ä¸ºä»€ä¹ˆ\nx86æ¶æ„æ”¯æŒä½¿ç”¨8ä½çš„ int æŒ‡ä»¤æ¥å®ç°ä¸­æ–­ï¼Œå…¶ä¸­ int3 ä¸ºCPUæ‰€æœ‰ï¼Œä¸“é—¨ç”¨äº debugger çš„ä¸­æ–­ã€‚å®ƒçš„åŸç†æ˜¯å°† 0xCC æ¢åˆ°å¯¹åº”æŒ‡ä»¤çš„ç¬¬ä¸€ä¸ªå­—èŠ‚ã€‚è¿™æ · CPU åœ¨è¯»å–æŒ‡ä»¤æ—¶é‡åˆ° 0xCC å°±ä¼šæš‚åœç¨‹åºçš„æ‰§è¡Œã€‚ä¹‹æ‰€ä»¥ä½¿ç”¨å•å­—çš„æŒ‡ä»¤ï¼Œæ˜¯å› ä¸ºè¿™æ ·ä¸è®ºè®¾ç½®æ–­ç‚¹çš„æŒ‡ä»¤æ˜¯å•å­—ã€åŒå­—è¿˜æ˜¯å››å­—ï¼Œæˆ‘ä»¬éƒ½å¯ä»¥åœ¨æœ¬æ¡æŒ‡ä»¤å†…éƒ¨å®Œæˆ int3 çš„æ ‡è®°ï¼Œä¸ä¼šå†™åˆ°ä¸‹ä¸€æ¡æŒ‡ä»¤ä¸­ã€‚\nåœ¨æœ¬é¢˜ä¸­ï¼Œå¦‚æœä½¿ç”¨2ä¸ªå­—èŠ‚çš„æŒ‡ä»¤ï¼Œåˆ™åœ¨å¯¹å•å­—æŒ‡ä»¤è¿›è¡Œæ ‡è®°æ—¶ä¼šå†™åˆ°åˆ«çš„å­˜å‚¨åŒºåŸŸä¸­ï¼Œä»è€Œå¯èƒ½å‡ºé”™ã€‚\néšå¿ƒæ‰€æ¬²çš„æ–­ç‚¹ å¦‚æœæŠŠæ–­ç‚¹è®¾ç½®åœ¨æŒ‡ä»¤çš„éé¦–å­—èŠ‚(ä¸­é—´æˆ–æœ«å°¾), ä¼šå‘ç”Ÿä»€ä¹ˆ? ä½ å¯ä»¥åœ¨GDBä¸­å°è¯•ä¸€ä¸‹, ç„¶åæ€è€ƒå¹¶è§£é‡Šå…¶ä¸­çš„ç¼˜ç”±.\nç¬”è€…å­¦ä¹ äº†å¦‚ä½•åœ¨æŒ‡å®šçš„åœ°å€æ·»åŠ æ–­ç‚¹ã€‚å¯¹äºä¸€ä¸ªè¾“å‡º hello world çš„ç®€å•Cç¨‹åºï¼Œç”¨ gdb è¿è¡Œåè®¾ç½®æ–­ç‚¹ b *main ï¼Œè¿è¡Œæš‚åœåè¾“å…¥å‘½ä»¤ disassembleï¼Œå¯ä»¥çœ‹åˆ°\n=\u0026gt; 0x0000555555555149 \u0026lt;+0\u0026gt;: endbr64 0x000055555555514d \u0026lt;+4\u0026gt;: push %rbp 0x000055555555514e \u0026lt;+5\u0026gt;: mov %rsp,%rbp 0x0000555555555151 \u0026lt;+8\u0026gt;: sub $0x10,%rsp 0x0000555555555155 \u0026lt;+12\u0026gt;: movl $0x1,-0xc(%rbp) 0x000055555555515c \u0026lt;+19\u0026gt;: movl $0x2,-0x8(%rbp) 0x0000555555555163 \u0026lt;+26\u0026gt;: mov -0xc(%rbp),%edx 0x0000555555555166 \u0026lt;+29\u0026gt;: mov -0x8(%rbp),%eax 0x0000555555555169 \u0026lt;+32\u0026gt;: add %edx,%eax 0x000055555555516b \u0026lt;+34\u0026gt;: mov %eax,-0x4(%rbp) 0x000055555555516e \u0026lt;+37\u0026gt;: mov -0x4(%rbp),%eax 0x0000555555555171 \u0026lt;+40\u0026gt;: mov %eax,%esi 0x0000555555555173 \u0026lt;+42\u0026gt;: lea 0xe8a(%rip),%rdi # 0x555555556004 0x000055555555517a \u0026lt;+49\u0026gt;: mov $0x0,%eax 0x000055555555517f \u0026lt;+54\u0026gt;: call 0x555555555050 \u0026lt;printf@plt\u0026gt; 0x0000555555555184 \u0026lt;+59\u0026gt;: mov $0x0,%eax 0x0000555555555189 \u0026lt;+64\u0026gt;: leave 0x000055555555518a \u0026lt;+65\u0026gt;: ret æˆ‘ä»¬å¯ä»¥çœ‹åˆ°æ¯æ¡æ±‡ç¼–æŒ‡ä»¤çš„åœ°å€ã€‚ç¬”è€…è®¾ç½®äº†æ–­ç‚¹ b *main+55 ï¼Œè¯¥ä½ç½®ä¸åœ¨æŒ‡ä»¤çš„é¦–å­—èŠ‚ï¼Œç»§ç»­è¿è¡Œå GDB æ²¡æœ‰æ£€æµ‹åˆ°è¿™ä¸ªæ–­ç‚¹ã€‚ç¬”è€…è®¤ä¸º GDB æ£€æµ‹æ–­ç‚¹çš„æœºåˆ¶æ˜¯æ¯æ¬¡å–æŒ‡è¯‘ç æ—¶æ ¹æ®é¦–å­—èŠ‚æ˜¯å¦æ˜¯ 0xCC æ¥åˆ¤æ–­æ˜¯å¦æœ‰æ–­ç‚¹ï¼Œå› æ­¤å°†æ ‡å¿—ä¿¡æ¯è®¾ç½®åœ¨éé¦–å­—èŠ‚æ˜¯æ— æ³•è¢«è¯†åˆ«çš„ã€‚\nNEMUçš„å‰ä¸–ä»Šç”Ÿ ä½ å·²ç»å¯¹NEMUçš„å·¥ä½œæ–¹å¼æœ‰æ‰€äº†è§£äº†. äº‹å®ä¸Šåœ¨NEMUè¯ç”Ÿä¹‹å‰, NEMUæ›¾ç»æœ‰ä¸€æ®µæ—¶é—´å¹¶ä¸å«NEMU, è€Œæ˜¯å«NDB(NJU Debugger), åæ¥ç”±äºæŸç§åŸå› æ‰æ”¹åä¸ºNEMU. å¦‚æœä½ æƒ³çŸ¥é“è¿™ä¸€æ®µå²å‰çš„ç§˜å¯†, ä½ é¦–å…ˆéœ€è¦äº†è§£è¿™æ ·ä¸€ä¸ªé—®é¢˜: æ¨¡æ‹Ÿå™¨(Emulator)å’Œè°ƒè¯•å™¨(Debugger)æœ‰ä»€ä¹ˆä¸åŒ? æ›´å…·ä½“åœ°, å’ŒNEMUç›¸æ¯”, GDBåˆ°åº•æ˜¯å¦‚ä½•è°ƒè¯•ç¨‹åºçš„?\nç•™å‘ã€‚ç¬”è€…æš‚æ—¶è®¤ä¸ºè°ƒè¯•å™¨æ˜¯å¯ä»¥æ¥è§¦åº•å±‚çš„ç¡¬ä»¶å’Œæ•°æ®çš„ï¼Œä¸ºç¨‹åºå‘˜åé¦ˆä¿¡æ¯çš„åº”ç”¨ç¨‹åºï¼ŒNEMU ç›¸å½“äºå†…ç½®äº†ä¸€ä¸ªè°ƒè¯•å™¨çš„åŠŸèƒ½ï¼Œå…¶æœ¬èº«ä¸åªæ˜¯åº”ç”¨ç¨‹åºï¼Œè€Œæ˜¯ä¸€æ•´å¥—è™šæ‹Ÿæœºã€‚\nè¡¥å…… å…³äº sscanf å‡½æ•° ç¬”è€…ä¹‹å‰åœ¨å¤„ç†æŒ‡ä»¤ä¸­çš„å¸¸æ•°æ—¶æ˜¯é€šè¿‡ä¸€ä½ä¸€ä½è¯»å–å¹¶è®¡ç®—çš„æ–¹å¼æ¥å°†å…¶è½¬æ¢ä¸º int å‹çš„ã€‚åœ¨ RTFSC çš„è¿‡ç¨‹ä¸­å‘ç° sscanf å‡½æ•°å¯ä»¥ç®€æ´åœ°å®ç°è¿™ä¸ªåŠŸèƒ½ã€‚ä¾‹å¦‚æœ‰ int å‹å˜é‡ Nï¼Œæœ‰å­˜å‚¨ç€å¸¸æ•°çš„å­—ç¬¦ä¸² argï¼Œåˆ™å¯ä»¥é€šè¿‡ sscanf(arg, \u0026quot;%d\u0026quot;, \u0026amp;N) æ¥å°† arg çš„å†…å®¹è½¬æ¢æˆæ•´æ•°å­˜è¿› Nã€‚\nAddress Sanitizer å®ç° use-after-free æ£€æµ‹çš„åŸç† ç•™å‘ã€‚\nå¦‚ä½•é˜…è¯»æ‰‹å†Œ å¿…ç­”é¢˜ å°è¯•é€šè¿‡ç›®å½•å®šä½å…³æ³¨çš„é—®é¢˜ å‡è®¾ä½ ç°åœ¨éœ€è¦äº†è§£ä¸€ä¸ªå«selectorçš„æ¦‚å¿µ, è¯·é€šè¿‡i386æ‰‹å†Œçš„ç›®å½•ç¡®å®šä½ éœ€è¦é˜…è¯»æ‰‹å†Œä¸­çš„å“ªäº›åœ°æ–¹. å³ä½¿ä½ é€‰æ‹©çš„ISAå¹¶ä¸æ˜¯x86, ä¹Ÿå¯ä»¥å°è¯•å»æŸ¥é˜…è¿™ä¸ªæ¦‚å¿µ.\nåœ¨ I386 æ‰‹å†Œçš„ 5.1.3 èŠ‚ä¸­å¯ä»¥æ‰¾åˆ°å’Œ selector æœ‰å…³çš„å†…å®¹ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"a46e57d8c94068d4be2fd92a7c7cb917","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-ics/pa/pa1/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/nju-ics/pa/pa1/","section":"notes","summary":"å®éªŒè¿›åº¦ æˆ‘å®Œæˆäº†æ‰€æœ‰çš„å¿…ç­”é¢˜ï¼Œå¹¶é’ˆå¯¹é€‰åšé¢˜å’Œæ€è€ƒé¢˜ç»™å‡ºäº†è‡ªå·±çš„æƒ³æ³•ã€‚\nå¿…ç­”é¢˜ ç¨‹åºæ˜¯ä¸ªçŠ¶æ€æœº ç‚¹å‡» è¿™é‡Œ è·³è½¬åˆ°è§£ç­”ã€‚\nç†è§£åŸºç¡€è®¾æ–½ æœ‰ 450 æ¬¡ç¼–è¯‘ç”¨äºè°ƒè¯•ï¼Œå‡è®¾åªæœ‰ 450 ä¸ª bugï¼Œé‚£ä¹ˆæ€»å…±éœ€è¦ 4500min = 75h ã€‚ç®€æ˜“è°ƒè¯•å™¨å¯ä»¥èŠ‚çº¦ 50h çš„æ—¶é—´ã€‚\nRTFM riscv32æœ‰å“ªå‡ ç§æŒ‡ä»¤æ ¼å¼?\nåœ¨ Volume I - 2.2 èŠ‚å¯ä»¥æŸ¥åˆ° Base Instruction Formats, åœ¨ Volume I -17.","tags":null,"title":"PA1 - å¼€å¤©è¾Ÿåœ°çš„ç¯‡ç« ï¼šæœ€ç®€å•çš„è®¡ç®—æœº","type":"docs"},{"authors":null,"categories":null,"content":"Overview è¯¥å®éªŒçš„ç›®çš„æ˜¯å®Œæˆ cool compiler çš„ lexical analysis éƒ¨åˆ†ã€‚è¯¾å ‚ä¸Šè®²è§£äº†ç”¨æ­£åˆ™è¡¨è¾¾å¼æè¿°è¯æ±‡æ ¼å¼ä»¥åŠå¦‚ä½•æ ¹æ®æ­£åˆ™è¡¨è¾¾å¼ç”Ÿæˆ NFAï¼Œé€šè¿‡ NFA è½¬ DFAï¼Œå†å°† DFA ä»¥äºŒç»´è¡¨çš„å½¢å¼å­˜å‚¨ä¸‹æ¥ã€‚ä¸è¿‡ç°åœ¨æœ‰æˆç†Ÿçš„å·¥å…·å¯ä»¥å®Œæˆæ­£åˆ™è¡¨è¾¾å¼çš„ implementationï¼Œæ‰€ä»¥æœ¬å®éªŒä¸­æˆ‘ä»¬åªéœ€è¦è€ƒè™‘å¦‚ä½•ç”¨æ­£åˆ™è¡¨è¾¾å¼æè¿° cool è¯­è¨€çš„è¯æ±‡ï¼Œä¸éœ€è¦è€ƒè™‘è‡ªåŠ¨æœºã€‚\nç¬”è€…é€‰æ‹©äº† C++ ç‰ˆæœ¬çš„å®éªŒã€‚æœ¬å®éªŒä¸­æˆ‘ä»¬ä½¿ç”¨ flex å·¥å…·æ¥å®Œæˆæ­£åˆ™è¡¨è¾¾å¼çš„ implementationã€‚æˆ‘ä»¬è¯†åˆ«å‡ºä¸€ä¸ª token åéœ€è¦å‘ flex ç”Ÿæˆçš„ yylex() å‡½æ•°è¿”å› token çš„ç¼–å· (åœ¨ cool-parse.h ä¸­å®šä¹‰)ï¼Œå¦‚æœå½“å‰ token æœ‰é¢å¤–çš„è¯­ä¹‰ä¿¡æ¯ (æ¯”å¦‚å­—ç¬¦ä¸²ï¼Œbool const) åˆ™éœ€è¦åœ¨ coolyyval è¿™ä¸ª union çš„ç›¸åº”å­—æ®µä¸­å¡«å†™ä¿¡æ¯ã€‚\né¡ºåˆ©å®Œæˆè¯¥å®éªŒçš„é‡è¦å‰ææ˜¯ä»”ç»†é˜…è¯»å®˜æ–¹æä¾›çš„å„ç§æ‰‹å†Œï¼š\né˜…è¯» flex manual çš„å‰ 10 ä¸ª section ä»¥ç†Ÿæ‚‰ flex çš„è¯­æ³•ã€‚ é˜…è¯» cool manual çš„ç¬¬ 10 ç« ä»¥åŠ Figure 1 ä»¥äº†è§£ cool çš„è¯­æ³•è§„åˆ™ã€‚ é˜…è¯» PA1 çš„è®²ä¹‰ï¼Œè¯¥è®²ä¹‰çš„é€»è¾‘ä¸å¤ªæ¸…æ™°ï¼Œå„ç§å¯¹è¿”å›å€¼çš„ specification æ•£è½åœ¨è®²ä¹‰çš„å„ä¸ªè§’è½ï¼Œéœ€è¦éå¸¸ä»”ç»†åœ°å¯»æ‰¾ã€‚ Tokens cool çš„ç¼–è¯‘å™¨éœ€è¦è¯†åˆ«ä»¥ä¸‹å‡ ç±» tokenï¼š\nInteger: éç©ºçš„ç”± 0~9 æ„æˆçš„å­—ç¬¦ä¸²ã€‚ Identifier: identifier éƒ½æ˜¯ç”±å°å†™/å¤§å†™å­—æ¯ã€æ•°å­—å’Œä¸‹åˆ’çº¿æ„æˆçš„éç©ºå­—ç¬¦ä¸²ã€‚type identifier è¦æ±‚ç¬¬ä¸€ä¸ªå­—ç¬¦å¿…é¡»æ˜¯å°å†™å­—æ¯ï¼Œobject identifier è¦æ±‚ç¬¬ä¸€ä¸ªå­—ç¬¦å¿…é¡»æ˜¯å¤§å†™å­—æ¯ã€‚ Operator: å„ç§ç¬¦å·ï¼Œé™¤äº† \u0026lt;= \u0026lt;- =\u0026gt; ä¸‰ä¸ªå¤šå­—ç¬¦ç¬¦å·æœ‰ä¸“é—¨çš„ token idï¼Œå…¶ä½™çš„ç¬¦å·ç›´æ¥è¿”å› ascii ç ã€‚ Keyword: å…³é”®å­—éƒ½æœ‰å„è‡ªå®šä¹‰å¥½çš„ token idã€‚true å’Œ false è¿™ä¸¤ä¸ªå…³é”®å­—è¦æ±‚é¦–å­—æ¯å¿…é¡»å°å†™ï¼Œå…¶ä½™çš„å…³é”®å­—éƒ½æ˜¯å¤§å°å†™ä¸æ•æ„Ÿçš„ã€‚ White space: ç¼–è¯‘å™¨éœ€è¦æ ¹æ® \\n æ­£ç¡®åˆ¤æ–­è¡Œå·ï¼Œå¹¶è¿‡æ»¤ \\v \\r \\f \\t å‡ ç§ç©ºç™½å­—ç¬¦ã€‚ String, Comments: è¿™ä¸¤ä¸ªç±»åˆ«æ¯”è¾ƒå¤æ‚ï¼Œä¸‹é¢ä¸“é—¨è®¨è®ºã€‚ Comments æ³¨é‡Šåˆ†ä¸º inline comment å’Œ block comment ä¸¤ç§ï¼Œå†™æ³•å¤§åŒå°å¼‚ã€‚å› ä¸ºæˆ‘ä»¬è¦åæ‰æ³¨é‡Šä¸­çš„æ‰€æœ‰å­—ç¬¦ï¼Œæ³¨é‡Šä¸­å­—ç¬¦çš„ action å’Œå¤–é¢ä¸ä¸€æ ·ï¼Œæ‰€ä»¥å¯¹äº comment æˆ‘ä»¬æœ€å¥½ä½¿ç”¨ flex çš„ start condition æœºåˆ¶æ¥è¯†åˆ«ã€‚\nå½“é‡åˆ° (* æ—¶ï¼Œè¿›å…¥ COMMENT çŠ¶æ€ï¼Œåœ¨ COMMENT çŠ¶æ€ä¸­ï¼Œæˆ‘ä»¬åªéœ€è¦ç‰¹æ®Šå¤„ç†æ¢è¡Œç¬¦å’Œ \u0026lt;EOF\u0026gt;ï¼Œå…¶ä½™çš„å­—ç¬¦éƒ½å¯ä»¥ç›´æ¥åæ‰ã€‚\nStrings å¤„ç† string æˆ‘ä»¬æœ€å¥½ä¹Ÿä½¿ç”¨ start condition æœºåˆ¶ã€‚string ä¸­æœ‰æ›´å¤šçš„é™åˆ¶ï¼Œæ¯”å¦‚ä¸èƒ½æœ‰ unescaped çš„ \\nï¼Œä¸èƒ½æœ‰ \\0ï¼Œä¸èƒ½æœ‰ \u0026lt;EOF\u0026gt;ï¼Œä»¥åŠè¦å•ç‹¬å¤„ç†ç‰¹æ®Šå­—ç¬¦ç­‰ã€‚\næ³¨æ„æ‰‹å†Œä¸­å¯¹ string é”™è¯¯å¤„ç†çš„è¦æ±‚ï¼šå¦‚æœä¸€ä¸ª string ä¸­æœ‰å¤šä¸ªé”™è¯¯ï¼Œåªè¿”å›ç¬¬ä¸€ä¸ªé”™è¯¯çš„ç›¸å…³ä¿¡æ¯ï¼›å½“ä¸€ä¸ª string é”™è¯¯æ—¶ï¼Œä¸‹ä¸€æ¬¡æ‰«æåº”å½“ä»è¿™ä¸ª string ç»“æŸçš„åœ°æ–¹å¼€å§‹ (unescaped \\n or \\\u0026quot;)ã€‚æœ‰çš„äººé€‰æ‹©å…ˆå°†æ•´ä¸ª string æ— è„‘è¯†åˆ«å¹¶å­˜å‚¨ä¸‹æ¥ï¼Œç„¶åå¯¹ç€ char æ•°ç»„å¤„ç†å„ç§ç‰¹æ®Šå­—ç¬¦å’Œé”™è¯¯ã€‚ç¬”è€…é‡‡å–çš„åšæ³•æ˜¯åœ¨é‡åˆ° ERROR åå†è¿›å…¥ä¸€ä¸ª \u0026lt;STR_ERROR\u0026gt; çš„ start conditionï¼Œåœ¨è¿™ç§çŠ¶æ€ä¸­ä¸å†å­—ç¬¦å¤„ç†å’Œ error handlingï¼Œä¸€è·¯æ‰«åˆ° string çš„ç»“æŸã€‚\nMiscellaneous è¿™é‡Œåˆ—ä¸¾ä¸€äº›æ˜“æ¼æ˜“é”™ç‚¹ï¼š\nè¦æ³¨æ„è¯†åˆ«æ²¡æœ‰ (* åŒ¹é…çš„å•ç‹¬çš„ *)ï¼Œè¿”å› unmatched *)ã€‚ åœ¨ string, comment ç­‰çŠ¶æ€ä¸­è¦è¿”å› ERROR æ—¶ï¼Œä¸è¦å¿˜äº†åœ¨è¿”å›å‰å°† start condition é‡ç½®ä¸º INITIALï¼Œå› ä¸ºæˆ‘ä»¬è¦å®Œæ•´åœ°å¤„ç†æ•´ä¸ªè¾“å…¥ï¼Œé‡åˆ° ERROR ä¹‹åå‰©ä¸‹çš„å†…å®¹ä¹Ÿä¸èƒ½æ‘†çƒ‚ã€‚ , n å’Œ \\n æ˜¯ä¸ä¸€æ ·çš„ã€‚åœ¨ string ä¸­å•ç‹¬å‡ºç°çš„ä¸¤ä¸ªå­—ç¬¦ (ä¾‹å¦‚ \u0026ldquo;\\n\u0026rdquo;) åº”å½“ä¿ç•™å¹¶åˆå¹¶æˆä¸€ä¸ªå­—ç¬¦ï¼ŒçœŸæ­£çš„ç‰¹æ®Šå­—ç¬¦æ˜¯ä¸€ä¸ªä¸å¯è§å­—ç¬¦ã€‚ \\ ä¹‹åå†è·Ÿç‰¹æ®Šå­—ç¬¦ \\0 æ˜¯ä¸€ä¸ªå®¹æ˜“å¿½ç•¥çš„æƒ…å†µã€‚æˆ‘ä»¬é€šå¸¸ä¼šå¯¹ \\0 è®¾ç½®ä¸€ä¸ª rule è¯†åˆ«ï¼Œä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼å¤„ç†è½¬ä¹‰å­—ç¬¦ï¼Œéœ€è¦æ³¨æ„è½¬ä¹‰å­—ç¬¦åé¢è·Ÿçš„å­—ç¬¦ä¹Ÿå¯èƒ½æ˜¯ null characterã€‚ ä¸ºäº†æ­£ç¡®åœ°è·å¾— string çš„è¡Œå·ï¼Œå¯¹äº unterminated çš„ string æœ€å¥½ä½¿ç”¨ yyless(0) å°† \\n é€€å›ï¼Œè®©ç¼–è¯‘å™¨åœ¨ INITIAL çš„çŠ¶æ€ä¸‹å¤„ç†è¿™ä¸ªæ¢è¡Œç¬¦ï¼Œå¦åˆ™ unterminated çš„ string çš„è¡Œå·ä¼šå¤§1ã€‚ ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"5e4c369faa3c2e4ecd2324666dd33d68","permalink":"https://kristoff-starling.github.io/notes/coursenotes/stanford-compiler/pa/pa1/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/stanford-compiler/pa/pa1/","section":"notes","summary":"Overview è¯¥å®éªŒçš„ç›®çš„æ˜¯å®Œæˆ cool compiler çš„ lexical analysis éƒ¨åˆ†ã€‚è¯¾å ‚ä¸Šè®²è§£äº†ç”¨æ­£åˆ™è¡¨è¾¾å¼æè¿°è¯æ±‡æ ¼å¼ä»¥åŠå¦‚ä½•æ ¹æ®æ­£åˆ™è¡¨è¾¾å¼ç”Ÿæˆ NFAï¼Œé€šè¿‡ NFA è½¬ DFAï¼Œå†å°† DFA ä»¥äºŒç»´è¡¨çš„å½¢å¼å­˜å‚¨ä¸‹æ¥ã€‚ä¸è¿‡ç°åœ¨æœ‰æˆç†Ÿçš„å·¥å…·å¯ä»¥å®Œæˆæ­£åˆ™è¡¨è¾¾å¼çš„ implementationï¼Œæ‰€ä»¥æœ¬å®éªŒä¸­æˆ‘ä»¬åªéœ€è¦è€ƒè™‘å¦‚ä½•ç”¨æ­£åˆ™è¡¨è¾¾å¼æè¿° cool è¯­è¨€çš„è¯æ±‡ï¼Œä¸éœ€è¦è€ƒè™‘è‡ªåŠ¨æœºã€‚\nç¬”è€…é€‰æ‹©äº† C++ ç‰ˆæœ¬çš„å®éªŒã€‚æœ¬å®éªŒä¸­æˆ‘ä»¬ä½¿ç”¨ flex å·¥å…·æ¥å®Œæˆæ­£åˆ™è¡¨è¾¾å¼çš„ implementationã€‚æˆ‘ä»¬è¯†åˆ«å‡ºä¸€ä¸ª token åéœ€è¦å‘ flex ç”Ÿæˆçš„ yylex() å‡½æ•°è¿”å› token çš„ç¼–å· (åœ¨ cool-parse.","tags":null,"title":"Stanford-CS143 PA1: Lexical Analysis","type":"docs"},{"authors":null,"categories":null,"content":"å®éªŒè¿›åº¦ æˆ‘å®Œæˆäº†æ‰€æœ‰çš„å¿…ç­”é¢˜ï¼Œå¹¶é’ˆå¯¹é€‰åšé¢˜å’Œæ€è€ƒé¢˜ç»™å‡ºäº†è‡ªå·±çš„æƒ³æ³•ã€‚\nå¿…ç­”é¢˜ ç¨‹åºæ˜¯ä¸ªçŠ¶æ€æœº ç‚¹å‡» è¿™é‡Œè·³è½¬åˆ°è§£ç­”ã€‚\nRTFSC ç‚¹å‡» è¿™é‡Œè·³è½¬åˆ°è§£ç­”ã€‚\nç¨‹åºå¦‚ä½•è¿è¡Œ ç‚¹å‡» è¿™é‡Œè·³è½¬åˆ°è§£ç­”ã€‚\nç¼–è¯‘ä¸é“¾æ¥ åœ¨nemu/src/engine/interpreter/rtl-basic.hä¸­, ä½ ä¼šçœ‹åˆ°ç”±static inlineå¼€å¤´å®šä¹‰çš„å„ç§RTLæŒ‡ä»¤å‡½æ•°. é€‰æ‹©å…¶ä¸­ä¸€ä¸ªå‡½æ•°, åˆ†åˆ«å°è¯•å»æ‰static, å»æ‰inlineæˆ–å»æ‰ä¸¤è€…, ç„¶åé‡æ–°è¿›è¡Œç¼–è¯‘, ä½ å¯èƒ½ä¼šçœ‹åˆ°å‘ç”Ÿé”™è¯¯. è¯·åˆ†åˆ«è§£é‡Šä¸ºä»€ä¹ˆè¿™äº›é”™è¯¯ä¼šå‘ç”Ÿ/ä¸å‘ç”Ÿ? ä½ æœ‰åŠæ³•è¯æ˜ä½ çš„æƒ³æ³•å—?\nå¦‚æœå»æ‰ inlineï¼Œç¼–è¯‘æ—¶ä¼šæŠ¥é”™ï¼šxxx defined but not usedã€‚è¿™æ˜¯å› ä¸º rtl.h æ–‡ä»¶ include äº† rtl-basic.h ï¼Œä½†å¹¶æ²¡æœ‰ä½¿ç”¨è¿™ä¸ªå‡½æ•°ï¼Œå› æ­¤è§¦å‘äº† -Werror ç¼–è¯‘é€‰é¡¹ã€‚\nå¦‚æœå»æ‰ staticï¼Œç¼–è¯‘æ—¶ä¸ä¼šæŠ¥é”™ã€‚è¿™æ˜¯å› ä¸ºè¿™é‡Œçš„å‡½æ•°è¢«å®šä¹‰æˆäº†å†…è”å‡½æ•°ï¼Œå‡½æ•°å†…å®¹è¢«ç›´æ¥å¡è¿›äº†è°ƒç”¨è€…çš„å‡½æ•°ä½“ä¸­ã€‚å¦‚æœæˆ‘ä»¬ç”¨ objdump -d å‘½ä»¤å»æ£€æŸ¥ç¼–è¯‘å¾—åˆ°çš„æ±‡ç¼–ç¨‹åºï¼Œæˆ‘ä»¬ä¼šå‘ç° rtl_xx ç­‰ä¸€ç³»åˆ—å‡½æ•°æ˜¯ä¸åœ¨å…¶ä¸­çš„ã€‚\nå¦‚æœåŒæ—¶å»æ‰ static å’Œ inlineï¼Œç¼–è¯‘æ—¶ä¼šæŠ¥é”™ï¼šmultiple definition of xxxã€‚æ­¤æ—¶å†æŸ¥çœ‹æ±‡ç¼–ç¨‹åºå¯ä»¥å‘ç° rtl_xx åœ¨å…¶ä¸­ã€‚å› ä¸º rtl_xx åŒæ—¶å‡ºç°åœ¨äº† cpu-exec.o hostcall.o å’Œ decode.o ä¸­ï¼Œæ‰€ä»¥é“¾æ¥æ—¶ä¼šå‡ºé”™ã€‚è¿™é‡Œä¸€ä¸ªå€¼å¾—å…³æ³¨çš„ç»†èŠ‚æ˜¯ï¼šæˆ‘ä»¬ç¼–å†™çš„å‡½æ•° exec_addi è°ƒç”¨äº† rtl_addi ï¼Œä½†åœ¨æ±‡ç¼–ä»£ç ä¸­å¹¶æ²¡æœ‰è¿™ä¸€æ¡è°ƒç”¨ã€‚å¯ä»¥çœ‹åˆ° rtl_addi çš„å†…å®¹è¢«ç›´æ¥è´´è¿›äº† exec_addi çš„å‡½æ•°ä½“ä¸­ã€‚è¿™åº”è¯¥æ˜¯ç¼–è¯‘å™¨é’ˆå¯¹ addi è¿™ç§æå…¶ç®€çŸ­çš„å‡½æ•°è°ƒç”¨åšå‡ºçš„ä¸€ç§ä¼˜åŒ–ã€‚\nç¼–è¯‘ä¸é“¾æ¥2 åœ¨nemu/include/common.hä¸­æ·»åŠ ä¸€è¡Œvolatile static int dummy; ç„¶åé‡æ–°ç¼–è¯‘NEMU. è¯·é—®é‡æ–°ç¼–è¯‘åçš„NEMUå«æœ‰å¤šå°‘ä¸ªdummyå˜é‡çš„å®ä½“? ä½ æ˜¯å¦‚ä½•å¾—åˆ°è¿™ä¸ªç»“æœçš„? æ·»åŠ ä¸Šé¢˜ä¸­çš„ä»£ç å, å†åœ¨nemu/include/debug.hä¸­æ·»åŠ ä¸€è¡Œvolatile static int dummy; ç„¶åé‡æ–°ç¼–è¯‘NEMU. è¯·é—®æ­¤æ—¶çš„NEMUå«æœ‰å¤šå°‘ä¸ªdummyå˜é‡çš„å®ä½“? ä¸ä¸Šé¢˜ä¸­dummyå˜é‡å®ä½“æ•°ç›®è¿›è¡Œæ¯”è¾ƒ, å¹¶è§£é‡Šæœ¬é¢˜çš„ç»“æœ. ä¿®æ”¹æ·»åŠ çš„ä»£ç , ä¸ºä¸¤å¤„dummyå˜é‡è¿›è¡Œåˆå§‹åŒ–:volatile static int dummy = 0; ç„¶åé‡æ–°ç¼–è¯‘NEMU. ä½ å‘ç°äº†ä»€ä¹ˆé—®é¢˜? ä¸ºä»€ä¹ˆä¹‹å‰æ²¡æœ‰å‡ºç°è¿™æ ·çš„é—®é¢˜? (å›ç­”å®Œæœ¬é¢˜åå¯ä»¥åˆ é™¤æ·»åŠ çš„ä»£ç .) ç¬”è€…èµ·åˆçš„åšæ³•æ˜¯åœ¨ Makefile ä¸­åŠ å…¥ä¸€äº›åŠŸèƒ½ï¼Œä½¿å¾—åœ¨ make å¯ä»¥å°†é¢„ç¼–è¯‘çš„ *.i æ–‡ä»¶åŒæ—¶è¾“å‡ºåˆ° /build ä¸­ï¼Œç„¶ååœ¨ /build ä¸­ä½¿ç”¨ grep \u0026quot;volatile static int dummy\u0026quot; -r | wc -l å‘½ä»¤ç»Ÿè®¡ä¸ªæ•°ï¼Œå¾—åˆ°çš„ç­”æ¡ˆæ˜¯ 33 ä¸ªã€‚\nä½†è¿™ä¸ªåšæ³•å…¶å®æœ‰ä¸€äº›é—®é¢˜ï¼Œå› ä¸ºé«˜çº§ç¨‹åºä¸­å®šä¹‰çš„â€œå˜é‡â€å¹¶ä¸ä¸€å®šæ˜¯å®ä½“ï¼Œæ¯”å¦‚è¿ç»­å®šä¹‰ä¸¤ä¸ªç›¸åŒåå­—çš„æœªåˆå§‹åŒ–å…¨å±€å˜é‡ï¼Œåœ¨ç¬¦å·è¡¨ä¸­åªä¼šå‡ºç°ä¸€ä¸ªã€‚å› æ­¤æ­£ç¡®çš„æ–¹æ³•åº”è¯¥æ˜¯æŸ¥çœ‹ç¬¦å·è¡¨ã€‚ä½¿ç”¨å‘½ä»¤ readelf --symbols $NEMU_HOME/build/riscv32-nemu-interpreter | grep \u0026quot;dummy\u0026quot; | wc -l å‘½ä»¤ï¼Œå¾—åˆ°çš„ç»“æœæ˜¯ 33 ä¸ªã€‚\næ­¤æ—¶ nemu ä¸­ä»ç„¶å«æœ‰ 33 ä¸ª dummy å˜é‡çš„å®ä½“ã€‚è¿™æ˜¯å› ä¸º common.h ä¸­ include äº† dubug.h ï¼Œä¸”è¿™æ˜¯å”¯ä¸€ä¸€ä¸ª include debug.h çš„åœ°æ–¹ï¼Œæœªåˆå§‹åŒ–çš„ç›¸åŒåå­—çš„å…¨å±€å˜é‡åœ¨ç¬¦å·è¡¨ä¸­åªæœ‰ä¸€ä¸ªå®ä½“ã€‚\nå¯¹å˜é‡è¿›è¡Œåˆå§‹åŒ–ä¹‹åå†ç¼–è¯‘ï¼Œä¼šæŠ¥é”™ï¼šredefinition of dummyã€‚è¿™æ˜¯å› ä¸ºèµ‹äº†åˆå€¼çš„å…¨å±€å˜é‡ä¼šè¢«è®¤ä¸ºæ˜¯ä¸€ä¸ªå¼ºç¬¦å·ã€‚C è¯­è¨€ä¸­ä¸å…è®¸æœ‰ä¸¤ä¸ªç›¸åŒçš„å¼ºç¬¦å·è¢«å®šä¹‰ã€‚è€Œæ²¡æœ‰èµ‹åˆå€¼çš„å˜é‡æ˜¯å¼±ç¬¦å·ï¼Œè¯­æ³•ä¸Šæ˜¯å¯ä»¥é‡å¤å®šä¹‰çš„ã€‚\näº†è§£ Makefile è¯·æè¿°ä½ åœ¨am-kernels/kernels/hello/ç›®å½•ä¸‹æ•²å…¥make ARCH=$ISA-nemu å, makeç¨‹åºå¦‚ä½•ç»„ç»‡.cå’Œ.hæ–‡ä»¶, æœ€ç»ˆç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶am-kernels/kernels/hello/build/hello-$ISA-nemu.elf. (è¿™ä¸ªé—®é¢˜åŒ…æ‹¬ä¸¤ä¸ªæ–¹é¢:Makefileçš„å·¥ä½œæ–¹å¼å’Œç¼–è¯‘é“¾æ¥çš„è¿‡ç¨‹.) å…³äºMakefileå·¥ä½œæ–¹å¼çš„æç¤º:\nMakefileä¸­ä½¿ç”¨äº†å˜é‡, åŒ…å«æ–‡ä»¶ç­‰ç‰¹æ€§ Makefileè¿ç”¨å¹¶é‡å†™äº†ä¸€äº›implicit rules åœ¨man makeä¸­æœç´¢-né€‰é¡¹, ä¹Ÿè®¸ä¼šå¯¹ä½ æœ‰å¸®åŠ© RTFM hello ä¸­çš„ Makefile å†…å®¹æ¯”è¾ƒç®€å•ï¼šå°† NAME å’Œ SRC è®¾ç½®å¥½ï¼Œç„¶åå°† AM ä¸­çš„ Makefile å…¨éƒ¨è´´è¿›æ¥ã€‚ï¼ˆè™½ç„¶ AM çš„ Makefile ç›¸å½“å¤æ‚ï¼‰\näº‹å®ä¸Š SRC æœ‰éå¸¸å¤šï¼šAM ä¸­å‡ ä¹æ¯ä¸ªæ–‡ä»¶å¤¹ä¸‹éƒ½æœ‰ Makefileï¼ŒæŠŠè¿™ä¸ªæ–‡ä»¶å¤¹ä¸‹çš„ .c æ–‡ä»¶æœåˆ®è¿› SRC ä¸­ã€‚\næŒ‰ç…§æ­£åºï¼ŒMakfile å¤§æ¦‚åšäº†å¦‚ä¸‹ä¸€äº›å¤§çš„äº‹æƒ…ï¼š\nåœ¨ Makefile ä¸­æœ‰\n$(DST_DIR)/%.o: %.c @mkdir -p $(dir $@) \u0026amp;\u0026amp; echo + CC $\u0026lt; @$(CC) -std=gnu11 $(CFLAGS) -c -o $@ $(realpath $\u0026lt;) å®ƒä¼šä¸­æ‰€æœ‰çš„.cæ–‡ä»¶ç¼–è¯‘æˆ.oæ–‡ä»¶æ”¾è¿›ç›®å½•DST_DIRä¸­ã€‚è¿™é‡ŒDST_DIRæ˜¯ AM ä¸‹çš„ build ç›®å½•ã€‚\nåœ¨ Makefile ä¸­æœ‰\n$(LIBS): %: @$(MAKE) -s -C $(AM_HOME)/$* archive å®ƒä¼šæŠŠæˆ‘ä»¬è‡ªå·±å†™çš„åº“å‡½æ•°ï¼ˆå¦‚ klibï¼‰æ‰“åŒ…æˆ archiveã€‚\nåœ¨ Makefile ä¸­æœ‰\n$(IMAGE).elf: $(OBJS) am $(LIBS) @echo + LD \u0026quot;-\u0026gt;\u0026quot; $(IMAGE_REL).elf @$(LD) $(LDFLAGS) -o $(IMAGE).elf --start-group $(LINKAGE) --end-group å®ƒä¼šå°†æ‰€æœ‰çš„ .o æ–‡ä»¶å…¨éƒ¨é“¾æ¥èµ·æ¥ç”Ÿæˆä¸€ä¸ª .elf æ–‡ä»¶ã€‚è¿™é‡Œçš„ $(OBJS) çš„ç”Ÿæˆæ–¹æ³•ä¸éš¾ï¼šå°† SRC ä¸­æ‰€æœ‰çš„ .c æ¢æˆäº† .oï¼ŒåŠ ä¸Šç›¸å¯¹åº”çš„è·¯å¾„å‰ç¼€å³å¯ã€‚\nåœ¨ nemu.mk ä¸­æœ‰\nimage: $(IMAGE).elf @$(OBJDUMP) -d $(IMAGE).elf \u0026gt; $(IMAGE).txt @echo + OBJCOPY \u0026quot;-\u0026gt;\u0026quot; $(IMAGE_REL).bin @$(OBJCOPY) -S --set-section-flags .bss=alloc,contents -O binary $(IMAGE).elf $(IMAGE).bin å®ƒä½¿ç”¨ OBJCOPY å‘½ä»¤å°† .elf æ–‡ä»¶ä¸­çš„ä¸€äº›èŠ‚åšäº†ä¿®æ”¹ï¼Œç„¶åç²˜è´´è¿›äº† .bin æ–‡ä»¶ä¸­ã€‚\nåœ¨ nemu.mk ä¸­æœ‰\nrun: image $(MAKE) -C $(NEMU_HOME) ISA=$(ISA) run ARGS=\u0026quot;$(NEMUFLAGS)\u0026quot; IMG=$(IMAGE).bin å®ƒç›¸å½“äºåœ¨ $NEMU_HOME ç›®å½•ä¸‹ä½¿ç”¨äº†å‘½ä»¤ make ISA=riscv32 run ARGS=... IMG=...ï¼Œè¿™æ ·å°±å®ç°äº†å°†é•œåƒåŠ è½½åˆ° nemu ä¸Šè¿è¡Œã€‚\nä»¥ä¸‹æ˜¯æˆ‘çš„è‡ªç”±æŠ¥å‘Šå†…å®¹ï¼Œæˆ‘åœ¨åšå®éªŒçš„è¿‡ç¨‹ä¸­è¯¦ç»†è®°å½•äº†è‡ªå·±é‡åˆ°çš„æ‰€æœ‰é—®é¢˜å’ŒæŸ¥é˜…çš„æ‰€æœ‰èµ„æ–™ã€‚è¿™äº›ç¬”è®°æŒ‰ç…§ç« èŠ‚æ’åˆ—ï¼Œæ¯ç« é€šå¸¸æœ‰ä¸¤ä¸ªéƒ¨åˆ†ï¼š\næ€è€ƒé¢˜ï¼šåŒ…å«ç¬”è€…é’ˆå¯¹æ€è€ƒé¢˜æŸ¥é˜…çš„èµ„æ–™å’Œæˆ‘å°è¯•ç»™å‡ºçš„ç­”æ¡ˆã€‚ è¡¥å……ï¼šè¿™é‡Œçš„å†…å®¹æ˜¯æ²¡æœ‰åœ¨è®²ä¹‰ä¸­æåŠçš„é—®é¢˜ï¼Œä»¥åŠè®²ä¹‰ä¸­å»ºè®®è‡ªå­¦çš„ä¸œè¥¿ã€‚ ä¸åœè®¡ç®—çš„æœºå™¨ å¿…ç­”é¢˜ ç†è§£YEMUå¦‚ä½•æ‰§è¡Œç¨‹åº YEMUå¯ä»¥çœ‹æˆæ˜¯ä¸€ä¸ªç®€åŒ–ç‰ˆçš„NEMU, å®ƒä»¬çš„åŸç†æ˜¯ç›¸é€šçš„, å› æ­¤ä½ éœ€è¦ç†è§£YEMUæ˜¯å¦‚ä½•æ‰§è¡Œç¨‹åºçš„. å…·ä½“åœ°, ä½ éœ€è¦\nç”»å‡ºåœ¨YEMUä¸Šæ‰§è¡Œçš„åŠ æ³•ç¨‹åºçš„çŠ¶æ€æœº é€šè¿‡RTFSCç†è§£YEMUå¦‚ä½•æ‰§è¡Œä¸€æ¡æŒ‡ä»¤ æ€è€ƒä¸€ä¸‹, ä»¥ä¸Šä¸¤è€…æœ‰ä»€ä¹ˆè”ç³»?\næˆ‘ä»¬å®šä¹‰ä¸€ä¸ªçŠ¶æ€ä¸º (PC, R[0], R[1], M[7], halt)ï¼Œåˆ™çŠ¶æ€æœºä¸ºï¼š\n(0, x, x, 0, 0) -\u0026gt; (0, 33, x, 0, 0) -\u0026gt; (1, 33, x, 0, 0) -\u0026gt; (1, 33, 33, 0, 0) -\u0026gt; (2, 33, 33, 0, 0) -\u0026gt; (2, 16, 33, 0, 0) -\u0026gt; (3, 16, 33, 0, 0) -\u0026gt; (3, 49, 33, 0, 0) -\u0026gt; (4, 49, 33, 0, 0) -\u0026gt; (4, 49, 33, 49, 0) -\u0026gt; (5, 49, 33, 49, 0) -\u0026gt; (5, 49, 33, 49, 1) YEMU æ‰§è¡ŒæŒ‡ä»¤çš„æµç¨‹ä¸ºï¼š\nå–æŒ‡ï¼šå°† $M[pc]$ å¤„çš„å†…å®¹æ‹¿å‡ºæ¥ è¯‘ç ï¼šæ ¹æ®æŒ‡ä»¤çš„å„ä¸ªå­—æ®µåˆ¤æ–­æŒ‡ä»¤åˆ°åº•æƒ³è®©è®¡ç®—æœºåšä»€ä¹ˆ æ‰§è¡Œï¼šä½äº switch ä»£ç æ®µä¸­ï¼ŒYEMU æ”¯æŒçš„æŒ‡ä»¤éå¸¸ç®€å•ï¼Œåªæœ‰å¯„å­˜å™¨èµ‹å€¼ï¼ŒåŠ æ³•ï¼Œload/store å››ç§ã€‚ æ›´æ–° PC ä¸¤è€…çš„è”ç³»åœ¨äºï¼šç¨‹åºçš„ä¸¤ä¸ªçŠ¶æ€ä¹‹é—´çš„å˜åŒ–å’ŒæŒ‡ä»¤çš„åŠŸèƒ½æ˜¯ä¸€ä¸€å¯¹åº”çš„ã€‚\nRTFSC(2) å¿…ç­”é¢˜ RTFSC ç†è§£æŒ‡ä»¤æ‰§è¡Œçš„è¿‡ç¨‹ è¿™ä¸€å°èŠ‚çš„ç»†èŠ‚éå¸¸å¤š, ä½ å¯èƒ½éœ€è¦å¤šæ¬¡é˜…è¯»è®²ä¹‰å’Œä»£ç æ‰èƒ½ç†è§£æ¯ä¸€å¤„ç»†èŠ‚. æ ¹æ®å¾€å±Šå­¦é•¿å­¦å§çš„åé¦ˆ, ä¸€ç§æœ‰æ•ˆçš„ç†è§£æ–¹æ³•æ˜¯é€šè¿‡åšç¬”è®°çš„æ–¹å¼æ¥æ•´ç†è¿™äº›ç»†èŠ‚. äº‹å®ä¸Š, é…åˆGDBé£Ÿç”¨æ•ˆæœæ›´ä½³.\nä¸ºäº†é¿å…ä½ é•¿æ—¶é—´å¯¹ä»£ç çš„ç†è§£æ²¡æœ‰ä»»ä½•è¿›å±•, æˆ‘ä»¬å°±å¢åŠ ä¸€é“å¿…ç­”é¢˜å§:\nè¯·æ•´ç†ä¸€æ¡æŒ‡ä»¤åœ¨NEMUä¸­çš„æ‰§è¡Œè¿‡ç¨‹.\né™¤äº†nemu/src/deviceå’Œnemu/src/isa/$ISA/systemä¹‹å¤–, NEMUçš„å…¶å®ƒä»£ç ä½ éƒ½å·²ç»æœ‰èƒ½åŠ›ç†è§£äº†. å› æ­¤ä¸è¦è§‰å¾—è®²ä¹‰ä¸­æ²¡æœ‰æåˆ°çš„æ–‡ä»¶å°±ä¸éœ€è¦çœ‹, å°è¯•å°½å¯èƒ½åœ°ç†è§£æ¯ä¸€å¤„ç»†èŠ‚å§! åœ¨ä½ é‡åˆ°bugçš„æ—¶å€™, è¿™äº›ç»†èŠ‚å°±ä¼šæˆä¸ºå¸®åŠ©ä½ è°ƒè¯•çš„çº¿ç´¢.\nfetch_decode_exec_updatepc() å‡½æ•°åˆ†æˆä¸‰ä¸ªéƒ¨åˆ†ï¼šfetch_decode() è´Ÿè´£å–æŒ‡è¯‘ç ï¼Œs-\u0026gt;EHelper(s) åˆ©ç”¨å‡½æ•°æŒ‡é’ˆè°ƒç”¨äº†è¯‘ç åæŒ‡ä»¤åº”è¯¥æ‰§è¡Œçš„å‡½æ•°ã€‚cpu-\u0026gt;pc=s-\u0026gt;dnpc å°† pc æŒ‡å‘ä¸‹ä¸€æ¡æŒ‡ä»¤ã€‚\nå–æŒ‡ fetch_decode() è°ƒç”¨äº† isa_fetch_decode()ã€‚isa_fetch_decode ä¼šè°ƒç”¨ instr_fetch() æŠŠæŒ‡ä»¤ä»å†…å­˜ä¸­å–å‡ºæ¥ã€‚instr_fetch(*pc, len) çš„æ›´æ·±å†…å®¹å’Œç‰©ç†å†…å­˜è¯»å†™æœ‰å…³ï¼Œæ­¤å¤„ä¸æ·±ç©¶ã€‚ç‰¹åˆ«çš„ä¸€ç‚¹æ˜¯å®ƒå–å‡ºæŒ‡ä»¤åä¼šæ ¹æ® len æ›´æ–° pc çš„å€¼ï¼ˆæŒ‡å‘ä¸‹ä¸€æ¡æŒ‡ä»¤ï¼‰ã€‚\nè¯‘ç  isa_fetch_decode() å°† instr_fetch() çš„è¿”å›ç»“æœå­˜å‚¨åˆ° s-\u0026gt;instr.val ä¸­ã€‚s æ˜¯ä¸€ä¸ª Decode ç»“æ„ä½“ç±»å‹ï¼Œå…¶ä¸­çš„ instr æ˜¯ ISADecodeInfo ç±»å‹ã€‚\nè¿™é‡Œæœ‰ä¸€ä¸ªæœ‰è¶£çš„ä»£ç ç»†èŠ‚æ˜¯ nemu ä¸ºäº†æŠ½è±¡åŒ–ä¸åŒ ISA çš„å·®å¼‚ï¼Œåœ¨é¡¶å±‚çš„ä»£ç ä¸­ä½¿ç”¨çš„æ˜¯ç›¸åŒçš„ç±»å‹åç§°ï¼Œè¿™äº›åç§°åœ¨åº•å±‚æ‰ä¼šåˆ†å‡ºåŒºåˆ«ï¼Œä¾‹å¦‚ ISADecodeInfo ç±»å‹çš„å®šä¹‰æ˜¯\ntypedef concat(__GUEST_ISA__, _ISADecodeInfo) ISADecodeInfo; concat å‡½æ•°çš„åŠŸèƒ½æ˜¯å°†ä¸¤ä¸ªå­—ç¬¦ä¸²æ‹¼æ¥èµ·æ¥ï¼Œä»è€Œå®ç°äº†æ ¹æ®é€‰æ‹©çš„ ISA çš„ä¸åŒå®šä¹‰ä¸åŒçš„ ISADecodeInfoï¼Œå°† ISA çš„å·®å¼‚å¯¹ä¸Šå±‚æŠ½è±¡äº†ã€‚\nåœ¨æœ¬å®éªŒä¸­ instr è‡ªç„¶æ˜¯ riscv32_ISADecodeInfo ç±»å‹ã€‚è¯¥ç±»å‹çš„å®šä¹‰å¯ä»¥åœ¨ isa-def.h ä¸­æŸ¥åˆ°ï¼Œè¿™æ˜¯ä¸€ä¸ª unionï¼Œç»™ instr.val èµ‹å€¼ä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è°ƒç”¨ union ä¸­çš„å„ä¸ªå˜é‡æ¥è½»æ¾è·å¾—æŒ‡ä»¤çš„å„ä¸ªéƒ¨åˆ†ã€‚\nnemu è°ƒç”¨äº† table_main å‡½æ•°æ¥è¿›è¡ŒæŒ‡ä»¤ç±»å‹çš„ç¡®è®¤ï¼Œæ‰€æœ‰çš„ table å‡½æ•°å¯ä»¥è¢«çœ‹åšä¸€ä¸ªå·¨å¤§çš„ switch-caseã€‚è¿™é‡Œé¢æœ‰ä¸¤ç§ç±»å‹çš„å®ï¼š\ndef_INSTR_IDTAB(\u0026quot;??????? ????? ????? ??? ????? xxxxx xx\u0026quot;, I/U/S/J/B/R , xxx); def_INSTR_TAB(\u0026quot;??????? ????? ????? ??? ????? xxxxx xx\u0026quot;, xxx) ç¬¬ä¸€ç§å’Œç¬¬äºŒç§çš„åŒºåˆ«åœ¨äºç¬¬ä¸€ç§è¿˜ä¼šæŒ‰ç…§ä¼ é€çš„æŒ‡ä»¤ç±»å‹å¯¹æŒ‡ä»¤çš„å¯„å­˜å™¨å’Œç«‹å³æ•°è¿›è¡Œè§£æã€‚è¿™ç§å®ä¼šè¿”å›ä¸€ä¸ªæ‰§è¡Œå‡½æ•°çš„ç¼–å·ã€‚ç±»å‹ç¡®è®¤çš„è¿‡ç¨‹æ— éæ˜¯ä¸€äº›ä½è¿ç®—ï¼Œè¿™é‡Œä¸»è¦å†çœ‹å¯„å­˜å™¨å’Œç«‹å³æ•°çš„è§£æï¼š\nä¸ºäº†è¿›ä¸€æ­¥å®ç°æŒ‡ä»¤è¯‘ç å’Œæ“ä½œæ•°è¯‘ç çš„è§£è€¦ï¼Œnemu è¿˜å®šä¹‰äº†è¯‘ç æ“ä½œæ•°è¾…åŠ©å‡½æ•°ï¼Œä¸“é—¨ç”¨äºå¯¹ç«‹å³æ•°æˆ–å¯„å­˜å™¨è¿›è¡Œè¯‘ç ã€‚s ä¸­æœ‰ä¸‰ä¸ª Operand ç±»å‹çš„å˜é‡ã€‚Operand ç±»å‹çš„å˜é‡ä¸­æœ‰ä¸€ä¸ª unionï¼Œåˆ†åˆ«æ˜¯æŒ‡å‘å¯„å­˜å™¨çš„æŒ‡é’ˆï¼Œå¸¦ç¬¦å·ç«‹å³æ•°å’Œæ— ç¬¦å·ç«‹å³æ•°ï¼Œä»£è¡¨äº†å¯„å­˜å™¨ç±»å‹/æœ‰ç¬¦å·ç«‹å³æ•°/æ— ç¬¦å·ç«‹å³æ•°ã€‚é’ˆå¯¹ç«‹å³æ•°çš„è¯‘ç æ“ä½œæ•°è¾…åŠ©å‡½æ•°å¾ˆç®€å•ï¼Œåªè¦å°†å€¼èµ‹ç»™ imm å³å¯ã€‚é’ˆå¯¹å¯„å­˜å™¨çš„åˆ™ç•¥å¾®å¤æ‚ä¸€äº›ï¼šä¸ºäº†å®ç° riscv ä¸­é›¶å·å¯„å­˜å™¨æ°¸è¿œä¸º0ã€ä¸å¯å†™çš„ç‰¹æ€§ï¼Œè¯‘ç æ“ä½œæ•°è¾…åŠ©å‡½æ•°ä¼šå¯¹æ“ä½œçš„è¯»/å†™ï¼Œå’Œç›®æ ‡è¿›è¡Œåˆ¤æ–­ï¼Œä»¥ç¡®ä¿ä¸ä¼šä¿®æ”¹é›¶å·å¯„å­˜å™¨çš„å†…å®¹ (is_write å‚æ•°åªåœ¨å¯„å­˜å™¨ä¸­æ‰ä¼šæœ‰ä½œç”¨ï¼‰ã€‚\næ‰€æœ‰çš„è¯‘ç è¾…åŠ©å‡½æ•°éƒ½æ˜¯å¯ä»¥é€šè¿‡è°ƒç”¨è¯‘ç æ“ä½œæ•°è¾…åŠ©å‡½æ•°æ¥é«˜æ•ˆå®Œæˆã€‚è¿™éƒ¨åˆ†å’Œæ‰‹å†Œå¯ä»¥å½¢æˆé«˜åº¦çš„å¯¹åº”ã€‚\næ‰§è¡Œ åœ¨ cpu-exec ä¸­æ‰§è¡Œçš„ä»£ç å¾ˆç®€å•ï¼šå°±æ˜¯è°ƒç”¨ s ä¸­å­˜å¥½çš„æ‰§è¡Œå‡½æ•°ã€‚å½¢å¦‚ exec_xxx çš„æ‰§è¡Œå‡½æ•°éƒ½æ˜¯é€šè¿‡æ›´åŠ åŸºæœ¬çš„ rtl æŒ‡ä»¤æ¥å®ç°åŠŸèƒ½ã€‚rtl æŒ‡ä»¤å¤§å¤šæ˜¯è°ƒç”¨äº†åŸºäº c è¯­è¨€çš„è¡¨è¾¾å¼è¿ç®—æ¥å®ç°åŠŸèƒ½ï¼Œå°‘æ•°çš„è·³è½¬æŒ‡ä»¤ç¨å¾®å¤æ‚ä¸€äº›ã€‚\næ›´æ–° pc å°† s-\u0026gt;dnpc èµ‹ç»™ sï¼Œè¿™é‡Œè¦æ³¨æ„ dnpc å’Œ snpc çš„åŒºåˆ«ï¼šsnpc ä»…ä»…æŒ‡å†…å­˜ä¸­è¯¥æ¡æŒ‡ä»¤çš„ä¸‹ä¸€æ¡æŒ‡ä»¤ï¼ˆpc+4ï¼‰ä½ç½®ï¼Œè€Œ dnpc ä¿å­˜äº†ä¸‹ä¸€æ¡çœŸæ­£è¦æ‰§è¡Œçš„æŒ‡ä»¤çš„ä½ç½®ã€‚åœ¨ä¸€äº›è·³è½¬æŒ‡ä»¤ä¸­ snpc å’Œ dnpc ä¸ä¸€å®šç›¸åŒã€‚\næ€è€ƒé¢˜ ç«‹å³æ•°èƒŒåçš„æ•…äº‹ æ¡†æ¶ä»£ç é€šè¿‡instr_fetch()å‡½æ•°è¿›è¡Œå–æŒ‡, åˆ«çœ‹è¿™é‡Œå°±è¿™ä¹ˆä¸€è¡Œä»£ç , å…¶å®èƒŒåéšè—ç€é’ˆå¯¹å­—èŠ‚åºçš„æ…é‡è€ƒè™‘. å¤§éƒ¨åˆ†åŒå­¦çš„ä¸»æœºéƒ½æ˜¯x86å°ç«¯æœº, å½“ä½ ä½¿ç”¨é«˜çº§è¯­è¨€æˆ–è€…æ±‡ç¼–è¯­è¨€å†™äº†ä¸€ä¸ª32ä½å¸¸æ•°0x1234çš„æ—¶å€™, åœ¨ç”Ÿæˆçš„äºŒè¿›åˆ¶ä»£ç ä¸­, è¿™ä¸ªå¸¸æ•°å¯¹åº”çš„å­—èŠ‚åºåˆ—å¦‚ä¸‹(å‡è®¾è¿™ä¸ªå¸¸æ•°åœ¨å†…å­˜ä¸­çš„èµ·å§‹åœ°å€æ˜¯x):\nx x+1 x+2 x+3 +----+----+----+----+ | 34 | 12 | 00 | 00 | +----+----+----+----+ è€Œå¤§å¤šæ•°PCæœºéƒ½æ˜¯å°ç«¯æ¶æ„(æˆ‘ä»¬ç›¸ä¿¡æ²¡æœ‰åŒå­¦ä¼šä½¿ç”¨IBMå¤§å‹æœºæ¥åšPA), å½“NEMUè¿è¡Œçš„æ—¶å€™,\nimm = instr_fetch(pc, 4); è¿™è¡Œä»£ç ä¼šå°†34 12 00 00è¿™ä¸ªå­—èŠ‚åºåˆ—åŸå°ä¸åŠ¨åœ°ä»å†…å­˜è¯»å…¥immå˜é‡ä¸­, ä¸»æœºçš„CPUä¼šæŒ‰ç…§å°ç«¯æ–¹å¼æ¥è§£é‡Šè¿™ä¸€å­—èŠ‚åºåˆ—, äºæ˜¯ä¼šå¾—åˆ°0x1234, ç¬¦åˆæˆ‘ä»¬çš„é¢„æœŸç»“æœ.\nMotorola 68kç³»åˆ—çš„å¤„ç†å™¨éƒ½æ˜¯å¤§ç«¯æ¶æ„çš„. ç°åœ¨é—®é¢˜æ¥äº†, è€ƒè™‘ä»¥ä¸‹ä¸¤ç§æƒ…å†µ:\nå‡è®¾æˆ‘ä»¬éœ€è¦å°†NEMUè¿è¡Œåœ¨Motorola 68kçš„æœºå™¨ä¸Š(æŠŠNEMUçš„æºä»£ç ç¼–è¯‘æˆMotorola 68kçš„æœºå™¨ç ) å‡è®¾æˆ‘ä»¬éœ€è¦æŠŠMotorola 68kä½œä¸ºä¸€ä¸ªæ–°çš„ISAåŠ å…¥åˆ°NEMUä¸­ åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹, ä½ éœ€è¦æ³¨æ„äº›ä»€ä¹ˆé—®é¢˜? ä¸ºä»€ä¹ˆä¼šäº§ç”Ÿè¿™äº›é—®é¢˜? æ€ä¹ˆè§£å†³å®ƒä»¬?\näº‹å®ä¸Šä¸ä»…ä»…æ˜¯ç«‹å³æ•°çš„è®¿é—®, é•¿åº¦å¤§äº1å­—èŠ‚çš„å†…å­˜è®¿é—®éƒ½éœ€è¦è€ƒè™‘ç±»ä¼¼çš„é—®é¢˜. æˆ‘ä»¬åœ¨è¿™é‡ŒæŠŠé—®é¢˜ç»Ÿä¸€æŠ›å‡ºæ¥, ä»¥åå°±ä¸å†å•ç‹¬è®¨è®ºäº†.\nå¦‚æœæˆ‘ä»¬è¦å°† NEMU è¿è¡Œåœ¨ Motorola 68k æœºå™¨ä¸Šï¼Œé‚£ä¹ˆæˆ‘ä»¬è®¿é—®å†…å­˜çš„æŒ‡ä»¤å°±ä¸èƒ½åƒç°åœ¨è¿™æ ·å°†è¿ç»­4ä¸ªå­—èŠ‚ç›´æ¥è¯»å…¥å˜é‡ï¼Œå› ä¸º Motorola 68k ä¼šæŒ‰ç…§å¤§ç«¯æ–¹å¼æ¥è¯»å–è¿™4ä¸ªå­—èŠ‚ã€‚æˆ‘ä»¬éœ€è¦è‡ªå·±æ‰‹å†™ä¸€ä¸ªå¾ªç¯æ¥æŒ‰ç…§å°ç«¯æ–¹å¼å¤„ç†æ•°æ®ã€‚\nå¦‚æœæˆ‘ä»¬è¦åœ¨ NEMU ä¸­åŠ å…¥ Motorola 68k çš„ ISAï¼Œé‚£ä¹ˆç›¸ä¼¼åœ°ï¼Œæˆ‘ä»¬ä¸èƒ½å°†è¿ç»­4ä¸ªå­—èŠ‚ç›´æ¥è¯»å…¥å˜é‡ï¼Œè€Œæ˜¯è¦æ‰‹å†™ä¸€ä¸ªå¾ªç¯æŒ‰ç…§å¤§ç«¯æ–¹å¼å¤„ç†æ•°æ®ã€‚\nç«‹å³æ•°èƒŒåçš„æ•…äº‹(2) mips32å’Œriscv32çš„æŒ‡ä»¤é•¿åº¦åªæœ‰32ä½, å› æ­¤å®ƒä»¬ä¸èƒ½åƒx86é‚£æ ·, æŠŠCä»£ç ä¸­çš„32ä½å¸¸æ•°ç›´æ¥ç¼–ç åˆ°ä¸€æ¡æŒ‡ä»¤ä¸­. æ€è€ƒä¸€ä¸‹, mips32å’Œriscv32åº”è¯¥å¦‚ä½•è§£å†³è¿™ä¸ªé—®é¢˜?\nå¯ä»¥è®¾ç½®ä¸¤ç§åŠ è½½ç«‹å³æ•°çš„æŒ‡ä»¤ï¼šä¸€ç§å‘é«˜ä½åŠ è½½ï¼Œä¸€ç§å‘ä½ä½åŠ è½½ã€‚riscv32 ä¸­çš„ lui æŒ‡ä»¤å¯ä»¥å®ç°å‘é«˜ä½åŠ è½½ç«‹å³æ•°çš„åŠŸèƒ½ã€‚mipsæŒ‡ä»¤é›†ç”±äºæ²¡æœ‰æ¥è§¦è¿‡ï¼Œæš‚æ—¶ç•™å‘ã€‚\nä¸ºä»€ä¹ˆä¸éœ€è¦ rtl_muls_lo æˆ‘ä»¬æ²¡æœ‰å®šä¹‰ç”¨äºè·å–æœ‰ç¬¦å·æ•°ä¹˜æ³•ç»“æœä½32ä½çš„RTLåŸºæœ¬æŒ‡ä»¤rtl_muls_lo, ä½ çŸ¥é“ä¸ºä»€ä¹ˆå—?\nrtl_muls_lo æ‰€éœ€å®ç°çš„åŠŸèƒ½ä¸ rtl_mulu_lo å®Œå…¨ç›¸åŒï¼Œæœ¬ç€ä¸è¦è®©å¤šä¸ªå‡½æ•°åšåŒä¸€ä»¶äº‹æƒ…çš„åŸåˆ™ï¼Œæˆ‘ä»¬ä¸éœ€è¦ rtl_muls_loã€‚ä½†æœ‰ç¬¦å·å’Œæ— ç¬¦å·åœ¨é«˜ä½çš„è¡¨ç°æ˜¯ä¸åŒçš„ï¼Œå› æ­¤ä¸¤ç§ hi æˆ‘ä»¬éƒ½éœ€è¦ã€‚\nRTLå¯„å­˜å™¨ä¸­å€¼çš„ç”Ÿå­˜æœŸ åœ¨ç¨‹åºè®¾è®¡è¯¾ä¸Š, æˆ‘ä»¬çŸ¥é“Cè¯­è¨€ä¸­ä¸åŒçš„å˜é‡æœ‰ä¸åŒçš„ç”Ÿå­˜æœŸ: æœ‰çš„å˜é‡çš„å€¼ä¼šä¸€ç›´æŒç»­åˆ°ç¨‹åºç»“æŸ, ä½†æœ‰çš„å˜é‡å´å¾ˆå¿«æ¶ˆäº¡. åœ¨ä¸Šè¿°å®šä¹‰çš„RTLå¯„å­˜å™¨ä¸­, å…¶å®ä¹Ÿæœ‰ä¸åŒçš„ç”Ÿå­˜æœŸ. å°è¯•æ ¹æ®ç”Ÿå­˜æœŸç»™RTLå¯„å­˜å™¨åˆ†ç±».\nå°½ç®¡ç›®å‰è¿™ä¸ªåˆ†ç±»ç»“æœå¹¶æ²¡æœ‰ä»€ä¹ˆç”¨å¤„, ä½†å…¶å®å°†æ¥åœ¨PA5ä¸­è®¾è®¡RTLä¼˜åŒ–æ–¹æ¡ˆçš„æ—¶å€™, ç”Ÿå­˜æœŸçš„æ€§è´¨ä¼šç»™æˆ‘ä»¬æä¾›å¾ˆå¤§çš„ä¼˜åŒ–æœºä¼š.\nç•™å‘ï¼ŒäºŒå‘¨ç›®å†åšã€‚\nä¸ºä»€ä¹ˆæ‰§è¡Œäº†æœªå®ç°æŒ‡ä»¤ä¼šå‡ºç°ä¸Šè¿°æŠ¥é”™ä¿¡æ¯ RTFSC, ç†è§£æ‰§è¡Œæœªå®ç°æŒ‡ä»¤çš„æ—¶å€™, NEMUå…·ä½“ä¼šæ€ä¹ˆåš.\nåœ¨æ‰§è¡Œäº†æœªå®ç°çš„æŒ‡ä»¤æ—¶ï¼Œè¯‘ç çš„è¿‡ç¨‹ä¸­æ— æ³•åŒ¹é…åˆ°ä»»ä½•ä¸€ç§ patternï¼Œæœ€ç»ˆä¼šè¿”å›ä¸€ä¸ª EXEC_ID_inv å®ï¼Œå³ä¸åˆæ³•æŒ‡ä»¤å¯¹åº”çš„æ‰§è¡Œå‡½æ•°çš„ç¼–å·ã€‚è¿™é‡Œçš„å®åˆ©ç”¨å…ƒç¼–ç¨‹å’Œ enum çš„æ–¹æ³•å†™å‡ºäº†ä¸€ç§é²æ£’æ€§å¾ˆå¼ºçš„ä»£ç ï¼Œå³ä½¿ä¸æ–­æ·»åŠ æ–°æŒ‡ä»¤ä¹Ÿå¯ä»¥ä½¿å¾— EXEC_ID_inv ä»£è¡¨çš„ç¼–å·æ˜¯æ­£ç¡®çš„ã€‚\næ‹¿åˆ° EXEC_ID_inv åï¼Œæ‰§è¡Œå‡½æ•°èµ‹ä¸º g[idx]ã€‚åœ¨æ‰§è¡Œ g[idx] æ—¶ï¼Œæ‰§è¡Œçš„æ˜¯ exec_invï¼Œexec_inv() å‡½æ•°è°ƒç”¨äº† rtl_hostcall å‡½æ•°ï¼Œå¹¶ä¼ å…¥äº† HOSTCALL_INV å‚æ•°ï¼ˆä¸æ­£å¸¸é€€å‡ºçš„ HOSTCALL_EXIT åŒºåˆ†ï¼‰ã€‚rtl_hostcall å‡½æ•°æ¥æ”¶åˆ° HOSTCALL_INV å‚æ•°æ—¶ï¼Œä¾¿ä¼šæ‰“å°ä¸Šè¿°çš„æŠ¥é”™ä¿¡æ¯ã€‚\nç¨‹åºï¼Œè¿è¡Œæ—¶ç¯å¢ƒä¸AM æ€è€ƒé¢˜ è¿™åˆèƒ½æ€ä¹ˆæ ·å‘¢ æ€è€ƒä¸€ä¸‹, è¿™æ ·çš„æŠ½è±¡è¿˜ä¼šå¸¦æ¥å“ªäº›å¥½å¤„å‘¢? ä½ å¾ˆå¿«å°±ä¼šä½“ä¼šåˆ°è¿™äº›å¥½å¤„äº†.\nè¿™æ ·çš„æŠ½è±¡æœ‰åˆ©äºä»£ç çš„ç§»æ¤ï¼šä½ ç”šè‡³å¯ä»¥æŠŠåˆ«äººçš„ä¸Šå±‚ä»£ç æ‹¿æ¥ç›´æ¥ç”¨ï¼Œå³ä½¿ä½ ä»¬ä½¿ç”¨ä¸åŒçš„è¯­è¨€åšäº† nemuï¼Œåªè¦ API æ¥å£ç»Ÿä¸€ï¼Œä¸Šå±‚çš„æ“ä½œç³»ç»Ÿå’Œç”¨æˆ·ç¨‹åºå°±å¯ä»¥è°ƒç”¨ API ç›´æ¥è¿è¡Œã€‚\n[äºŒå‘¨ç›®]ä¸ºä»€ä¹ˆè¦æœ‰AMï¼Ÿ æ“ä½œç³»ç»Ÿä¹Ÿæœ‰è‡ªå·±çš„è¿è¡Œæ—¶ç¯å¢ƒ. AMå’Œæ“ä½œç³»ç»Ÿæä¾›çš„è¿è¡Œæ—¶ç¯å¢ƒæœ‰ä»€ä¹ˆä¸åŒå‘¢? ä¸ºä»€ä¹ˆä¼šæœ‰è¿™äº›ä¸åŒ?\nç•™å‘ã€‚ç¬”è€…æš‚æ—¶è®¤ä¸º AM ä¸­çš„è¿è¡Œæ—¶ç¯å¢ƒæ›´å¤šæ˜¯å¯¹ç¡¬ä»¶åŠŸèƒ½çš„ç›´æ¥æŠ½è±¡ï¼šæ¯”å¦‚å¯ä»¥è®¿é—®å¤–è®¾ï¼Œå¯ä»¥è¯»å†™å†…å­˜ç­‰ã€‚è€Œæ“ä½œç³»ç»Ÿä¸­çš„è¿è¡Œæ—¶ç¯å¢ƒæŠ½è±¡å±‚æ¬¡æ›´é«˜ï¼Œæ¯”å¦‚ç³»ç»Ÿè°ƒç”¨ç­‰ç­‰ï¼Œæ˜¯å¯¹ AM è¿è¡Œæ—¶ç¯å¢ƒçš„è¿›ä¸€æ­¥å°è£…ã€‚ä¹‹æ‰€ä»¥ä¸åŒæ˜¯å› ä¸ºä»–ä»¬æ‰€å¤„çš„æŠ½è±¡å±‚ä¸åŒï¼ŒæœåŠ¡çš„å¯¹è±¡ä¹Ÿä¸åŒã€‚æ“ä½œç³»ç»Ÿå‘åº”ç”¨ç¨‹åºæš´éœ² APIï¼Œè‡ªç„¶ä¸éœ€è¦è®©åº”ç”¨ç¨‹åºçŸ¥é“ç¡¬ä»¶ç»†èŠ‚ã€‚AM çš„è¿è¡Œæ—¶ç¯å¢ƒå¯ä»¥è®©æ“ä½œç³»ç»Ÿæ›´å¥½åœ°åˆ©ç”¨å·²æœ‰çš„ç¡¬ä»¶åŠŸèƒ½ï¼Œå¯ä»¥åšåˆ°æ¶æ„å’ŒOSçš„è§£è€¦ã€‚\nmips32çš„åˆ†æ”¯å»¶è¿Ÿæ§½ ä¸ºäº†æå‡å¤„ç†å™¨çš„æ€§èƒ½, mipsä½¿ç”¨äº†ä¸€ç§å«åˆ†æ”¯å»¶è¿Ÿæ§½çš„æŠ€æœ¯. é‡‡ç”¨è¿™ç§æŠ€æœ¯ä¹‹å, ç¨‹åºçš„æ‰§è¡Œé¡ºåºä¼šå‘ç”Ÿä¸€äº›æ”¹å˜: æˆ‘ä»¬æŠŠç´§è·Ÿåœ¨è·³è½¬æŒ‡ä»¤(åŒ…æ‹¬æœ‰æ¡ä»¶å’Œæ— æ¡ä»¶)ä¹‹åçš„é™æ€æŒ‡ä»¤ç§°ä¸ºå»¶è¿Ÿæ§½, é‚£ä¹ˆç¨‹åºåœ¨æ‰§è¡Œå®Œè·³è½¬æŒ‡ä»¤å, ä¼šå…ˆæ‰§è¡Œå»¶è¿Ÿæ§½ä¸­çš„æŒ‡ä»¤, å†æ‰§è¡Œä½äºè·³è½¬ç›®æ ‡çš„æŒ‡ä»¤. ä¾‹å¦‚\n100: beq 200 101: add 102: xor ... 200: sub 201: j 102 202: slt è‹¥beqæŒ‡ä»¤çš„æ‰§è¡Œç»“æœä¸ºè·³è½¬, åˆ™ç›¸åº”çš„åŠ¨æ€æŒ‡ä»¤æµä¸º100 -\u0026gt; 101 -\u0026gt; 200; è‹¥beqæŒ‡ä»¤çš„æ‰§è¡Œç»“æœä¸ºä¸è·³è½¬, åˆ™ç›¸åº”çš„åŠ¨æ€æŒ‡ä»¤æµä¸º100 -\u0026gt; 101 -\u0026gt; 102; è€Œå¯¹äºjæŒ‡ä»¤, ç›¸åº”çš„åŠ¨æ€æŒ‡ä»¤æµä¸º201 -\u0026gt; 202 -\u0026gt; 102.\nä½ ä¸€å®šä¼šå¯¹è¿™ç§åç›´è§‰çš„æŠ€æœ¯å¦‚ä½•æå‡å¤„ç†å™¨æ€§èƒ½è€Œæ„Ÿåˆ°ç–‘æƒ‘. ä¸è¿‡è¿™éœ€è¦ä½ å…ˆäº†è§£ä¸€äº›å¾®ç»“æ„çš„çŸ¥è¯†, ä¾‹å¦‚å¤„ç†å™¨æµæ°´çº¿, ä½†è¿™å·²ç»è¶…å‡ºäº†ICSçš„è¯¾ç¨‹èŒƒå›´äº†, æ‰€ä»¥æˆ‘ä»¬ä¹Ÿä¸è¯¦ç»†è§£é‡Šäº†, æ„Ÿå…´è¶£çš„è¯å¯ä»¥STFW.\nä½†æˆ‘ä»¬å¯ä»¥çŸ¥é“, å»¶è¿Ÿæ§½æŠ€æœ¯éœ€è¦è½¯ç¡¬ä»¶ååŒæ‰èƒ½æ­£ç¡®å·¥ä½œ: mipsæ‰‹å†Œä¸­æè¿°äº†è¿™ä¸€çº¦å®š, å¤„ç†å™¨è®¾è®¡è€…æŒ‰ç…§è¿™ä¸€çº¦å®šè®¾è®¡å¤„ç†å™¨, è€Œç¼–è¯‘å™¨å¼€å‘è€…åˆ™ä¼šè®©ç¼–è¯‘å™¨è´Ÿè´£åœ¨å»¶è¿Ÿæ§½ä¸­æ”¾ç½®ä¸€æ¡æœ‰æ„ä¹‰çš„æŒ‡ä»¤, ä½¿å¾—æ— è®ºæ˜¯å¦è·³è½¬, æŒ‰ç…§è¿™ä¸€çº¦å®šçš„æ‰§è¡Œé¡ºåºéƒ½èƒ½å¾—åˆ°æ­£ç¡®çš„æ‰§è¡Œç»“æœ.\nå¦‚æœä½ æ˜¯ç¼–è¯‘å™¨å¼€å‘è€…, ä½ å°†ä¼šå¦‚ä½•å¯»æ‰¾åˆé€‚çš„æŒ‡ä»¤æ”¾åˆ°å»¶è¿Ÿæ§½ä¸­å‘¢?\næµæ°´çº¿CPUä¸­å¦‚æœåˆ†æ”¯é¢„æµ‹å¤±è´¥ï¼Œå¸¸è§çš„åšæ³•æ˜¯å¯¹å„ä¸ªæµæ°´æ®µè¿›è¡Œå†²åˆ·ï¼Œç„¶åå°†åº”è¯¥è·³è½¬åˆ°çš„PCé€å…¥æµæ°´çº¿ç»§ç»­æ‰§è¡Œã€‚flush æ˜¯ä¸€ä¸ªä»£ä»·å¾ˆå¤§çš„æ“ä½œï¼Œä¼šä½¿æµæ°´çº¿æµªè´¹å¾ˆå¤šä¸ªæ—¶é’Ÿå‘¨æœŸï¼Œå› æ­¤æˆ‘ä»¬æœ‰ä¸¤ä¸ªæ–¹å‘å¯ä»¥åŠªåŠ›ï¼šä¸€ä¸ªæ˜¯å°½å¯èƒ½å‡å°‘ flush çš„æ¬¡æ•°ï¼Œä¹Ÿå°±æ˜¯æé«˜åˆ†æ”¯é¢„æµ‹çš„æˆåŠŸç‡ï¼ˆåŠ¨æ€åˆ†æ”¯é¢„æµ‹ etc.ï¼‰ï¼Œå¦ä¸€ä¸ªæ˜¯ä½¿æµæ°´çº¿ä¸­æ‰§è¡Œçš„æŒ‡ä»¤å³ä½¿åœ¨åˆ†æ”¯é¢„æµ‹é”™è¯¯çš„æ—¶å€™ä¹Ÿå¯ä»¥ä¿ç•™ï¼Œè¿™å°±æ˜¯mipsä¸­çš„å»¶è¿Ÿæ§½ã€‚\nè‡³äºåˆ†æ”¯å»¶è¿Ÿæ§½ä¸­åº”è¯¥æ”¾ä»€ä¹ˆæŒ‡ä»¤ï¼Œæœ€ç®€å•çš„è‡ªç„¶æ˜¯æ’å…¥nopæŒ‡ä»¤ã€‚è¿™æ ·æ­£ç¡®æ€§æ— ç–‘å¯ä»¥å¾—åˆ°ä¿è¯ï¼Œä½†æ€§èƒ½ä¸é«˜ï¼šä¸è®ºåˆ†æ”¯é¢„æµ‹æ˜¯å¦æˆåŠŸï¼Œæ‰§è¡Œè¿™æ¡nopæŒ‡ä»¤éƒ½ç›¸å½“äºæ²¡åšäº‹æƒ…ï¼Œå¯ä»¥ç†è§£ä¸ºæµæ°´çº¿è¢«é˜»å¡äº†ã€‚\nä»¥ä¸‹æ˜¯ç¬”è€…çš„ä¸€äº›çŒœæƒ³ï¼šå¦‚æœè·³è½¬å’Œä¸è·³è½¬çš„æ¥ä¸‹æ¥çš„å‡ æ¡æŒ‡ä»¤ä¸­æœ‰å®Œå…¨ç›¸åŒçš„æŒ‡ä»¤ï¼Œè‡ªç„¶å¯ä»¥å°†è¿™æ¡æŒ‡ä»¤æ”¾åˆ°å»¶è¿Ÿæ§½ä¸­ã€‚è¿™æ ·ä¸è®ºèµ°äº†å“ªä¸ªåˆ†æ”¯è¿™æ¡æŒ‡ä»¤çš„æ‰§è¡Œéƒ½æ˜¯æœ‰ç”¨çš„ã€‚å½“ç„¶ï¼Œèƒ½å¦è°ƒæ•´æŒ‡ä»¤çš„é¡ºåºå–å†³äºæŒ‡ä»¤ä¹‹é—´çš„ä¾èµ–å…³ç³»ã€‚ä¸è¿‡å®Œå…¨ç›¸åŒçš„æŒ‡ä»¤å¾ˆéš¾æ‰¾ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨å¯„å­˜å™¨çš„é‡å‘½åæŠ€æœ¯ï¼Œç°å°†æŸæ¡æŒ‡ä»¤çš„ç»“æœæ”¾åˆ°ä¸€ä¸ªå¤‡ç”¨çš„å†…å­˜ç©ºé—´ä¸­ï¼Œå¦‚æœå°†æ¥èµ°è¿™æ¡åˆ†æ”¯ï¼Œå°±å°†å¯¹åº”çš„å¯„å­˜å™¨åæ˜ å°„åˆ°è¿™ä¸ªåœ°å€ä¸Šã€‚\næŒ‡ä»¤åå¯¹ç…§ AT\u0026amp;Tæ ¼å¼åæ±‡ç¼–ç»“æœä¸­çš„å°‘é‡æŒ‡ä»¤, ä¸æ‰‹å†Œä¸­åˆ—å‡ºçš„æŒ‡ä»¤åç§°ä¸ç¬¦, å¦‚x86çš„cltd, mips32å’Œriscv32åˆ™æœ‰ä¸å°‘ä¼ªæŒ‡ä»¤(pseudo instruction). é™¤äº†STFWä¹‹å¤–, ä½ æœ‰åŠæ³•åœ¨æ‰‹å†Œä¸­æ‰¾åˆ°å¯¹åº”çš„æŒ‡ä»¤å—? å¦‚æœæœ‰çš„è¯, ä¸ºä»€ä¹ˆè¿™ä¸ªåŠæ³•æ˜¯æœ‰æ•ˆçš„å‘¢?\nç¬”è€…ä½¿ç”¨çš„ä¸€ä¸ªæ–¹æ³•æ˜¯ï¼šç›´æ¥å°†è¿™æ¡ä¼ªæŒ‡ä»¤å¯¹åº”çš„æœºå™¨ä»£ç äºŒè¿›åˆ¶ä¸²æ”¾è¿›æ‰‹å†Œé‡Œæœç´¢ã€‚å› ä¸ºä¼ªæŒ‡ä»¤å®é™…ä¸Šä¹Ÿæ˜¯é€šè¿‡æ™®é€šæŒ‡ä»¤å®ŒæˆåŠŸèƒ½çš„ï¼Œæ‰€ä»¥å¯ä»¥æœç´¢åˆ°å¯¹åº”çš„æ™®é€šæŒ‡ä»¤ï¼Œä»è€Œç¡®å®šä¼ªæŒ‡ä»¤çš„è¡Œä¸ºã€‚\nstdargæ˜¯å¦‚ä½•å®ç°çš„? stdarg.hä¸­åŒ…å«ä¸€äº›è·å–å‡½æ•°è°ƒç”¨å‚æ•°çš„å®, å®ƒä»¬å¯ä»¥çœ‹åšæ˜¯è°ƒç”¨çº¦å®šä¸­å…³äºå‚æ•°ä¼ é€’æ–¹å¼çš„æŠ½è±¡. ä¸åŒISAçš„ABIè§„èŒƒä¼šå®šä¹‰ä¸åŒçš„å‡½æ•°å‚æ•°ä¼ é€’æ–¹å¼, å¦‚æœè®©ä½ æ¥å®ç°è¿™äº›å®, ä½ ä¼šå¦‚ä½•å®ç°?\nç¬”è€…å¹¶æ²¡æœ‰å»çœ‹ stdarg.h çš„æºç ï¼Œä½†ç¬”è€…ç”¨è¿‡å® __VA_ARGS__ï¼Œè®¤ä¸ºå®ƒèƒŒåçš„å®ç°æ–¹å¼åº”è¯¥æ˜¯ä¸€ä¸ªé“¾è¡¨ï¼Œé“¾è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ åŒ…å«äº†å‚æ•°çš„åç§°å’Œå‚æ•°æŒ‡å‘çš„åœ°å€ã€‚\nè¡¥å…… å…³äº riscv çš„ jalr æŒ‡ä»¤ ç¬”è€…åœ¨å®ç° jalr æŒ‡ä»¤çš„æ—¶å€™çŠ¯äº†ä¸€äº›é”™è¯¯ï¼Œè¿™ä¸ªé”™è¯¯ç›´åˆ° PA3 æ‰æš´éœ²å‡ºæ¥ï¼Œåœ¨æ­¤ç‰¹åœ°è®°å½•ã€‚jalr æŒ‡ä»¤çš„è¡Œä¸ºåœ¨æ‰‹å†Œä¸­çš„å®šä¹‰å¦‚ä¸‹ï¼š\nt=pc+4; pc=(x[rs1]+sext(offset))\u0026amp;~1; x[rd]=t ç¬”è€…èµ·åˆè®¤ä¸ºè¿™æ ·çš„å†™æ³•éå¸¸éº»çƒ¦ï¼šä¸ºä»€ä¹ˆä¸æŠŠ pc+4 çš„å€¼ç›´æ¥èµ‹ç»™ x[rd] ï¼Œè€Œè¦æå‡ºè¿™ä¹ˆä¸€ä¸ªä¸­é—´å˜é‡ t å‘¢ï¼Ÿäº‹å®ä¸Šè¿™æ˜¯å› ä¸ºæŒ‡ä»¤ä¸­ rs1 å’Œ rd å¯èƒ½æ˜¯ä¸€æ ·çš„ï¼Œå¦‚æœåœ¨ç¬¬ä¸€æ¡æŒ‡ä»¤å°±ç›´æ¥ä¿®æ”¹äº† x[rd]ï¼Œå°±å¯èƒ½ä¹Ÿä¿®æ”¹äº† x[rs1]ï¼Œä»è€Œç¬¬äºŒæ¡æŒ‡ä»¤çš„ç»“æœå°±ä¸å¯¹äº†ã€‚å› æ­¤ä¸­é—´å˜é‡ t çš„è®¾ç½®ç»éæ˜¯ç”»è›‡æ·»è¶³ã€‚\nISA çš„æ‰‹å†Œç»è¿‡äº†å¾ˆå¤šäººçš„æ‰“ç£¨ï¼Œæ˜¯éå¸¸ç®€ç»ƒçš„ã€‚æ¯ä¸€æ¡çœ‹ä¼¼æ— ç”¨çš„è¯­å¥ä¸€å®šéƒ½æ˜¯å……åˆ†è€ƒè™‘åˆ°äº†ä¸€äº›ç‰¹æ®Šæƒ…å†µæ— æ³•åˆ é™¤æ‰å‘ˆç°åœ¨æ‰‹å†Œä¸­çš„ã€‚å› æ­¤æœ€ç®€å•çš„ä¿è¯æ­£ç¡®çš„å®ç°æ–¹æ³•å°±æ˜¯ï¼šæ‰‹å†Œè¯´ä»€ä¹ˆä½ å°±å†™ä»€ä¹ˆã€‚\nåŸºç¡€è®¾æ–½(2) æ€è€ƒé¢˜ æ¶ˆå¤±çš„ç¬¦å· æˆ‘ä»¬åœ¨am-kernels/tests/cpu-tests/tests/add.cä¸­å®šä¹‰äº†å®NR_DATA, åŒæ—¶ä¹Ÿåœ¨add()å‡½æ•°ä¸­å®šä¹‰äº†å±€éƒ¨å˜é‡cå’Œå½¢å‚a, b, ä½†ä½ ä¼šå‘ç°åœ¨ç¬¦å·è¡¨ä¸­æ‰¾ä¸åˆ°å’Œå®ƒä»¬å¯¹åº”çš„è¡¨é¡¹, ä¸ºä»€ä¹ˆä¼šè¿™æ ·? æ€è€ƒä¸€ä¸‹, ä»€ä¹ˆæ‰ç®—æ˜¯ä¸€ä¸ªç¬¦å·(symbol)?\nå®åªæ˜¯åšäº†ç®€å•çš„å­—ç¬¦ä¸²æ›¿æ¢ï¼Œåœ¨é¢„å¤„ç†é˜¶æ®µå°±ä¼šå¤„ç†æ‰ï¼Œæ˜¾ç„¶ä¸ä¼šè¿›å…¥ç¬¦å·è¡¨ã€‚å±€éƒ¨å˜é‡å’Œå½¢å¼å‚æ•°éƒ½æ˜¯åœ¨æ ˆä¸Šå®šä¹‰çš„ï¼Œæ‰€ä»¥ä¸åœ¨ç¬¦å·è¡¨ä¸­ã€‚åªæœ‰å…¨å±€å˜é‡ã€å‡½æ•°ã€é™æ€å…¨å±€å˜é‡ã€åªè¯»å­—ç¬¦ä¸²ç­‰æ‰ä¼šå‡ºç°åœ¨ç¬¦å·è¡¨ä¸­ã€‚\nå¯»æ‰¾\u0026quot;Hello World!\u0026quot; åœ¨Linuxä¸‹ç¼–å†™ä¸€ä¸ªHello Worldç¨‹åº, ç¼–è¯‘åé€šè¿‡ä¸Šè¿°æ–¹æ³•æ‰¾åˆ°ELFæ–‡ä»¶çš„å­—ç¬¦ä¸²è¡¨, ä½ å‘ç°\u0026quot;Hello World!\u0026ldquo;å­—ç¬¦ä¸²åœ¨å­—ç¬¦ä¸²è¡¨ä¸­çš„ä»€ä¹ˆä½ç½®? ä¸ºä»€ä¹ˆä¼šè¿™æ ·?\nç¬”è€…å…ˆç”¨å‘½ä»¤ hd a.out æŸ¥çœ‹äºŒè¿›åˆ¶æ–‡ä»¶å¹¶æ‰¾åˆ°äº† \u0026ldquo;Hello, World\\n\u0026rdquo; å­—ç¬¦ä¸²åœ¨æ–‡ä»¶ä¸­çš„åç§»é‡ï¼Œç„¶åç”¨ readelf -a a.out å‘½ä»¤æŸ¥çœ‹äº†æ‰€æœ‰èŠ‚ï¼Œå‘ç°è¯¥å­—ç¬¦ä¸²åœ¨åªè¯»æ•°æ®èŠ‚ä¸­ã€‚ä¹‹æ‰€ä»¥åœ¨åªè¯»ä»£ç èŠ‚ä¸­æ˜¯å› ä¸ºè¿™ä¸ªå­—ç¬¦ä¸²æ˜¯ç†è®ºä¸Šä¸åº”è¯¥è¢«ä¿®æ”¹çš„ã€‚\nä¸åŒ¹é…çš„å‡½æ•°è°ƒç”¨å’Œè¿”å› å¦‚æœä½ ä»”ç»†è§‚å¯Ÿä¸Šæ–‡recursionçš„ç¤ºä¾‹è¾“å‡º, ä½ ä¼šå‘ç°ä¸€äº›æœ‰è¶£çš„ç°è±¡. å…·ä½“åœ°, æ³¨é‡Š(1)å¤„çš„retçš„å‡½æ•°æ˜¯å’Œå¯¹åº”çš„callåŒ¹é…çš„, ä¹Ÿå°±æ˜¯è¯´, callè°ƒç”¨äº†f2, è€Œä¸ä¹‹å¯¹åº”çš„retä¹Ÿæ˜¯ä»f2è¿”å›; ä½†æ³¨é‡Š(2)æ‰€æŒ‡ç¤ºçš„ä¸€ç»„callå’Œretçš„æƒ…å†µå´æœ‰æ‰€ä¸åŒ, callè°ƒç”¨äº†f1, ä½†å´ä»f0è¿”å›; æ³¨é‡Š(3)æ‰€æŒ‡ç¤ºçš„ä¸€ç»„callå’Œretä¹Ÿå‡ºç°äº†ç±»ä¼¼çš„ç°è±¡, callè°ƒç”¨äº†f1, ä½†å´ä»f3è¿”å›.\nå°è¯•ç»“åˆåæ±‡ç¼–ç»“æœ, åˆ†æä¸ºä»€ä¹ˆä¼šå‡ºç°è¿™ä¸€ç°è±¡.\nè¿™æ˜¯ä¸€ä¸ªéå¸¸æœ‰æ„æ€çš„é—®é¢˜ï¼Œæˆ‘ä»¬ä»¥æ³¨é‡Š(2)å¤„çš„ä»£ç ä¸ºä¾‹åˆ†æè¿™ä¸€æƒ…å†µï¼š\næ³¨é‡Š(2)å¤„æ˜¾ç¤ºï¼Œå‡½æ•° f2 ä¸­è°ƒç”¨äº† f1 ï¼Œä½†æ²¡æœ‰ä» f1 è¿”å›è€Œæ˜¯ä» f0 è¿”å›çš„ã€‚ä½¿ç”¨ nemu è¿½è¸ª CPU æ˜¯å¦‚ä½•ä» f1 æ‚„æ‚„è·³åˆ° f0 çš„ï¼Œå‘ç°äº† f1 ç»“å°¾å¤„çš„å¦‚ä¸‹æ±‡ç¼–ä»£ç ï¼š\n80000090:\t00158593 addi\ta1,a1,1 80000094:\tfff50513 addi\ta0,a0,-1 80000098:\t00078067 jr\ta5 8000009c:\t00100513 li\ta0,1 800000a0:\t00008067 ret f1 çš„ C è¯­è¨€åŸæ–‡å¦‚ä¸‹ï¼š\nint f1(int n, int l) { if (l \u0026gt; lvl) lvl = l; rec ++; return n \u0026lt;= 0 ? 1 : func[0](n - 1, l + 1); }; æ­£æ˜¯ä½äºåœ°å€ 0x80000098 å¤„çš„æŒ‡ä»¤ jr a5 ä» f1 è·³è½¬åˆ°äº† f0ï¼Œä¹Ÿå°±æ˜¯è¯´å…¶å®æˆ‘ä»¬çš„ ftrace è¿½è¸ªæ¼äº†ä¸€æ¬¡è°ƒç”¨ã€‚è¿™ä¸€è·³è½¬æŒ‡ä»¤ä¹‹æ‰€ä»¥ä¼šåœ¨è¿½è¸ªä¸­è¢«é—æ¼æ˜¯å› ä¸ºå®ƒä¸ç¬¦åˆæ ‡å‡†çš„è·³è½¬æŒ‡ä»¤çš„å½¢å¼ï¼šæ ‡å‡†çš„è·³è½¬æŒ‡ä»¤ä¸€èˆ¬éƒ½æ˜¯ jal æˆ– jalr æŒ‡ä»¤ï¼Œä¸”å­˜å‚¨ snpc çš„å¯„å­˜å™¨æŒ‰ç…§ calling convention åº”ä¸º raï¼Œä»¥æ–¹ä¾¿ return å›æ¥ä»¥åä»è·³è½¬æŒ‡ä»¤çš„ä¸‹ä¸€æ¡å¼€å§‹ç»§ç»­æ‰§è¡Œã€‚è¿™é‡Œä½¿ç”¨ jr a5 ç›´æ¥è·³è½¬ï¼Œä¼šå¯¼è‡´ä» f0 è¿”å›åå…¶å®æ²¡æœ‰å›åˆ° f1ã€‚\nè¿™é‡Œä¹‹æ‰€ä»¥å‡ºç°è¿™æ ·çš„æƒ…å†µæ˜¯å› ä¸ºç¼–è¯‘å™¨å¯¹å°¾è°ƒç”¨è¿›è¡Œäº†ä¼˜åŒ–ã€‚å› ä¸º f1 è°ƒç”¨ f0 åœ¨ f1 çš„å‡½æ•°æœ«å°¾ï¼Œæ‰€ä»¥æ‰§è¡Œå®Œ f0 è¿”å›ä¹‹å f1 ä¼šç«‹å³æ‹¿ç€ f0 çš„è¿”å›å€¼å†è¿”å›ç»™ f2ï¼Œæ‰€ä»¥ä¸å¦¨è®© f0 ç›´æ¥è¿”å› f2ã€‚è¿™ä¸ªä¼˜åŒ–åœ¨å°¾é€’å½’ä¸­ä¼šæ ¼å¤–æœ‰ç”¨ï¼Œä¸ä»…çœå»äº†ä¸€äº›æŒ‡ä»¤ï¼Œè¿˜å¯ä»¥é‡å¤åˆ©ç”¨æ ˆå¸§ï¼Œä½¿å¾—å±‚æ•°å¾ˆæ·±çš„å°¾é€’å½’ä¹Ÿä¸ä¼šçˆ†æ ˆã€‚\nå†—ä½™çš„ç¬¦å·è¡¨ åœ¨Linuxä¸‹ç¼–å†™ä¸€ä¸ªHello Worldç¨‹åº, ç„¶åä½¿ç”¨stripå‘½ä»¤ä¸¢å¼ƒå¯æ‰§è¡Œæ–‡ä»¶ä¸­çš„ç¬¦å·è¡¨:\ngcc -o hello hello.c strip -s hello ç”¨readelfæŸ¥çœ‹helloçš„ä¿¡æ¯, ä½ ä¼šå‘ç°ç¬¦å·è¡¨è¢«ä¸¢å¼ƒäº†, æ­¤æ—¶çš„helloç¨‹åºèƒ½æˆåŠŸè¿è¡Œå—?\nç›®æ ‡æ–‡ä»¶ä¸­ä¹Ÿæœ‰ç¬¦å·è¡¨, æˆ‘ä»¬åŒæ ·å¯ä»¥ä¸¢å¼ƒå®ƒ:\ngcc -c hello.c strip -s hello.o ç”¨readelfæŸ¥çœ‹hello.oçš„ä¿¡æ¯, ä½ ä¼šå‘ç°ç¬¦å·è¡¨è¢«ä¸¢å¼ƒäº†. å°è¯•å¯¹hello.oè¿›è¡Œé“¾æ¥:\ngcc -o hello hello.o ä½ å‘ç°äº†ä»€ä¹ˆé—®é¢˜? å°è¯•å¯¹æ¯”ä¸Šè¿°ä¸¤ç§æƒ…å†µ, å¹¶åˆ†æå…¶ä¸­çš„åŸå› .\nç¬¬ä¸€ç§æƒ…å†µä¸¢å¼ƒäº†ç¬¦å·è¡¨ä¹‹åä»ç„¶å¯ä»¥æ­£å¸¸è¿è¡Œï¼Œç¬¬äºŒç§æƒ…å†µä¸¢å¼ƒäº†ç¬¦å·è¡¨åä¼šæŠ¥é”™ï¼š\n/usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/10/../../../x86_64-linux-gnu/Scrt1.o: in function `_start': (.text+0x24): undefined reference to `main' å› ä¸ºç¬¦å·è¡¨è¢«åˆ é™¤äº†ï¼Œæ— æ³•æ‰¾åˆ° main å‡½æ•°çš„ä½ç½®ï¼Œæ‰€ä»¥é“¾æ¥å¤±è´¥ã€‚ç¬¦å·è¡¨çš„ä½œç”¨å°±æ˜¯åœ¨é“¾æ¥çš„æ—¶å€™å‘Šè¯‰å¤–éƒ¨æ¨¡å—æœ¬æ¨¡å—çš„å„ä¸ªå‡½æ•°ã€å˜é‡çš„åœ°å€ï¼Œåœ¨å·²ç»ç”Ÿæˆå¥½çš„å¯æ‰§è¡Œæ–‡ä»¶ä¸­ï¼Œæ‰€æœ‰é‡å®šä½å·²ç»å®Œæˆï¼Œè‡ªç„¶ä¸å†éœ€è¦ç¬¦å·è¡¨ï¼›ä½†å¦‚æœåœ¨å¯é‡å®šä½æ–‡ä»¶ä¸­åˆ å»äº†ç¬¦å·è¡¨ï¼Œé“¾æ¥åˆ™ä¼šå‡ºé—®é¢˜ã€‚\nå¦‚ä½•ç”Ÿæˆ native çš„å¯æ‰§è¡Œæ–‡ä»¶ é˜…è¯»ç›¸å…³Makefile, å°è¯•ç†è§£abstract-machineæ˜¯å¦‚ä½•ç”Ÿæˆnativeçš„å¯æ‰§è¡Œæ–‡ä»¶çš„.\nMakefile ä¸­æœ‰ä¸€ä¸ªå˜é‡ CROSS_COMPILEï¼Œåœ¨ native ä¸‹è¿è¡Œçš„æ—¶å€™è¿™ä¸ªå˜é‡æ²¡æœ‰èµ‹å€¼ï¼Œæ‰€ä»¥ Makefile ä¸ä¼šä½¿ç”¨äº¤å‰ç¼–è¯‘å·¥å…·ç¼–è¯‘ä»£ç ï¼Œè€Œæ˜¯ç”¨ native çš„ gcc å’Œ binutilsã€‚\nå¥‡æ€ªçš„é”™è¯¯ç  ä¸ºä»€ä¹ˆé”™è¯¯ç æ˜¯1å‘¢? ä½ çŸ¥é“makeç¨‹åºæ˜¯å¦‚ä½•å¾—åˆ°è¿™ä¸ªé”™è¯¯ç çš„å—?\nå¦‚æœ main å‡½æ•°æ­£å¸¸é€€å‡ºï¼Œè¿”å›å€¼ä¼šæ˜¯0ï¼Œå¦åˆ™è¿”å›å€¼æ˜¯1ã€‚make ç¨‹åºæ•æ‰ main å‡½æ•°çš„è¿”å›å€¼ï¼Œå¹¶æ®æ­¤åˆ¤æ–­æ˜¯å¦å‘ç”Ÿäº†é”™è¯¯ï¼Œå¹¶å°†é”™è¯¯ç å‘ˆç°å‡ºæ¥ã€‚\nè¿™æ˜¯å¦‚ä½•å®ç°çš„ï¼Ÿ ä¸ºä»€ä¹ˆå®šä¹‰å®__NATIVE_USE_KLIB__ä¹‹åå°±å¯ä»¥æŠŠnativeä¸Šçš„è¿™äº›åº“å‡½æ•°é“¾æ¥åˆ°klib? è¿™å…·ä½“æ˜¯å¦‚ä½•å‘ç”Ÿçš„? å°è¯•æ ¹æ®ä½ åœ¨è¯¾å ‚ä¸Šå­¦ä¹ çš„é“¾æ¥ç›¸å…³çš„çŸ¥è¯†è§£é‡Šè¿™ä¸€ç°è±¡.\nklib ä¸­ç¼–å†™çš„æ‰€æœ‰åº“å‡½æ•°éƒ½è¢«æ¡ä»¶ç¼–è¯‘ ifdef æ¡†äº†èµ·æ¥ï¼Œå‚ä¸ç¼–è¯‘çš„æ¡ä»¶ä¸º !defined(__ISA_NATIVE__) || defined(__NATIVE_USE_KLIB))ã€‚å¦‚æœ NATIVE_USE_KLIB è¢«æ³¨é‡Šäº†çš„è¯ï¼Œåœ¨ native ä¸‹è¿è¡Œå°±ä¸ä¼šæœ‰æ‰‹å†™çš„åº“å‡½æ•°ï¼Œnative ä¼šä½¿ç”¨ glibc çš„åº“å‡½æ•°ã€‚å¦‚æœ NATIVE_USE_KLIB æ²¡æœ‰è¢«æ³¨é‡Šï¼Œåœ¨ native ä¸‹è¿è¡Œæœ‰æ‰‹å†™çš„åº“å‡½æ•°ï¼Œå½“æ‰‹å†™å‡½æ•°ä¸ glibc åº“å‡½æ•°åç§°å†²çªæ—¶ï¼Œä¼˜å…ˆé“¾æ¥ç”¨æˆ·æ‰‹å†™çš„å‡½æ•°ï¼Œè¿™æ ·å°±è¾¾åˆ°äº†ä½¿ç”¨ klib çš„æ•ˆæœã€‚\nåŒªå¤·æ‰€æ€çš„QEMUè¡Œä¸º(æœ‰ç‚¹éš¾åº¦) åœ¨ä¸€äº›æ—§ç‰ˆçš„mips32-QEMUä¸­, ä»…åœ¨ä¸Šè¿°æŒ‡ä»¤çš„PCå€¼å12ä½ä¸º0xffcæ—¶, æ‰ä¼šè¿›è¡ŒæŒ‡ä»¤æ‰“åŒ…. è¿™ä¸ªæ‰“åŒ…æ¡ä»¶çœ‹ä¸Šå»éå¸¸å¥‡æ€ª, ä½ çŸ¥é“å¯èƒ½çš„åŸå› æ˜¯ä»€ä¹ˆå—?\nç¬”è€…æ²¡æœ‰ä½¿ç”¨ QEMU è¿›è¡Œ difftestï¼Œä¹Ÿä¸äº†è§£ mips æŒ‡ä»¤é›†ï¼Œæ•…ç•™å‘ã€‚\næ•æ‰æ­»å¾ªç¯(æœ‰ç‚¹éš¾åº¦) NEMUé™¤äº†ä½œä¸ºæ¨¡æ‹Ÿå™¨ä¹‹å¤–, è¿˜å…·æœ‰ç®€å•çš„è°ƒè¯•åŠŸèƒ½, å¯ä»¥è®¾ç½®æ–­ç‚¹, æŸ¥çœ‹ç¨‹åºçŠ¶æ€. å¦‚æœè®©ä½ ä¸ºNEMUæ·»åŠ å¦‚ä¸‹åŠŸèƒ½\nå½“ç”¨æˆ·ç¨‹åºé™·å…¥æ­»å¾ªç¯æ—¶, è®©ç”¨æˆ·ç¨‹åºæš‚åœä¸‹æ¥, å¹¶è¾“å‡ºç›¸åº”çš„æç¤ºä¿¡æ¯\nä½ è§‰å¾—åº”è¯¥å¦‚ä½•å®ç°? å¦‚æœä½ æ„Ÿåˆ°ç–‘æƒ‘, åœ¨äº’è”ç½‘ä¸Šæœç´¢ç›¸å…³ä¿¡æ¯.\nä»ç†è®ºä¸Šè¯æ˜æŸä¸ªç¨‹åºä¼šæ­»å¾ªç¯æ˜¯ä¸å¯èƒ½çš„ï¼Œå› ä¸ºè¿™æ¶‰åŠåˆ°å›¾çµåœæœºé—®é¢˜ï¼šæ¯”å¦‚æˆ‘å†™ä¸€ä¸ª check å“¥å¾·å·´èµ«çŒœæƒ³çš„ç¨‹åºï¼Œå¦‚æœæˆ‘èƒ½åˆ¤æ–­å®ƒæ˜¯å¦ä¼šæ­»å¾ªç¯ï¼Œæˆ‘å°±è¯æ˜äº†å“¥å¾·å·´èµ«çŒœæƒ³ã€‚\nç¬”è€…ç»“åˆäº†ç½‘ä¸Šçš„èµ„æ–™å¹¶è‡ªå·±æ€è€ƒäº†ä¹‹åè®¤ä¸ºå¯ä»¥æœ‰å¦‚ä¸‹çš„ä¸€äº›æ•æ‰æ–¹æ³•ï¼š\nåœ¨ä¸€ä¸ªè¿›ç¨‹è¿è¡Œçš„åŒæ—¶ç”¨å¦ä¸€ä¸ªè¿›ç¨‹æ¥ç›‘è§†å®ƒçš„è¡Œä¸ºï¼Œå¦‚æœè¯¥è¿›ç¨‹è€—æ—¶è¿‡é•¿å°±å°†å…¶ killã€‚ æ­»å¾ªç¯ä¸»è¦æ¥è‡ª do-while å’Œ for å¾ªç¯ã€‚è™½ç„¶æ— é™é€’å½’ä»ç†è®ºä¸Šä¹Ÿä¼šæ­»å¾ªç¯ï¼Œä½†ç¡¬ä»¶çš„é™åˆ¶ä¼šä½¿å…¶é€šè¿‡çˆ†æ ˆçš„æ–¹å¼åœä¸‹æ¥ã€‚å› æ­¤å¯ä»¥åœ¨ç¼–è¯‘æ˜¯æ‰¾åˆ°æ‰€æœ‰çš„ do-while å’Œ for å¾ªç¯ï¼Œå‘å…¶ä¸­åŠ å…¥è®¡æ•°å™¨ï¼Œåœ¨å¾ªç¯æ‰§è¡Œæ¬¡æ•°è¶…è¿‡äº†ä¸€ä¸ªé˜ˆå€¼åå¼ºè¡Œé€€å‡ºã€‚ è¡¥å…… å…³äº Difftest ç¬”è€…åˆšå¼€å§‹æ— æ³•é€šè¿‡ spike çš„ difftestï¼ŒæŸ¥çœ‹å¯„å­˜å™¨çŠ¶æ€å‘ç° t0 å¯„å­˜å™¨çš„å€¼ä¸æ­£ç¡®ã€‚äº§ç”Ÿè¿™ä¸ªé—®é¢˜çš„åŸå› æ˜¯ç¬”è€…åœ¨å®ç° jal/jalr æŒ‡ä»¤æ—¶ä½¿ç”¨äº† t0 å¯„å­˜å™¨ä¿å­˜ä¸­é—´ç»“æœâ€”â€”è¿™ä¸€è¡Œä¸ºè™½ç„¶ç¬¦åˆè®²ä¹‰ä¸­çš„è°ƒç”¨çº¦å®šï¼Œä½†ç”±äº spike æ²¡æœ‰ç›¸åŒçš„è¡Œä¸ºï¼Œæ‰€ä»¥æŠ¥é”™äº†ã€‚äº‹å®ä¸Šæˆ‘ä»¬å†™çš„ nemu å¹¶ä¸æ˜¯çœŸæ­£çš„â€œç¡¬ä»¶â€ï¼šæˆ‘ä»¬æ ¹æœ¬ä¸éœ€è¦çœŸçš„ç”¨å¯„å­˜å™¨æ¥ä¿å­˜ä¸­é—´ç»“æœâ€”â€”æˆ‘ä»¬æœ‰ C è¯­è¨€ï¼Œå®šä¹‰ä¸€ä¸ªå˜é‡ä¿å­˜å°±å¯ä»¥äº†ï¼æ¡†æ¶ä»£ç ä¸­ç»™çš„ rtl_j å‡½æ•°ä¼¼ä¹ä¹Ÿä½¿ç”¨äº†ç±»ä¼¼çš„æ‰‹æ³•ï¼ˆç¬”è€…æ²¡æœ‰è°ƒç”¨æ¡†æ¶ä»£ç ç»™çš„ rtl_j æ¥å®ç°è·³è½¬æŒ‡ä»¤ï¼‰\nè¾“å…¥è¾“å‡º å¿…ç­”é¢˜ æ¸¸æˆæ˜¯å¦‚ä½•è¿è¡Œçš„ è¯·ä½ ä»¥æ‰“å­—å°æ¸¸æˆä¸ºä¾‹, ç»“åˆ\u0026quot;ç¨‹åºåœ¨è®¡ç®—æœºä¸Šè¿è¡Œ\u0026quot;çš„ä¸¤ä¸ªè§†è§’, æ¥å‰–ææ‰“å­—å°æ¸¸æˆç©¶ç«Ÿæ˜¯å¦‚ä½•åœ¨è®¡ç®—æœºä¸Šè¿è¡Œçš„. å…·ä½“åœ°, å½“ä½ æŒ‰ä¸‹ä¸€ä¸ªå­—æ¯å¹¶å‘½ä¸­çš„æ—¶å€™, æ•´ä¸ªè®¡ç®—æœºç³»ç»Ÿ(NEMU, ISA, AM, è¿è¡Œæ—¶ç¯å¢ƒ, ç¨‹åº) æ˜¯å¦‚ä½•ååŒå·¥ä½œ, ä»è€Œè®©æ‰“å­—å°æ¸¸æˆå®ç°å‡º\u0026quot;å‘½ä¸­\u0026quot;çš„æ¸¸æˆæ•ˆæœ?\nåœ¨ä¸»å¾ªç¯ä¹‹é—´ï¼Œæ‰“å­—å°æ¸¸æˆåšäº†ä¸€äº›ç»˜åˆ¶å±å¹•æ–¹é¢çš„å‡†å¤‡å·¥ä½œã€‚è¿™äº›å·¥ä½œåœ¨ vedio_init ä¸­ï¼Œå…·ä½“ä¸º\nè¯»å–çª—å£çš„å®½å’Œé«˜ã€‚ç¨‹åºè¯»å–çª—å£å¤§å°é€šè¿‡è¯»å– AM æä¾›çš„ AM_GPU_CONFIG æŠ½è±¡å¯„å­˜å™¨å®ç°ã€‚AM_GPU_CONFIG æŠ½è±¡å¯„å­˜å™¨åˆ™é€šè¿‡è®¿é—® nemu æä¾›çš„ I/O ç«¯å£æ¥è·å¾—è¿™äº›å‚æ•°ã€‚ å°†æ•´ä¸ªç”»å¸ƒæ¶‚æˆç´«è‰²çš„ã€‚ç¨‹åºå‘ç”»å¸ƒè¾“å‡ºé¢œè‰²é€šè¿‡å‘ AM æä¾›çš„ AM_GPU_FBDRAW æŠ½è±¡å¯„å­˜å™¨å†™å…¥å†…å®¹æ¥å®ç°ã€‚æŠ½è±¡å¯„å­˜å™¨ä¼šæ¥æ”¶åˆ°å¼€å§‹ç»˜åˆ¶çš„ä½ç½®çš„åæ ‡ï¼Œç»˜åˆ¶å†…å®¹æ•°é‡ï¼Œç»˜åˆ¶çš„å†…å®¹çš„ bufferï¼Œå’Œä¸€ä¸ªæ˜¯å¦ç«‹å³åŒæ­¥çš„å¸ƒå°”å˜é‡ã€‚æŠ½è±¡å¯„å­˜å™¨çš„è¡Œä¸ºå¾ˆç®€å•ï¼Œå°±æ˜¯å°†å¯¹åº”çš„æ•°æ®å†™åˆ° nemu çš„ I/O ç«¯å£ä¸­ã€‚nemu çš„ç¡¬ä»¶ä¼šæ¯éš”ä¸€æ®µæ—¶é—´æ£€æŸ¥æ˜¯å¦æœ‰åŒæ­¥ä¿¡å·ï¼Œå¦‚æœæœ‰å°±å°†ç¼“å†²åŒºçš„å†…å®¹è¾“å‡ºåˆ°å±å¹•ä¸Šã€‚ å¯¹å„ç§å­—æ¯çš„é¢œè‰²åšå¥½è®¾å®šã€‚ æ‰“å­—å°æ¸¸æˆçš„ä¸»å¾ªç¯æ˜¯ä¸€ä¸ª while(1) {} ï¼Œåœ¨å¾ªç¯ä¸­ä¼šåšè¿™æ ·ä¸€äº›äº‹æƒ…ï¼š\ngame_logic_updateï¼šæ¯æ¬¡å¾ªç¯ä¸­éƒ½ä¼šæ ¹æ®å’Œä¸Šæ¬¡æ›´æ–°çš„æ—¶é—´å·®è¿›è¡Œè‹¥å¹²æ¬¡æ¸¸æˆé€»è¾‘æ›´æ–°ã€‚è¿™é‡Œç¨‹åºè°ƒç”¨æ—¶é—´å‡½æ•°ä¼šä½¿ç”¨ AM æä¾›çš„æŠ½è±¡å¯„å­˜å™¨ AM_TIMER_UPTIME æ¥è¯»å–æ¸¸æˆå·²ç»å¼€å§‹çš„æ—¶é—´ã€‚AMä¸­è¯»å–è¿™ä¸ªæŠ½è±¡å¯„å­˜å™¨çš„é€»è¾‘æ˜¯è®¿é—® nemu çš„æ—¶é’Ÿ I/O ç«¯å£ã€‚\næ¸¸æˆé€»è¾‘æ›´æ–°ä¸­ä¼šå®šæœŸç”Ÿæˆä¸€ä¸ªæ–°çš„å­—æ¯ï¼Œå¹¶ä¸”å°†æ¯ä¸ªå­—æ¯æ ¹æ®å…¶ä¿¡æ¯æ›´æ–°ä½ç½®ã€‚å…³äºå­—æ¯ï¼Œæ¯ä¸ªå­—æ¯æœ‰å¦‚ä¸‹ä¸€äº›å‚æ•°ï¼š\nchï¼šè¡¨ç¤ºè¿™ä¸ªå­—æ¯æ˜¯å•¥ï¼Œå¯ä»¥å– A-Zã€‚ (x,y)ï¼šè¡¨ç¤ºå­—æ¯å½“å‰çš„ä½ç½®ã€‚x å€¼æ˜¯ç”Ÿæˆå­—æ¯çš„æ—¶å€™éšæœºçš„ï¼Œy å€¼åˆ™ä¼šæ ¹æ®å½“å‰çš„æ—¶é—´ä¸æ–­æ›´æ–°ã€‚ vï¼šè¡¨ç¤ºå­—æ¯å•ä½æ—¶é—´ç§»åŠ¨çš„é€Ÿåº¦ã€‚æ­£å¸¸æƒ…å†µä¸‹é€Ÿåº¦æ˜¯æ­£æ•°ï¼Œå­—æ¯ä¼šå¾€ä¸‹è½ã€‚å½“å­—æ¯è¢«å‡»ä¸­çš„æ—¶å€™é€Ÿåº¦ä¼šå˜æˆè´Ÿæ•°ï¼Œä»è€Œå®ç°å­—æ¯å‘ä¸Šå‡çš„æ•ˆæœã€‚å¦‚æœé€Ÿåº¦ä¸º0ï¼Œè¡¨ç¤ºå½“å‰å­—æ¯ miss äº†ã€‚ tï¼šè¿™æ˜¯ä¸€ä¸ªè®¡æ—¶å™¨ï¼Œç”¨äºå½“ä¸€ä¸ªå­—æ¯ miss çš„æ—¶å€™ï¼Œå»¶è¿Ÿ FPS çš„æ—¶é—´åæ‰ä¼šæ¶ˆå¤±ã€‚ é”®ç›˜è¯»å–ï¼šé™¤éè¯»å–åˆ° AM_KEY_NONE è¡¨ç¤ºå½“å‰æ²¡æœ‰æŒ‰é”®ï¼Œå¦åˆ™ç¨‹åºä¼šä¸€ç›´åœ¨é”®ç›˜è¯»å–çš„ while å¾ªç¯ä¸­ã€‚è¿™é‡Œç¨‹åºæ”¶é›†é”®ç›˜æŒ‰é”®ä¼šä½¿ç”¨ AM æä¾›çš„æŠ½è±¡å¯„å­˜å™¨ AM_INPUT_KEYBRDã€‚AM_INPUT_KEYBRD ä¼šè®¿é—® nemu çš„é”®ç›˜ I/O ç«¯å£ï¼Œå¹¶æ ¹æ®å¾—åˆ°çš„æ•°æ®ç”Ÿæˆ keydown å’Œ keycode ä¸¤ä¸ªå‚æ•°ã€‚\né”®ç›˜è¯»å–åˆ†ä¸ºä»¥ä¸‹ä¸¤ç§æƒ…å†µï¼š\næŒ‰ä¸‹äº† escape é”®ï¼šè°ƒç”¨ halt(0)ï¼Œé€€å‡ºã€‚ æŒ‰ä¸‹äº†æ˜¯å­—æ¯çš„é”®ï¼šè°ƒç”¨ check_hit å‡½æ•°æ£€æŸ¥æ˜¯å¦ç¡®å®å‡»ä¸­äº†å­—æ¯ã€‚check_hit çš„è¡Œä¸ºæ¯”è¾ƒç®€å•ï¼šå¦‚æœæ²¡æœ‰åŒ¹é…åˆ°ä»»ä½•ä¸€ä¸ªå­—æ¯åˆ™æ›´æ–° wrongï¼Œå¦åˆ™ä¼šå°†å‡»ä¸­çš„å­—æ¯çš„é€Ÿåº¦æ”¹æˆä¸€ä¸ªè´Ÿå€¼ï¼Œä»è€Œä¸€é¢å®ç°å­—æ¯è¢«å‡»ä¸­çš„æ ‡è®°ï¼Œä¸€é¢å®ç°å­—æ¯å‘ä¸Šå‡çš„æ•ˆæœã€‚ render ï¼šè¿™ä¸ªå‡½æ•°è´Ÿè´£æ›´æ–°å±å¹•ã€‚è¯¥å‡½æ•°ä¼šå°†å­—æ¯åŸæœ¬æ‰€å¤„ä½ç½®çš„å±å¹•å†…å®¹æŠ¹å»ï¼ˆå˜æˆç´«è‰²ï¼‰ï¼Œç„¶åæ ¹æ®å­—æ¯æ–°çš„ä½ç½®ä»¥åŠå­—æ¯å½“å‰çš„çŠ¶æ€ï¼ˆä¸‹è½ç™½è‰²ï¼Œmissçº¢è‰²ï¼Œå‡»ä¸­ç»¿è‰²ï¼‰é€‰æ‹©ç›¸åº”çš„ texture ä½œä¸º buffer è¾“å‡ºåˆ°å¯¹åº”ä½ç½®ã€‚\næ€è€ƒé¢˜ ç†è§£ volatile å…³é”®å­— ä¹Ÿè®¸ä½ ä»æ¥éƒ½æ²¡å¬è¯´è¿‡Cè¯­è¨€ä¸­æœ‰volatileè¿™ä¸ªå…³é”®å­—, ä½†å®ƒä»Cè¯­è¨€è¯ç”Ÿå¼€å§‹å°±ä¸€ç›´å­˜åœ¨. volatileå…³é”®å­—çš„ä½œç”¨ååˆ†ç‰¹åˆ«, å®ƒçš„ä½œç”¨æ˜¯é¿å…ç¼–è¯‘å™¨å¯¹ç›¸åº”ä»£ç è¿›è¡Œä¼˜åŒ–. ä½ åº”è¯¥åŠ¨æ‰‹ä½“ä¼šä¸€ä¸‹volatileçš„ä½œç”¨, åœ¨GNU/Linuxä¸‹ç¼–å†™ä»¥ä¸‹ä»£ç :\nvoid fun() { extern unsigned char _end; // _endæ˜¯ä»€ä¹ˆ? volatile unsigned char *p = \u0026amp;_end; *p = 0; while(*p != 0xff); *p = 0x33; *p = 0x34; *p = 0x86; } ç„¶åä½¿ç”¨-O2ç¼–è¯‘ä»£ç . å°è¯•å»æ‰ä»£ç ä¸­çš„volatileå…³é”®å­—, é‡æ–°ä½¿ç”¨-O2ç¼–è¯‘, å¹¶å¯¹æ¯”å»æ‰volatileå‰ååæ±‡ç¼–ç»“æœçš„ä¸åŒ.\nä½ æˆ–è®¸ä¼šæ„Ÿåˆ°ç–‘æƒ‘, ä»£ç ä¼˜åŒ–ä¸æ˜¯ä¸€ä»¶å¥½äº‹æƒ…å—? ä¸ºä»€ä¹ˆä¼šæœ‰volatileè¿™ç§å¥‡è‘©çš„å­˜åœ¨? æ€è€ƒä¸€ä¸‹, å¦‚æœä»£ç ä¸­pæŒ‡å‘çš„åœ°å€æœ€ç»ˆè¢«æ˜ å°„åˆ°ä¸€ä¸ªè®¾å¤‡å¯„å­˜å™¨, å»æ‰volatileå¯èƒ½ä¼šå¸¦æ¥ä»€ä¹ˆé—®é¢˜?\n_end æ˜¯ä¸€ä¸ªå˜é‡ï¼Œå®ƒçš„åœ°å€æŒ‡å‘äº†æ•°æ®æ®µçš„ç¬¬ä¸€ä¸ªæœªä½¿ç”¨çš„ä½ç½®ã€‚\nåœ¨æœ‰ volatile å…³é”®å­—çš„æƒ…å†µä¸‹ï¼Œåæ±‡ç¼–ç»“æœä¸ºï¼š\n0000000000000000 \u0026lt;fun\u0026gt;: 0:\tf3 0f 1e fa endbr64 4:\tc6 05 00 00 00 00 00 movb $0x0,0x0(%rip) # b \u0026lt;fun+0xb\u0026gt; b:\t48 8d 15 00 00 00 00 lea 0x0(%rip),%rdx # 12 \u0026lt;fun+0x12\u0026gt; 12:\t66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) 18:\t0f b6 02 movzbl (%rdx),%eax 1b:\t3c ff cmp $0xff,%al 1d:\t75 f9 jne 18 \u0026lt;fun+0x18\u0026gt; 1f:\tc6 05 00 00 00 00 33 movb $0x33,0x0(%rip) # 26 \u0026lt;fun+0x26\u0026gt; 26:\tc6 05 00 00 00 00 34 movb $0x34,0x0(%rip) # 2d \u0026lt;fun+0x2d\u0026gt; 2d:\tc6 05 00 00 00 00 86 movb $0x86,0x0(%rip) # 34 \u0026lt;fun+0x34\u0026gt; 34:\tc3 ret å¯ä»¥çœ‹åˆ°è¿™æ®µæŒ‡ä»¤å’Œ C è¯­è¨€ç¨‹åºçš„åŠŸèƒ½åŸºæœ¬æ˜¯ä¸€ä¸€å¯¹åº”çš„ã€‚\nåœ¨æ²¡æœ‰ volatile å…³é”®å­—çš„æƒ…å†µä¸‹ï¼Œåæ±‡ç¼–ç»“æœä¸ºï¼š\n0000000000000000 \u0026lt;fun\u0026gt;: 0:\tf3 0f 1e fa endbr64 4:\tc6 05 00 00 00 00 00 movb $0x0,0x0(%rip) # b \u0026lt;fun+0xb\u0026gt; b:\teb fe jmp b \u0026lt;fun+0xb\u0026gt; æŒ‡ä»¤å‘ç”Ÿäº†å¾ˆå¤§çš„å˜åŒ–ã€‚ç¼–è¯‘å™¨å‘ç° *p=0 ä¹‹åè¿›å…¥äº†ä¸€ä¸ªåªæœ‰ *p=0xff æ‰ä¼šé€€å‡ºçš„å¾ªç¯ï¼Œè¿™æœŸé—´æ²¡æœ‰ä»»ä½•å¯¹ p çš„æ›´æ”¹ï¼Œæ‰€ä»¥è®¤ä¸ºè¿™æ˜¯ä¸€ä¸ªæ­»å¾ªç¯ï¼Œç›´æ¥å°†å…¶ç¼©å‡ä¸ºäº† jmp b ï¼Œå¹¶ä¸”ç æ‰äº†åé¢çš„æ‰€æœ‰å†…å®¹ã€‚\nå¦‚æœ p æŒ‡å‘çš„åœ°å€è¢«æ˜ å°„åˆ°äº†ä¸€ä¸ªè®¾å¤‡å¯„å­˜å™¨ï¼Œé‚£ä¹ˆåŸæœ¬è¿™ä¸ªç¨‹åºçš„åŠŸèƒ½å¯èƒ½æ˜¯æ­£ç¡®çš„ï¼šå½“æ£€æµ‹åˆ°è®¾å¤‡å¯„å­˜å™¨çš„å€¼å˜ä¸º 0xff åï¼Œä¾æ¬¡å‘è®¾å¤‡å¯„å­˜å™¨å†™å…¥ 0x33, 0x34 å’Œ 0x86ã€‚ä½†ç¼–è¯‘ä¼˜åŒ–ä¹‹åï¼Œè¿™ä¸ªç¨‹åºå°±å®Œå…¨å˜æˆäº†ä¸€ä¸ªæ­»å¾ªç¯ã€‚å› æ­¤æˆ‘ä»¬å¹¶ä¸æ˜¯ä»€ä¹ˆæ—¶å€™éƒ½å¸Œæœ›æ¿€è¿›çš„ç¼–è¯‘ä¼˜åŒ–ï¼šç¼–è¯‘å™¨æœ‰å¯èƒ½è€ƒè™‘ä¸åˆ°å¤–è®¾çš„å‚ä¸ç­‰æƒ…å†µã€‚\nå¦‚ä½•æ£€æµ‹å¤šä¸ªé”®åŒæ—¶è¢«æŒ‰ä¸‹? åœ¨æ¸¸æˆä¸­, å¾ˆå¤šæ—¶å€™éœ€è¦åˆ¤æ–­ç©å®¶æ˜¯å¦åŒæ—¶æŒ‰ä¸‹äº†å¤šä¸ªé”®, ä¾‹å¦‚RPGæ¸¸æˆä¸­çš„å…«æ–¹å‘è¡Œèµ°, æ ¼æ–—æ¸¸æˆä¸­çš„ç»„åˆæ‹›å¼ç­‰ç­‰. æ ¹æ®é”®ç›˜ç çš„ç‰¹æ€§, ä½ çŸ¥é“è¿™äº›åŠŸèƒ½æ˜¯å¦‚ä½•å®ç°çš„å—?\né”®ç›˜ç æ˜¯ä¸€ä¸ª8ä½äºŒè¿›åˆ¶æ•°ï¼Œå¦‚æœæˆ‘ä»¬ç”¨32ä½æ•´æ•°æ¥ä¼ é€’é”®ç›˜ç ï¼Œå°±å¯ä»¥åŒæ—¶ä¼ é€’4ä¸ªï¼Œå¯ä»¥ç”¨äºæ£€æµ‹å¤šä¸ªé”®åŒæ—¶æŒ‰ä¸‹ã€‚\nç¥å¥‡çš„è°ƒè‰²æ¿ ç°ä»£çš„æ˜¾ç¤ºå™¨ä¸€èˆ¬éƒ½æ”¯æŒ24ä½çš„é¢œè‰²(R, G, Bå„å 8ä¸ªbit, å…±æœ‰2^8*2^8*2^8çº¦1600ä¸‡ç§é¢œè‰²), ä¸ºäº†è®©å±å¹•æ˜¾ç¤ºä¸åŒçš„é¢œè‰²æˆä¸ºå¯èƒ½, åœ¨8ä½é¢œè‰²æ·±åº¦æ—¶ä¼šä½¿ç”¨è°ƒè‰²æ¿çš„æ¦‚å¿µ. è°ƒè‰²æ¿æ˜¯ä¸€ä¸ªé¢œè‰²ä¿¡æ¯çš„æ•°ç»„, æ¯ä¸€ä¸ªå…ƒç´ å 4ä¸ªå­—èŠ‚, åˆ†åˆ«ä»£è¡¨R(red), G(green), B(blue), A(alpha)çš„å€¼. å¼•å…¥äº†è°ƒè‰²æ¿çš„æ¦‚å¿µä¹‹å, ä¸€ä¸ªåƒç´ å­˜å‚¨çš„å°±ä¸å†æ˜¯é¢œè‰²çš„ä¿¡æ¯, è€Œæ˜¯ä¸€ä¸ªè°ƒè‰²æ¿çš„ç´¢å¼•: å…·ä½“æ¥è¯´, è¦å¾—åˆ°ä¸€ä¸ªåƒç´ çš„é¢œè‰²ä¿¡æ¯, å°±è¦æŠŠå®ƒçš„å€¼å½“ä½œä¸‹æ ‡, åœ¨è°ƒè‰²æ¿è¿™ä¸ªæ•°ç»„ä¸­åšä¸‹æ ‡è¿ç®—, å–å‡ºç›¸åº”çš„é¢œè‰²ä¿¡æ¯. å› æ­¤, åªè¦ä½¿ç”¨ä¸åŒçš„è°ƒè‰²æ¿, å°±å¯ä»¥åœ¨ä¸åŒçš„æ—¶åˆ»ä½¿ç”¨ä¸åŒçš„256ç§é¢œè‰²äº†.\nåœ¨ä¸€äº›90å¹´ä»£çš„æ¸¸æˆä¸­(æ¯”å¦‚ä»™å‰‘å¥‡ä¾ ä¼ ), å¾ˆå¤šæ¸å‡ºæ¸å…¥æ•ˆæœéƒ½æ˜¯é€šè¿‡è°ƒè‰²æ¿å®ç°çš„, èªæ˜çš„ä½ çŸ¥é“å…¶ä¸­çš„ç„æœºå—?\nåœ¨ä¿æŒé¢œè‰²ç´¢å¼•ä¸å˜çš„æƒ…å†µä¸‹ï¼Œåªè¦å¹³æ»‘åœ°åˆ‡æ¢è°ƒè‰²æ¿å°±å¯ä»¥å®ç°æ¸å˜ã€‚å¦‚æœå‡†å¤‡å¤šå¥—è°ƒè‰²æ¿ï¼Œäº‹å®ä¸Šæˆ‘ä»¬å¯ä»¥ä½¿ç”¨è¿œä¸æ­¢256ç§é¢œè‰²ã€‚\nLiteNES å¦‚ä½•å·¥ä½œï¼Ÿ å¦ä¸€ä¸ªå€¼å¾—RTFSCçš„é¡¹ç›®æ˜¯LiteNES, é™¤äº†å†…ç½®romä¹‹å¤–, ä»£ç æ€»æ•°å¤§çº¦1500è¡Œ. å…³é”®æ˜¯è¿™ä¸ªå°å·§ç²ç‘çš„é¡¹ç›®é‡Œé¢å·²ç»åŒ…å«äº†ä¸€ä¸ªå®Œæ•´çš„è®¡ç®—æœºç³»ç»Ÿ: CPU, å†…å­˜, MMIO, ä»¥åŠæ‰‹æŸ„(psg), å¡å¸¦(mmc)å’Œå›¾å½¢å¤„ç†å™¨(ppu)è¿™ä¸‰ä¸ªå¤–è®¾. é™¤äº†ppuçš„å†…éƒ¨å®ç°ç»†èŠ‚ä¹‹å¤–, å…¶ä½™çš„éƒ¨åˆ†ä½ éƒ½å·²ç»æœ‰èƒ½åŠ›å»ç†è§£äº†.\næœ‰è¶£çš„æ˜¯, LiteNESå¯ä»¥çœ‹æˆæ˜¯NEMUå’ŒAMç¨‹åºçš„èåˆ. å°è¯•é˜…è¯»LiteNESçš„ä»£ç , ç†è§£LiteNESä½œä¸ºä¸€ä¸ªå®Œæ•´çš„è®¡ç®—æœºç³»ç»Ÿ, ä¸Šè¿°éƒ¨ä»¶å¦‚ä½•äº¤äº’, ä»¥åŠLiteNESä½œä¸ºä¸€ä¸ªAMç¨‹åº, å¦‚ä½•é€šè¿‡AMæä¾›çš„APIæ¥å®ç°æ¸¸æˆæ•ˆæœ. æˆ‘ä»¬æä¾› 6502å¤„ç†å™¨(NESçš„CPU)ä»¥åŠ NES PPU(å›¾å½¢å¤„ç†å™¨)çš„èµ„æ–™ä¾›å¤§å®¶å‚è€ƒ.\nç•™å‘ã€‚\nè¡¥å…… å…³äºä¸²å£èƒŒåçš„åŸç† putch ä»…ä»…æ‰§è¡Œäº† outb(SERIAL_PORT,ch)ï¼Œè€Œ outb(SERIAL_PORT,ch) ä»…ä»…å°† *SERIAL_PORT çš„å€¼èµ‹æˆäº† chï¼Œä¸ºä»€ä¹ˆå°±èƒ½åŒæ—¶é€šè¿‡æ ‡å‡†é”™è¯¯æµæŠŠä¿¡æ¯è¾“å‡ºåœ¨å±å¹•ä¸Šå‘¢ï¼Ÿ\næˆ‘ä»¬éœ€è¦æ·±å…¥åˆ°æ±‡ç¼–å±‚é¢ç†è§£è¿™æ®µä»£ç ï¼Œputch ç¼–è¯‘æˆæ±‡ç¼–ä»£ç åä»…æœ‰ä¸‰å¥è¯ï¼š\nlui a5, 0xa0000 sb a0, 1016(a5) ret ç¬¬ä¸€å¥è¯è£…è½½ç«‹å³æ•°ï¼Œç»“åˆç¬¬äºŒå¥çš„ 1016(a5) å®šä½åˆ° SERIAL_PORT æŒ‡å‘çš„åœ°å€ï¼Œç¬¬äºŒå¥è¯å°±æ˜¯çœŸæ­£çš„å†™å…¥å‡½æ•°ã€‚è™½ç„¶çœ‹ä¸Šå»ä»…ä»…æ˜¯ storeï¼Œä½†å‘ I/O è®¾å¤‡çš„ store è¡Œä¸ºæ˜¯æ›´ä¸°å¯Œçš„ï¼Œåœ¨ nemu ä¸­å®ƒä¼šèµ°è¿‡è¿™æ ·çš„æµç¨‹ï¼š\nå–æŒ‡è¯‘ç ä¹‹åè·å–æ‰€æœ‰çš„ä¿¡æ¯ï¼Œå¹¶åˆ†é…å¥½ä¸€ä¸ªå­˜å‚¨ç›¸å…³çš„æ‰§è¡Œå‡½æ•°ã€‚ è¿è¡Œæ‰§è¡Œå‡½æ•°ï¼Œstore çš„æ‰§è¡Œå‡½æ•°ä¼šè°ƒç”¨ paddr_writeã€‚ paddr_write åˆ†æäº†ä¸€ä¸‹è¦å†™å…¥çš„åœ°å€ï¼Œå‘ç°å¹¶ä¸åœ¨å†…å­˜ä¸­ï¼Œè€Œæ˜¯åœ¨ I/O åŒºåŸŸï¼Œäºæ˜¯è°ƒç”¨äº† mmio_writeã€‚ mmio_write åˆ†æäº†ä¸€ä¸‹è¦å†™å…¥çš„åœ°å€ï¼Œå‘ç°æ˜¯ä¸²å£çš„åœ°å€ï¼Œäºæ˜¯è°ƒç”¨äº† map_write ï¼Œå¹¶æŠŠä¸²å£çš„ IOMap ä¼ äº†è¿‡å»ã€‚ map_write åšäº†ä¸€äº›æ­£ç¡®æ€§æ£€æŸ¥ä¹‹åï¼Œå…ˆè°ƒç”¨äº† host_write ï¼Œå°† ch è¿™ä¸ªæ•°æ®å†™åˆ°äº† SERIAL_PORT åœ°å€ï¼Œç„¶åè°ƒç”¨äº†ä¸²å£çš„å›è°ƒå‡½æ•°ã€‚ ä¸²å£çš„å›è°ƒå‡½æ•°æ˜¯ serial_io_handler ï¼Œä¸²å£çš„å›è°ƒå‡½æ•°é»˜è®¤æ˜¯è¾“å‡ºï¼Œå¦åˆ™ä¼šæŠ¥é”™ï¼Œåœ¨ is_write==true çš„æƒ…å†µä¸‹å›è°ƒå‡½æ•°ä¼šè°ƒç”¨ serial_putcã€‚ serial_putc ä½¿ç”¨äº† glibc ä¸­çš„ putc(ch,stderr) å°†å­—ç¬¦è¾“å‡ºåˆ°äº†æ ‡å‡†é”™è¯¯æµã€‚ å› æ­¤äº‹å®ä¸Šè™½ç„¶ä»é«˜çº§è¯­è¨€å±‚é¢ putch ä¸­åªæœ‰ä¸€ä¸ªå­˜å‚¨æŒ‡ä»¤ï¼Œä½†åœ¨æ±‡ç¼–å±‚é¢å®ƒæ—¢å®Œæˆäº†å­˜å‚¨åˆå®Œæˆäº†è¾“å‡ºã€‚ç¬¦åˆä¸²å£çš„ featureã€‚\nç–‘é—® å¦‚æœ nemu æ‰€æœ‰å‘å±å¹•è¾“å‡ºçš„å‡½æ•°æœ€ç»ˆéƒ½æ˜¯é€šè¿‡ putch æ¥å®ç°ï¼Œé‚£ä¹ˆæŒ‰ç†æ¥è¯´åªéœ€è¦ç”³è¯·ä¸€ä¸ªå­—èŠ‚å¤§å°çš„ä¸²å£ç©ºé—´å°±å¯ä»¥äº†ï¼Œä¸ºä»€ä¹ˆè¦ 8 ä¸ªå­—èŠ‚å‘¢ï¼Ÿ\nå…³äºæ—¶é’Ÿç¡¬ä»¶æ¥å£ æ¡†æ¶ä»£ç ä¸­æœ‰ä¸€ä¸ªå°ç»†èŠ‚ï¼šåªæœ‰åœ¨è¯»å–æ—¶é’Ÿçš„é«˜32ä½çš„æ—¶å€™æ‰ä¼šè§¦å‘ nemu é‡æ–°è¯»å–å½“å‰æ—¶é—´ã€‚è¿™æ„å‘³ç€å¦‚æœéœ€è¦è¯»å–æ—¶é—´ï¼Œä¸€å®šè¦å…ˆè¯»å–é«˜32ä½å†è¯»å–ä½32ä½ï¼Œé¡ºåºåè¿‡æ¥å°±ä¼šå‡ºé”™ã€‚è¿™æ ·æœ‰ä¸€ä¸ªå¥½å¤„ï¼šå› ä¸ºä¸¤æ¬¡è¯»å–æ€»æ˜¯æœ‰æ—¶é—´å·®çš„ï¼Œæ‰€ä»¥è¿™æ ·å¯ä»¥ä¿è¯é«˜32ä½å’Œä½32ä½æ¥è‡ªåŒä¸€ä¸ªæ—¶åˆ»ã€‚\nå£°å¡ ç¬”è€…å®Œæˆäº†å£°å¡çš„é€‰åšé¢˜ã€‚å£°å¡çš„ I/O ç›¸è¾ƒäºå…¶ä»–çš„ä¼šå¤æ‚ä¸€äº›ï¼Œå› ä¸º nemu çš„ç¡¬ä»¶éƒ¨åˆ†çš„ä»£ç ä¹Ÿéœ€è¦è‡ªå·±å®ç°ã€‚nemu ä¸æ˜¯çœŸæ­£çš„â€œç¡¬ä»¶â€ï¼Œè¦å®ç°éŸ³é¢‘çš„è¾“å‡ºè¿˜æ˜¯å¾—é åº“å‡½æ•°ã€‚è¿™é‡Œç¬”è€…æ ¹æ®è®²ä¹‰ä½¿ç”¨äº† SDL åº“ã€‚\næˆ‘ä»¬éœ€è¦åœ¨ AM ä¸­å®ç°ä»¥ä¸‹å‡½æ•°ï¼š\n__am_audio_configï¼šè¯»å–å£°å¡çš„çŠ¶æ€ï¼ŒåŒ…æ‹¬æ˜¯å¦å­˜åœ¨å£°å¡ (cfg-\u0026gt;present)ã€‚ __am_audio_ctrlï¼šå‘Šè¯‰ç¡¬ä»¶ä¸€äº›åŸºæœ¬çš„ä¿¡æ¯ï¼Œå¦‚é¢‘ç‡ï¼Œé¢‘é“ï¼Œé‡‡æ ·ç‡ç­‰ç­‰ã€‚ __am_audio_statusï¼šè¯»å–ç¼“å†²åŒºä¸­è¿˜æœ‰çš„æ•°æ®å­—èŠ‚æ•°ã€‚ __am_audio_playï¼šå‘å£°å¡çš„ç¼“å†²åŒºå†™å…¥æ•°æ®ã€‚å¦‚æœå£°å¡çš„ç¼“å†²åŒºä¸å¤Ÿï¼Œåˆ™åº”è¯¥è½®è¯¢ï¼Œç›´åˆ°ç¼“å†²åŒºå¤§å°è¶³å¤Ÿä½ç½®ã€‚ æˆ‘ä»¬éœ€è¦åœ¨ nemu ä¸­åšè¿™æ ·ä¸€äº›äº‹æƒ…ï¼š\nåœ¨ audio çš„å›è°ƒå‡½æ•° audio_io_handler ä¸­å®Œæˆåˆå§‹åŒ–ï¼ŒåŒ…æ‹¬å‘ SDL_AudioSpec ç±»å‹çš„å˜é‡ä¸­å¡«å†™é¢‘ç‡ã€é¢‘é“ã€é‡‡æ ·ç‡ï¼Œæ³¨å†Œä¸€ä¸ªå›è°ƒå‡½æ•° audio_callback()ï¼Œä»¥åŠè°ƒç”¨ SDL_InitSubSystem å’Œ SDL_OpenAudio å‡½æ•°ç­‰ã€‚ å®Œæˆ audio-sbuf çš„å›è°ƒå‡½æ•° audio_sbuf_handler ï¼Œä¸»è¦å·¥ä½œå°±æ˜¯æŠŠ AM é€è¿‡æ¥çš„æ•°æ®æ”¾å…¥ç¼“å†²é˜Ÿåˆ—ã€‚ å®Œæˆ audio_callback()ï¼ŒSDL ä¼šä¸å®šæ—¶ç´¢è¦ä¸€å®šé‡çš„æ•°æ®ï¼Œä»å½“å‰ç¼“å†²åŒºçš„é˜Ÿåˆ—å¤´éƒ¨å–æ•°æ®ç»™ SDLã€‚å¦‚æœå½“å‰æ‰€å‰©æ•°æ®é‡ä¸å¤Ÿï¼Œåº”è¯¥å†è¡¥å……ä¸€äº› 0ï¼Œä»¥é˜²å‡ºç°å™ªéŸ³ã€‚ ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"67eec276bde55606eff45faa36dcba26","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-ics/pa/pa2/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/nju-ics/pa/pa2/","section":"notes","summary":"å®éªŒè¿›åº¦ æˆ‘å®Œæˆäº†æ‰€æœ‰çš„å¿…ç­”é¢˜ï¼Œå¹¶é’ˆå¯¹é€‰åšé¢˜å’Œæ€è€ƒé¢˜ç»™å‡ºäº†è‡ªå·±çš„æƒ³æ³•ã€‚\nå¿…ç­”é¢˜ ç¨‹åºæ˜¯ä¸ªçŠ¶æ€æœº ç‚¹å‡» è¿™é‡Œè·³è½¬åˆ°è§£ç­”ã€‚\nRTFSC ç‚¹å‡» è¿™é‡Œè·³è½¬åˆ°è§£ç­”ã€‚\nç¨‹åºå¦‚ä½•è¿è¡Œ ç‚¹å‡» è¿™é‡Œè·³è½¬åˆ°è§£ç­”ã€‚\nç¼–è¯‘ä¸é“¾æ¥ åœ¨nemu/src/engine/interpreter/rtl-basic.hä¸­, ä½ ä¼šçœ‹åˆ°ç”±static inlineå¼€å¤´å®šä¹‰çš„å„ç§RTLæŒ‡ä»¤å‡½æ•°. é€‰æ‹©å…¶ä¸­ä¸€ä¸ªå‡½æ•°, åˆ†åˆ«å°è¯•å»æ‰static, å»æ‰inlineæˆ–å»æ‰ä¸¤è€…, ç„¶åé‡æ–°è¿›è¡Œç¼–è¯‘, ä½ å¯èƒ½ä¼šçœ‹åˆ°å‘ç”Ÿé”™è¯¯. è¯·åˆ†åˆ«è§£é‡Šä¸ºä»€ä¹ˆè¿™äº›é”™è¯¯ä¼šå‘ç”Ÿ/ä¸å‘ç”Ÿ? ä½ æœ‰åŠæ³•è¯æ˜ä½ çš„æƒ³æ³•å—?\nå¦‚æœå»æ‰ inlineï¼Œç¼–è¯‘æ—¶ä¼šæŠ¥é”™ï¼šxxx defined but not usedã€‚è¿™æ˜¯å› ä¸º rtl.h æ–‡ä»¶ include äº† rtl-basic.","tags":null,"title":"PA2 - ç®€å•å¤æ‚çš„æœºå™¨: å†¯è¯ºä¾æ›¼è®¡ç®—æœºç³»ç»Ÿ","type":"docs"},{"authors":null,"categories":null,"content":"å®éªŒè¿›åº¦ æˆ‘å®Œæˆäº†æ‰€æœ‰çš„å¿…ç­”é¢˜ï¼Œå¹¶é’ˆå¯¹é€‰åšé¢˜å’Œæ€è€ƒé¢˜ç»™å‡ºäº†è‡ªå·±çš„æƒ³æ³•ã€‚\nå¿…ç­”é¢˜ ç†è§£ä¸Šä¸‹æ–‡ç»“æ„ä½“çš„å‰ä¸–ä»Šç”Ÿ ç‚¹å‡» è¿™é‡Œè·³è½¬åˆ°è§£ç­”ã€‚\nç†è§£ç©¿è¶Šæ—¶ç©ºçš„æ—…ç¨‹ ç‚¹å‡» è¿™é‡Œè·³è½¬åˆ°è§£ç­”ã€‚\nhelloç¨‹åºæ˜¯ä»€ä¹ˆ, å®ƒä»ä½•è€Œæ¥, è¦åˆ°å“ªé‡Œå» ç‚¹å‡» è¿™é‡Œè·³è½¬åˆ°è§£ç­”\nä»™å‰‘å¥‡ä¾ ä¼ ç©¶ç«Ÿå¦‚ä½•è¿è¡Œ è¿è¡Œä»™å‰‘å¥‡ä¾ ä¼ æ—¶ä¼šæ’­æ”¾å¯åŠ¨åŠ¨ç”», åŠ¨ç”»é‡Œä»™é¹¤åœ¨ç¾¤å±±ä¸­é£è¿‡. è¿™ä¸€åŠ¨ç”»æ˜¯é€šè¿‡navy-apps/apps/pal/repo/src/main.cä¸­çš„PAL_SplashScreen()å‡½æ•°æ’­æ”¾çš„. é˜…è¯»è¿™ä¸€å‡½æ•°, å¯ä»¥å¾—çŸ¥ä»™é¹¤çš„åƒç´ ä¿¡æ¯å­˜æ”¾åœ¨æ•°æ®æ–‡ä»¶mgo.mkfä¸­. è¯·å›ç­”ä»¥ä¸‹é—®é¢˜: åº“å‡½æ•°, libos, Nanos-lite, AM, NEMUæ˜¯å¦‚ä½•ç›¸äº’ååŠ©, æ¥å¸®åŠ©ä»™å‰‘å¥‡ä¾ ä¼ çš„ä»£ç ä»mgo.mkfæ–‡ä»¶ä¸­è¯»å‡ºä»™é¹¤çš„åƒç´ ä¿¡æ¯, å¹¶ä¸”æ›´æ–°åˆ°å±å¹•ä¸Š? æ¢ä¸€ç§PAçš„ç»å…¸é—®æ³•: è¿™ä¸ªè¿‡ç¨‹ç©¶ç«Ÿç»å†äº†äº›ä»€ä¹ˆ? (Hint: åˆç†ä½¿ç”¨å„ç§traceå·¥å…·, å¯ä»¥å¸®åŠ©ä½ æ›´å®¹æ˜“åœ°ç†è§£ä»™å‰‘å¥‡ä¾ ä¼ çš„è¡Œä¸º)\nç¨‹åºçš„è¡Œä¸ºæ€»ä½“ä¸Šæ˜¯è¯»å‡ºä»™é¹¤çš„åƒç´ ä¿¡æ¯ï¼Œç„¶åä¸æ–­æ›´æ–°åˆ°å±å¹•ä¸Šå¹¶ä¿®æ”¹ä»™é¹¤çš„ä½ç½®ã€‚åœ¨è½¯ä»¶å±‚é¢ï¼Œç¨‹åºä¼šä½¿ç”¨fseek å’Œ fread åº“å‡½æ•°æ¥å®šä½å’Œè¯»å–åƒç´ ä¿¡æ¯ï¼Œä½¿ç”¨SDLåº“å‡½æ•°æ¥è¾“å‡ºã€‚fseek å’Œ fread å‡½æ•°æœ€ç»ˆä¼šä½¿ç”¨lseek å’Œ read ç³»ç»Ÿè°ƒç”¨ï¼ŒSDLåº“å‡½æ•°åŸºäºæˆ‘ä»¬å¯¹ç³»ç»Ÿè°ƒç”¨è¿›ä¸€æ­¥å°è£…çš„NDLåº“å®ç°ï¼ŒNDLåº“ä¼šä½¿ç”¨ç³»ç»Ÿè°ƒç”¨ lseek å’Œ write æ¥å®ç°åƒç´ çš„å®šä½å’Œå†™å…¥ï¼ˆæ³¨æ„VGAè¢«æŠ½è±¡æˆäº†æ–‡ä»¶ï¼Œè¯»å†™åƒç´ ä¸éœ€è¦ä¸“é—¨çš„ I/O ç›¸å…³å‡½æ•°ã€‚ï¼‰lseek read å’Œ write æœ€ç»ˆä¼šè°ƒç”¨ libos ä¸­çš„ _read, _write å’Œ _lseekï¼Œä¼ é€’å¯¹åº”çš„ç³»ç»Ÿè°ƒç”¨å·å’Œç›¸å…³å‚æ•°ï¼Œä½¿ç”¨ ecall æŒ‡ä»¤è§¦å‘ä¸­æ–­ã€‚\nNanos-lite ä¸­ä¼šè¯†åˆ«ç³»ç»Ÿè°ƒç”¨çš„ç±»å‹ï¼Œå¹¶è°ƒç”¨ fs_read fs_write å’Œ fs_lseek ã€‚fs_lseek æ¯”è¾ƒç®€å•ï¼Œåªæ˜¯ä¿®æ”¹æ–‡ä»¶å½“å‰çš„ offsetï¼Œfs_read ä¼šä½¿ç”¨ /bin/pal å¯¹åº”çš„è¯»å‡½æ•° ramdisk_read æ¥ä»â€œç¡¬ç›˜â€ä¸­è¯»å–ä¿¡æ¯ï¼ˆäº‹å®ä¸Šå·²ç»è¢«åŠ è½½åˆ°å†…å­˜ä¸­ï¼‰ramdisk_read ä½¿ç”¨çš„æ˜¯ AM çš„å‡½æ•° memcpyï¼›fs_write ä¼šä½¿ç”¨ /dev/fb æ–‡ä»¶å¯¹åº”çš„å†™å‡½æ•° fb_write ã€‚fb_write ä¼šä½¿ç”¨ AM æä¾›çš„ VGA ç›¸å…³çš„æŠ½è±¡å¯„å­˜å™¨å’Œä¸€æ®µåƒç´ ç©ºé—´æ¥å†™å…¥ä¿¡æ¯ã€‚\nAM å’Œ nemu ä¹‹é—´æœ‰ä¸€å¥—å†…å­˜ I/O çš„æ˜ å°„è§„å®šï¼Œnemu ä¼šæ ¹æ®è¿™äº› I/O ç©ºé—´çš„ä¿¡æ¯è¿›è¡Œç¡¬ä»¶å±‚é¢çš„ä¿®æ”¹ã€‚memcpy æ˜¯ klib ä¸­çš„å‡½æ•°ï¼Œå¯ä»¥ç›´æ¥è®¿é—® nemu çš„å¤§æ•°ç»„ï¼ˆå†…å­˜ï¼‰ï¼Œå®ç°ä¿¡æ¯çš„è¯»å–ã€‚\nä»¥ä¸‹æ˜¯æˆ‘çš„è‡ªç”±æŠ¥å‘Šå†…å®¹ï¼Œæˆ‘åœ¨åšå®éªŒçš„è¿‡ç¨‹ä¸­è¯¦ç»†è®°å½•äº†è‡ªå·±é‡åˆ°çš„æ‰€æœ‰é—®é¢˜å’ŒæŸ¥é˜…çš„æ‰€æœ‰èµ„æ–™ã€‚è¿™äº›ç¬”è®°æŒ‰ç…§ç« èŠ‚æ’åˆ—ï¼Œæ¯ç« é€šå¸¸æœ‰ä¸¤ä¸ªéƒ¨åˆ†ï¼š\næ€è€ƒé¢˜ï¼šåŒ…å«ç¬”è€…é’ˆå¯¹æ€è€ƒé¢˜æŸ¥é˜…çš„èµ„æ–™å’Œæˆ‘å°è¯•ç»™å‡ºçš„ç­”æ¡ˆã€‚ è¡¥å……ï¼šè¿™é‡Œçš„å†…å®¹æ˜¯æ²¡æœ‰åœ¨è®²ä¹‰ä¸­æåŠçš„é—®é¢˜ï¼Œä»¥åŠè®²ä¹‰ä¸­å»ºè®®è‡ªå­¦çš„ä¸œè¥¿ã€‚ æœ€ç®€å•çš„æ“ä½œç³»ç»Ÿ æ€è€ƒé¢˜ [äºŒå‘¨ç›®] ä»€ä¹ˆæ˜¯æ“ä½œç³»ç»Ÿï¼Ÿ è¿™å¯æ˜¯ä¸ªå¤§é—®é¢˜, æˆ‘ä»¬ä¹Ÿé¼“åŠ±ä½ å­¦ä¹ å®Œæ“ä½œç³»ç»Ÿè¯¾ç¨‹ä¹‹åå†å›æ¥é‡æ–°å®¡è§†å®ƒ.\nç•™å‘ï¼ŒäºŒå‘¨ç›®å†å¡«ã€‚ç›®å‰ç¬”è€…è®¤ä¸ºæ“ä½œç³»ç»Ÿæ˜¯ç›´æ¥ä¸ç¡¬ä»¶æ¥è§¦çš„ä¸€ä¸ªç¨‹åºï¼Œå®ƒå°†ç¡¬ä»¶æ”¯æŒçš„åŠŸèƒ½å°è£…æˆç³»ç»Ÿè°ƒç”¨ä½œä¸ºæœåŠ¡æä¾›ç»™ä¸Šå±‚åº”ç”¨ç¨‹åºï¼Œå¹¶è´Ÿè´£ä¸Šå±‚åº”ç”¨ç¨‹åºä¹‹é—´çš„è¿è¡Œè°ƒåº¦ã€‚\nè¡¥å…… åˆæ¬¡è¿è¡Œ nanos-lite æŠ¥é”™ åˆæ¬¡è¿è¡Œ nanos-lite æ˜¾ç¤ºç¨‹åºè®¿é—®äº†éæ³•çš„åœ°å€ï¼Œç»è¿‡å®šä½åå‘ç° AM ä¸­çš„ printf æ²¡æœ‰å®ç° %p æ‰“å°æŒ‡é’ˆçš„åŠŸèƒ½ï¼Œè§¦å‘äº† UBã€‚è¿™ä¸ºæˆ‘ä»¬æ•²å“äº†ç¼–å†™å¥½çš„ä»£ç çš„è­¦é’Ÿï¼šå¦‚æœå‡½æ•°çš„å‚æ•°è¾“å…¥å‡ºç°äº†â€œæœªå®šä¹‰â€œçš„è¡Œä¸ºï¼Œå‡½æ•°åº”è¯¥è¾“å‡ºä¸€äº›æç¤ºä¿¡æ¯ï¼Œä»è€Œå¿«é€Ÿå®šä½é—®é¢˜ã€‚ï¼ˆä¾‹å¦‚æ­¤å¤„å°±åº”è¯¥è®© printf æŠ¥é”™ï¼Œè€Œä¸æ˜¯é€šè¿‡éæ³•çš„åœ°å€è®¿é—®å»å¯»æ‰¾ faultï¼‰ã€‚\nç©¿è¶Šæ—¶ç©ºçš„æ—…ç¨‹ å¿…ç­”é¢˜ ç†è§£ä¸Šä¸‹æ–‡ç»“æ„ä½“çš„å‰ä¸–ä»Šç”Ÿ ä½ ä¼šåœ¨__am_irq_handle()ä¸­çœ‹åˆ°æœ‰ä¸€ä¸ªä¸Šä¸‹æ–‡ç»“æ„æŒ‡é’ˆc, cæŒ‡å‘çš„ä¸Šä¸‹æ–‡ç»“æ„ç©¶ç«Ÿåœ¨å“ªé‡Œ? è¿™ä¸ªä¸Šä¸‹æ–‡ç»“æ„åˆæ˜¯æ€ä¹ˆæ¥çš„? å…·ä½“åœ°, è¿™ä¸ªä¸Šä¸‹æ–‡ç»“æ„æœ‰å¾ˆå¤šæˆå‘˜, æ¯ä¸€ä¸ªæˆå‘˜ç©¶ç«Ÿåœ¨å“ªé‡Œèµ‹å€¼çš„? $ISA-nemu.h, trap.S, ä¸Šè¿°è®²ä¹‰æ–‡å­—, ä»¥åŠä½ åˆšåˆšåœ¨NEMUä¸­å®ç°çš„æ–°æŒ‡ä»¤, è¿™å››éƒ¨åˆ†å†…å®¹åˆæœ‰ä»€ä¹ˆè”ç³»?\nå¦‚æœä½ ä¸æ˜¯è„‘è¢‹è¶³å¤Ÿçµå…‰, è¿˜æ˜¯ä¸è¦çœ¼ççåœ°ç›¯ç€ä»£ç çœ‹äº†, ç†è§£ç¨‹åºçš„ç»†èŠ‚è¡Œä¸ºè¿˜æ˜¯è¦ä»çŠ¶æ€æœºè§†è§’å…¥æ‰‹.\ntrap.S æ–‡ä»¶çš„å‰åŠéƒ¨åˆ†è´Ÿè´£ç»„ç»‡ä¸Šä¸‹æ–‡ç»“æ„ä½“ã€‚è¿™ä¸ªä¸Šä¸‹æ–‡ç»“æ„ä½“ä½œä¸ºå‡½æ•°çš„å‚æ•°ï¼Œä¿å­˜åœ¨æ ˆä¸Šã€‚trap.S çš„è¡Œä¸ºå’Œæ­£å¸¸çš„ C ç¨‹åºè°ƒç”¨å‡½æ•°å‰å‡†å¤‡å‚æ•°çš„è¿‡ç¨‹æ˜¯ä¸€æ ·çš„ã€‚ç¬¬ä¸€å¥\naddi sp, sp, -CONTEXT_SIZE ä¸º Context ç»“æ„ä½“å¼€è¾Ÿäº†ç©ºé—´ã€‚æ¥ä¸‹æ¥çš„\nMAP(REGS, PUSH) åˆ©ç”¨äº†ä¸€ç‚¹å…ƒç¼–ç¨‹æŠ€å·§ï¼Œå…¶å«ä¹‰æ˜¯å°†é€šç”¨å¯„å­˜å™¨çš„å€¼æŒ‰é¡ºåºä¸Šæ ˆã€‚\næ¥ä¸‹æ¥è¿˜è¦å°†ç‰¹æƒå¯„å­˜å™¨çš„å€¼ä¸Šæ ˆã€‚ç‰¹æƒå¯„å­˜å™¨ä¸èƒ½ç”¨ store æŒ‡ä»¤ç›´æ¥ä¸Šæ ˆï¼Œå› æ­¤è¦å…ˆå°†å…¶å€¼ä¿å­˜åˆ°é€šç”¨å¯„å­˜å™¨ä¸­å†ä¸Šæ ˆã€‚ä»£ç æ˜¯å¦‚ä¸‹6è¡Œï¼š\ncsrr t0, mcause csrr t1, mstatus csrr t2, mepc sd t0, OFFSET_CAUSE(sp) sd t1, OFFSET_STATUS(sp) sd t2, OFFSET_EPC(sp) åœ¨è¿›å…¥å¤„ç†å‡½æ•°ä¹‹å‰ï¼Œæœ€åä¸€å¥è¯æ˜¯\nmv a0, sp æ ¹æ® RISCV çš„ calling conventionï¼Œa0 å¯„å­˜å™¨ä¿å­˜äº†ç¬¬ä¸€ä¸ªå‚æ•°çš„å€¼ã€‚æˆ‘ä»¬åé¢è¦è°ƒç”¨çš„å‡½æ•° __am_irq_handle çš„å‚æ•°æ˜¯ Context *cï¼Œå› æ­¤å°†å½“å‰çš„ sp å€¼ä¼ è¿› a0ï¼Œè¿›å…¥å‡½æ•°åæŒ‡é’ˆ c å°±æŒ‡å‘äº†åœ¨æ ˆä¸Šä¿å­˜çš„ä¸Šä¸‹æ–‡ç»“æ„ä½“çš„é¦–åœ°å€ã€‚\nè¿™æ•´ä¸ªè¿‡ç¨‹å……åˆ†åˆ©ç”¨äº† C å’Œæ±‡ç¼–è¯­è¨€çš„ç´§å¯†è”ç³»ã€‚\nç†è§£ç©¿è¶Šæ—¶ç©ºçš„æ—…ç¨‹ ä»Nanos-liteè°ƒç”¨yield()å¼€å§‹, åˆ°ä»yield()è¿”å›çš„æœŸé—´, è¿™ä¸€è¶Ÿæ—…ç¨‹å…·ä½“ç»å†äº†ä»€ä¹ˆ? è½¯(AM, Nanos-lite)ç¡¬(NEMU)ä»¶æ˜¯å¦‚ä½•ç›¸äº’ååŠ©æ¥å®Œæˆè¿™è¶Ÿæ—…ç¨‹çš„? ä½ éœ€è¦è§£é‡Šè¿™ä¸€è¿‡ç¨‹ä¸­çš„æ¯ä¸€å¤„ç»†èŠ‚, åŒ…æ‹¬æ¶‰åŠçš„æ¯ä¸€è¡Œæ±‡ç¼–ä»£ç /Cä»£ç çš„è¡Œä¸º, å°¤å…¶æ˜¯ä¸€äº›æ¯”è¾ƒå…³é”®çš„æŒ‡ä»¤/å˜é‡. äº‹å®ä¸Š, ä¸Šæ–‡çš„å¿…ç­”é¢˜\u0026quot;ç†è§£ä¸Šä¸‹æ–‡ç»“æ„ä½“çš„å‰ä¸–ä»Šç”Ÿ\u0026quot;å·²ç»æ¶µç›–äº†è¿™è¶Ÿæ—…ç¨‹ä¸­çš„ä¸€éƒ¨åˆ†, ä½ å¯ä»¥æŠŠå®ƒçš„å›ç­”åŒ…å«è¿›æ¥.\nåˆ«è¢«\u0026quot;æ¯ä¸€è¡Œä»£ç \u0026quot;å“åˆ°äº†, è¿™ä¸ªè¿‡ç¨‹ä¹Ÿå°±å¤§çº¦50è¡Œä»£ç , è¦å®Œå…¨ç†è§£é€å½»å¹¶ä¸æ˜¯ä¸å¯èƒ½çš„. æˆ‘ä»¬ä¹‹æ‰€ä»¥è®¾ç½®è¿™é“å¿…ç­”é¢˜, æ˜¯ä¸ºäº†å¼ºè¿«ä½ ç†è§£æ¸…æ¥šè¿™ä¸ªè¿‡ç¨‹ä¸­çš„æ¯ä¸€å¤„ç»†èŠ‚. è¿™ä¸€ç†è§£æ˜¯å¦‚æ­¤é‡è¦, ä»¥è‡³äºå¦‚æœä½ ç¼ºå°‘å®ƒ, æ¥ä¸‹æ¥ä½ é¢å¯¹bugå‡ ä¹æ˜¯æŸæ‰‹æ— ç­–.\nNanos-lite è°ƒç”¨ yield() ä¹‹åï¼Œæ‰§è¡Œäº†ä¸¤æ¡æ±‡ç¼–æŒ‡ä»¤ï¼ˆè¿™ä¸¤æ¡æ±‡ç¼–æŒ‡ä»¤æ˜¯ç”¨å†…è”æ±‡ç¼–çš„æ–¹å¼ç›´æ¥åµŒå…¥çš„ï¼‰ï¼š\nasm volatile(\u0026quot;li a7, -1; ecall\u0026quot;); å…¶ä¸­ç¬¬ä¸€æ¡æŒ‡ä»¤å‘ a7 å¯„å­˜å™¨å†™å…¥ -1ï¼Œa7 å¯„å­˜å™¨æ˜¯çº¦å®šä¸­ä¼ é€’ä¸­æ–­ç±»å‹çš„å¯„å­˜å™¨ã€‚ç¬¬äºŒæ¡æŒ‡ä»¤ ecall åˆ™æ˜¯â€œä¸­æ–­â€æŒ‡ä»¤ã€‚\nåœ¨ç¡¬ä»¶å±‚é¢ï¼Œnemu å¯¹ ecall æŒ‡ä»¤è¯‘ç åï¼Œæ‰§è¡Œæ—¶ä¼šè°ƒç”¨ isa_raise_intr å‡½æ•°ï¼Œè¯¥å‡½æ•°å°† a7 å¯„å­˜å™¨ä¼ é€’çš„äº‹ä»¶ç±»å‹å­˜æ”¾åˆ° mcause å¯„å­˜å™¨ä¸­ï¼Œå‘ mepc å¯„å­˜å™¨å†™å…¥å½“å‰çš„ pcï¼Œç„¶åå°† pc è·³è½¬åˆ° mtvec å¯„å­˜å™¨é¢„å…ˆå­˜å¥½çš„ä¸€ä¸ªåœ°å€å¼€å§‹æ‰§è¡Œã€‚mtvec ä¸­çš„åœ°å€æ˜¯å‡½æ•° __am_asm_trap çš„åœ°å€ï¼Œåœ¨ cte_init ä¸­çš„\nasm volatile(\u0026quot;csrw mtvec, %0\u0026quot; : : \u0026quot;r\u0026quot;(__am_asm_trap)); å®Œæˆäº† mtvec å†…å®¹çš„åˆå§‹åŒ–ã€‚\n__am_asm_trap å‡½æ•°åœ¨ trap.S ä¸­å®šä¹‰ï¼Œæ˜¯ç”¨å†…è”æ±‡ç¼–å†™çš„ã€‚è¯¥å‡½æ•°é¦–å…ˆç»„ç»‡ä¸Šä¸‹æ–‡ç»“æ„ä½“ï¼Œç»„ç»‡æ–¹å¼è§ä¸Šä¸€é“å¿…ç­”é¢˜ã€‚ç„¶åè·³è½¬è¿›å…¥å¤„ç†å‡½æ•° __am_irq_handleã€‚å‡½æ•° __am_irq_handle ä¼šæ ¹æ®ä¸Šä¸‹æ–‡ç»“æ„ä½“çš„å†…å®¹æ‰“åŒ…å‡ºä¸€ä¸ªäº‹ä»¶ç»“æ„ä½“ evã€‚æ ¹æ®ä¸Šä¸‹æ–‡ç»“æ„ä½“ä¸­çš„ mcause å¯„å­˜å™¨çš„å€¼ï¼Œå¯ä»¥è¯†åˆ«äº‹ä»¶çš„ç±»å‹ï¼Œå¦‚è‡ªé™·äº‹ä»¶çš„äº‹ä»¶å·ä¸º -1ã€‚æ‰“åŒ…å®Œäº‹ä»¶ç»“æ„ä½“åï¼Œ__am_irq_handle ä¼šå°†ä¸Šä¸‹æ–‡ç»“æ„ä½“å’Œäº‹ä»¶ç»“æ„ä½“ä¸€èµ·ä¼ ç»™å¤„ç†å‡½æ•°ã€‚è¿™ä¸ªå¤„ç†å‡½æ•°æ˜¯åœ¨ cte_init ä¸­ä¼ è¿›æ¥çš„ do_eventã€‚\ndo_event å‡½æ•°æ£€æŸ¥äº‹ä»¶ç»“æ„ä½“ä¸­çš„äº‹ä»¶ç±»å‹ï¼Œå½“çœ‹åˆ°æ˜¯ EVENT_YIELD æ—¶ï¼Œå®ƒåˆ¤å®šè¿™ä¸ªä¸­æ–­æ²¡æœ‰å¿…è¦é‡å¤ï¼Œå› æ­¤ç»™ mepc çš„å€¼ +4ï¼Œè¿™ä¸ª +4 æ“ä½œç›´æ¥ä¿®æ”¹äº†ä¸Šä¸‹æ–‡ç»“æ„ä½“ä¸­çš„ mepc çš„ä¿å­˜å€¼ã€‚\nè¿™æ—¶è¿›å…¥ trap.S çš„ååŠéƒ¨åˆ†ï¼ŒååŠéƒ¨åˆ†å°†æ ˆä¸Šä¿å­˜çš„å¯„å­˜å™¨å†…å®¹æ¢å¤ï¼Œç„¶åè°ƒç”¨ mret æŒ‡ä»¤ã€‚åœ¨ç¡¬ä»¶å±‚é¢ï¼Œnemu è¯†åˆ«å‡º mret æŒ‡ä»¤åï¼Œç›´æ¥å°† pc æ¢å¤ä¸º mepc çš„å€¼ã€‚è‡³æ­¤ï¼Œæ—¶ç©ºç©¿è¶Šçš„æ—…ç¨‹ç»“æŸã€‚\næ€è€ƒé¢˜ [äºŒå‘¨ç›®] ç‰¹æ®Šçš„åŸå› ï¼Ÿ è¿™äº›ç¨‹åºçŠ¶æ€(x86çš„eflags, cs, eip; mips32çš„epc, status, cause; riscv32çš„mepc, mstatus, mcause)å¿…é¡»ç”±ç¡¬ä»¶æ¥ä¿å­˜å—? èƒ½å¦é€šè¿‡è½¯ä»¶æ¥ä¿å­˜? ä¸ºä»€ä¹ˆ?\nç•™å‘ï¼ŒäºŒå‘¨ç›®å†åšã€‚\nå¼‚å¸¸å·çš„ä¿å­˜ x86é€šè¿‡è½¯ä»¶æ¥ä¿å­˜å¼‚å¸¸å·, æ²¡æœ‰ç±»ä¼¼causeçš„å¯„å­˜å™¨. mips32å’Œriscv32ä¹Ÿå¯ä»¥è¿™æ ·å—? ä¸ºä»€ä¹ˆ?\nx86çš„å¯„å­˜å™¨æ¯”è¾ƒå¤æ‚ï¼Œæœ‰ç±»ä¼¼äºEFLAGSç­‰å¤§é‡çš„åŠŸèƒ½ä¸“ä¸€çš„å¯„å­˜å™¨ï¼Œè¿™äº›å¯„å­˜å™¨çš„å€¼ä¹Ÿæ˜¯å¯ä»¥ä¸Šæ ˆçš„ã€‚è€Œ riscv32 ä¸­åªæœ‰é€šç”¨å¯„å­˜å™¨çš„å€¼å¯ä»¥ä¸Šæ ˆï¼Œå¦‚æœä¸€å®šè¦ç”¨è½¯ä»¶æ¥ä¿å­˜å¼‚å¸¸å·çš„è¯ï¼Œåˆ™å¿…é¡»ç¡¬ä»¶å’Œè½¯ä»¶çº¦å®šå¥½ä½¿ç”¨ä¸€ä¸ªé€šç”¨å¯„å­˜å™¨æ¥ä¸“é—¨ä¿å­˜å¼‚å¸¸å·ï¼Œè¿™åœ¨æœ¬è´¨ä¸Šå·²ç»å’Œcauseå¯„å­˜å™¨æ²¡æœ‰åŒºåˆ«äº†ã€‚\nå¯¹æ¯”å¼‚å¸¸å¤„ç†ä¸å‡½æ•°è°ƒç”¨ æˆ‘ä»¬çŸ¥é“è¿›è¡Œå‡½æ•°è°ƒç”¨çš„æ—¶å€™ä¹Ÿéœ€è¦ä¿å­˜è°ƒç”¨è€…çš„çŠ¶æ€: è¿”å›åœ°å€, ä»¥åŠcalling conventionä¸­éœ€è¦è°ƒç”¨è€…ä¿å­˜çš„å¯„å­˜å™¨. è€ŒCTEåœ¨ä¿å­˜ä¸Šä¸‹æ–‡çš„æ—¶å€™å´è¦ä¿å­˜æ›´å¤šçš„ä¿¡æ¯. å°è¯•å¯¹æ¯”å®ƒä»¬, å¹¶æ€è€ƒä¸¤è€…ä¿å­˜ä¿¡æ¯ä¸åŒæ˜¯ä»€ä¹ˆåŸå› é€ æˆçš„.\nå¼‚å¸¸å¤„ç†æ¯”å‡½æ•°è°ƒç”¨æ›´å¤æ‚ä¸€äº›ï¼šå‡½æ•°è°ƒç”¨èƒ½ä¿è¯ callee çš„æ“ä½œæ»¡è¶³ calling conventionï¼Œä½†ä¸­æ–­ä¹‹åä¼šæ¶‰åŠæ›´å¤æ‚çš„æ“ä½œï¼Œæ¯”å¦‚ç‰¹æƒçº§åˆ‡æ¢ç­‰ï¼Œè¿™ä¸ªè¿‡ç¨‹ä¸­æ¯ä¸ªå¯„å­˜å™¨çš„å€¼éƒ½å¯èƒ½ä¼šè¢«æ”¹å†™ã€‚ä¸ºäº†ä¿è¯æ¢å¤ä¸Šä¸‹æ–‡æ—¶ç¨‹åºçš„çŠ¶æ€æœºä¸ä¼šå˜ï¼Œæˆ‘ä»¬éœ€è¦ä¿å­˜æ›´å¤šçš„ä¿¡æ¯ã€‚\nè¯¡å¼‚çš„ x86 ä»£ç  x86çš„trap.Sä¸­æœ‰ä¸€è¡Œpushl %espçš„ä»£ç , ä¹çœ‹ä¹‹ä¸‹å…¶è¡Œä¸ºååˆ†è¯¡å¼‚. ä½ èƒ½ç»“åˆå‰åçš„ä»£ç ç†è§£å®ƒçš„è¡Œä¸ºå—? Hint: ç¨‹åºæ˜¯ä¸ªçŠ¶æ€æœº.\nè¿™å¥è¯å’Œ riscv çš„ trap.S ä¸­çš„ mv a0, sp æ²¡æœ‰æœ¬è´¨åŒºåˆ«ï¼Œéƒ½æ˜¯åœ¨ä¸ºå³å°†æ‰§è¡Œçš„ __am_irq_handle å‡†å¤‡å‚æ•°ã€‚è¿™é‡Œçš„ esp çš„å†…å®¹å°±æ˜¯ä¸Šä¸‹æ–‡ç»“æ„ä½“çš„åœ°å€ã€‚\nä»åŠ 4æ“ä½œçœ‹CISCå’ŒRISC äº‹å®ä¸Š, è‡ªé™·åªæ˜¯å…¶ä¸­ä¸€ç§å¼‚å¸¸ç±»å‹. æœ‰ä¸€ç§æ•…éšœç±»å¼‚å¸¸, å®ƒä»¬è¿”å›çš„PCå’Œè§¦å‘å¼‚å¸¸çš„PCæ˜¯åŒä¸€ä¸ª, ä¾‹å¦‚ç¼ºé¡µå¼‚å¸¸, åœ¨ç³»ç»Ÿå°†æ•…éšœæ’é™¤å, å°†ä¼šé‡æ–°æ‰§è¡Œç›¸åŒçš„æŒ‡ä»¤è¿›è¡Œé‡è¯•, å› æ­¤å¼‚å¸¸è¿”å›çš„PCæ— éœ€åŠ 4. æ‰€ä»¥æ ¹æ®å¼‚å¸¸ç±»å‹çš„ä¸åŒ, æœ‰æ—¶å€™éœ€è¦åŠ 4, æœ‰æ—¶å€™åˆ™ä¸éœ€è¦åŠ .\nè¿™æ—¶å€™, æˆ‘ä»¬å°±å¯ä»¥è€ƒè™‘è¿™æ ·çš„ä¸€ä¸ªé—®é¢˜äº†: å†³å®šè¦ä¸è¦åŠ 4çš„, æ˜¯ç¡¬ä»¶è¿˜æ˜¯è½¯ä»¶å‘¢? CISCå’ŒRISCçš„åšæ³•æ­£å¥½ç›¸å, CISCéƒ½äº¤ç»™ç¡¬ä»¶æ¥åš, è€ŒRISCåˆ™äº¤ç»™è½¯ä»¶æ¥åš. æ€è€ƒä¸€ä¸‹, è¿™ä¸¤ç§æ–¹æ¡ˆå„æœ‰ä»€ä¹ˆå–èˆ? ä½ è®¤ä¸ºå“ªç§æ›´åˆç†å‘¢? ä¸ºä»€ä¹ˆ?\næˆ‘è®¤ä¸ºä»æŠ½è±¡å±‚çš„è§’åº¦æ¥çœ‹ç”±è½¯ä»¶å¤„ç†æ˜¯å¦+4æ›´åŠ åˆç†ï¼Œå› ä¸ºæ˜¯å¦éœ€è¦+4å–å†³äºä¸­æ–­çš„ç±»å‹ï¼Œè€Œåˆ¤æ–­ä¸­æ–­ç±»å‹çš„æ˜¯æ“ä½œç³»ç»Ÿã€‚å› æ­¤è½¯ä»¶åˆ¤æ–­ä¸­æ–­ç±»å‹åç”±è½¯ä»¶å†³å®šè¿™æ¬¡ä¸­æ–­æ˜¯å¦éœ€è¦å†æ¬¡æ‰§è¡Œã€‚\nmips32å»¶è¿Ÿæ§½å’Œå¼‚å¸¸ æˆ‘ä»¬åœ¨PA2ä¸­æåˆ°, æ ‡å‡†çš„mips32å¤„ç†å™¨é‡‡ç”¨äº†åˆ†æ”¯å»¶è¿Ÿæ§½æŠ€æœ¯. æ€è€ƒä¸€ä¸‹, å¦‚æœæ ‡å‡†çš„mips32å¤„ç†å™¨åœ¨æ‰§è¡Œå»¶è¿Ÿæ§½æŒ‡ä»¤çš„æ—¶å€™è§¦å‘äº†å¼‚å¸¸, ä»å¼‚å¸¸è¿”å›ä¹‹åå¯èƒ½ä¼šé€ æˆä»€ä¹ˆé—®é¢˜? è¯¥å¦‚ä½•è§£å†³? å°è¯•RTFMå¯¹æ¯”ä½ çš„è§£å†³æ–¹æ¡ˆ.\nmips32å¼•å…¥äº†åˆ†æ”¯å»¶è¿Ÿæ§½ï¼Œæ‰€ä»¥åœ¨é‡åˆ°è·³è½¬æŒ‡ä»¤ä¸”ç¡®å®å‘ç”Ÿè·³è½¬æ—¶çš„æŒ‡ä»¤æ‰§è¡Œæµä¸ºï¼š\nè·³è½¬æŒ‡ä»¤ --\u0026gt; åˆ†æ”¯å»¶è¿Ÿæ§½ --\u0026gt; è·³è½¬çš„ç›®æ ‡æŒ‡ä»¤ å¦‚æœåœ¨åˆ†æ”¯å»¶è¿Ÿæ§½æŒ‡ä»¤å¤„å‡ºç°äº†å¼‚å¸¸é™·å…¥å†…æ ¸æ€å¤„ç†ï¼Œå¤„ç†ç»“æŸä¹‹åæˆ‘ä»¬ä¸èƒ½æŒ‰ç…§æƒ¯ä¾‹å›åˆ°åˆ†æ”¯å»¶è¿Ÿæ§½çš„ snpc æ‰§è¡Œã€‚å› ä¸ºåœ¨æµæ°´çº¿ CPU ä¸­ï¼Œç»è¿‡äº†å¼‚å¸¸å¤„ç†ç¨‹åºä¹‹åï¼Œè·³è½¬æŒ‡ä»¤æ—©å°±ä¸åœ¨ CPU ä¸­äº†ï¼Œå¦‚æœè¿›å…¥ snpc åˆ™æ— æ³•è·³è½¬ã€‚æ‰€ä»¥æˆ‘ä»¬åº”è¯¥å°† pc æ‹¨å›åˆ°è·³è½¬æŒ‡ä»¤ï¼Œå°†è·³è½¬æŒ‡ä»¤å†æ¬¡é€å…¥æµæ°´çº¿ï¼Œç„¶åæŒ‰ç…§é¡ºåºå†åšä¸€æ¬¡åˆ†æ”¯å»¶è¿Ÿæ§½ï¼Œè¿™ä¸€æ¬¡åˆ†æ”¯å»¶è¿Ÿæ§½ä¸ä¸€å®šå†ä¼šè§¦å‘å¼‚å¸¸ï¼ˆæ¯”å¦‚å‰ä¸€æ¬¡å·²ç»å¤„ç†äº†ç¼ºé¡µï¼‰ï¼Œç„¶åå°±èƒ½æ­£ç¡®è·³è½¬åˆ°ç›®æ ‡æŒ‡ä»¤ç»§ç»­æ‰§è¡Œã€‚\nè¡¥å…… å…³äº ecall æŒ‡ä»¤ ecall æŒ‡ä»¤æ²¡æœ‰ä»»ä½•å‚æ•°ï¼Œé‚£ä¹ˆå¦‚ä½•ç›´åˆ°åº”è¯¥å‘ mcause å¯„å­˜å™¨é‡Œå†™å…¥å“ªç§ä¸­æ–­åŸå› å‘¢ï¼ŸRTFSC æˆ–è€…æŸ¥çœ‹ riscv-linux çš„çº¦å®šå¯ä»¥çœ‹åˆ° ecall æŒ‡ä»¤åˆ©ç”¨ a7 å¯„å­˜å™¨æ¥ä¿å­˜è°ƒç”¨å·ã€‚å› æ­¤å°† a7 çš„å†…å®¹å†™å…¥ mcause å³å¯ã€‚\nå…³äºæ¢å¤ä¸Šä¸‹æ–‡ä¸­çš„è½¯ä»¶ +4 ç¡¬ä»¶æ¢å¤ä¸Šä¸‹æ–‡çš„æ–¹æ³•æ˜¯åœ¨ mret æŒ‡ä»¤ä¸­å°† dnpc è®¾ç½®ä¸º mpec+4ï¼Œä½†æŒ‰ç…§è®²ä¹‰ä¸­æ‰€å†™ï¼Œriscv åº”è¯¥ç”¨è½¯ä»¶æ¢å¤ä¸Šä¸‹æ–‡ã€‚ç¬”è€…åˆšå¼€å§‹å°è¯•äº†å†™å…¥ä¸€æ®µå†…è”æ±‡ç¼–çš„ä»£ç ï¼Œåˆ©ç”¨ csrr csrw æŒ‡ä»¤ç›´æ¥ä¿®æ”¹ mepc çš„å€¼ï¼Œä½†å¤±è´¥äº†ã€‚ç»è¿‡åˆ†æå‘ç°å¤„ç†å®Œä¸­æ–­ä¹‹å trap.S ä¼šæ ¹æ®ä¸Šä¸‹æ–‡ç»“æ„ä½“ c çš„å†…å®¹æ¥æ¢å¤ä¸Šä¸‹æ–‡ï¼Œæ‰€ä»¥å³ä½¿ä¸­é—´ä¿®æ”¹äº† mepc çš„å€¼ï¼Œæœ€åä»ç„¶ä¼šè¢«æ¢å¤ä¸ºæ²¡æœ‰ +4 çš„åŸå§‹å€¼ã€‚å› æ­¤è½¯ä»¶+4çš„æ–¹æ³•éå¸¸ç®€å•ï¼šåœ¨ do_event ä¸­çš„ EVENT_YIELD éƒ¨åˆ†ï¼Œå°† c-\u0026gt;mepc ç›´æ¥ +4 å³å¯ã€‚\nç”¨æˆ·ç¨‹åºå’Œç³»ç»Ÿè°ƒç”¨ å¿…ç­”é¢˜ helloç¨‹åºæ˜¯ä»€ä¹ˆ, å®ƒä»ä½•è€Œæ¥, è¦åˆ°å“ªé‡Œå» æˆ‘ä»¬çŸ¥é“navy-apps/tests/hello/hello.cåªæ˜¯ä¸€ä¸ªCæºæ–‡ä»¶, å®ƒä¼šè¢«ç¼–è¯‘é“¾æ¥æˆä¸€ä¸ªELFæ–‡ä»¶. é‚£ä¹ˆ, helloç¨‹åºä¸€å¼€å§‹åœ¨å“ªé‡Œ? å®ƒæ˜¯æ€ä¹ˆå‡ºç°å†…å­˜ä¸­çš„? ä¸ºä»€ä¹ˆä¼šå‡ºç°åœ¨ç›®å‰çš„å†…å­˜ä½ç½®? å®ƒçš„ç¬¬ä¸€æ¡æŒ‡ä»¤åœ¨å“ªé‡Œ? ç©¶ç«Ÿæ˜¯æ€ä¹ˆæ‰§è¡Œåˆ°å®ƒçš„ç¬¬ä¸€æ¡æŒ‡ä»¤çš„? helloç¨‹åºåœ¨ä¸æ–­åœ°æ‰“å°å­—ç¬¦ä¸², æ¯ä¸€ä¸ªå­—ç¬¦åˆæ˜¯ç»å†äº†ä»€ä¹ˆæ‰ä¼šæœ€ç»ˆå‡ºç°åœ¨ç»ˆç«¯ä¸Š?\nç”±äºæ­¤æ—¶è¿˜æ²¡æœ‰å®ç°æ–‡ä»¶ç³»ç»Ÿï¼Œæ‰€ä»¥ ramdisk.img ä¸­åªæœ‰ hello ç¨‹åºã€‚nanos-lite ä¸­çš„å†…è”æ±‡ç¼–ç¨‹åº resources.S å°† ramdisk.img çš„å†…å®¹åŠ è½½åˆ°äº†å†…å­˜ä¸­ã€‚resources.S çš„å†…å®¹å¦‚ä¸‹ï¼š\n.section .data .global ramdisk_start, ramdisk_end ramdisk_start: .incbin \u0026quot;build/ramdisk.img\u0026quot; ramdisk_end: .section .rodata .globl logo logo: .incbin \u0026quot;resources/logo.txt\u0026quot; .byte 0 ä¸€ä¸ªæœ‰æ„æ€çš„ç»†èŠ‚æ˜¯ resources.S ä¸­å®šä¹‰äº†å…¨å±€å˜é‡ ramdisk_start å’Œ ramdisk_end ï¼Œè¿™æ ·åœ¨ C ç¨‹åºä¸­æˆ‘ä»¬å¯ä»¥å¾ˆæ–¹ä¾¿åœ°å®šä½ ramdisk.img è¢«åŠ è½½åˆ°äº†å†…å­˜ä¸­çš„å“ªä¸ªä½ç½®ã€‚ä»ç¡¬ä»¶å±‚é¢æ¥è¯´ï¼Œç”±äºç°åœ¨è¿˜æ²¡æœ‰å¼•å…¥è™šæ‹Ÿå†…å­˜ï¼Œramdisk.img è¢«æ”¾åœ¨äº†åœ°å€ 0x83000000 å¤„ï¼ŒMakefile çš„ LNK_ADDR å®ç°äº†è¿™ä¸€ç‚¹ã€‚\nåœ¨è°ƒç”¨äº† naive_uload å‡½æ•°åï¼Œç³»ç»Ÿä¼šè¿›å…¥ hello ç¨‹åºçš„æ±‡ç¼–ä»£ç ï¼ˆelfæ–‡ä»¶ä¸­æœ‰å…¥å£åœ°å€ï¼‰ï¼Œhelloç¨‹åºè¾“å‡ºå­—ç¬¦çš„æ—¶å€™ï¼Œä¼šä½¿ç”¨ write ç³»ç»Ÿè°ƒç”¨ï¼ˆç›´æ¥ä½¿ç”¨ write æˆ–è€…é€šè¿‡ printf åº“å‡½æ•°ä½¿ç”¨ writeï¼‰ï¼Œnanos-lite ä¸­çš„ fs_write å‡½æ•°ä¼šä½¿ç”¨ AM æä¾›çš„æ¥å£æ¥è¾“å‡ºï¼ˆåœ¨å®ç°äº†æ–‡ä»¶ç³»ç»Ÿä¹‹åï¼Œfs_write ä¼šç›´æ¥ä½¿ç”¨ stdout æ–‡ä»¶å¯¹åº”çš„å†™å‡½æ•° serial_writeï¼‰ã€‚\næ€è€ƒé¢˜ å †å’Œæ ˆåœ¨å“ªé‡Œï¼Ÿ æˆ‘ä»¬æåˆ°äº†ä»£ç å’Œæ•°æ®éƒ½åœ¨å¯æ‰§è¡Œæ–‡ä»¶é‡Œé¢, ä½†å´æ²¡æœ‰æåˆ°å †(heap)å’Œæ ˆ(stack). ä¸ºä»€ä¹ˆå †å’Œæ ˆçš„å†…å®¹æ²¡æœ‰æ”¾å…¥å¯æ‰§è¡Œæ–‡ä»¶é‡Œé¢? é‚£ç¨‹åºè¿è¡Œæ—¶åˆ»ç”¨åˆ°çš„å †å’Œæ ˆåˆæ˜¯æ€ä¹ˆæ¥çš„? AMçš„ä»£ç æ˜¯å¦èƒ½ç»™ä½ å¸¦æ¥ä¸€äº›å¯å‘?\nAM çš„ä½œç”¨å°±æ˜¯åœ¨ç¡¬ä»¶å±‚çš„åŸºç¡€ä¸Šè¿›è¡Œäº†ä¸€å®šç¨‹åº¦çš„æŠ½è±¡ï¼Œæä¾›äº†è¿è¡Œæ—¶ç¯å¢ƒã€‚å †å’Œæ ˆæ˜¯ä¸€ç§å¿…è¦çš„è¿è¡Œæ—¶ç¯å¢ƒï¼ˆäº‹å®ä¸Šå°±æ˜¯ nemu å†…å­˜å¤§æ•°ç»„çš„ä¸€éƒ¨åˆ†ï¼‰ï¼Œå› æ­¤å¯æ‰§è¡Œæ–‡ä»¶ä¸­åªéœ€è¦åˆ»ç”»å¦‚ä½•ä½¿ç”¨å †å’Œæ ˆï¼Œå¹¶ä¸éœ€è¦æŠŠå †å’Œæ ˆæ”¾åœ¨æ–‡ä»¶é‡Œã€‚\nå¦‚ä½•è¯†åˆ«ä¸åŒæ ¼å¼çš„å¯æ‰§è¡Œæ–‡ä»¶ï¼Ÿ å¦‚æœä½ åœ¨GNU/Linuxä¸‹æ‰§è¡Œä¸€ä¸ªä»Windowsæ‹·è¿‡æ¥çš„å¯æ‰§è¡Œæ–‡ä»¶, å°†ä¼šæŠ¥å‘Š\u0026quot;æ ¼å¼é”™è¯¯\u0026quot;. æ€è€ƒä¸€ä¸‹, GNU/Linuxæ˜¯å¦‚ä½•çŸ¥é“\u0026quot;æ ¼å¼é”™è¯¯\u0026quot;çš„?\nå¯æ‰§è¡Œæ–‡ä»¶çš„å‰å‡ ä¸ªå­—ç¬¦æ˜¯æ–‡ä»¶çš„é­”æ•°ï¼Œç”¨äºæ ‡è¯†æ–‡ä»¶çš„ç±»å‹ã€‚GNU/Linux åœ¨æ‰§è¡Œæ–‡ä»¶ä¹‹å‰å¯ä»¥å…ˆæ£€æŸ¥é­”æ•°æ¥åˆ¤æ–­è¿™æ˜¯å¦æ˜¯ä¸€ä¸ª ELF æ ¼å¼çš„å¯æ‰§è¡Œæ–‡ä»¶ã€‚\nå†—ä½™çš„å±æ€§ï¼Ÿ ä½¿ç”¨readelfæŸ¥çœ‹ä¸€ä¸ªELFæ–‡ä»¶çš„ä¿¡æ¯, ä½ ä¼šçœ‹åˆ°ä¸€ä¸ªsegmentåŒ…å«ä¸¤ä¸ªå¤§å°çš„å±æ€§, åˆ†åˆ«æ˜¯FileSizå’ŒMemSiz, è¿™æ˜¯ä¸ºä»€ä¹ˆ? å†ä»”ç»†è§‚å¯Ÿä¸€ä¸‹, ä½ ä¼šå‘ç°FileSizé€šå¸¸ä¸ä¼šå¤§äºç›¸åº”çš„MemSiz, è¿™åˆæ˜¯ä¸ºä»€ä¹ˆ?\nè¯¥é—®é¢˜çš„è§£ç­”è§ä¸‹ä¸€é“æ€è€ƒé¢˜â€œä¸ºä»€ä¹ˆè¦æ¸…é›¶â€ã€‚\nä¸ºä»€ä¹ˆè¦æ¸…é›¶ï¼Ÿ ä¸ºä»€ä¹ˆéœ€è¦å°† [VirtAddr + FileSiz, VirtAddr + MemSiz) å¯¹åº”çš„ç‰©ç†åŒºé—´æ¸…é›¶?\nSFTW åå‘ç°è¿™æ˜¯ä¸€ä¸ªéå¸¸æœ‰æ„æ€çš„é—®é¢˜ã€‚ELF æ–‡ä»¶ä¸­çš„ Filesize æŒ‡çš„æ˜¯è¿™ä¸ªæ®µåœ¨ ELF æ–‡ä»¶ä¸­å æ®çš„å¤§å°ï¼Œè€Œ Memsize æŒ‡çš„æ˜¯è¿™ä¸ªæ®µæœ€ç»ˆåœ¨å†…å­˜ä¸­å æ®çš„å¤§å°ã€‚è¿™ä¸¤è€…ä¹‹æ‰€ä»¥ä¸ä¸€æ ·æ˜¯å› ä¸º .bss èŠ‚ï¼ˆæœªåˆå§‹åŒ–å˜é‡ï¼‰åœ¨ ELF ä¸­æ˜¯æ²¡æœ‰åˆ†é…å…·ä½“çš„ç©ºé—´çš„ï¼Œåªæ˜¯ä¸€ä¸ªå ä½ç¬¦ï¼Œä½†æœ€ç»ˆåœ¨è¿è¡ŒçŠ¶æ€ä¸‹å®ƒä»¬ä¹Ÿéœ€è¦è¢«åˆ†é…å†…å­˜ç©ºé—´ã€‚\nå°† [VirtAddr + FileSiz, VirtAddr + MemSiz] å¯¹åº”çš„ç‰©ç†åŒºé—´æ¸…é›¶ï¼Œç›¸å½“äºä½¿å¾— .bss ä¸­çš„å˜é‡çš„åˆå€¼éƒ½ä¸º 0ã€‚æˆ‘ä»¬åœ¨ C è¯­è¨€ç¨‹åºä¸­å®šä¹‰æœªåˆå§‹åŒ–çš„å…¨å±€å˜é‡ï¼Œå…¶é»˜è®¤åˆå€¼ä¸º0ï¼Œæ­£æ˜¯å› ä¸ºåŠ è½½å™¨åœ¨åŠ è½½æ—¶å°†è¿™ä¸€æ®µå†…å­˜ç½®ä¸ºäº†0ã€‚ç»è¿‡ç¬”è€…çš„å®éªŒï¼Œå¦‚æœå°†è¿™ä¸€æ¸…ç©ºè¯­å¥åˆ é™¤ï¼Œè¿è¡Œç¨‹åºå°†ä¼šè§¦å‘æ®µé”™è¯¯ã€‚ è¿™ç¯‡å›ç­”å¯¹è¿™ä¸ªé—®é¢˜ç»™å‡ºäº†è¾ƒä¸ºè¯¦ç»†çš„è§£é‡Šã€‚\nç³»ç»Ÿè°ƒç”¨çš„å¿…è¦æ€§ å¯¹äºæ‰¹å¤„ç†ç³»ç»Ÿæ¥è¯´, ç³»ç»Ÿè°ƒç”¨æ˜¯å¿…é¡»çš„å—? å¦‚æœç›´æ¥æŠŠAMçš„APIæš´éœ²ç»™æ‰¹å¤„ç†ç³»ç»Ÿä¸­çš„ç¨‹åº, ä¼šä¸ä¼šæœ‰é—®é¢˜å‘¢?\nAM çš„ API åªèƒ½è´Ÿè´£å®Œæˆç›¸åº”çš„åŠŸèƒ½ï¼Œè€Œç³»ç»Ÿè°ƒç”¨åº”è¯¥è¿˜å…·æœ‰ç»Ÿä¸€è°ƒåº¦å„ä¸ªç¨‹åºå¯¹ç¡¬ä»¶çš„ä½¿ç”¨çš„åŠŸèƒ½ã€‚æ¯”å¦‚ç³»ç»Ÿè°ƒç”¨ readï¼Œä¸ºäº†å®‰å…¨æ€§çš„è€ƒè™‘ï¼Œå®ƒåº”è¯¥åªèƒ½è¯»å–æœ¬ç”¨æˆ·ç¨‹åºç›¸å…³çš„å†…å­˜åŒºåŸŸï¼Œä¸èƒ½è®¿é—®åˆ«çš„ç”¨æˆ·ç¨‹åºçš„å†…å­˜ã€‚è¿™éƒ¨åˆ†å®‰å…¨æ£€æŸ¥å°±åº”è¯¥ç”±ç³»ç»Ÿè°ƒç”¨åŠå…¶èƒŒåçš„æ“ä½œç³»ç»Ÿæ¥å®Œæˆã€‚AM çš„ API åªæ˜¯ç¡¬ä»¶åŠŸèƒ½çš„ç®€å•å°è£…ï¼Œæ— æ³•å®ç°è¿™æ ·çš„åŠŸèƒ½ã€‚\nRISC-Vç³»ç»Ÿè°ƒç”¨å·çš„ä¼ é€’ å¦‚æœä½ é€‰æ‹©çš„æ˜¯RISC-V, ä½ ä¼šå‘ç°å®ƒå¹¶ä¸æ˜¯é€šè¿‡a0æ¥ä¼ é€’ç³»ç»Ÿè°ƒç”¨å·. äº‹å®ä¸Š, æˆ‘ä»¬å‚è€ƒäº†RISC-V Linuxçš„ç³»ç»Ÿè°ƒç”¨å‚æ•°ä¼ é€’çš„çº¦å®š: å³åœ¨RISC-V Linuxä¸Šä¹Ÿæ˜¯é€šè¿‡è¿™ä¸ªå¯„å­˜å™¨æ¥ä¼ é€’ç³»ç»Ÿè°ƒç”¨å·çš„. ä½ è§‰å¾—RISC-V Linuxä¸ºä»€ä¹ˆæ²¡æœ‰ä½¿ç”¨a0æ¥ä¼ é€’ç³»ç»Ÿè°ƒç”¨å·å‘¢?\nRISC-V Linux è°ƒç”¨çº¦å®šä¸­ä½¿ç”¨ a7 æ¥ä¼ é€’ç³»ç»Ÿè°ƒç”¨å·ï¼Œä¸”è§„å®šç³»ç»Ÿè°ƒç”¨æœ€å¤šæœ‰ 6 ä¸ªå‚æ•°ï¼Œå­˜æ”¾åœ¨ a0~a5 ä¸­ã€‚æˆ‘è®¤ä¸ºè¿™æ ·è®¾è®¡å¯èƒ½çš„ç›®çš„æ˜¯ä¿æŒç³»ç»Ÿè°ƒç”¨å’Œå‡½æ•°è°ƒç”¨åœ¨ä¼ é€’å‚æ•°ä¸Šçš„ä¸€è‡´æ€§ã€‚\nè¡¥å…… æ£€æŸ¥ ELF æ–‡ä»¶çš„é­”æ•° æˆ‘ä»¬çŸ¥é“ELFæ–‡ä»¶çš„å¼€å¤´éƒ½æœ‰ä¸€ä¸ªç‰¹æ®Šçš„é­”æ•°, ä¸ºäº†é˜²æ­¢loaderåŠ è½½äº†ä¸€ä¸ªéELFæ ¼å¼çš„æ–‡ä»¶, æˆ‘ä»¬å¯ä»¥åœ¨loaderä¸­å¯¹é­”æ•°è¿›è¡Œæ£€æŸ¥:\nassert(*(uint32_t *)elf-\u0026gt;e_ident == 0xBadC0de); ä½ éœ€è¦æŠŠä¸Šè¿°çš„0xBadC0deæ¢æˆæ­£ç¡®çš„é­”æ•°.\nåˆ«å°çœ‹è¿™ä¸ªè¡¨é¢ä¸Šå¾ˆè ¢çš„assert(), å½“ä½ å“ªå¤©æ‰‹æŠ–ä¸çŸ¥é“åšäº†ä»€ä¹ˆè€Œåˆè¢«å®ƒæŠ“åˆ°çš„æ—¶å€™, ä½ å°±çŸ¥é“è°¢å¤©è°¢åœ°äº†.\nELFæ–‡ä»¶å¼€å¤´çš„å››ä¸ªå­—èŠ‚æ˜¯ 7f 45 4c 46 ï¼Œæ³¨æ„åˆ° riscv æ˜¯å°ç«¯æœºï¼Œæ‰€ä»¥æ­£ç¡®çš„é­”æ•°ä¸º 0x464c457fã€‚\næ£€æµ‹ ELF æ–‡ä»¶çš„ISAç±»å‹ ä½ å¾ˆæœ‰å¯èƒ½ä¼šå› ä¸ºç–å¿½, ä»è€Œè®©nativeçš„Nanos-liteæ¥åŠ è½½è¿è¡Œä¸€ä¸ªx86/mips32/riscv32çš„dummy. ä»ISAè§„èŒƒçš„è§’åº¦æ¥è¯´, è¿™ç§è¡Œä¸ºæ˜¾ç„¶å±äºUB, å…·ä½“è€Œè¨€é€šå¸¸ä¼šå‘ç”Ÿä¸€äº›éš¾ä»¥ç†è§£çš„é”™è¯¯. ä¸ºäº†é¿å…è¿™ç§æƒ…å†µ, ä½ å¯ä»¥åœ¨loaderä¸­æ£€æµ‹ELFæ–‡ä»¶çš„ISAç±»å‹. æˆ‘ä»¬å¯ä»¥æ ¹æ®AMä¸­å®šä¹‰çš„ä¸€äº›å®æ¥ç­›é€‰å‡ºé¢„æœŸçš„ISAç±»å‹ï¼Œç„¶åå’ŒELFä¿¡æ¯ä¸­çš„æŸä¸ªåŸŸè¿›è¡Œå¯¹æ¯”, å¦‚æœå‘ç°è¦åŠ è½½çš„ELFæ–‡ä»¶çš„ISAç±»å‹å’Œé¢„æœŸä¸ä¸€è‡´, å°±æŠ¥é”™. å¦‚æœä½ ä¸çŸ¥é“AMä¸­çš„å®åœ¨å“ªé‡Œå®šä¹‰, RTFSC. å¦‚æœä½ ä¸çŸ¥é“åº”è¯¥å’ŒELFä¸­çš„å“ªä¸ªåŸŸè¿›è¡Œå¯¹æ¯”, RTFM.\nå½“å‰å¯èƒ½éœ€è¦ç”¨åˆ°çš„ ISA åº”è¯¥åªæœ‰ native çš„ x86-64 å’Œ nemu çš„ riscv32ï¼Œå› æ­¤ç¬”è€…ä½¿ç”¨äº†å¦‚ä¸‹ä»£ç æ¥å®šä¹‰å® EXPECT_ISAï¼š\n#if defined(__ISA_AM_NATIVE) # define EXPECT_TYPE EM_X86_64 #elif defined(__ISA_RISCV32__) # define EXPECT_TYPE EM_RISCV // é˜…è¯» elf.h ä¸­çš„å®å¯ä»¥æ‰¾åˆ° RISC-V å¯¹åº” EM_RISCV #else # error Unsupported ISA #endif ELF æ–‡ä»¶ä¸­çš„ ISA å±æ€§å­˜æ”¾åœ¨ elf_header çš„ e_machine å­—æ®µä¸­ã€‚å› æ­¤ç”¨ä¸€ä¸ª assert è¯­å¥è¿›è¡Œæ¯”è¾ƒå³å¯ã€‚\nå…³äºå†…å­˜çš„è¯»å†™ ç¬”è€…æ›¾ç»æƒ³äº†å¾ˆä¹…ä¹Ÿä¸æ˜ç™½åº”è¯¥å¦‚ä½•è¯»å†™å†…å­˜ï¼ˆå› ä¸ºåœ¨ AM çš„ nemu ç›¸å…³æ–‡ä»¶å¤¹ä¸­æ²¡æœ‰æ‰¾åˆ° APIï¼‰ã€‚åæ¥æƒ³èµ·æ¥å†…å­˜çš„è¯»å†™ä½œä¸ºä¸€æ¡æ¶æ„æ— å…³çš„åŠŸèƒ½ï¼Œæ”¾åœ¨äº† klib é‡Œé¢ã€‚å› æ­¤ç›´æ¥è°ƒç”¨ memset, memcpy ç­‰å³å¯ã€‚ä» ELF æ–‡ä»¶ä¸­è¯»å‡ºæ¥çš„ vaddr è™½ç„¶æ˜¯å˜é‡ï¼Œä½†é‡Œé¢å­˜å‚¨çš„å°±æ˜¯åœ°å€ï¼Œç›´æ¥å°†å…¶è½¬æ¢æˆæŒ‡é’ˆç±»å‹å³å¯ã€‚\nå…³äºè·³è½¬ ç¼–è¯‘å™¨ç¼–è¯‘å¹¶ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶æ—¶ï¼Œä¼šå¯»æ‰¾ start.S å¹¶å°†å…¶ä½œä¸ºç¨‹åºçš„å…¥å£ã€‚è¿™ä¸ªå…¥å£ä¿å­˜åœ¨äº† elf header çš„ e_entry å­—æ®µä¸­ï¼Œå› æ­¤ç›´æ¥è®¿é—®è¯¥å­—æ®µå³å¯ã€‚æ¡†æ¶ä»£ç ä¸­æœ‰ä¸€ä¸ªå¾ˆå¥½çš„ç»†èŠ‚ï¼š\n((void *)())entry) (); å®ƒå°†ä¿å­˜æœ‰å®¢æˆ·ç¨‹åºå…¥å£åœ°å€çš„å˜é‡ entry å¼ºåˆ¶è½¬æ¢æˆäº†ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆã€‚ç„¶åè°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œç›¸å½“äºè·³è½¬åˆ°å‡½æ•°æŒ‡é’ˆæŒ‡å‘çš„åœ°å€ï¼Œè€Œè¿™ä¸ªåœ°å€å°±æ˜¯ entry åŸæ¥å­˜å‚¨çš„å€¼ã€‚è¿™ä¸€å¥ä»£ç ç”¨ C çš„æ–¹å¼å®Œæˆäº†æ±‡ç¼–çº§åˆ«çš„è·³è½¬ã€‚\nå…³äºè¿”å›å€¼ ä¸ºä»€ä¹ˆæˆ‘ä½¿ç”¨äº†æ¡†æ¶ä»£ç ç»™å®šçš„å® GPRx æ¥å­˜å‚¨è¿”å›å€¼ï¼Œä½†å †åŒºçš„å®ç°è¿˜æ˜¯å¤±è´¥äº†ï¼Ÿ\næ£€æŸ¥æ¡†æ¶ä»£ç å¯ä»¥å‘ç°ï¼Œé™¤äº† GPR1 å¯¹åº”åˆ°äº†æ­£ç¡®çš„ a7 ä»¥å¤–ï¼Œå…¶ä»–çš„éƒ½æ˜¯é”™çš„ï¼æ ¹æ® riscv-linux çš„ syscall çº¦å®šï¼Œæˆ‘ä»¬åº”è¯¥å°† GPR2~GPR4 å¯¹åº”åˆ° a0~a2ï¼Œè¿”å›å¯„å­˜å™¨ GPRx å¯¹åº”åˆ° a0ï¼Œè¿™æ ·å°±å¯ä»¥æ­£ç¡®åœ°æä¾›è¿”å›å€¼äº†ã€‚\næ–‡ä»¶ç³»ç»Ÿ è¡¥å…… å…³äº file-test ä¸­æ–‡ä»¶è¯»å…¥çš„æº¢å‡ºé—®é¢˜ ç¬”è€…èµ·åˆè®¤ä¸ºè¿›è¡Œè¯»å–æ“ä½œæ—¶ï¼Œè¯»å–çš„èŒƒå›´æ˜¯ä¸èƒ½è¶…è¿‡æœ¬æ–‡ä»¶å¤§å°çš„ï¼Œå› æ­¤åœ¨è¯»å–çš„æ—¶å€™å¯¹ offset å’Œ len è¿›è¡Œäº† assertï¼Œç»“æœè§¦å‘äº† failã€‚\nç¬”è€…æ‰“å°äº†æ¯æ¬¡è¯»å–çš„ lenï¼Œå‘ç° fscanf æ˜¯æ‰¹é‡è¯»å–çš„ï¼šç”±äºæœ‰ä¸€æ¬¡è¯»å–åœ¨å››åƒå¤šçš„ä½ç½®ä¸€ä¸‹è¯»å–äº† 1024 ä¸ªå­—ç¬¦ï¼Œæ‰€ä»¥è§¦å‘äº†æ–­è¨€ã€‚\nç¬”è€…å†æ¬¡é˜…è¯»äº† read ç³»ç»Ÿè°ƒç”¨çš„æ‰‹å†Œï¼Œå‘ç°å…¶è¿”å›å€¼ç†åº”æ˜¯å®é™…è¯»å–åˆ°çš„å­—ç¬¦ä¸ªæ•°ã€‚å¤„äºå®‰å…¨æ€§çš„è€ƒè™‘ï¼Œä¸€ä¸ªåº”ç”¨ç¨‹åºä¸åº”è¯¥å¯ä»¥è¯»å–åˆ°åˆ«çš„ç”¨æˆ·ç¨‹åºçš„æ•°æ®ä¿¡æ¯ï¼Œæ‰€ä»¥å¦‚æœåœ¨æ–‡ä»¶ç³»ç»Ÿä¸­å‰©ä½™çš„æ•°æ®ä¸è¶³ç»™å®šçš„ lenï¼Œåˆ™åº”è¯¥åªå°†å‰©ä½™çš„æ•°æ®æ”¾å…¥ç¼“å†²åŒºï¼Œå¹¶è¿”å›çœŸå®çš„è¯»å–åˆ°çš„å­—ç¬¦æ•°ã€‚\nç²¾å½©çº·å‘ˆçš„åº”ç”¨ç¨‹åº æ€è€ƒé¢˜ æ¯”è¾ƒ fixedpt å’Œ float fixedptå’Œfloatç±»å‹çš„æ•°æ®éƒ½æ˜¯32ä½, å®ƒä»¬éƒ½å¯ä»¥è¡¨ç¤º2^32ä¸ªä¸åŒçš„æ•°. ä½†ç”±äºè¡¨ç¤ºæ–¹æ³•ä¸ä¸€æ ·, fixedptå’Œfloatèƒ½è¡¨ç¤ºçš„æ•°é›†æ˜¯ä¸ä¸€æ ·çš„. æ€è€ƒä¸€ä¸‹, æˆ‘ä»¬ç”¨fixedptæ¥æ¨¡æ‹Ÿè¡¨ç¤ºfloat, è¿™å…¶ä¸­éšå«ç€å“ªäº›å–èˆ?\nfixedpt ä¸­æ¯ç›¸é‚»çš„ä¸¤ä¸ªæ•°ä¹‹é—´çš„å·®éƒ½æ˜¯ $2^{-8}$ï¼Œè€Œ float åœ¨è¶Šå°çš„æ•°æ®èŒƒå›´ä¸‹è¡¨ç¤ºçš„ç²¾åº¦è¶Šé«˜ã€‚é€šå¸¸æ¥è¯´æˆ‘ä»¬åœ¨è¡¨ç¤ºå¤§æ•°çš„æ—¶å€™ä¼šå¯¹å…¶å°æ•°ç‚¹åçš„ç²¾åº¦è¦æ±‚ä¸é‚£ä¹ˆé«˜ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬æ›´åœ¨æ„æ•°æ®çš„â€œç›¸å¯¹è¯¯å·®â€è€Œä¸æ˜¯â€œç»å¯¹è¯¯å·®â€ï¼Œåœ¨è¿™ä¸€ç‚¹ä¸Š float ä¼šæ›´åŠ åˆç†ã€‚\nç¥å¥‡çš„fixedpt_rconst é˜…è¯»fixedpt_rconst()çš„ä»£ç , ä»è¡¨é¢ä¸Šçœ‹, å®ƒå¸¦æœ‰éå¸¸æ˜æ˜¾çš„æµ®ç‚¹æ“ä½œ, ä½†ä»ç¼–è¯‘ç»“æœæ¥çœ‹å´æ²¡æœ‰ä»»ä½•æµ®ç‚¹æŒ‡ä»¤. ä½ çŸ¥é“å…¶ä¸­çš„åŸå› å—?\nç¬”è€…æš‚æ—¶æ²¡æœ‰ç ”ç©¶å‡ºæ¥ï¼Œç•™å‘ã€‚\nç¥å¥‡çš„LD_PRELOAD bmp-testéœ€è¦æ‰“å¼€ä¸€ä¸ªè·¯å¾„ä¸º/share/pictures/projectn.bmpçš„æ–‡ä»¶, ä½†åœ¨Linux nativeä¸­, è¿™ä¸ªè·¯å¾„å¯¹åº”çš„æ–‡ä»¶å¹¶ä¸å­˜åœ¨. ä½†æˆ‘ä»¬è¿˜æ˜¯æŠŠbmp-testæˆåŠŸè¿è¡Œèµ·æ¥äº†, ä½ çŸ¥é“è¿™æ˜¯å¦‚ä½•å®ç°çš„å—? å¦‚æœä½ æ„Ÿå…´è¶£, å¯ä»¥åœ¨äº’è”ç½‘ä¸Šæœç´¢LD_PRELOADç›¸å…³çš„å†…å®¹.\nLD_PRELOAD å¯ä»¥å®ç°è·¯å¾„çš„é‡å®šå‘ï¼ŒPA4.1 çš„ busybox ä¹Ÿä½¿ç”¨äº†ç›¸ä¼¼çš„æŠ€æœ¯å®ç°äº†å°† shell å‘½ä»¤çš„åœ°å€é‡å®šå‘åˆ° busybox ä¸­çš„ç¨‹åºã€‚å…·ä½“å†…å®¹å°šæœªäº†è§£ï¼Œç•™å‘ã€‚\nä»™å‰‘å¥‡ä¾ ä¼ æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Ÿ æˆ‘ä»¬åœ¨PA2ä¸­è®¨è®ºè¿‡ä¸€ä¸ªæ¸¸æˆçš„åŸºæœ¬æ¡†æ¶, å°è¯•é˜…è¯»ä»™å‰‘å¥‡ä¾ ä¼ çš„ä»£ç , æ‰¾å‡ºåŸºæœ¬æ¡†æ¶æ˜¯é€šè¿‡å“ªäº›å‡½æ•°å®ç°çš„. æ‰¾åˆ°ä¹‹å, å¯èƒ½ä¼šå¯¹ä½ è°ƒè¯•ä»™å‰‘å¥‡ä¾ ä¼ å¸¦æ¥ä¸€å®šçš„å¸®åŠ©. è™½ç„¶ä»™å‰‘å¥‡ä¾ ä¼ çš„ä»£ç å¾ˆå¤š, ä½†ä¸ºäº†å›ç­”è¿™ä¸ªé—®é¢˜, ä½ å¹¶ä¸éœ€è¦é˜…è¯»å¤§é‡çš„ä»£ç .\nPA2 ä¸­æåˆ°çš„ä¸€ä¸ªæ¸¸æˆçš„åŸºæœ¬æ¡†æ¶å¤§è‡´ä¸ºï¼š\nwhile (1) { ç­‰å¾…æ–°çš„ä¸€å¸§(); // AM_TIMER_UPTIME å¤„ç†ç”¨æˆ·æŒ‰é”®(); // AM_INPUT_KEYBRD æ›´æ–°æ¸¸æˆé€»è¾‘(); // TRM ç»˜åˆ¶æ–°çš„å±å¹•(); // AM_GPU_FBDRAW } ä»™å‰‘å¥‡ä¾ ä¼ ä¸­çš„ PAL_GameMain() ä¸­çš„ while å¾ªç¯å¤§æŠµåšäº†ç›¸ä¼¼çš„å·¥ä½œï¼š\nwhile (TRUE) { // // Do some initialization at game start. // if (gpGlobals-\u0026gt;fGameStart) { PAL_GameStart(); gpGlobals-\u0026gt;fGameStart = FALSE; } // // Load the game resources if needed. // PAL_LoadResources(); // // Clear the input state of previous frame. // PAL_ClearKeyState(); // // Wait for the time of one frame. Accept input here. // PAL_DelayUntil(dwTime); uint32_t now = SDL_GetTicks(); UpdateFPS(now); // // Set the time of the next frame. // dwTime = now + FRAME_TIME; // // Run the main frame routine. // PAL_StartFrame(); } PAL_LoadResources() ç”¨äºåŠ è½½éœ€è¦çš„æ¸¸æˆèµ„æºã€‚PAL_ClearKeyState() æ¸…ç©ºä¹‹åï¼ŒPAL_DelayUntil() ä¼šæŒç»­æ‰§è¡Œä¸€æ®µæ—¶é—´å¹¶æ¥æ”¶è®¾å¤‡çš„è¾“å…¥ï¼ˆä¸»è¦ä½¿ç”¨äº† SDL_Delay() å’Œ PAL_ProcessEvent()ï¼‰ã€‚PAL_StartFrame() ç”¨äºæ›´æ–°æ¸¸æˆé€»è¾‘ï¼ˆæ¯”å¦‚æ ¹æ®è¾“å…¥æ¥æ”¹å˜äººç‰©çš„ä½ç½®ï¼‰å¹¶ç»˜åˆ¶å›¾åƒã€‚\nä»™å‰‘å¥‡ä¾ ä¼ çš„è„šæœ¬å¼•æ“ åœ¨navy-apps/apps/pal/repo/src/game/script.cä¸­æœ‰ä¸€ä¸ªPAL_InterpretInstruction()çš„å‡½æ•°, å°è¯•å¤§è‡´äº†è§£è¿™ä¸ªå‡½æ•°çš„ä½œç”¨å’Œè¡Œä¸º. ç„¶åå¤§èƒ†çŒœæµ‹ä¸€ä¸‹, ä»™å‰‘å¥‡ä¾ ä¼ çš„å¼€å‘è€…æ˜¯å¦‚ä½•å¼€å‘è¿™æ¬¾æ¸¸æˆçš„? ä½ å¯¹\u0026quot;æ¸¸æˆå¼•æ“\u0026quot;æ˜¯å¦æœ‰æ–°çš„è®¤è¯†?\nè¿™ä¸ªå‡½æ•°çš„è¡Œä¸ºæœ‰ä¸€ç‚¹åƒä¸€ä¸ª cpuï¼šå®ƒæ‹¿åˆ°â€œæŒ‡ä»¤â€ä¹‹åï¼Œä¼šè¿›è¡Œè¯‘ç ï¼Œæ‰§è¡Œï¼Œå‡½æ•°ä¼šè¿”å›ä¸‹ä¸€æ¡åº”è¯¥æ‰§è¡Œçš„â€œæŒ‡ä»¤â€çš„åœ°å€ã€‚\nä»™å‰‘çš„å¼€å‘è€…åœ¨å¼€å‘è¿™æ¬¾æ¸¸æˆçš„æ—¶å€™ï¼Œå¯èƒ½å‘æ˜äº†ä¸€æ¬¾ä¸“ç”¨äº pal çš„ ISAï¼Œç„¶åæ‰€æœ‰å’Œæ¸¸æˆç›¸å…³çš„é€»è¾‘æ›´æ–°çš„æ“ä½œéƒ½é€šè¿‡è¿™ä¸ª ISA æ”¯æŒçš„æŒ‡ä»¤æ¥å®Œæˆã€‚ æ¸¸æˆå¼•æ“å…¶å®å°±æ˜¯ä¸€ä¸ªè™šæ‹Ÿæœºã€‚å¦‚æœæˆ‘ä»¬è®¤ä¸º nemu æ˜¯çœŸæœºçš„è¯ï¼Œé‚£ä¹ˆ pal é‡Œçš„è¿™ä¸ªä¸“é—¨æ‰§è¡Œ pal-ISA æŒ‡ä»¤é›†çš„ \u0026ldquo;cpu\u0026rdquo; å°±æ˜¯æ¸¸æˆå¼•æ“ï¼›å¦‚æœæˆ‘ä»¬è®¤ä¸º native æ˜¯çœŸæœºçš„è¯ï¼Œç¬”è€…ç›®å‰çš„ nemu å°±æ˜¯ä¸€ä¸ªæ‰§è¡Œ riscv32-ISA æŒ‡ä»¤é›†çš„â€œæ¸¸æˆå¼•æ“â€ã€‚\nä¸å†ç¥ç§˜çš„ç§˜æŠ€ ç½‘ä¸Šæµä¼ ç€ä¸€äº›å…³äºä»™å‰‘å¥‡ä¾ ä¼ çš„ç§˜æŠ€, å…¶ä¸­çš„è‹¥å¹²æ¡ç§˜æŠ€å¦‚ä¸‹:\nå¾ˆå¤šäººåˆ°äº†äº‘å§¨é‚£é‡Œéƒ½ä¼šå»æ‹¿ä¸‰æ¬¡é’±, å…¶å®æ‹¿ä¸€æ¬¡å°±ä¼šè®©é’±ç®±çˆ†æ»¡! ä½ æ‹¿äº†ä¸€æ¬¡é’±å°±å»ä¹°å‰‘æŠŠé’±ç”¨åˆ°åªå‰©ä¸€åƒå¤š, ç„¶åå»é“å£«é‚£é‡Œ, å…ˆä¸è¦ä¸Šæ¥¼, å»æŒæŸœé‚£é‡Œä¹°é…’, å¤šä¹°å‡ æ¬¡ä½ å°±ä¼šå‘ç°é’±ç”¨ä¸å®Œäº†. ä¸æ–­ä½¿ç”¨ä¹¾å¤ä¸€æ·(é’±å¿…é¡»å¤šäºäº”åƒæ–‡)ç”¨åˆ°è´¢äº§ä½äºäº”åƒæ–‡, é’±ä¼šæš´å¢åˆ°ä¸Šé™, å¦‚æ­¤ä¸€æ¥å°±æœ‰ç”¨ä¸å®Œçš„é’±äº† å½“æé€é¥ç­‰çº§åˆ°è¾¾99çº§æ—¶, ç”¨5~10åªé‡‘èš•ç‹, ç»éªŒç‚¹åˆè·‘å‡ºæ¥äº†, è€Œä¸”å‡çº§æ‰€éœ€ç»éªŒä¼šå˜å›åˆæœŸ5~10çº§å†…çš„ç»éªŒå€¼, ç„¶åå»æ‰“æ•Œäººæˆ–ç”¨é‡‘èš•ç‹å‡çº§, å¯ä»¥å­¦åˆ°çµå„¿çš„æ³•æœ¯(ä»äº”æ°”æœå…ƒå¼€å§‹); å‡åˆ°199çº§åå†ç”¨5~10åªé‡‘èš•ç‹, ç»éªŒç‚¹å†è·‘å‡ºæ¥, æ‰€éœ€å‡çº§ç»éªŒä¹Ÿæ˜¯å¾ˆä½, å¯ä»¥å­¦åˆ°æœˆå¦‚çš„æ³•æœ¯(ä»ä¸€é˜³æŒ‡å¼€å§‹); åˆ°299çº§åå†ç”¨10~30åªé‡‘èš•ç‹, ç»éªŒç‚¹å‡ºæ¥åç»§ç»­å‡çº§, å¯å­¦åˆ°é˜¿å¥´çš„æ³•æœ¯(ä»ä¸‡èšèš€è±¡å¼€å§‹). å‡è®¾è¿™äº›ä¸Šè¿°è¿™äº›ç§˜æŠ€å¹¶éæ¸¸æˆåˆ¶ä½œäººå‘˜çš„æœ¬æ„, è¯·å°è¯•è§£é‡Šè¿™äº›ç§˜æŠ€ä¸ºä»€ä¹ˆèƒ½ç”Ÿæ•ˆ.\nç¬”è€…æ²¡æœ‰ä»”ç»†ç©è¿‡ä»™å‰‘å¥‡ä¾ ä¼ ï¼Œå› æ­¤å¯¹å…¶ä¸­çš„ä¸€äº›æ¸¸æˆæœºåˆ¶ä¸å¤ªäº†è§£ã€‚ä½†æ˜¯ä»ä¸Šè¿°çš„æŸäº› bug çš„ç°è±¡ä¸­ï¼ˆæ¯”å¦‚ç¬¬äºŒä¸ªï¼‰å¯ä»¥æ¨æµ‹æœ‰ä¸€äº›æ— ç¬¦å·æ•°åœ¨ä¸‹æº¢å‡ºä¹‹åç›´æ¥å˜æˆäº† UINT_MAXï¼Œä»è€Œå¯¼è‡´é—®é¢˜ã€‚\nåœ¨ Navy ä¸­è¿è¡Œ microbench å°è¯•æŠŠmicrobenchç¼–è¯‘åˆ°Navyå¹¶è¿è¡Œ, ä½ åº”è¯¥ä¼šå‘ç°è¿è¡Œé”™è¯¯, è¯·å°è¯•åˆ†æåŸå› .\nç¬”è€…æš‚æ—¶è¿˜æœªå®ç° Navy ä¸­çš„ AMï¼Œç•™å‘ã€‚\nå¦‚ä½•åœ¨ Navy ä¸Šè¿è¡Œ Nanos-lite? æ—¢ç„¶èƒ½åœ¨Navyä¸Šè¿è¡ŒåŸºäºAMçš„FCEUX, é‚£ä¹ˆä¸ºäº†ç‚«è€€, åœ¨Navyä¸Šè¿è¡ŒNanos-liteä¹Ÿå¹¶ä¸æ˜¯ä¸å¯èƒ½çš„. æ€è€ƒä¸€ä¸‹, å¦‚æœæƒ³åœ¨Navyä¸Šå®ç°CTE, æˆ‘ä»¬è¿˜éœ€è¦äº›ä»€ä¹ˆå‘¢?\næˆ‘ä»¬éœ€è¦æ”¯æŒ CTE çš„ä¸­æ–­æœºåˆ¶ã€‚åœ¨ Nanos-lite ä¸­æœ‰ä¸€äº›æ±‡ç¼–æ“æ§ç‰¹æƒå¯„å­˜å™¨çš„è¯­å¥ï¼Œè¿™äº›è¯­å¥ç›´æ¥ä¸ç¡¬ä»¶äº¤äº’ã€‚ä½†ç°åœ¨ Navy-Nanos-lite æ˜¯åœ¨ Nanos-lite ä¸Šè·‘çš„ï¼Œæ‰€ä»¥ç‰¹æƒå¯„å­˜å™¨çš„ä¸€å¥—æœºåˆ¶éœ€è¦æœ‰ä¸€ç§è½¯çš„å¤„ç†æ–¹æ¡ˆã€‚\nRTFSC??? æœºæ™ºçš„ä½ ä¹Ÿè®¸ä¼šæƒ³: å“‡å¡, ä¸‹å­¦æœŸçš„oslab0æˆ‘ä¸å°±æœ‰ä¼˜ç§€ä»£ç å¯ä»¥å‚è€ƒäº†å—? ä¸è¿‡æˆ‘ä»¬å·²ç»å¯¹å‘å¸ƒçš„ä»£ç è¿›è¡Œäº†æŸç§ç‰¹æ®Šçš„å¤„ç†. åœ¨æ²®ä¸§ä¹‹ä½™, ä¸å¦¨æ€è€ƒä¸€ä¸‹, å¦‚æœè¦ä½ æ¥å®ç°è¿™ä¸€ç‰¹æ®Šçš„å¤„ç†, ä½ ä¼šå¦‚ä½•å®ç°? è¿™å’ŒPA1ä¸­çš„è¡¨è¾¾å¼æ±‚å€¼æœ‰ä»€ä¹ˆç›¸ä¼¼ä¹‹å¤„å—?\nè§‚å¯Ÿ oslab0 çš„ä»£ç ï¼Œæˆ‘ä»¬åŸºæœ¬å¯ä»¥ç¡®å®šä»£ç çš„å‘å¸ƒè€…å¯¹ä»£ç ä¸­çš„å˜é‡åï¼Œå‡½æ•°åç­‰è¿›è¡Œäº†æ›¿æ¢ï¼Œå°†å…¶æ¢æˆäº†å†—é•¿çš„ä¸å¯è¯»å­—ç¬¦ä¸²ã€‚PA1 ä¸­ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…å­—ç¬¦ä¸²çš„æŠ€æœ¯åœ¨è¿™é‡Œå¯ä»¥æ´¾ä¸Šç”¨åœºã€‚\nç»ˆææ‹·é—® è‡ªå¤ä»¥æ¥, è®¡ç®—æœºç³»ç»Ÿæ–¹å‘çš„è¯¾ç¨‹å°±æœ‰ä¸€ä¸ªç»ˆææ‹·é—®:\nå½“ä½ åœ¨ç»ˆç«¯é”®å…¥./helloè¿è¡ŒHello Worldç¨‹åºçš„æ—¶å€™, è®¡ç®—æœºç©¶ç«Ÿåšäº†äº›ä»€ä¹ˆ?\nä½ å·²ç»å®ç°äº†æ‰¹å¤„ç†ç³»ç»Ÿ, å¹¶ä¸”æˆåŠŸé€šè¿‡NTermæ¥è¿è¡Œå…¶å®ƒç¨‹åº. å°½ç®¡æˆ‘ä»¬çš„æ‰¹å¤„ç†ç³»ç»Ÿç»è¿‡äº†è¯¸å¤šç®€åŒ–, ä½†è¿˜æ˜¯ä¿ç•™äº†è®¡ç®—æœºå‘å±•å²çš„ç²¾é«“. å®ç°äº†æ‰¹å¤„ç†ç³»ç»Ÿä¹‹å, ä½ å¯¹ä¸Šè¿°çš„ç»ˆææ‹·é—®æœ‰ä»€ä¹ˆæ–°çš„è®¤è¯†?\nä¸€ä¸ªç®€å•çš„æµç¨‹å¦‚ä¸‹ï¼š\né”®å…¥ ./hello ä»¥åï¼Œshell è§£æå‘½ä»¤ä¹‹åå‘ç°è¦è¿è¡Œ hello æ–‡ä»¶ï¼ˆå¯æ‰§è¡Œç¨‹åºï¼‰ï¼Œäºæ˜¯ä½¿ç”¨ execve ç³»ç»Ÿè°ƒç”¨ï¼Œå°†æ–‡ä»¶å hello å’Œç›¸åº”çš„å‚æ•°ï¼Œç¯å¢ƒå˜é‡ä¼ è¿›å»ã€‚ é™·å…¥å†…æ ¸æ€ä¹‹åï¼Œæ“ä½œç³»ç»Ÿæ£€æŸ¥ hello æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼Œæ˜¯å¦æœ‰è¶³å¤Ÿçš„è®¿é—®æƒé™ç­‰ï¼Œå¦‚æœæœ‰é—®é¢˜ä¼šè¿”å›ç›¸åº”çš„é”™è¯¯å·ã€‚shell å¦‚æœå‘ç° execve ç³»ç»Ÿè°ƒç”¨è¿”å›ï¼Œåˆ™ä¼šæ ¹æ®é”™è¯¯å·æŠ¥é”™ã€‚ å¦‚æœä¸€åˆ‡æ­£å¸¸ï¼Œexecve ç³»ç»Ÿè°ƒç”¨ä¸ä¼šè¿”å›ã€‚æ“ä½œç³»ç»Ÿä¼šä¸º hello ç¨‹åºåˆ›å»ºä¸€ä¸ªåˆå§‹çš„ä¸Šä¸‹æ–‡ç»“æ„ä½“ï¼Œç„¶åè°ƒåº¦ hello ä½œä¸ºä¸‹ä¸€ä¸ªæ‰§è¡Œçš„è¿›ç¨‹ã€‚ï¼ˆåœ¨ pa3 ä¸­æš‚æ—¶æ²¡æœ‰è¿›ç¨‹çš„æ¦‚å¿µï¼Œä¼šç›´æ¥ä½¿ç”¨ naive_uload æ¥åŠ è½½ hello å¹¶è·³è½¬åˆ° entry æ‰§è¡Œï¼‰ã€‚ hello ç¨‹åºä½¿ç”¨ printf åº“å‡½æ•°æ‰“å°å­—ç¬¦ä¸² \u0026ldquo;Hello, world!\\n\u0026rdquo;ï¼Œprintf åº“å‡½æ•°çš„åº•å±‚ä¼šä½¿ç”¨ write ç³»ç»Ÿè°ƒç”¨ï¼Œé™·å…¥å†…æ ¸æ€ä¹‹åï¼Œæ“ä½œç³»ç»Ÿä½¿ç”¨ write ç³»ç»Ÿè°ƒç”¨ç›¸å…³çš„æœåŠ¡ç¨‹åºï¼Œå‘ stdout (å±å¹•) è¾“å‡ºå­—ç¬¦ã€‚ è¡¥å…… å…³äº convert.sh çš„æŠ¥é”™ ç›´æ¥è¿è¡Œ convert.sh ä¼šæŠ¥é”™\nattempt to perform an operation not allowed by the security policy `PDF' STFWåå¾—çŸ¥ï¼Œåªéœ€å°† /etc/ImageMagick-6/policy.xml ä¸­çš„\n\u0026lt;policy domain=\u0026quot;coder\u0026quot; rights=\u0026quot;none\u0026quot; pattern=\u0026quot;PDF\u0026quot; /\u0026gt; ä¸­çš„ \u0026quot;none\u0026quot; æ”¹ä¸º \u0026quot;read | write\u0026quot; å³å¯ã€‚\nå…³äºä»™å‰‘å¥‡ä¾ ä¼ çš„çº¢è“é¢œè‰² ç¬”è€…çš„ä»™å‰‘å¥‡ä¾ ä¼ åˆšå¼€å§‹å¯åŠ¨é¡µé¢å‡ºç°çš„æ˜¯çº¢è‰²çš„æ——å­ï¼Œæ¸¸æˆä¸­çš„æ‰€æœ‰äººç‰©éƒ½æ˜¯é’è‰²çš„è„¸åºã€‚ä»”ç»†é˜…è¯» SDL éƒ¨åˆ†çš„æºç åå‘ç°ï¼ŒSDL ä¸­å¯¹äº 32 ä½é¢œè‰²æ•°æ®çš„è§£è¯»å’Œè®²ä¹‰ä¸­å†™çš„ç•¥æœ‰ä¸åŒï¼šæ­£ç¡®çš„è§£è¯»æ–¹æ³•åº”è¯¥æ˜¯ aabbggrrï¼Œå’Œè®²ä¹‰ä¸­çš„ç›¸æ¯”æ­£å¥½çº¢è‰²å’Œè“è‰²é¢ å€’äº†ã€‚\nå…³äºä»™å‰‘å¥‡ä¾ ä¼ çš„å­—å¹•é»‘æ¡† ç¬”è€…çš„ä»™å‰‘å¥‡ä¾ ä¼ æ›¾ç»å‡ºç°æ‰€æœ‰æœ‰å­—å¹•çš„åœ°æ–¹ï¼ˆæ¯”å¦‚äººç‰©çš„å¯¹è¯åŒºåŸŸï¼Œä»¥åŠâ€œæ–°çš„æ•…äº‹â€â€œæ—§çš„å›å¿†â€çš„é€‰æ‹©åŒºåŸŸï¼‰å…¨éƒ¨æ˜¯é»‘æ¡†çš„ç°è±¡ã€‚ä»”ç»†é˜…è¯» SDL æ‰‹å†Œåå‘ç° SDL_UpdateRect() å‡½æ•°å®ç°çš„æœ‰ä¸€äº›é—®é¢˜ï¼Œå¯¼è‡´ä¸€ç›´åœ¨å–å±å¹•å·¦ä¸Šè§’çš„ä¸€å°å—çŸ©å½¢æ¥æ›´æ–°åƒç´ ï¼Œé‚£ä¸€éƒ¨åˆ†æ°å¥½æ˜¯é»‘è‰²çš„ã€‚ä¿®æ­£çŸ©å½¢åŒºåŸŸçš„åæ ‡åé—®é¢˜è§£å†³ã€‚\nä»™å‰‘å¥‡ä¾ ä¼ ä¸ SDL_FillRect() SDL_FillRect() çš„å®˜æ–¹æ–‡æ¡£çš„æè¿°æ˜¯å°†ç”»å¸ƒä¸­æŒ‡å®šçŸ©å½¢åŒºåŸŸçš„é¢œè‰²éƒ½ç½®ä¸º colorã€‚å…¶ä¸­çš„å‚æ•° color æ˜¯ä¸€ä¸ª 32 ä½æ•°ã€‚ä½†ä»™å‰‘å¥‡ä¾ ä¼ ä¸­æ˜¯ä½¿ç”¨è°ƒè‰²ç›˜æ¥è¡¨ç¤ºé¢œè‰²çš„ï¼Œpixels é‡Œå­˜æ”¾çš„æ˜¯é¢œè‰²åœ¨è°ƒè‰²ç›˜ä¸­çš„ç´¢å¼•ï¼Œåº”è¯¥æ€ä¹ˆå°†è¿™ä¸ª color èµ‹è¿‡å»å‘¢ï¼Ÿ\nç¬”è€…èµ·åˆä»¥ä¸ºä»™å‰‘ä¸­è°ƒç”¨è¯¥å‡½æ•°æ—¶ä¼ å…¥çš„ color åº”è¯¥æ˜¯ 32 ä½çš„ aaggbbrr æ ¼å¼çš„é¢œè‰²ï¼Œå› æ­¤å°†è°ƒè‰²ç›˜ä¸­çš„æ‰€æœ‰é¢œè‰²å–å‡ºå’Œ color ä¸€ä¸€æ¯”å¯¹ï¼Œä½†å‘ç° color å¹¶ä¸ä¸€å®šåœ¨è°ƒè‰²ç›˜ä¸­ã€‚ç¬”è€…å°è¯•ä½¿ç”¨æ›¼å“ˆé¡¿è·ç¦»æœ€å°çš„é¢œè‰²æ¥ä»£æ›¿ colorï¼Œä½†æ•ˆæœå¾ˆå·®ã€‚ç¬”è€…åˆå°è¯•äº†ä»è°ƒè‰²ç›˜ä¸­éšæœºæŒ‘ä¸€ä¸ªé¢œè‰²ï¼Œå°† color æ›¿æ¢è¿›å»ã€‚è¿™æ ·è™½ç„¶å¯ä»¥è¾¾åˆ°æ­£ç¡®çš„æ•ˆæœï¼Œä½†å­˜åœ¨ä¸€å®šçš„éšæ‚£ã€‚\nç¬”è€…åœ¨é˜…è¯»äº† pal çš„æºç ä¹‹åï¼Œå‘ç°å…¶ä¸­è°ƒç”¨ SDL_FillRect() çš„æ—¶å€™ä¼ é€’çš„ color å‚æ•°éƒ½æ˜¯ 8 ä½äºŒè¿›åˆ¶æ•°ï¼Œæ˜ç™½å…¶å®ä¼ è¿›å»çš„å°±æ˜¯é¢œè‰²çš„è°ƒè‰²ç›˜ç´¢å¼•ï¼Œæ‰€ä»¥ç›´æ¥èµ‹å€¼å³å¯ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"e479e780bba6cd9c03779466bf928b59","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-ics/pa/pa3/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/nju-ics/pa/pa3/","section":"notes","summary":"å®éªŒè¿›åº¦ æˆ‘å®Œæˆäº†æ‰€æœ‰çš„å¿…ç­”é¢˜ï¼Œå¹¶é’ˆå¯¹é€‰åšé¢˜å’Œæ€è€ƒé¢˜ç»™å‡ºäº†è‡ªå·±çš„æƒ³æ³•ã€‚\nå¿…ç­”é¢˜ ç†è§£ä¸Šä¸‹æ–‡ç»“æ„ä½“çš„å‰ä¸–ä»Šç”Ÿ ç‚¹å‡» è¿™é‡Œè·³è½¬åˆ°è§£ç­”ã€‚\nç†è§£ç©¿è¶Šæ—¶ç©ºçš„æ—…ç¨‹ ç‚¹å‡» è¿™é‡Œè·³è½¬åˆ°è§£ç­”ã€‚\nhelloç¨‹åºæ˜¯ä»€ä¹ˆ, å®ƒä»ä½•è€Œæ¥, è¦åˆ°å“ªé‡Œå» ç‚¹å‡» è¿™é‡Œè·³è½¬åˆ°è§£ç­”\nä»™å‰‘å¥‡ä¾ ä¼ ç©¶ç«Ÿå¦‚ä½•è¿è¡Œ è¿è¡Œä»™å‰‘å¥‡ä¾ ä¼ æ—¶ä¼šæ’­æ”¾å¯åŠ¨åŠ¨ç”», åŠ¨ç”»é‡Œä»™é¹¤åœ¨ç¾¤å±±ä¸­é£è¿‡. è¿™ä¸€åŠ¨ç”»æ˜¯é€šè¿‡navy-apps/apps/pal/repo/src/main.cä¸­çš„PAL_SplashScreen()å‡½æ•°æ’­æ”¾çš„. é˜…è¯»è¿™ä¸€å‡½æ•°, å¯ä»¥å¾—çŸ¥ä»™é¹¤çš„åƒç´ ä¿¡æ¯å­˜æ”¾åœ¨æ•°æ®æ–‡ä»¶mgo.mkfä¸­. è¯·å›ç­”ä»¥ä¸‹é—®é¢˜: åº“å‡½æ•°, libos, Nanos-lite, AM, NEMUæ˜¯å¦‚ä½•ç›¸äº’ååŠ©, æ¥å¸®åŠ©ä»™å‰‘å¥‡ä¾ ä¼ çš„ä»£ç ä»mgo.mkfæ–‡ä»¶ä¸­è¯»å‡ºä»™é¹¤çš„åƒç´ ä¿¡æ¯, å¹¶ä¸”æ›´æ–°åˆ°å±å¹•ä¸Š? æ¢ä¸€ç§PAçš„ç»å…¸é—®æ³•: è¿™ä¸ªè¿‡ç¨‹ç©¶ç«Ÿç»å†äº†äº›ä»€ä¹ˆ? (Hint: åˆç†ä½¿ç”¨å„ç§traceå·¥å…·, å¯ä»¥å¸®åŠ©ä½ æ›´å®¹æ˜“åœ°ç†è§£ä»™å‰‘å¥‡ä¾ ä¼ çš„è¡Œä¸º)","tags":null,"title":"PA3 - ç©¿è¶Šæ—¶ç©ºçš„æ—…ç¨‹: æ‰¹å¤„ç†ç³»ç»Ÿ","type":"docs"},{"authors":null,"categories":null,"content":"å®éªŒè¿›åº¦ æˆ‘å®Œæˆäº†æ‰€æœ‰çš„å¿…ç­”é¢˜ï¼Œå¹¶é’ˆå¯¹é€‰åšé¢˜å’Œæ€è€ƒé¢˜ç»™å‡ºäº†è‡ªå·±çš„æƒ³æ³•ã€‚\nå¿…ç­”é¢˜ åˆ†æ—¶å¤šä»»åŠ¡çš„å…·ä½“è¿‡ç¨‹ è¯·ç»“åˆä»£ç , è§£é‡Šåˆ†é¡µæœºåˆ¶å’Œç¡¬ä»¶ä¸­æ–­æ˜¯å¦‚ä½•æ”¯æ’‘ä»™å‰‘å¥‡ä¾ ä¼ å’Œhelloç¨‹åºåœ¨æˆ‘ä»¬çš„è®¡ç®—æœºç³»ç»Ÿ(Nanos-lite, AM, NEMU)ä¸­åˆ†æ—¶è¿è¡Œçš„.\nè¿™é‡Œä¸»è¦å™è¿°ä» hello ç”¨æˆ·ç¨‹åºåˆ‡æ¢åˆ° pal çš„è¿‡ç¨‹ã€‚åœ¨æŠ¢å å¼å¤šä»»åŠ¡ç³»ç»Ÿä¸­ï¼Œhello ç›¸å½“äºä¸€ä¸ªâ€œæ¶æ„ç”¨æˆ·ç¨‹åºâ€ï¼Œå› ä¸ºå®ƒä¸ä¼šä¸»åŠ¨ä½¿ç”¨ yield() æ¥è®©æ“ä½œç³»ç»Ÿåˆ‡æ¢ç¨‹åºã€‚ä½†å®ç°äº†æ—¶é’Ÿä¸­æ–­ä¹‹åæˆ‘ä»¬å¯ä»¥å¼ºåˆ¶ hello çš„æŒ‚èµ·ã€‚\næ¯ä¸€æ¡æŒ‡ä»¤æ‰§è¡Œç»“æŸæ—¶ï¼Œnemu çš„ cpu_exec() ä¸­éƒ½ä¼šè°ƒç”¨ timer_interrupt() å‡½æ•°æ¥æ£€æŸ¥ CPU çš„ INTR å¼•è„šæœ‰æ²¡æœ‰è¢«æ‹‰é«˜ã€‚å¦‚æœè¢«æ‹‰é«˜äº†è¯´æ˜æœ‰è®¾å¤‡å‘å‡ºäº†ä¸­æ–­è¯·æ±‚ï¼ˆåœ¨ PA ä¸­åªæœ‰æ—¶é’Ÿä¸­æ–­è¯·æ±‚ï¼‰ï¼Œæ­¤æ—¶ CPU ä¼šå°† mstatus å¯„å­˜å™¨çš„ MIE ä½ç½®é›¶ï¼ˆé˜²æ­¢ä¸­æ–­åµŒå¥—ï¼‰ï¼Œç„¶åè¿›å…¥ nanos-lite çš„ä¸­æ–­/å¼‚å¸¸å¤„ç†ç¨‹åº trap.Sã€‚\nåœ¨ trap.S ä¸­ï¼Œnanos-lite é¦–å…ˆä¼šå°† sp æŒ‡é’ˆåˆ‡æ¢åˆ° hello ç”¨æˆ·è¿›ç¨‹çš„å†…æ ¸æ ˆï¼Œåœ¨å†…æ ¸æ ˆä¸Šä¿å­˜ hello è¿›ç¨‹çš„ä¸Šä¸‹æ–‡ï¼Œå°† mscratch å’Œ c-\u0026gt;np ç­‰ä¿¡æ¯è®¾ç½®å¥½ä¹‹åï¼Œè¿›å…¥ __am_irq_handle() å‡½æ•°ã€‚\nåœ¨ __am_irq_handle() å‡½æ•°ä¸­ï¼Œnanos-lite å‘ç° mcause å¯„å­˜å™¨ä¸­çš„äº‹ä»¶ç¼–å·æ˜¯ 0x80000007ï¼Œäºæ˜¯æ ‡è®°è¯¥äº‹ä»¶ä¸ºæ—¶é’Ÿä¸­æ–­ï¼Œè°ƒç”¨ do_event() å‡½æ•°ã€‚do_event() å‡½æ•°ä¸­è°ƒç”¨äº† shedule() å‡½æ•°ï¼Œschedule() å‡½æ•°å°† current-\u0026gt;cp æŒ‡å‘åˆšæ‰ä¿å­˜åœ¨ hello å†…æ ¸æ ˆä¸Šçš„ hello ä¸Šä¸‹æ–‡ï¼Œå°† current æŒ‡é’ˆæŒ‡å‘ pal è¿›ç¨‹çš„ pcbï¼Œå¹¶è¿”å› pal è¿›ç¨‹å†…æ ¸æ ˆä¸Šçš„ä¸Šä¸‹æ–‡ç»“æ„ä½“ï¼ˆè¯¥ç»“æ„ä½“å¯èƒ½æ˜¯ context_uload() æ—¶åˆ›å»ºçš„åˆå§‹ç»“æ„ä½“ï¼Œä¹Ÿå¯èƒ½æ˜¯å‰ä¸€æ¬¡è¿›ç¨‹åˆ‡æ¢æ—¶ä¿å­˜çš„ç»“æ„ä½“ï¼‰ã€‚__am_irq_handle() å‡½æ•°æœ€ç»ˆä¼šè¿”å› pal è¿›ç¨‹çš„ä¸Šä¸‹æ–‡ç»“æ„ä½“ã€‚\nå›åˆ° trap.S ä¸­ä»¥åï¼Œnanos-lite ä¼šæ¢å¤ pal è¿›ç¨‹çš„ä¸Šä¸‹æ–‡ï¼Œå¹¶ä¸”æ ¹æ® c-\u0026gt;np å°†æ ˆæŒ‡é’ˆä» pal è¿›ç¨‹çš„å†…æ ¸æ ˆç§»åˆ° pal è¿›ç¨‹çš„ç”¨æˆ·æ ˆã€‚æ‰§è¡Œå®Œ mret æŒ‡ä»¤ä¹‹åï¼Œnanos-lite å°±åˆ‡æ¢åˆ°äº† pal çš„ä»£ç ç»§ç»­æ‰§è¡Œï¼ˆmret æŒ‡ä»¤ä¼šå°† mstatus çš„ MIE ä½é‡æ–°æ‰“å¼€ï¼Œä»¥æ¥æ”¶ä¸­æ–­ï¼‰ã€‚\nç†è§£è®¡ç®—æœºç³»ç»Ÿ å°è¯•åœ¨Linuxä¸­ç¼–å†™å¹¶è¿è¡Œä»¥ä¸‹ç¨‹åº:\nint main() { char *p = \u0026quot;abc\u0026quot;; p[0] = 'A'; return 0; } ä½ ä¼šçœ‹åˆ°ç¨‹åºå› ä¸ºå¾€åªè¯»å­—ç¬¦ä¸²è¿›è¡Œå†™å…¥è€Œè§¦å‘äº†æ®µé”™è¯¯. è¯·ä½ æ ¹æ®å­¦ä¹ çš„çŸ¥è¯†å’Œå·¥å…·, ä»ç¨‹åº, ç¼–è¯‘å™¨, é“¾æ¥å™¨, è¿è¡Œæ—¶ç¯å¢ƒ, æ“ä½œç³»ç»Ÿå’Œç¡¬ä»¶ç­‰è§†è§’åˆ†æ\u0026quot;å­—ç¬¦ä¸²çš„å†™ä¿æŠ¤æœºåˆ¶æ˜¯å¦‚ä½•å®ç°çš„\u0026quot;. æ¢å¥è¯è¯´, ä¸Šè¿°ç¨‹åºåœ¨æ‰§è¡Œp[0] = 'A'çš„æ—¶å€™, è®¡ç®—æœºç³»ç»Ÿç©¶ç«Ÿå‘ç”Ÿäº†ä»€ä¹ˆè€Œå¼•å‘æ®µé”™è¯¯? è®¡ç®—æœºç³»ç»Ÿåˆæ˜¯å¦‚ä½•ä¿è¯æ®µé”™è¯¯ä¼šå‘ç”Ÿ? å¦‚ä½•ä½¿ç”¨åˆé€‚çš„å·¥å…·æ¥è¯æ˜ä½ çš„æƒ³æ³•?\nå­—ç¬¦ä¸² \u0026ldquo;abc\u0026rdquo; åœ¨ç¼–è¯‘çš„æ—¶å€™ä¼šè¢«æ”¾å…¥ ELF æ–‡ä»¶çš„åªè¯»æ•°æ®æ®µï¼Œå¹¶åœ¨é“¾æ¥è¿è¡Œçš„æ—¶å€™ä½äºåªè¯»ä»£ç æ®µã€‚é«˜çº§è¯­è¨€ä¸­çš„ p[0] = 'A' å®é™…ä¸Šæ˜¯ä¸€æ¬¡è®¿å­˜å†™å…¥æ“ä½œï¼Œå¯¹åº”çš„æ±‡ç¼–ä»£ç ä¸º\n0000000000000000 \u0026lt;main\u0026gt;: 0: f3 0f 1e fa endbr64 4: 55 push %rbp 5: 48 89 e5 mov %rsp,%rbp 8: 48 8d 05 00 00 00 00 lea 0x0(%rip),%rax # f \u0026lt;main+0xf\u0026gt; f: 48 89 45 f8 mov %rax,-0x8(%rbp) 13: 48 8b 45 f8 mov -0x8(%rbp),%rax 17: c6 00 41 movb $0x41,(%rax) # p[0] = 'A' 1a: b8 00 00 00 00 mov $0x0,%eax 1f: 5d pop %rbp 20: c3 ret æ‰§è¡Œåˆ° \u0026lt;main+0x17\u0026gt; è¿™æ¡æŒ‡ä»¤æ—¶ï¼Œç¡¬ä»¶ä¸­çš„ MMU ä¼šæ£€æŸ¥å½“å‰è¿›ç¨‹çš„æƒé™æ˜¯å¦å¯ä»¥è®¿é—®è¿™ä¸€å†…å­˜åŒºåŸŸã€‚ç”±äº \u0026ldquo;abc\u0026rdquo; æ˜¯åªè¯»æ•°æ®ï¼Œæ‰€ä»¥å‘ç”Ÿäº†è¶Šæƒè¡Œä¸ºã€‚è®¿é—®éæ³•åœ°å€å MMU ä¼šä¿®æ”¹ä¸€äº›ç‰¹æƒå¯„å­˜å™¨çš„å€¼è®°å½•ä¿¡æ¯ï¼Œç„¶åè½¬åˆ°æ“ä½œç³»ç»Ÿçš„å¼‚å¸¸å¤„ç†ç¨‹åºã€‚æ“ä½œç³»ç»Ÿä¼šå‘ç”¨æˆ·è¿›ç¨‹å‘é€ä¸€ä¸ª SIGSEGV ä¿¡å·ï¼Œè¡¨ç¤ºå‘ç”Ÿäº†æ®µé”™è¯¯ã€‚ç”¨æˆ·è¿›ç¨‹æ”¶åˆ° SIGSEGV ä¿¡å·åçš„é»˜è®¤åŠ¨ä½œæ˜¯ç»ˆæ­¢ç¨‹åºè¿è¡Œï¼Œä½†å®ƒä¼šç”Ÿæˆä¸€ä¸ªæ ¸å¿ƒæ–‡ä»¶ä»¥å¸®åŠ©è°ƒè¯•ï¼Œä¹Ÿå°±æ˜¯æ‰€è°“çš„ (core dumped æ ¸å¿ƒå·²è½¬å‚¨)ã€‚\næˆ‘ä»¬å¯ä»¥åœ¨ç”¨æˆ·ç¨‹åºä¸­æ³¨å†Œä¸€ä¸ªä¿¡å·å¤„ç†å‡½æ•°æ¥æ•æ‰ SIGSEGV ä¿¡å·ï¼Œä»£ç å¦‚ä¸‹ï¼š\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void signal_handler(int signum) { if (signum == 11) printf(\u0026quot;Signal SIGSEGV captured\\n\u0026quot;); exit(0); } int main() { signal(SIGSEGV, signal_handler); char *p = \u0026quot;abc\u0026quot;; p[0] = 'A'; return 0; } ç¼–è¯‘ã€è¿è¡Œè¯¥ç¨‹åºåä¸ä¼šæŠ¥æ®µé”™è¯¯ï¼Œè€Œä¼šæ‰“å° Signal SIGSEGV captured ä¹‹åæ­£å¸¸é€€å‡ºã€‚è¿™å¯ä»¥è¯æ˜ç”¨æˆ·è¿›ç¨‹ç¡®å®æ¥æ”¶åˆ°äº† SIGSEGV ä¿¡å·ã€‚\næˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡ gdb æ¥æ£€æµ‹ SIGSEGV ä¿¡å·ï¼šåœ¨ gdb ä¸­ä½¿ç”¨ layout asm æ‰“å¼€æ±‡ç¼–ä»£ç ï¼Œä¸€æ¡ä¸€æ¡æ‰§è¡Œï¼Œåœ¨æ‰§è¡Œåˆ° movb è¯­å¥æ—¶ä¼šæ˜¾ç¤º SIGSEGV ä¿¡å·ã€‚\nä¸ºäº†çœ‹åˆ°æ“ä½œç³»ç»Ÿæ‰§è¡Œè¯¥ç¨‹åºæ—¶ç»å†çš„è¿‡ç¨‹ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ strace å·¥å…·æ¥æŸ¥çœ‹æ‰§è¡Œ ./a.out æ—¶ä½¿ç”¨çš„æ‰€æœ‰ç³»ç»Ÿè°ƒç”¨ã€‚ï¼ˆæ³¨æ„ï¼šstrace å·¥å…·é»˜è®¤å°†ä¿¡æ¯è¾“å‡ºåˆ°æ ‡å‡†é”™è¯¯æµï¼Œæ‰€ä»¥å¦‚æœæƒ³ç”¨ less å·¥å…·æ¥æŸ¥çœ‹çš„è¯ï¼Œéœ€è¦å…ˆå°†è¾“å‡ºé‡å®šå‘åˆ°æ ‡å‡†è¾“å‡ºæµï¼Œä½¿ç”¨å‘½ä»¤ strace ./a.out 2\u0026gt;\u0026amp;1 | lessã€‚ï¼‰\nexecve(\u0026quot;./a.out\u0026quot;, [\u0026quot;./a.out\u0026quot;], 0x7ffec38443f0 /* 67 vars */) = 0 brk(NULL) = 0x555ca9bfc000 arch_prctl(0x3001 /* ARCH_??? */, 0x7ffd43e30600) = -1 EINVAL (Invalid argument) access(\u0026quot;/etc/ld.so.preload\u0026quot;, R_OK) = -1 ENOENT (No such file or directory) openat(AT_FDCWD, \u0026quot;/etc/ld.so.cache\u0026quot;, O_RDONLY|O_CLOEXEC) = 3 newfstatat(3, \u0026quot;\u0026quot;, {st_mode=S_IFREG|0644, st_size=76978, ...}, AT_EMPTY_PATH) = 0 mmap(NULL, 76978, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fe701222000 close(3) = 0 openat(AT_FDCWD, \u0026quot;/lib/x86_64-linux-gnu/libc.so.6\u0026quot;, O_RDONLY|O_CLOEXEC) = 3 read(3, \u0026quot;\\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\u0026gt;\\0\\1\\0\\0\\0\\240\\206\\2\\0\\0\\0\\0\\0\u0026quot;..., 832) = 832 pread64(3, \u0026quot;\\6\\0\\0\\0\\4\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0\u0026quot;..., 784, 64) = 784 pread64(3, \u0026quot;\\4\\0\\0\\0 \\0\\0\\0\\5\\0\\0\\0GNU\\0\\2\\0\\0\\300\\4\\0\\0\\0\\3\\0\\0\\0\\0\\0\\0\\0\u0026quot;..., 48, 848) = 48 pread64(3, \u0026quot;\\4\\0\\0\\0\\24\\0\\0\\0\\3\\0\\0\\0GNU\\0+H)\\227\\201T\\214\\233\\304R\\352\\306\\3379\\220%\u0026quot;..., 68, 896) = 68 newfstatat(3, \u0026quot;\u0026quot;, {st_mode=S_IFREG|0755, st_size=1983576, ...}, AT_EMPTY_PATH) = 0 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fe701220000 pread64(3, \u0026quot;\\6\\0\\0\\0\\4\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0\u0026quot;..., 784, 64) = 784 mmap(NULL, 2012056, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fe701034000 mmap(0x7fe70105a000, 1486848, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x26000) = 0x7fe70105a000 mmap(0x7fe7011c5000, 311296, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x191000) = 0x7fe7011c5000 mmap(0x7fe701211000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1dc000) = 0x7fe701211000 mmap(0x7fe701217000, 33688, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fe701217000 close(3) = 0 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fe701032000 arch_prctl(ARCH_SET_FS, 0x7fe701221580) = 0 mprotect(0x7fe701211000, 12288, PROT_READ) = 0 mprotect(0x555ca947c000, 4096, PROT_READ) = 0 mprotect(0x7fe701267000, 8192, PROT_READ) = 0 munmap(0x7fe701222000, 76978) = 0 rt_sigaction(SIGHUP, {sa_handler=0x555ca947a189, sa_mask=[HUP], sa_flags=SA_RESTORER|SA_RESTART, sa_restorer=0x7fe701075040}, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0 --- SIGSEGV {si_signo=SIGSEGV, si_code=SEGV_ACCERR, si_addr=0x555ca947b01c} --- +++ killed by SIGSEGV (core dumped) +++ Segmentation fault (core dumped) è™½ç„¶ç¬”è€…ä¸èƒ½çœ‹æ‡‚æ‰€æœ‰çš„ç³»ç»Ÿè°ƒç”¨ï¼Œä½†å¤§æ¦‚å¯ä»¥çœ‹åˆ°ä¸€äº›æ¯”è¾ƒæ ¸å¿ƒçš„æ­¥éª¤ï¼Œæ¯”å¦‚ä½¿ç”¨ execve ç³»ç»Ÿè°ƒç”¨è½¬åˆ° a.out ç¨‹åºæ‰§è¡Œï¼Œä¸­é—´çš„ mmap ç³»ç»Ÿè°ƒç”¨è¯•å›¾è®¿é—®äº†ä¸€äº›æœ‰ç€ MAP_DENYWRITE å±æ€§çš„ä¸œè¥¿ã€‚æœ€åå‘å‡ºäº† SIGSEGV ä¿¡å·ï¼Œå¹¶ç»™å‡ºäº†è§¦å‘è¯¥ä¿¡å·çš„æŒ‡ä»¤åœ°å€ã€‚\nä»¥ä¸‹æ˜¯æˆ‘çš„è‡ªç”±æŠ¥å‘Šå†…å®¹ï¼Œæˆ‘åœ¨åšå®éªŒçš„è¿‡ç¨‹ä¸­è¯¦ç»†è®°å½•äº†è‡ªå·±é‡åˆ°çš„æ‰€æœ‰é—®é¢˜å’ŒæŸ¥é˜…çš„æ‰€æœ‰èµ„æ–™ã€‚è¿™äº›ç¬”è®°æŒ‰ç…§ç« èŠ‚æ’åˆ—ï¼Œæ¯ç« é€šå¸¸æœ‰ä¸¤ä¸ªéƒ¨åˆ†\næ€è€ƒé¢˜ï¼šåŒ…å«ç¬”è€…é’ˆå¯¹æ€è€ƒé¢˜æŸ¥é˜…çš„èµ„æ–™å’Œæˆ‘å°è¯•ç»™å‡ºçš„ç­”æ¡ˆã€‚ è¡¥å……ï¼šè¿™é‡Œçš„å†…å®¹æ˜¯æ²¡æœ‰åœ¨è®²ä¹‰ä¸­æåŠçš„é—®é¢˜ï¼Œä»¥åŠè®²ä¹‰ä¸­å»ºè®®è‡ªå­¦çš„ä¸œè¥¿ã€‚ å¤šé“ç¨‹åº æ€è€ƒé¢˜ ä¸ºä»€ä¹ˆéœ€è¦ä½¿ç”¨ä¸åŒçš„æ ˆç©ºé—´? å¦‚æœä¸åŒçš„è¿›ç¨‹å…±äº«åŒä¸€ä¸ªæ ˆç©ºé—´, ä¼šå‘ç”Ÿä»€ä¹ˆå‘¢?\næ¯”å¦‚ä¸åŒçš„è¿›ç¨‹å¯ä»¥äº’ç›¸ä¿®æ”¹åˆ«äººçš„æ ˆçš„å†…å®¹ï¼Œè¿™æ ·åŸå…ˆçš„è¿›ç¨‹å°±å¯èƒ½å´©æºƒã€‚\nmips32 å’Œ riscv32 çš„è°ƒç”¨çº¦å®š æˆ‘ä»¬æ²¡æœ‰ç»™å‡ºmips32å’Œriscv32çš„è°ƒç”¨çº¦å®š, ä½ éœ€è¦æŸ¥é˜…ç›¸åº”çš„ABIæ‰‹å†Œ. å½“ç„¶, ä½ ä¹Ÿå¯ä»¥è‡ªå·±åŠ¨æ‰‹å®è·µæ¥æ€»ç»“ä¼ å‚çš„è§„åˆ™.\nç¬”è€…é€‰æ‹©çš„æ¶æ„æ˜¯ riscv32ï¼Œæ‰€ä»¥åœ¨æ­¤ç®€å•åœ°åˆ—ä¸¾ riscv32 çš„è°ƒç”¨çº¦å®šï¼šriscv32 ä½¿ç”¨å¯„å­˜å™¨æ¥ä¼ é€’å‚æ•°å’Œè¿”å›å€¼ã€‚a0 a1 a2 ç­‰å¯„å­˜å™¨åˆ†åˆ«å­˜å‚¨äº†ç¬¬ä¸€ï¼Œç¬¬äºŒï¼Œç¬¬ä¸‰ä¸ªå‚æ•°ï¼Œä»¥æ­¤ç±»æ¨ï¼›a0 å¯„å­˜å™¨å­˜å‚¨äº†è¿”å›å€¼ã€‚\nä¸€å±±ä¸èƒ½è—äºŒè™? å°è¯•æŠŠhello_fun()æ¢æˆNavyä¸­çš„hello:\n-context_kload(\u0026amp;pcb[0], (void *)hello_fun, NULL); +context_uload(\u0026amp;pcb[0], \u0026quot;/bin/hello\u0026quot;); context_uload(\u0026amp;pcb[1], \u0026quot;/bin/pal\u0026quot;); ä½ å‘ç°äº†ä»€ä¹ˆé—®é¢˜? ä¸ºä»€ä¹ˆä¼šè¿™æ ·? æ€è€ƒä¸€ä¸‹, ç­”æ¡ˆä¼šåœ¨ä¸‹ä¸€é˜¶æ®µæ­æ™“!\nç¨‹åºè§¦å‘äº†æ®µé”™è¯¯ã€‚ä¸¤ä¸ªç”¨æˆ·ç¨‹åºä½¿ç”¨çš„æ˜¯ç›¸åŒçš„ç”¨æˆ·æ ˆï¼Œä»£ç ä¹Ÿä¼šåŠ è½½åˆ°åŒæ ·çš„ä½ç½®ï¼Œå®ƒä»¬ä¼šç›¸äº’è¦†ç›–ï¼Œä»è€Œå¯¼è‡´é”™è¯¯ã€‚\nä¸ºä»€ä¹ˆå°‘äº†ä¸€ä¸ªconst? åœ¨main()å‡½æ•°ä¸­, argvå’Œenvpçš„ç±»å‹æ˜¯char * [], è€Œåœ¨execve()å‡½æ•°ä¸­, å®ƒä»¬çš„ç±»å‹åˆ™æ˜¯char *const []. ä»è¿™ä¸€å·®å¼‚æ¥çœ‹, main()å‡½æ•°ä¸­argvå’Œenvpæ‰€æŒ‡å‘çš„å­—ç¬¦ä¸²æ˜¯å¯å†™çš„, ä½ çŸ¥é“ä¸ºä»€ä¹ˆä¼šè¿™æ ·å—?\næ ¹æ® C99 æ‰‹å†Œä¸­çš„è§„å®šï¼š\nProgram Startup The parameters argc and argv and the strings pointed to by the argv array shall be modifiable by the program, and retain their last-stored values between program startup and program termination.\nSTFW å¾—å‡ºçš„ç»“è®ºæ˜¯ï¼Œè¿™æ˜¯ä¸€ä¸ªå†å²é—ç•™é—®é¢˜ã€‚æ—©æœŸçš„ C è¯­è¨€æ²¡æœ‰ constï¼Œåæ¥ C++ ä¸ºäº†å…¼å®¹ä¹‹å‰çš„ C ç¨‹åºï¼Œä¹Ÿæ²¡æœ‰åŠ ä¸Šè¿™ä¸ª constã€‚æœ‰ä¸€äº›ç¨‹åºæ­£æ˜¯åˆ©ç”¨ argv[] çš„å¯ä¿®æ”¹æ€§è¿›è¡Œå·¥ä½œçš„ï¼Œä¾‹å¦‚ï¼š\n// print out all the arguments: while (--argc) std::cout \u0026lt;\u0026lt; *++argv \u0026lt;\u0026lt; std::endl; æ­¤å¤–ï¼Œä¸€äº› UNIX APIï¼Œæ¯”å¦‚ getoptï¼Œç¡®å®ä¼šä¿®æ”¹ argv[] çš„å†…å®¹ã€‚ä½† argv[] ä½œä¸ºä¸€ä¸ªæ ˆä¸Šçš„å±€éƒ¨å˜é‡ï¼Œåœ¨å®šä¹‰çš„æ—¶å€™åŠ ä¸Š const ä¹Ÿæ˜¯æ— ä¼¤å¤§é›…çš„ã€‚ï¼ˆstackoverflow ä¸Šçš„ è¿™ä¸ªå›ç­”æ¯”è¾ƒè¯¦ç»†ï¼‰\nè¡¥å…… è°ƒè¯•å¿ƒå¾— å­—ç¬¦ä¸²çš„å¤åˆ¶æœ€å¥½ä½¿ç”¨ strcpy å‡½æ•°ï¼Œå®ƒä¼šå¸®ä½ å°†å­—ç¬¦ä¸²æœ«å°¾çš„ \\0 ä¹Ÿä¸€å¹¶å¤åˆ¶è¿‡å»ã€‚å¦‚æœæƒ³è¦ä½¿ç”¨ memcpy æ¥å¤åˆ¶çš„è¯ï¼Œé•¿åº¦ä¸€å®šè¦è®¾ç½®æˆ strlen(src)+1 ï¼Œå¦åˆ™ä¼šæ¼å¤åˆ¶æœ«å°¾çš„ \\0 ä»è€Œå¯¼è‡´å¥‡æ€ªçš„åæœã€‚\nå…³äºç”¨æˆ·ç¨‹åºå‚æ•°çš„é”™è¯¯ ç¬”è€…åœ¨å®ç°äº† nterm çš„å†…å»º shell çš„å‚æ•°ä¼ é€åŠŸèƒ½ä¹‹åï¼Œåœ¨ä½¿ç”¨å‘½ä»¤ pal --skip æ¥è·³è¿‡ä»™å‰‘å¥‡ä¾ ä¼ çš„åŠ¨ç”»æ—¶å‘ç°æ— æ•ˆã€‚ç®€å•æ’æŸ¥ä¹‹åå‘ç°å­˜å‚¨å‚æ•°å­—ç¬¦ä¸²çš„å†…å­˜åœ¨ä¸€ä¸ªå¥‡ç‰¹çš„æ—¶åˆ»è¢«æ”¹å†™äº†ã€‚ä»”ç»†æ’æŸ¥ä¹‹åå‘ç°ï¼Œè¿™äº›å‚æ•°å­—ç¬¦ä¸²æ˜¯è¢«ä»™å‰‘å¥‡ä¾ ä¼ ç”¨æˆ·ç¨‹åºæ”¹å†™çš„â€”â€”è¿™å…¶ä¸­æœ‰ä¸€äº›æœºç¼˜å·§åˆï¼šç¬”è€…åœ¨ nterm ä¸­å®šä¹‰äº†ä¸€ä¸ªæ•°ç»„æ¥å­˜æ”¾å‚æ•°å­—ç¬¦ä¸²ï¼Œå› æ­¤å‚æ•°å­—ç¬¦ä¸²çš„å†…å®¹ä½œä¸ºå®¢æˆ·ç¨‹åºçš„ä¸€éƒ¨åˆ†ï¼Œåœ¨ nterm è¿è¡Œæ—¶ä¼šè¢«åŠ è½½åˆ° 0x83000000 é™„è¿‘ã€‚ç¬”è€…åˆšå¼€å§‹å®ç°çš„ loader å‡½æ•°åœ¨åˆ‡æ¢ç”¨æˆ·ç¨‹åºæ—¶ï¼Œä¼šå…ˆåŠ è½½æ–°çš„ç”¨æˆ·ç¨‹åºï¼Œå†åœ¨ç”¨æˆ·æ ˆä¸­å®‰æ”¾ç”¨æˆ·ç¨‹åºçš„å‚æ•°ï¼Œè¿™å¯¼è‡´ pal ç¨‹åºåœ¨åŠ è½½åˆ° 0x83000000 é™„è¿‘æ—¶ç›´æ¥è¦†ç›–äº† nterm ä¸­è¿˜æ²¡æ¥å¾—åŠæ‹¿å‡ºæ¥çš„å‚æ•°å­—ç¬¦ä¸²ã€‚å› æ­¤å°†è¿™ä¸¤ä¸ªæ­¥éª¤æ¢ä¸ªé¡ºåºâ€”â€”å…ˆæŠŠå‚æ•°å­—ç¬¦ä¸²æ”¾åˆ°ç”¨æˆ·æ ˆé‡Œï¼Œå†åŠ è½½ç¨‹åºå³å¯ã€‚\nè¿™ä¸ªé—®é¢˜çš„å‘ç”Ÿå½’æ ¹ç»“åº•åœ¨äºä¸åŒçš„ç”¨æˆ·ç¨‹åºä½¿ç”¨äº†åŒä¸€æ®µç‰©ç†å†…å­˜æ¥è¿›è¡Œå·¥ä½œã€‚åœ¨å®ç°äº†è™šæ‹Ÿå†…å­˜ä¹‹ååº”è¯¥å°±ä¸ä¼šæœ‰è¿™ä¸ªé—®é¢˜ã€‚\nå…³äºæ·»åŠ  busybox ä¹‹åçš„é”™è¯¯ ç¬”è€…åœ¨æ·»åŠ äº†busybox ç”¨æˆ·ç¨‹åºä¹‹åï¼Œnanos-lite ç›´æ¥å´©æºƒã€‚æ£€æŸ¥å †åŒºçš„èŒƒå›´åå‘ç°ï¼Œheap.start æ­¤æ—¶å·²ç»åˆ°äº† 0x83000000 ä¹‹åï¼Œå› æ­¤åŠ è½½ç”¨æˆ·ç¨‹åºæ—¶ç”¨æˆ·ç¨‹åºçš„ä»£ç ä¼šç›´æ¥è¦†ç›–ç”¨æˆ·æ ˆçš„å†…å®¹ã€‚\nè¿™è¯´æ˜ ramdisk.img çš„å¤§å°çš„ä¸Šé™å¹¶ä¸æ˜¯ 48MBï¼Œè€Œæ˜¯æ›´å°çš„ä¸€ä¸ªé˜ˆå€¼ã€‚å› ä¸º heap.start è€ƒè™‘åˆ°ä¸€äº›å¯¹é½åŸå› å¹¶ä¸æ˜¯ç´§è´´ç€ ramdisk_end è®¾ç½®çš„ã€‚\nç¬”è€…åœ¨ nslider ç”¨æˆ·ç¨‹åºä¸­åˆ æ‰äº†å‡ å¼ å›¾ç‰‡ï¼Œå°† ramdisk.img çš„å¤§å°é™åˆ° 37MB ä¹‹åï¼Œæ¢å¤æ­£å¸¸ã€‚\nè™šå®äº¤é”™çš„é­”æ³• æ€è€ƒé¢˜ [äºŒå‘¨ç›®] å®ç°åŸºäºPIEçš„loader å¤©ä¸‹å¹¶æ²¡æœ‰å…è´¹çš„åˆé¤, PIEä¹‹æ‰€ä»¥èƒ½åšåˆ°ä½ç½®æ— å…³, å…¶å®æ˜¯è¦ä¾èµ–äºç¨‹åºä¸­ä¸€ä¸ªå«GOT(global offset table, å…¨å±€åç§»é‡è¡¨)çš„æ•°æ®ç»“æ„. è¦æ­£ç¡®è¿è¡ŒPIE, åŠ è½½å™¨éœ€è¦åœ¨åŠ è½½ç¨‹åºçš„æ—¶å€™å¾€GOTä¸­å¡«å†™æ­£ç¡®çš„å†…å®¹.\næœ‰å…´è¶£çš„åŒå­¦å¯ä»¥è®©Nanos-liteçš„loaderæ”¯æŒPIE, å½“ç„¶è¿™éœ€è¦äº†è§£ä¸€äº›ELFç›¸å…³çš„ç»†èŠ‚, å…·ä½“ç»†èŠ‚å¯ä»¥å‚è€ƒABIæ‰‹å†Œ.\nç•™å‘ï¼ŒäºŒå‘¨ç›®å†åšã€‚\nç¬”è€…è™½ç„¶è¿˜æ²¡æœ‰å®ç°åŸºäº PIE çš„ loaderï¼Œä½†å­¦ä¹ äº†ä¸€ä¸‹åŠ¨æ€åŠ è½½çš„åŸºæœ¬åŸç†ã€‚ä»¥ä¸‹é¢çš„ç¨‹åºä¸ºä¾‹ï¼š\nextern int foo; int func(void) { return foo; } åœ¨ amd64 æ¶æ„ä¸‹ï¼Œè®¿é—®å˜é‡ foo çš„æ ¸å¿ƒè¯­å¥æ˜¯\nmov 0x200271(%rip), %rax # 200828 200828 å¤„æ˜¯ GOT çš„ä¸€ä¸ªè¡¨é¡¹ï¼š\nOffset Info Type Sym. Value Sym. Name + Addend [...] 000000200828 000400000006 R_X86_64_GLOB_DAT 0000000000000000 foo + 0 åŠ¨æ€åŠ è½½å™¨åœ¨åŠ è½½åŠ¨æ€é“¾æ¥åº“æ—¶ï¼Œä¼šå¾€ GOT ä¸­å¡«å†™ç›¸å…³çš„è¡¨é¡¹ã€‚\nåœ¨ i386 æ¶æ„ä¸­æ²¡æœ‰ç±»ä¼¼ %rip è¿™æ ·çš„å¯„å­˜å™¨ï¼Œæ— æ³•ç›´æ¥å¾—çŸ¥å½“å‰æŒ‡ä»¤çš„ä½ç½®ï¼Œå› æ­¤é€šå¸¸ä¼šä½¿ç”¨ç±»ä¼¼äºä¸‹é¢è¿™æ ·çš„ç•¥å¸¦ tricky çš„ä»£ç ï¼š\n0000040c \u0026lt;function\u0026gt;: 40c: 55 push %ebp 40d: 89 e5 mov %esp,%ebp 40f: e8 0e 00 00 00 call 422 \u0026lt;__i686.get_pc_thunk.cx\u0026gt; 414: 81 c1 5c 11 00 00 add $0x115c,%ecx 41a: 8b 81 18 00 00 00 mov 0x18(%ecx),%eax 420: 5d pop %ebp 421: c3 ret 00000422 \u0026lt;__i686.get_pc_thunk.cx\u0026gt;: 422: 8b 0c 24 mov (%esp),%ecx 425: c3 ret åœ¨ 40f å¤„è°ƒç”¨äº†ä¸€ä¸ªå‡½æ•° __i686.get_pc_thunk.cx\u0026gt;ï¼Œè¿™ä¸ªå‡½æ•°å°† call çš„è¿”å›åœ°å€ï¼ˆä¹Ÿå°±æ˜¯ 414ï¼‰ä¿å­˜åˆ°äº† %ecx å¯„å­˜å™¨ä¸­ï¼Œä»è€Œå˜å‘å®ç°äº† get_pc çš„åŠŸèƒ½ã€‚\nè¶…è¶Šå®¹é‡çš„ç•Œé™ æ€è€ƒé¢˜ è™šå­˜ç®¡ç†ä¸­PICçš„å¥½å¤„ æˆ‘ä»¬ä¹‹å‰æåˆ°, PICçš„å…¶ä¸­ä¸€ä¸ªå¥½å¤„æ˜¯å¯ä»¥å°†ä»£ç åŠ è½½åˆ°ä»»æ„å†…å­˜ä½ç½®æ‰§è¡Œ. å¦‚æœé…åˆè™šå­˜ç®¡ç†, PICè¿˜æœ‰ä»€ä¹ˆæ–°çš„å¥½å¤„å‘¢? (Hint: åŠ¨æ€åº“å·²ç»åœ¨äº«å—è¿™äº›å¥½å¤„äº†)\nPIC çš„å¥½å¤„åœ¨äºï¼Œæˆ‘ä»¬ä¸éœ€è¦å°† PIC åå¤è£…è¿›å†…å­˜ã€‚æ¯”å¦‚ç¬¬ä¸€ä¸ªè¿›ç¨‹å°†åŠ¨æ€åº“æ”¾è¿›äº†å†…å­˜ï¼Œé‚£ä¹ˆç¬¬äºŒä¸ªè¿›ç¨‹å¦‚æœä¹Ÿè¦ç”¨åŠ¨æ€åº“ï¼Œå®ƒåªè¦æ‰¾ä¸€ä¸‹å†…å­˜é‡Œæœ‰æ²¡æœ‰åŠ¨æ€åº“çš„é¡µé¢ï¼Œå¦‚æœæœ‰å°±å°†è‡ªå·±çš„é¡µè¡¨ä¸­å…³äºåŠ¨æ€åº“çš„é‚£é¡¹ç›´æ¥æŒ‡å‘å·²æœ‰çš„åŠ¨æ€åº“é¡µé¢å³å¯ã€‚\nç†è§£åˆ†é¡µç»†èŠ‚ i386ä¸æ˜¯ä¸€ä¸ª32ä½çš„å¤„ç†å™¨å—, ä¸ºä»€ä¹ˆè¡¨é¡¹ä¸­çš„åŸºåœ°å€ä¿¡æ¯åªæœ‰20ä½, è€Œä¸æ˜¯32ä½? æ‰‹å†Œä¸Šæåˆ°è¡¨é¡¹(åŒ…æ‹¬CR3)ä¸­çš„åŸºåœ°å€éƒ½æ˜¯ç‰©ç†åœ°å€, ç‰©ç†åœ°å€æ˜¯å¿…é¡»çš„å—? èƒ½å¦ä½¿ç”¨è™šæ‹Ÿåœ°å€? ä¸ºä»€ä¹ˆä¸é‡‡ç”¨ä¸€çº§é¡µè¡¨? æˆ–è€…è¯´é‡‡ç”¨ä¸€çº§é¡µè¡¨ä¼šæœ‰ä»€ä¹ˆç¼ºç‚¹? æ¯ä¸ªé¡µçš„å¤§å°æ˜¯ 4KBï¼Œæ‰€ä»¥åœ°å€çš„ä½ 12 ä½ç”¨æ¥è¡¨ç¤ºé¡µå†…åç§»ï¼Œé«˜ 20 ä½ç”¨æ¥æŒ‡ç¤ºé¡µå·ã€‚ ç‰©ç†åœ°å€æ˜¯å¿…é¡»çš„ï¼Œå¦‚æœæ‰€æœ‰çš„ä¸œè¥¿éƒ½æ˜¯è™šæ‹Ÿåœ°å€ï¼Œé‚£æˆ‘ä»¬å°±æ— æ³•æ‰¾åˆ°è§£æè™šæ‹Ÿåœ°å€æ‰€éœ€çš„ä¿¡æ¯ã€‚ é‡‡ç”¨ä¸€çº§é¡µè¡¨çš„ç¼ºç‚¹åœ¨äºï¼šé€šå¸¸æ¥è¯´é¡µè¡¨ä¸­çš„æœ‰æ•ˆé¡¹æ˜¯éå¸¸ç¨€ç–çš„ã€‚å¦‚æœé‡‡ç”¨ä¸€çº§çš„çº¿æ€§é¡µè¡¨ï¼Œæˆ‘ä»¬ä¸å¾—ä¸å°†æ‰€æœ‰çš„é¡µè¡¨å†…å®¹æ”¾è¿›å†…å­˜ï¼Œå ç”¨ç›¸å½“å¤§çš„ä¸€å—å†…å­˜ç©ºé—´ï¼Œä½†å…¶å®é‡Œé¢æœ‰å¤§é‡çš„ 0ã€‚å¦‚æœé‡‡ç”¨äºŒçº§é¡µè¡¨ï¼Œæˆ‘ä»¬åªéœ€è¦å°†é¡µç›®å½•çš„ä¸€ä¸ªé¡µå’Œæœ‰å†…å®¹çš„é‚£äº›å­é¡µæ”¾è¿›å†…å­˜ï¼Œè¿™æ ·å°±èŠ‚çœäº†å†…å­˜ç©ºé—´ã€‚ ç©ºæŒ‡é’ˆçœŸçš„æ˜¯\u0026quot;ç©º\u0026quot;çš„å—? ç¨‹åºè®¾è®¡è¯¾ä¸Šè€å¸ˆå‘Šè¯‰ä½ , å½“ä¸€ä¸ªæŒ‡é’ˆå˜é‡çš„å€¼ç­‰äºNULLæ—¶, ä»£è¡¨ç©º, ä¸æŒ‡å‘ä»»ä½•ä¸œè¥¿. ä»”ç»†æƒ³æƒ³, çœŸçš„æ˜¯è¿™æ ·å—? å½“ç¨‹åºå¯¹ç©ºæŒ‡é’ˆè§£å¼•ç”¨çš„æ—¶å€™, è®¡ç®—æœºå†…éƒ¨å…·ä½“éƒ½åšäº†äº›ä»€ä¹ˆ? ä½ å¯¹ç©ºæŒ‡é’ˆçš„æœ¬è´¨æœ‰ä»€ä¹ˆæ–°çš„è®¤è¯†?\nä¸¥æ ¼æ¥è¯´ç©ºæŒ‡é’ˆå¹¶ä¸æ˜¯ä¸æŒ‡å‘ä»»ä½•ä¸œè¥¿ï¼Œè€Œæ˜¯å®ƒæŒ‡å‘ä¸€ä¸ªä¸å¯ä»¥è¢«è®¿é—®çš„ä¸œè¥¿ï¼Œå¦‚æœè¯•å›¾å¯¹ç©ºæŒ‡é’ˆè§£å¼•ç”¨ï¼Œä¼šå› ä¸ºè¶Šæƒè¡Œä¸ºè§¦å‘å¼‚å¸¸ã€‚\nmips32çš„TLBç®¡ç†æ˜¯å¦æ›´ç®€å•? æœ‰ä¸€ç§è§‚ç‚¹è®¤ä¸º, mips32çš„åˆ†é¡µæœºåˆ¶æ›´ç®€å•. ä½ è®¤åŒå—? å°è¯•åˆ†åˆ«åœ¨ç°åœ¨, ä»¥åŠå®Œæˆè¿™éƒ¨åˆ†å†…å®¹ä¹‹åå›ç­”è¿™ä¸ªé—®é¢˜.\nmips32 å°† TLB ç®¡ç†å®Œå…¨äº¤ç»™è½¯ä»¶ï¼Œè¿™ä½¿å¾—åœ¨ PA ä¸­æˆ‘ä»¬ä¸èƒ½çœç•¥ TLB çš„å®ç°ï¼Œä¹Ÿå¿…é¡»è¦å¤„ç†è¿›ç¨‹åˆ‡æ¢æ—¶äº§ç”Ÿçš„ä¸€ç³»åˆ—ä¸€è‡´æ€§é—®é¢˜ï¼Œåœ¨ PA ä¸­å®Œæˆ mips32 çš„åˆ†é¡µæœºåˆ¶æ›´åŠ éº»çƒ¦ã€‚ä½†å®é™…ä¸­ï¼Œç¡¬ä»¶ä¸Šç»´æŠ¤ TLB æ¯”è½¯ä»¶ä¸Šç»´æŠ¤ TLB è¦å¤æ‚ï¼Œéœ€è¦æ›´å¤šçš„é—¨ç”µè·¯æ”¯æŒã€‚mips32 çš„ TLB ç®¡ç†å°†ç¡¬ä»¶çš„æ´»äº¤ç»™è½¯ä»¶ï¼Œå¯ä»¥ä½¿ç¡¬ä»¶è®¾è®¡æ›´ä¸ºç®€å•ã€‚\nå†…æ ¸æ˜ å°„çš„ä½œç”¨ å¯¹äºx86å’Œriscv32, åœ¨protect()ä¸­åˆ›å»ºåœ°å€ç©ºé—´çš„æ—¶å€™, æœ‰ä¸€å¤„ä»£ç ç”¨äºæ‹·è´å†…æ ¸æ˜ å°„:\n// map kernel space memcpy(updir, kas.ptr, PGSIZE); å°è¯•æ³¨é‡Šè¿™å¤„ä»£ç , é‡æ–°ç¼–è¯‘å¹¶è¿è¡Œ, ä½ ä¼šçœ‹åˆ°å‘ç”Ÿäº†é”™è¯¯. è¯·è§£é‡Šä¸ºä»€ä¹ˆä¼šå‘ç”Ÿè¿™ä¸ªé”™è¯¯.\næˆ‘ä»¬åœ¨ä»ç”¨æˆ·è¿›ç¨‹åˆ‡æ¢åˆ°å†…æ ¸çº¿ç¨‹çš„æ—¶å€™å¹¶æ²¡æœ‰åˆ‡æ¢ satpï¼Œå› ä¸ºå¯¹äºä»»ä½•ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹æ¥è¯´ï¼Œå†…æ ¸æ®µéƒ½æ˜¯æ’ç­‰æ˜ å°„ã€‚ä½†è¿™å°±è¦æ±‚ç”¨æˆ·è¿›ç¨‹çš„é¡µè¡¨é‡Œå¿…é¡»åŒ…å«å†…æ ¸æ˜ å°„ï¼Œä¸ç„¶å†…æ ¸åŒºåŸŸçš„ä»£ç æ— æ³•æ­£ç¡®æ‰§è¡Œã€‚\nNative çš„ VME å®ç° å°è¯•é˜…è¯»nativeçš„VMEå®ç°, ä½ å‘ç°nativeæ˜¯å¦‚ä½•å®ç°VMEçš„? ä¸ºä»€ä¹ˆå¯ä»¥è¿™æ ·åš?\nç•™å‘ã€‚\nå¯ä»¥åœ¨ç”¨æˆ·æ ˆé‡Œé¢åˆ›å»ºç”¨æˆ·è¿›ç¨‹ä¸Šä¸‹æ–‡å—? ucontext()çš„è¡Œä¸ºæ˜¯åœ¨å†…æ ¸æ ˆkstackä¸­åˆ›å»ºç”¨æˆ·è¿›ç¨‹ä¸Šä¸‹æ–‡. æˆ‘ä»¬æ˜¯å¦å¯ä»¥å¯¹ucontext()çš„è¡Œä¸ºè¿›è¡Œä¿®æ”¹, è®©å®ƒåœ¨ç”¨æˆ·æ ˆä¸Šåˆ›å»ºç”¨æˆ·è¿›ç¨‹ä¸Šä¸‹æ–‡? ä¸ºä»€ä¹ˆ?\nç›®å‰æ¥è¯´æ˜¯å¯ä»¥çš„ï¼Œäº‹å®ä¸Šé™¤äº†åˆ›å»ºçš„æ—¶å€™ä¸Šä¸‹æ–‡åœ¨å†…æ ¸æ ˆä¸Šï¼Œå…¶ä»–æ—¶å€™ä¸Šä¸‹æ–‡éƒ½åœ¨ç”¨æˆ·æ ˆä¸Šã€‚ä½†åœ¨ç”¨æˆ·æ ˆä¸Šåˆ›å»ºå’Œä¿å­˜ä¸Šä¸‹æ–‡ä¼šé‡åˆ°ä¸‹é¢ä¸€é“æ€è€ƒé¢˜æ¶‰åŠçš„é—®é¢˜ã€‚\nå¹¶å‘æ‰§è¡Œå¤šä¸ªç”¨æˆ·è¿›ç¨‹ è®©Nanos-liteåŠ è½½ä»™å‰‘å¥‡ä¾ ä¼ å’Œhelloè¿™ä¸¤ä¸ªç”¨æˆ·è¿›ç¨‹; æˆ–è€…æ˜¯åŠ è½½NTermå’Œhelloå†…æ ¸çº¿ç¨‹, ç„¶åä»NTermå¯åŠ¨ä»™å‰‘å¥‡ä¾ ä¼ , ä½ åº”è¯¥ä¼šåœ¨è¿è¡Œçš„æ—¶å€™è§‚å¯Ÿåˆ°é”™è¯¯. å°è¯•åˆ†æè¿™ä¸€é”™è¯¯çš„åŸå› , å¹¶æ€»ç»“ä¸ºäº†æ”¯æŒè¿™ä¸€åŠŸèƒ½, æˆ‘ä»¬éœ€è¦æ»¡è¶³ä»€ä¹ˆæ ·çš„æ¡ä»¶.\nè¿™å¯ä»¥è¯´æ˜¯ä¸€å‘¨ç›®æœ€éš¾çš„ä¸€é“æ€è€ƒé¢˜äº†, è™½ç„¶æˆ‘ä»¬ä¼šåœ¨PA4çš„æœ€åç»™å‡ºåˆ†æ, å–œæ¬¢æŒ‘æˆ˜çš„åŒå­¦ä»ç„¶å¯ä»¥åœ¨è¿™é‡Œå°è¯•ç‹¬ç«‹æ€è€ƒ: å¦‚æœä½ èƒ½ç‹¬ç«‹è§£å†³è¿™ä¸ªé—®é¢˜, è¯´æ˜ä½ å¯¹è®¡ç®—æœºç³»ç»Ÿçš„ç†è§£å¯ä»¥è¯´æ˜¯ç›¸å½“äº†å¾—äº†.\nä»¥å‰è€…ä¸ºä¾‹ï¼Œå½“æˆ‘ä»¬æƒ³è¦ä» pal è¿›ç¨‹åˆ‡æ¢åˆ° hello è¿›ç¨‹çš„æ—¶å€™ï¼Œæˆ‘ä»¬é¦–å…ˆä¼šæŠŠ pal è¿›ç¨‹çš„ä¸Šä¸‹æ–‡ä¿å­˜åœ¨ pal çš„ç”¨æˆ·æ ˆä¸Šï¼Œç„¶åé™·å…¥å†…æ ¸æ‰§è¡Œä¸­æ–­æœåŠ¡ç¨‹åºï¼Œæ³¨æ„æˆ‘ä»¬åœ¨ä¸­æ–­æœåŠ¡ç¨‹åºä¸­è¿›è¡Œçš„å‡½æ•°è°ƒç”¨ï¼Œå±€éƒ¨å˜é‡å®šä¹‰ç­‰äº‹æƒ…ä¹Ÿä¸€ç›´æ˜¯åœ¨ pal çš„ç”¨æˆ·æ ˆä¸Šåšçš„ã€‚schedule() å°†ä¸‹ä¸€ä¸ªè¿›ç¨‹åˆ‡æ¢åˆ° helloï¼Œåšå®Œ __am_switch() åï¼Œé¡µè¡¨å·²ç»æ˜¯ hello è¿›ç¨‹çš„é¡µè¡¨ï¼Œå’Œ pal ç›¸å…³çš„æ‰€æœ‰è™šå­˜æ˜ å°„éƒ½ä¸åœ¨è¯¥é¡µè¡¨ä¸­ã€‚å› æ­¤ç›®å‰æˆ‘ä»¬æ— æ³•è®¿é—®åˆ°ä¿å­˜åœ¨ pal ç”¨æˆ·æ ˆä¸Šçš„é‚£äº›å’Œä¸­æ–­æœåŠ¡ç¨‹åºç›¸å…³çš„æ ˆå¸§ä¿¡æ¯ï¼ˆæ¯”å¦‚è¿”å›åœ°å€ï¼‰ï¼Œæ‰€ä»¥ä¼šå‘ç”Ÿæ®µé”™è¯¯ã€‚\nè¡¥å…… å…³äº mm_brk() ç¬”è€…åœ¨è¿™é‡Œå¡äº†ç›¸å½“é•¿çš„æ—¶é—´ï¼Œå› ä¸ºä¸å¤ªèƒ½ç†è§£è®²ä¹‰çš„å†…å®¹ã€‚ç»è¿‡æ€è€ƒåå¤§è‡´æ˜ç™½äº†è¿™ä¸ªå †åŒºçš„æ„æ€ã€‚ç”¨æˆ·ç¨‹åºç”³è¯·çš„æ–° program-break éƒ½æ˜¯è™šæ‹Ÿå†…å­˜ä¸‹çš„ pbã€‚pcb ç»“æ„ä½“ä¸­çš„ max_brk å­˜çš„ä¹Ÿæ˜¯è™šæ‹Ÿå†…å­˜ä¸‹çš„ pbã€‚å¦‚æœå½“å‰ç”³è¯·çš„ pb å€¼è¶…è¿‡äº† max_brkï¼Œå°±ç”³è¯·ä¸€äº›æ–°çš„ç‰©ç†å†…å­˜é¡µï¼Œå°† [max_brk,pb) ä¸­çš„å†…å®¹æ˜ å°„åˆ°ç‰©ç†å†…å­˜é¡µä¸­ã€‚æƒ³è¦è·å¾—å½“å‰è¿›ç¨‹çš„ max_brkï¼Œåªè¦é€šè¿‡ current æŒ‡é’ˆè®¿é—®å½“å‰è¿›ç¨‹çš„ pcb å³å¯ã€‚\næ¥è‡ªå¤–éƒ¨çš„å£°éŸ³ æ€è€ƒé¢˜ ç¾éš¾æ€§çš„åæœ(è¿™ä¸ªé—®é¢˜æœ‰ç‚¹éš¾åº¦) å‡è®¾ç¡¬ä»¶æŠŠä¸­æ–­ä¿¡æ¯å›ºå®šä¿å­˜åœ¨æŸä¸ªå†…å­˜åœ°å€(ä¾‹å¦‚0x1000)çš„ä½ç½®, AMä¹Ÿæ€»æ˜¯ä»è¿™é‡Œå¼€å§‹æ„é€ ä¸Šä¸‹æ–‡. å¦‚æœå‘ç”Ÿäº†ä¸­æ–­åµŒå¥—, å°†ä¼šå‘ç”Ÿä»€ä¹ˆæ ·çš„ç¾éš¾æ€§åæœ? è¿™ä¸€ç¾éš¾æ€§çš„åæœå°†ä¼šä»¥ä»€ä¹ˆæ ·çš„å½¢å¼è¡¨ç°å‡ºæ¥? å¦‚æœä½ è§‰å¾—æ¯«æ— å¤´ç»ª, ä½ å¯ä»¥ç”¨çº¸ç¬”æ¨¡æ‹Ÿä¸­æ–­å¤„ç†çš„è¿‡ç¨‹.\nç•™å‘ã€‚\nå¦‚ä½•æ”¯æŒä¸­æ–­åµŒå¥— æ€è€ƒä¸€ä¸‹, x86, mips32å’Œriscv32çš„è½¯ç¡¬ä»¶è¯¥åˆ†åˆ«å¦‚ä½•ååŒ, æ¥æ”¯æŒä¸­æ–­åµŒå¥—?\nç•™å‘ã€‚\nä¸­æ–­å’Œç”¨æˆ·è¿›ç¨‹åˆå§‹åŒ– æˆ‘ä»¬çŸ¥é“, ç”¨æˆ·è¿›ç¨‹ä»Navyçš„_startå¼€å§‹è¿è¡Œ, å¹¶ä¸”åœ¨_startä¸­è®¾ç½®æ­£ç¡®çš„æ ˆæŒ‡é’ˆ. å¦‚æœåœ¨ç”¨æˆ·è¿›ç¨‹è®¾ç½®æ­£ç¡®çš„æ ˆæŒ‡é’ˆä¹‹å‰å°±åˆ°æ¥äº†ä¸­æ–­, æˆ‘ä»¬çš„ç³»ç»Ÿè¿˜èƒ½å¤Ÿæ­£ç¡®åœ°è¿›è¡Œä¸­æ–­å¤„ç†å—?\nåœ¨å®ç°å†…æ ¸æ ˆåˆ‡æ¢ä¹‹å‰ï¼Œè¿™ä¼šå¯¼è‡´ä¸€äº›é—®é¢˜ã€‚å› ä¸º sp è¿˜æ²¡æŒ‡å‘æ­£ç¡®çš„ä½ç½®ï¼Œæ— æ³•åœ¨ç”¨æˆ·æ ˆä¸Šä¿å­˜ä¸Šä¸‹æ–‡ã€‚ä½†å®ç°äº†å†…æ ¸æ ˆåˆ‡æ¢ä¹‹åä¸ä¼šæœ‰é—®é¢˜ã€‚å› ä¸ºæˆ‘ä»¬æ€»æ˜¯å¯ä»¥å°† sp åˆ‡æ¢åˆ°è¿›ç¨‹çš„å†…æ ¸æ ˆä¸Šä¿å­˜ä¸Šä¸‹æ–‡ï¼Œä¸­æ–­å¤„ç†ç»“æŸä¹‹åå†å›åˆ°ç”¨æˆ·ç¨‹åºï¼Œç»§ç»­è®¾ç½®æ­£ç¡®çš„ç”¨æˆ·æ ˆæŒ‡é’ˆã€‚\nç”¨æˆ·æ€å’Œæ ˆæŒ‡é’ˆ ä¸€èˆ¬æ¥è¯´, å¤„ç†å™¨çš„ç‰¹æƒçº§ä¹Ÿæ˜¯ä¸€ç§çŠ¶æ€. æˆ‘ä»¬æ˜¯å¦å¯ä»¥é€šè¿‡æ ˆæŒ‡é’ˆçš„å€¼æ¥åˆ¤æ–­å½“å‰ä½äºç”¨æˆ·æ€è¿˜æ˜¯å†…æ ¸æ€?\né€šå¸¸æ¥è¯´æ˜¯å¯ä»¥çš„ï¼Œåœ¨ nanos-lite ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥æ£€æŸ¥ sp æŒ‡é’ˆæ˜¯å¦ä½äºç”¨æˆ·æ ˆï¼ˆå³å°äº 0x80000000ï¼‰æ¥åˆ¤æ–­è¿›å…¥ trap.S æ—¶å¤„äºç”¨æˆ·æ€è¿˜æ˜¯å†…æ ¸æ€ã€‚ä½†å¦‚æœé‡åˆ°ä¸Šè¿°æ€è€ƒé¢˜æåˆ°çš„é‚£ç§â€œåœ¨è®¾ç½®å¥½æ ˆæŒ‡é’ˆä¹‹å‰è¿›å…¥äº†ä¸­æ–­â€çš„æƒ…å†µï¼Œåˆ™ä¸å¯ä»¥ï¼ˆå› ä¸ºåœ¨è®¾ç½®å¥½æ ˆæŒ‡é’ˆå‰ sp ä¸€å®šå¤„äºå†…æ ¸åŒºï¼Œè¿™ä¼šå¯¼è‡´è¯¯åˆ¤ï¼‰ã€‚å› æ­¤åœ¨ä¸Šä¸‹æ–‡ç»“æ„ä½“ä¸­ä¿å­˜ä¸€ä¸ª np çŠ¶æ€æ˜¯æ¯”è¾ƒå¥½çš„é€‰æ‹©ã€‚\nç³»ç»Ÿçš„å¤æ‚æ€§(3) æˆ‘ä»¬æŠŠCTEé‡å…¥é—®é¢˜ä½œä¸ºçŠ¶æ€æœºè§†è§’çš„ä¸€ä¸ªç»ƒä¹ , è¯·ä½ æ¥å°è¯•åˆ†æä¸Šè¿°ä»£ç åœ¨CTEé‡å…¥çš„æƒ…å†µä¸‹å­˜åœ¨ä»€ä¹ˆé—®é¢˜.\nä¸Šè¿°ä»£ç åœ¨è¿›å…¥ __am_irq_handle(c) çš„æ—¶å€™è¿˜æ²¡æœ‰å¯¹ pp è¿›è¡Œè®¾ç½®ï¼Œæ¯”æ–¹å°†ä»ç”¨æˆ·æ€é€šè¿‡ç³»ç»Ÿè°ƒç”¨é™·å…¥å†…æ ¸æ€ï¼Œæ­¤æ—¶ pp == USERï¼Œç„¶åå¦‚æœåœ¨ç³»ç»Ÿè°ƒç”¨ä¸­é€”å‘ç”Ÿäº† CTE é‡å…¥ï¼Œè¿›å…¥ __am_asm_trap çš„æ—¶å€™ï¼Œpp ä»ç„¶æ˜¯ USERï¼Œä¼šå‡ºé”™ã€‚\nä¸ºäº†é¢„é˜² CTE é‡å…¥å¯¼è‡´çš„ä¸Šè¿°é—®é¢˜ï¼Œæˆ‘ä»¬è¦æå‰è®¾ç½®å¥½ ppã€‚å› ä¸º CTE é‡å…¥ä¸€å®šæ˜¯ä» CTE è¿›å…¥ CTEï¼Œè€Œ CTE ä¸€å®šåœ¨å†…æ ¸æ€ï¼Œæ‰€ä»¥ç›´æ¥å°† pp è®¾ä¸º KERNEL å³å¯ã€‚\nä¸´æ—¶å¯„å­˜å™¨çš„æ–¹æ¡ˆ åŒæ ·æ˜¯ä½œä¸ºCTEçš„ä¸´æ—¶å¯„å­˜å™¨, mips32é€‰æ‹©åœ¨GPRä¸­åˆ†é…å‡ºk0å’Œk1, è€Œriscv32åˆ™æ˜¯é‡‡ç”¨mscratchè¿™ä¸ªCSRå¯„å­˜å™¨. è¿™ä¸¤ç§æ–¹æ¡ˆç›¸æ¯”, æ˜¯å¦å­˜åœ¨å“ªä¸€ç§æ–¹æ¡ˆæ›´ä¼˜? ä¸ºä»€ä¹ˆ?\nç¬”è€…è®¤ä¸ºæ²¡æœ‰æ˜æ˜¾çš„ä¼˜åŠ£ã€‚ä¸€ä¸ªæ‰§è¡Œå•ä¸€åŠŸèƒ½çš„é€šç”¨å¯„å­˜å™¨å’ŒCSRæ²¡æœ‰å¤ªæœ¬è´¨çš„åŒºåˆ«ã€‚\n[äºŒå‘¨ç›®] Nanos-lite ä¸å¹¶å‘ bug ä¸Šæ–‡è®¨è®ºå¹¶å‘çš„æ—¶å€™æåˆ°: æ›´ä¸€èˆ¬åœ°, ç”¨æˆ·è¿›ç¨‹éƒ½ä¼šå¹¶å‘åœ°æ‰§è¡Œç³»ç»Ÿè°ƒç”¨, æ“ä½œç³»ç»Ÿè¿˜éœ€è¦ä¿è¯å®ƒä»¬éƒ½èƒ½æŒ‰ç…§ç³»ç»Ÿè°ƒç”¨çš„è¯­ä¹‰æ­£ç¡®åœ°æ‰§è¡Œ.\næˆ‘ä»¬åœ¨PA3ä¸­çŸ¥é“printf()ä¼šé€šè¿‡malloc()ç”³è¯·ç¼“å†²åŒº, è€Œmalloc()åˆå¯èƒ½ä¼šæ‰§è¡Œ_sbrk(), é€šè¿‡SYS_brké™·å…¥å†…æ ¸; åœ¨ä¸Šä¸€ä¸ªé˜¶æ®µä¸­, æˆ‘ä»¬å®ç°äº†æ”¯æŒåˆ†é¡µæœºåˆ¶çš„mm_brk(), åœ¨å¿…è¦çš„æ—¶å€™å®ƒä¼šé€šè¿‡new_page()ç”³è¯·ä¸€é¡µ. è€Œä»™å‰‘å’Œhelloç”¨æˆ·è¿›ç¨‹éƒ½ä¼šè°ƒç”¨printf(), ä½¿å¾—å®ƒä»¬å¯èƒ½ä¼šå¹¶å‘æ‰§è¡ŒSYS_brk. æ€è€ƒä¸€ä¸‹, ç›®å‰Nanos-liteçš„è®¾è®¡ä¼šå¯¼è‡´å¹¶å‘bugå—? ä¸ºä»€ä¹ˆ?\nç•™å‘ã€‚\nè¡¥å…… å…³äºæ—¶é’Ÿä¸­æ–­çš„è½¯ä»¶+4 æ—¶é’Ÿä¸­æ–­å’Œ yield çš„å¤„ç†è¿‡ç¨‹å‡ ä¹å®Œå…¨ç›¸åŒã€‚ä½†éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œyield ä¸­ mepc ä¿å­˜çš„æ˜¯å½“å‰æŒ‡ä»¤ (ecall) çš„ pcï¼Œè€Œæ—¶é’Ÿä¸­æ–­ç”±äºæ”¾åœ¨ CPU å¾ªç¯çš„ updatepc ä¹‹åï¼Œæ‰€ä»¥ mepc ä¿å­˜çš„æ˜¯ä¸‹ä¸€æ¡æŒ‡ä»¤çš„ pcã€‚å› æ­¤æ—¶é’Ÿä¸­æ–­åœ¨æ“ä½œç³»ç»Ÿå±‚é¢ä¸éœ€è¦+4ã€‚\nå…³äºæ—¶é’Ÿä¸­æ–­çš„ä¸Šä¸‹æ–‡æ­£ç¡®åˆ›å»ºæ–¹å¼ ç¬”è€…æœ€åˆåœ¨åˆ›å»ºä¸Šä¸‹æ–‡çš„æ—¶å€™ï¼Œå°† mstatus çš„ MIE ä½å’Œ PMIE ä½éƒ½è®¾ç½®æˆ 1ï¼Œä½†è¿™å¯¼è‡´äº†æ®µé”™è¯¯ã€‚ç»è¿‡æ’æŸ¥å‘ç°ï¼Œnanos-lite åœ¨æ‰§è¡Œ trap.S ä¸­çš„æŒ‡ä»¤æ—¶å“åº”äº†ä¸­æ–­ï¼Œå¯¼è‡´ä¸Šä¸‹æ–‡ä¿¡æ¯æ¢å¤äº†ä¸€åŠæ—¶å‘ç”Ÿäº†ä¸­æ–­åµŒå¥—ã€‚\næ­£ç¡®çš„ä¸Šä¸‹æ–‡åˆ›å»ºæ–¹å¼åº”è¯¥æ˜¯å°† PMIE ç½®ä¸º1ï¼ŒMIE ç½®ä¸º 0ã€‚ä»»ä½•ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹ç¬¬ä¸€æ¬¡è¢«è°ƒåº¦åˆ°çš„æ—¶å€™ï¼Œä¸€å®šæ˜¯ä» trap.S çš„ååŠæ®µå¼€å§‹çš„ï¼Œæ²¡æœ‰ç»™ä½ å…³ä¸­æ–­çš„æœºä¼šã€‚å› æ­¤è¿™æ—¶ MIE ä¸€å®šè¦ç½®ä¸º 0ï¼Œå¦åˆ™ä¸€æ—¦æ¢å¤ mstatus å°±ä¼šå‘ç”Ÿä¸­æ–­åµŒå¥—ã€‚PMIE ç½®ä¸º 1 æ˜¯ä¸ºäº†ä¿è¯åœ¨æ‰§è¡Œ mret ä¹‹å MIE å¯ä»¥æ¥æ”¶ PMIE çš„å€¼å˜ä¸º 1ï¼Œä»è€Œåç»­å¯ä»¥æ­£å¸¸åœ°å“åº”ä¸­æ–­ã€‚\nå…³äºä» nterm ä¸­æ‰§è¡Œå…¶ä»–ç¨‹åºæ—¶å‡ºé”™ ç¬”è€…åœ¨å®ç°äº† execve è°ƒç”¨ä¹‹åå°è¯•ä» nterm ä¸­ç”¨å‘½ä»¤ pal --skip åŠ è½½ä»™å‰‘å¥‡ä¾ ä¼ å¹¶è·³è¿‡ç‰‡å¤´åŠ¨ç”»ï¼Œä½†è§¦å‘äº†æ®µé”™è¯¯ã€‚æœ‰æ•ˆçš„ debug è·¯å¾„å¦‚ä¸‹ï¼š\nå‘ç°pcæ˜¯åœ¨å†…æ ¸åŒºè·‘é£çš„ --\u0026gt; åœ¨æŒ‡ä»¤åºåˆ—ä¸­å¯»æ‰¾pcå¯¹åº”çš„æŒ‡ä»¤ï¼Œå‘ç°ä½äºcontext_uloadé‡Œé¢ --\u0026gt; ä½¿ç”¨åœ¨å„ä¸ªä½ç½®æ’å…¥assert(0)çš„æ–¹æ³•æ¥å®šä½å‡ºé”™çš„å…·ä½“è¯­å¥ï¼Œå‘ç°åœ¨å®Œæˆprotect()ï¼Œåˆ‡æ¢åˆ°æ–°è¿›ç¨‹çš„ç”¨æˆ·æ ˆä¸Šï¼Œå‡†å¤‡å°†å‚æ•°æ¬ä¸Šç”¨æˆ·æ ˆæ—¶å‘ç”Ÿæ®µé”™è¯¯ nterm çš„å‚æ•°è§£æå†™åœ¨å†…å»º shell ä¸­ï¼Œç¬”è€…åœ¨å®ç°å†…å»º shell æ—¶å°†å‚æ•°æ¬åˆ°äº† buildin-shell.c æ–‡ä»¶ä¸­å®šä¹‰çš„æ•°ç»„é‡Œã€‚è¿™äº›æ•°ç»„åœ¨ç¼–è¯‘æ˜¯ä½äº nterm è¿›ç¨‹çš„æ•°æ®æ®µã€‚åœ¨ context_uload() ä¸­å®Œæˆ protect() åï¼Œsatp åˆ‡æ¢åˆ°äº†æ–°è¿›ç¨‹çš„é¡µè¡¨ã€‚æ–°è¿›ç¨‹çš„é¡µè¡¨ä¸­æ²¡æœ‰ nterm ç”¨æˆ·æ ˆçš„æ˜ å°„ä¿¡æ¯ï¼Œå› æ­¤ä¿å­˜åœ¨ nterm æ•°æ®æ®µçš„å‚æ•°æ˜¯å–ä¸åˆ°çš„ã€‚å¼ºè¡Œå–å°±ä¼šè§¦å‘æ®µé”™è¯¯ã€‚ä½†æ˜¯æˆ‘ä»¬å¿…é¡»åœ¨é¡µè¡¨åˆ‡æ¢åˆ°æ–°è¿›ç¨‹ä¹‹åæ‰èƒ½å¼€å§‹ä¿å­˜å‚æ•°ï¼Œè¿™ä¼¼ä¹æ˜¯ä¸€ä¸ªä¸¤éš¾çš„é—®é¢˜ã€‚\nç¬”è€…é‡‡å–çš„è§£å†³æ–¹æ¡ˆæ˜¯ï¼Œè¿›å…¥ context_uload() ä¹‹åï¼Œå…ˆæŠŠæ‰€æœ‰çš„å‚æ•°å¤åˆ¶åˆ°å†…æ ¸ä»£ç åˆ›å»ºçš„æ•°ç»„ä¸­ï¼Œè¿™äº›æ•°ç»„ä½äºå†…æ ¸çš„æ•°æ®æ®µï¼Œæ˜¯æ‰€æœ‰è¿›ç¨‹éƒ½å¯ä»¥è®¿é—®çš„ã€‚è¿™æ ·åˆ‡æ¢åˆ°æ–°è¿›ç¨‹çš„é¡µè¡¨ä¹‹åï¼Œå†å°†å·²ç»ä¿å­˜åœ¨å†…æ ¸æ•°æ®æ®µçš„å‚æ•°æ‹·è´åˆ°æ–°è¿›ç¨‹çš„ç”¨æˆ·æ ˆä¸Šï¼Œå°±ä¸ä¼šå‡ºé—®é¢˜äº†ã€‚\nå…³äºåå¤åŠ è½½ bird ç”¨æˆ·ç¨‹åºæ—¶å‡ºé”™ ç¬”è€…ç»™ bird ç¨‹åºç»‘å®šäº† esc é”®ç”¨äºé€€å‡ºï¼Œä½†ç¬”è€…å‘ç°å¦‚æœé€€å‡ºæ—¶å†æ¬¡åŠ è½½ bird ç¨‹åºä¼šè§¦å‘æ®µé”™è¯¯ï¼Œæœ‰æ•ˆçš„ debug è·¯å¾„å¦‚ä¸‹ï¼š\nå‘ç°pcæ˜¯åœ¨ç”¨æˆ·åŒºè·‘é£çš„ --\u0026gt; ä½¿ç”¨straceæ‰“å°æ‰§è¡Œè¿‡çš„æ‰€æœ‰ç³»ç»Ÿè°ƒç”¨ --\u0026gt; å‘ç°æœ€è¿‘ä¸€æ¬¡ä½¿ç”¨çš„ç³»ç»Ÿè°ƒç”¨æ˜¯sys_brk --\u0026gt; æ£€æŸ¥sys_brkä»£ç ï¼Œæ€è€ƒç¬¬äºŒæ¬¡åŠ è½½ä¸ç¬¬ä¸€æ¬¡åŠ è½½çš„ä¸åŒ ç¬”è€…å‘ç°å…³é”®ç‚¹åœ¨äº max_brk çš„ç»´æŠ¤ä¸Šã€‚loader ä¸­å°†å„ä¸ªæ®µåŠ è½½åˆ°è™šæ‹Ÿå†…å­˜ä¸­ï¼Œå¹¶æ ¹æ®åŠ è½½çš„ä½ç½®æ›´æ–° max_brkã€‚å› æ­¤åŠ è½½ç»“æŸæ—¶ max_brk æ€»æ˜¯èƒ½æŒ‡å‘æ•°æ®æ®µä¹‹åç¬¬ä¸€ä¸ªæœªè¢«åˆ†é…çš„åœ°å€ã€‚\nfor (int i = 0; i \u0026lt; ehdr-\u0026gt;e_phnum; i ++) if (phdr[i].p_type == PT_LOAD) { fs_lseek(fd, phdr[i].p_offset, SEEK_SET); fs_read(fd, data, phdr[i].p_filesz); uintptr_t _ed = memory_loader(\u0026amp;pcb-\u0026gt;as, phdr[i].p_vaddr, phdr[i].p_filesz, phdr[i].p_memsz); if (_ed \u0026gt; pcb-\u0026gt;max_brk) pcb-\u0026gt;max_brk = _ed; } ç”¨å½“å‰ pcb é‡æ–°åŠ è½½å¦ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹æ—¶ï¼Œä¸€å®šè¦å°† max_brk æ¸…é›¶ï¼Œå¦åˆ™å¦‚æœä¸‹ä¸€ä¸ªè¿›ç¨‹çš„å®é™…çš„ max_brk å°äºå‰ä¸€ä¸ªè¿›ç¨‹ç»“æŸæ—¶çš„ brkï¼Œå°±ä¼šå‡ºç°ä¸€æ®µæ²¡æœ‰åœ¨é¡µè¡¨ä¸­æ˜ å°„åˆ°çš„â€œçœŸç©ºåœ°å¸¦â€ï¼Œåœ¨è¿›ç¨‹ä½¿ç”¨å †åŒºçš„æ—¶å€™å°±ä¼šå‡ºå‘æ®µé”™è¯¯ã€‚\nå…³äºå®ç°å†…æ ¸æ ˆåˆ‡æ¢ä¹‹åæ—¶é’Ÿä¸­æ–­æ— æ³•ä¸ yield() å¹¶å­˜ ç¬”è€…åœ¨å®ç°å†…æ ¸æ ˆåˆ‡æ¢ä¹‹åå‘ç°å¦‚æœæ—¢æœ‰ yield() åˆæœ‰æ—¶é’Ÿä¸­æ–­ä¼šå‡ºç°æ®µé”™è¯¯ã€‚æœ‰æ•ˆçš„ debug è·¯å¾„å¦‚ä¸‹ï¼š\nå‘ç°pcæ˜¯åœ¨å†…æ ¸åŒºè·‘é£çš„ --\u0026gt; ä½¿ç”¨itraceæ‰“å°è·‘é£ä¹‹å‰æ‰§è¡Œè¿‡çš„è‹¥å¹²æ¡æŒ‡ä»¤ --\u0026gt; å‘ç°åœ¨trap.Sçš„ä»£ç æ‰§è¡Œäº†ä¸€åŠçš„æ—¶å€™åˆè§¦å‘äº†æ—¶é’Ÿä¸­æ–­ï¼Œå‡ºç°äº†ä¸­æ–­åµŒå¥— ç»è¿‡å¯¹ trap.S ä¸­ä»£ç çš„æ£€æŸ¥ï¼Œå‘ç°äº†å¦‚ä¸‹é—®é¢˜ï¼š\nSTORE t0, OFFSET_CAUSE(sp) STORE t1, OFFSET_STATUS(sp) STORE t2, OFFSET_EPC(sp) STORE t3, OFFSET_SP(sp) addi t0, sp, CONTEXT_SIZE csrr t1, mscratch xor t0, t0, t1 bnez t0, user_np addi t2, x0, KERNEL STORE t2, OFFSET_NP(sp) j continue user_np: addi t2, x0, USER STORE t2, OFFSET_NP(sp) # c-\u0026gt;np continue: # set mstatus.MPRV to pass difftest li a0, (1 \u0026lt;\u0026lt; 17) or t1, t1, a0 csrw mstatus, t1 æœ€åä¸€æ®µæœ‰ä¸‰æ¡ç”¨äº pass difftest çš„æŒ‡ä»¤ï¼Œè¿™é‡Œçš„æŒ‡ä»¤é»˜è®¤ t1 ä¸­ä»ç„¶å­˜å‚¨çš„æ˜¯ STORE t1, OFFSET_STATUS(sp) ä¸­çš„ mstatus çš„å€¼ï¼ˆåœ¨åŸæœ¬çš„ trap.S çš„ä»£ç ä¸­å®ƒä»¬æ˜¯è¿åœ¨ä¸€èµ·çš„ï¼‰ã€‚ä½†ç¬”è€…ç°åœ¨åœ¨ä¸­é—´åŠ å…¥äº†ä¸€äº›åˆ¤æ–­çŠ¶æ€çš„æ±‡ç¼–è¯­å¥ï¼Œç ´åäº† t1 å¯„å­˜å™¨çš„å€¼ï¼Œå½“ t1 çš„å€¼çš„ MIE ä½æ­£å¥½æ˜¯ 1 çš„æ—¶å€™ï¼Œæ‰§è¡Œå®Œæœ€åçš„ csrw mstatus, t1 å°±ä¼šç¥ä¸çŸ¥é¬¼ä¸è§‰åœ°æ‰“å¼€ä¸­æ–­ï¼Œä»è€Œå¯¼è‡´ä¸­æ–­åµŒå¥—ã€‚\nä¿®å¤çš„æ–¹æ³•å¾ˆç®€å•ï¼šåªè¦å°† pass difftest çš„ä¸‰æ¡è¯­å¥ç§»åŠ¨åˆ° STORE çš„ä¸‹é¢å³å¯ã€‚\nå…³äºå®ç°å†…æ ¸æ ˆåˆ‡æ¢ä¹‹åæ— æ³•é€šè¿‡ OJ ç¬”è€…åœ¨å®ç°äº†å†…æ ¸æ ˆåˆ‡æ¢ä¹‹åå‘ç°æ— æ³•é€šè¿‡ OJ çš„ easy testã€‚è¿™æ˜¯ç¬”è€…è°ƒè¿‡çš„æœ€ç—›è‹¦çš„ \u0026ldquo;bug\u0026rdquo;ï¼Œå› ä¸ºæœ¬åœ°æ²¡æœ‰ä»»ä½•çš„é”™è¯¯ï¼Œæ— æ³•æ‰¾åˆ°ä»»ä½•ä¸å¯¹åŠ²çš„åœ°æ–¹ï¼Œåªèƒ½è™šç©ºè°ƒ bugã€‚åæ¥ç¬”è€…é€šè¿‡åœ¨å„ä¸ªå‡½æ•°ä¸­åŠ å…¥ assert(0) çš„æ–¹æ³•æ¥æµ‹è¯• OJ åˆ°åº•æ˜¯å¦‚ä½•è¯„æµ‹çš„ï¼ŒæƒŠå¥‡åœ°å‘ç° OJ ä½¿ç”¨äº† kcontext() ä½†æ²¡æœ‰ä½¿ç”¨ context_kload() ï¼Œå³ OJ åªæ˜¯åˆ›å»ºäº†ä¸€ä¸ªå†…æ ¸çº¿ç¨‹ä¸Šä¸‹æ–‡ï¼Œä½†æ²¡æœ‰ä½¿ç”¨è¿›ä¸€æ­¥å°è£…çš„ context_kload() å°†å…¶ä¿å­˜åœ¨æŸä¸ªå…·ä½“çš„ pcb çš„å†…æ ¸æ ˆä¸Šã€‚\nç¬”è€…é»˜è®¤åˆ›å»ºä¸Šä¸‹æ–‡ä¼šè°ƒç”¨æ›´é«˜å±‚çš„ context_kload() ï¼Œä¸ä¼šç»•è¿‡å®ƒç›´æ¥è°ƒç”¨åº•å±‚çš„ kcontext() ï¼Œå› æ­¤åœ¨å®ç°æ—¶å¹¶æ²¡æœ‰åœ¨ kcontext() ä¸­å®Œæˆæ‰€æœ‰çš„ä¸Šä¸‹æ–‡ä¿¡æ¯çš„è®¾ç½®ï¼Œc-\u0026gt;sp çš„è®¾ç½®è¢«æ”¾åœ¨äº† context_kload() é‡Œé¢ã€‚å› æ­¤å•çº¯è°ƒç”¨ kcontext() è·å¾—çš„ä¸Šä¸‹æ–‡ç»“æ„ä½“ç¼ºå°‘äº† c-\u0026gt;spï¼Œæ ˆåˆ‡æ¢æ—¶ sp å¯„å­˜å™¨è‡ªç„¶ä¼šè·‘é£ã€‚å°†è¿™ä¸€åˆå§‹åŒ–æŒªåˆ° kcontext() é‡Œé¢å®Œæˆåå³å¯é€šè¿‡ OJã€‚\nè¿™ä¸€æ•™è®­å‘Šè¯‰æˆ‘ä»¬å¿…é¡»ä»”ç»†é˜…è¯»è®²ä¹‰çš„ API å®šä¹‰ã€‚è®²ä¹‰ä¸­å…³äº kcontext() API çš„å®šä¹‰æ˜¯ï¼š\nâ€œå…¶ä¸­kstackæ˜¯æ ˆçš„èŒƒå›´, entryæ˜¯å†…æ ¸çº¿ç¨‹çš„å…¥å£, argåˆ™æ˜¯å†…æ ¸çº¿ç¨‹çš„å‚æ•°. ä½ éœ€è¦åœ¨kstackçš„åº•éƒ¨åˆ›å»ºä¸€ä¸ªä»¥entryä¸ºè¿”å›åœ°å€çš„ä¸Šä¸‹æ–‡ç»“æ„(ç›®å‰ä½ å¯ä»¥å…ˆå¿½ç•¥argå‚æ•°), ç„¶åè¿”å›è¿™ä¸€ç»“æ„çš„æŒ‡é’ˆ.â€\nå› æ­¤ç¡®å®åº”åœ¨åœ¨ kcontext() å†…å®Œæˆæ‰€æœ‰åˆ›å»ºå·¥ä½œã€‚\nç¼–å†™ä¸æœ½çš„ä¼ å¥‡ æ€è€ƒé¢˜ ç¬”è€…å°šæœªå®Œæˆè¯¥ç« èŠ‚çš„é€‰åšå†…å®¹ï¼Œæ•…æ­¤éƒ¨åˆ†çš„æ€è€ƒé¢˜æš‚æ—¶ç•™å‘ã€‚\nè¡¥å…… å…³äºä½¿ç”¨ F1 F2 F3 åˆ‡æ¢æ—¶ç”»é¢äº’ç›¸è¦†ç›– ç”±äºæ²¡æœ‰ç”¨äºè°ƒåº¦çª—å£çš„è¿›ç¨‹ï¼Œåœ¨è¿›ç¨‹åˆ‡æ¢çš„æ—¶å€™ç”»é¢ä¼šäº’ç›¸è¦†ç›–ï¼Œéå¸¸éš¾çœ‹ã€‚ç¬”è€…é‡‡ç”¨çš„æš‚æ—¶æ€§çš„è§£å†³æ–¹æ¡ˆæ˜¯åœ¨è¿›ç¨‹åˆ‡æ¢çš„æ—¶å€™å¼ºè¡Œåˆ·æ–°ä¸€æ¬¡ VGAï¼Œå°†æ‰€æœ‰åƒç´ å¡«æˆé»‘è‰²ã€‚è¿™ä¸ªæ–¹æ¡ˆå¯¹äº birdï¼Œnterm ç­‰æ•´ä¸ªå±å¹•éƒ½åœ¨ä¸æ–­æ›´æ–°çš„åº”ç”¨æ¯”è¾ƒå‹å¥½ï¼Œä½†å¯¹äº palï¼Œnslider ç­‰æ²¡æœ‰å˜åŒ–çš„åŒºåŸŸå±å¹•ä¸ä¼šæ›´æ–°çš„åº”ç”¨ä¸å¤ªå‹å¥½â€”â€”å±å¹•ä¸Šæ²¡æœ‰æ›´æ–°çš„éƒ¨åˆ†ä¼šä¸€ç›´æ˜¯é»‘çš„ï¼Œé™¤éå¯¹åº”ç”¨è¿›è¡Œæ“ä½œä½¿å…¶åˆ·æ–°å±å¹•ã€‚ç¬”è€…è®¤ä¸ºå¦‚æœå°†æ•´ä¸ªå±å¹•çš„åƒç´ ä¿¡æ¯åŠ å…¥ä¸Šä¸‹æ–‡ï¼Œåœ¨æ¢å¤ä¸Šä¸‹æ–‡çš„æ—¶å€™å°†æ•´ä¸ªç”»é¢æ¢å¤ä¼šæœ‰æ¯”è¾ƒå¥½çš„æ•ˆæœã€‚ä½†è¿™æ ·ä¸Šä¸‹æ–‡ç»“æ„ä½“ä¼šæå…¶è‡ƒè‚¿ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"40d0202dbdc2113a3ba2cdc030ec7727","permalink":"https://kristoff-starling.github.io/notes/coursenotes/nju-ics/pa/pa4/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/notes/coursenotes/nju-ics/pa/pa4/","section":"notes","summary":"å®éªŒè¿›åº¦ æˆ‘å®Œæˆäº†æ‰€æœ‰çš„å¿…ç­”é¢˜ï¼Œå¹¶é’ˆå¯¹é€‰åšé¢˜å’Œæ€è€ƒé¢˜ç»™å‡ºäº†è‡ªå·±çš„æƒ³æ³•ã€‚\nå¿…ç­”é¢˜ åˆ†æ—¶å¤šä»»åŠ¡çš„å…·ä½“è¿‡ç¨‹ è¯·ç»“åˆä»£ç , è§£é‡Šåˆ†é¡µæœºåˆ¶å’Œç¡¬ä»¶ä¸­æ–­æ˜¯å¦‚ä½•æ”¯æ’‘ä»™å‰‘å¥‡ä¾ ä¼ å’Œhelloç¨‹åºåœ¨æˆ‘ä»¬çš„è®¡ç®—æœºç³»ç»Ÿ(Nanos-lite, AM, NEMU)ä¸­åˆ†æ—¶è¿è¡Œçš„.\nè¿™é‡Œä¸»è¦å™è¿°ä» hello ç”¨æˆ·ç¨‹åºåˆ‡æ¢åˆ° pal çš„è¿‡ç¨‹ã€‚åœ¨æŠ¢å å¼å¤šä»»åŠ¡ç³»ç»Ÿä¸­ï¼Œhello ç›¸å½“äºä¸€ä¸ªâ€œæ¶æ„ç”¨æˆ·ç¨‹åºâ€ï¼Œå› ä¸ºå®ƒä¸ä¼šä¸»åŠ¨ä½¿ç”¨ yield() æ¥è®©æ“ä½œç³»ç»Ÿåˆ‡æ¢ç¨‹åºã€‚ä½†å®ç°äº†æ—¶é’Ÿä¸­æ–­ä¹‹åæˆ‘ä»¬å¯ä»¥å¼ºåˆ¶ hello çš„æŒ‚èµ·ã€‚\næ¯ä¸€æ¡æŒ‡ä»¤æ‰§è¡Œç»“æŸæ—¶ï¼Œnemu çš„ cpu_exec() ä¸­éƒ½ä¼šè°ƒç”¨ timer_interrupt() å‡½æ•°æ¥æ£€æŸ¥ CPU çš„ INTR å¼•è„šæœ‰æ²¡æœ‰è¢«æ‹‰é«˜ã€‚å¦‚æœè¢«æ‹‰é«˜äº†è¯´æ˜æœ‰è®¾å¤‡å‘å‡ºäº†ä¸­æ–­è¯·æ±‚ï¼ˆåœ¨ PA ä¸­åªæœ‰æ—¶é’Ÿä¸­æ–­è¯·æ±‚ï¼‰ï¼Œæ­¤æ—¶ CPU ä¼šå°† mstatus å¯„å­˜å™¨çš„ MIE ä½ç½®é›¶ï¼ˆé˜²æ­¢ä¸­æ–­åµŒå¥—ï¼‰ï¼Œç„¶åè¿›å…¥ nanos-lite çš„ä¸­æ–­/å¼‚å¸¸å¤„ç†ç¨‹åº trap.","tags":null,"title":"PA4 - è™šå®äº¤é”™çš„é­”æ³•: åˆ†æ—¶å¤šä»»åŠ¡","type":"docs"},{"authors":null,"categories":null,"content":"é«˜ä¸­çš„æ—¶å€™ï¼Œæ¯å¤©è€å¸ˆä¼šç»™ä½ å¸ƒç½®ä¸€å †è¯•å·ï¼Œä½ ä»€ä¹ˆä¹Ÿä¸ç”¨ç®¡åªéœ€è¦è·Ÿç€è€å¸ˆçš„èŠ‚å¥èµ°ï¼›ä½†å¤§å­¦é‡Œï¼Œä½ å¾ˆå¯èƒ½åœ¨è¯¾ä¸‹æ ¹æœ¬æ‰¾ä¸åˆ°è€å¸ˆçš„è¸ªå½±ï¼Œå¤§å­¦è¯¾ç¨‹çš„ä½œä¸šé‡é€šå¸¸ä¸å¤§ï¼Œæ¯å¤©ä¼šæœ‰å¤§é‡çš„ç©ºä½™æ—¶é—´ä¸çŸ¥é“è¯¥åšä»€ä¹ˆâ€¦â€¦å› æ­¤è¿›å…¥å¤§å­¦åï¼Œå¤§å®¶ä¸€å®šè¦æ‰­è½¬è‡ªå·±çš„å­¦ä¹ æ¨¡å¼ï¼Œåšä¸€ä¸ª self-motivated çš„äººã€‚ä½ åº”å½“å­¦ä¼šä¸ºè‡ªå·±è§„åˆ’ï¼šåº”è¯¥çœ‹ä¸€äº›ä»€ä¹ˆæ ·çš„ä¹¦ï¼Œåº”å½“ä¸Šä¸€äº›ä»€ä¹ˆæ ·çš„ç½‘è¯¾ï¼Œå¦‚æœæ‰“ç®—å‡ºå›½æˆ‘æ˜¯ä¸æ˜¯åº”å½“ç€æ‰‹å‡†å¤‡è‹±è¯­æµ‹è¯•â€¦â€¦å­¦ä¼š self-learningï¼Œä½ æ‰èƒ½åœ¨å¤§å­¦ä¸­å­˜æ´»ä¸‹æ¥ã€‚\nä¸Šé¢çš„è¯æ˜¯å„ä¸ªå­¦ç§‘é€šç”¨çš„ï¼Œç€çœ¼äºè®¡ç®—æœºè¿™ä¸ªå­¦ç§‘ï¼Œself-learning æœ‰å…¶ç‹¬ç‰¹çš„æ–¹æ³•ã€‚è®¡ç®—æœºå­¦ç§‘çš„ä¸€å¤§ç‰¹ç‚¹åœ¨äºæŠ€æœ¯æ›´æ–°æå¿«â€”â€”ä½ å­¦ä¹ çš„æŸé¡¹æŠ€æœ¯å¾ˆå¯èƒ½æ˜¯å»å¹´åˆšåˆšäº§ç”Ÿçš„ï¼Œå¾ˆå¤šå·¥å…·çš„ä½¿ç”¨ä¹Ÿä¸ä¼šåœ¨æ•™ç§‘ä¹¦ä¸­å†™å‡ºã€‚å› æ­¤ä¸åŒäºå­¦ä¹ æ•°å­¦ç‰©ç†æ—¶å››å¤„å¯»æ‰¾å¥½çš„æ•™æï¼Œå­¦ä¹ è®¡ç®—æœºä¸€å®šè¦å­¦ä¼šåˆ©ç”¨å¥½å¼ºå¤§çš„äº’è”ç½‘ã€‚å­¦ä¹ å·¥å…·æ—¶ï¼Œå¤šæ‰¾ä¸€æ‰¾å®˜æ–¹çš„æ–‡æ¡£ (Almost all official manuals are written in English, which again demonstrates the significance of proficiency in English.)ï¼Œé‡åˆ°ç–‘éš¾æ‚ç—‡æ—¶ï¼Œå¤šçœ‹ä¸€çœ‹æœ‰æ²¡æœ‰ç±»ä¼¼çš„é—®é¢˜è§£ç­”å¯ä»¥å‚ç…§â€¦â€¦å½“ä½ é‡åˆ°é—®é¢˜ç¬¬ä¸€ååº”æ˜¯è‡ªå·±åŠ¨æ‰‹å¯»æ±‚è§£å†³æ–¹æ¡ˆè€Œä¸æ˜¯æ‰“å¼€å’Œâ€œå¤§è…¿â€çš„QQèŠå¤©æ¡†æ±‚æ•‘æ—¶ï¼Œä½ ä¾¿å·²ç»è¿›æ­¥äº†å¾ˆå¤šã€‚\nä¸‹é¢çš„è¯æ¥è‡ªå¤§å®¶æœªæ¥æ“ä½œç³»ç»Ÿè¯¾ç¨‹çš„è€å¸ˆï¼š\nSearch the friendly(f**king) web.\nRead the friendly(f**king) manual.\nå…¶ä¸­çš„ F è®©å®ƒä»¬æ›´å…·ä¼ å¥‡è‰²å½©ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"5701697cbff4a99cfb7f3e162370110e","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/cser0/self-learning/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/problemsolving22/cser0/self-learning/","section":"courses","summary":"é«˜ä¸­çš„æ—¶å€™ï¼Œæ¯å¤©è€å¸ˆä¼šç»™ä½ å¸ƒç½®ä¸€å †è¯•å·ï¼Œä½ ä»€ä¹ˆä¹Ÿä¸ç”¨ç®¡åªéœ€è¦è·Ÿç€è€å¸ˆçš„èŠ‚å¥èµ°ï¼›ä½†å¤§å­¦é‡Œï¼Œä½ å¾ˆå¯èƒ½åœ¨è¯¾ä¸‹æ ¹æœ¬æ‰¾ä¸åˆ°è€å¸ˆçš„è¸ªå½±ï¼Œå¤§å­¦è¯¾ç¨‹çš„ä½œä¸šé‡é€šå¸¸ä¸å¤§ï¼Œæ¯å¤©ä¼šæœ‰å¤§é‡çš„ç©ºä½™æ—¶é—´ä¸çŸ¥é“è¯¥åšä»€ä¹ˆâ€¦â€¦å› æ­¤è¿›å…¥å¤§å­¦åï¼Œå¤§å®¶ä¸€å®šè¦æ‰­è½¬è‡ªå·±çš„å­¦ä¹ æ¨¡å¼ï¼Œåšä¸€ä¸ª self-motivated çš„äººã€‚ä½ åº”å½“å­¦ä¼šä¸ºè‡ªå·±è§„åˆ’ï¼šåº”è¯¥çœ‹ä¸€äº›ä»€ä¹ˆæ ·çš„ä¹¦ï¼Œåº”å½“ä¸Šä¸€äº›ä»€ä¹ˆæ ·çš„ç½‘è¯¾ï¼Œå¦‚æœæ‰“ç®—å‡ºå›½æˆ‘æ˜¯ä¸æ˜¯åº”å½“ç€æ‰‹å‡†å¤‡è‹±è¯­æµ‹è¯•â€¦â€¦å­¦ä¼š self-learningï¼Œä½ æ‰èƒ½åœ¨å¤§å­¦ä¸­å­˜æ´»ä¸‹æ¥ã€‚\nä¸Šé¢çš„è¯æ˜¯å„ä¸ªå­¦ç§‘é€šç”¨çš„ï¼Œç€çœ¼äºè®¡ç®—æœºè¿™ä¸ªå­¦ç§‘ï¼Œself-learning æœ‰å…¶ç‹¬ç‰¹çš„æ–¹æ³•ã€‚è®¡ç®—æœºå­¦ç§‘çš„ä¸€å¤§ç‰¹ç‚¹åœ¨äºæŠ€æœ¯æ›´æ–°æå¿«â€”â€”ä½ å­¦ä¹ çš„æŸé¡¹æŠ€æœ¯å¾ˆå¯èƒ½æ˜¯å»å¹´åˆšåˆšäº§ç”Ÿçš„ï¼Œå¾ˆå¤šå·¥å…·çš„ä½¿ç”¨ä¹Ÿä¸ä¼šåœ¨æ•™ç§‘ä¹¦ä¸­å†™å‡ºã€‚å› æ­¤ä¸åŒäºå­¦ä¹ æ•°å­¦ç‰©ç†æ—¶å››å¤„å¯»æ‰¾å¥½çš„æ•™æï¼Œå­¦ä¹ è®¡ç®—æœºä¸€å®šè¦å­¦ä¼šåˆ©ç”¨å¥½å¼ºå¤§çš„äº’è”ç½‘ã€‚å­¦ä¹ å·¥å…·æ—¶ï¼Œå¤šæ‰¾ä¸€æ‰¾å®˜æ–¹çš„æ–‡æ¡£ (Almost all official manuals are written in English, which again demonstrates the significance of proficiency in English.)ï¼Œé‡åˆ°ç–‘éš¾æ‚ç—‡æ—¶ï¼Œå¤šçœ‹ä¸€çœ‹æœ‰æ²¡æœ‰ç±»ä¼¼çš„é—®é¢˜è§£ç­”å¯ä»¥å‚ç…§â€¦â€¦å½“ä½ é‡åˆ°é—®é¢˜ç¬¬ä¸€ååº”æ˜¯è‡ªå·±åŠ¨æ‰‹å¯»æ±‚è§£å†³æ–¹æ¡ˆè€Œä¸æ˜¯æ‰“å¼€å’Œâ€œå¤§è…¿â€çš„QQèŠå¤©æ¡†æ±‚æ•‘æ—¶ï¼Œä½ ä¾¿å·²ç»è¿›æ­¥äº†å¾ˆå¤šã€‚\nä¸‹é¢çš„è¯æ¥è‡ªå¤§å®¶æœªæ¥æ“ä½œç³»ç»Ÿè¯¾ç¨‹çš„è€å¸ˆï¼š\nSearch the friendly(f**king) web.\nRead the friendly(f**king) manual.","tags":null,"title":"Self Learning","type":"docs"},{"authors":null,"categories":null,"content":"ä»æŸç§è§’åº¦æ¥è¯´ï¼Œè®¡ç®—æœºé¢†åŸŸçš„å¤§ç‰›å¤šå°‘æœ‰ä¸€ç‚¹åæ‰§â€”â€”æ¯•ç«Ÿå†™ä»£ç çš„æ—¶å€™æ¼æ‰“ä¸€ä¸ªç¬¦å·ä¾¿å¯èƒ½é…¿æˆå¤§ç¥¸ï¼Œæ‰€ä»¥å­¦è®¡ç®—æœºçš„äººæ€»æœ‰ç‚¹â€œå¼ºè¿«ç—‡â€ã€‚é€€ä¸€æ­¥æ¥è¯´ï¼Œå³ä½¿ä½ æ²¡æœ‰å¼ºè¿«ç—‡ï¼Œå†™ä½œæ–‡çš„æ—¶å€™æ­ªä¸ƒæ‰­å…«ã€è¡Œé—´è·ä¸ä¸€ã€æ¯ä¸ªå­—éƒ½ä¸ä¸€æ ·å¤§ï¼Œå¼€å¤´æ—¶ä¸æ—¶åœ°å¿˜è®°ç©ºä¸¤æ ¼â€¦â€¦æ€»ä¸æ˜¯ä»¶å¥½äº‹ã€‚\nä½ ä¹Ÿè®¸åœ¨ä¹¦é¢åŠ©æ•™çš„ä½œä¸šè¦æ±‚ä¸­æ³¨æ„åˆ°äº† LaTeX è¿™ä¸ªä¸œè¥¿ã€‚$\\LaTeX$ æ˜¯ä¸€ä¸ªé«˜è´¨é‡çš„æ’ç‰ˆç³»ç»Ÿï¼Œä½ å¯ä»¥é€šè¿‡ç¼–å†™ä»£ç ç”Ÿæˆæ–‡æ¡£çš„æ–¹å¼æ¥ç²¾ç¡®åœ°æ§åˆ¶æ–‡æ¡£é‡Œçš„æ¯ä¸€å¤„ç»†èŠ‚ï¼Œæ¯”å¦‚åˆ†éš”çº¿çš„ç²—ç»†ã€å›¾ç‰‡çš„å¤§å°ï¼Œé¡µè¾¹è·çš„å®½çª„ç­‰ç­‰ï¼Œç²¾åº¦å¯ä»¥è¾¾åˆ°æ¯«ç±³ã€‚æˆ‘ä»¬ä¸å¼ºåˆ¶è¦æ±‚å¤§å®¶ä½¿ç”¨ LaTeX ä¹¦å†™ä½œä¸š (å› ä¸ºå¯¹äºæ–°æ‰‹æ¥è¯´è¿™å¯èƒ½ä¼šè€—è´¹å¾ˆå¤šçš„æ—¶é—´)ï¼Œä½†æˆ‘ä»¬ä»ç„¶æ¨èä½ å­¦ä¹ è¿™é¡¹å·¥å…· (ä¸å‡ºæ„å¤–ï¼Œä½ æ’°å†™æ¯•ä¸šè®ºæ–‡çš„æ—¶å€™æ˜¯è‚¯å®šä¼šç”¨åˆ°å®ƒçš„)ã€‚\nå¦‚æœä½ è®¤ä¸º $\\LaTeX$ å¤ªè¿‡éº»çƒ¦ï¼Œä¸å¦¨å°è¯•ä¸€ä¸‹ Markdownã€‚ä»åŸç†ä¸Šæ¥è¯´ Markdown å’Œ LaTeX å¾ˆä¸ä¸€æ ·ï¼Œä½†ä½ å¯ä»¥ç®€å•åœ°è®¤ä¸ºå®ƒä»¬éƒ½æ˜¯é€šè¿‡ä¸€äº›ç‰¹æ®Šçš„ç¬¦å·æ¥ç”Ÿæˆå…·æœ‰æ ¼å¼ï¼Œç¼–æ’ç¾è§‚çš„æ–‡æ¡£ (åŠ©æ•™åšå®¢ä¸­çš„å¤§éƒ¨åˆ†é¡µé¢éƒ½æ˜¯ç”¨ Markdown ä¹¦å†™çš„)ã€‚Markdown æ¯” LaTeX ç®€æ˜å¾ˆå¤šï¼Œæ¯”å¦‚ä½ å¯ä»¥é€šè¿‡ # æ¥ç”Ÿæˆå„ä¸ªçº§åˆ«çš„æ ‡é¢˜ï¼š\nè¿™æ˜¯äºŒçº§æ ‡é¢˜ è¿™æ˜¯ä¸‰çº§æ ‡é¢˜ å¯ä»¥é€šè¿‡ * æ¥ç”Ÿæˆåˆ—è¡¨ï¼š\nåˆ—è¡¨1 åˆ—è¡¨2 Markdown åŒæ ·æ”¯æŒä¸°å¯Œçš„æ•°å­¦ç¬¦å·ï¼š\n\\begin{align} f(n)=\\sum_{d|n}g(d)\\Longleftrightarrow g(n)=\\sum_{d|n}\\mu(d)f\\left(\\frac{n}{d}\\right). \\end{align} $$ \\begin{align} f(n)=\\sum_{d|n}g(d)\\Longleftrightarrow g(n)=\\sum_{d|n}\\mu(d)f\\left(\\frac{n}{d}\\right). \\end{align} $$\næˆ‘ä»¬å¼ºçƒˆå»ºè®®ä½ è‡³å°‘æŒæ¡ä¸€äº› Markdown çš„åŸºæœ¬è¯­æ³•ï¼Œè¿™å¯ä»¥å¸®åŠ©ä½ å°†æ¥è¿…é€Ÿåœ°å†™å‡ºä¸€ä»½è¿˜ç®—ç¾è§‚çš„æ–‡æ¡£ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"be0ce6b9feb12c6c4963e17d53343cb5","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/cser0/typesetting/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/problemsolving22/cser0/typesetting/","section":"courses","summary":"ä»æŸç§è§’åº¦æ¥è¯´ï¼Œè®¡ç®—æœºé¢†åŸŸçš„å¤§ç‰›å¤šå°‘æœ‰ä¸€ç‚¹åæ‰§â€”â€”æ¯•ç«Ÿå†™ä»£ç çš„æ—¶å€™æ¼æ‰“ä¸€ä¸ªç¬¦å·ä¾¿å¯èƒ½é…¿æˆå¤§ç¥¸ï¼Œæ‰€ä»¥å­¦è®¡ç®—æœºçš„äººæ€»æœ‰ç‚¹â€œå¼ºè¿«ç—‡â€ã€‚é€€ä¸€æ­¥æ¥è¯´ï¼Œå³ä½¿ä½ æ²¡æœ‰å¼ºè¿«ç—‡ï¼Œå†™ä½œæ–‡çš„æ—¶å€™æ­ªä¸ƒæ‰­å…«ã€è¡Œé—´è·ä¸ä¸€ã€æ¯ä¸ªå­—éƒ½ä¸ä¸€æ ·å¤§ï¼Œå¼€å¤´æ—¶ä¸æ—¶åœ°å¿˜è®°ç©ºä¸¤æ ¼â€¦â€¦æ€»ä¸æ˜¯ä»¶å¥½äº‹ã€‚\nä½ ä¹Ÿè®¸åœ¨ä¹¦é¢åŠ©æ•™çš„ä½œä¸šè¦æ±‚ä¸­æ³¨æ„åˆ°äº† LaTeX è¿™ä¸ªä¸œè¥¿ã€‚$\\LaTeX$ æ˜¯ä¸€ä¸ªé«˜è´¨é‡çš„æ’ç‰ˆç³»ç»Ÿï¼Œä½ å¯ä»¥é€šè¿‡ç¼–å†™ä»£ç ç”Ÿæˆæ–‡æ¡£çš„æ–¹å¼æ¥ç²¾ç¡®åœ°æ§åˆ¶æ–‡æ¡£é‡Œçš„æ¯ä¸€å¤„ç»†èŠ‚ï¼Œæ¯”å¦‚åˆ†éš”çº¿çš„ç²—ç»†ã€å›¾ç‰‡çš„å¤§å°ï¼Œé¡µè¾¹è·çš„å®½çª„ç­‰ç­‰ï¼Œç²¾åº¦å¯ä»¥è¾¾åˆ°æ¯«ç±³ã€‚æˆ‘ä»¬ä¸å¼ºåˆ¶è¦æ±‚å¤§å®¶ä½¿ç”¨ LaTeX ä¹¦å†™ä½œä¸š (å› ä¸ºå¯¹äºæ–°æ‰‹æ¥è¯´è¿™å¯èƒ½ä¼šè€—è´¹å¾ˆå¤šçš„æ—¶é—´)ï¼Œä½†æˆ‘ä»¬ä»ç„¶æ¨èä½ å­¦ä¹ è¿™é¡¹å·¥å…· (ä¸å‡ºæ„å¤–ï¼Œä½ æ’°å†™æ¯•ä¸šè®ºæ–‡çš„æ—¶å€™æ˜¯è‚¯å®šä¼šç”¨åˆ°å®ƒçš„)ã€‚\nå¦‚æœä½ è®¤ä¸º $\\LaTeX$ å¤ªè¿‡éº»çƒ¦ï¼Œä¸å¦¨å°è¯•ä¸€ä¸‹ Markdownã€‚ä»åŸç†ä¸Šæ¥è¯´ Markdown å’Œ LaTeX å¾ˆä¸ä¸€æ ·ï¼Œä½†ä½ å¯ä»¥ç®€å•åœ°è®¤ä¸ºå®ƒä»¬éƒ½æ˜¯é€šè¿‡ä¸€äº›ç‰¹æ®Šçš„ç¬¦å·æ¥ç”Ÿæˆå…·æœ‰æ ¼å¼ï¼Œç¼–æ’ç¾è§‚çš„æ–‡æ¡£ (åŠ©æ•™åšå®¢ä¸­çš„å¤§éƒ¨åˆ†é¡µé¢éƒ½æ˜¯ç”¨ Markdown ä¹¦å†™çš„)ã€‚Markdown æ¯” LaTeX ç®€æ˜å¾ˆå¤šï¼Œæ¯”å¦‚ä½ å¯ä»¥é€šè¿‡ # æ¥ç”Ÿæˆå„ä¸ªçº§åˆ«çš„æ ‡é¢˜ï¼š\nè¿™æ˜¯äºŒçº§æ ‡é¢˜ è¿™æ˜¯ä¸‰çº§æ ‡é¢˜ å¯ä»¥é€šè¿‡ * æ¥ç”Ÿæˆåˆ—è¡¨ï¼š","tags":null,"title":"Typesetting","type":"docs"},{"authors":null,"categories":null,"content":"å¯¹äºé›¶åŸºç¡€çš„åŒå­¦æ¥è¯´ï¼Œé”®ç›˜å¯èƒ½æ˜¯ååˆ†é™Œç”Ÿçš„ã€‚ä½†å¤§å®¶æ—¢ç„¶é€‰æ‹©äº†CSï¼Œè®¡ç®—æœºä¹‹äºå¤§å®¶å°±åº”å½“ç›¸å½“äºå®å‰‘ä¹‹äºéª‘å£«ï¼Œæ‰“å­—å°±åº”å½“åƒæ‹¿ç­·å­åƒé¥­ä¸€æ ·ç†Ÿç»ƒã€‚å¦‚æœä½ è¿\nåº”å½“å¦‚ä½•é€šè¿‡é”®ç›˜æ•²å‡ºä¸‹åˆ’çº¿ _ ï¼Ÿ\nè¿™ä¸ªé—®é¢˜éƒ½æ„Ÿåˆ°æ— ä»ä¸‹æ‰‹ï¼Œé‚£ä½ ä¸€å®šè¦èŠ±ä¸€äº›åŠŸå¤«ç»ƒä¹ æ‰“å­—ã€‚\næ‰“å­—è¿™ä»¶äº‹å¾ˆåƒæŠ•ç¯®ã€‚èƒ½æŠŠçƒæŠ•è¿›ç¯®ç­çš„å§¿åŠ¿éƒ½æ˜¯å¥½å§¿åŠ¿ï¼ŒåŒç†æ‰“å¾—å¿«ã€å‡†ç¡®ç‡é«˜çš„å§¿åŠ¿ä¹Ÿéƒ½æ˜¯å¥½å§¿åŠ¿ã€‚ä½†æˆ‘ä»¬è¿˜æ˜¯å»ºè®®åˆå­¦è€…æ‰“å¥½åŸºç¡€ï¼Œå­¦ä¹ æ­£è§„çš„åæŒ‡å¸ƒå±€ã€‚æˆ‘ä»¬è®¤ä¸ºä¸€ä¸ªåˆæ ¼çš„CSeråº”å½“æ‹¥æœ‰200+cpm (character per minute) çš„æ‰“å­—é€Ÿåº¦ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"ac6430c6d3c2f9c7e310fc09cd539769","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/cser0/typing/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/problemsolving22/cser0/typing/","section":"courses","summary":"å¯¹äºé›¶åŸºç¡€çš„åŒå­¦æ¥è¯´ï¼Œé”®ç›˜å¯èƒ½æ˜¯ååˆ†é™Œç”Ÿçš„ã€‚ä½†å¤§å®¶æ—¢ç„¶é€‰æ‹©äº†CSï¼Œè®¡ç®—æœºä¹‹äºå¤§å®¶å°±åº”å½“ç›¸å½“äºå®å‰‘ä¹‹äºéª‘å£«ï¼Œæ‰“å­—å°±åº”å½“åƒæ‹¿ç­·å­åƒé¥­ä¸€æ ·ç†Ÿç»ƒã€‚å¦‚æœä½ è¿\nåº”å½“å¦‚ä½•é€šè¿‡é”®ç›˜æ•²å‡ºä¸‹åˆ’çº¿ _ ï¼Ÿ\nè¿™ä¸ªé—®é¢˜éƒ½æ„Ÿåˆ°æ— ä»ä¸‹æ‰‹ï¼Œé‚£ä½ ä¸€å®šè¦èŠ±ä¸€äº›åŠŸå¤«ç»ƒä¹ æ‰“å­—ã€‚\næ‰“å­—è¿™ä»¶äº‹å¾ˆåƒæŠ•ç¯®ã€‚èƒ½æŠŠçƒæŠ•è¿›ç¯®ç­çš„å§¿åŠ¿éƒ½æ˜¯å¥½å§¿åŠ¿ï¼ŒåŒç†æ‰“å¾—å¿«ã€å‡†ç¡®ç‡é«˜çš„å§¿åŠ¿ä¹Ÿéƒ½æ˜¯å¥½å§¿åŠ¿ã€‚ä½†æˆ‘ä»¬è¿˜æ˜¯å»ºè®®åˆå­¦è€…æ‰“å¥½åŸºç¡€ï¼Œå­¦ä¹ æ­£è§„çš„åæŒ‡å¸ƒå±€ã€‚æˆ‘ä»¬è®¤ä¸ºä¸€ä¸ªåˆæ ¼çš„CSeråº”å½“æ‹¥æœ‰200+cpm (character per minute) çš„æ‰“å­—é€Ÿåº¦ã€‚","tags":null,"title":"Typing","type":"docs"},{"authors":null,"categories":null,"content":"éšç€ç¨‹åºè§„æ¨¡çš„æ‰©å¤§ï¼Œä½ çš„ main() å‡½æ•°å¯èƒ½å˜å¾—è¶Šæ¥è¶Šè‡ƒè‚¿äº†ã€‚è¿™æ—¶å€™ä½¿ç”¨å‡½æ•°å°†ä¸åŒçš„æ¨¡å—åˆ†å¼€ä¹¦å†™ï¼Œå¯ä»¥è®©ç¨‹åºå˜å¾—æ¡ç†æ¸…æ™°ã€ç®€æ˜æ˜“æ‡‚ã€‚ä¾‹å¦‚ä¸‹é¢æ˜¯ OJ ä¹ é¢˜ \u0026ldquo;ç¯å½¢çŸ©é˜µ\u0026rdquo; çš„ä¸€æ®µä»£ç ï¼š\nint n; int a[100][100]; int main () { scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); for (int k = 1; k \u0026lt;= (n + 1) / 2; k++) for (int i = k; i \u0026lt;= n + 1 - k; i++) for (int j = k; j \u0026lt;= n + 1 - k; j++) a[i][j] = k; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) printf(\u0026quot;%4d\u0026quot;, a[i][j]); puts(\u0026quot;\u0026quot;); } return 0; } è¯»å…¥ã€çŸ©é˜µåˆ¶ä½œã€è¾“å‡ºä¸‰ä¸ªæ­¥éª¤å…¨éƒ¨æ”¾åœ¨ main() å‡½æ•°ä¸­æ˜¾å¾—æœ‰äº›å†—é•¿ã€‚æˆ‘ä»¬å¯ä»¥æ ¹æ®åŠŸèƒ½å°†ä¸Šè¿°ä»£ç åˆ†æˆä¸‰ä¸ªæ¨¡å—ï¼Œæ¯ä¸ªæ¨¡å—å†™åœ¨ä¸€ä¸ªå•ç‹¬çš„å­å‡½æ•°é‡Œï¼š\nint n; int a[100][100]; void input() { scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); } void matrix_generation() { for (int k = 1; k \u0026lt;= (n + 1) / 2; k++) for (int i = k; i \u0026lt;= n + 1 - k; i++) for (int j = k; j \u0026lt;= n + 1 - k; j++) a[i][j] = k; } void print() { for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) printf(\u0026quot;%4d\u0026quot;, a[i][j]); puts(\u0026quot;\u0026quot;); } } int main () { input(); matrix_generation(); print(); return 0; } ç”±äºè¿™ä¸ªç¨‹åºæ¯”è¾ƒç®€å•ï¼Œä½ å¯èƒ½ä¼šè§‰å¾—è¿™æ ·å†™ä»£ç éå¸¸æ‹–æ²“ã€‚ä½†éšç€ç¨‹åºç»“æ„çš„è¿›ä¸€æ­¥å¤æ‚åŒ–ï¼Œä½ ä¸€å®šä¼šå‘ç°å°†ç¨‹åºåˆ†åŠŸèƒ½åˆ†æ¨¡å—ä¹¦å†™èƒ½å¸®åŠ©ä½ ç†æ¸…æ€è·¯ï¼Œä¹Ÿæ–¹ä¾¿ debugã€‚\nä»£ç é£æ ¼\nå¯¹äºåˆå­¦è€…æ¥è¯´ï¼Œå…»æˆè‰¯å¥½çš„ä»£ç é£æ ¼æå…¶é‡è¦ã€‚ä¸€æ–¹é¢ï¼Œæ¡ç†æ¸…æ™°çš„ä»£ç çœ‹èµ·æ¥èµå¿ƒæ‚¦ç›®ï¼Œæ–¹ä¾¿è‡ªå·± debugï¼›å¦ä¸€æ–¹é¢ï¼Œå¦‚æœä½ å°†æ¥ä¸åˆ«äººåˆä½œå¼€å‘é¡¹ç›®ï¼Œè‰¯å¥½çš„ä»£ç é£æ ¼å¯ä»¥è®©ä»–äººå¿«é€Ÿç†è§£ä½ ä¹¦å†™çš„æ¨¡å—ï¼Œæ–¹ä¾¿æ²Ÿé€šäº¤æµã€‚å¤§å®¶æˆ–è®¸å¬è¯´è¿‡ä¸€äº›ç±»ä¼¼äº â€œè€ç¨‹åºå‘˜ä¸€èµ°ï¼Œæ•´ä¸ªé¡¹ç›®å°±ç©ä¸è½¬äº†ï¼Œå› ä¸ºæ²¡äººçŸ¥é“ä»–å†™äº†ä»€ä¹ˆâ€ çš„ç¬‘è¯ï¼Œæ’‡å¼€å·¥ç¨‹å¤æ‚æ€§çš„å®¢è§‚åŸå› ï¼Œè¿™æ ·çš„ç°è±¡ä¹Ÿè¯´æ˜å¾ˆå¤§ä¸€éƒ¨åˆ†ç¨‹åºå‘˜çš„ä»£ç ä¹¦å†™ä¹ æƒ¯æå…¶ç³Ÿç³•ã€‚\næ‰€ä»¥æ— è®ºä½ æ˜¯å¦æœ‰ç¼–ç¨‹åŸºç¡€ï¼Œè¯·ä¸€å®šé‡è§†è‡ªå·±çš„ä»£ç é£æ ¼ã€‚æˆ‘ä»¬å»ºè®®ä½ è‡³å°‘åœ¨ä»¥ä¸‹å‡ ä¸ªæ–¹é¢æ³¨æ„ï¼š\nåˆç†çš„å˜é‡å‘½åï¼šä¸è¦ä½¿ç”¨æ— æ„ä¹‰çš„ a b c _ __ï¼Œè€Œåº”è¯¥ä½¿ç”¨ arrayLength stuCount ç­‰ã€‚æœ‰æ„ä¹‰çš„å˜é‡åå¯ä»¥è®©ä½ /ä»–äººç«‹åˆ»ç†è§£è¿™ä¸ªå˜é‡çš„ç”¨é€”ã€‚è‡³äºå˜é‡çš„å‘½åæ ¼å¼ï¼Œæˆ‘ä»¬å»ºè®®ä½ æœç´¢é©¼å³°å‘½åæ³•ã€‚ åˆç†çš„å‡½æ•°ä½¿ç”¨ï¼šä¸è¦å°†ä¸€å¤§å †ä»£ç å¡åœ¨ä¸€èµ·ã€‚ åˆç†ä¹¦å†™æ³¨é‡Šï¼Œå¯¹ç¨‹åºçš„åŠŸèƒ½åšä¸€ç‚¹è§£é‡Šã€‚ åˆç†çš„ç¬¦å·ä½¿ç”¨ (æ‹¬å·ï¼Œæ¢è¡Œç¬¦ etc.) åˆç†çš„ç¼©è¿› â€¦â€¦ å¦‚æœä½ æ„Ÿå…´è¶£ï¼Œä½ å¯ä»¥ä¸Šç½‘æœç´¢ Google çš„ä»£ç é£æ ¼è§„èŒƒã€‚\næœ€åæ˜¯ä¸€ä¸ªå°ç¬‘è¯ï¼š\nä¸–ç•Œä¸Šæœ‰ä¸¤ä»¶æœ€è®¨åŒçš„äº‹æƒ…ï¼Œä¸€ä¸ªæ˜¯å†™æ³¨é‡Šï¼Œä¸€ä¸ªæ˜¯åˆ«äººçš„ä»£ç ä¸å†™æ³¨é‡Šã€‚\nå®šä¹‰ å‡½æ•°çš„åŸºæœ¬è¯­æ³•å¦‚ä¸‹ï¼š\nint func(int a, float b, char c, ...) { } å…¶ä¸­\nç¬¬ä¸€ä¸ª int æŒ‡æ˜äº†å‡½æ•°çš„è¿”å›å€¼ç±»å‹ä¸º intã€‚ä½ å½“ç„¶å¯ä»¥é€‰æ‹©åˆ«çš„ç±»å‹ï¼Œå¦‚æœä½ çš„å‡½æ•°ä¸éœ€è¦è¿”å›å€¼ï¼Œå¯ä»¥ç”¨ voidã€‚ func æ˜¯å‡½æ•°çš„åç§°ã€‚è¿™æ˜¯ä½ å¯ä»¥è‡ªç”±æŒ‡å®šçš„éƒ¨åˆ†ã€‚ (int a, float b, ...) æ˜¯å‡½æ•°çš„å‚æ•°ã€‚ä½ å¯ä»¥æŒ‡å®šä»»æ„ä¸ªæ•°çš„å‚æ•°ï¼Œä½†æ¯ä¸ªå‚æ•°éƒ½è¦æœ‰ç±»å‹ã€‚ ä¸‹é¢æ˜¯ä¸€ä¸ªç®€æ˜çš„ä¾‹å­ï¼š\nint abs(int x) { int res = x \u0026gt;= 0 ? x : -x; return res; } int main () { int x = -1; x_abs = abs(x); // x_abs = 1 return 0; } æ³¨æ„æ‰€æœ‰çš„å­å‡½æ•°è¦å†™åœ¨ main å‡½æ•°çš„ä¸Šæ–¹ (è¿™æ˜¯ C/C++ çš„è¦æ±‚)ã€‚å¦‚æœä½ æƒ³è¦å°†å­å‡½æ•°å†™åœ¨ main å‡½æ•°çš„ä¸‹æ–¹ï¼Œéœ€è¦åœ¨ main å‡½æ•°ä¹‹å‰å…ˆå£°æ˜è¯¥å­å‡½æ•°ã€‚å£°æ˜ç®€å•æ¥è¯´å°±æ˜¯å°†å‡½æ•°çš„å®šä¹‰æŠ„ä¸€éï¼š\nint abs(int x); int main () { int x = -1; x_abs = abs(x); return 0; } int abs(int x) { int res = x \u0026gt;= 0 ? x : -x; return res; } å˜é‡çš„ä½œç”¨åŸŸ æœ‰äº†å‡½æ•°çš„æ¦‚å¿µåæˆ‘ä»¬å°±å¿…é¡»è¦åŒºåˆ†â€œå…¨å±€å˜é‡â€œå’Œâ€œå±€éƒ¨å˜é‡â€ã€‚é¡¾åæ€ä¹‰åœ¨å‡½æ•°å†…éƒ¨å®šä¹‰çš„å˜é‡æ˜¯å±€éƒ¨å˜é‡ï¼Œè¯¥å˜é‡åªèƒ½åœ¨å½“å‰å‡½æ•°å†…ä½¿ç”¨ã€‚åœ¨æ‰€æœ‰å‡½æ•°å¤–å®šä¹‰çš„å˜é‡æ˜¯å…¨å±€å˜é‡ï¼Œè¯¥å˜é‡å¯ä»¥åœ¨ä»»ä½•å‡½æ•°ä¸­ä½¿ç”¨ (æ³¨ï¼šä¸€ä¸ªå‡½æ•°çš„å‚æ•°ä¹Ÿæ˜¯è¯¥å‡½æ•°çš„å±€éƒ¨å˜é‡)ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š\nint n = 0; void func() { printf(\u0026quot;%d\\n\u0026quot;, n); // è¾“å‡ºç»“æœä¸º 0ã€‚ printf(\u0026quot;%d\\n\u0026quot;, m); // ç¼–è¯‘é”™è¯¯ï¼šm æ˜¯ main() çš„å±€éƒ¨å˜é‡ï¼Œåœ¨ func() ä¸­ä¸å¯ç”¨ã€‚ } int main () { int n = 1, m = 2; printf(\u0026quot;%d\\n\u0026quot;, n); // è¾“å‡ºç»“æœä¸º 1ï¼Œå…¨å±€å˜é‡å’Œå±€éƒ¨å˜é‡é‡åä¼˜å…ˆä½¿ç”¨å±€éƒ¨å˜é‡ã€‚ } æŒ‰å€¼ä¼ é€’å’ŒæŒ‰å¼•ç”¨ä¼ é€’ æŒ‰å€¼ä¼ é€’å’ŒæŒ‰å¼•ç”¨ä¼ é€’æ˜¯å‡½æ•°ä¸­å¿…é¡»æåŠçš„å¦ä¸€ä¸ªé‡è¦æ¦‚å¿µã€‚å¾ˆå¤šåˆå­¦è€…ä¼šç–‘æƒ‘ï¼šå¦‚æœæˆ‘åœ¨å­å‡½æ•°ä¸­å¯¹å‚æ•°çš„å€¼åšäº†æ”¹åŠ¨ï¼Œä¸»å‡½æ•°é‡Œç›¸åº”çš„å˜é‡ä¼šå˜å—ï¼Ÿä½ å¯ä»¥åšä¸€ä¸ªå°å®éªŒæ¢ç´¢è¿™ä¸€ç‚¹ï¼š\nvoid func(int x) { x = 2; } int main () { int x = 1; func(x); printf(\u0026quot;%d\\n\u0026quot;, x); // è¾“å‡ºç»“æœä¸º 1 } äº‹å®è¯æ˜å­å‡½æ•°çš„æ”¹åŠ¨ä¸ä¼šå½±å“ä¸»å‡½æ•°ã€‚è¿™æ˜¯å› ä¸º C/C++ ä¸­å‡½æ•°å˜é‡å‚æ•°çš„ä¼ é€’é»˜è®¤ä½¿ç”¨æŒ‰å€¼ä¼ é€’ï¼Œå³å­å‡½æ•°çš„å‚æ•°å˜é‡ x å’Œä¸»å‡½æ•°çš„å˜é‡ x æ˜¯ä¸¤ä¸ªç‹¬ç«‹çš„ä¸»ä½“ï¼Œåœ¨å‡½æ•°è°ƒç”¨æ—¶ä¸»å‡½æ•°çš„ x çš„å€¼ä¼šè¢«å¤åˆ¶åˆ°å­å‡½æ•°çš„ x ä¸­ï¼Œåœ¨å­å‡½æ•°ä¸­å¯¹ x çš„æ‰€æœ‰æ”¹åŠ¨éƒ½æ˜¯é’ˆå¯¹è¿™ä¸ªâ€œå¤å°ä»¶â€çš„ï¼Œå¯¹åŸä»¶æ²¡æœ‰å½±å“ã€‚\né‚£ä¹ˆæœ‰æ²¡æœ‰åŠæ³•å¯ä»¥è®©å­å‡½æ•°ç›´æ¥ä¿®æ”¹ä¸»å‡½æ•°ä¸­çš„å˜é‡çš„å€¼å‘¢ï¼Ÿ C++ æä¾›äº†å¼•ç”¨å˜é‡çš„æœºåˆ¶ï¼Œä¸€ä¸ªä¾‹å­å¦‚ä¸‹ï¼š\nvoid func(int x, int \u0026amp;y) { x++; y++; } int main () { int x = 1, y = 1; func(x, y); printf(\u0026quot;%d %d\\n\u0026quot;, x, y); // è¾“å‡ºç»“æœä¸º 1 2 } åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œx æ˜¯æŒ‰å€¼ä¼ é€’çš„ï¼Œy æ˜¯æŒ‰å¼•ç”¨ä¼ é€’çš„ (æ³¨æ„å‡½æ•°å‚æ•°å‰çš„ \u0026amp; ç¬¦å·)ã€‚æŒ‰å¼•ç”¨ä¼ é€’å¯ä»¥ç†è§£ä¸ºç›´æ¥å°†åŸä»¶äº¤ç»™äº†å­å‡½æ•°ï¼Œå­å‡½æ•°çš„æ”¹åŠ¨ä¼šå½±å“ä¸»å‡½æ•°çš„å€¼ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"bf40eb456eef4ee614fb8bb8d9689526","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/c++0/functions/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/problemsolving22/c++0/functions/","section":"courses","summary":"éšç€ç¨‹åºè§„æ¨¡çš„æ‰©å¤§ï¼Œä½ çš„ main() å‡½æ•°å¯èƒ½å˜å¾—è¶Šæ¥è¶Šè‡ƒè‚¿äº†ã€‚è¿™æ—¶å€™ä½¿ç”¨å‡½æ•°å°†ä¸åŒçš„æ¨¡å—åˆ†å¼€ä¹¦å†™ï¼Œå¯ä»¥è®©ç¨‹åºå˜å¾—æ¡ç†æ¸…æ™°ã€ç®€æ˜æ˜“æ‡‚ã€‚ä¾‹å¦‚ä¸‹é¢æ˜¯ OJ ä¹ é¢˜ \u0026ldquo;ç¯å½¢çŸ©é˜µ\u0026rdquo; çš„ä¸€æ®µä»£ç ï¼š\nint n; int a[100][100]; int main () { scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); for (int k = 1; k \u0026lt;= (n + 1) / 2; k++) for (int i = k; i \u0026lt;= n + 1 - k; i++) for (int j = k; j \u0026lt;= n + 1 - k; j++) a[i][j] = k; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) printf(\u0026quot;%4d\u0026quot;, a[i][j]); puts(\u0026quot;\u0026quot;); } return 0; } è¯»å…¥ã€çŸ©é˜µåˆ¶ä½œã€è¾“å‡ºä¸‰ä¸ªæ­¥éª¤å…¨éƒ¨æ”¾åœ¨ main() å‡½æ•°ä¸­æ˜¾å¾—æœ‰äº›å†—é•¿ã€‚æˆ‘ä»¬å¯ä»¥æ ¹æ®åŠŸèƒ½å°†ä¸Šè¿°ä»£ç åˆ†æˆä¸‰ä¸ªæ¨¡å—ï¼Œæ¯ä¸ªæ¨¡å—å†™åœ¨ä¸€ä¸ªå•ç‹¬çš„å­å‡½æ•°é‡Œï¼š","tags":null,"title":"å‡½æ•°","type":"docs"},{"authors":null,"categories":null,"content":"å¾ˆå¤šæ—¶å€™æˆ‘ä»¬éœ€è¦æ ¹æ®æŸä¸ªæ¡ä»¶å†³å®šå»åšäº‹æƒ…1è¿˜æ˜¯äº‹æƒ…2,è¿™å°±æ˜¯åˆ†æ”¯ã€‚ä¸€ä¸ªåˆ†æ”¯æ¡†æ¶çš„æ ¼å¼å¦‚ä¸‹ï¼š\nif (condition) { // your code } å®ƒçš„æ„æ€æ˜¯ï¼šå¦‚æœ if () æ‹¬å·ä¸­çš„æ¡ä»¶æˆç«‹ï¼Œé‚£ä¹ˆå°±æ‰§è¡Œå¤§æ‹¬å·ä¸­çš„é‚£äº›è¯­å¥ï¼Œå¦åˆ™è·³è¿‡è¿™äº›è¯­å¥ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥æ·»åŠ  else åˆ†æ”¯ï¼š\nif (condition) { // your code } else { // your code } è¿™æ—¶å¦‚æœæ¡ä»¶æˆç«‹å°±æ‰§è¡Œç´§æ¥ç€çš„å¤§æ‹¬å·ä¸­çš„è¯­å¥ï¼Œå¹¶è·³è¿‡ else ä¸‹çš„è¯­å¥ï¼›å¦‚æœæ¡ä»¶ä¸æˆç«‹å°±è·³è¿‡ç´§æ¥ç€çš„è¯­å¥ï¼Œç›´æ¥æ‰§è¡Œ else ä¸‹çš„è¯­å¥ã€‚ä¸€ä¸ªé¢å¤–çš„è§„åˆ™æ˜¯ï¼šå¦‚æœ \u0026ldquo;your code\u0026rdquo; çš„åœ°æ–¹ä½ åªéœ€è¦å†™ä¸€æ¡è¯­å¥ï¼Œä½ å¯ä»¥çœç•¥å¤§æ‹¬å·å¯¹ (è¿™æ ·ä»£ç çœ‹ä¸Šå»æ›´ç´§å‡‘ç®€æ´)ï¼Œä¸è¿‡å¦‚æœä½ æ²¡æœ‰æŠŠæ¡ï¼ŒåŠ ä¸Šå¤§æ‹¬å·æ°¸è¿œæ˜¯æœ€ç¨³å¦¥æœ€æ­£ç¡®çš„é€‰æ‹©ã€‚\næˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼šè¾“å…¥ä¸¤ä¸ªæ•°ï¼Œå¦‚æœå®ƒä»¬çš„å’Œæ˜¯å¥‡æ•°å°±è¾“å‡º \u0026ldquo;odd\u0026rdquo;ï¼Œå¦åˆ™è¾“å‡º \u0026ldquo;even\u0026rdquo;ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; int main () { int a, b, sum; std::cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; sum = a + b; if (sum % 2 == 1) std::cout \u0026lt;\u0026lt; \u0026quot;odd\u0026quot; \u0026lt;\u0026lt; '\\n'; else std::cout \u0026lt;\u0026lt; \u0026quot;even\u0026quot; \u0026lt;\u0026lt; '\\n'; return 0; } è¿™é‡Œéœ€è¦å¯¹ if çš„æ¡ä»¶è¯­å¥åšä¸€ç‚¹è¯´æ˜ï¼š\n% æ˜¯å–æ¨¡ç¬¦å·ï¼Œsum % 2 å³è®¡ç®—å˜é‡ sum é™¤ä»¥ 2 åçš„ä½™æ•°ã€‚ åœ¨ C++ ä¸­æˆ‘ä»¬è¦æ ¼å¤–å°å¿ƒ == å’Œ = çš„åŒºåˆ«: == æ˜¯ä¸€ä¸ªæ¯”è¾ƒè¿ç®—ç¬¦ï¼Œç”¨æ¥æ¯”è¾ƒå¼å­çš„å·¦è¾¹å’Œå³è¾¹æ˜¯å¦ç›¸ç­‰ã€‚å…¶ä»–çš„ä¸€äº›å¸¸ç”¨çš„æ¯”è¾ƒè¿ç®—ç¬¦åˆ—ä¸¾å¦‚ä¸‹\nç¬¦å· æ„ä¹‰ \u0026lt;= å°äºç­‰äº \u0026lt; å°äº \u0026gt;= å¤§äºç­‰äº \u0026gt; å¤§äº != ä¸ç­‰äº = æ˜¯èµ‹å€¼ç¬¦å·ï¼Œæ¯”å¦‚åœ¨ sum = a + b; ä¸­ï¼Œå°† a + b çš„å€¼èµ‹ç»™ sumã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"74bc57c6713cea8a7e36283b093daed4","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/c++0/branch/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/problemsolving22/c++0/branch/","section":"courses","summary":"å¾ˆå¤šæ—¶å€™æˆ‘ä»¬éœ€è¦æ ¹æ®æŸä¸ªæ¡ä»¶å†³å®šå»åšäº‹æƒ…1è¿˜æ˜¯äº‹æƒ…2,è¿™å°±æ˜¯åˆ†æ”¯ã€‚ä¸€ä¸ªåˆ†æ”¯æ¡†æ¶çš„æ ¼å¼å¦‚ä¸‹ï¼š\nif (condition) { // your code } å®ƒçš„æ„æ€æ˜¯ï¼šå¦‚æœ if () æ‹¬å·ä¸­çš„æ¡ä»¶æˆç«‹ï¼Œé‚£ä¹ˆå°±æ‰§è¡Œå¤§æ‹¬å·ä¸­çš„é‚£äº›è¯­å¥ï¼Œå¦åˆ™è·³è¿‡è¿™äº›è¯­å¥ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥æ·»åŠ  else åˆ†æ”¯ï¼š\nif (condition) { // your code } else { // your code } è¿™æ—¶å¦‚æœæ¡ä»¶æˆç«‹å°±æ‰§è¡Œç´§æ¥ç€çš„å¤§æ‹¬å·ä¸­çš„è¯­å¥ï¼Œå¹¶è·³è¿‡ else ä¸‹çš„è¯­å¥ï¼›å¦‚æœæ¡ä»¶ä¸æˆç«‹å°±è·³è¿‡ç´§æ¥ç€çš„è¯­å¥ï¼Œç›´æ¥æ‰§è¡Œ else ä¸‹çš„è¯­å¥ã€‚ä¸€ä¸ªé¢å¤–çš„è§„åˆ™æ˜¯ï¼šå¦‚æœ \u0026ldquo;your code\u0026rdquo; çš„åœ°æ–¹ä½ åªéœ€è¦å†™ä¸€æ¡è¯­å¥ï¼Œä½ å¯ä»¥çœç•¥å¤§æ‹¬å·å¯¹ (è¿™æ ·ä»£ç çœ‹ä¸Šå»æ›´ç´§å‡‘ç®€æ´)ï¼Œä¸è¿‡å¦‚æœä½ æ²¡æœ‰æŠŠæ¡ï¼ŒåŠ ä¸Šå¤§æ‹¬å·æ°¸è¿œæ˜¯æœ€ç¨³å¦¥æœ€æ­£ç¡®çš„é€‰æ‹©ã€‚","tags":null,"title":"åˆ†æ”¯","type":"docs"},{"authors":null,"categories":null,"content":"ä¸€ä¸ªæœ€ç®€å•çš„ C++ ç¨‹åºé•¿æˆè¿™æ ·ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; int main () { // your code return 0; } æˆ‘ä»¬å¯¹è¿™ä¸ªç¨‹åºçš„å‡ ä¸ªç»„æˆéƒ¨åˆ†åšä¸€ç‚¹è¯´æ˜ï¼š\n\u0026ldquo;include\u0026quot;ä¸€è¡Œä½¿ç¨‹åºåŒ…å«äº†ä¸€ç³»åˆ—å¤´æ–‡ä»¶ (header file), å¤´æ–‡ä»¶ä¸­å®šä¹‰äº†è®¸å¤šæœ‰ç”¨çš„å‡½æ•°ï¼Œæˆ‘ä»¬åªæœ‰ä½¿ç”¨ include åŒ…å«è¿™äº›å¤´æ–‡ä»¶æ‰èƒ½ä½¿ç”¨è¿™äº›å‡½æ•°ï¼ˆå¤´æ–‡ä»¶åœ¨å®‰è£…ç¯å¢ƒæ—¶å°±æœ‰äº†ï¼Œä½ æš‚æ—¶ä¸éœ€è¦å…³å¿ƒå®ƒä»¬åœ¨å“ªé‡Œä»¥åŠæ˜¯å¦‚ä½•å®ç°çš„ï¼Œä½ åªéœ€è¦çŸ¥é“ include è¿™è¡Œå‡ ä¹æ˜¯å¿…é¡»è¦å†™çš„ï¼‰ã€‚ int main () {} ç§°ä¸º main å‡½æ•°ã€‚æ¯ä¸ªç¨‹åºéƒ½å¿…é¡»æœ‰ main å‡½æ•°ï¼Œå½“ç¨‹åºå¼€å§‹è¿è¡Œæ—¶ï¼Œç¬¬ä¸€æ¡æ‰§è¡Œçš„æŒ‡ä»¤å°±æ˜¯ main å‡½æ•°çš„ç¬¬ä¸€æ¡æŒ‡ä»¤ã€‚ return 0; æ˜¯ä¸€æ¡è¯­å¥ï¼Œæ— è®º main å‡½æ•°ä¸­å†™äº†ä»€ä¹ˆå†…å®¹ï¼Œæœ€åä¸€æ ·éƒ½åº”å½“æ˜¯ return 0;ã€‚ C++ è¯­æ³•\nä½ çš„æ¯æ¡è¯­å¥éƒ½å¿…é¡»ä»¥ ; ç»“å°¾ã€‚ä¸€è¡Œå¯ä»¥æœ‰å¤šæ¡è¯­å¥ï¼Œä½†æ¯ä¸ªè¯­å¥åéƒ½è¦æœ‰ ;ã€‚\nä½¿ç”¨ // å¯ä»¥åœ¨ C++ ä»£ç ä¸­ä¹¦å†™æ³¨é‡Š (comment)ï¼Œæ³¨é‡Šç±»ä¼¼äºæ‰¹æ³¨ï¼Œå…¶ç›®çš„æ˜¯è®©é˜…è¯»ä»£ç çš„äººæ›´å¥½åœ°ç†è§£ä»£ç çš„æ„æ€ï¼Œæ³¨é‡Šä¸­çš„å†…å®¹ä¸ä¼šè¢«æ‰§è¡Œã€‚æ­¤å¤–ï¼Œå¦‚æœä½ æƒ³ä¹¦å†™ä¸€æ®µå¤šè¡Œçš„æ³¨é‡Šï¼Œå¯ä»¥ä½¿ç”¨å¦‚ä¸‹æ–¹æ³•ï¼š\n/* write your comments here write your comments here */ ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"cbb55943d7dee727ea6d97be41afcfbb","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/c++0/framework/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/problemsolving22/c++0/framework/","section":"courses","summary":"ä¸€ä¸ªæœ€ç®€å•çš„ C++ ç¨‹åºé•¿æˆè¿™æ ·ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; int main () { // your code return 0; } æˆ‘ä»¬å¯¹è¿™ä¸ªç¨‹åºçš„å‡ ä¸ªç»„æˆéƒ¨åˆ†åšä¸€ç‚¹è¯´æ˜ï¼š\n\u0026ldquo;include\u0026quot;ä¸€è¡Œä½¿ç¨‹åºåŒ…å«äº†ä¸€ç³»åˆ—å¤´æ–‡ä»¶ (header file), å¤´æ–‡ä»¶ä¸­å®šä¹‰äº†è®¸å¤šæœ‰ç”¨çš„å‡½æ•°ï¼Œæˆ‘ä»¬åªæœ‰ä½¿ç”¨ include åŒ…å«è¿™äº›å¤´æ–‡ä»¶æ‰èƒ½ä½¿ç”¨è¿™äº›å‡½æ•°ï¼ˆå¤´æ–‡ä»¶åœ¨å®‰è£…ç¯å¢ƒæ—¶å°±æœ‰äº†ï¼Œä½ æš‚æ—¶ä¸éœ€è¦å…³å¿ƒå®ƒä»¬åœ¨å“ªé‡Œä»¥åŠæ˜¯å¦‚ä½•å®ç°çš„ï¼Œä½ åªéœ€è¦çŸ¥é“ include è¿™è¡Œå‡ ä¹æ˜¯å¿…é¡»è¦å†™çš„ï¼‰ã€‚ int main () {} ç§°ä¸º main å‡½æ•°ã€‚æ¯ä¸ªç¨‹åºéƒ½å¿…é¡»æœ‰ main å‡½æ•°ï¼Œå½“ç¨‹åºå¼€å§‹è¿è¡Œæ—¶ï¼Œç¬¬ä¸€æ¡æ‰§è¡Œçš„æŒ‡ä»¤å°±æ˜¯ main å‡½æ•°çš„ç¬¬ä¸€æ¡æŒ‡ä»¤ã€‚ return 0; æ˜¯ä¸€æ¡è¯­å¥ï¼Œæ— è®º main å‡½æ•°ä¸­å†™äº†ä»€ä¹ˆå†…å®¹ï¼Œæœ€åä¸€æ ·éƒ½åº”å½“æ˜¯ return 0;ã€‚ C++ è¯­æ³•","tags":null,"title":"åŸºæœ¬æ¡†æ¶","type":"docs"},{"authors":null,"categories":null,"content":"ä¸Šä¸€èŠ‚çš„æ‰€æœ‰ç¤ºä¾‹ä»£ç ä¸­æˆ‘ä»¬å®šä¹‰çš„éƒ½æ˜¯ä¸€ç»´æ•°ç»„ï¼Œä¸€ç»´æ•°ç»„é¡¾åæ€ä¹‰å°±æ˜¯å°†æ‰€æœ‰çš„â€å°ç›’å­â€œæ’æˆä¸€æ’ï¼Œç”¨ä¸€ä¸ªä¸‹æ ‡å»ç´¢å¼•å®ƒä»¬ã€‚C/C++ ä¸­å¯ä»¥å®šä¹‰å„ç§ç»´åº¦çš„æ•°ç»„ï¼Œæ¯”å¦‚ä½ å¯ä»¥å®šä¹‰ä¸€ä¸ªäºŒç»´æ•°ç»„æ¥å­˜å‚¨æ–¹é˜µï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; int a[100][100]; int main () { a[0][0] = 1; // äºŒç»´æ•°ç»„çš„æ¯ä¸ªç»´åº¦éƒ½æ˜¯ä»0å¼€å§‹ç¼–å·çš„ï¼ a[2][3] = 5; std::cout \u0026lt;\u0026lt; a[0][0] \u0026lt;\u0026lt; '\\n'; //è¾“å‡ºç»“æœä¸º1 return 0; } æœ‰äº†å¤šç»´æ•°ç»„åï¼Œä½ ä¼šå‘ç°æˆ‘ä»¬æ‰‹é‡ŒåŸæœ‰çš„çº¿æ€§çš„å¾ªç¯å·¥å…·æœ‰ç‚¹ä¸å¤Ÿç”¨äº†ã€‚ä½†äº‹å®ä¸Šæˆ‘ä»¬å¯ä»¥ç”¨åµŒå¥—å¾ªç¯æ¥è½»æ¾åœ°å¯¹å¤šç»´æ•°ç»„è¿›è¡Œè®¿é—®ã€‚ä¸‹é¢çš„ç¤ºä¾‹ç¨‹åºæ¥å—ä¸€ä¸ª $n$ è¡Œ $m$ åˆ—çš„åŒ…å«æ•´æ•°çš„æ–¹é˜µä½œä¸ºè¾“å…¥ï¼Œå®ƒä¼šå°†å…¶åŸå°ä¸åŠ¨åœ°æ‰“å°å‡ºæ¥ (å‡è®¾ $n,m\\leq 100$)ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; int a[100][100]; int main () { int row, col; std::cin \u0026gt;\u0026gt; row \u0026gt;\u0026gt; col; // input for (int i = 0; i \u0026lt; row; i++) { for (int j = 0; j \u0026lt; col; j++) { std::cin \u0026gt;\u0026gt; a[i][j]; } } // output for (int i = 0; i \u0026lt; row; i++) for (int j = 0; j \u0026lt; col; j++) { char suffix_char = ((j == col - 1) ? '\\n' : ' '); std::cout \u0026lt;\u0026lt; a[i][j] \u0026lt;\u0026lt; suffix_char; } } ä»é€»è¾‘ä¸Šæ¥çœ‹åµŒå¥—å¾ªç¯ä¹Ÿæ²¡ä»€ä¹ˆâ€œäº†ä¸èµ·â€ï¼šä»¥è¾“å‡ºéƒ¨åˆ†ä¸ºä¾‹ï¼Œå¯¹äºæ¯ä¸€ä¸ª $i=0,1,\\cdots,row-1$ï¼Œå¾ªç¯å˜é‡ $j$ éƒ½ä¼šä» $0$ å¾ªç¯åˆ° $col-1$ï¼Œè¿™æ ·åœ¨å†…å±‚å¾ªç¯çš„é‡Œé¢æˆ‘ä»¬å°±å¯ä»¥æŒ‰ç…§ $(0,0)$, $(0,1)$,$\\cdots$, $(0, col-1)$, $(1, 0)$, $(1, 1)$, $\\cdots$ ,$(1, col-1)$, $(2, 0)$,$\\cdots$, $(row-1, 0)$, $\\cdots$, $(row-1, col-1)$ çš„é¡ºåºå»è®¿é—®äºŒç»´æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ã€‚\nè¿™ä¸ªä»£ç ä¸­æœ‰ä¸€äº›ç»†èŠ‚å€¼å¾—è®²è§£ï¼š\nåœ¨ä¹¦å†™åµŒå¥—å¾ªç¯æ—¶ï¼Œå†…å±‚å¾ªç¯å’Œå¤–å±‚å¾ªç¯åº”å½“ä½¿ç”¨ä¸åŒçš„å¾ªç¯å˜é‡ã€‚å¦‚æœä½ åœ¨å†…å±‚å¾ªç¯ä¸­ä½¿ç”¨äº†å’Œå¤–å±‚å¾ªç¯ä¸€æ ·çš„å˜é‡ï¼Œé‚£ä¹ˆæ‰§è¡Œå®Œå†…å±‚å¾ªç¯åå›åˆ°å¤–å±‚å¾ªç¯æ—¶ï¼Œå˜é‡çš„å€¼å°±ä¹±äº†ã€‚ä¸è¦å°ç§è¿™æ¡çœ‹ä¸Šå»æ˜¾è€Œæ˜“è§çš„ç»“è®ºï¼Œä½ ä»¬æ‰€æœ‰äººå¤§æŠµéƒ½ä¼šåœ¨è¿‡å»ã€ç°åœ¨æˆ–å°†æ¥çŠ¯ä¸€äº›ç±»ä¼¼ä¸‹é¢çš„é”™è¯¯ï¼š for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; m; i++) æˆ‘ä»¬åœ¨ç»™å‡ºä¸¤æ®µåŒé‡å¾ªç¯çš„ä»£ç æ—¶ç‰¹åœ°ä½¿ç”¨äº†ä¸åŒçš„æ‹¬å·é£æ ¼ï¼Œä½ å¯ä»¥å€Ÿæ­¤æœºä¼šå¯¹åˆ°åº•ä»€ä¹ˆæ—¶å€™éœ€è¦æ‰“å¤§æ‹¬å·æœ‰æ›´æ·±å…¥çš„ç†è§£ï¼šæˆ‘ä»¬ä¹‹å‰æåˆ°å¦‚æœå½“å‰ç»“æ„å†…éƒ¨åªæœ‰ä¸€æ¡è¯­å¥ï¼Œforå¾ªç¯/ifè¯­å¥å¯ä»¥ä¸æ‰“å¤§æ‹¬å·ï¼›ä½†æ›´å‡†ç¡®åœ°è¯´åº”è¯¥æ˜¯å¦‚æœåªæœ‰â€œä¸€å—â€ä¸€å¥ï¼Œæ¯”å¦‚ç¬¬äºŒæ®µåŒé‡å¾ªç¯çš„å¤–å±‚å¾ªç¯å†…éƒ¨åªæœ‰ä¸€ä¸ªforå¾ªç¯è¿™â€œä¸€å—â€è¯­å¥ï¼Œæ‰€ä»¥å¯ä»¥çœç•¥å¤§æ‹¬å·ã€‚è¿˜æ˜¯é‚£å¥è¯ï¼Œå¦‚æœä½ æ‹¿æä¸å‡†ï¼ŒæŠŠå¤§æ‹¬å·å†™å…¨æ°¸è¿œæ˜¯æœ€ç¨³å¦¥çš„ã€‚ ç¤ºä¾‹ä»£ç ä¸­å‡ºç°äº†ä¸€ä¸ªæ¯”è¾ƒå¥‡æ€ªçš„è¯­å¥ï¼šsuffix_char = ((j == col - 1) ? '\\n' : ' ')ã€‚? : è¢«ç§°ä¸ºä¸‰ç›®è¿ç®—ç¬¦ï¼Œæ˜¯ C/C++ æä¾›çš„ä¸€ä¸ªè¯­æ³•æœºåˆ¶ã€‚(a ? b : c) çš„æ„æ€æ˜¯å¦‚æœ a çš„å€¼ä¸ºçœŸåˆ™è¿”å› bï¼Œå¦åˆ™è¿”å› cã€‚ä¸Šé¢çš„è¿™ä¸€è¡Œä»£ç ç­‰ä»·äºä¸€ä¸ªifè¯­å¥ï¼š if (j == col - 1) suffix_char = '\\n'; else suffix_char = ' '; å¯ä»¥çœ‹åˆ°åˆç†ä½¿ç”¨ä¸‰ç›®è¿ç®—ç¬¦æœ‰åŠ©äºä½¿ä»£ç æ›´åŠ ç®€æ´ã€‚ è¿ç®—ç¬¦ä¼˜å…ˆçº§\nä½ å¯èƒ½ä¼šç–‘æƒ‘ï¼šä¸‰ç›®è¿ç®—ç¬¦çš„ä»£ç å†™æˆ\nsuffix_char = (j == col - 1 ? '\\n' : ' '); ç”šè‡³æ˜¯\nsuffix_char = j == col - 1 ? '\\n' : ' '; å¯ä¸å¯ä»¥å‘¢ï¼Ÿ åœ¨åç­‰ç­”æ¡ˆä¹‹å‰ï¼Œä½ åº”è¯¥åšçš„äº‹æƒ…æ˜¯æŠŠæ‹¬å·å»æ‰å¹¶å°è¯•è¿è¡Œç¨‹åºï¼Œè¿™æ˜¯ä½ è‡ªå·±é€šè¿‡è¯•éªŒå¯»æ±‚é—®é¢˜ç­”æ¡ˆçš„é€”å¾„ã€‚å½“ç„¶åœ¨è¿™é‡Œæˆ‘ä»¬ä¼šå‘Šè¯‰ä½ ï¼šä¸Šé¢ä¸¤æ®µä»£ç æ˜¯æ²¡æœ‰é—®é¢˜çš„ï¼Œå› ä¸º C/C++ ä¸­ä¸åŒçš„ç¬¦å·å­˜åœ¨ä¼˜å…ˆçº§å·®å¼‚ã€‚æ­£å¦‚ç®—æœ¯ä¸­ä¹˜é™¤æ³•æ¯”åŠ å‡æ³•ä¼˜å…ˆçº§é«˜ï¼ŒC/C++å†…éƒ¨ä¹Ÿæœ‰ä¸€å¥—ä¸¥æ ¼çš„ä¼˜å…ˆçº§é‡‘å­—å¡”ã€‚ä¼˜å…ˆçº§ç›¸åŒçš„è¿ç®—ç¬¦ä¼˜å…ˆè®¡ç®—å·¦ä¾§çš„ï¼›ä¼˜å…ˆçº§ä¸åŒçš„è¿ç®—ç¬¦ä¼˜å…ˆè®¡ç®—ç­‰çº§é«˜çš„ã€‚è¿™ä¸ª é“¾æ¥ è¯¦ç»†è®²è¿°äº†ä¼˜å…ˆçº§çš„åˆ’åˆ†ã€‚\nä¸‹é¢å±•ç¤ºä¸€ä¸ªæ›´ç²¾å·§çš„ä¾‹å­ï¼Œå®ƒçš„ä½œç”¨æ˜¯æ‰“å°å‡ºä¸€ä¸ªå­—ç¬¦ä¸‰è§’å½¢ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; int main () { int n; std::cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt; i; j++) std:: cout \u0026lt;\u0026lt; '*'; std::cout \u0026lt;\u0026lt; '\\n'; } return 0; } å¯ä»¥çœ‹åˆ°å¤–å±‚çš„å¾ªç¯å˜é‡æ˜¯å¯ä»¥åœ¨å†…å±‚å¾ªç¯ä½“å’Œå¾ªç¯æ¡ä»¶ä¸­ä½¿ç”¨çš„ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"3eb9f1b11d39ac785a2b5583355a19e3","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/c++0/nestedloop/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/problemsolving22/c++0/nestedloop/","section":"courses","summary":"ä¸Šä¸€èŠ‚çš„æ‰€æœ‰ç¤ºä¾‹ä»£ç ä¸­æˆ‘ä»¬å®šä¹‰çš„éƒ½æ˜¯ä¸€ç»´æ•°ç»„ï¼Œä¸€ç»´æ•°ç»„é¡¾åæ€ä¹‰å°±æ˜¯å°†æ‰€æœ‰çš„â€å°ç›’å­â€œæ’æˆä¸€æ’ï¼Œç”¨ä¸€ä¸ªä¸‹æ ‡å»ç´¢å¼•å®ƒä»¬ã€‚C/C++ ä¸­å¯ä»¥å®šä¹‰å„ç§ç»´åº¦çš„æ•°ç»„ï¼Œæ¯”å¦‚ä½ å¯ä»¥å®šä¹‰ä¸€ä¸ªäºŒç»´æ•°ç»„æ¥å­˜å‚¨æ–¹é˜µï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; int a[100][100]; int main () { a[0][0] = 1; // äºŒç»´æ•°ç»„çš„æ¯ä¸ªç»´åº¦éƒ½æ˜¯ä»0å¼€å§‹ç¼–å·çš„ï¼ a[2][3] = 5; std::cout \u0026lt;\u0026lt; a[0][0] \u0026lt;\u0026lt; '\\n'; //è¾“å‡ºç»“æœä¸º1 return 0; } æœ‰äº†å¤šç»´æ•°ç»„åï¼Œä½ ä¼šå‘ç°æˆ‘ä»¬æ‰‹é‡ŒåŸæœ‰çš„çº¿æ€§çš„å¾ªç¯å·¥å…·æœ‰ç‚¹ä¸å¤Ÿç”¨äº†ã€‚ä½†äº‹å®ä¸Šæˆ‘ä»¬å¯ä»¥ç”¨åµŒå¥—å¾ªç¯æ¥è½»æ¾åœ°å¯¹å¤šç»´æ•°ç»„è¿›è¡Œè®¿é—®ã€‚ä¸‹é¢çš„ç¤ºä¾‹ç¨‹åºæ¥å—ä¸€ä¸ª $n$ è¡Œ $m$ åˆ—çš„åŒ…å«æ•´æ•°çš„æ–¹é˜µä½œä¸ºè¾“å…¥ï¼Œå®ƒä¼šå°†å…¶åŸå°ä¸åŠ¨åœ°æ‰“å°å‡ºæ¥ (å‡è®¾ $n,m\\leq 100$)ï¼š","tags":null,"title":"åµŒå¥—å¾ªç¯","type":"docs"},{"authors":null,"categories":null,"content":"å‡è®¾æˆ‘ä»¬ç°åœ¨è¦è®¡ç®— $1+2+3+4+5$ï¼Œç›¸ä¿¡ä½ å·²ç»æœ‰èƒ½åŠ›å†™å‡ºä¸€æ®µä»£ç å®Œæˆè¿™ä¸ªä»»åŠ¡ï¼š\nint sum; sum = 1; sum = sum + 2; // ä½ ä¹Ÿå¯ä»¥å†™ sum += 2; å®ƒä»¬çš„åŠŸèƒ½æ˜¯ä¸€æ ·çš„ sum = sum + 3; sum = sum + 4; sum = sum + 5; ä½†æ˜¯è¿™æ ·çš„ä»£ç çœ‹èµ·æ¥æœªå…æœ‰äº›ç¬¨æ‹™ï¼Œå¦‚æœæˆ‘ä»¬è¦è®¡ç®— $1+2+\\cdots+100$ï¼Œå²‚ä¸æ˜¯è¦å†™ 100 è¡Œï¼Ÿå½“é‡åˆ°è¿™ç§éœ€è¦å¤§é‡é‡å¤åšç›¸åŒ/ç›¸ä¼¼æ“ä½œçš„æƒ…å†µæ—¶ï¼Œå¾ªç¯ä¾¿èƒ½æ´¾ä¸Šç”¨åœºã€‚while å¾ªç¯çš„åŸºæœ¬æ¶æ„ä¸ºï¼š\nwhile (condition) { // your code here } åœ¨è¿›å…¥å¾ªç¯ä½“ä¹‹å‰ï¼Œç¨‹åºä¼šå…ˆæ£€æŸ¥æ‹¬å·ä¸­çš„æ¡ä»¶æ˜¯å¦æˆç«‹ï¼Œå¦‚æœæˆç«‹å°±æ‰§è¡Œå¤§æ‹¬å·ä¸­çš„å†…å®¹ï¼Œæ‰§è¡Œå®Œå†…å®¹åç¨‹åºä¼šå†æ¬¡åˆ¤æ–­æ‹¬å·ä¸­çš„æ¡ä»¶æ˜¯å¦æˆç«‹â€¦â€¦ç›´åˆ°æŸæ¬¡æ‰§è¡Œå®Œå¾ªç¯ä½“åæ¡ä»¶ä¸æˆç«‹äº†ï¼Œwhile å¾ªç¯æ‰ä¼šé€€å‡ºï¼Œä¸‹é¢çš„æµç¨‹å›¾å¾ˆå¥½åœ°è¯ é‡Šäº† while å¾ªç¯çš„æ‰§è¡Œè¿‡ç¨‹ï¼š\ngraph TD s0[start] s1{while yes?} s2(body) s3(break) s0 --\u0026gt; s1 s1 --\u0026gt; |yes| s2 s2 --\u0026gt; s1 s1 --\u0026gt; |no| s3 æœ‰äº† while å¾ªç¯åï¼Œæˆ‘ä»¬å¯ä»¥å®¹æ˜“åœ°è§£å†³ä¸‹é¢çš„è¿™ä¸ªé—®é¢˜ï¼šè¾“å…¥ä¸€ä¸ªæ•´æ•° $n$ï¼Œè¾“å‡º $1+2+\\cdots+n$ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; int main () { int n, sum; std::cin \u0026gt;\u0026gt; n; sum = 0; while (n != 0) { sum += n; n--; // \u0026quot;n--\u0026quot; is equal to \u0026quot;n = n - 1\u0026quot; } std::cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; '\\n'; return 0; } ä¸Šè¿° while å¾ªç¯å°†åˆ¤æ–­æ¡ä»¶æ”¾åœ¨å¼€å¤´ï¼Œå¦æœ‰ä¸€ç§ do-while å¾ªç¯æ¡†æ¶å°†åˆ¤æ–­æ¡ä»¶æ”¾åœ¨æœ«å°¾ï¼š\ndo { // your code } while (condition); // è¿™é‡Œè¦åŠ åˆ†å·ï¼ do-while å¾ªç¯ä¸€å®šä¼šå…ˆæ‰§è¡Œå¾ªç¯ä½“å†æ£€æŸ¥æ¡ä»¶ï¼Œå…¶ä»–çš„éƒ¨åˆ†å’Œ while å¾ªç¯æ²¡æœ‰åŒºåˆ«ã€‚\né™¤äº† while å¾ªç¯ï¼Œfor å¾ªç¯ä¹Ÿæ˜¯ä¸€ç§å¸¸ç”¨çš„å¾ªç¯æ¡†æ¶ï¼Œä¸è¿‡ for å¾ªç¯çš„æ ¼å¼ç›¸å¯¹å¤æ‚ï¼š\nfor (/* statement 1 */; /* statement 2 */; /* statement 3 */) { // your code } C++ è¯­è¨€çš„ for å¾ªç¯ä¸­æœ‰ 3 æ¡è¯­å¥ï¼Œå…¶æ‰§è¡Œé¡ºåºéå¸¸å¾®å¦™ (è¿™æ˜¯ C/C++ ç»å¸¸è¢«åæ§½çš„ä¸€ä¸ªç‚¹)ã€‚ç”¨æµç¨‹å›¾å¯ä»¥æ¯”è¾ƒæ¸…æ¥šåœ°è§£é‡Šæ‰§è¡Œçš„é¡ºåºï¼š\ngraph LR s0[start] s1(statement 1) s2{statement 2 yes?} s3(body) s4(statement 3) s5(break) s0 --\u0026gt; s1 s1 --\u0026gt; s2 s2 --\u0026gt; |yes| s3 s3 --\u0026gt; s4 s4 --\u0026gt; s2 s2 --\u0026gt; |no| s5 å¦‚æœä½ è§‰å¾—è¿™ä¸ªæµç¨‹æ¯”è¾ƒå¤æ‚ï¼Œä¹Ÿå¯ä»¥æš‚æ—¶ä¸é‚£ä¹ˆä»”ç»†åœ°ç†è§£å®ƒï¼Œæ¯•ç«Ÿ while å¾ªç¯å¯ä»¥åšåˆ° for å¾ªç¯èƒ½åšåˆ°çš„æ‰€æœ‰äº‹æƒ…ã€‚ä¸è¿‡ä½ å¯ä»¥è®°ä½çš„æ˜¯ï¼š\nint i; for (i = 1; i \u0026lt;= n; i++) {} è¿™æ ·ä¸€ä¸ª for å¾ªç¯å¯ä»¥è®©å˜é‡ i åˆ†åˆ«å– $1, 2, \\cdots, n$ï¼Œç„¶åé€€å‡ºå¾ªç¯ã€‚å¦‚æœä½ æŠŠä¸‰æ¡è¯­å¥ä»£å…¥åˆšæ‰çš„æµç¨‹å›¾ï¼Œä½ ä¼šå‘ç°å®ƒç¡®å®æ˜¯æ­£ç¡®çš„ã€‚è¿™æ ·ä¸€ä¸ªä» $1$ æšä¸¾åˆ° $n$ çš„å†™æ³•æ¯” while å¾ªç¯çœ‹ä¸Šå»ç®€æ´ä¸€äº›ã€‚\næˆ‘ä»¬ç»™å‡ºä¸¤ä¸ªä½¿ç”¨ for å¾ªç¯å®ç°è®¡ç®— $1+2+\\cdots n$ çš„ç¤ºä¾‹ä»£ç ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; int main () { int n, sum; std::cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) // å¦‚æœä½ æƒ³åœ¨å¾ªç¯ä½“å†…éƒ¨ä¸´æ—¶ä½¿ç”¨ä¸€ä¸ªå˜é‡ï¼Œä½ å¯ä»¥é€‰æ‹©åƒè¿™æ ·çš„å®šä¹‰æ–¹å¼ sum += i; // åˆ«å¿˜äº†å•æ¡è¯­å¥å¯ä»¥ä¸ç”¨{}åŒ…è£¹èµ·æ¥ std::cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; '\\n'; return 0; } å¦‚ä½ æ‰€è§ï¼Œä½ å¯ä»¥åœ¨ for å¾ªç¯ä¸­ä¸´æ—¶å®šä¹‰å˜é‡ iï¼Œè¿™ä¸ªå˜é‡ i åªå¯ä»¥åœ¨å¾ªç¯ä½“ä¸­ä½¿ç”¨ï¼Œåœ¨å¾ªç¯ä½“ä»¥å¤–ä½ ä¸èƒ½ä½¿ç”¨ iã€‚\nè¿™ä¸ª for å¾ªç¯çš„å†™æ³•æ˜¯ä¹‹å‰ä»‹ç»çš„æ¯”è¾ƒè§„æ•´çš„å†™æ³•ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªé•¿ç›¸æ¯”è¾ƒç‰¹åˆ«çš„ for å¾ªç¯ï¼š\nint main () { int n, sum; std::cin \u0026gt;\u0026gt; n; for ( ;n != 0; n--) sum = sum + n; std::cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; '\\n'; return 0; } å¦‚æœä½ ä»£å…¥ä¹‹å‰çš„æµç¨‹å›¾ç†è§£ for å¾ªç¯æ‰§è¡Œçš„è¿‡ç¨‹ï¼Œä½ ä¼šå‘ç°è¿™ä¸ªå†™æ³•æ¯”è¾ƒåƒ while å¾ªç¯çš„é€»è¾‘ã€‚äº‹å®ä¸Šï¼Œä¹‹æ‰€ä»¥è¯´ for å¾ªç¯å®Œå…¨å¯ä»¥ç”¨ while å¾ªç¯ä»£æ›¿ï¼Œæ˜¯å› ä¸º\nfor (s1; s2; s3) { // your code } ç­‰ä»·äº\ns1; while (s2) { // your code s3; } ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"1fa517a55138ecfac147e3557f1935e8","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/c++0/loop/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/problemsolving22/c++0/loop/","section":"courses","summary":"å‡è®¾æˆ‘ä»¬ç°åœ¨è¦è®¡ç®— $1+2+3+4+5$ï¼Œç›¸ä¿¡ä½ å·²ç»æœ‰èƒ½åŠ›å†™å‡ºä¸€æ®µä»£ç å®Œæˆè¿™ä¸ªä»»åŠ¡ï¼š\nint sum; sum = 1; sum = sum + 2; // ä½ ä¹Ÿå¯ä»¥å†™ sum += 2; å®ƒä»¬çš„åŠŸèƒ½æ˜¯ä¸€æ ·çš„ sum = sum + 3; sum = sum + 4; sum = sum + 5; ä½†æ˜¯è¿™æ ·çš„ä»£ç çœ‹èµ·æ¥æœªå…æœ‰äº›ç¬¨æ‹™ï¼Œå¦‚æœæˆ‘ä»¬è¦è®¡ç®— $1+2+\\cdots+100$ï¼Œå²‚ä¸æ˜¯è¦å†™ 100 è¡Œï¼Ÿå½“é‡åˆ°è¿™ç§éœ€è¦å¤§é‡é‡å¤åšç›¸åŒ/ç›¸ä¼¼æ“ä½œçš„æƒ…å†µæ—¶ï¼Œå¾ªç¯ä¾¿èƒ½æ´¾ä¸Šç”¨åœºã€‚while å¾ªç¯çš„åŸºæœ¬æ¶æ„ä¸ºï¼š","tags":null,"title":"å¾ªç¯","type":"docs"},{"authors":null,"categories":null,"content":" ä¸ºäº†è§£é‡Šæ¸…æ¥šä¸€äº›ç°è±¡èƒŒåçš„åŸå› ï¼Œæœ¬æ–‡æ¶‰åŠä¸€äº›è¶…çº²çš„è®¡ç®—æœºåº•å±‚çŸ¥è¯†ã€‚è¿™éƒ¨åˆ†å†…å®¹éƒ½åœ¨ç»¿è‰²çš„æ¡†å†…ï¼Œå¦‚æœä½ æ— æ³•çœ‹æ‡‚å¯ä»¥ç›´æ¥è·³è¿‡ã€‚ç­‰åˆ°å¤§å®¶å­¦å®Œäº†è®¡ç®—æœºç³»ç»ŸåŸºç¡€ (ICS) åè‡ªç„¶å°±èƒ½ç†è§£è¿™äº›è¯çš„å«ä¹‰ã€‚ æœ‰äº†å¾ªç¯ä¹‹åï¼Œä½ å¾ˆå¿«å°±ä¼šå‘ç°ç®€å•åœ°å®šä¹‰ä¸€ä¸ªä¸€ä¸ªçš„å˜é‡æœ‰ç‚¹â€œä¸å¤Ÿç”¨â€äº†ï¼Œæ¯”å¦‚è€ƒè™‘å¦‚ä¸‹é—®é¢˜ï¼š\nè¾“å…¥æ•´æ•° $N$ï¼Œç„¶åè¾“å…¥ $N$ ä¸ªæ•°çš„ä¸€ä¸ªæ•°åˆ—ï¼Œå°†è¿™ä¸ªæ•°åˆ—å€’åºè¾“å‡ºã€‚\næˆ‘ä»¬æƒ³è¦å€’åºè¾“å‡ºï¼Œå°±è¯´æ˜æˆ‘ä»¬åœ¨è¯»å–å®Œæ•°åˆ—çš„æœ€åä¸€ä¸ªæ•´æ•°æ—¶ï¼Œè¿˜è¦â€œè®°ä½â€å‰é¢çš„ $N-1$ ä¸ªæ•´æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬æ¯è¯»å–åˆ°ä¸€ä¸ªæ•´æ•°éƒ½å¾—å°†å…¶ä¿å­˜åœ¨å˜é‡é‡Œï¼Œä½†æˆ‘ä»¬åœ¨é¢„å…ˆä¸çŸ¥é“æ•°åˆ—é•¿åº¦çš„æƒ…å†µä¸‹æ€ä¹ˆçŸ¥é“è¯¥å®šä¹‰å¤šå°‘ä¸ªå˜é‡å‘¢ï¼Ÿè¿™ä¼¼ä¹é™·å…¥äº†æ­»å±€ã€‚\n(åœ¨è¿™é‡Œæˆ‘ä»¬ä¸è€ƒè™‘é€’å½’ç­‰æŠ€å·§) æˆ‘ä»¬å¸Œæœ›æœ‰ä¸€ç§è¯­æ³•ï¼Œå¯ä»¥æ‰¹é‡å¼€ä¸€å †å˜é‡ï¼Œè€Œä¸”æœ€å¥½èƒ½ç”¨ä¸‹æ ‡å»ç´¢å¼•å®ƒä»¬ã€‚åœ¨ C/C++ ä¸­æˆ‘ä»¬å¯ä»¥é€šè¿‡å®šä¹‰æ•°ç»„æ¥å®ç°è¿™ä¸€ç‚¹ã€‚æˆ‘ä»¬å…ˆç»™å‡ºä¸Šé¢é—®é¢˜çš„ä¸€æ®µç¤ºä¾‹ä»£ç ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; int main () { int n; std::cin \u0026gt;\u0026gt; n; int a[n]; for (int i = 0; i \u0026lt; n; i++) std::cin \u0026gt;\u0026gt; a[i]; for (int i = n - 1; i \u0026gt;= 0; i--) std::cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; '\\n'; return 0; } è¿™é‡Œå‡ºç°çš„æ–°è¯­æ³•æ˜¯ int a[n]ã€‚å¦‚æœè¯´ int ç±»å‹çš„å˜é‡æ˜¯ä¸€ä¸ªå¯ä»¥å­˜æ”¾ä¸€ä¸ªæ•´æ•°çš„å°ç›’å­ï¼Œé‚£ä¹ˆ int a[n] å°±å®šä¹‰äº† $n$ ä¸ªå°ç›’å­ï¼Œæ¯ä¸ªå°ç›’å­éƒ½å¯ä»¥å­˜æ”¾ä¸€ä¸ªæ•´æ•°ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œçš„â€œå°ç›’å­â€æ˜¯æŒ‰ç…§ $0,1,\\cdots, n-1$ ç¼–å·çš„ã€‚\nVariable-Length Array (VLA)\nåœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å®šä¹‰çš„æ•°ç»„çš„é•¿åº¦ä¾èµ–äºæˆ‘ä»¬è¾“å…¥çš„å˜é‡ $n$ çš„å€¼ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨ç¨‹åºå¼€å§‹è¿è¡Œä¹‹å‰ï¼Œæˆ‘ä»¬æ— æ³•çŸ¥é“æ•°ç»„çš„å…·ä½“é•¿åº¦ã€‚è¿™ç§ä»¥å˜é‡ä½œä¸ºé•¿åº¦çš„æ•°ç»„ç§°ä¸º variable-length array (VLA)ã€‚\nVLA çš„å¾®å¦™ä¹‹å¤„åœ¨äºï¼Œç¼–è¯‘å™¨åœ¨ä¸çŸ¥é“æ•°ç»„å…·ä½“é•¿åº¦çš„æƒ…å†µä¸‹å¯èƒ½ä¼šåœ¨å†…å­˜åˆ†é…ä¸ŠçŠ¯éš¾ã€‚C99 æ ‡å‡†é¦–æ¬¡å…è®¸ VLA çš„ä½¿ç”¨ï¼Œä½†å¯¹å…¶ä½œå‡ºäº†è¯¸å¤šé™åˆ¶ï¼Œæ¯”å¦‚ä¸èƒ½ä½¿ç”¨ $\\mathbf{extern}$, $\\mathbf{static}$ ç­‰å…³é”®å­—ä¿®é¥°ã€‚ä¸åŒçš„ç¼–è¯‘å™¨æ”¯æŒçš„æ ‡å‡†ä¹Ÿç•¥æœ‰å·®å¼‚ï¼Œä¾‹å¦‚ Visual Studio ä½¿ç”¨çš„ msvc ç¼–è¯‘å™¨å¾ˆå¯èƒ½ä¼šå¯¹ä¸Šé¢çš„ç¤ºä¾‹ä»£ç æŠ¥é”™ã€‚\nå¦‚æœä½ å¯¹è¿™äº›å†…å®¹æ„Ÿå…´è¶£ï¼Œå¯ä»¥ä¸Šç½‘æŸ¥è¯¢æ›´å¤šçš„èµ„æ–™ã€‚\nå¦‚æœä¸Šé¢å…³äº VLA çš„å†…å®¹ä½ æ²¡æœ‰çœ‹æ‡‚ï¼Œæ²¡æœ‰å…³ç³»ï¼Œä¸€å¥è¯æ¦‚æ‹¬å°±æ˜¯ä½¿ç”¨å˜é‡ä½œä¸ºæ•°ç»„çš„é•¿åº¦â€œä¸å¤ªå¥½â€ã€‚æˆ‘ä»¬çš„ OJ é¢˜ä¼šå¯¹è¾“å…¥æ•°æ®çš„èŒƒå›´ä½œå‡ºä¸¥æ ¼çš„é™åˆ¶ï¼Œä½ å¯ä»¥æ ¹æ®æ•°æ®èŒƒå›´å°†æ•°ç»„å¼€åˆ°è¶³å¤Ÿå¤§çš„ä¸€ä¸ªå›ºå®šé•¿åº¦ã€‚å‡è®¾é¢˜ç›®è§„å®šäº† $N\\leq 1000$ï¼Œé‚£ä¹ˆä¸€ä¸ªä¸ä½¿ç”¨ VLA çš„ç¨‹åºåº”è¯¥è¿™æ ·å†™ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; int a[1000]; int main () { int n; std::cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) std::cin \u0026gt;\u0026gt; a[i]; for (int i = n - 1; i \u0026gt;= 0; i--) std::cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; '\\n'; return 0; } è¿™é‡Œæˆ‘ä»¬å¸Œæœ›ä¸åŠ è§£é‡Šåœ°åšå‡ºä¸€ä¸ªè§„å®šï¼šå¦‚æœä½ è¦å®šä¹‰ä¸€ä¸ªå®šé•¿çš„æ•°ç»„ï¼Œè¯·å°†å®ƒå®šä¹‰åœ¨ main() å‡½æ•°çš„å¤–é¢ã€‚\nä¸è¡Œï¼Œæˆ‘å°±æ˜¯æƒ³çŸ¥é“ä¸ºä»€ä¹ˆè¦è¿™ä¹ˆè§„å®š\nC/C++ çš„ç¼–è¯‘å™¨éœ€è¦è´Ÿè´£å°†é«˜çº§è¯­è¨€ç¨‹åºæ˜ å°„åˆ°å…·ä½“çš„ç¡¬ä»¶ä¸Šã€‚å¯¹äºæ•°ç»„è¿™æ ·çš„å­˜å‚¨è®¾æ–½ï¼Œç¼–è¯‘å™¨ä¼šå°†å…¶æ˜ å°„åˆ°å†…å­˜ä¸­çš„æŸå—åŒºåŸŸã€‚å¦‚æœä½ å°†æ•°ç»„å®šä¹‰åœ¨å‡½æ•°å†…éƒ¨ï¼Œç¼–è¯‘å™¨ä¼šå°†å…¶å®‰æ’åœ¨æ ˆä¸Šï¼›å¦‚æœä½ å°†æ•°ç»„å®šä¹‰åœ¨å…¨å±€ (å‡½æ•°å¤–éƒ¨)ï¼Œç¼–è¯‘å™¨ä¼šå°†å…¶å®‰æ’åœ¨é™æ€æ•°æ®åŒºã€‚é™¤éç‰¹åˆ«é…ç½®ï¼Œä¸€ä¸ªç¨‹åºçš„æ ˆç©ºé—´é€šå¸¸ä¸æ˜¯å¾ˆå¤§ï¼Œå¦‚æœåœ¨å‡½æ•°å†…éƒ¨å®šä¹‰äº†è¿‡é•¿çš„æ•°ç»„å¯èƒ½ä¼šå¯¼è‡´æ ˆæº¢å‡ºï¼Œæ ˆæº¢å‡ºä¼šå¯¼è‡´ä¸å¯é¢„çŸ¥çš„ä¸¥é‡åæœã€‚\nå¦‚æœä½ æƒ³äº²æ‰‹ä½“éªŒä¸€ä¸‹â€œæ ˆæº¢å‡ºâ€ï¼Œä½ å¯ä»¥å°è¯•è¿è¡Œä»¥ä¸‹ä»£ç  (ä¸è¦åŠ ä»»ä½•ç¼–è¯‘ä¼˜åŒ–)ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; int main () { char s[1 \u0026lt;\u0026lt; 25]; } ç›´æ¥è¿è¡Œè¿™æ®µä»£ç å¯èƒ½ä¼šè·å¾—æ®µé”™è¯¯ (Segmentation Fault)ã€‚\nå¦‚æœä½ æ²¡æœ‰çœ‹æ‡‚è¿™æ®µè¯ï¼Œé‚£å°±è€è€å®å®åœ°éµå®ˆæˆ‘ä»¬çš„è§„å®šå§ã€‚\næ€»æœ‰ä¸€äº›â€œå®Œç¾ä¸»ä¹‰è€…â€è§‰å¾—è¿™æ ·å†™ä»£ç ååˆ†ä»¤äººä¸çˆ½â€”â€”å¦‚æœ $N$ è¿œå°äº 1000ï¼Œæˆ‘ä»¬çš„ä»£ç å²‚ä¸æ˜¯æ— è°“çš„å¤šä½¿ç”¨äº†å¾ˆå¤šèµ„æºï¼Ÿè¿™é‡Œæˆ‘ä»¬å†ä»‹ç»ä¸€ç§å®šä¹‰æ•°ç»„çš„æ–¹å¼ï¼Œå®ƒåœ¨åŠŸèƒ½ä¸Šå’Œå‰é¢çš„å‡ ç§æ˜¯å®Œå…¨ç›¸åŒçš„ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; int main () { int n; std::cin \u0026gt;\u0026gt; n; int *a = new int [n]; for (int i = 0; i \u0026lt; n; i++) std::cin \u0026gt;\u0026gt; a[i]; for (int i = n - 1; i \u0026gt;= 0; i--) std::cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; '\\n'; delete [] a; return 0; } int *a = new int [n] çš„åŠŸèƒ½æ˜¯å®šä¹‰ä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„æ•°ç»„ï¼Œæ¯ä¸ªæ•°ç»„å…ƒç´ éƒ½æ˜¯ int ç±»å‹ï¼Œè¿™ä¸ªæ•°ç»„çš„åå­—å«åš aã€‚æˆ‘ä»¬åœ¨è¿™é‡Œå¸Œæœ›å¼ºè°ƒä¸€ç‚¹ï¼šå¦‚æœä½ ä½¿ç”¨äº†newè¯­æ³•å®šä¹‰æ•°ç»„ï¼Œè¯·ä¸€å®šåœ¨ä½ ç¡®å®šä¸ä¼šå†ä½¿ç”¨è¯¥æ•°ç»„çš„æ—¶åˆ» (ä¾‹å¦‚ return 0 ä¹‹å‰) ä½¿ç”¨deleteé‡Šæ”¾å®ƒã€‚\næˆ‘ä¸å†™deleteè¿™ä¸€è¡Œå¥½åƒä¹Ÿæ²¡æŠ¥é”™å•Šï¼Ÿ\nå¦‚æœä½ æ˜¯ä¸€ä¸ªæ›¾ç»å­¦è¿‡ç®—æ³•ç«èµ›çš„åŒå­¦ï¼Œä½ å¾ˆå¯èƒ½å·²ç»å…»æˆäº†â€œéšæ‰‹newï¼Œä»ä¸deleteâ€çš„ä¹ æƒ¯ã€‚æˆ‘ä»¬åœ¨è¿™é‡Œå¿…é¡»ä¸¥è‚ƒåœ°è­¦å‘Šï¼šè¿™æ˜¯ä¸€ä¸ªéå¸¸å±é™©çš„ä¹ æƒ¯ï¼ä½ ä¹‹å‰å†™è¿‡çš„å¿˜è®° delete çš„ OJ ç¨‹åºä¹‹æ‰€ä»¥å¯ä»¥æ­£å¸¸é€€å‡ºï¼Œæ˜¯å› ä¸ºå½“ OJ ç¨‹åºæ‰€åœ¨çš„è¿›ç¨‹è¢«é”€æ¯æ—¶ï¼Œæ“ä½œç³»ç»Ÿä¼šå°†è¿›ç¨‹ç”³è¯·çš„èµ„æºè‡ªåŠ¨é‡Šæ”¾â€”â€”æ¢è¨€ä¹‹ï¼Œæ“ä½œç³»ç»Ÿå¸®ä½ é»˜é»˜åœ°åšäº† deleteã€‚æ²¡æœ‰åŠæ—¶é‡Šæ”¾ç”³è¯·çš„å†…å­˜ä¼šå¯¼è‡´å†…å­˜æ³„æ¼ (memory leak)ï¼Œå¦‚æœå°†æ¥ä½ ç»´æŠ¤ä¸€ä¸ªå¤§å‹çš„é¡¹ç›®ï¼Œå†…å­˜æ³„æ¼çš„ç´¯ç§¯å¾ˆå¯èƒ½å¯¼è‡´ç¨‹åºå´©æºƒã€‚\nå¦‚æœä½ æ˜¯ä¸€ä¸ªè®¡ç®—æœºå°ç™½ï¼Œæ­å–œä½ æ‹¥æœ‰äº†ä¸€ä¸ªå°å°çš„ä¼˜åŠ¿ï¼šä½ æ²¡æœ‰ç»å†è¿‡ç®—æ³•ç«èµ›ä¸­å„ç§ç³Ÿç³•çš„ä»£ç ä¹¦å†™ä¹ æƒ¯çš„ç†é™¶ã€‚ä»åˆå­¦é˜¶æ®µå¼€å§‹ä¸¥æ ¼éµå®ˆå„ç§è§„èŒƒï¼Œä½ å°†è‡ªç„¶è€Œç„¶åœ°å°†ä¹¦å†™å®‰å…¨ã€é«˜è´¨é‡ã€å¯è¯»æ€§å¼ºçš„ä»£ç ä½œä¸ºä¸€ç§æœ¬èƒ½ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"af58f0ca73f9f8e7cb1edc0d2c5c72b3","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/c++0/array/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/problemsolving22/c++0/array/","section":"courses","summary":"ä¸ºäº†è§£é‡Šæ¸…æ¥šä¸€äº›ç°è±¡èƒŒåçš„åŸå› ï¼Œæœ¬æ–‡æ¶‰åŠä¸€äº›è¶…çº²çš„è®¡ç®—æœºåº•å±‚çŸ¥è¯†ã€‚è¿™éƒ¨åˆ†å†…å®¹éƒ½åœ¨ç»¿è‰²çš„æ¡†å†…ï¼Œå¦‚æœä½ æ— æ³•çœ‹æ‡‚å¯ä»¥ç›´æ¥è·³è¿‡ã€‚ç­‰åˆ°å¤§å®¶å­¦å®Œäº†è®¡ç®—æœºç³»ç»ŸåŸºç¡€ (ICS) åè‡ªç„¶å°±èƒ½ç†è§£è¿™äº›è¯çš„å«ä¹‰ã€‚ æœ‰äº†å¾ªç¯ä¹‹åï¼Œä½ å¾ˆå¿«å°±ä¼šå‘ç°ç®€å•åœ°å®šä¹‰ä¸€ä¸ªä¸€ä¸ªçš„å˜é‡æœ‰ç‚¹â€œä¸å¤Ÿç”¨â€äº†ï¼Œæ¯”å¦‚è€ƒè™‘å¦‚ä¸‹é—®é¢˜ï¼š\nè¾“å…¥æ•´æ•° $N$ï¼Œç„¶åè¾“å…¥ $N$ ä¸ªæ•°çš„ä¸€ä¸ªæ•°åˆ—ï¼Œå°†è¿™ä¸ªæ•°åˆ—å€’åºè¾“å‡ºã€‚\næˆ‘ä»¬æƒ³è¦å€’åºè¾“å‡ºï¼Œå°±è¯´æ˜æˆ‘ä»¬åœ¨è¯»å–å®Œæ•°åˆ—çš„æœ€åä¸€ä¸ªæ•´æ•°æ—¶ï¼Œè¿˜è¦â€œè®°ä½â€å‰é¢çš„ $N-1$ ä¸ªæ•´æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬æ¯è¯»å–åˆ°ä¸€ä¸ªæ•´æ•°éƒ½å¾—å°†å…¶ä¿å­˜åœ¨å˜é‡é‡Œï¼Œä½†æˆ‘ä»¬åœ¨é¢„å…ˆä¸çŸ¥é“æ•°åˆ—é•¿åº¦çš„æƒ…å†µä¸‹æ€ä¹ˆçŸ¥é“è¯¥å®šä¹‰å¤šå°‘ä¸ªå˜é‡å‘¢ï¼Ÿè¿™ä¼¼ä¹é™·å…¥äº†æ­»å±€ã€‚\n(åœ¨è¿™é‡Œæˆ‘ä»¬ä¸è€ƒè™‘é€’å½’ç­‰æŠ€å·§) æˆ‘ä»¬å¸Œæœ›æœ‰ä¸€ç§è¯­æ³•ï¼Œå¯ä»¥æ‰¹é‡å¼€ä¸€å †å˜é‡ï¼Œè€Œä¸”æœ€å¥½èƒ½ç”¨ä¸‹æ ‡å»ç´¢å¼•å®ƒä»¬ã€‚åœ¨ C/C++ ä¸­æˆ‘ä»¬å¯ä»¥é€šè¿‡å®šä¹‰æ•°ç»„æ¥å®ç°è¿™ä¸€ç‚¹ã€‚æˆ‘ä»¬å…ˆç»™å‡ºä¸Šé¢é—®é¢˜çš„ä¸€æ®µç¤ºä¾‹ä»£ç ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; int main () { int n; std::cin \u0026gt;\u0026gt; n; int a[n]; for (int i = 0; i \u0026lt; n; i++) std::cin \u0026gt;\u0026gt; a[i]; for (int i = n - 1; i \u0026gt;= 0; i--) std::cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; '\\n'; return 0; } è¿™é‡Œå‡ºç°çš„æ–°è¯­æ³•æ˜¯ int a[n]ã€‚å¦‚æœè¯´ int ç±»å‹çš„å˜é‡æ˜¯ä¸€ä¸ªå¯ä»¥å­˜æ”¾ä¸€ä¸ªæ•´æ•°çš„å°ç›’å­ï¼Œé‚£ä¹ˆ int a[n] å°±å®šä¹‰äº† $n$ ä¸ªå°ç›’å­ï¼Œæ¯ä¸ªå°ç›’å­éƒ½å¯ä»¥å­˜æ”¾ä¸€ä¸ªæ•´æ•°ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œçš„â€œå°ç›’å­â€æ˜¯æŒ‰ç…§ $0,1,\\cdots, n-1$ ç¼–å·çš„ã€‚","tags":null,"title":"æ•°ç»„","type":"docs"},{"authors":null,"categories":null,"content":"å¦‚æœä½ ä½¿ç”¨çš„æ˜¯ Dev-cppï¼Œå°†åŸºæœ¬æ¡†æ¶ä¸­çš„ç¨‹åºæ‹·è´åˆ°ä»£ç åŒºå¹¶æŒ‰ä¸‹ F11ï¼Œä½ ä¼šå‘ç°ç¨‹åºå·²ç»å¯ä»¥æˆåŠŸåœ°è¿è¡Œäº†ï¼ä¸è¿‡è·³å‡ºçš„é»‘è‰²çª—å£ä¸­æ²¡æœ‰ä»»ä½•å†…å®¹â€”â€”å› ä¸ºæˆ‘ä»¬çš„ main å‡½æ•°ä¸­ä»€ä¹ˆéƒ½æ²¡å†™ã€‚æˆ‘ä»¬ç°åœ¨æ¥å°è¯•è¾“å‡ºä¸€è¡Œ \u0026ldquo;hello world!\u0026quot;ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; int main () { std::cout \u0026lt;\u0026lt; \u0026quot;Hello World\u0026quot; \u0026lt;\u0026lt; '\\n'; // don't forget to add ';' at the end! return 0; } cout æ˜¯ä¸€ä¸ªå¯¹è±¡ (object)ï¼Œä½œä¸ºåˆå­¦è€…æˆ‘ä»¬ä¸éœ€è¦çŸ¥é“å¯¹è±¡æ˜¯ä»€ä¹ˆæ„æ€ï¼Œä¸€ä¸ªå¥½çš„ç†è§£æ–¹å¼æ˜¯ï¼šä½ å¯ä»¥æŠŠ \u0026ldquo;cout\u0026rdquo; æƒ³è±¡æˆè¿è¡Œæ—¶è¹¦å‡ºçš„çª—å£ï¼Œç°åœ¨æˆ‘ä»¬çš„ä»»åŠ¡æ˜¯å°†è¦è¾“å‡ºçš„å†…å®¹å–‚ç»™çª—å£ï¼Œè¿™é‡Œçš„ \u0026lt;\u0026lt; å°±åƒç®­å¤´ä¸€æ ·æŒ‡æ˜äº†æ•°æ®çš„æµå‘ï¼Œâ€œHello World\u0026rdquo; å’Œä»£è¡¨æ¢è¡Œç¬¦çš„ \u0026ldquo;\\n\u0026rdquo; ä¾æ¬¡æµå…¥ \u0026ldquo;cout\u0026rdquo; å¹¶è¢«æ˜¾ç¤ºå‡ºæ¥ï¼Œè¿™å°±æ˜¯ cout çš„ç”¨æ³•ï¼Œé¢‡æœ‰è±¡å½¢æ–‡å­—çš„æ™ºæ…§ã€‚\nstd:: è¿™ä¸ªå‰ç¼€æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿ\nstd æ˜¯ä¸€ä¸ªå‘½åç©ºé—´ (namespace)ã€‚å¯¹äºåˆå­¦è€…æ¥è¯´å‘½åç©ºé—´çš„æ¦‚å¿µå¤ªè¿‡å¤æ‚äº†ï¼Œä½ å¯ä»¥æŠŠå®ƒå½“ä½œâ€œå¤´æ–‡ä»¶â€æ¥ç†è§£ï¼šstd ä¸­æœ‰å¾ˆå¤šå‡½æ•°/å¯¹è±¡/\u0026hellip;å¯ä»¥ä¾›æˆ‘ä»¬ä½¿ç”¨ã€‚åœ¨ä½¿ç”¨å®ƒä»¬æ—¶ï¼Œä¸ºäº†è®©è®¡ç®—æœºçŸ¥é“è¿™ä¸ªå‡½æ•°/å¯¹è±¡/\u0026hellip;æ¥è‡ªäº stdï¼Œæˆ‘ä»¬è¦å‰é¢åŠ ä¸Š std:: è¿™ä¸ªå‰ç¼€ã€‚\nä¸€ä¸ªè‡ªç„¶çš„é—®é¢˜æ˜¯ï¼šæˆ‘ä»¬æ—¢ç„¶æœ‰ä¸€ä¸ª include è¯­å¥åŒ…å«å¤´æ–‡ä»¶ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä¸å¯ä»¥ä¹Ÿç”¨ä¸€æ¡è¯­å¥æ¥â€œåŒ…å«â€ std ä»è€Œé¿å…æ¯æ¬¡ä½¿ç”¨ std ä¸­çš„ä¸œè¥¿éƒ½è¦å†™ std:: å‘¢ï¼Ÿç­”æ¡ˆæ˜¯è‚¯å®šçš„ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·å†™ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; ç¬¬äºŒè¡Œçš„æ„æ€æ˜¯ï¼šåœ¨æ•´ä¸ªç¨‹åºä¸­æˆ‘éƒ½å¯ä»¥ä»»æ„åœ°ä½¿ç”¨ std è¿™ä¸ª namespace çš„æ‰€æœ‰å†…å®¹ï¼Œä¸å†éœ€è¦ std:: è¿™ä¸ªå‰ç¼€ã€‚è¿™æ ·å†™å›ºç„¶æ–¹ä¾¿ï¼Œä½†æˆ‘ä»¬ä»ç„¶æ¨èæ–°æ‰‹å…»æˆä¸æ»¥ç”¨ using namespace std; çš„ä¹ æƒ¯ï¼Œå› ä¸ºè¿™æ ·ä½ èƒ½å¤Ÿæ›´å¥½åœ°çŸ¥é“å“ªäº›å‡½æ•°æ˜¯å¤´æ–‡ä»¶ä¸­çš„ï¼Œå“ªäº›å‡½æ•°æ˜¯ std ä¸­çš„ï¼Œè¿™å¯¹å°†æ¥çš„ç¼–ç¨‹å­¦ä¹ å¾ˆæœ‰å¥½å¤„ã€‚\nä¸€ä¸ªåªèƒ½è¾“å‡ºçš„ç¨‹åºæ²¡æœ‰æ„æ€ï¼Œæˆ‘ä»¬å¸Œæœ›ç¨‹åºå¯ä»¥ä¸äººç±»äº¤äº’ï¼Œå› æ­¤æˆ‘ä»¬æ¥ä¸‹æ¥è€ƒè™‘ä¸€ä¸ªæ›´å¤æ‚çš„ä¾‹å­ï¼šè¾“å…¥ä¸¤ä¸ªæ•°ï¼Œè¾“å‡ºå®ƒä»¬çš„å’Œã€‚æˆ‘ä»¬ç›´æ¥ç»™å‡ºç¤ºä¾‹ä»£ç ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; int main () { int a, b, sum; std::cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; // don't forget the \u0026quot;std::\u0026quot; prefix! sum = a + b; std::cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; '\\n'; return 0; } è¿™ä¸ªç¨‹åºé¢‡ä¸ºå¤æ‚ï¼Œå‡ºç°äº†å¾ˆå¤šæ–°ä¸œè¥¿ï¼Œæˆ‘ä»¬æ¥ä¸€ä¸€çœ‹ï¼š\nç¨‹åºä¸­çš„ a b sum è¢«ç§°ä¸ºå˜é‡ (variable)ã€‚å˜é‡å¯ä»¥è¢«ç†è§£ä¸ºä¸€ä¸ªâ€œå°ç›’å­â€œï¼Œé‡Œé¢å¯ä»¥å­˜æ”¾ä¸€ä¸ªå€¼ã€‚åœ¨ä½¿ç”¨å˜é‡å‰æˆ‘ä»¬éœ€è¦å®šä¹‰å˜é‡ï¼Œå®šä¹‰çš„æ ¼å¼æ˜¯ ç±»å‹ å˜é‡å;ï¼Œè¿™é‡Œæˆ‘ä»¬å®šä¹‰äº† int ç±»å‹çš„å˜é‡ï¼Œè¡¨ç¤º a b sum è¿™ä¸‰ä¸ªâ€œç›’å­â€é‡Œåªèƒ½å­˜æ”¾æ•´æ•°ã€‚ cin æ˜¯ç”¨äºè¾“å…¥çš„å¯¹è±¡ã€‚æœ‰äº† cout çš„ç»éªŒï¼Œcin ä¸€è¡Œå¾ˆå¥½ç†è§£ï¼šæˆ‘ä»¬è¿˜æ˜¯å°† \u0026ldquo;cin\u0026rdquo; æƒ³è±¡æˆé»‘è‰²çª—å£ï¼Œå½“æˆ‘ä»¬è¾“å…¥äº†ä¸¤ä¸ªæ•°å­—çš„æ—¶å€™ï¼Œ\u0026ldquo;cin\u0026rdquo; éœ€è¦å°†æ•°æ®å–‚ç»™å˜é‡ï¼Œå› æ­¤æµç¬¦å·çš„æ–¹å‘æ˜¯ \u0026gt;\u0026gt;ã€‚ sum = a + b; æ˜¯ä¸€ä¸ªèµ‹å€¼è¯­å¥ï¼Œå®ƒçš„å«ä¹‰æ˜¯å°† a å’Œ b ä¸­çš„å€¼åŠ èµ·æ¥ï¼Œå­˜æ”¾åˆ° sum ä¸­ï¼Œæ³¨æ„è¯¥æ“ä½œä¸ä¼šå½±å“ a å’Œ b ä¸­çš„å†…å®¹ã€‚ å˜é‡\nä¸Šè¿°ç¤ºä¾‹ä»£ç ä¸­å®šä¹‰çš„æ˜¯ int å‹çš„å˜é‡ (\u0026ldquo;int\u0026quot;æ˜¯æ•´æ•° integer çš„ç¼©å†™ï¼‰ã€‚C++ ä¸ºæˆ‘ä»¬æä¾›äº†å¾ˆå¤šçš„å˜é‡ç±»å‹ï¼Œæ¯”å¦‚å­˜å‚¨å°æ•°(æµ®ç‚¹æ•°ï¼‰çš„ float ç±»å‹å’Œ double ç±»å‹ï¼Œå­˜å‚¨æ›´å¤§çš„æ•´æ•°çš„ long long ç±»å‹ï¼Œå­˜å‚¨å­—ç¬¦çš„ char ç±»å‹ç­‰ç­‰ï¼Œä½ å¯ä»¥ä¸Šç½‘æœç´¢è¿™äº›ç±»å‹çš„å«ä¹‰ã€‚\né™¤æ­¤ä¹‹å¤–ï¼Œå˜é‡çš„å‘½åçœ‹ä¼¼è‡ªç”±ï¼Œå…¶å®ä¹Ÿæœ‰ä¸€å®šçš„çº¦æŸæ¡ä»¶ï¼Œæ¯”å¦‚å˜é‡åçš„ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸èƒ½æ˜¯æ•°å­—ã€‚å¦‚æœä½ æ„Ÿå…´è¶£ï¼Œä½ ä¹Ÿå¯ä»¥ä¸Šç½‘æœç´¢ç›¸å…³çš„èµ„æ–™ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"c854c8cdfcb821c5e43b471585efd925","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/c++0/io/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/problemsolving22/c++0/io/","section":"courses","summary":"å¦‚æœä½ ä½¿ç”¨çš„æ˜¯ Dev-cppï¼Œå°†åŸºæœ¬æ¡†æ¶ä¸­çš„ç¨‹åºæ‹·è´åˆ°ä»£ç åŒºå¹¶æŒ‰ä¸‹ F11ï¼Œä½ ä¼šå‘ç°ç¨‹åºå·²ç»å¯ä»¥æˆåŠŸåœ°è¿è¡Œäº†ï¼ä¸è¿‡è·³å‡ºçš„é»‘è‰²çª—å£ä¸­æ²¡æœ‰ä»»ä½•å†…å®¹â€”â€”å› ä¸ºæˆ‘ä»¬çš„ main å‡½æ•°ä¸­ä»€ä¹ˆéƒ½æ²¡å†™ã€‚æˆ‘ä»¬ç°åœ¨æ¥å°è¯•è¾“å‡ºä¸€è¡Œ \u0026ldquo;hello world!\u0026quot;ï¼š\n#include \u0026lt;bits/stdc++.h\u0026gt; int main () { std::cout \u0026lt;\u0026lt; \u0026quot;Hello World\u0026quot; \u0026lt;\u0026lt; '\\n'; // don't forget to add ';' at the end! return 0; } cout æ˜¯ä¸€ä¸ªå¯¹è±¡ (object)ï¼Œä½œä¸ºåˆå­¦è€…æˆ‘ä»¬ä¸éœ€è¦çŸ¥é“å¯¹è±¡æ˜¯ä»€ä¹ˆæ„æ€ï¼Œä¸€ä¸ªå¥½çš„ç†è§£æ–¹å¼æ˜¯ï¼šä½ å¯ä»¥æŠŠ \u0026ldquo;cout\u0026rdquo; æƒ³è±¡æˆè¿è¡Œæ—¶è¹¦å‡ºçš„çª—å£ï¼Œç°åœ¨æˆ‘ä»¬çš„ä»»åŠ¡æ˜¯å°†è¦è¾“å‡ºçš„å†…å®¹å–‚ç»™çª—å£ï¼Œè¿™é‡Œçš„ \u0026lt;\u0026lt; å°±åƒç®­å¤´ä¸€æ ·æŒ‡æ˜äº†æ•°æ®çš„æµå‘ï¼Œâ€œHello World\u0026rdquo; å’Œä»£è¡¨æ¢è¡Œç¬¦çš„ \u0026ldquo;\\n\u0026rdquo; ä¾æ¬¡æµå…¥ \u0026ldquo;cout\u0026rdquo; å¹¶è¢«æ˜¾ç¤ºå‡ºæ¥ï¼Œè¿™å°±æ˜¯ cout çš„ç”¨æ³•ï¼Œé¢‡æœ‰è±¡å½¢æ–‡å­—çš„æ™ºæ…§ã€‚","tags":null,"title":"è¾“å…¥è¾“å‡º","type":"docs"},{"authors":null,"categories":null,"content":"é€’å½’å¯¹äºåˆå­¦è€…æ¥è¯´æ˜¯ä¸€ä¸ªéå¸¸å¤´ç–¼çš„æ¦‚å¿µã€‚å¦‚æœä½ è§‰å¾—æš‚æ—¶æ— æ³•ç†è§£ï¼Œè¯·ä¸è¦ç°å¿ƒï¼Œå› ä¸ºæ­£å¸¸çš„äººç±»å€¾å‘äºä½¿ç”¨é€’æ¨æ€è€ƒé—®é¢˜ï¼Œå³ä»ä¸€ä¸ª base case å‡ºå‘ä»å°å¾€å¤§æ¨ï¼Œè€Œä¸æ˜¯æŠŠä¸€ä¸ªå¤§çš„é—®é¢˜é€æ¸æ‹†è§£ã€‚ä½†ä½ å¿…é¡»é€æ¸ä¹ æƒ¯è®¡ç®—æœºä¸–ç•Œä¸­çš„è¿™ç§å°†å¤§ä»»åŠ¡æ‹†æˆå°ä»»åŠ¡è§£å†³çš„æ€æƒ³ï¼Œå¤§å®¶åé¢ä¼šæ¥è§¦åˆ°çš„åˆ†æ²»æ€æƒ³æ›´æ˜¯å°†è¿™ä¸€ç‚¹å‘æŒ¥åˆ°äº†æè‡´ã€‚\nè¿™ç¯‡è®²ä¹‰å¸Œæœ›ç”¨ä¸€ä¸ªæ•…äº‹æŠŠé€’å½’çš„æ€æƒ³è®²æ˜ç™½ã€‚å‡è®¾ä¸€ä¸ªå›½å®¶çš„å›½ç‹æœ‰ä¸€ä¸ªä»»åŠ¡ï¼šè®¡ç®— $1+2+\\cdots+100$ã€‚æ—¥ç†ä¸‡æœºçš„å›½ç‹è‚¯å®šä¸ä¼šä¸€ä¸ªä¸€ä¸ªç´¯åŠ æµªè´¹æ—¶é—´ï¼Œä½†ä»–ä¹Ÿæ²¡æœ‰èªæ˜åˆ°èƒ½å¤Ÿå‘ç°é«˜æ–¯å…¬å¼ã€‚å¹¸è¿çš„æ˜¯ä»–æœ‰ä¸€æ‰¹å¬è¯çš„å¤§è‡£å¯ä»¥ä½¿ç”¨ï¼Œäºæ˜¯ä»–è®¾è®¡äº†ä¸€ä¸ªè¿™æ ·çš„ç­–ç•¥ï¼š\nè®©ä¸ç›¸å»è®¡ç®— $1+2+\\cdots +99$ï¼Œç­‰ä»–æŠŠç»“æœè¿”å›ç»™æˆ‘äº†ï¼Œæˆ‘åªè¦è®¡ç®—è¿™ä¸ªç»“æœ+100ï¼Œç­”æ¡ˆå°±å‡ºæ¥äº†ã€‚\nä¸ç›¸åŒæ ·å¿™ç¢Œä¸”æ•°å­¦å¤©åˆ†ä¸é«˜ï¼Œä½†å¹¸è¿çš„æ˜¯ä»–ä¹Ÿæœ‰ä¸€æ‰¹æ‰‹ä¸‹å¯ä»¥å¬å”¤ï¼Œäºæ˜¯ä»–è®¾è®¡äº†ä¸€ä¸ªåŒæ ·çš„ç­–ç•¥ï¼š\næ‰¾ä¸€ä¸ªæ‰‹ä¸‹å¤§è‡£å»è®¡ç®— $1+2+\\cdots +98$ï¼Œç­‰ä»–æŠŠç»“æœè¿”å›ç»™æˆ‘äº†ï¼Œæˆ‘åªè¦è®¡ç®—è¿™ä¸ªç»“æœ+99ï¼Œå°±èƒ½å‘å›½ç‹äº¤å·®äº†ã€‚\nè¿™ä¸ªç‹å›½çš„æ‰€æœ‰äººéƒ½æ·±è°™èµ„æœ¬ä¸»ä¹‰å‹æ¦¨ä¸‹å±çš„å¥—è·¯ (bushi)ï¼Œäºæ˜¯è¿™ä¸ªä»»åŠ¡è¢«ä¸€çº§ä¸€çº§ä¼ é€’ä¸‹å»ï¼Œç›´åˆ°æ‘é•¿æ‹¿åˆ° $1+2+3$ æ—¶ï¼ŒæŠŠ $1+2$ è¿™ä¸ªä»»åŠ¡åˆ†é…ç»™äº†ä¸€ä¸ªæ™®é€šçš„æ‘æ°‘ã€‚æ‘æ°‘æ²¡æœ‰æ‰‹ä¸‹å¯ä»¥ä½¿ç”¨äº†ï¼Œä½†å¹¸è¿çš„æ˜¯è¿™ä¸ªé—®é¢˜è¶³å¤Ÿç®€å•ï¼Œä»–æƒ³éƒ½æ²¡æƒ³å°±æœºæ™ºåœ°å¾—åˆ°äº†ç­”æ¡ˆ $3$ å¹¶å°†ç»“æœè¿”å›ç»™äº†æ‘é•¿ã€‚æ‘é•¿æ”¶åˆ° $3$ åè®¡ç®—å‡º $3+3=6$ï¼Œåˆå°†ç»“æœè¿”å›ç»™äº†é•‡é•¿â€¦â€¦ä¸€è·¯ä¸‹æ”¾çš„ä»»åŠ¡åœ¨æ”¶ç»“æœçš„è¿‡ç¨‹ä¸­åˆè¢«ä¸€è·¯ä¸Šä¼ å›å»ï¼Œæœ€åå›½ç‹æ”¶åˆ°äº†ä¸ç›¸çš„å›å¤ï¼š$4950$ï¼Œäºæ˜¯ä»–å®Œæˆäº†æœ€åä¸€æ­¥åŠ æ³•ï¼Œ$4950+100=5050$ï¼Œå¹¶å¾ˆé«˜å…´åœ°å®£ç§°è¯¥ä»»åŠ¡åœ†æ»¡ç»“æŸã€‚\nè¿™æ ·çš„å†™æ³•å¯èƒ½è¿˜ä¸è¶³ä»¥å”¤é†’ä½ åœ¨è¯¾å ‚ä¸Šå­¦ä¹ çš„é€’å½’â€œå¥—è·¯â€ã€‚æˆ‘ä»¬ä¸å¦¨å†™çš„æ›´å½¢å¼åŒ–ä¸€ç‚¹ï¼šä»¤ $F(n)$ è¡¨ç¤ºè®¡ç®— $1+2+\\cdots +n$ è¿™ä¸ªä»»åŠ¡ï¼Œé‚£ä¹ˆå›½ç‹çš„ä»»åŠ¡æ˜¯è®¡ç®— $F(100)$ï¼Œä¸ç›¸çš„ä»»åŠ¡æ˜¯è®¡ç®— $F(99)$â€¦â€¦é•‡é•¿çš„ä»»åŠ¡æ˜¯è®¡ç®— $F(4)$ï¼Œæ‘é•¿çš„ä»»åŠ¡æ˜¯è®¡ç®— $F(3)$ã€‚ä¸è®ºè¿™ä¸ªå‚æ•°æ˜¯å¤§æ˜¯å°ï¼Œä»–ä»¬éƒ½é‡‡å–äº†ç›¸åŒçš„æˆ˜æœ¯ï¼š $$ F(n)=F(n-1)+n $$ åªæœ‰æ‘æ°‘ä¸ä¸€æ ·ï¼Œä»–çš„ä»»åŠ¡å°±æ˜¯ä¸€ä¸ªç®€å•çš„åŠ æ³•ã€‚æ‰€ä»¥æ•´ä¸ªç‹å›½çš„ç­–ç•¥å¯ä»¥è¢«å½’çº³ä¸º $$ F(n)= \\begin{cases} 3\u0026amp;,n=2\\\\ F(n-1)+n\u0026amp;,n\\geq 3 \\end{cases} $$ è¿™å°±æ˜¯é€’å½’çš„åŸºæœ¬æ€æƒ³ï¼šå¦‚æœä¸€ä¸ªå¤§ä»»åŠ¡ (ä¾‹å¦‚ $F(n)$) å¯ä»¥è¢«åˆ†è§£æˆä¸€ä¸ªæ€§è´¨ç›¸åŒä½†è§„æ¨¡æ›´å°çš„ä»»åŠ¡ (ä¾‹å¦‚ $F(n-1)$) ä»¥åŠä¸€äº›ç®€å•çš„é¢å¤–è¿ç®— (ä¾‹å¦‚ $+n$)ï¼Œé‚£ä¹ˆè¿™ä¸ªé—®é¢˜å°±éå¸¸é€‚åˆç”¨é€’å½’è§£å†³ã€‚æˆ‘ä»¬å¯ä»¥ä¸ºä¸Šé¢çš„é€’å½’åŠ æ³•å†™ä¸€ä¸ªç¨‹åºï¼š\nint query_sum(int n) { if (n == 2) return 3; else return query_sum(n - 1) + n; } è¯¥å‡½æ•°çš„æ‰§è¡Œè¿‡ç¨‹å’Œç‹å›½é‡Œä»»åŠ¡ä¸‹æ”¾å†å›æ”¶çš„è¿‡ç¨‹å®Œå…¨ç›¸åŒï¼šquery_sum(100) è°ƒç”¨ query_sum(99) ç­‰å¾…å…¶è¿”å›å€¼ï¼Œquery_sum(99) åˆè°ƒç”¨äº† query_sum(98)â€¦â€¦ä»è€Œå½¢æˆäº†ä¸€ä¸ªé•¿é•¿çš„è°ƒç”¨é“¾ã€‚query_sum(3) è°ƒç”¨ query_sum(2) æ—¶ï¼Œquery_sum(2) ä¸éœ€è¦å†è°ƒç”¨å­å‡½æ•°ï¼Œç›´æ¥è¿”å›äº†ç»“æœï¼Œä»è€Œ query_sum(3) æ‰§è¡Œå®ŒåŠ æ³•åä¹Ÿè¿”å›äº†ç»“æœï¼Œä¸€å±‚å±‚è¿”å›ç»“æœï¼Œç›´åˆ° query_sum(100) è¿”å›ã€‚\nå¤§å®¶æ›´åŠ å–œé—»ä¹è§çš„å¯èƒ½æ˜¯å°å­¦/ä¸­å­¦æ¥è§¦è¿‡çš„æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼š $$ fib_n= \\begin{cases} 0\u0026amp;, n=0\\\\ 1\u0026amp;, n=1\\\\ fib_{n-1}+fib_{n-2}\u0026amp;, n\\geq 2 \\end{cases} $$\nèƒ½å¤Ÿå†™å‡ºè¿™ç§é€’æ¨å¼çš„æ•°åˆ—ä¸€å®šå¯ä»¥éå¸¸ç®€æ˜åœ°ç”¨é€’å½’å®ç°è®¡ç®—ï¼š\nint query_fib(int n) { if (n == 0) return 0; else if (n == 1) return 1; else return query_fib(n - 1) + query_fib(n - 2); } è¿™ä¸ªä¾‹å­æ¯”ä¸Šä¸€ä¸ªä¾‹å­ç¨ç¨å¤æ‚ä¸€äº›ï¼Œå› ä¸ºå®ƒæŠŠä¸€ä¸ªå¤§ä»»åŠ¡åˆ†è§£æˆäº†ä¸¤ä¸ªå°ä»»åŠ¡ï¼Œå¯ä»¥æƒ³è±¡é€’å½’çš„è°ƒç”¨ä¼šå½¢æˆä¸€ä¸ªæ ‘çŠ¶ç»“æ„è€Œä¸æ˜¯é“¾çŠ¶ç»“æ„ã€‚ä½ å¯ä»¥è‡ªå·±ç”¨çº¸ç¬”ç”»ä¸€ç”» query_fib(5) çš„é€’å½’è°ƒç”¨è¿‡ç¨‹ï¼Œç”»å®Œä¹‹åå‚è€ƒ è¿™ä¸ªé“¾æ¥ çš„åŠ¨ç”»è¿›è¡Œæ¯”å¯¹ã€‚\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"82091eade8d2de99a8e1f34ff8ef6e49","permalink":"https://kristoff-starling.github.io/courses/problemsolving22/c++0/recursion/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/problemsolving22/c++0/recursion/","section":"courses","summary":"é€’å½’å¯¹äºåˆå­¦è€…æ¥è¯´æ˜¯ä¸€ä¸ªéå¸¸å¤´ç–¼çš„æ¦‚å¿µã€‚å¦‚æœä½ è§‰å¾—æš‚æ—¶æ— æ³•ç†è§£ï¼Œè¯·ä¸è¦ç°å¿ƒï¼Œå› ä¸ºæ­£å¸¸çš„äººç±»å€¾å‘äºä½¿ç”¨é€’æ¨æ€è€ƒé—®é¢˜ï¼Œå³ä»ä¸€ä¸ª base case å‡ºå‘ä»å°å¾€å¤§æ¨ï¼Œè€Œä¸æ˜¯æŠŠä¸€ä¸ªå¤§çš„é—®é¢˜é€æ¸æ‹†è§£ã€‚ä½†ä½ å¿…é¡»é€æ¸ä¹ æƒ¯è®¡ç®—æœºä¸–ç•Œä¸­çš„è¿™ç§å°†å¤§ä»»åŠ¡æ‹†æˆå°ä»»åŠ¡è§£å†³çš„æ€æƒ³ï¼Œå¤§å®¶åé¢ä¼šæ¥è§¦åˆ°çš„åˆ†æ²»æ€æƒ³æ›´æ˜¯å°†è¿™ä¸€ç‚¹å‘æŒ¥åˆ°äº†æè‡´ã€‚\nè¿™ç¯‡è®²ä¹‰å¸Œæœ›ç”¨ä¸€ä¸ªæ•…äº‹æŠŠé€’å½’çš„æ€æƒ³è®²æ˜ç™½ã€‚å‡è®¾ä¸€ä¸ªå›½å®¶çš„å›½ç‹æœ‰ä¸€ä¸ªä»»åŠ¡ï¼šè®¡ç®— $1+2+\\cdots+100$ã€‚æ—¥ç†ä¸‡æœºçš„å›½ç‹è‚¯å®šä¸ä¼šä¸€ä¸ªä¸€ä¸ªç´¯åŠ æµªè´¹æ—¶é—´ï¼Œä½†ä»–ä¹Ÿæ²¡æœ‰èªæ˜åˆ°èƒ½å¤Ÿå‘ç°é«˜æ–¯å…¬å¼ã€‚å¹¸è¿çš„æ˜¯ä»–æœ‰ä¸€æ‰¹å¬è¯çš„å¤§è‡£å¯ä»¥ä½¿ç”¨ï¼Œäºæ˜¯ä»–è®¾è®¡äº†ä¸€ä¸ªè¿™æ ·çš„ç­–ç•¥ï¼š\nè®©ä¸ç›¸å»è®¡ç®— $1+2+\\cdots +99$ï¼Œç­‰ä»–æŠŠç»“æœè¿”å›ç»™æˆ‘äº†ï¼Œæˆ‘åªè¦è®¡ç®—è¿™ä¸ªç»“æœ+100ï¼Œç­”æ¡ˆå°±å‡ºæ¥äº†ã€‚\nä¸ç›¸åŒæ ·å¿™ç¢Œä¸”æ•°å­¦å¤©åˆ†ä¸é«˜ï¼Œä½†å¹¸è¿çš„æ˜¯ä»–ä¹Ÿæœ‰ä¸€æ‰¹æ‰‹ä¸‹å¯ä»¥å¬å”¤ï¼Œäºæ˜¯ä»–è®¾è®¡äº†ä¸€ä¸ªåŒæ ·çš„ç­–ç•¥ï¼š\næ‰¾ä¸€ä¸ªæ‰‹ä¸‹å¤§è‡£å»è®¡ç®— $1+2+\\cdots +98$ï¼Œç­‰ä»–æŠŠç»“æœè¿”å›ç»™æˆ‘äº†ï¼Œæˆ‘åªè¦è®¡ç®—è¿™ä¸ªç»“æœ+99ï¼Œå°±èƒ½å‘å›½ç‹äº¤å·®äº†ã€‚\nè¿™ä¸ªç‹å›½çš„æ‰€æœ‰äººéƒ½æ·±è°™èµ„æœ¬ä¸»ä¹‰å‹æ¦¨ä¸‹å±çš„å¥—è·¯ (bushi)ï¼Œäºæ˜¯è¿™ä¸ªä»»åŠ¡è¢«ä¸€çº§ä¸€çº§ä¼ é€’ä¸‹å»ï¼Œç›´åˆ°æ‘é•¿æ‹¿åˆ° $1+2+3$ æ—¶ï¼ŒæŠŠ $1+2$ è¿™ä¸ªä»»åŠ¡åˆ†é…ç»™äº†ä¸€ä¸ªæ™®é€šçš„æ‘æ°‘ã€‚æ‘æ°‘æ²¡æœ‰æ‰‹ä¸‹å¯ä»¥ä½¿ç”¨äº†ï¼Œä½†å¹¸è¿çš„æ˜¯è¿™ä¸ªé—®é¢˜è¶³å¤Ÿç®€å•ï¼Œä»–æƒ³éƒ½æ²¡æƒ³å°±æœºæ™ºåœ°å¾—åˆ°äº†ç­”æ¡ˆ $3$ å¹¶å°†ç»“æœè¿”å›ç»™äº†æ‘é•¿ã€‚æ‘é•¿æ”¶åˆ° $3$ åè®¡ç®—å‡º $3+3=6$ï¼Œåˆå°†ç»“æœè¿”å›ç»™äº†é•‡é•¿â€¦â€¦ä¸€è·¯ä¸‹æ”¾çš„ä»»åŠ¡åœ¨æ”¶ç»“æœçš„è¿‡ç¨‹ä¸­åˆè¢«ä¸€è·¯ä¸Šä¼ å›å»ï¼Œæœ€åå›½ç‹æ”¶åˆ°äº†ä¸ç›¸çš„å›å¤ï¼š$4950$ï¼Œäºæ˜¯ä»–å®Œæˆäº†æœ€åä¸€æ­¥åŠ æ³•ï¼Œ$4950+100=5050$ï¼Œå¹¶å¾ˆé«˜å…´åœ°å®£ç§°è¯¥ä»»åŠ¡åœ†æ»¡ç»“æŸã€‚\nè¿™æ ·çš„å†™æ³•å¯èƒ½è¿˜ä¸è¶³ä»¥å”¤é†’ä½ åœ¨è¯¾å ‚ä¸Šå­¦ä¹ çš„é€’å½’â€œå¥—è·¯â€ã€‚æˆ‘ä»¬ä¸å¦¨å†™çš„æ›´å½¢å¼åŒ–ä¸€ç‚¹ï¼šä»¤ $F(n)$ è¡¨ç¤ºè®¡ç®— $1+2+\\cdots +n$ è¿™ä¸ªä»»åŠ¡ï¼Œé‚£ä¹ˆå›½ç‹çš„ä»»åŠ¡æ˜¯è®¡ç®— $F(100)$ï¼Œä¸ç›¸çš„ä»»åŠ¡æ˜¯è®¡ç®— $F(99)$â€¦â€¦é•‡é•¿çš„ä»»åŠ¡æ˜¯è®¡ç®— $F(4)$ï¼Œæ‘é•¿çš„ä»»åŠ¡æ˜¯è®¡ç®— $F(3)$ã€‚ä¸è®ºè¿™ä¸ªå‚æ•°æ˜¯å¤§æ˜¯å°ï¼Œä»–ä»¬éƒ½é‡‡å–äº†ç›¸åŒçš„æˆ˜æœ¯ï¼š $$ F(n)=F(n-1)+n $$ åªæœ‰æ‘æ°‘ä¸ä¸€æ ·ï¼Œä»–çš„ä»»åŠ¡å°±æ˜¯ä¸€ä¸ªç®€å•çš„åŠ æ³•ã€‚æ‰€ä»¥æ•´ä¸ªç‹å›½çš„ç­–ç•¥å¯ä»¥è¢«å½’çº³ä¸º $$ F(n)= \\begin{cases} 3\u0026amp;,n=2\\\\ F(n-1)+n\u0026amp;,n\\geq 3 \\end{cases} $$ è¿™å°±æ˜¯é€’å½’çš„åŸºæœ¬æ€æƒ³ï¼šå¦‚æœä¸€ä¸ªå¤§ä»»åŠ¡ (ä¾‹å¦‚ $F(n)$) å¯ä»¥è¢«åˆ†è§£æˆä¸€ä¸ªæ€§è´¨ç›¸åŒä½†è§„æ¨¡æ›´å°çš„ä»»åŠ¡ (ä¾‹å¦‚ $F(n-1)$) ä»¥åŠä¸€äº›ç®€å•çš„é¢å¤–è¿ç®— (ä¾‹å¦‚ $+n$)ï¼Œé‚£ä¹ˆè¿™ä¸ªé—®é¢˜å°±éå¸¸é€‚åˆç”¨é€’å½’è§£å†³ã€‚æˆ‘ä»¬å¯ä»¥ä¸ºä¸Šé¢çš„é€’å½’åŠ æ³•å†™ä¸€ä¸ªç¨‹åºï¼š","tags":null,"title":"é€’å½’","type":"docs"}]