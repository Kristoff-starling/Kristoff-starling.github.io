---
title: "PA1 - 开天辟地的篇章：最简单的计算机"
linktitle: 'PA1'
type: docs
draft: false
featured: false

math: true

menu:
    njuics-pa:
        parent: Contents
        weight: 2
---

## 实验进度

我完成了所有的必答题，并针对选做题和思考题给出了自己的想法。

## 必答题

### 程序是个状态机

点击 [这里](#answer) 跳转到解答。

### 理解基础设施

有 450 次编译用于调试，假设只有 450 个 bug，那么总共需要 4500min = 75h 。简易调试器可以节约 50h 的时间。

### RTFM

> riscv32有哪几种指令格式?

在 Volume I - 2.2 节可以查到 Base Instruction Formats, 在 Volume I -17.2 节中可以查到 Compressed Instruction Formats。在 Volume I - 26.3 节可以查到扩展 RISCV 的指令格式。

> LUI指令的行为是什么?

在 Volume I 第 19 页可以查到 LUI 指令的行为。

> mstatus寄存器的结构是怎么样的?

在 Volume II - 3.1.6 节可以查到 machine status register 的结构。

### Shell命令

笔者使用了如下命令来统计所有非空行的代码行数：

```bash
find . -name "*[.c|.h]" | xargs grep ^. | wc -l
```

其中的正则表达式 `^.` 用来识别开头至少有一个字符的行。

pa0结束时共有代码 19868 行，pa1结束时共有代码 20272 行。

### RTFM

`-Wall` 选项会显示所有的 warning 信息，`-Werror` 会将所有 warning 视作 error 报错。使用这些编译选项可以尽早发现潜在的错误并强制报错，将 bug 消灭在 fault 的阶段。

---

以下是我的自由报告内容，我在做实验的过程中详细记录了自己遇到的所有问题和查阅的所有资料。这些笔记按照章节排列，每章通常有两个部分：

* 思考题：包含笔者针对思考题查阅的资料和我尝试给出的答案。
* 补充：这里的内容是没有在讲义中提及的问题，以及讲义中建议自学的东西。

## 在开始愉快的PA之旅之前

### 补充

#### 关于 `git status` 追踪不到修改

在 `ics2021` 根目录下新建文件 `touch test.cpp` 后使用 `git status` 查看变化，发现 git 并没有追踪到这条变化。使用 `git add a.cpp` 命令后显示：

```bash
The following paths are ignored by one of your .gitignore files
```

这说明根目录的 `.gitignore` 文件忽略了该文件，打开 `.gitignore` 查看：

```bash
*.*
*
!*/
!/nemu/*
!/nexus-am/*
!/nanos-lite/*
!/navy-apps/*
!Makefile
!README.md
!.gitignore
!init.sh
/fceux-am
/am-kernels
```

查阅资料得知，`.gitignore` 文件的最基础语法包括：

* 可以用正则表达式 `[]` `?` `*` 等来匹配文件名
* 行开头使用 `!` 表示不忽略该行匹配的文件

`ics2001/a.cpp` 被 `*.*` 捕捉，因此被 git 忽略了。为了验证我的思考，我在 `ics2001/nemu` 下创建了 `a.cpp` ，根据根目录下的 `.gitignore` 文件 `/nemu` 下的文件没有被忽略，但 git 仍然没有追踪到 `a.cpp`。

我发现 `/nemu` 下也有 `.gitignore` 文件，该文件中的 `*.*` 捕捉了 `a.cpp`。查阅资料得知，当多个 `.gitignore` 文件发生冲突时，git 优先服从本地的文件而不是父文件夹的文件。

#### 关于添加环境变量

`ccache` 工具要求将 `/usr/lib/ccache` 添加到 PATH 中。笔者一开始直接在 `~/.bashrc` 中添加了如下一行：

```bash
export PATH=/usr/lib/ccache
```

之后发现其他所有的命令都用不了了。事实上大部分命令都放在 `/usr/bin` 之下，这个路径默认保存在 PATH 中。如果向上文那样直接修改 PATH，会导致其他命令无法使用。

在命令行中输入 `export PATH="/usr/bin:$PATH"` 可以暂时将 `/usr/bin` 添加回 PATH，但终端关闭后会失效。此时打开 `~/.bashrc` 将命令修改为

```bash
export PATH=/usr/lib/ccache:$PATH
```

后一切正常。这里的 `:` 是多个路径之间的分隔符，这条语句相当于在原本的 `$PATH` 内容之前加上 `/usr/lib/ccache`。

（事实上仔细阅读 `ccache` 的文档可以发现它让你将路径 “perpend” 到 PATH 中，没让你直接修改……）

## 开天辟地的篇章

### 必答题

#### 从状态机视角理解程序运行 <a id = 'answer'></a>

> 以上一小节中`1+2+...+100`的指令序列为例, 尝试画出这个程序的状态机.
>
> 这个程序比较简单, 需要更新的状态只包括`PC`和`r1`, `r2`这两个寄存器, 因此我们用一个三元组`(PC, r1, r2)`就可以表示程序的所有状态, 而无需画出内存的具体状态. 初始状态是`(0, x, x)`, 此处的`x`表示未初始化. 程序`PC=0`处的指令是`mov r1, 0`, 执行完之后`PC`会指向下一条指令, 因此下一个状态是`(1, 0, x)`. 如此类推, 我们可以画出执行前3条指令的状态转移过程:
>
> ```
>(0, x, x) -> (1, 0, x) -> (2, 0, 0) -> (3, 0, 1)
> ```
> 
> 请你尝试继续画出这个状态机, 其中程序中的循环只需要画出前两次循环和最后两次循环即可.

完整的状态机如下：

```
(0,x,x) -> (1,0,x) -> (2,0,0) -> (3,0,1) -> (4,1,1) -> (2,1,1) -> (3,1,2) -> (4,3,2) -> (2,3,2) -> ... -> (2,4851,98) -> (3,4851,99) -> (4,4950,99) -> (2,4950,99) -> (3,4950,100) -> (4,5050,100) -> (5,5050,100) -> (5,5050,100) -> ...
```

### 思考题

#### [二周目] 计算机可以没有寄存器吗？

> 如果没有寄存器, 计算机还可以工作吗? 如果可以, 这会对硬件提供的编程模型有什么影响呢?
>
> 就算你是二周目来思考这个问题, 你也有可能是第一次听到"编程模型"这个概念. 不过如果一周目的时候你已经仔细地阅读过ISA手册, 你会记得确实有这么个概念. 所以, 如果想知道什么是编程模型, RTFM吧.

留坑，二周目再做。

## RTFSC

### 思考题

#### kconfig生成的宏与条件编译

> 我们已经在上文提到过, kconfig会根据配置选项的结果在 `nemu/include/generated/autoconf.h`中定义一些形如`CONFIG_xxx`的宏, 我们可以在C代码中通过条件编译的功能对这些宏进行测试, 来判断是否编译某些代码. 例如, 当`CONFIG_DEBUG`这个宏没有定义时, 调试相关的代码就无需进行编译.
>
> 为了编写更紧凑的代码, 我们在`nemu/include/debug.h`中定义了一些专门用来对宏进行测试的宏. 例如`IFDEF(CONFIG_DEVICE, init_device());`表示, 如果定义了`CONFIG_DEVICE`, 才会调用`init_device()`函数; 而`MUXDEF(CONFIG_DEBUG, "ON", "OFF")`则表示, 如果定义了`CONFIG_DEBUG`, 则预处理结果为`"ON"`(`"OFF"`在预处理后会消失), 否则预处理结果为`"OFF"`.
>
> 这些宏的功能非常神奇, 你知道这些宏是如何工作的吗?

宏定义的基本格式为 `#define A B`，这里的 `A` 可以包含参数也可以不包含。在编译的过程中，程序中的 A 会被替换成 B。

条件编译指类似于 `#idef A`  `#ifndef A` 等，表示如果宏 `A` 有定义/无定义才会编译下面的代码，以 `#endif` 结尾。

#### 为什么全部都是函数?

> 阅读`init_monitor()`函数的代码, 你会发现里面全部都是函数调用. 按道理, 把相应的函数体在`init_monitor()`中展开也不影响代码的正确性. 相比之下, 在这里使用函数有什么好处呢?

事实上，如果能确定这些代码块只会使用一次，那么将这些代码放进函数体，并在每块的开头用注释写上该部分的作用，也可以达到代码易阅读的效果；但阅读代码发现这些代码块在其他的函数体中也有使用，因此封装成函数可以减少代码量。从另一种角度，这样写 `init_monitor()` 函数内容更加清爽，可以更好地体现分层抽象。

#### 究竟要执行多久？

> 在`cmd_c()`函数中, 调用`cpu_exec()`的时候传入了参数`-1`, 你知道这是什么意思吗?

`cpu_exec()` 中的参数 `n` 代表的是 cpu 执行指令的次数。在 `/nemu/src/cpu/cpu_exec.c` 的源码中是这样写的

```c
for (;n>0;n--) {
    ...
}
```

因此传入参数 `-1` 可以使 cpu 不停地执行指令，直到遇到 nemu_trap 指令。

#### 参数的处理过程

> 另外的一个问题是, 这些参数是从哪里来的呢?

这些参数来自命令行，是用户键入的。main() 函数自带的两个参数 `int argc` 和 `char *argv[]` 处理用户在命令行中键入的参数。`argc` 是参数的个数，`char *argv[]` 是指向参数的指针数组。`parse_args()` 中传递的参数就是这两个。

#### [二周目] 潜在的威胁

> "调用`cpu_exec()`的时候传入了参数`-1`", 这一做法属于未定义行为吗? 请查阅C99手册确认你的想法.

留坑，二周目再做。

#### 谁来指示程序的结束？

> 在程序设计课上老师告诉你, 当程序执行到`main()`函数返回处的时候, 程序就退出了, 你对此深信不疑. 但你是否怀疑过, 凭什么程序执行到`main()`函数的返回处就结束了? 如果有人告诉你, 程序设计课上老师的说法是错的, 你有办法来证明/反驳吗? 如果你对此感兴趣, 请在互联网上搜索相关内容.

main() 函数是程序的入口，但 main () 函数也是被其他程序调用的。例如有一个可执行文件 `test`，在 shell 中输入 `./test` 之后，shell 会 clone 一个子进程，执行

```bash
execve("./test",char * const argv[], char * const envp[]) 
```

execve 加载 ./test 并将参数一步步传递下去。从 `./test` 的入口开始执行（ELF文件中的 `_start()`）, `_start()` 调用 `__libc_start_main()`。`__libc_start_main()` 中有一条

```c
int result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);
```

从这里进入 main() 函数，main() 函数的返回值会存在 result 中，`__libc_start_main()` 会直接 `exit(result)` ，从而 main() 函数的返回值会被父进程捕捉到。

执行完 `./test` 后用 `echo $>` 指令可以打印 main() 函数的返回值。

#### [二周目] 有始有终

> 对于GNU/Linux上的一个程序, 怎么样才算开始? 怎么样才算是结束? 对于在NEMU中运行的程序, 问题的答案又是什么呢?
>
> 与此相关的问题还有: NEMU中为什么要有`nemu_trap`? 为什么要有monitor?

留坑，二周目再做。

### 补充

#### 关于 `$@` 和 `$<`

`$@` 代表目标文件，`$<` 代表第一个依赖文件，此外类似的字符还有 `$^` 代表所有的依赖文件。

#### 关于 `getopt` 和 `getopt_long`

两者都是用于分析参数，不同的是 `getopt` 会忽略长参数（即由 `--` 开头的参数，参数名字可以不止一个字符）而 `getopt_long` 不会。

`monitor.c` 中的源码如下

```c
const struct option table[] = {
    {"batch"    , no_argument      , NULL, 'b'},
    {"log"      , required_argument, NULL, 'l'},
    {"diff"     , required_argument, NULL, 'd'},
    {"port"     , required_argument, NULL, 'p'},
    {"help"     , no_argument      , NULL, 'h'},
    {0          , 0                , NULL,  0 },
};
int o;
while ( (o = getopt_long(argc, argv, "-bhl:d:p:", table, NULL)) != -1) {
    switch (o) {
      case 'b': sdb_set_batch_mode(); break;
      case 'p': sscanf(optarg, "%d", &difftest_port); break;
      case 'l': log_file = optarg; break;
      case 'd': diff_so_file = optarg; break;
      case 1: img_file = optarg; return optind - 1;
      default:
        printf("Usage: %s [OPTION...] IMAGE [args]\n\n", argv[0]);
        printf("\t-b,--batch              run with batch mode\n");
        printf("\t-l,--log=FILE           output log to FILE\n");
        printf("\t-d,--diff=REF_SO        run DiffTest with reference REF_SO\n");
        printf("\t-p,--port=PORT          run DiffTest with port PORT\n");
        printf("\n");
        exit(0);
    }
}
```

* `getopt()` 里有如下参数：`int argc` 表示要分析的选项个数，`char *argv[]` 是指向参数的选项数组。`getopt()` 有一个额外的变量 `optind` 记录当前已经分析到第几个选项。每调用一次，`getopt()` 会返回下一个选项剥去了 `-` 的结果 (optional character)，如果已经没有下一个选项则返回 `-1`。

*  `getopt()` 的参数 `optstring` 表示识别哪些选项。如果选项字符前有 `:` 的话表示该选项还有参数，`getopt()` 分析时会将该选项的参数保存在 `optarg` 变量中。 

    `getopt()` 在默认情况下会将 `argv` 数组中的选项重排，将那些不是选项的 args 放到数组的最后。有两种特殊的扫描方式可以无视这种默认：

    * `optstring` 的首字母是 `+` ，表示遇到第一个非选项的 args 就退出
    * `optstring` 的首字母是 `-` ，表示处理所有的 args，如果遇到非选项的 args，返回的 optional character 是 `1`。可以看到代码中对于非选项的部分 (Case 1) 返回了 `optind-1` ，转到异常处理。

* `switch` 语句中没有判断 `h` ，因为 `h` 是 default 的情况。

## 基础设施

### 思考题

#### 如何测试字符串处理函数？

> 你可能会抑制不住编码的冲动: 与其RTFM, 还不如自己写. 如果真是这样, 你可以考虑一下, 你会如何测试自己编写的字符串处理函数?
>
> 如果你愿意RTFM, 也不妨思考一下这个问题, 因为你会在PA2中遇到类似的问题.

笔者的一点思考是，在测试的时候一定要仔细考虑字符串行末的 '\0' 问题。笔者在实现简易的表达式求值函数时，在 `make_token` 函数中使用 C语言自带的 `strncpy` 函数来将一个字符串的一部分拷贝进 tokens 数组中，但在测试时发现如果 `p` 过之后 `x` 再 `p` 会打印意想不到的结果。

仔细阅读 `strncpy` 的手册，发现其中有这样一句话：

```bash
Warning: If there is no null byte among the first n bytes of src, the string placed in dest will not be null-terminated.
```

这正好是笔者在复制 tokens 过程中遇到的情况。因为复制过来的字符串不带结束符，所以 strlen 函数不能准确给出字符串长度，从而出现错误。

### 补充

#### RTFSC 技巧

如果遇到一个宏或者一个函数不知道该到哪里去找来源，可以使用 `grep xxx -r` 命令来寻找所有包含关键字 `xxx` 的文件。当然在使用了现代的IDE（如 vscode）后这方面的焦虑会少很多。

#### 关于在 nemu 中直接用 `q` 退出会报错 `Error 1`

在 nemu 的主程序 `/nemu/src/nemu-main.c` 中最后调用了函数 `is_exit_status_bad()`，该函数在 `/nemu/src/utils/state.c` 中，源码如下：

```c
int is_exit_status_bad() {
  int good = (nemu_state.state == NEMU_END && nemu_state.halt_ret == 0) ||
    (nemu_state.state == NEMU_QUIT);
  return !good;
}
```

可以看到正常退出的两个条件

* 程序运行结束且没有遇到任何非正常情况
* 执行了 quit 操作

判断执行 quit 操作的方法是 `nemu_state.state == NEMU_QUIT`，然而在框架代码中的 `cmd_q()` 中只有一行 `return -1`。这里的 `return -1` 只是用于给 `sdb_mainloop()` 传递信息使其结束，但没有做好标志信息的设置。所以修改 `cmd_q()` 为

```c
static int cmd_q()
{
    nemu_state.state = NEMU_QUIT;
    return -1;
}
```

再次编译后，即使在程序未运行结束时 quit 也不会收到报错。

#### 关于在 `sdb.c` 中使用访问内存函数报错

在扫描内存函数中，笔者使用 `paddr.c` 中定义的函数 `guest_to_host()` 函数来访问内存，但运行后显示

```bash
error: implicit declaration of function 'guest_to_host'
```

这是因为程序找不到该函数的定义，我们可以 `#include <memory/paddr.c>` 来解决这个问题。

#### 内置客户代码放在了哪里？

跟着程序运行的过程 RTFSC 是一个不错的方法，不过更简单的是我们可以充分相信自己写的程序的正确性：直接在 `nemu ` 文件夹内搜索打印出的内存信息。迅速定位到在 `/nemu/src/isa/init.c` 中的代码：

```
0x800002b7,  // lui t0,0x80000
0x0002a023,  // sw  zero,0(t0)
0x0002a503,  // lw  a0,0(t0)
0x0000006b,  // nemu_trap
```

和打印得到的信息比对，我们可以看到 riscv 是一个小端机器。在 `init_isa` 函数中是通过

```c
memcpy(gueset_to_host(RESET_VECTOR), img, sizeof(img))
```

的方式将 img 中的代码拷贝进内存的。另外我们可以看到：内存中未初始化的部分是乱码。

## 表达式求值

### 思考题

####  为什么printf()的输出要换行?

> 如果不换行, 可能会发生什么? 你可以在代码中尝试一下, 并思考原因, 然后STFW对比你的想法.

留坑。

#### [二周目] 为什么要使用无符号类型? 

> 我们在表达式求值中约定, 所有运算都是无符号运算. 你知道为什么要这样约定吗? 如果进行有符号运算, 有可能会发生什么问题?

留坑。一个想法是引入负数可能会在访存时发生意想不到的问题，但这个问题似乎可以通过访存前的判断来筛除。

#### 表达式生成器如何获得C程序的打印结果?

> 代码中这部分的内容没有任何注释, 聪明的你也许马上就反应过来: 竟然是个RTFM的圈套! 阅读手册了解API的具体行为可是程序员的基本功. 如果觉得去年一整年的程序员都白当了, 就从现在开始好好锻炼吧.

`gen-expr.c` 中使用了如下几个值得借鉴的函数：

* `sprintf(code_buf, code_format, buf)` ，该函数用于将 buf 的内容填入到 code_format 的 "%s" 中，并将整段c语言代码的字符串放进 code_buf。
* `system()`，用于执行一个命令，返回值是为该命令创建的子进程的返回值，如果不是 0 说明指令执行失败。
* `fopen/popen ("file", "r"/"w")` 用于打开文件，后面的 `r/w` 指明是读取还是写入。根据 STFW 的结果，两者的区别在于 `popen()` 会 fork 一个子进程并建立管道连接（不懂，留坑）。经测试，第一处 `fopen` 如果换成 `popen` 会在写入时报错 `Permission denied`；第二处 `popen` 如果换成 `fopen` 则无法读到程序的输出结果。

### 补充

#### 关于表达式生成

1. 如果直接将生成的表达式喂给C语言，C语言会把常量当做整型参与运算，从而得到不正确的结果，如在下面的例子中

    ```
    (0 - 1) / 10
    ```

    在 int 规则下结果为 0，赋给 unsigned 变量之后结果仍是0，而在 unsigned 规则下结果显然不为0。unsigned 可以看做 int 的一个值域右移的版本，在这个版本下做任何加减操作不会影响正确性，但做乘除操作时会发生问题。

    笔者的解决方案是：生成两个表达式，一个正常的表达式用于喂给 nemu，另一个表达式在每个常量后面添加一个 `u`，将常量转化为 unsigned 类型后再喂给C语言。

2. 笔者并不希望通过计算的方式来过滤除0的表达式，因此使用了一种比较无脑的暴力方法：

    笔者修改了生成表达式的 BNF 规范，在新规范中没有 `<expr> / <expr>` ，而是 `<expr> / ((<expr>)*2+ 1)`。无符号数可以看作做完所有操作以后对 $2^{32}$ 取模，由于模数是偶数，因此 `<expr>*2+1` 取模过后必然是一个奇数，这样可以保证除数非零。这样做的唯一缺陷是生成的除数不再是等概率分布的，不过在测试正确性的过程中除数分布的均匀无关紧要。

3. 空格的插入是容易的，只需要在 BNF 规范中添加一条：`<expr> ::= " "<expr>` 即可。

4. 在当前的随机生成方式下，生成长表达式的概率较小。如果想生成更多的表达式，可以修改随机到各个部分的概率，使 `<expr> ::=  <decimal number> | <heximal number> ` 的概率变小。或者设置一个下界，当表达式总长小于下界时不允许生成 `<number>`。

    控制表达式的长度不超过 buffer 的限制是容易的：我们在生成表达式的同时记录当前表达式的总长，当总长超过一个预警值时，强制新表达式只能生成常数即可。

#### 关于负数功能

笔者在 PA1 中实现了负数功能。负号的识别和指针解引用是类似的：如果一个 `-` 的前面是双目运算符，负号或者 `(` 的话，那么当前的 `-` 就是负号（单目运算符）。

在计算的过程中，如果一个表达式由负号开头，且后面的部分中没有“裸露在外”（即不被任何一对括号包裹）的双目运算符，则可以剥离这个负号递归计算，将得到的答案取负之后返回。

## 监视点

### 思考题

#### 温故而知新

> 框架代码中定义`wp_pool`等变量的时候使用了关键字`static`, `static`在此处的含义是什么? 为什么要在此处使用它?

static 最重要的作用在于隐藏。带有 static 的变量以及函数不能在该文件以外的地方访问和使用。例如在 `cpu-exec.c` 文件中，我们要实现对所有监视点的扫描，但又不能直接访问 `watchpoint.c` 中的监视点池，因此我们可以在 `watchpoint.c` 中写一个函数实现这个功能，再通过在 `cpu-exec.c` 中调用这个非 static 的函数来完成任务。使用 static 可以保证本文件中的东西不会被外界污染，如果出现问题，可以在本文件中寻找 bug，降低了调试难度。

#### 你会如何测试你的监视点实现?

> 我们没有提供监视点相关的测试, 思考一下, 你会如何测试?
>
> 当然, 对于实验来说, 将来边用边测也是一种说得过去的方法, 就看你对自己代码的信心了.

笔者没有批量生成测试用例，而是针对监视点的各个功能设计了几种测试手段：

* 每执行完一次操作都使用命令 `info w` 检查所有监视点是否正常。
* 使用表达式 `w *0x80000000+1` ，检查指针解引用部分的正确性， 以及监视点遇到变化是否能暂停程序。
* 使用表达式 `w $t0 / 5`，检查寄存器访问部分的正确性（`t0` 是内置客户程序中唯一修改过的寄存器）。
* 检测 `d` 命令是否能实现，以及删除不存在的监视点是否可以报错。
* 尝试添加大于监视点池容量的监视点，检查是否能触发 assertion fail。

####  强大的GDB

> 如果你遇到了段错误, 你很可能会想知道究竟是哪一行代码触发了段错误. 尝试编写一个触发段错误的程序, 然后在GDB中运行它. 你发现GDB能为你提供哪些有用的信息吗?

笔者尝试在 nemu 中输入指令 `x 10 0x0`。由于 riscv32 的地址从 0x80000000 开始，该命令在计算地址时会得到负数从而引发段错误。GDB 输出了以下信息：

```bash
Program received signal SIGSEGV, Segmentation fault.
0x0000555555562cfd in cmd_x ()
```

GDB 可以定位到引发段错误的函数 `cmd_x()`。

#### [二周目] 如何提高断点的效率

> 如果你在运行稍大一些的程序(如microbench)的时候使用断点, 你会发现设置断点之后会明显地降低NEMU执行程序的效率. 思考一下这是为什么? 有什么方法解决这个问题吗?

留坑。

#### 一点也不能长?

> x86的`int3`指令不带任何操作数, 操作码为1个字节, 因此指令的长度是1个字节. 这是必须的吗? 假设有一种x86体系结构的变种my-x86, 除了`int3`指令的长度变成了2个字节之外, 其余指令和x86相同. 在my-x86中, 上述文章中的断点机制还可以正常工作吗? 为什么

x86架构支持使用8位的 `int` 指令来实现中断，其中 `int3` 为CPU所有，专门用于 debugger 的中断。它的原理是将 `0xCC` 换到对应指令的第一个字节。这样 CPU 在读取指令时遇到 `0xCC` 就会暂停程序的执行。之所以使用单字的指令，是因为这样不论设置断点的指令是单字、双字还是四字，我们都可以在本条指令内部完成 `int3` 的标记，不会写到下一条指令中。

在本题中，如果使用2个字节的指令，则在对单字指令进行标记时会写到别的存储区域中，从而可能出错。

#### 随心所欲的断点

> 如果把断点设置在指令的非首字节(中间或末尾), 会发生什么? 你可以在GDB中尝试一下, 然后思考并解释其中的缘由.

笔者学习了如何在指定的地址添加断点。对于一个输出 hello world 的简单C程序，用 gdb 运行后设置断点 `b *main` ，运行暂停后输入命令 `disassemble`，可以看到

```bash
=> 0x0000555555555149 <+0>:        endbr64 
   0x000055555555514d <+4>:        push   %rbp
   0x000055555555514e <+5>:        mov    %rsp,%rbp
   0x0000555555555151 <+8>:        sub    $0x10,%rsp
   0x0000555555555155 <+12>:    movl   $0x1,-0xc(%rbp)
   0x000055555555515c <+19>:    movl   $0x2,-0x8(%rbp)
   0x0000555555555163 <+26>:    mov    -0xc(%rbp),%edx
   0x0000555555555166 <+29>:    mov    -0x8(%rbp),%eax
   0x0000555555555169 <+32>:    add    %edx,%eax
   0x000055555555516b <+34>:    mov    %eax,-0x4(%rbp)
   0x000055555555516e <+37>:    mov    -0x4(%rbp),%eax
   0x0000555555555171 <+40>:    mov    %eax,%esi
   0x0000555555555173 <+42>:    lea    0xe8a(%rip),%rdi        # 0x555555556004
   0x000055555555517a <+49>:    mov    $0x0,%eax
   0x000055555555517f <+54>:    call   0x555555555050 <printf@plt>
   0x0000555555555184 <+59>:    mov    $0x0,%eax
   0x0000555555555189 <+64>:    leave  
   0x000055555555518a <+65>:    ret
```

我们可以看到每条汇编指令的地址。笔者设置了断点 `b *main+55` ，该位置不在指令的首字节，继续运行后 GDB 没有检测到这个断点。笔者认为 GDB 检测断点的机制是每次取指译码时根据首字节是否是 0xCC 来判断是否有断点，因此将标志信息设置在非首字节是无法被识别的。

#### NEMU的前世今生

> 你已经对NEMU的工作方式有所了解了. 事实上在NEMU诞生之前, NEMU曾经有一段时间并不叫NEMU, 而是叫NDB(NJU Debugger), 后来由于某种原因才改名为NEMU. 如果你想知道这一段史前的秘密, 你首先需要了解这样一个问题: 模拟器(Emulator)和调试器(Debugger)有什么不同? 更具体地, 和NEMU相比, GDB到底是如何调试程序的?

留坑。笔者暂时认为调试器是可以接触底层的硬件和数据的，为程序员反馈信息的应用程序，NEMU 相当于内置了一个调试器的功能，其本身不只是应用程序，而是一整套虚拟机。

### 补充

#### 关于 `sscanf` 函数

笔者之前在处理指令中的常数时是通过一位一位读取并计算的方式来将其转换为 int 型的。在 RTFSC 的过程中发现 `sscanf` 函数可以简洁地实现这个功能。例如有 int 型变量 N，有存储着常数的字符串 arg，则可以通过 `sscanf(arg, "%d", &N)` 来将 arg 的内容转换成整数存进 N。

#### Address Sanitizer 实现 use-after-free 检测的原理

留坑。 

## 如何阅读手册

### 必答题

####  尝试通过目录定位关注的问题

> 假设你现在需要了解一个叫`selector`的概念, 请通过i386手册的目录确定你需要阅读手册中的哪些地方. 即使你选择的ISA并不是x86, 也可以尝试去查阅这个概念.

在 I386 手册的 5.1.3 节中可以找到和 selector 有关的内容。
