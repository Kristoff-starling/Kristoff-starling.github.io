---
title: "PA2 - 简单复杂的机器: 冯诺依曼计算机系统"
linktitle: 'PA2'
type: docs
draft: false
featured: false

math: true

menu:
    njuics-pa:
        parent: Contents
        weight: 3
---

## 实验进度

我完成了所有的必答题，并针对选做题和思考题给出了自己的想法。

## 必答题

### 程序是个状态机

点击[这里](#answer1)跳转到解答。

### RTFSC

点击[这里](#answer2)跳转到解答。

### 程序如何运行

点击[这里](#answer3)跳转到解答。

### 编译与链接

> 在`nemu/src/engine/interpreter/rtl-basic.h`中, 你会看到由`static inline`开头定义的各种RTL指令函数. 选择其中一个函数, 分别尝试去掉`static`, 去掉`inline`或去掉两者, 然后重新进行编译, 你可能会看到发生错误. 请分别解释为什么这些错误会发生/不发生? 你有办法证明你的想法吗?

如果去掉 inline，编译时会报错：`xxx defined but not used`。这是因为 `rtl.h` 文件 include 了 `rtl-basic.h` ，但并没有使用这个函数，因此触发了 `-Werror` 编译选项。

如果去掉 static，编译时不会报错。这是因为这里的函数被定义成了内联函数，函数内容被直接塞进了调用者的函数体中。如果我们用 `objdump -d` 命令去检查编译得到的汇编程序，我们会发现 `rtl_xx` 等一系列函数是不在其中的。

如果同时去掉 static 和 inline，编译时会报错：`multiple definition of xxx`。此时再查看汇编程序可以发现 `rtl_xx` 在其中。因为 `rtl_xx` 同时出现在了 `cpu-exec.o` `hostcall.o` 和 `decode.o` 中，所以链接时会出错。这里一个值得关注的细节是：我们编写的函数 `exec_addi` 调用了 `rtl_addi` ，但在汇编代码中并没有这一条调用。可以看到 `rtl_addi` 的内容被直接贴进了 `exec_addi` 的函数体中。这应该是编译器针对 addi 这种极其简短的函数调用做出的一种优化。

### 编译与链接2

> 1. 在`nemu/include/common.h`中添加一行`volatile static int dummy;` 然后重新编译NEMU. 请问重新编译后的NEMU含有多少个`dummy`变量的实体? 你是如何得到这个结果的?
> 2. 添加上题中的代码后, 再在`nemu/include/debug.h`中添加一行`volatile static int dummy;` 然后重新编译NEMU. 请问此时的NEMU含有多少个`dummy`变量的实体? 与上题中`dummy`变量实体数目进行比较, 并解释本题的结果.
> 3. 修改添加的代码, 为两处`dummy`变量进行初始化:`volatile static int dummy = 0;` 然后重新编译NEMU. 你发现了什么问题? 为什么之前没有出现这样的问题? (回答完本题后可以删除添加的代码.)

1. 笔者起初的做法是在 Makefile 中加入一些功能，使得在 make 可以将预编译的 `*.i` 文件同时输出到 `/build` 中，然后在 `/build` 中使用 `grep "volatile static int dummy" -r | wc -l` 命令统计个数，得到的答案是 33 个。

    但这个做法其实有一些问题，因为高级程序中定义的“变量”并不一定是实体，比如连续定义两个相同名字的未初始化全局变量，在符号表中只会出现一个。因此正确的方法应该是查看符号表。使用命令 `readelf --symbols $NEMU_HOME/build/riscv32-nemu-interpreter | grep "dummy" | wc -l` 命令，得到的结果是 33 个。

2. 此时 nemu 中仍然含有 33 个 dummy 变量的实体。这是因为 `common.h` 中 include 了 `dubug.h` ，且这是唯一一个 include `debug.h` 的地方，未初始化的相同名字的全局变量在符号表中只有一个实体。

3. 对变量进行初始化之后再编译，会报错：`redefinition of dummy`。这是因为赋了初值的全局变量会被认为是一个强符号。C 语言中不允许有两个相同的强符号被定义。而没有赋初值的变量是弱符号，语法上是可以重复定义的。

### 了解 Makefile

> 请描述你在`am-kernels/kernels/hello/`目录下敲入`make ARCH=$ISA-nemu` 后, `make`程序如何组织.c和.h文件, 最终生成可执行文件`am-kernels/kernels/hello/build/hello-$ISA-nemu.elf`. (这个问题包括两个方面:`Makefile`的工作方式和编译链接的过程.) 关于`Makefile`工作方式的提示:
>
> - `Makefile`中使用了变量, 包含文件等特性
> - `Makefile`运用并重写了一些implicit rules
> - 在`man make`中搜索`-n`选项, 也许会对你有帮助
> - RTFM

hello 中的 Makefile 内容比较简单：将 NAME 和 SRC 设置好，然后将 AM 中的 Makefile 全部贴进来。（虽然 AM 的 Makefile 相当复杂）

事实上 SRC 有非常多：AM 中几乎每个文件夹下都有 Makefile，把这个文件夹下的 .c 文件搜刮进 SRC 中。

按照正序，Makfile 大概做了如下一些大的事情：

* 在 `Makefile` 中有

    ```makefile
    $(DST_DIR)/%.o: %.c
    	@mkdir -p $(dir $@) && echo + CC $<
    	@$(CC) -std=gnu11 $(CFLAGS) -c -o $@ $(realpath $<)
    ```

    它会中所有的.c文件编译成.o文件放进目录DST_DIR中。这里DST_DIR是 AM 下的 build 目录。

* 在 `Makefile` 中有

    ```makefile
    $(LIBS): %:
    	@$(MAKE) -s -C $(AM_HOME)/$* archive
    ```

    它会把我们自己写的库函数（如 klib）打包成 archive。

* 在 `Makefile` 中有

    ```makefile
    $(IMAGE).elf: $(OBJS) am $(LIBS)
    	@echo + LD "->" $(IMAGE_REL).elf
    	@$(LD) $(LDFLAGS) -o $(IMAGE).elf --start-group $(LINKAGE) --end-group
    ```

    它会将所有的 .o 文件全部链接起来生成一个 .elf 文件。这里的 `$(OBJS)` 的生成方法不难：将 SRC 中所有的 .c 换成了 .o，加上相对应的路径前缀即可。

* 在 `nemu.mk` 中有

    ```makefile
    image: $(IMAGE).elf
    	@$(OBJDUMP) -d $(IMAGE).elf > $(IMAGE).txt
    	@echo + OBJCOPY "->" $(IMAGE_REL).bin
    	@$(OBJCOPY) -S --set-section-flags .bss=alloc,contents -O binary $(IMAGE).elf $(IMAGE).bin
    ```

    它使用 `OBJCOPY` 命令将 .elf 文件中的一些节做了修改，然后粘贴进了 .bin 文件中。

* 在 `nemu.mk` 中有

    ```makefile
    run: image
    	$(MAKE) -C $(NEMU_HOME) ISA=$(ISA) run ARGS="$(NEMUFLAGS)" IMG=$(IMAGE).bin
    ```

    它相当于在 `$NEMU_HOME` 目录下使用了命令 `make ISA=riscv32 run ARGS=... IMG=...`，这样就实现了将镜像加载到 nemu 上运行。

---

以下是我的自由报告内容，我在做实验的过程中详细记录了自己遇到的所有问题和查阅的所有资料。这些笔记按照章节排列，每章通常有两个部分：

* 思考题：包含笔者针对思考题查阅的资料和我尝试给出的答案。
* 补充：这里的内容是没有在讲义中提及的问题，以及讲义中建议自学的东西。

## 不停计算的机器

### 必答题

#### 理解YEMU如何执行程序 <a id=answer1></a>

> YEMU可以看成是一个简化版的NEMU, 它们的原理是相通的, 因此你需要理解YEMU是如何执行程序的. 具体地, 你需要
>
> - 画出在YEMU上执行的加法程序的状态机
> - 通过RTFSC理解YEMU如何执行一条指令
>
> 思考一下, 以上两者有什么联系?

我们定义一个状态为 (PC, R[0], R[1], M[7], halt)，则状态机为：

```
(0, x, x, 0, 0) -> (0, 33, x, 0, 0) -> (1, 33, x, 0, 0) -> (1, 33, 33, 0, 0) -> (2, 33, 33, 0, 0) -> (2, 16, 33, 0, 0) -> (3, 16, 33, 0, 0) -> (3, 49, 33, 0, 0) -> (4, 49, 33, 0, 0) -> (4, 49, 33, 49, 0) -> (5, 49, 33, 49, 0) -> (5, 49, 33, 49, 1)
```

YEMU 执行指令的流程为：

* 取指：将 $M[pc]$ 处的内容拿出来
* 译码：根据指令的各个字段判断指令到底想让计算机做什么
* 执行：位于 switch 代码段中，YEMU 支持的指令非常简单，只有寄存器赋值，加法，load/store 四种。
* 更新 PC

两者的联系在于：程序的两个状态之间的变化和指令的功能是一一对应的。

## RTFSC(2)

### 必答题

#### RTFSC 理解指令执行的过程<a id=answer2></a>

> 这一小节的细节非常多, 你可能需要多次阅读讲义和代码才能理解每一处细节. 根据往届学长学姐的反馈, 一种有效的理解方法是通过做笔记的方式来整理这些细节. 事实上, 配合GDB食用效果更佳.
>
> 为了避免你长时间对代码的理解没有任何进展, 我们就增加一道必答题吧:
>
> > 请整理一条指令在NEMU中的执行过程.
>
> 除了`nemu/src/device`和`nemu/src/isa/$ISA/system`之外, NEMU的其它代码你都已经有能力理解了. 因此不要觉得讲义中没有提到的文件就不需要看, 尝试尽可能地理解每一处细节吧! 在你遇到bug的时候, 这些细节就会成为帮助你调试的线索.

`fetch_decode_exec_updatepc()` 函数分成三个部分：`fetch_decode()` 负责取指译码，`s->EHelper(s)` 利用函数指针调用了译码后指令应该执行的函数。`cpu->pc=s->dnpc` 将 pc 指向下一条指令。

##### 取指

`fetch_decode()` 调用了 `isa_fetch_decode()`。`isa_fetch_decode` 会调用 `instr_fetch()` 把指令从内存中取出来。`instr_fetch(*pc, len)` 的更深内容和物理内存读写有关，此处不深究。特别的一点是它取出指令后会根据 len 更新 pc 的值（指向下一条指令）。

##### 译码

`isa_fetch_decode()` 将 `instr_fetch()` 的返回结果存储到 `s->instr.val` 中。`s` 是一个 `Decode` 结构体类型，其中的 `instr` 是 `ISADecodeInfo` 类型。

> 这里有一个有趣的代码细节是 nemu 为了抽象化不同 ISA 的差异，在顶层的代码中使用的是相同的类型名称，这些名称在底层才会分出区别，例如 `ISADecodeInfo` 类型的定义是
>
> ```c
> typedef concat(__GUEST_ISA__, _ISADecodeInfo) ISADecodeInfo;
> ```
>
> `concat` 函数的功能是将两个字符串拼接起来，从而实现了根据选择的 ISA 的不同定义不同的 `ISADecodeInfo`，将 ISA 的差异对上层抽象了。

在本实验中 `instr` 自然是 `riscv32_ISADecodeInfo` 类型。该类型的定义可以在 `isa-def.h` 中查到，这是一个 union，给 `instr.val` 赋值之后，我们可以通过调用 union 中的各个变量来轻松获得指令的各个部分。

nemu 调用了 `table_main` 函数来进行指令类型的确认，所有的 table 函数可以被看做一个巨大的 switch-case。这里面有两种类型的宏：

```c
def_INSTR_IDTAB("??????? ????? ????? ??? ????? xxxxx xx", I/U/S/J/B/R     , xxx);
def_INSTR_TAB("??????? ????? ????? ??? ????? xxxxx xx", xxx)
```

第一种和第二种的区别在于第一种还会按照传送的指令类型对指令的寄存器和立即数进行解析。这种宏会返回一个执行函数的编号。类型确认的过程无非是一些位运算，这里主要再看寄存器和立即数的解析：

为了进一步实现指令译码和操作数译码的解耦，nemu 还定义了译码操作数辅助函数，专门用于对立即数或寄存器进行译码。s 中有三个 Operand 类型的变量。Operand 类型的变量中有一个 union，分别是指向寄存器的指针，带符号立即数和无符号立即数，代表了寄存器类型/有符号立即数/无符号立即数。针对立即数的译码操作数辅助函数很简单，只要将值赋给 imm 即可。针对寄存器的则略微复杂一些：为了实现 riscv 中零号寄存器永远为0、不可写的特性，译码操作数辅助函数会对操作的读/写，和目标进行判断，以确保不会修改零号寄存器的内容 (is_write 参数只在寄存器中才会有作用）。

所有的译码辅助函数都是可以通过调用译码操作数辅助函数来高效完成。这部分和手册可以形成高度的对应。

##### 执行

在 cpu-exec 中执行的代码很简单：就是调用 s 中存好的执行函数。形如 `exec_xxx` 的执行函数都是通过更加基本的 rtl 指令来实现功能。rtl 指令大多是调用了基于 c 语言的表达式运算来实现功能，少数的跳转指令稍微复杂一些。

##### 更新 pc

将 `s->dnpc` 赋给 `s`，这里要注意 `dnpc` 和 `snpc` 的区别：`snpc` 仅仅指内存中该条指令的下一条指令（pc+4）位置，而 `dnpc` 保存了下一条真正要执行的指令的位置。在一些跳转指令中 `snpc` 和 `dnpc` 不一定相同。

### 思考题

#### 立即数背后的故事

> 框架代码通过`instr_fetch()`函数进行取指, 别看这里就这么一行代码, 其实背后隐藏着针对字节序的慎重考虑. 大部分同学的主机都是x86小端机, 当你使用高级语言或者汇编语言写了一个32位常数`0x1234`的时候, 在生成的二进制代码中, 这个常数对应的字节序列如下(假设这个常数在内存中的起始地址是x):
>
> ```
> x   x+1  x+2  x+3
> +----+----+----+----+
> | 34 | 12 | 00 | 00 |
> +----+----+----+----+
> ```
>
> 而大多数PC机都是小端架构(我们相信没有同学会使用IBM大型机来做PA), 当NEMU运行的时候,
>
> ```c
> imm = instr_fetch(pc, 4);
> ```
>
> 这行代码会将`34 12 00 00`这个字节序列原封不动地从内存读入`imm`变量中, 主机的CPU会按照小端方式来解释这一字节序列, 于是会得到`0x1234`, 符合我们的预期结果.
>
> Motorola 68k系列的处理器都是大端架构的. 现在问题来了, 考虑以下两种情况:
>
> - 假设我们需要将NEMU运行在Motorola 68k的机器上(把NEMU的源代码编译成Motorola 68k的机器码)
> - 假设我们需要把Motorola 68k作为一个新的ISA加入到NEMU中
>
> 在这两种情况下, 你需要注意些什么问题? 为什么会产生这些问题? 怎么解决它们?
>
> 事实上不仅仅是立即数的访问, 长度大于1字节的内存访问都需要考虑类似的问题. 我们在这里把问题统一抛出来, 以后就不再单独讨论了.

如果我们要将 NEMU 运行在 Motorola 68k 机器上，那么我们访问内存的指令就不能像现在这样将连续4个字节直接读入变量，因为 Motorola 68k 会按照大端方式来读取这4个字节。我们需要自己手写一个循环来按照小端方式处理数据。

如果我们要在 NEMU 中加入 Motorola 68k 的 ISA，那么相似地，我们不能将连续4个字节直接读入变量，而是要手写一个循环按照大端方式处理数据。

#### 立即数背后的故事(2)

> mips32和riscv32的指令长度只有32位, 因此它们不能像x86那样, 把C代码中的32位常数直接编码到一条指令中. 思考一下, mips32和riscv32应该如何解决这个问题?

可以设置两种加载立即数的指令：一种向高位加载，一种向低位加载。riscv32 中的 lui 指令可以实现向高位加载立即数的功能。mips指令集由于没有接触过，暂时留坑。

#### 为什么不需要 `rtl_muls_lo`

> 我们没有定义用于获取有符号数乘法结果低32位的RTL基本指令`rtl_muls_lo`, 你知道为什么吗?

`rtl_muls_lo` 所需实现的功能与 `rtl_mulu_lo` 完全相同，本着不要让多个函数做同一件事情的原则，我们不需要 `rtl_muls_lo`。但有符号和无符号在高位的表现是不同的，因此两种 hi 我们都需要。

#### RTL寄存器中值的生存期

> 在程序设计课上, 我们知道C语言中不同的变量有不同的生存期: 有的变量的值会一直持续到程序结束, 但有的变量却很快消亡. 在上述定义的RTL寄存器中, 其实也有不同的生存期. 尝试根据生存期给RTL寄存器分类.
>
> 尽管目前这个分类结果并没有什么用处, 但其实将来在PA5中设计RTL优化方案的时候, 生存期的性质会给我们提供很大的优化机会.

留坑，二周目再做。

#### 为什么执行了未实现指令会出现上述报错信息

> RTFSC, 理解执行未实现指令的时候, NEMU具体会怎么做.

在执行了未实现的指令时，译码的过程中无法匹配到任何一种 pattern，最终会返回一个 `EXEC_ID_inv` 宏，即不合法指令对应的执行函数的编号。这里的宏利用元编程和 enum 的方法写出了一种鲁棒性很强的代码，即使不断添加新指令也可以使得 `EXEC_ID_inv` 代表的编号是正确的。

拿到 `EXEC_ID_inv` 后，执行函数赋为 `g[idx]`。在执行 `g[idx]` 时，执行的是 `exec_inv`，`exec_inv()` 函数调用了 `rtl_hostcall` 函数，并传入了 `HOSTCALL_INV` 参数（与正常退出的 `HOSTCALL_EXIT` 区分）。`rtl_hostcall` 函数接收到 `HOSTCALL_INV` 参数时，便会打印上述的报错信息。

## 程序，运行时环境与AM

### 思考题

#### 这又能怎么样呢

> 思考一下, 这样的抽象还会带来哪些好处呢? 你很快就会体会到这些好处了.

这样的抽象有利于代码的移植：你甚至可以把别人的上层代码拿来直接用，即使你们使用不同的语言做了 nemu，只要 API 接口统一，上层的操作系统和用户程序就可以调用 API 直接运行。

#### [二周目]为什么要有AM？

> 操作系统也有自己的运行时环境. AM和操作系统提供的运行时环境有什么不同呢? 为什么会有这些不同?

留坑。笔者暂时认为 AM 中的运行时环境更多是对硬件功能的直接抽象：比如可以访问外设，可以读写内存等。而操作系统中的运行时环境抽象层次更高，比如系统调用等等，是对 AM 运行时环境的进一步封装。之所以不同是因为他们所处的抽象层不同，服务的对象也不同。操作系统向应用程序暴露 API，自然不需要让应用程序知道硬件细节。AM 的运行时环境可以让操作系统更好地利用已有的硬件功能，可以做到架构和OS的解耦。

#### mips32的分支延迟槽

> 为了提升处理器的性能, mips使用了一种叫分支延迟槽的技术. 采用这种技术之后, 程序的执行顺序会发生一些改变: 我们把紧跟在跳转指令(包括有条件和无条件)之后的静态指令称为延迟槽, 那么程序在执行完跳转指令后, 会先执行延迟槽中的指令, 再执行位于跳转目标的指令. 例如
>
> ```
> 100: beq 200
> 101: add
> 102: xor
> ...
> 200: sub
> 201: j   102
> 202: slt
> ```
>
> 若`beq`指令的执行结果为跳转, 则相应的动态指令流为`100 -> 101 -> 200`; 若`beq`指令的执行结果为不跳转, 则相应的动态指令流为`100 -> 101 -> 102`; 而对于`j`指令, 相应的动态指令流为`201 -> 202 -> 102`.
>
> 你一定会对这种反直觉的技术如何提升处理器性能而感到疑惑. 不过这需要你先了解一些微结构的知识, 例如处理器流水线, 但这已经超出了ICS的课程范围了, 所以我们也不详细解释了, 感兴趣的话可以STFW.
>
> 但我们可以知道, 延迟槽技术需要软硬件协同才能正确工作: mips手册中描述了这一约定, 处理器设计者按照这一约定设计处理器, 而编译器开发者则会让编译器负责在延迟槽中放置一条有意义的指令, 使得无论是否跳转, 按照这一约定的执行顺序都能得到正确的执行结果.
>
> 如果你是编译器开发者, 你将会如何寻找合适的指令放到延迟槽中呢?

流水线CPU中如果分支预测失败，常见的做法是对各个流水段进行冲刷，然后将应该跳转到的PC送入流水线继续执行。flush 是一个代价很大的操作，会使流水线浪费很多个时钟周期，因此我们有两个方向可以努力：一个是尽可能减少 flush 的次数，也就是提高分支预测的成功率（动态分支预测 etc.），另一个是使流水线中执行的指令即使在分支预测错误的时候也可以保留，这就是mips中的延迟槽。

至于分支延迟槽中应该放什么指令，最简单的自然是插入nop指令。这样正确性无疑可以得到保证，但性能不高：不论分支预测是否成功，执行这条nop指令都相当于没做事情，可以理解为流水线被阻塞了。

以下是笔者的一些猜想：如果跳转和不跳转的接下来的几条指令中有完全相同的指令，自然可以将这条指令放到延迟槽中。这样不论走了哪个分支这条指令的执行都是有用的。当然，能否调整指令的顺序取决于指令之间的依赖关系。不过完全相同的指令很难找，我们可以利用寄存器的重命名技术，现将某条指令的结果放到一个备用的内存空间中，如果将来走这条分支，就将对应的寄存器名映射到这个地址上。

#### 指令名对照

> AT&T格式反汇编结果中的少量指令, 与手册中列出的指令名称不符, 如x86的`cltd`, mips32和riscv32则有不少伪指令(pseudo instruction). 除了STFW之外, 你有办法在手册中找到对应的指令吗? 如果有的话, 为什么这个办法是有效的呢?

笔者使用的一个方法是：直接将这条伪指令对应的机器代码二进制串放进手册里搜索。因为伪指令实际上也是通过普通指令完成功能的，所以可以搜索到对应的普通指令，从而确定伪指令的行为。

#### stdarg是如何实现的?

> `stdarg.h`中包含一些获取函数调用参数的宏, 它们可以看做是调用约定中关于参数传递方式的抽象. 不同ISA的ABI规范会定义不同的函数参数传递方式, 如果让你来实现这些宏, 你会如何实现?

笔者并没有去看 `stdarg.h` 的源码，但笔者用过宏 `__VA_ARGS__`，认为它背后的实现方式应该是一个链表，链表中的每个元素包含了参数的名称和参数指向的地址。

### 补充

#### 关于 riscv 的 jalr 指令

笔者在实现 jalr 指令的时候犯了一些错误，这个错误直到 PA3 才暴露出来，在此特地记录。jalr 指令的行为在手册中的定义如下：

```c
t=pc+4; pc=(x[rs1]+sext(offset))&~1; x[rd]=t
```

笔者起初认为这样的写法非常麻烦：为什么不把 pc+4 的值直接赋给 x[rd] ，而要搞出这么一个中间变量 t 呢？事实上这是因为指令中 rs1 和 rd 可能是一样的，如果在第一条指令就直接修改了 x[rd]，就可能也修改了 x[rs1]，从而第二条指令的结果就不对了。因此中间变量 t 的设置绝非是画蛇添足。

ISA 的手册经过了很多人的打磨，是非常简练的。每一条看似无用的语句一定都是充分考虑到了一些特殊情况无法删除才呈现在手册中的。因此最简单的保证正确的实现方法就是：**手册说什么你就写什么**。

## 基础设施(2)

### 思考题

#### 消失的符号

> 我们在`am-kernels/tests/cpu-tests/tests/add.c`中定义了宏`NR_DATA`, 同时也在`add()`函数中定义了局部变量`c`和形参`a`, `b`, 但你会发现在符号表中找不到和它们对应的表项, 为什么会这样? 思考一下, 什么才算是一个符号(symbol)?

宏只是做了简单的字符串替换，在预处理阶段就会处理掉，显然不会进入符号表。局部变量和形式参数都是在栈上定义的，所以不在符号表中。只有全局变量、函数、静态全局变量、只读字符串等才会出现在符号表中。

#### 寻找"Hello World!"

> 在Linux下编写一个Hello World程序, 编译后通过上述方法找到ELF文件的字符串表, 你发现"Hello World!"字符串在字符串表中的什么位置? 为什么会这样?

笔者先用命令 `hd a.out` 查看二进制文件并找到了 "Hello, World\n" 字符串在文件中的偏移量，然后用 `readelf -a a.out` 命令查看了所有节，发现该字符串在只读数据节中。之所以在只读代码节中是因为这个字符串是理论上不应该被修改的。

#### 不匹配的函数调用和返回

> 如果你仔细观察上文`recursion`的示例输出, 你会发现一些有趣的现象. 具体地, 注释(1)处的`ret`的函数是和对应的`call`匹配的, 也就是说, `call`调用了`f2`, 而与之对应的`ret`也是从`f2`返回; 但注释(2)所指示的一组`call`和`ret`的情况却有所不同, `call`调用了`f1`, 但却从`f0`返回; 注释(3)所指示的一组`call`和`ret`也出现了类似的现象, `call`调用了`f1`, 但却从`f3`返回.
>
> 尝试结合反汇编结果, 分析为什么会出现这一现象.

这是一个非常有意思的问题，我们以注释(2)处的代码为例分析这一情况：

注释(2)处显示，函数 `f2` 中调用了 `f1` ，但没有从 `f1` 返回而是从 `f0` 返回的。使用 nemu 追踪 CPU 是如何从 `f1` 悄悄跳到 `f0` 的，发现了 `f1` 结尾处的如下汇编代码：

```assembly
80000090:	00158593          	addi	a1,a1,1
80000094:	fff50513          	addi	a0,a0,-1
80000098:	00078067          	jr	a5
8000009c:	00100513          	li	a0,1
800000a0:	00008067          	ret
```

`f1` 的 C 语言原文如下：

```c
int f1(int n, int l) {
  if (l > lvl) lvl = l;
  rec ++;
  return n <= 0 ? 1 : func[0](n - 1, l + 1);
};
```

正是位于地址 0x80000098 处的指令 `jr a5` 从 `f1` 跳转到了 `f0`，也就是说其实我们的 ftrace 追踪漏了一次调用。这一跳转指令之所以会在追踪中被遗漏是因为它不符合标准的跳转指令的形式：标准的跳转指令一般都是 `jal` 或 `jalr` 指令，且存储 snpc 的寄存器按照 calling convention 应为 `ra`，以方便 return 回来以后从跳转指令的下一条开始继续执行。这里使用 `jr a5` 直接跳转，会导致从 `f0` 返回后其实没有回到 `f1`。

这里之所以出现这样的情况是因为编译器对**尾调用**进行了优化。因为 `f1` 调用 `f0` 在 `f1` 的函数末尾，所以执行完  `f0` 返回之后 `f1` 会立即拿着 `f0` 的返回值再返回给 `f2`，所以不妨让 `f0` 直接返回 `f2`。这个优化在尾递归中会格外有用，不仅省去了一些指令，还可以重复利用栈帧，使得层数很深的尾递归也不会爆栈。

#### 冗余的符号表

> 在Linux下编写一个Hello World程序, 然后使用`strip`命令丢弃可执行文件中的符号表:
>
> ```bash
> gcc -o hello hello.c
> strip -s hello
> ```
>
> 用`readelf`查看hello的信息, 你会发现符号表被丢弃了, 此时的hello程序能成功运行吗?
>
> 目标文件中也有符号表, 我们同样可以丢弃它:
>
> ```bash
> gcc -c hello.c
> strip -s hello.o
> ```
>
> 用`readelf`查看hello.o的信息, 你会发现符号表被丢弃了. 尝试对hello.o进行链接:
>
> ```bash
> gcc -o hello hello.o
> ```
>
> 你发现了什么问题? 尝试对比上述两种情况, 并分析其中的原因.

第一种情况丢弃了符号表之后仍然可以正常运行，第二种情况丢弃了符号表后会报错：

```bash
/usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/10/../../../x86_64-linux-gnu/Scrt1.o: in function `_start':
(.text+0x24): undefined reference to `main'
```

因为符号表被删除了，无法找到 main 函数的位置，所以链接失败。符号表的作用就是在链接的时候告诉外部模块本模块的各个函数、变量的地址，在已经生成好的可执行文件中，所有重定位已经完成，自然不再需要符号表；但如果在可重定位文件中删去了符号表，链接则会出问题。

#### 如何生成 native 的可执行文件

> 阅读相关Makefile, 尝试理解`abstract-machine`是如何生成`native`的可执行文件的.

Makefile 中有一个变量 `CROSS_COMPILE`，在 native 下运行的时候这个变量没有赋值，所以 Makefile 不会使用交叉编译工具编译代码，而是用 native 的 gcc 和 binutils。

#### 奇怪的错误码

> 为什么错误码是`1`呢? 你知道`make`程序是如何得到这个错误码的吗?

如果 main 函数正常退出，返回值会是0，否则返回值是1。`make` 程序捕捉 main 函数的返回值，并据此判断是否发生了错误，并将错误码呈现出来。

#### 这是如何实现的？

> 为什么定义宏`__NATIVE_USE_KLIB__`之后就可以把`native`上的这些库函数链接到klib? 这具体是如何发生的? 尝试根据你在课堂上学习的链接相关的知识解释这一现象.

klib 中编写的所有库函数都被条件编译 ifdef 框了起来，参与编译的条件为 `!defined(__ISA_NATIVE__) || defined(__NATIVE_USE_KLIB))`。如果 `NATIVE_USE_KLIB` 被注释了的话，在 native 下运行就不会有手写的库函数，native 会使用 glibc 的库函数。如果 `NATIVE_USE_KLIB` 没有被注释，在 native 下运行有手写的库函数，当手写函数与 glibc 库函数名称冲突时，优先链接用户手写的函数，这样就达到了使用 klib 的效果。

#### 匪夷所思的QEMU行为(有点难度)

> 在一些旧版的mips32-QEMU中, 仅在上述指令的PC值后12位为`0xffc`时, 才会进行指令打包. 这个打包条件看上去非常奇怪, 你知道可能的原因是什么吗?

笔者没有使用 QEMU 进行 difftest，也不了解 mips 指令集，故留坑。

#### 捕捉死循环(有点难度)

> NEMU除了作为模拟器之外, 还具有简单的调试功能, 可以设置断点, 查看程序状态. 如果让你为NEMU添加如下功能
>
> > 当用户程序陷入死循环时, 让用户程序暂停下来, 并输出相应的提示信息
>
> 你觉得应该如何实现? 如果你感到疑惑, 在互联网上搜索相关信息.

从理论上证明某个程序会死循环是不可能的，因为这涉及到图灵停机问题：比如我写一个 check 哥德巴赫猜想的程序，如果我能判断它是否会死循环，我就证明了哥德巴赫猜想。

笔者结合了网上的资料并自己思考了之后认为可以有如下的一些捕捉方法：

* 在一个进程运行的同时用另一个进程来监视它的行为，如果该进程耗时过长就将其 kill。
* 死循环主要来自 do-while 和 for 循环。虽然无限递归从理论上也会死循环，但硬件的限制会使其通过爆栈的方式停下来。因此可以在编译是找到所有的 do-while 和 for 循环，向其中加入计数器，在循环执行次数超过了一个阈值后强行退出。

### 补充

#### 关于 Difftest

笔者刚开始无法通过 spike 的 difftest，查看寄存器状态发现 `t0` 寄存器的值不正确。产生这个问题的原因是笔者在实现 jal/jalr 指令时使用了 `t0` 寄存器保存中间结果——这一行为虽然符合讲义中的调用约定，但由于 spike 没有相同的行为，所以报错了。事实上我们写的 nemu 并不是真正的“硬件”：我们根本不需要真的用寄存器来保存中间结果——我们有 C 语言，定义一个变量保存就可以了！框架代码中给的 `rtl_j` 函数似乎也使用了类似的手法（笔者没有调用框架代码给的 `rtl_j` 来实现跳转指令）

## 输入输出

### 必答题

#### 游戏是如何运行的<a id=answer3></a>

> 请你以打字小游戏为例, 结合"程序在计算机上运行"的两个视角, 来剖析打字小游戏究竟是如何在计算机上运行的. 具体地, 当你按下一个字母并命中的时候, 整个计算机系统(NEMU, ISA, AM, 运行时环境, 程序) 是如何协同工作, 从而让打字小游戏实现出"命中"的游戏效果?

在主循环之间，打字小游戏做了一些绘制屏幕方面的准备工作。这些工作在 `vedio_init` 中，具体为

* 读取窗口的宽和高。程序读取窗口大小通过读取 AM 提供的 `AM_GPU_CONFIG` 抽象寄存器实现。`AM_GPU_CONFIG` 抽象寄存器则通过访问 nemu 提供的 I/O 端口来获得这些参数。
* 将整个画布涂成紫色的。程序向画布输出颜色通过向 AM 提供的 `AM_GPU_FBDRAW` 抽象寄存器写入内容来实现。抽象寄存器会接收到开始绘制的位置的坐标，绘制内容数量，绘制的内容的 buffer，和一个是否立即同步的布尔变量。抽象寄存器的行为很简单，就是将对应的数据写到 nemu 的 I/O 端口中。nemu 的硬件会每隔一段时间检查是否有同步信号，如果有就将缓冲区的内容输出到屏幕上。
* 对各种字母的颜色做好设定。

打字小游戏的主循环是一个 `while(1) {}` ，在循环中会做这样一些事情：

* `game_logic_update`：每次循环中都会根据和上次更新的时间差进行若干次游戏逻辑更新。这里程序调用时间函数会使用 AM 提供的抽象寄存器 `AM_TIMER_UPTIME` 来读取游戏已经开始的时间。AM中读取这个抽象寄存器的逻辑是访问 nemu 的时钟 I/O 端口。

    游戏逻辑更新中会定期生成一个新的字母，并且将每个字母根据其信息更新位置。关于字母，每个字母有如下一些参数：

    * `ch`：表示这个字母是啥，可以取 `A-Z`。
    * `(x,y)`：表示字母当前的位置。`x` 值是生成字母的时候随机的，`y` 值则会根据当前的时间不断更新。
    * `v`：表示字母单位时间移动的速度。正常情况下速度是正数，字母会往下落。当字母被击中的时候速度会变成负数，从而实现字母向上升的效果。如果速度为0，表示当前字母 miss 了。
    * `t`：这是一个计时器，用于当一个字母 miss 的时候，延迟 FPS 的时间后才会消失。

* 键盘读取：除非读取到 `AM_KEY_NONE` 表示当前没有按键，否则程序会一直在键盘读取的 while 循环中。这里程序收集键盘按键会使用 AM 提供的抽象寄存器 `AM_INPUT_KEYBRD`。`AM_INPUT_KEYBRD` 会访问 nemu 的键盘 I/O 端口，并根据得到的数据生成 keydown 和 keycode 两个参数。

    键盘读取分为以下两种情况：
    
    * 按下了 escape 键：调用 `halt(0)`，退出。
    * 按下了是字母的键：调用 `check_hit` 函数检查是否确实击中了字母。`check_hit` 的行为比较简单：如果没有匹配到任何一个字母则更新 wrong，否则会将击中的字母的速度改成一个负值，从而一面实现字母被击中的标记，一面实现字母向上升的效果。
    
* `render` ：这个函数负责更新屏幕。该函数会将字母原本所处位置的屏幕内容抹去（变成紫色），然后根据字母新的位置以及字母当前的状态（下落白色，miss红色，击中绿色）选择相应的 texture 作为 buffer 输出到对应位置。

### 思考题

#### 理解 volatile 关键字

> 也许你从来都没听说过C语言中有`volatile`这个关键字, 但它从C语言诞生开始就一直存在. `volatile`关键字的作用十分特别, 它的作用是避免编译器对相应代码进行优化. 你应该动手体会一下`volatile`的作用, 在GNU/Linux下编写以下代码:
>
> ```c
> void fun() {
>   extern unsigned char _end;  // _end是什么?
>   volatile unsigned char *p = &_end;
>   *p = 0;
>   while(*p != 0xff);
>   *p = 0x33;
>   *p = 0x34;
>   *p = 0x86;
> }
> ```
>
> 然后使用`-O2`编译代码. 尝试去掉代码中的`volatile`关键字, 重新使用`-O2`编译, 并对比去掉`volatile`前后反汇编结果的不同.
>
> 你或许会感到疑惑, 代码优化不是一件好事情吗? 为什么会有`volatile`这种奇葩的存在? 思考一下, 如果代码中`p`指向的地址最终被映射到一个设备寄存器, 去掉`volatile`可能会带来什么问题?

`_end` 是一个变量，它的地址指向了数据段的第一个未使用的位置。

在有 `volatile` 关键字的情况下，反汇编结果为：

```assembly
0000000000000000 <fun>:
   0:	f3 0f 1e fa          	endbr64 
   4:	c6 05 00 00 00 00 00 	movb   $0x0,0x0(%rip)        # b <fun+0xb>
   b:	48 8d 15 00 00 00 00 	lea    0x0(%rip),%rdx        # 12 <fun+0x12>
  12:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  18:	0f b6 02             	movzbl (%rdx),%eax
  1b:	3c ff                	cmp    $0xff,%al
  1d:	75 f9                	jne    18 <fun+0x18>
  1f:	c6 05 00 00 00 00 33 	movb   $0x33,0x0(%rip)        # 26 <fun+0x26>
  26:	c6 05 00 00 00 00 34 	movb   $0x34,0x0(%rip)        # 2d <fun+0x2d>
  2d:	c6 05 00 00 00 00 86 	movb   $0x86,0x0(%rip)        # 34 <fun+0x34>
  34:	c3                   	ret
```

可以看到这段指令和 C 语言程序的功能基本是一一对应的。

在没有 `volatile` 关键字的情况下，反汇编结果为：

```assembly
0000000000000000 <fun>:
   0:	f3 0f 1e fa          	endbr64 
   4:	c6 05 00 00 00 00 00 	movb   $0x0,0x0(%rip)        # b <fun+0xb>
   b:	eb fe                	jmp    b <fun+0xb>
```

指令发生了很大的变化。编译器发现 `*p=0` 之后进入了一个只有 `*p=0xff` 才会退出的循环，这期间没有任何对 p 的更改，所以认为这是一个死循环，直接将其缩减为了 `jmp b` ，并且砍掉了后面的所有内容。

如果 p 指向的地址被映射到了一个设备寄存器，那么原本这个程序的功能可能是正确的：当检测到设备寄存器的值变为 0xff 后，依次向设备寄存器写入 0x33, 0x34 和 0x86。但编译优化之后，这个程序就完全变成了一个死循环。因此我们并不是什么时候都希望激进的编译优化：编译器有可能考虑不到外设的参与等情况。

#### 如何检测多个键同时被按下?

> 在游戏中, 很多时候需要判断玩家是否同时按下了多个键, 例如RPG游戏中的八方向行走, 格斗游戏中的组合招式等等. 根据键盘码的特性, 你知道这些功能是如何实现的吗?

键盘码是一个8位二进制数，如果我们用32位整数来传递键盘码，就可以同时传递4个，可以用于检测多个键同时按下。

#### 神奇的调色板

> 现代的显示器一般都支持24位的颜色(R, G, B各占8个bit, 共有`2^8*2^8*2^8`约1600万种颜色), 为了让屏幕显示不同的颜色成为可能, 在8位颜色深度时会使用调色板的概念. 调色板是一个颜色信息的数组, 每一个元素占4个字节, 分别代表R(red), G(green), B(blue), A(alpha)的值. 引入了调色板的概念之后, 一个像素存储的就不再是颜色的信息, 而是一个调色板的索引: 具体来说, 要得到一个像素的颜色信息, 就要把它的值当作下标, 在调色板这个数组中做下标运算, 取出相应的颜色信息. 因此, 只要使用不同的调色板, 就可以在不同的时刻使用不同的256种颜色了.
>
> 在一些90年代的游戏中(比如仙剑奇侠传), 很多渐出渐入效果都是通过调色板实现的, 聪明的你知道其中的玄机吗?

在保持颜色索引不变的情况下，只要平滑地切换调色板就可以实现渐变。如果准备多套调色板，事实上我们可以使用远不止256种颜色。

#### LiteNES 如何工作？

> 另一个值得RTFSC的项目是LiteNES, 除了内置rom之外, 代码总数大约1500行. 关键是这个小巧玲珑的项目里面已经包含了一个完整的计算机系统: CPU, 内存, MMIO, 以及手柄(psg), 卡带(mmc)和图形处理器(ppu)这三个外设. 除了ppu的内部实现细节之外, 其余的部分你都已经有能力去理解了.
>
> 有趣的是, LiteNES可以看成是NEMU和AM程序的融合. 尝试阅读LiteNES的代码, 理解LiteNES作为一个完整的计算机系统, 上述部件如何交互, 以及LiteNES作为一个AM程序, 如何通过AM提供的API来实现游戏效果. 我们提供[6502处理器(NES的CPU)](https://wiki.nesdev.com/w/index.php/CPU)以及[NES PPU(图形处理器)](https://wiki.nesdev.com/w/index.php/PPU)的资料供大家参考.

留坑。

### 补充

#### 关于串口背后的原理

>  `putch` 仅仅执行了 `outb(SERIAL_PORT,ch)`，而 `outb(SERIAL_PORT,ch)` 仅仅将 *SERIAL_PORT 的值赋成了 ch，为什么就能同时通过标准错误流把信息输出在屏幕上呢？

我们需要深入到汇编层面理解这段代码，`putch` 编译成汇编代码后仅有三句话：

```assembly
lui a5, 0xa0000
sb a0, 1016(a5)
ret
```

第一句话装载立即数，结合第二句的 1016(a5) 定位到 SERIAL_PORT 指向的地址，第二句话就是真正的写入函数。虽然看上去仅仅是 store，但向 I/O 设备的 store 行为是更丰富的，在 nemu 中它会走过这样的流程：

* 取指译码之后获取所有的信息，并分配好一个存储相关的执行函数。
* 运行执行函数，store 的执行函数会调用 `paddr_write`。
* `paddr_write` 分析了一下要写入的地址，发现并不在内存中，而是在 I/O 区域，于是调用了 `mmio_write`。
* `mmio_write` 分析了一下要写入的地址，发现是串口的地址，于是调用了 `map_write` ，并把串口的 IOMap 传了过去。
* `map_write` 做了一些正确性检查之后，先调用了 `host_write` ，将 ch 这个数据写到了 SERIAL_PORT 地址，然后调用了串口的回调函数。
* 串口的回调函数是 `serial_io_handler` ，串口的回调函数默认是输出，否则会报错，在 `is_write==true` 的情况下回调函数会调用 `serial_putc`。
* `serial_putc` 使用了 glibc 中的 `putc(ch,stderr)` 将字符输出到了标准错误流。

因此事实上虽然从高级语言层面 `putch` 中只有一个存储指令，但在汇编层面它既完成了存储又完成了输出。符合串口的 feature。

##### 疑问

如果 nemu 所有向屏幕输出的函数最终都是通过 putch 来实现，那么按理来说只需要申请一个字节大小的串口空间就可以了，为什么要 8 个字节呢？

#### 关于时钟硬件接口

框架代码中有一个小细节：只有在读取时钟的高32位的时候才会触发 nemu 重新读取当前时间。这意味着如果需要读取时间，一定要先读取高32位再读取低32位，顺序反过来就会出错。这样有一个好处：因为两次读取总是有时间差的，所以这样可以保证高32位和低32位来自同一个时刻。

#### 声卡

笔者完成了声卡的选做题。声卡的 I/O 相较于其他的会复杂一些，因为 nemu 的硬件部分的代码也需要自己实现。nemu 不是真正的“硬件”，要实现音频的输出还是得靠库函数。这里笔者根据讲义使用了 SDL 库。

我们需要在 AM 中实现以下函数：

* `__am_audio_config`：读取声卡的状态，包括是否存在声卡 (cfg->present)。
* `__am_audio_ctrl`：告诉硬件一些基本的信息，如频率，频道，采样率等等。
* `__am_audio_status`：读取缓冲区中还有的数据字节数。
* `__am_audio_play`：向声卡的缓冲区写入数据。如果声卡的缓冲区不够，则应该轮询，直到缓冲区大小足够位置。

我们需要在 nemu 中做这样一些事情：

* 在 audio 的回调函数 `audio_io_handler` 中完成初始化，包括向 `SDL_AudioSpec` 类型的变量中填写频率、频道、采样率，注册一个回调函数 `audio_callback()`，以及调用 `SDL_InitSubSystem` 和 `SDL_OpenAudio`  函数等。
* 完成 audio-sbuf 的回调函数 `audio_sbuf_handler` ，主要工作就是把 AM 送过来的数据放入缓冲队列。
* 完成 `audio_callback()`，SDL 会不定时索要一定量的数据，从当前缓冲区的队列头部取数据给 SDL。如果当前所剩数据量不够，应该再补充一些 0，以防出现噪音。
